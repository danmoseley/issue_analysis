[
    {
        "url":  "https://github.com/dotnet/runtime/issues/4574",
        "createdAt":  "2015-10-13T12:21:27Z",
        "number":  4574,
        "author":  "GSPP",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCzTj5g==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "theodorzoulias",
                                            "createdAt":  "2023-10-15T23:49:16Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2023-09-25T00:16:06Z",
        "body":  "Reopening [this ticket](https://github.com/dotnet/corefx/issues/2329) here per the suggestion of ericeil.\n\nAs of .NET 4.5 the thread pool injects one thread per 0.5sec if it thinks more threads are required. This is a problem if the number of required threads suddenly increases. Example: A corporate ASP.NET website is idle at night. In the morning at 8AM 1000 people log on and start working. If the app is using let\u0027s say 100 threads starting from 8AM it will take like 50sec to create all of them. Until then there will be serious delays and timeouts. It is possible to construe arbitrarily bad scenarios.\n\n**Problem statement:** If thread pool load suddenly increases in IO bound workloads the pool is too slow to respond. This causes throughput and availability disruption. IO bound workloads relying on synchronous IO are common. Sudden workload changes are also common. Sometimes the workload can change due to a problem outside of the developer\u0027s control: A web service timing out or a database become slow.\n\nLet me stress that this causes service interruption.\n\nYou can easily repro this yourself. Run a load test on an ASP.NET site with `Thread.Sleep(10000);`. The thread count goes up by 2 each second.\n\nStarting and shutting down a thread was benchmarked by me to be around 1ms in total. Threads are not really an expensive resource. The thread pool should be a lot more eager to create and destroy threads. 500ms delay to potentially save 1ms is not a good trade-off.\n\n**Easy fix:** I propose lowering the injection delay to 100ms. This reduces the problem given above by 5x. Ideally, the rate would be configurable. The shutdown delay could be lowered from 30s as well. Keeping an idle thread for 30000ms to save 1ms seems excessive. In this ticket I\u0027m not that concerned with retiring threads, though.\n\n**Smarter, riskier fix:** The delay could depend on the number of threads in existence, the core count and the perceived pressure on the thread-pool. The injection rate could be:\n- 0ms delay for up to (ProcessorCount \\* 1) threads\n- 50ms delay for up to (ProcessorCount \\* 4) threads\n- Starting from that a delay of (100ms \\* (ThreadCount / ProcessorCount \\* someFloatFactor)). Reasoning: The more the CPU is oversubscribed the slower we want to inject. Maybe we need to have a maximum delay of 1sec. Or, the delay must rise sub-linearly (e.g. sqrt).\n\nNote, that the Windows Kernel has some thread pool injection heuristics that apply back pressure the more threads are in existence. This seems to work. Source: https://channel9.msdn.com/Shows/Going+Deep/Inside-Windows-8-Pedro-Teixeira-Thread-pool\n\nHere\u0027s what happens when you Parallel.ForEach over an infinite sequence and sleep for a few seconds in each work item: ![thread injection](https://cloud.githubusercontent.com/assets/12032350/10454685/cd4e828e-71b6-11e5-8017-21616f7827f5.png) The memory use is proportional to the number of threads (here: 731).\n\n```\nSystem.Threading.Tasks.Parallel.ForEach(\n Enumerable.Range(0, int.MaxValue),\n i =\u003e Thread.Sleep(delay));\n```\n\nThe problem exists at **all** delays:\n\n```\n//Time to get to about 750 threads on an 8 core box:\n//var delay = Timeout.Infinite; //15min\n//var delay = TimeSpan.FromSeconds(1); //30min\n//var delay = TimeSpan.FromSeconds(0.1); //2h 15min\nvar delay = TimeSpan.FromSeconds(0.01); //980 threads after 6h\n```\n\n10ms delay is something that is very unrealistic to avoid in a production workload. Almost nothing is faster than 10ms (e.g. web service, database).\n\nPlease also see the discussion at the [original location](https://github.com/dotnet/corefx/issues/2329) which is now closed.\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOZ0cbdg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDE0NzY5OTM3Nw==",
                                           "createdAt":  "2015-10-13T12:22:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GSPP",
                                           "body":  "@stephentoub @ericeil pinging you. Please note the added information.\n",
                                           "updatedAt":  "2015-10-13T12:32:22Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIxNzczMTAyMQ==",
                                           "createdAt":  "2016-05-08T16:28:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAEFC5g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "GSPP",
                                                                               "createdAt":  "2016-05-08T16:34:40Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AqlaSolutions",
                                                                               "createdAt":  "2016-10-15T08:18:26Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "JeffCyr",
                                           "body":  "In java there is a mechanism to inform the thread pool that one of its thread is about to block. This allows the thread pool to create a new thread immediately if needed.\n\nSomething similar might be doable in .Net, this could be done transparently in WaitHandle.WaitOne and all equivalent blocking calls. I think there is already something like this with SynchronizationContext.\n",
                                           "updatedAt":  "2016-05-08T16:28:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIyMjc5MDMyOQ==",
                                           "createdAt":  "2016-05-31T19:12:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "acelent",
                                           "body":  "In ASP.NET under a IIS worker process, since the CLR is hosted, the host could consider the current HTTP request queues as pressure to create threads.  Even with the 500ms checking interval, it could create more than a single thread at a time, such as the minimum of 1) the number of queued requests and 2) the number of threads to reach the current MaxWorkerThreads configuration.\n\nIf ASP.NET Core under a IIS worker process runs in a specialized CLR host as well, this host could do the same.\n\nBut in essence, setting MinWorkerThreads to a high enough number has a similar effect, since it tells the CLR host how many threads should be created on demand (read: instantaneously) before using the 1 thread per 500ms adjusting algorithm.  Setting a high minimum number of threads doesn\u0027t actually mean creating them all upfront or keep them all alive.\n\nThis also works when running a standalone ASP.NET Core application, i.e. without IIS.\n\nIf you have a requirement on the number of concurrent requests, you should probably provide a high enough minimum for now.\n\nHowever, I agree that the thread pool algorithm could be improved, probably be configurable or replaced, or make the thread-pool be an API, such that we can create our own thread pools and task schedulers that use them, replace the default thread pool at will, perform certain tasks or requests in fixed thread-pools, etc.\n",
                                           "updatedAt":  "2016-05-31T19:12:48Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI1NTkxMTAzNg==",
                                           "createdAt":  "2016-10-25T01:25:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "As @ericeil mentioned in dotnet/corefx#2329, it would be good to investigate switching to the Windows thread pool. We need a good solution outside Windows as well, and `SynchronizationContext.Wait` only handles synchronization waits., For that as @JeffCyr pointed out, an API that indicates when blocking begins and ends, along with some heuristics, I think could be used to mostly alleviate this problem. It may also require replacing some of the existing heuristics or tuning them down to handle the other edge cases they are intended to solve.\n",
                                           "updatedAt":  "2016-10-25T01:25:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI2MDY1ODQ0Nw==",
                                           "createdAt":  "2016-11-15T14:40:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GSPP",
                                           "body":  "IO also can be blocking. Nothing wrong with doing synchronous IO.\n\nNot sure how blocking would play into the heuristics even if the exact number of blocked threads was known. Just releasing another thread for each one blocked could easily cause an explosion of threads.\n\nKnowing the number of blocked threads might help the heuristics but this can never fully resolve the problems detailed in this issue.\n",
                                           "updatedAt":  "2016-11-15T14:41:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI2MDc1NjgxNQ==",
                                           "createdAt":  "2016-11-15T20:24:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "\u003e Just releasing another thread for each one blocked could easily cause an explosion of threads.\n\nSuppose we immediately spin off a new thread to compensate for a blocked thread, when blocking ends and it calls the API to indicate that blocking has ended, instead of allowing that thread to run, we could block that thread and put it in a separate queue that would be prioritized when a thread pool thread becomes available. That way, it would not cause too many threads to be running after blocking operations complete. Realistically, there would need to be some sort of configurable limits on how many threads can be created like this, and perhaps also and increasing delay before compensating with a new thread, based on the number of active threads and processors, to prevent creating too many threads unnecessarily.\n\n\u003e this can never fully resolve the problems detailed in this issue.\n\nThe 0.5 sec heuristic you mentioned (starvation heuristic) kicks in when all of the thread pool threads have not completed their work in that amount of time. That could be due to blocking work or long CPU-bound work. With a heuristic that compensates for blocking threads much quicker (immediately for all practical purposes), the starvation heuristic would not kick in due to blocking, only due to long CPU-bound work (but that\u0027s a separate issue). Why would this not resolve the problems you mentioned?\n",
                                           "updatedAt":  "2016-11-15T20:24:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI2MTMyMTYwMA==",
                                           "createdAt":  "2016-11-17T18:04:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GSPP",
                                           "body":  "This would immediately create a maximum amount of threads with the following code:\n\nEnumerable.Range(0, 100000).Select(_ =\u003e Task.Run(() =\u003e File.ReadAllBytes(\"...\"))).ToList();\n\nBecause all those tasks immediately block, causing another thread to be spawned.\n\nHolding a thread at the end of a blocking operation can lead to deadlocks or catastrophically low throughput if that thread was holding any locks. It can dramatically alter the perceived latency of IO operations.\n\nBut I agree that using the number of blocked threads in the thread injection heuristics could improve them. It seems that injection should happen more liberally if there are many threads blocked on IO.\n\nI think the bias should be towards over-subscribing resources instead of under-subscribing. 10x too little threads means 10x loss in thoughput. 10x too many threads usually means far less than 10x loss.\n\nWhat I recommend at the moment is to target the \"Easy fix\" immediately:\n\n\u003e I propose lowering the injection delay to 100ms.\n\nAnd then possibly pursue a more sophisticated solution.\n",
                                           "updatedAt":  "2016-11-17T18:04:04Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI2MTM2NjI1Mw==",
                                           "createdAt":  "2016-11-17T20:53:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "\u003e Enumerable.Range(0, 100000).Select(_ =\u003e Task.Run(() =\u003e File.ReadAllBytes(\"...\"))).ToList();\n\nThere would need to be some limit on how many threads are added to compensate for blocked threads, such that this type of worst-case scenario caps out the number of threads at a reasonable amount. There are several pieces of information available to make reasonable heuristics for this case.\n\n\u003e Holding a thread at the end of a blocking operation can lead to deadlocks or catastrophically low throughput if that thread was holding any locks. It can dramatically alter the perceived latency of IO operations.\n\nYea that\u0027s a good point, especially if threads returning from blocked state are many and the queue gets backed up. Another issue is that when there are CPU-bound and IO-bound work items, it could artificially slow down the IO-bound work. I agree that we should let some threads continue running after unblocking up to some point and then queue them up, but it would not be reasonable to let all of them run immediately. There is lots of information we can use to tune this well, but yea it won\u0027t be perfect since it doesn\u0027t have control over scheduling. For instance we can look at duration and time spent unblocked for a particular work item, and make decisions based on that. In any case, it should be significantly better than what we have now.\n\n\u003e I think the bias should be towards over-subscribing resources instead of under-subscribing. 10x too little threads means 10x loss in thoughput. 10x too many threads usually means far less than 10x loss.\n\nWhat I suggested would not undersubscribe resources, it just may not be fair in allocating resources, that can be tuned.\n\n\u003e I propose lowering the injection delay to 100ms.\n\nThe heuristic is currently unbounded in the number of threads it would create (max threads by default is 32K). So realistically, the delay is the bound. By reducing the delay, more apps would be subject to this heuristic, and the more the delay is reduced, the more it can get out of control. It could create more threads than necessary, creating inefficiencies and causing higher memory usage, and it would do so much faster than before due to the shorter delay.\n\nSo I don\u0027t think it\u0027s as simple as reducing the delay. Adding a bound to this heuristic would be arbitrary. Some apps may benefit from having many threads, and some may benefit from having few, and the information needed to create a reasonable bound is not available. Choosing thresholds for adjusting the rate of thread injection would also be arbitrary. This heuristic is inherently flawed, tweaking it may help some apps but it may hurt others.\n\nFor instance, an app that has a work item duration of 150 ms would not currently hit the starvation heuristic, and if all of those are CPU-bound work items, it would be performing well with the right number of threads. Reducing the delay to 100 ms would cause the starvation heuristic to kick in and 10 threads would be created per second in this app as long as there is work.\n",
                                           "updatedAt":  "2016-11-17T20:56:21Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI2MTM2OTc5Mg==",
                                           "createdAt":  "2016-11-17T21:07:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GSPP",
                                           "body":  "Maybe a tunable settings for app developers to alter the injection speed? It seems we need two settings:\n1. The maximum thread count that we want to converge to over time.\n2. The speed at which we would want to inject.\n\nTo illustrate:\n- The red line is the old behavior.\n- The other lines show different maximum values and speeds. They all converge to a maximum but at different speeds.\n\n![image](https://cloud.githubusercontent.com/assets/12032350/20407567/2e5f8a36-ad12-11e6-9621-cd472932a6a9.png)\n\nFor all productions apps that I have ever worked on I\u0027d prefer the new lines over the red line. The green one is what I would use in all my web apps.\n",
                                           "updatedAt":  "2016-11-17T21:09:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI2MTM3NDY4NA==",
                                           "createdAt":  "2016-11-17T21:27:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "Configuring the minimum and maximum worker thread count produces an approximation of the green line above, though not as nice:\n\n![image](https://cloud.githubusercontent.com/assets/13499639/20408197/4149964e-acc9-11e6-957e-d117f21178ac.png)\n\nI\u0027m not sure that it is always beneficial to have a curve. It should get to the right number of threads quickly. The type of work could also be changing, and it would have to adjust the thread count based on that. When the type of work is stable, configuring the min \u0026 max can produce decent results.\n",
                                           "updatedAt":  "2016-11-17T21:27:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI2MTM3NTIzOQ==",
                                           "createdAt":  "2016-11-17T21:28:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "An issue with that is often times a min thread count closer to the max typically required for the app will be configured, and the app may not run as efficiently.\n",
                                           "updatedAt":  "2016-11-17T21:28:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5nRxt2",
                                           "createdAt":  "2023-09-25T00:16:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "OwnageIsMagic",
                                           "body":  "resolved by https://github.com/dotnet/runtime/pull/53471 ?\r\nhttps://learn.microsoft.com/en-us/dotnet/core/runtime-config/threading#thread-injection-in-response-to-blocking-work-items",
                                           "updatedAt":  "2023-09-25T00:16:06Z"
                                       }
                                   ],
                         "totalCount":  12
                     },
        "title":  "Use a more dependable policy for thread pool thread injection",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/17975",
        "createdAt":  "2016-08-01T01:41:13Z",
        "number":  17975,
        "author":  "benaadams",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCu8GRA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "clarkis117",
                                            "createdAt":  "2016-08-01T07:30:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aleks-sidorenko",
                                            "createdAt":  "2016-08-01T08:56:16Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aharpervc",
                                            "createdAt":  "2016-08-01T21:32:16Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jamesqo",
                                            "createdAt":  "2016-08-04T14:44:16Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "alexwiese",
                                            "createdAt":  "2016-09-03T03:03:25Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "nietras",
                                            "createdAt":  "2016-11-01T08:51:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "BenjaminHolland",
                                            "createdAt":  "2017-03-09T06:58:49Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SteveDesmond-ca",
                                            "createdAt":  "2017-07-08T00:03:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dVakulen",
                                            "createdAt":  "2017-07-08T00:13:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "NickCraver",
                                            "createdAt":  "2017-08-23T12:23:55Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Horusiath",
                                            "createdAt":  "2017-08-23T12:25:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jnm2",
                                            "createdAt":  "2017-10-28T20:16:25Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "jnm2",
                                            "createdAt":  "2017-10-28T20:16:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ViIvanov",
                                            "createdAt":  "2017-10-29T10:09:25Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "chaim770",
                                            "createdAt":  "2018-05-08T12:42:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mvacha",
                                            "createdAt":  "2018-05-08T12:46:44Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "vermorel",
                                            "createdAt":  "2018-12-02T21:52:06Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "soerenBoisen",
                                            "createdAt":  "2019-03-05T13:54:09Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MBurtsev",
                                            "createdAt":  "2019-04-16T18:14:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Salgat",
                                            "createdAt":  "2019-05-23T16:08:18Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rikimaru0345",
                                            "createdAt":  "2019-05-26T12:47:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "juliusfriedman",
                                            "createdAt":  "2019-05-26T14:31:01Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "juliusfriedman",
                                            "createdAt":  "2019-05-26T14:31:02Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "juliusfriedman",
                                            "createdAt":  "2019-05-26T14:31:05Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kameko",
                                            "createdAt":  "2019-06-11T07:13:52Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AmrAlSayed0",
                                            "createdAt":  "2019-06-12T10:36:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pentp",
                                            "createdAt":  "2019-06-12T15:00:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "bilal-fazlani",
                                            "createdAt":  "2019-07-31T15:18:18Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ltrzesniewski",
                                            "createdAt":  "2019-09-10T11:49:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MendelMonteiro",
                                            "createdAt":  "2019-09-10T11:51:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kirsan31",
                                            "createdAt":  "2019-09-12T20:32:57Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "BrunoZell",
                                            "createdAt":  "2019-11-08T23:17:27Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "D3-LucaPiombino",
                                            "createdAt":  "2020-01-31T12:44:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "nsentinel",
                                            "createdAt":  "2020-04-05T20:48:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SommerEngineering",
                                            "createdAt":  "2020-07-28T13:09:34Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "SommerEngineering",
                                            "createdAt":  "2020-07-28T13:09:36Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "viktor-svub",
                                            "createdAt":  "2021-01-21T12:02:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Sergio0694",
                                            "createdAt":  "2021-02-01T17:58:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sunkin351",
                                            "createdAt":  "2021-04-10T19:48:10Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "sunkin351",
                                            "createdAt":  "2021-04-10T19:48:10Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "sunkin351",
                                            "createdAt":  "2021-04-10T19:48:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "omariom",
                                            "createdAt":  "2021-04-30T11:44:36Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "andriysavin",
                                            "createdAt":  "2021-06-13T08:40:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "uvw",
                                            "createdAt":  "2022-04-27T00:14:32Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "timcassell",
                                            "createdAt":  "2022-04-29T03:30:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aromaa",
                                            "createdAt":  "2022-05-14T13:14:25Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Enderlook",
                                            "createdAt":  "2022-06-04T13:12:52Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lanyizi",
                                            "createdAt":  "2022-10-06T17:04:33Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dlyz",
                                            "createdAt":  "2023-02-28T12:18:04Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hexawyz",
                                            "createdAt":  "2023-03-17T20:47:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "tkent",
                                            "createdAt":  "2023-03-18T21:04:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MineCake147E",
                                            "createdAt":  "2023-08-17T08:37:25Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "BoundedChenn31",
                                            "createdAt":  "2023-10-28T12:00:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2023-12-25T12:44:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rzikm",
                                            "createdAt":  "2024-05-13T07:26:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "issue-dispenser",
                                            "createdAt":  "2024-10-03T06:08:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "miyu",
                                            "createdAt":  "2025-02-23T18:57:58Z"
                                        }
                                    ],
                          "totalCount":  57
                      },
        "updatedAt":  "2022-12-14T12:48:12Z",
        "body":  "## Atomic\u003cT\u003e\n### Background\n\nx64 has been able to do 128bit/16 byte Interlocked CompareExchanges for a while and its a cpu requirement to be able install Window 8.1 x64 and Windows 10 x64. Its also available on MacOS/OSX and Linux. Its availability would allow for more interesting lock-less algorithms.\n\nWas trying to think if there was an easy fallback for https://github.com/dotnet/corefx/issues/10478 but since its struct-based there is nothing to lock. \n\nSo additionally it would be good to have a type Atomic\u003cT\u003e which mirrors the C++ 11 atomic type, adds some .NET magic and can fallback to locks when the data width is not supported on the platform.\n### Proposed Api\n\nInterface, struct, class, extenstions (and some reference manipulation types)\n\n``` csharp\nnamespace System.Threading.Atomics\n{\n    public interface IAtomic\u003cT\u003e  where T : IEquatable\u003cT\u003e\n    {\n        T Read();\n        T Read(MemoryOrder order);\n        void Write(T value);\n        void Write(T value, MemoryOrder order);\n\n        T Exchange(T value);\n        T Exchange(T value, MemoryOrder order);\n\n        bool CompareExchangeWeak(T value, T comperand);\n        bool CompareExchangeWeak(T value, T comperand, MemoryOrder order);\n\n        bool CompareExchangeStrong(T value, T comperand);\n        bool CompareExchangeStrong(T value, T comperand, MemoryOrder order);\n\n        // MemoryOrder variants skipped for brevity\n\n        // Unsafe transformations, bypass the atomicity\n        T UnsafeTransform(AtomicTransform\u003cT\u003e transformation);\n        T UnsafeTransform(AtomicTransformParam\u003cT\u003e transformation, T val);\n\n        // Atomic transformations, Func should be pure and repeatable in case of retry\n\n        // Pure transform\n        T Transform(Func\u003cT, T\u003e transformation);\n        T Transform\u003cTState\u003e(Func\u003cT, TState, T\u003e transformation, TState state);\n\n        // Conditional transforms e.g. Increment but only while \u003c N\n        T Transform(Func\u003cT, T\u003e transformation, Func\u003cT, bool\u003e condition);\n        T Transform\u003cTState\u003e(Func\u003cT, T\u003e transformation, Func\u003cT, TState, bool\u003e condition, TState state);\n\n        // Same data transform, apply if value is what is expected\n        T Transform(Func\u003cT, T\u003e transformation, T comperand);\n        T Transform\u003cTState\u003e(Func\u003cT, TState, T\u003e transformation, TState state, T comperand);\n    }\n\n    public delegate T AtomicTransform\u003cT\u003e(ref T input);\n    public delegate T AtomicTransformParam\u003cT\u003e(ref T input, T val);\n\n    public enum MemoryOrder\n    {\n        Relaxed,\n        Consume,\n        Acquire,\n        Release,\n        AcquireRelease,\n        SequentiallyConsistent\n    }\n}\n```\n#### Atomic struct\n\n``` csharp\n[Disallow(Stack,Boxing)]\npublic struct ValueAtomic\u003cT\u003e : IAtomic\u003cT\u003e where T : IEquatable\u003cT\u003e\n{\n    private T _data;\n    // allocated if not supported lock-free natively\n    private object _lock;\n\n    [JitIntrinsic]\n    public static bool IsLockFree { get; }\n\n    public ValueAtomic(T value)\n    {\n        _data = value;\n        _lock = IsLockFree ? null : new object();\n    }\n\n    public T Read();\n    public T Read(MemoryOrder order);\n    public void Write(T value);\n    public void Write(T value, MemoryOrder order);\n    public T Exchange(T value);\n    public T Exchange(T value, MemoryOrder order);\n    public bool CompareExchangeWeak(T value, T comperand);\n    public bool CompareExchangeWeak(T value, T comperand, MemoryOrder order);\n    public bool CompareExchangeStrong(T value, T comperand);\n    public bool CompareExchangeStrong(T value, T comperand, MemoryOrder order);\n    public unsafe T UnsafeTransform(AtomicTransform\u003cT\u003e transformation)\n        =\u003e transformation(ref _data);\n    public unsafe T UnsafeTransform(AtomicTransformParam\u003cT\u003e transformation, T val)\n        =\u003e transformation(ref _data, val);\n    public T Transform(Func\u003cT, T\u003e transformation);\n    public T Transform\u003cTState\u003e(Func\u003cT, TState, T\u003e transformation, TState state);\n    public T Transform(Func\u003cT, T\u003e transformation, Func\u003cT, bool\u003e condition);\n    public T Transform\u003cTState\u003e(Func\u003cT, T\u003e transformation, Func\u003cT, TState, bool\u003e condition, TState state)\n    {\n        //T current = Read();\n        //while (condition(current, state))\n        //{\n        //    T next = transformation(current);\n        //    T prev = Interlocked.CompareExchange(ref _data, next, current);\n        //    if (prev.Equals(current))\n        //    {\n        //        return next;\n        //    }\n        //    current = prev;\n        //}\n    }\n    public T Transform(Func\u003cT, T\u003e transformation, T comperand);\n    public T Transform\u003cTState\u003e(Func\u003cT, TState, T\u003e transformation, TState state, T comperand);\n\n    public static implicit operator T(ValueAtomic\u003cT\u003e atom) =\u003e atom.Read();\n}\n```\n#### Atomic class (struct wrapper)\n\n``` csharp\npublic class Atomic\u003cT\u003e : IAtomic\u003cT\u003e where T : IEquatable\u003cT\u003e\n{\n    private ValueAtomic\u003cT\u003e _atom;\n    public static bool IsLockFree =\u003e ValueAtomic\u003cT\u003e.IsLockFree;\n\n    Atomic(T value)\n    {\n        _atom = new ValueAtomic\u003cT\u003e(value);\n    }\n\n    public T Read()\n        =\u003e _atom.Read();\n    public T Read(MemoryOrder order)\n        =\u003e _atom.Read(order);\n    public void Write(T value)\n        =\u003e _atom.Write(value);\n    public void Write(T value, MemoryOrder order)\n        =\u003e _atom.Write(value, order);\n    public T Exchange(T value)\n        =\u003e _atom.Exchange(value);\n    public T Exchange(T value, MemoryOrder order)\n        =\u003e _atom.Exchange(value, order);\n    public bool CompareExchangeWeak(T value, T comperand)\n        =\u003e _atom.CompareExchangeWeak(value, comperand);\n    public bool CompareExchangeWeak(T value, T comperand, MemoryOrder order)\n        =\u003e _atom.CompareExchangeWeak(value, comperand, order);\n    public bool CompareExchangeStrong(T value, T comperand)\n        =\u003e _atom.CompareExchangeStrong(value, comperand);\n    public bool CompareExchangeStrong(T value, T comperand, MemoryOrder order)\n        =\u003e _atom.CompareExchangeStrong(value, comperand, order);\n    public unsafe T UnsafeTransform(AtomicTransform\u003cT\u003e transformation)\n        =\u003e _atom.UnsafeTransform(transformation);\n    public unsafe T UnsafeTransform(AtomicTransformParam\u003cT\u003e transformation, T val)\n        =\u003e _atom.UnsafeTransform(transformation, val);\n    public T Transform(Func\u003cT, T\u003e transformation)\n        =\u003e _atom.Transform(transformation);\n    public T Transform\u003cTState\u003e(Func\u003cT, TState, T\u003e transformation, TState state) \n    =\u003e _atom.Transform(transformation, state);\n    public T Transform(Func\u003cT, T\u003e transformation, Func\u003cT, bool\u003e condition)\n        =\u003e _atom.Transform(transformation, condition);\n    public T Transform\u003cTState\u003e(Func\u003cT, T\u003e transformation, Func\u003cT, TState, bool\u003e condition, TState state)\n        =\u003e _atom.Transform(transformation, condition, state);\n    public T Transform(Func\u003cT, T\u003e transformation, T comperand)\n        =\u003e _atom.Transform(transformation, comperand);\n    public T Transform\u003cTState\u003e(Func\u003cT, TState, T\u003e transformation, TState state, T comperand) \n        =\u003e _atom.Transform(transformation, state, comperand);\n\n    public static implicit operator T(Atomic\u003cT\u003e atom) =\u003e atom.Read();\n}\n```\n#### Numeric Extensions\n\n``` csharp\npublic static class AtomicNumericExtensions\n{\n    // For byte, short, ushort, uint, int, long, ulong, single, double\n\n    public static int Add(this Atomic\u003cint\u003e atom, int value);\n    public static int Subtract(this Atomic\u003cint\u003e atom, int value);\n    public static int Multiply(this Atomic\u003cint\u003e atom, int value);\n    public static int Divide(this Atomic\u003cint\u003e atom, int value);\n\n    // For byte, short, ushort, uint, int, long, ulong\n\n    public static int Increment(this Atomic\u003cint\u003e atom);\n    public static int Increment(this Atomic\u003cint\u003e atom, int max);\n\n    public static int Decrement(this Atomic\u003cint\u003e atom);\n    public static int Decrement(this Atomic\u003cint\u003e atom, int min);\n\n    public static int And(this Atomic\u003cint\u003e atom, int value);\n    public static int Or(this Atomic\u003cint\u003e atom, int value);\n    public static int Xor(this Atomic\u003cint\u003e atom, int value);\n    public static int Not(this Atomic\u003cint\u003e atom);\n}\n```\n#### Bool Extensions\n\n``` csharp\npublic static class AtomicBoolExtensions\n{\n    public static bool TestAndSet(this Atomic\u003cbool\u003e atom);\n    public static bool Clear(this Atomic\u003cbool\u003e atom);\n}\n```\n#### Atomic Flagged References\n\n``` csharp\npublic struct FlaggedReference\u003cTRef\u003e\n    where TRef : class\n{\n    TRef Reference { get; set; }\n    bool Flag { get; set; }\n}\n\npublic static class AtomicFlaggedReferenceExtensions\n{\n    public static bool TestAndSet\u003cTRef\u003e(this Atomic\u003cFlaggedReference\u003cTRef\u003e\u003e atom);\n    public static bool TestAndSet\u003cTRef\u003e(\n                        this Atomic\u003cFlaggedReference\u003cTRef\u003e\u003e atom,\n                        TRef expectedReference);\n    public static bool Clear\u003cTRef\u003e(this Atomic\u003cFlaggedReference\u003cTRef\u003e\u003e atom);\n    public static bool Clear\u003cTRef\u003e(\n                        this Atomic\u003cFlaggedReference\u003cTRef\u003e\u003e atom,\n                        TRef expectedReference);\n}\n```\n#### Atomic Versioned References\n\n``` csharp\npublic struct VersionedReference\u003cTRef\u003e\n    : IEquatable\u003cVersionedReference\u003cTRef\u003e\u003e\n    where TRef : class\n{\n    TRef Reference { get; set; }\n    long Version { get; set; }\n\n    public bool Equals(VersionedReference\u003cTRef\u003e other)\n        =\u003e ReferenceEquals(Reference, other.Reference) \n            \u0026\u0026 Version == other.Version;\n\n    public static implicit operator TRef(VersionedReference\u003cTRef\u003e atom) =\u003e atom.Reference;\n}\n\npublic static class AtomicVersionedReferenceExtensions\n{\n    public static VersionedReference\u003cTRef\u003e Increment\u003cTRef\u003e(\n                    this Atomic\u003cVersionedReference\u003cTRef\u003e\u003e atom)\n                    where TRef : class;\n    public static VersionedReference\u003cTRef\u003e Increment\u003cTRef\u003e(\n                    this Atomic\u003cVersionedReference\u003cTRef\u003e\u003e atom,\n                    TRef expectedReference)\n                    where TRef : class;\n    public static VersionedReference\u003cTRef\u003e UpdateIncrement\u003cTRef\u003e(\n                    this Atomic\u003cVersionedReference\u003cTRef\u003e\u003e atom,\n                    VersionedReference\u003cTRef\u003e newRefExpectedVersion)\n                    where TRef : class;\n}\n```\n#### Atomic Tagged References\n\n``` csharp\npublic struct TaggedReference\u003cTRef, TTag\u003e\n    where TRef : class \n    where TTag : struct\n{\n    TRef Reference { get; set; }\n    TTag Tag { get; set; }\n}\n\npublic static class AtomicTaggedReferenceExtensions\n{\n    public static TaggedReference\u003cTRef, TTag\u003e Update\u003cTRef, TTag\u003e(\n                    this TaggedReference\u003cTRef, TTag\u003e atom,\n                    TaggedReference\u003cTRef, TTag\u003e newTaggedReference,\n                    TRef expectedReference);\n    public static TaggedReference\u003cTRef, TTag\u003e Update\u003cTRef, TTag\u003e(\n                    this TaggedReference\u003cTRef, TTag\u003e atom,\n                    TRef newReference,\n                    TRef expectedReference);\n    public static TaggedReference\u003cTRef, TTag\u003e Update\u003cTRef, TTag\u003e(\n                    this TaggedReference\u003cTRef, TTag\u003e atom,\n                    TTag newTag,\n                    TRef expectedReference);\n    public static TaggedReference\u003cTRef, TTag\u003e Update\u003cTRef, TTag\u003e(\n                    this TaggedReference\u003cTRef, TTag\u003e atom,\n                    TaggedReference\u003cTRef, TTag\u003e newTaggedReference,\n                    TTag expectedTag);\n    public static TaggedReference\u003cTRef, TTag\u003e Update\u003cTRef, TTag\u003e(\n                    this TaggedReference\u003cTRef, TTag\u003e atom,\n                    TRef newReference,\n                    TTag expectedTag);\n    public static TaggedReference\u003cTRef, TTag\u003e Update\u003cTRef, TTag\u003e(\n                    this TaggedReference\u003cTRef, TTag\u003e atom,\n                    TTag newTag,\n                    TTag expectedTag);\n    public static TaggedReference\u003cTRef, TTag\u003e Update\u003cTRef, TTag\u003e(\n                    this TaggedReference\u003cTRef, TTag\u003e atom,\n                    TRef newReference,\n                    TaggedReference\u003cTRef, TTag\u003e expectedTaggedReference);\n    public static TaggedReference\u003cTRef, TTag\u003e Update\u003cTRef, TTag\u003e(\n                    this TaggedReference\u003cTRef, TTag\u003e atom,\n                    TTag newTag,\n                    TaggedReference\u003cTRef, TTag\u003e expectedTaggedReference);\n    // essentially CompareExchange\n    public static TaggedReference\u003cTRef, TTag\u003e Update\u003cTRef, TTag\u003e(\n                    this TaggedReference\u003cTRef, TTag\u003e atom,\n                    TaggedReference\u003cTRef, TTag\u003e newTaggedReference,\n                    TaggedReference\u003cTRef, TTag\u003e expectedTaggedReference);\n}\n```\n#### Atomic Double Reference\n\n``` csharp\npublic struct DoubleReference\u003cTRef\u003e : IEquatable\u003cDoubleReference\u003cTRef\u003e\u003e\n    where TRef : class\n{\n    TRef ReferenceLeft { get; set; }\n    TRef ReferenceRight { get; set; }\n\n    public bool Equals(DoubleReference\u003cTRef\u003e other)\n        =\u003e ReferenceEquals(ReferenceLeft, other.ReferenceLeft) \u0026\u0026\n            ReferenceEquals(ReferenceRight, other.ReferenceRight);\n}\n\npublic static class DoubleReferenceExtensions\n{\n    public static DoubleReference\u003cTRef\u003e ExchangeLeft\u003cTRef\u003e(\n                    this Atomic\u003cDoubleReference\u003cTRef\u003e\u003e atom,\n                    TRef expectedRight) where TRef : class;\n    public static DoubleReference\u003cTRef\u003e ExchangeRight\u003cTRef\u003e(\n                    this Atomic\u003cDoubleReference\u003cTRef\u003e\u003e atom,\n                    TRef expectedLeft) where TRef : class;\n}\n```\n#### Transforms\n\nThe transforms give the flexibility to compose more complex atomic data structures; for example the `int` `Add`, `Increment` and `Increment` to limit can be implemented as\n\n``` csharp\npublic static int Add\u003cTAtomic\u003e(this TAtomic atom, int value) \n    where TAtomic : IAtomic\u003cint\u003e\n{\n    return atom.UnsafeTransform(\n        (ref int current, int inc) \n            =\u003e Interlocked.Add(ref current, inc), value);\n}\n\npublic static int Increment\u003cTAtomic\u003e(this TAtomic atom) \n    where TAtomic : IAtomic\u003cint\u003e\n{\n    return atom.UnsafeTransform((ref int v) =\u003e Interlocked.Increment(ref v));\n}\n\npublic static int Increment\u003cTAtomic\u003e(this TAtomic atom, int value, int max) \n    where TAtomic : IAtomic\u003cint\u003e\n{\n    return atom.Transform((current) =\u003e current + 1, (c, m) =\u003e c \u003c= m, max);\n}\n```\n\nOr an entirely new type that hadn\u0027t previously supported atomic updates, with new operations\n\n``` csharp\npublic static Decimal Multiply\u003cTAtomic\u003e(this TAtomic atom, Decimal value)\n   where TAtomic : IAtomic\u003cDecimal\u003e\n{\n    return atom.Transform((current, m) =\u003e current * m, value);\n}\n```\n\nWhen the struct was 16 bytes `_data` would need to be 16 byte aligned to allow lock free use with `LOCK CMPXCHG16b` where available. Might be easier to enforce alignment than with https://github.com/dotnet/corefx/issues/10478?\n\n`VersionedReference` and `FlaggedReference` should be 16 byte aligned in `Atomic` (don\u0027t need to be outside), as should `TaggedReference` when the struct is \u003c= 16 bytes.\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHODjgkug==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNjQ4NDY0MQ==",
                                           "createdAt":  "2016-08-01T04:01:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html\n",
                                           "updatedAt":  "2016-08-01T04:01:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNjQ5OTUzOQ==",
                                           "createdAt":  "2016-08-01T06:29:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "Maybe a CompareExchange variant that takes a `Func\u003cT, T\u003e`? \n\n``` csharp\nbool Transform\u003cTVal\u003e(Func\u003cTVal, TVal\u003e transformation, T comperand) where TVal : struct, T;\n```\n\n_Added_\n",
                                           "updatedAt":  "2016-08-01T06:48:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzA0MTkxNA==",
                                           "createdAt":  "2016-08-02T20:59:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "joshfree",
                                           "body":  "cc @sergiy-k \n",
                                           "updatedAt":  "2016-08-02T20:59:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzE2MzU1MQ==",
                                           "createdAt":  "2016-08-03T07:28:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "clrjunkie",
                                           "body":  "I think in _this case_ it’s ok skip the interface name suffix convention so things don’t read weird.\n\nConsider changing ValueAtomic to AtomicValue.\n\nFurthermore, the api really abstracts a memory location consider renaming to AtomicVariable \n(I think atomic value generally means something that can’t be further divided)\n\nConsider adding \u0027Extensions\u0027 suffix to Extension Method classes.\n",
                                           "updatedAt":  "2016-08-03T07:28:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzIxNzQ4MQ==",
                                           "createdAt":  "2016-08-03T11:58:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "\u003e I think in this case it’s ok skip the interface name suffix convention so things don’t read weird. Consider changing ValueAtomic to AtomicValue.\n\nThere are 3 types, IAtomic, Atomic (class) and ValueAtomic (struct). The ValueAtomic follows the naming of ValueTuple and ValueTask for the struct based versions of Tuple and Task.\n\nIAtomic is so generic constraints can be used for the two types in the extension methods. \n\nIdeally I\u0027d like ValueTask to be a heap+ref return only (array of ValueTask) struct. It would have a similar problem to SpinLock in stack space (e.g. no purpose and error though copying).\n\n\u003e the api really abstracts a memory location\n\nIt can represent any type at any size; just will fallback to a lock when it can\u0027t be covered by a CAS or equivalent (e.g. TSX/LLSC).\n\n\u003e Consider adding \u0027Extensions\u0027 suffix to Extension Method classes.\n\nDone\n",
                                           "updatedAt":  "2016-08-03T11:59:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzIyMTIzOQ==",
                                           "createdAt":  "2016-08-03T12:18:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GSPP",
                                           "body":  "An alternative design would be to add the following:\n1. Add all these methods in the form of static methods.\n2. Support specifying memory alignment for structs.\n\nThat\u0027s more flexible than demanding that a certain type must be used.\n",
                                           "updatedAt":  "2016-08-03T12:18:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzIzMzIzNw==",
                                           "createdAt":  "2016-08-03T13:13:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODQfntg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "bcronce",
                                                                               "createdAt":  "2020-02-22T19:42:44Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2023-12-25T12:45:16Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "benaadams",
                                           "body":  "\u003e Add all these methods in the form of static methods ... That\u0027s more flexible than demanding that a certain type must be used.\n\nDoesn\u0027t allow fallbacks; if I had a 16 byte struct it may support CAS on x64, but not x86, a 64 byte struct may support an atomic update with TSX on Intel Skylake but not on earlier cpus, AMD or ARM. \n\nAs a user I just want an atomically updating data structure without worrying how its done; whether CAS, LLSC, Transactional memory etc. \n\nAs a power user I may want to know if `IsLockFree` and use a different strategy if not.\n\nWith the `Atomic` type set; I could define a 256 byte struct and have it happily be atomically updated by just enclosing it in the type.\n\n``` csharp\nAtomic\u003cstruct256byte\u003e LargeStruct = new Atomic\u003cstruct256byte\u003e();\nvar val = LargeStruct.Read();\nval.x = 15;\nval.name = \"www\";\nLargeStruct.Write(val);\n```\n\nAn if that became an lock-free operation at some point on a platform the framework could be updated to take advantage of it and no user code would need to change.\n",
                                           "updatedAt":  "2016-08-03T13:16:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzIzMzY1NQ==",
                                           "createdAt":  "2016-08-03T13:15:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "clrjunkie",
                                           "body":  "\u003e The ValueAtomic follows the naming of ValueTuple and ValueTask for the struct based versions of Tuple and Task.\n\nWhy? How are these related to this api?\n\n\u003e It can represent any type at any size; just will fallback to a lock when it can\u0027t be covered by a CAS or equivalent (e.g. TSX/LLSC).\n\nSo it abstracts a location in memory.. seems natural to call it as such (e.g AtomicVariable) \n\np.s\n\nNot planning to over argue about it... food for your thought\n",
                                           "updatedAt":  "2016-08-03T13:15:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzIzNTMwNw==",
                                           "createdAt":  "2016-08-03T13:22:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "\u003e \u003e The ValueAtomic follows the naming of ValueTuple and ValueTask for the struct based versions of Tuple and Task.\n\u003e \n\u003e Why? How are these related to this api?\n\nAs there are two types:\n\n``` csharp\nAtomic\u003cdecimal\u003e objectAtomicDecimal = new Atomic\u003cdecimal\u003e();\nValueAtomic\u003cdecimal\u003e valueTypeAtomicDecimal = new ValueAtomic\u003cdecimal\u003e();\n```\n\nThe class type (heap) to be passed as parameter; the valuetype to be embedded in class (heap) or used in arrays (heap).\n",
                                           "updatedAt":  "2016-08-03T13:25:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzIzNzg0OQ==",
                                           "createdAt":  "2016-08-03T13:32:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "clrjunkie",
                                           "body":  "Aha... didn\u0027t pay quite attention to the Atomic class (wrapper)\n",
                                           "updatedAt":  "2016-08-03T13:32:51Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzI0MzczNw==",
                                           "createdAt":  "2016-08-03T13:55:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "clrjunkie",
                                           "body":  "@benaadams \n\nBTW.. I don\u0027t recall encountering code where an atomic variable was passed around as an argument for anything other then passing it to an interlocked method...  even while reading through java code I only recall noticing their atomic abstraction used at the field level. Have you encountered any usage that justifies the \u0027class version\u0027? Might worth posting an example here to be included in the api doc\u0027s as \"sample usage\". Genuinely interested. \n",
                                           "updatedAt":  "2016-08-03T13:55:43Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzI1OTgxMA==",
                                           "createdAt":  "2016-08-03T14:52:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GSPP",
                                           "body":  "There\u0027s no need for a copy of the struct to put it on the heap. The framework has `Box\u003cT\u003e` for putting anything on the heap.\n",
                                           "updatedAt":  "2016-08-03T14:52:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzI2Mzc4Nw==",
                                           "createdAt":  "2016-08-03T15:04:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "@clrjunkie Unless it could be enforced that a stack copy of the `ValueAtomic` couldn\u0027t be taken, I\u0027d see `Atomic` as the go to type; that a user would use first due to the simpler name and it would carry less coding risk.\n\nSay you had an atomic subtract extension for decimal which took a minimum value:\n\n``` csharp\nstatic ValueTuple\u003cbool, decimal\u003e Subtract\u003cTAtomic\u003e(this TAtomic atom,\n    decimal value,\n    decimal min)\n    where TAtomic : IAtomic\u003cdecimal\u003e;\n```\n\nThen you took a function local copy:\n\n``` csharp\nclass Account\n{\n    ValueAtomic\u003cdecimal\u003e _balance = new ValueAtomic\u003cdecimal\u003e();\n\n    public bool Withdraw(decimal amount, out string message)\n    {\n        var balance = _balance; // uh oh - different copy\n\n        var result = balance.Subtract(amount, 0);\n\n        var success = result.Item1;\n        var currentBalance = result.Item2;\n\n        if (success)\n        {\n            message = $\"{amount} was withrawn from your account and you have {currentBalance} remaing\";\n        }\n        else\n        {\n            message = $\"You only have {currentBalance} which is insufficent to withrawn {amount}\"\n                        + $\"as that would leave you with {currentBalance - amount}\";\n        }\n\n        return success;\n    }\n}\n```\n\nYou may be confused why the actual `_balance` had not changed. If you were using the class version the results would be as expected. \n\nSo I\u0027d prefer the struct version; but the class version comes with less hazards - thus offer both.\n\n\u003e even while reading through java code I only recall noticing their atomic abstraction used at the field level\n\nDoes Java have value types? Everything is mostly an object type?\n",
                                           "updatedAt":  "2016-08-03T15:08:43Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzI2Njk5Nw==",
                                           "createdAt":  "2016-08-03T15:11:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOApWAsw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "rikimaru0345",
                                                                               "createdAt":  "2019-05-26T12:56:42Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "benaadams",
                                           "body":  "\u003e The framework has `Box\u003cT\u003e` for putting anything on the heap.\n\n``` csharp\nBox\u003cAtomic\u003cdecimal\u003e\u003e balance = new Box\u003cAtomic\u003cdecimal\u003e\u003e(1000);\n// ...\nbalance.Value.Subtract(10, 0);\n```\n\nIs just unhappy code... So you\u0027d probably go:\n\n``` csharp\nBox\u003cAtomic\u003cdecimal\u003e\u003e objectBalance = new Box\u003cAtomic\u003cdecimal\u003e\u003e(1000);\n// ...\nvar balance = objectBalance.Value;\nbalance.Subtract(10, 0);\n```\n\nAnd now you are in trouble for the reason mentioned in previous comment as you are operating on a different instance.\n",
                                           "updatedAt":  "2016-08-03T15:14:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzI2ODc1Mw==",
                                           "createdAt":  "2016-08-03T15:16:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tenor",
                                           "body":  "I did something similar with [InterlockedBoolean](https://github.com/tenor/RestBus/blob/master/src/Common/RestBus.Common/InterlockedBoolean.cs) which is a great convenience structure for storing atomic boolean values.\n\nHowever, it can\u0027t be passed around since it\u0027s an ordinary struct. Perhaps the compiler can issue an error/warning if an instance of the proposed value is passed around.\n\nI also think naming these types InterlockedValue\u003cT\u003e and InterlockedObject\u003cT\u003e are more congruent with .NET\u0027s InterlockedXXX naming style.\n",
                                           "updatedAt":  "2016-08-03T15:16:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzI3MjkyMA==",
                                           "createdAt":  "2016-08-03T15:29:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "clrjunkie",
                                           "body":  "@benaadams \n\nActually I started  to think about it the other way around: go with class, drop struct, exactly because of boxing penalty.. and I don\u0027t see the need for a huge array of atomics and the boxing conversion penalty of both IAtomic\u003cT\u003e where T : IEquatable\u003cT\u003e can have a negative impact overall.\n\nAnd why would anyone do this:\n\nvar balance = _balance; // uh oh - different copy\n\nand not work with the _balance directly to extract the wrapped value via the Read method?\n\nYou mentioned that the motivation for the  class version was for passing it as parameter, and my understanding was that your intention was to reduce the copy size. Java currently has only reference types and my point was that I didn\u0027t see those passed around anyway so I didn\u0027t understand the motivation compared to a field allocated struct. \n",
                                           "updatedAt":  "2016-08-03T15:29:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzI3NzUxMw==",
                                           "createdAt":  "2016-08-03T15:45:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODQfn_w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "soerenBoisen",
                                                                               "createdAt":  "2019-03-05T14:01:42Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "popcatalin81",
                                                                               "createdAt":  "2019-05-28T10:51:38Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2023-12-25T12:47:09Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "benaadams",
                                           "body":  "@clrjunkie people take different approaches to things, and its to leave the flexibility open. Depends whether you are taking an object orientated approach and adding 12 bytes plus a GC handle to every object or a data orientated approach for fast batch processing where you\u0027d stream through arrays of data.\n\nref returns for example fit more with a data orientated approach. And you could ref return an ValueAtomic from the array\n\n\u003e boxing conversion penalty \n\nShouldn\u0027t be any boxing? There\u0027s an extra pass though concrete call to the struct which should be inlinable.\n",
                                           "updatedAt":  "2016-08-03T15:47:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzI3NzUyOA==",
                                           "createdAt":  "2016-08-03T15:45:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "clrjunkie",
                                           "body":  "@benaadams\n\n\u003e var balance = objectBalance.Value;\n\u003e balance.Subtract(10, 0);\n\nbut \u0027balance\u0027 is the _value_ how can it have \u0027Subtract\u0027 ?\n",
                                           "updatedAt":  "2016-08-03T15:45:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzI3Nzc2MA==",
                                           "createdAt":  "2016-08-03T15:46:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "\u003e but \u0027balance\u0027 is the value how can it have \u0027Subtract\u0027 ?\n\nIf `Box\u003cT\u003e` was used it would be the Atomic\n",
                                           "updatedAt":  "2016-08-03T15:46:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzI4MzM4Mw==",
                                           "createdAt":  "2016-08-03T16:05:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODQfoBQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "soerenBoisen",
                                                                               "createdAt":  "2019-03-05T14:02:40Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "sunkin351",
                                                                               "createdAt":  "2021-04-10T20:00:50Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2023-12-25T12:47:23Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "clrjunkie",
                                           "body":  "@benaadams\n\n\u003e If Box\u003cT\u003e was used it would be the Atomic\n\nYou mean in case the user did  var balance = objectBalance, but there is no reason to do so other then by mistake and there can be many other mistakes...\n\nLooks like another reason why having a struct version is bad.\n\n\u003e Shouldn\u0027t be any boxing?\n\nI meant the \"box\" problem in general but as soon as you starting invoking methods that call the atomic through the base interface methods, notability IEquatable the _unboxing_ penalty will start showing. \n\nWhy do we need this?\n",
                                           "updatedAt":  "2016-08-03T16:16:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzI4NjMwOQ==",
                                           "createdAt":  "2016-08-03T16:15:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "clrjunkie",
                                           "body":  "@benaadams\n\n```\nIf Box\u003cT\u003e was used it would be the Atomic\n```\n\nHow can the Atomic be returned and not T ? \n\n```\npublic class Atomic\u003cT\u003e : IAtomic\u003cT\u003e where T : IEquatable\u003cT\u003e\nprivate ValueAtomic\u003cT\u003e _atom;\n\nAtomic(T value)\n{\n  _atom = new ValueAtomic\u003cT\u003e(value);\n} \n\npublic T Read() =\u003e _atom.Read();\n```\n\n```\npublic struct ValueAtomic\u003cT\u003e : IAtomic\u003cT\u003e where T : IEquatable\u003cT\u003e\nprivate T _data;\n\npublic ValueAtomic(T value)\n{\n    _data = value;\n}\npublic T Read();\n```\n",
                                           "updatedAt":  "2016-08-03T16:15:53Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzI4ODEwMA==",
                                           "createdAt":  "2016-08-03T16:22:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "clrjunkie",
                                           "body":  "@benaadams\n\nI think you consider the large collection (was array) scenario to be very important, no problem.. what\u0027s the use-case? Maybe it involves comparing or lookup and the unboxing effect will introduce a negative effect overall? \n",
                                           "updatedAt":  "2016-08-03T16:26:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzI5NDAwNA==",
                                           "createdAt":  "2016-08-03T16:44:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODQfoCA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "soerenBoisen",
                                                                               "createdAt":  "2020-04-24T12:41:33Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2023-12-25T12:47:34Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "clrjunkie",
                                           "body":  "@benaadams\n\n\u003e people take different approaches to things, and its to leave the flexibility open.\n\nAre you advocating that each class in the framework should also have a struct version to satisfy every potential need or programing approach?\n",
                                           "updatedAt":  "2016-08-03T16:44:36Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzMwNjM3OQ==",
                                           "createdAt":  "2016-08-03T17:25:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "\u003e \u003e If Box\u003cT\u003e was used it would be the Atomic\n\u003e \n\u003e How can the Atomic be returned and not T ?\n\nWas in answer to @GSPP suggestion about using [`Box\u003cT\u003e`](https://github.com/dotnet/corefx/blob/master/src/System.Threading.Tasks.Parallel/src/System/Threading/Tasks/Box.cs) instead.\n\nThe value-type Atomic should be \"non-copyable\". So casting it to object, to IAtomic, assigning to a local or assigning another heap variable to it should all be compile errors; as they will take a copy and not modify the original. Passing as a ref return or modifying in place should be fine.\n\nKind of like `Span\u003cT\u003e` is stack only; so you can\u0027t cast it to object or take a heap reference. Equally SpinWait should probably be stack only like `Span\u003cT\u003e` as more than one thing shouldn\u0027t spin on it, and SpinLock should have the same constraints the value-type Atomic as as soon as a copy is taken of it is no longer the same lock.\n\nThe `IAtomic` interface is for the generic constraint to apply so one set of extension methods can apply to both types and so the atomic type can be used with test IoC, DI if someone wants to create a different type that behaves functionally the same etc.\n\n\u003e I think you consider the large collection (was array) scenario to be very important, no problem.\n\nGoing back to the Java comparison it has [AtomicReferenceArray](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicReferenceArray.html) for similar. \n\nHowever, with the struct type you could use a normal .NET array of `ValueAtomic\u003cobject\u003e[100]` for similar effect; or project though a `ReadOnlySpan\u003cValueAtomic\u003cobject\u003e\u003e` for extra safety.\n\n\u003e  what\u0027s the use-case?\n\nIf you were organising data in a column store manner and say the data type was Decimal (16 bytes) then if you wanted to do a Sum: \n\nValueType: for loop over array, proceed in 32 byte skips, 2 per cache line (16 byte decimal + 8 byte null lock pointer + alignment)\nObjectType: for loop over array, proceed in 8 byte skips (pointer to Atomic), 8 per cache line, dereference (potentially scattered data, otherwise) proceed in 48 byte skips 1.5 per cache line (12 byte object header + 16 byte decimal + 8 byte null lock pointer + alignment)\n\nSo the value type would be faster.\n\nAnd if its any array of references then using a object type atomic would mean to use the object would require a double deference. Array-\u003eAtomic-\u003eObject-\u003eFunction\n",
                                           "updatedAt":  "2016-08-03T17:42:10Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzMxMDA1MA==",
                                           "createdAt":  "2016-08-03T17:37:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODQfrFQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "soerenBoisen",
                                                                               "createdAt":  "2019-03-05T14:05:33Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "D3-LucaPiombino",
                                                                               "createdAt":  "2020-01-31T12:48:56Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2023-12-25T13:06:12Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "benaadams",
                                           "body":  "\u003e Are you advocating that each class in the framework should also have a struct version to satisfy every potential need or programing approach?\n\nNo; just certain building blocks, that represent extensions over simple types. If you are dealing with small types like `int`, `decimal`, reference, when adding extra features to it you want to be as light as possible else the object overhead dominates; though there are reasons for both.\n\n`Task\u003cT\u003e`-\u003e`ValueTask\u003cT\u003e`\n`Tuple\u003cT1,T2,..\u003e`-\u003e`ValueTuple\u003cT1,T2,..\u003e` (not sure about `Tuple`)\n`lock(object)`-\u003e`SpinLock`\n`T[]`-\u003e`Span\u003cT\u003e`/`ReadOnlySpan\u003cT\u003e`\n`Atomic\u003cT\u003e`-\u003e`ValueAtomic\u003cT\u003e`\netc\n\nHowever, I do think it would be excellent if escape analysis was done on function allocated local objects and they were allocated on the stack if they didn\u0027t escape rather than the heap; but that\u0027s another story...\n",
                                           "updatedAt":  "2016-08-03T17:49:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzMxMzg5OQ==",
                                           "createdAt":  "2016-08-03T17:49:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "clrjunkie",
                                           "body":  "@benaadams \n\n\u003e If you were organising data in a column store manner and say the data type was Decimal (16 bytes) then if you wanted to do a Sum: \n\nBut your doing \u0027Sum\u0027... you would probably need to lock some range to get a consistent point in time snapshot, how does atomicity come into play here per data item??\n",
                                           "updatedAt":  "2016-08-03T17:49:46Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzMyMzQ2NQ==",
                                           "createdAt":  "2016-08-03T18:19:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "\u003e how does atomicity come into play here per data item\n\nMaybe poor example, call it `EstimatedSum` :) \n\nPreventing torn reads; admittedly you could get the same effect by using `Interlocked.CompareExchange` and having every entry an object; or if you were using object pooling a [128bit  `Interlocked.CompareExchange`](https://github.com/dotnet/corefx/issues/10478) which is kind of where this started as a more general form.\n",
                                           "updatedAt":  "2016-08-03T18:19:48Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzQwMzA5Nw==",
                                           "createdAt":  "2016-08-03T23:10:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "@clrjunkie my main motivation is for an `Interlocked.CompareExchange128` with a fallback on platforms that don\u0027t support it. The struct works as that, the class adds an extra allocation and indirection on the call for the supported route.\n",
                                           "updatedAt":  "2016-08-03T23:10:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzUwODYyMQ==",
                                           "createdAt":  "2016-08-04T09:57:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAkaVtg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "soerenBoisen",
                                                                               "createdAt":  "2019-03-05T14:06:51Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "clrjunkie",
                                           "body":  "@benaadams \n\n\u003e Going back to the Java comparison it has AtomicReferenceArray for similar.\n\nYou can’t infer from that a general requirement for optimized traversal of large arrays for the purpose of invoking an atomic operation on each element. Plus, the fact that support for atomicity is provided by the collection and not the element should encourage you to question why they decided to implement the collection in the first place and not stay with a simple array of [AtomicReference](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicReference.html)\n\n\u003e my main motivation is for an Interlocked.CompareExchange128 with a fallback on platforms that don\u0027t support it.\n\nFor what practical purpose(s)? \n\nIs this supported by any other major framework? (being on par is a valid motivation)\n\nDid Windows provide a public api for this (on supported platforms) \n\nYou wrote at the beginning that the availability of the api would allow for more interesting lock-less algorithms, great! Then I genuinely believe that it’s absolute must to include sample usage code that shows a scenario, at least in pseudo code, even from an academic paper.\n\nHow exactly are `Atomic\u003cT\u003e` and bitness related?\n\nBTW it reads like the cpu requirement for Windows 8.1 is for the enterprise edition.\n[Windows 8.1 Enterprise: System Requirements](https://technet.microsoft.com/en-us/windows/dn140267.aspx)\n\n\u003e The struct works as that, the class adds an extra allocation and indirection on the call for the supported route.\n\nI’m challenging the struct api, not the implementation, because:\n1. No obvious requirement stands out for traversing large lists of atomic’s specifically. \n2. I bet most developers would use at most one atomic instance per algorithm, experts 2 geniuses 3.\n3. Structs can be tricky, that is on top of synchronization which in itself is tricky.\n",
                                           "updatedAt":  "2016-08-04T09:57:51Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzUxMTQxNw==",
                                           "createdAt":  "2016-08-04T10:10:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "clrjunkie",
                                           "body":  "@benaadams\nMake no mistake, I would _love_ to see a use-case that takes advantage of the struct version and say, Aha!\n",
                                           "updatedAt":  "2016-08-04T10:10:01Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzU5MDYxMQ==",
                                           "createdAt":  "2016-08-04T15:33:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAkaWuw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "soerenBoisen",
                                                                               "createdAt":  "2019-03-05T14:10:30Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "benaadams",
                                           "body":  "\u003e Is this supported by any other major framework? (being on par is a valid motivation)\n\n(pre-C++ 11) Boost Atomic http://www.boost.org/doc/libs/master/doc/html/atomic/interface.html\nCLang/GCC C++ 11 std::atomic https://gcc.gnu.org/onlinedocs/gcc/_005f_005fatomic-Builtins.html\n\nJava [AtomicStampedReference](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicStampedReference.html) and [AtomicMarkableReference](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicMarkableReference.html)\n\nGoLang [bytecode decoder](https://github.com/golang/go/blob/master/src/cmd/vendor/golang.org/x/arch/x86/x86asm/decode.go#L1369-L1387) (Don\u0027t know much about Go so not sure how its used)\n\n\u003e Did Windows provide a public api for this (on supported platforms)\n\nGCC/Clang on Linux support it via std::atomic\n\nWindows via InterlockedCompareExchange128 https://msdn.microsoft.com/en-us/library/windows/desktop/hh972640%28v=vs.85%29.aspx (128bit std::atomic in MSVC isn\u0027t lock free)\n\nMin client: Windows 8; Min server: Windows Server 2012\n\n\u003e How exactly are `Atomic\u003cT\u003e` and bitness related?\n\nIs the dwCAS or lock-free 2x64bit swap; to be able to CAS for a 64bit pointer and marker ([ABA avoidance](https://en.wikipedia.org/wiki/ABA_problem) without GC) or 2x64bit pointer swap for double linked list.\n\n\u003e BTW it reads like the cpu requirement for Windows 8.1 is for the enterprise edition.\n\nIs for regular 8.1 x64 also https://support.microsoft.com/en-us/help/12660/windows-8-system-requirements (and Windows 10)\n\n\u003e To install a 64-bit OS on a 64-bit PC, your processor needs to support CMPXCHG16b, PrefetchW, and LAHF/SAHF\n\nIts been available on all AMD64 CPUs other than pre-2006 AMD ones, so all Intel have it. Which means MacOS/OSX also always have support. Requirement for Win 8.1 x64, Win 10 x64, Server 2012 R2 x64, Server 2016 x64.\n\nLinux x64, Win7 x64, Win8 x64 may be running on  first generation Opterons so would need fallback for x86 world (also for 32bit). Would also need fall backs for ARM (pre-ARMv[78]?).\n\n\u003e No obvious requirement stands out for traversing large lists of atomic’s specifically.\n\nMaybe something like Non-blocking Trees? http://www.cs.toronto.edu/~tabrown/chromatic/paper.pdf\n\n\u003e I bet most developers would use at most one atomic instance per algorithm\n\nStruct directly embedded in class rather than extra indirection? \n\nThere isn\u0027t a functionality gap that the struct would provide that the class couldn\u0027t. (Except it would probably be easier to align a specific struct on a 16byte boundary `ValueAtomic\u003cT\u003e` than a general struct `T` for `Atomic\u003cT\u003e`. If that aligned struct exists why not also expose it for use directly?)\n\nHowever, equally there isn\u0027t any functionality you can do with a 128bit CAS that you can\u0027t do with a lock. Its a performance reason where the direct struct is better than the class.\n\nAlso my main use case is around object pooling and memory management, rather than other lock-free data structures, so allocating another object to do it bothers me in principle :wink: \n\n\u003e Structs can be tricky\n\nHence the class variant also.\n\n\u003e You wrote at the beginning that the availability of the api would allow for more interesting lock-less algorithms, great! Then I genuinely believe that it’s absolute must to include sample usage code that shows a scenario, at least in pseudo code, even from an academic paper.\n\nWill aim to provide :smile: \n",
                                           "updatedAt":  "2016-08-04T15:33:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzYwOTU3OA==",
                                           "createdAt":  "2016-08-04T16:36:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "clrjunkie",
                                           "body":  "@benaadams\n\n\u003e (pre-C++ 11) Boost Atomic http://www.boost.org/doc/libs/master/doc/html/atomic/interface.html\n\nBingo.\n\n\u003e Windows via InterlockedCompareExchange128 https://msdn.microsoft.com/en-us/library/windows/desktop/hh972640%28v=vs.85%29.aspx (128bit std::atomic in MSVC isn\u0027t lock free)\n\nBingo^2.\n\n\u003e How exactly are `Atomic\u003cT\u003e` and bitness related?\n\u003e \n\u003e \u003e Is the dwCAS or lock-free 2x64bit swap; to be able to CAS for a 64bit pointer and marker (ABA avoidance without GC) or 2x64bit pointer swap for double linked list.\n\nDon\u0027t understand. Can you simplify?\n\n(edit: Don\u0027t understand how you got from 128bit to T)\n\n\u003e I bet most developers would use at most one atomic instance per algorithm\n\u003e \n\u003e \u003e Struct directly embedded in class rather than extra indirection?\n\nI was referring to atomic variables in general, in which case AFAIK accessing either a class or a struct declared at the field level would involve one indirection for both.\n\n\u003e Also my main use case is around object pooling and memory management,\n\nOh, I definitely got that.. :smiley:\n",
                                           "updatedAt":  "2016-08-04T18:34:09Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzY5MjMxNA==",
                                           "createdAt":  "2016-08-04T21:41:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "\u003e \u003e Is the dwCAS or lock-free 2x64bit swap; to be able to CAS for a 64bit pointer and marker (ABA avoidance without GC)\n\u003e \n\u003e Don\u0027t understand. Can you simplify?\n\nWas writing a response with some examples; discovered the api needs some tweaking... Might need to a full example set to get the api right :open_mouth: \n",
                                           "updatedAt":  "2016-08-04T21:41:05Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzc0ODM1Nw==",
                                           "createdAt":  "2016-08-05T03:45:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "Started an initial project that I\u0027ll explore this further in https://github.com/benaadams/System.Threading.Atomics\n",
                                           "updatedAt":  "2016-08-05T03:45:43Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzgyOTMyOQ==",
                                           "createdAt":  "2016-08-05T11:38:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "clrjunkie",
                                           "body":  "At this stage, I suggest you keep it driven towards one or two common scenarios. Skip the error handling. \n",
                                           "updatedAt":  "2016-08-05T11:38:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzg0MzczMQ==",
                                           "createdAt":  "2016-08-05T12:59:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "whoisj",
                                           "body":  "What if this is not already available via  the Volatile class? I\u0027m likely just missing something, so i wanted to ask.\n",
                                           "updatedAt":  "2016-08-05T12:59:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzg1NTA2Mw==",
                                           "createdAt":  "2016-08-05T13:49:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "clrjunkie",
                                           "body":  "@whoisj As I see it this API aims to be an OO abstraction for both volatile and interlocked operations - cross-platform. Apparently the API’s fallback capability (e.g use ‘lock’ when O/S doesn\u0027t support CPU instruction CMPXCHG16b) is too easily overlooked. @benaadams  might worth **highlighting** this at the very beginning, emphasizing that the \u0027lock fallback\u0027 is per _instance_. \n",
                                           "updatedAt":  "2016-08-05T13:49:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzk0NjEwMA==",
                                           "createdAt":  "2016-08-05T19:50:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAkaXOw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "soerenBoisen",
                                                                               "createdAt":  "2019-03-05T14:12:33Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "benaadams",
                                           "body":  "@whoisj Volatile and Interlocked are static classes representing actions on memory locations with 1:1 mapping of hardware capabilities so limited to the lowest common denominator (e.g. currently no 128 bit CAS)\n\nThe Atomic type is an abstraction on top; which allows fallbacks and also allows more complex behaviour to be captured in the types.\n\nIf for example you wanted to atomically count up, but to a maximum level, and atomically count down but only to a minimum. Then you\u0027d have to do something like this (taken from [ThreadPool.cs](https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/ThreadPool.cs#L568-L607))\n\n``` csharp\nint outstandingRequests;\n\ninternal void EnsureThreadRequested()\n{\n    // Add one to a maximum of processorCount\n    int count = Volatile.Read(ref outstandingRequests);\n    while (count \u003c processorCount)\n    {\n        int prev = Interlocked.CompareExchange(ref outstandingRequests, count + 1, count);\n        if (prev == count)\n        {\n            ThreadPool.RequestWorkerThread();\n            break;\n        }\n        count = prev;\n    }\n}\n\ninternal void MarkThreadRequestSatisfied()\n{\n    // Subtract one to a minimum of 0\n    int count = Volatile.Read(ref outstandingRequests);\n    while (count \u003e 0)\n    {\n        int prev = Interlocked.CompareExchange(ref outstandingRequests, count - 1, count);\n        if (prev == count)\n        {\n            break;\n        }\n        count = prev;\n    }\n}\n```\n\nWhereas with Atomic you could do\n\n``` csharp\nValueAtomic\u003cint\u003e outstandingRequests;\n\ninternal void EnsureThreadRequested()\n{\n    if (outstandingRequests.CappedIncrement(processorCount).Success)\n    {\n        ThreadPool.RequestWorkerThread();\n    }\n}\n\ninternal void MarkThreadRequestSatisfied()\n{\n    outstandingRequests.CappedDecrement(0);\n}\n```\n",
                                           "updatedAt":  "2016-08-05T19:56:40Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzNzk3NzQ0Mw==",
                                           "createdAt":  "2016-08-05T22:07:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "clrjunkie",
                                           "body":  "Both _CappedIncrement_ and _CappedDecrement_ should be listed under \"Proposed Api\" along with a clear explanation for why they should exist, specifically what does it mean to:  \n\n\u003e atomically count up, but to a maximum level \n",
                                           "updatedAt":  "2016-08-05T23:09:40Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzODA2MDY5OA==",
                                           "createdAt":  "2016-08-07T03:10:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "whoisj",
                                           "body":  "\u003e API’s fallback capability (e.g use ‘lock’ when O/S doesn\u0027t support CPU instruction CMPXCHG16b) is too easily overlooked.\n\n@clrjunkie Thanks, that\u0027s exactly what I was getting at. `Volatile` already does the `Monitor` fallback to gloss over hardware differences. I think the approach is novel, but I often feel the days of OO design are behind us and the work is moving more towards a functional future.\n",
                                           "updatedAt":  "2016-08-07T03:11:54Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzODQyOTU4Ng==",
                                           "createdAt":  "2016-08-09T01:40:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "@benaadams:\n\n\u003e ... and can fallback to locks when the data width is not supported on the platform\n\nMy understanding is that interlocked operations need to be atomic with respect to all other interlocked operations. So if the 128-bit interlocked compare-exchange operation is not supported by the processor and a lock is used instead, its implementation would not be atomic with respect to other 64-bit interlocked compare-exchange operations on the same data for instance.\n\nIf that\u0027s correct, then we cannot fall back to using locks, and have to instead provide an API that determines whether it\u0027s available, and have the 128-bit interlocked compare-exchange throw if attempted.\n\nI believe the 64-bit interlocked compare-exchange is available on all currently supported architectures, so it doesn\u0027t need such an API.\n",
                                           "updatedAt":  "2016-08-09T01:40:51Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzODQzNDAwMQ==",
                                           "createdAt":  "2016-08-09T02:13:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "\u003e If that\u0027s correct, then we cannot fall back to using locks, and have to instead provide an API that determines whether it\u0027s available, and have the 128-bit interlocked compare-exchange throw if attempted.\n\nAs the Atomic controls the reads and the writes they can both be locked; whether a `lock`, `spinlock`, reader/writer lock, left/right lock etc\n\n\u003e I believe the 64-bit interlocked compare-exchange is available on all currently supported architectures, so it doesn\u0027t need such an API.\n\nIt doesn\u0027t work for structs unless you cast through IntPtr which is a bit ugly; and that can only work up to 8 byte structs. If you used a 16 byte struct that can only by compare-exchanged on some platforms and being a struct there is no handle to use to provide a fall back; like-wise if you went bigger with 32 byte or 64 bytes - so it would need a generic constraint that was related to its `sizeof` which I\u0027d imagine wouldn\u0027t be forthcoming...\n",
                                           "updatedAt":  "2016-08-09T02:14:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzODQ0NjE1Mw==",
                                           "createdAt":  "2016-08-09T03:49:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "\u003e As the Atomic controls the reads and the writes they can both be locked; whether a lock, spinlock, reader/writer lock, left/right lock etc\n\nBut does that mean all interlocked operations need to use a lock just to support 128-bit interlocked compare-exchange, when it\u0027s not available in the processor?\n\n\u003e It doesn\u0027t work for structs unless you cast through IntPtr which is a bit ugly; and that can only work up to 8 byte structs\n\nI see\n",
                                           "updatedAt":  "2016-08-09T03:49:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzODQ0OTM2NA==",
                                           "createdAt":  "2016-08-09T04:18:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "whoisj",
                                           "body":  "The Windows operating system exposes these constructs, which means it\u0027s very possible to implement them on Intel and ARM.\n\nhttps://msdn.microsoft.com/en-us/library/windows/desktop/ms686360(v=vs.85).aspx\n\nLooks like they support quite a number of \"interlocked\" operations, up to 128 bits.\n\nGiven that the compiler often doesn\u0027t know the size of structs at \"compile\" time, I\u0027m not wholly sure how the library is supposed to know if it can safely do atomic operations on structs with intrinsics or not.\n",
                                           "updatedAt":  "2016-08-09T04:18:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzODQ0OTQ1Nw==",
                                           "createdAt":  "2016-08-09T04:19:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "\u003e But does that mean all interlocked operations need to use a lock just to support 128-bit interlocked compare-exchange, when it\u0027s not available in the processor?\n\nThey would need to use some kind of lock and both `ValueAtomic\u003cT\u003e` and `Atomic\u003cT\u003e` would have the `IsLockFree` boolean to allow the user to choose a different strategy if they felt the framework\u0027s choice of fallback locking mechanism wasn\u0027t suitable.\n\nBut for the majority of users they would be happy it was Atomic under all circumstances and hopefully the framework\u0027s choice of fallback lock would be suitable for the general case.\n",
                                           "updatedAt":  "2016-08-09T04:19:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzODQ0OTg1MQ==",
                                           "createdAt":  "2016-08-09T04:23:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "\u003e Given that the compiler often doesn\u0027t know the size of structs at \"compile\" time, I\u0027m not wholly sure how the library is supposed to know if it can safely do atomic operations on structs with intrinsics or not.\n\nIt could be done at jit time in the same way Vectors are done. For AOT it would know the sizes; but it would need to determine the available instructions at runtime. Both would need to work with up to 16byte alignment - so need to work with the allocator.\n",
                                           "updatedAt":  "2016-08-09T04:24:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzODQ1MDc3MQ==",
                                           "createdAt":  "2016-08-09T04:32:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "Independent of the framework you could probably over allocate then use the `Unsafe` library to cast to aligned structs; however I\u0027m not sure how it could safely be done with structs with references...\n",
                                           "updatedAt":  "2016-08-09T04:32:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzODQ3MTMyMA==",
                                           "createdAt":  "2016-08-09T07:06:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "clrjunkie",
                                           "body":  "@kouvel \n\n\u003e My understanding is that interlocked operations need to be atomic with respect to all other interlocked operations. So if the 128-bit interlocked compare-exchange operation is not supported by the processor and a lock is used instead, its implementation would not be atomic with respect to other 64-bit interlocked compare-exchange operations on the same data for instance.\n\nI think the first question is: what does it mean to do a 128 bit  interlocked compare-exchange operation on a T?\n",
                                           "updatedAt":  "2016-08-09T07:06:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzODQ3MTUzNA==",
                                           "createdAt":  "2016-08-09T07:07:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "clrjunkie",
                                           "body":  "@whoisj \n\n\u003e Given that the compiler often doesn\u0027t know the size of structs at \"compile\" time, I\u0027m not wholly sure how the library is supposed to know if it can safely do atomic operations on structs with intrinsics or not.\n\nExactly.\n",
                                           "updatedAt":  "2016-08-09T07:07:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIzODU2MDQ0Mg==",
                                           "createdAt":  "2016-08-09T13:55:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAkaYiw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "soerenBoisen",
                                                                               "createdAt":  "2019-03-05T14:16:59Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "whoisj",
                                           "body":  "\u003e Independent of the framework you could probably over allocate then use the Unsafe library to cast to aligned structs; however I\u0027m not sure how it could safely be done with structs with references...\n\nIt cannot. So we have a problem. Anything involving mutating a \"reference structure\" (ie any thing that is or contains a reference) cannot be treated as flat memory, therefore there are severe limiting factors here.\n\nHonestly, CRITICAL_SECTIONS are stupid fast, and `Monitor` relies heavily on them. With the added advantage that `Monitor` is likely highly tuned per platform. Why not just rely on it?\n\nIn test after real-world test, the `Monitor` approach has proven to equivalent, and occasionally better, than the non-locking model.\n\nI like `Atomic\u003cT\u003e`, but I think it needs to just rely on `Volatile.Read/Write` and `Monitor.Enter/Exit` to get things done.\n",
                                           "updatedAt":  "2016-08-09T13:56:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI0MDIzODQ0MA==",
                                           "createdAt":  "2016-08-16T21:04:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "@clrjunkie @whoisj here is an example of using tagged pointers from a recent Mono change http://www.mono-project.com/news/2016/08/16/lock-free-gc-handles/\n",
                                           "updatedAt":  "2016-08-16T21:04:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI0MzI0Nzg1NQ==",
                                           "createdAt":  "2016-08-29T20:37:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "@benaadams, (old news) MSVCRT as of VS2015 Update 3 has also implemented full set of C++11, 85%+ of C++14 and ~30% of C++17, 95% of C99 and 18% of C11 (all ISO standards). So std::atomic is available there as well: https://msdn.microsoft.com/en-us/library/hh567368.aspx#atomics :wink:\n",
                                           "updatedAt":  "2016-08-29T20:37:35Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI1NTg3MzA1Mg==",
                                           "createdAt":  "2016-10-24T21:34:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "@whoisj:\n\n\u003e The Windows operating system exposes these constructs, which means it\u0027s very possible to implement them on Intel and ARM.\n\u003e https://msdn.microsoft.com/en-us/library/windows/desktop/ms686360(v=vs.85).aspx\n\u003e Looks like they support quite a number of \"interlocked\" operations, up to 128 bits.\n\nIt looks like InterlockedCompareExchange128 is only available on x64 on Windows:\nhttps://msdn.microsoft.com/en-us/library/26td21ds.aspx\nhttps://msdn.microsoft.com/en-us/library/bb514094.aspx\n\n\u003e Anything involving mutating a \"reference structure\" (ie any thing that is or contains a reference) cannot be treated as flat memory, therefore there are severe limiting factors here.\n\nWhat is the issue with mutating a struct containing a reference? Why can it not be treated as flat memory?\n",
                                           "updatedAt":  "2016-10-24T21:34:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI1NTg3MzYwOA==",
                                           "createdAt":  "2016-10-24T21:37:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBpL5UQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nietras",
                                                                               "createdAt":  "2016-11-01T09:06:45Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "omariom",
                                                                               "createdAt":  "2021-04-30T11:46:31Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "kouvel",
                                           "body":  "I like the proposal, but I think it would be good to provide only a value type atomic (have `Atomic\u003cT\u003e` be a value type) and let the user determine how to store and use that data correctly so that multiple threads can share it. That would simplify it a bit and eliminate the interface, which I feel mostly wraps boxing, only marginally improves the usability, and may even add some confusion.\n\nIt looks like we would need the following:\n- At JIT time, per expansion of ValueAtomic\u003cT\u003e, determine if a sufficiently-sized interlocked compare-exchange is available on the platform\n- At JIT time, enforce alignment on ValueAtomic\u003cT\u003e if interlocked operations will be used. If a lock will be used, alignment is not necessary.\n- For ValueAtomic\u003cT\u003e types that can use interlocked operations, a CompareExchange would be replaced by the JIT with the instruction. IsLockFree could also behave as an intrinsic for these types.\n\n@benaadams, are you aware of any real-world scenarios that would greatly benefit from this feature? For instance, are there scenarios that are blocked from a performance perspective due to the inability of being able to do interlocked operations on structs?\n\nCC @jkotas @gkhanna79 @cmckinsey @vancem \n",
                                           "updatedAt":  "2016-10-24T21:37:09Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI1NTg4MzQ2OA==",
                                           "createdAt":  "2016-10-24T22:23:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "@kouvel there are a number of lock free algorithms that are blocked from not having it.\n\nSo for example the lock-free Concurrent collections and the threadpool queues can\u0027t be fully non-allocating and use pooled nodes as they would suffer from the [ABA problem](https://en.wikipedia.org/wiki/ABA_problem). With the 128 bit CAS then you can add a state/tag/counter to the pointer to resolve this.\n\nA 128 bit CAS by itself https://github.com/dotnet/corefx/issues/10478 will only work on certain CPU classes; so the Atomic is better as it provides a lock fallback so can work on all platforms; though obviously less than ideal on some. For example it may be preferable to allocate and still be lock free if locking is involved - hence the static `IsLockFree` bool; which allows you to choose the algorithm if that is important.\n",
                                           "updatedAt":  "2016-10-24T22:27:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI1NTg4NjM2Mw==",
                                           "createdAt":  "2016-10-24T22:39:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAwRCiw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nietras",
                                                                               "createdAt":  "2016-11-01T09:08:52Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MendelMonteiro",
                                                                               "createdAt":  "2019-09-10T12:00:30Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "vancem",
                                           "body":  "There is a fair bit of detail here, and I have not really given it too much thought, but I have some observations / concerns.\n\n1) It is VERY easy to get low-lock code correct, so ideally uses of Atomic would be RARE.   Thus the \u0027benefit\u0027 part of a cost-benefit analysis is not going to be high (since relatively few users benefit).  This argues AGAINST doing anything tricky (e.g. special JIT support etc).   It also argues to keep the implementation \u0027light\u0027 (simple/small).   This argues against the IAtomic interface unless we can clearly articulate the extra value it adds.   \n\n2) It is unclear how the alignment restrictions of a CAS128 would be handled.  To guarantee alignment, we need the GC heap to be as aligned (because objects move around and they have to continue to be aligned)     The more aligned the GC heap is, the more \u0027waste\u0027 you have, so we really don\u0027t want to align the GC heap more than we have to (e.g. pointer sized).    It is unclear how to resolve this tradeoff.  \n\n3) Given that I am arguing that simplicity is king we have to compare this against the \u0027trivial\u0027 solution of defining an Int128 and defining \n\n```\nInterlocked.InterlockedCompareExchange(ref Int128, Int128, Int128)\n```\n\nNote that even if we did decide to do implement Atomic\u003cT\u003e, we probably want implement it by providing low level support (like the Interlocked operation above), and then implement Atomic\u003cT\u003e on top of it.   This keeps the runtime small.    If we can\u0027t do that (that is we need magic), we need to think about it because by issue (1) above, this is probably not worth implementing much magic.\n\nHaving said all this, I am aware that most other languages/systems do implement something very much like Atomic\u003cT\u003e, so you can argue that this just filling a competitive hole.  However I would like this hole filled with as little magic as possible.   Ideally it is a class library sitting on top of very little magic support in CoreCLR.  \n",
                                           "updatedAt":  "2016-10-24T22:39:18Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI1NTg4ODY3NA==",
                                           "createdAt":  "2016-10-24T22:52:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "@vancem https://github.com/dotnet/corefx/issues/10478 is for 128 bit `InterlockedCompareExchange`; but then you still need alignment for the Int128s which can\u0027t be guaranteed for arbitrary structs and has no fallback for when there is either no cpu support (x86, some arm) or platform support (not implemented in the clr yet)\n",
                                           "updatedAt":  "2016-10-24T22:52:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI1NTkwMDMyNQ==",
                                           "createdAt":  "2016-10-25T00:06:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vancem",
                                           "body":  "Yes, it seems that magic is needed to solve the alignment issues for CAS128, which makes its cost higher and thus its cost-benefit proposition worse.    Right now we don\u0027t really have a thought-through design for CAS128, and it \u0027feels\u0027 like it is probably too expensive for its value (so far at least...).\n\nIf we want to proceed with this, we need to clearly articulate the cost (how we would solve the alignment issue and how expensive that would be), as well as the value (how much faster would these lock-free algorithms be from what we have today.\n\nP.S: (slightly off topic, but is relevant in deciding how much better CAS128 algorithms are from Cas64 algorithms.  \n\nFor what it is worth in garbage collected systems when you are playing with GC references (which you typically are) the ABA problem is sometimes not as problematic, because, unlike native code, a reference can\u0027t change identity (can\u0027t be deleted and that same memory morphed into a different object), as long as there is an object reference pointing at it (which you typically naturally have in the code doing the update).    \n\nFor example normally implementing a linked list stack with PUSH and POP operations would suffer from the ABA problem if POP was implemented in the \u0027obvious\u0027 way with CAS.    However that implementation DOES work in a GC environment if the list never tries to reuse link cells because the linked list element being POPed can\u0027t be recycled (and thus mutated) while the POP operation has a reference to it.   \n",
                                           "updatedAt":  "2016-10-25T00:06:18Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI1NTkwOTk5Nw==",
                                           "createdAt":  "2016-10-25T01:17:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAkabMA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nietras",
                                                                               "createdAt":  "2016-11-05T18:13:23Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "omariom",
                                                                               "createdAt":  "2018-05-07T19:43:22Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "soerenBoisen",
                                                                               "createdAt":  "2019-03-05T14:25:29Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "benaadams",
                                           "body":  "@vancem yes, I mean you can\u0027t do object pooling + CAS on x64 in .NET currently; you can only do GC + CAS on x64.\n\nYou could in theory do object pooling + CAS on x86 in .NET though I haven\u0027t investigated that particularly as its not relevant to my domain (need Vector ops too much)\n",
                                           "updatedAt":  "2016-10-25T01:17:37Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI5NTk5MDA5MQ==",
                                           "createdAt":  "2017-04-21T00:44:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "Even javascript is getting Atomic 😱  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics",
                                           "updatedAt":  "2017-04-21T00:44:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQwMTIzMTI2Mg==",
                                           "createdAt":  "2018-06-29T02:46:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "What\u0027s the current status on this? If it\u0027s unlikely to be done in the near future I\u0027m going to reopen the proposal for the extra bitwise APIs on `Interlocked` given that there are immediate use cases for it and we\u0027re already making changes to that type.",
                                           "updatedAt":  "2018-06-29T02:46:18Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQwNDAwMjI1Ng==",
                                           "createdAt":  "2018-07-10T23:58:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "It seems unlikely to happen in the near future. `Interlocked` should probably have the equivalent bare operations despite this type anyway.",
                                           "updatedAt":  "2018-07-10T23:58:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4Mzc5MDE3Mw==",
                                           "createdAt":  "2019-04-16T18:26:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MBurtsev",
                                           "body":  "A year has passed but nothing has moved )",
                                           "updatedAt":  "2019-04-16T18:26:47Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYxODQ2MDkwMQ==",
                                           "createdAt":  "2020-04-23T15:22:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "zachsawcs",
                                           "body":  "An array backed concurrent stack such as the Stroustrup one would need the CAS128 instruction to avoid ABA. Our problem with the LinkedList based concurrent stack implementation is that we have several million long lived items, and they get popped and pushed over time but the ones lower in the stack generally don\u0027t change too much. These items don\u0027t get cleaned up until Gen2 runs and the few millions that haven\u0027t changed still need its pointers traced by the GC. Stroustrup\u0027s implementation creates a lot of short lived objects if you have contention but these will never get past ephemeral gens. If CAS128 is available, Stroustrup\u0027s algo could be a good replacement for the current ConcurrentStack implementation,",
                                           "updatedAt":  "2020-04-23T15:22:47Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYxODg1NDE0Nw==",
                                           "createdAt":  "2020-04-24T07:33:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ayende",
                                           "body":  "@zachsawcs Do you have reference for that impl?",
                                           "updatedAt":  "2020-04-24T07:33:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYxODk3NzgxMg==",
                                           "createdAt":  "2020-04-24T12:24:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODQfrGw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "viktor-svub",
                                                                               "createdAt":  "2021-06-18T08:03:22Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2023-12-25T13:06:19Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "zachsawcs",
                                           "body":  "http://www.stroustrup.com/lock-free-vector.pdf\r\n\r\nI implemented it from the paper above, but ran into all sorts of trouble with C# - Interlocked.CompareExchange was the first problem preventing me from creating a generic typed ConcurrentStack\u003cT\u003e. I managed to workaround that by doing unsafe cast (Unsafe.As) with a factory for the different types.\r\n\r\nBut the biggest problem was C# just doesn\u0027t support 128-bit compare exchange, preventing me from solving the ABA problem for 64-bit data types. There\u0027s currently no way to implement such an algo in C#.",
                                           "updatedAt":  "2020-04-25T04:12:18Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYxOTAwMjA0Mw==",
                                           "createdAt":  "2020-04-24T13:16:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "samsosa",
                                           "body":  "Related: https://github.com/dotnet/runtime/issues/31911",
                                           "updatedAt":  "2020-04-24T13:16:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HTB6Q",
                                           "createdAt":  "2022-07-27T01:36:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "This would help [ManualResetValueTaskSourceCore](https://github.com/dotnet/runtime/blob/1f989749fbaf196ef966a73cc86bebe2be13fad3/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Sources/ManualResetValueTaskSourceCore.cs#L146-L159) where it is theoretically possible for a race condition to cause the wrong state object to be used (even though that would be user error anyway). And the extra null check could be removed.\r\n\r\nhttps://github.com/dotnet/runtime/blob/1f989749fbaf196ef966a73cc86bebe2be13fad3/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Sources/ManualResetValueTaskSourceCore.cs#L146-L159\r\n\r\n[Edit] Or I guess #31911 would solve the same problem.",
                                           "updatedAt":  "2022-07-27T02:00:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5QixYw",
                                           "createdAt":  "2022-12-14T12:47:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEcEnjw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "tkent",
                                                                               "createdAt":  "2023-03-18T21:03:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "MineCake147E",
                                                                               "createdAt":  "2023-08-17T08:42:15Z"
                                                                           },
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2023-12-25T13:06:35Z"
                                                                           },
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "miyu",
                                                                               "createdAt":  "2025-02-23T18:58:23Z"
                                                                           },
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "ZimM-LostPolygon",
                                                                               "createdAt":  "2025-07-27T14:08:03Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  5
                                                         },
                                           "author":  "bamo-volue",
                                           "body":  "Any update on this? \r\nLack of a threadsafe lockfree wrapper type (e.g. over bool), that is intuitive to work with, seems to me like a significant defect in the language, considering even c++ has had std::atomic since c++11",
                                           "updatedAt":  "2022-12-14T12:48:12Z"
                                       }
                                   ],
                         "totalCount":  69
                     },
        "title":  "Proposal: Atomic\u003cT\u003e (corefx)",
        "labels":  [
                       "api-needs-work",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/20025",
        "createdAt":  "2017-01-25T23:13:08Z",
        "number":  20025,
        "author":  "davidfowl",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODLBCHg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "JonHanna",
                                            "createdAt":  "2017-01-26T00:00:49Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jnm2",
                                            "createdAt":  "2017-01-26T15:02:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ReubenBond",
                                            "createdAt":  "2019-05-17T17:14:42Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "avo32768",
                                            "createdAt":  "2019-11-29T08:32:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "noseratio",
                                            "createdAt":  "2020-06-02T12:22:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "OutSorcerer",
                                            "createdAt":  "2020-06-20T19:13:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "alex-novikov-1990",
                                            "createdAt":  "2020-07-11T13:10:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "avatards",
                                            "createdAt":  "2020-07-26T12:51:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "michaelstonis",
                                            "createdAt":  "2020-09-29T01:10:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "juner",
                                            "createdAt":  "2020-11-12T07:45:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "vladd",
                                            "createdAt":  "2020-12-16T14:17:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "theodorzoulias",
                                            "createdAt":  "2020-12-26T20:47:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sipsorcery",
                                            "createdAt":  "2021-01-25T22:16:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Kira-NT",
                                            "createdAt":  "2021-02-28T17:15:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pentp",
                                            "createdAt":  "2021-03-02T19:25:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mrlacey",
                                            "createdAt":  "2022-01-15T14:50:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "alexrp",
                                            "createdAt":  "2022-05-11T14:37:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "TheCodeTraveler",
                                            "createdAt":  "2022-10-21T01:58:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rodion-m",
                                            "createdAt":  "2023-03-07T20:41:32Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "cremor",
                                            "createdAt":  "2023-03-19T12:23:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Neme12",
                                            "createdAt":  "2024-03-30T17:16:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "omariom",
                                            "createdAt":  "2024-03-30T23:03:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Fresa",
                                            "createdAt":  "2024-04-23T12:34:32Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Sergio0694",
                                            "createdAt":  "2024-04-24T18:53:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2024-04-24T21:08:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dlyz",
                                            "createdAt":  "2024-10-22T09:20:25Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2025-02-07T14:27:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "campersau",
                                            "createdAt":  "2025-02-09T07:46:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "KirisameY",
                                            "createdAt":  "2025-02-24T07:16:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "angelofb",
                                            "createdAt":  "2025-08-13T10:22:38Z"
                                        }
                                    ],
                          "totalCount":  30
                      },
        "updatedAt":  "2025-02-07T21:30:51Z",
        "body":  "`Task.Run` breaks the execution flow by forcing the code into a delegate, it\u0027s basically callback hell (since it\u0027s the first callback in the chain). Instead, for the situations where we want to stay in the await pattern, `ThreadPool.Yield()` would be a nice to have API. It would turn code that looks like this:\r\n\r\n```C#\r\nawait Task.Run(() =\u003e DoSomething());\r\n```\r\n\r\n```C#\r\nawait ThreadPool.Yield();\r\n\r\n// Now on a thread pool thread so we can call some user code\r\nDoSomething();\r\n```\r\n\r\n/cc @stephentoub ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOnZrDRA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI3NTI2NjEwNA==",
                                           "createdAt":  "2017-01-25T23:31:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEFqq4Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "JonHanna",
                                                                               "createdAt":  "2017-01-26T00:01:05Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jnm2",
                                                                               "createdAt":  "2017-01-26T15:02:45Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alexperovich",
                                                                               "createdAt":  "2017-01-26T19:58:55Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kevingosse",
                                                                               "createdAt":  "2017-09-10T11:42:19Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pentp",
                                                                               "createdAt":  "2021-03-02T19:25:19Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "vladd",
                                                                               "createdAt":  "2023-10-07T00:37:54Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "EgorBo",
                                                                               "createdAt":  "2025-02-07T18:51:24Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  7
                                                         },
                                           "author":  "omariom",
                                           "body":  "SwitchTo?",
                                           "updatedAt":  "2017-01-25T23:31:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI3NTI2NzQzNg==",
                                           "createdAt":  "2017-01-25T23:38:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEFo5tQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "popcatalin81",
                                                                               "createdAt":  "2019-12-10T17:00:25Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alex-novikov-1990",
                                                                               "createdAt":  "2020-07-11T13:10:15Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2025-02-07T14:27:17Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "Was keeping in line with `Task.Yield()`",
                                           "updatedAt":  "2017-01-25T23:38:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI3NTI3MDYxNg==",
                                           "createdAt":  "2017-01-25T23:56:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEHVIuw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jnm2",
                                                                               "createdAt":  "2017-01-26T15:02:43Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nietras",
                                                                               "createdAt":  "2017-01-27T10:31:18Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "noseratio",
                                                                               "createdAt":  "2019-11-29T05:55:52Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "avo32768",
                                                                               "createdAt":  "2019-11-29T08:32:41Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "popcatalin81",
                                                                               "createdAt":  "2019-12-10T17:01:20Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "vladd",
                                                                               "createdAt":  "2020-12-16T14:17:35Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Frassle",
                                                                               "createdAt":  "2021-11-03T12:56:13Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "reflectronic",
                                                                               "createdAt":  "2024-04-24T21:27:28Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2025-02-07T14:27:23Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "KirisameY",
                                                                               "createdAt":  "2025-02-24T07:16:56Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  10
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "I agree this is a pretty reasonable thing to add.  In the original async/await CTP, we actually had methods for doing this, IIRC as extensions on a TaskScheduler and SynchronizationContext, e.g.\r\n```C#\r\nawait TaskScheduler.Default.SwitchTo(); // continuation will be queued to the thread pool\r\n```\r\nWe removed these because you couldn\u0027t use an await inside of a catch/finally, which meant it was difficult to return to the original context if you were trying to do something structured like:\r\n```C#\r\nvar origScheduler = TaskScheduler.Current;\r\nawait TaskScheduler.Default.SwitchTo();\r\ntry\r\n{\r\n    ... // runs on thread pool\r\n}\r\nfinally { await origScheduler; }\r\n```\r\nand as a result you could end up in situations where error related logic would run on the \"wrong\" context; in a sense we were concerned we were adding APIs that would lead to dangerous situations.  However, C# has since gained the ability to have awaits in catch/finally blocks, making that largely a moot argument.\r\n\r\nI would personally also err on the side of using a name more like SwitchTo.  The Yield naming was intended to suggest yielding and coming back to the current context, so using it to mean \"go to that other context\" might be a little confusing.",
                                           "updatedAt":  "2017-01-25T23:57:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI3NTI3MTc5Ng==",
                                           "createdAt":  "2017-01-26T00:02:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEFo5yw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "jnm2",
                                                                               "createdAt":  "2017-01-26T15:02:59Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "alexperovich",
                                                                               "createdAt":  "2017-01-26T19:56:39Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "nietras",
                                                                               "createdAt":  "2017-01-27T10:31:37Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "avo32768",
                                                                               "createdAt":  "2019-11-29T08:32:51Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "noseratio",
                                                                               "createdAt":  "2019-11-29T10:19:55Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "popcatalin81",
                                                                               "createdAt":  "2019-12-10T17:01:37Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "noseratio",
                                                                               "createdAt":  "2020-07-14T11:50:54Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "Frassle",
                                                                               "createdAt":  "2021-11-03T12:56:18Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "AmrAlSayed0",
                                                                               "createdAt":  "2021-11-08T16:27:04Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AmrAlSayed0",
                                                                               "createdAt":  "2021-11-08T16:27:07Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2025-02-07T14:27:27Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  11
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "SwitchTo sounds fine to me.\r\n\r\n\u003e However, C# has since gained the ability to have awaits in catch/finally blocks, making that largely a moot argument.\r\n\r\nIf we ever get async disposable maybe that pattern could be more natural.\r\n\r\n```C#\r\nawait using (TaskScheduler.Current.Preserve())\r\n{\r\n    await TaskScheduler.Default.SwitchTo();\r\n    // Do thread pool stuff\r\n} // Revert to the original scheduler\r\n```",
                                           "updatedAt":  "2017-01-26T00:02:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI3NTI4MjY2MQ==",
                                           "createdAt":  "2017-01-26T01:11:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "Should it check if already on threadpool/scheduler and immediately complete if so?",
                                           "updatedAt":  "2017-01-26T01:11:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI3NTI4ODQ5OA==",
                                           "createdAt":  "2017-01-26T01:49:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBh84UQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "davidfowl",
                                                                               "createdAt":  "2017-01-26T08:17:35Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jnm2",
                                                                               "createdAt":  "2017-01-26T15:03:09Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pentp",
                                                                               "createdAt":  "2021-03-02T19:26:44Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Should it check if already on threadpool/scheduler and immediately complete if so?\r\n\r\nIt would depend on your scenario. For example, if you were using it to ensure that a caller of your async API wasn\u0027t blocked while doing some long computation, then you\u0027d want it to always queue. But if you were using it to ensure you were running on a context that owned done resources only accessible to that context, you wouldn\u0027t care and for perf might want it to nop.",
                                           "updatedAt":  "2017-01-26T01:50:18Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU1OTc0Mjg0MA==",
                                           "createdAt":  "2019-11-29T10:29:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "noseratio",
                                           "body":  "@davidfowl, now we have `IAsyncDisposable` and this still looks nice, indeed:\r\n\r\n```\r\nawait using (TaskScheduler.Current.Preserve())\r\n{\r\n    await TaskScheduler.Default.SwitchTo();\r\n    // Do thread pool stuff\r\n} // Revert to the original scheduler\r\n```\r\n\r\nBut I feel it is no different from:\r\n\r\n```\r\nawait Task.Run(async() =\u003e {\r\n    // do thread pool stuff \r\n    // (or async stuff without sync context)\r\n}); // Revert to the original sync context - without ConfigireAwait(false)\r\n```\r\n\r\nIs there any subtle difference?\r\n\r\n",
                                           "updatedAt":  "2019-11-29T10:30:01Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2MjczOTQ1MQ==",
                                           "createdAt":  "2019-12-06T21:14:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOA2vLrA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "noseratio",
                                                                               "createdAt":  "2019-12-06T22:38:27Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Is there any subtle difference?\r\n\r\nPotentially perf, but functionally I\u0027d expect them to be the same.  That said, the former doesn\u0027t exist, so it\u0027s hard to say for sure.",
                                           "updatedAt":  "2019-12-06T21:14:46Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2NDA0NDQ4NA==",
                                           "createdAt":  "2019-12-10T13:59:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "supervos",
                                           "body":  "Wouldn\u0027t it be possible to have the `SwitchTo` to pass in your `TaskScheduler`. The return value is an async dispobable that contains the previous `TaskScheduler`.\r\n\r\nA use case is where you have a limited access to a resource like a database connection or external API service. Together with the async disposable, you can create something like the following:\r\n\r\n```csharp\r\nprivate TaskScheduler _limitedResource = new LimitedTaskScheduler(10);\r\n\r\nawait using (Task.SwitchTo(_limitedResource))\r\n{\r\n  // Use resource with limited concurrent access\r\n}\r\n```\r\n\r\nPlacing the `SwitchTo` on the `Task` would make it more visible for people who are not aware of the existence of the `TaskScheduler`.\r\n\r\nAn overload to this method can accept a boolean indicating whether you must always switch or only if you are running on a different context than the provided one.",
                                           "updatedAt":  "2019-12-10T14:24:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2NTE0ODU4Nw==",
                                           "createdAt":  "2019-12-12T19:25:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBWh4Zw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "noseratio",
                                                                               "createdAt":  "2020-07-03T22:27:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "juner",
                                                                               "createdAt":  "2020-11-12T07:46:40Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "jnm2",
                                           "body":  "Could the API take a cancellation token? Making the SwitchTo implementation aware of cancellation could avoid queuing work on the thread pool when already canceled.\r\n\r\nIt would be a single call, replacing:\r\n\r\n```cs\r\ncancellationToken.ThrowIfCancellationRequested();\r\nawait TaskScheduler.Default.SwitchTo();\r\ncancellationToken.ThrowIfCancellationRequested();\r\n```\r\n\r\nUsage:\r\n\r\n```cs\r\npublic static async IAsyncEnumerable\u003cstring\u003e EnumerateFilesAsync(\r\n    string path,\r\n    string searchPattern,\r\n    SearchOption searchOption,\r\n    [EnumeratorCancellation] CancellationToken cancellationToken)\r\n{\r\n    await TaskScheduler.Default.SwitchTo(cancellationToken);\r\n\r\n    foreach (var file in Directory.EnumerateFiles(path, searchPattern, searchOption))\r\n    {\r\n        yield return file;\r\n\r\n        await TaskScheduler.Default.SwitchTo(cancellationToken);\r\n    }\r\n}\r\n```\r\n\r\nMaybe not relevant to how .NET Core would implement it, but this implementation actually passes the cancellation token to TaskFactory.StartNew when switching to a non-default task scheduler: https://gist.github.com/jnm2/46a642d2c9f2794ece0b095ba3d96270",
                                           "updatedAt":  "2019-12-12T19:25:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2NTQwNDYyNg==",
                                           "createdAt":  "2019-12-13T11:17:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBJW2lg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "noseratio",
                                                                               "createdAt":  "2020-07-03T22:28:41Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "omariom",
                                           "body":  "@noseratio\r\n```C#\r\nawait using (TaskScheduler.Current.Preserve())\r\n{\r\n    await TaskScheduler.Default.SwitchTo();\r\n    // Do thread pool stuff\r\n} // Revert to the original scheduler\r\n```\r\nIt could be simplified to \r\n```C#\r\nawait using (await TaskScheduler.Default.SwitchTo())\r\n{\r\n}\r\n```",
                                           "updatedAt":  "2019-12-13T11:17:04Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2NTQzODIxMw==",
                                           "createdAt":  "2019-12-13T13:18:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBQpcAA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "noseratio",
                                                                               "createdAt":  "2020-09-17T00:52:14Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jnm2",
                                           "body":  "I don\u0027t like having `await TaskScheduler.Default.SwitchTo()` produce an IAsyncDisposable. It\u0027s much rarer that I\u0027ll want to revert to the original scheduler. In the 99% case, I\u0027ll get IDE warnings that I\u0027m not disposing a disposable object.",
                                           "updatedAt":  "2019-12-13T13:18:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2NTQ2NTkxMA==",
                                           "createdAt":  "2019-12-13T14:43:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "omariom",
                                           "body":  "It must implement it via async disposable pattern, with `DisposeAsync` returning a struct instead of ValueTask. \r\n",
                                           "updatedAt":  "2019-12-13T14:43:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2NTQ2NzAyMQ==",
                                           "createdAt":  "2019-12-13T14:46:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBa9q-A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "omariom",
                                                                               "createdAt":  "2019-12-13T15:35:11Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "theodorzoulias",
                                                                               "createdAt":  "2020-12-26T21:04:05Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "jnm2",
                                           "body":  "The IDE will (should!) still warn when a type follows the async disposable pattern and is not disposed, and I wouldn\u0027t like that for this API.\r\n\r\nMaybe `_ = await TaskScheduler.Default.SwitchTo();` would be okay as a way to silence, but the name `SwitchTo` doesn\u0027t make it obvious what is being discarded. And we\u0027re making the 99% case less optimal for the sake of the 1%. It seems more fitting for the rarer case to use the additional `.Preserve()` call. On top of that, the name `Preserve` is significantly more self-documenting",
                                           "updatedAt":  "2019-12-13T14:47:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMDM5NzI4OA==",
                                           "createdAt":  "2020-09-29T03:03:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "noseratio",
                                           "body":  "Is `TaskSheduler.SwitchTo` still planned for 6.0? \r\n\r\nIt\u0027d be really useful where we deal we a 3rd party code that we don\u0027t want to execute on any custom synchronization context.\r\nE.g., I really like the simplicity of the first option from the below. IMO, it clearly indicates the intent, with minimum boilerplate code, and it\u0027s also free of some corner cases (unlike the last option):\r\n\r\n```csharp\r\n// switch to the thread pool explicitly for the rest of the async method\r\nawait TaskScheduler.Default.SwitchTo();\r\nawait RunOneWorkflowAsync();\r\nawait RunAnotherWorkflowAsync();\r\n```\r\n---\r\n```csharp\r\n// execute RunOneWorkflowAsync on the thread pool \r\n// and stay there for the rest of the async method\r\nawait Task.Run(RunOneWorkflowAsync).ConfigureAwait(false);\r\nawait RunAnotherWorkflowAsync();\r\n```\r\n---\r\n```C#\r\nawait Task.Run(async () =\u003e \r\n{\r\n  // start on the thread pool\r\n  await RunOneWorkflowAsync();\r\n  await RunAnotherWorkflowAsync();\r\n}).ConfigureAwait(false);\r\n// continue on the thread pool for the rest of the async method\r\n```\r\n---\r\n```csharp\r\n// start on whatever the current synchronization context is\r\nawait RunOneWorkflowAsync().ConfigureAwait(false);\r\n// continue on the thread pool for the rest of the async method,\r\n// unless everything inside `RunOneWorkflowAsync` has completed synchronously\r\nawait RunAnotherWorkflowAsync();\r\n```\r\n\r\nI have an experimental implementation of `SwitchTo` as an extension method ([gist](https://gist.github.com/noseratio/5d2d5f2a0cbb71b7880ce731c3958e62)), it needs some work and tests and I\u0027d be happy to contribute that as a PR for 6.0.\r\n ",
                                           "updatedAt":  "2020-09-29T07:04:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMDY4OTk4Mw==",
                                           "createdAt":  "2020-09-29T13:07:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC2Jvww==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "noseratio",
                                                                               "createdAt":  "2020-09-29T13:26:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "theodorzoulias",
                                                                               "createdAt":  "2023-02-15T23:02:48Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "AArnott",
                                           "body":  "@noseratio the syntax you want already works if you reference the Microsoft.VisualStudio.Threading Nuget package. ",
                                           "updatedAt":  "2020-09-29T13:07:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMDcxNDYzMg==",
                                           "createdAt":  "2020-09-29T13:46:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "noseratio",
                                           "body":  "\u003e the syntax you want already works if you reference the Microsoft.VisualStudio.Threading Nuget package.\r\n\r\n@AArnott thanks for the pointer, didn\u0027t know that had also been open-sourced! 👍\r\n\r\nIt\u0027s good to see the `alwaysYield` param there as well, mindlike! Do you think [supressing `ExecutionContext` flow](https://gist.github.com/noseratio/5d2d5f2a0cbb71b7880ce731c3958e62#file-taskschedulerawaiter-cs-L86) for non-default task schedulers is an overkill?\r\n\r\nI\u0027m curious to know if this `SwitchTo` pattern get used a lot in Visual Studio itself. I generally like it much more than async lambda to `Task.Run`. The latter IMHO should only be used for synchronous lambdas which do some CPU-bound work.\r\n",
                                           "updatedAt":  "2020-09-29T13:46:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMTQ1MDU4OA==",
                                           "createdAt":  "2020-09-30T15:05:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC2JwIA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "noseratio",
                                                                               "createdAt":  "2020-09-30T23:59:38Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "theodorzoulias",
                                                                               "createdAt":  "2023-02-15T23:05:06Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "AArnott",
                                           "body":  "I don\u0027t know why I\u0027d want to suppress ExecutionContext flow. But I\u0027m open to learning. The whole distinction between safe and unsafe awaiters is one I\u0027m not particularly strong on.\r\n\r\nWe only explicitly call `SwitchTo` when we want to use `alwaysYield: true`. Otherwise we just await on the `TaskScheduler` directly (since we made that awaitable as well). \r\nAnd yes, we generally prefer `await TaskScheduler.Default;` over `await Task.Run` because not only the code is cleaner, but we avoid allocating another closure, delegate, and async state machine since the calling method already has all those that can be reused. However, using `await taskScheduler` causes us to lose our caller\u0027s context. So if we want to return to our caller\u0027s context (e.g. the main thread) then using `await Task.Run` is an easy way to do some amount of work on the threadpool but then return to our caller\u0027s context when we\u0027re done.",
                                           "updatedAt":  "2020-09-30T15:05:18Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMTQ2MjQzMg==",
                                           "createdAt":  "2020-09-30T15:24:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBSEnKg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AArnott",
                                                                               "createdAt":  "2020-09-30T15:28:47Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "noseratio",
                                                                               "createdAt":  "2020-10-01T03:15:00Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "jnm2",
                                           "body":  "\u003e I don\u0027t know why I\u0027d want to suppress ExecutionContext flow. But I\u0027m open to learning. The whole distinction between safe and unsafe awaiters is one I\u0027m not particularly strong on.\r\n\r\nThis explained things for me: https://devblogs.microsoft.com/pfxteam/whats-new-for-parallelism-in-net-4-5-beta/\r\nCtrl+F for `For those of you familiar with ExecutionContext`.",
                                           "updatedAt":  "2020-09-30T15:24:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMTQ2ODM4Nw==",
                                           "createdAt":  "2020-09-30T15:33:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "I don\u0027t know why you\u0027d want to suppress the execution context flow as part of this either. Seems entirely unrelated here. Maybe there\u0027s some common scenario I\u0027m missing?",
                                           "updatedAt":  "2020-09-30T15:33:34Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMTQ4NjA0Mg==",
                                           "createdAt":  "2020-09-30T16:02:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBSEmZw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "noseratio",
                                                                               "createdAt":  "2020-10-01T03:11:07Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "AArnott",
                                           "body":  "I think we could do a better job of suppressing ExecutionFlow in some of our awaiters: https://github.com/microsoft/vs-threading/pull/689",
                                           "updatedAt":  "2020-09-30T16:02:10Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMTcxMDU5Ng==",
                                           "createdAt":  "2020-10-01T00:10:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "noseratio",
                                           "body":  "\u003e I don\u0027t know why you\u0027d want to suppress the execution context flow as part of this either. Seems entirely unrelated here. Maybe there\u0027s some common scenario I\u0027m missing?\r\n\r\n@davidfowl  and  @AArnott  I might be wrong, but I think it might be a sensible optimization for `ICriticalNotifyCompletion.UnsafeOnCompleted`. We don\u0027t have to flow execution context there, but `Task.Factory.StartNew` would still do that, adding a bit of unneeded overhead. I believe suppressing the flow explicitly tells `Task.Factory.StartNew` to not do that.\r\n\r\nThis is not a concern for `TaskScheduler.Default`, for which can just use `ThreadPool.UnsafeQueueUserWorkItem`.",
                                           "updatedAt":  "2020-10-01T00:11:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMTcxNDk2Ng==",
                                           "createdAt":  "2020-10-01T00:26:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "noseratio",
                                           "body":  "\u003e And yes, we generally prefer `await TaskScheduler.Default;` over `await Task.Run` because not only the code is cleaner, but we avoid allocating another closure, delegate, and async state machine since the calling method already has all those that can be reused. However, using `await taskScheduler` causes us to lose our caller\u0027s context.\r\n\r\nThat makes sense. I usually use `await TaskScheduler.Default` at the beginning of the methods that don\u0027t touch the UI or ViewModel at all. ",
                                           "updatedAt":  "2020-10-01T00:26:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMTc1MTcyNg==",
                                           "createdAt":  "2020-10-01T02:22:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBSEdAQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "noseratio",
                                                                               "createdAt":  "2020-10-01T02:27:16Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e I think it might be a sensible optimization for ICriticalNotifyCompletion.UnsafeOnCompleted. We don\u0027t have to flow execution context there, but Task.Factory.StartNew would still do that, adding a bit of unneeded overhead\r\n\r\nSee https://github.com/microsoft/vs-threading/pull/689#discussion_r497711508.  Someone could do the appropriate measurements, but my guess is that for .NET Core this would actually be a net negative rather than positive.",
                                           "updatedAt":  "2020-10-01T02:22:48Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMTgxNzg2OA==",
                                           "createdAt":  "2020-10-01T03:10:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "noseratio",
                                           "body":  "\u003e See [microsoft/vs-threading#689 (comment)](https://github.com/microsoft/vs-threading/pull/689#discussion_r497711508). Someone could do the appropriate measurements, but my guess is that for .NET Core this would actually be a net negative rather than positive.\r\n\r\nThat comment is a great insight, thank you. I suppose it explains why there [so few uses of `SuppressFlow` in .NET Core](https://source.dot.net/System.Private.CoreLib/R/4ed52c6477d5daa4.html).\r\n",
                                           "updatedAt":  "2020-10-01T03:10:53Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMjA1MzUxNw==",
                                           "createdAt":  "2020-10-01T10:51:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBh87hg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "noseratio",
                                                                               "createdAt":  "2020-10-01T11:04:08Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AArnott",
                                                                               "createdAt":  "2020-10-01T23:49:03Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "vladd",
                                                                               "createdAt":  "2020-12-16T14:18:55Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "theodorzoulias",
                                                                               "createdAt":  "2020-12-26T21:17:21Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pentp",
                                                                               "createdAt":  "2021-03-02T19:32:44Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  5
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e I suppose it explains why there so few uses of SuppressFlow in .NET Core.\r\n\r\nYes, it\u0027s use now isn\u0027t about throughout or allocation, but entirely about object lifetime, i.e. ensuring that ExecutionContext isn\u0027t captured unnecessarily into something that may live for a long time, that doesn\u0027t need access to the context (and won\u0027t be calling unknown code that might), and thus shouldn\u0027t forcibly extend the lifetime of values stored into async locals captured by the EC.",
                                           "updatedAt":  "2020-10-01T10:51:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5VXt3z",
                                           "createdAt":  "2023-02-16T00:25:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEbOFiw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "noseratio",
                                                                               "createdAt":  "2023-02-17T22:33:48Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "rodion-m",
                                                                               "createdAt":  "2023-03-07T20:50:03Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "timaiv",
                                                                               "createdAt":  "2023-03-31T16:10:02Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pavelsavara",
                                                                               "createdAt":  "2023-07-01T06:51:39Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "shzycat",
                                                                               "createdAt":  "2024-04-13T08:05:44Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "safakgur",
                                                                               "createdAt":  "2024-09-24T10:34:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nguerrera",
                                                                               "createdAt":  "2025-07-20T18:00:20Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  7
                                                         },
                                           "author":  "theodorzoulias",
                                           "body":  "I\u0027ve seen occasionally the `await Task.Yield()` being used with the explicit intention of switching to the `ThreadPool` ([example](https://stackoverflow.com/questions/74558319/async-function-not-launching-asynchronously/74558485#74558485)). This does work, but it depends on the ambient `SynchronizationContext.Current` and `TaskScheduler.Current` being `null`, so I consider it to be a hack and not a proper use of this API. But it\u0027s hard to argue against something that does work, it is readily available, and it\u0027s easy to discover, use and remember. So I think that there is some merit in [the alternative proposal](https://github.com/dotnet/runtime/issues/23498) by @AArnott of adding `ConfigureAwait` support to the `Task.Yield`:\r\n\r\n```C#\r\nawait Task.Yield().ConfigureAwait(false);\r\n```\r\n\r\nIt would have identical functionality with the proposed here:\r\n\r\n```C#\r\nawait TaskScheduler.Default.SwitchTo(alwaysYield: true);\r\n```\r\n\r\nThe first line is more concise and, to me, more familiar. But to be honest both are lacking the critical component: `ThreadPool`. My brain has to read between the lines in order to get the real meaning: *\"jump to the `ThreadPool`\"*.",
                                           "updatedAt":  "2023-02-16T07:16:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5oYvJR",
                                           "createdAt":  "2023-10-06T19:35:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODg4ulw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Zetanova",
                                                                               "createdAt":  "2023-11-21T15:28:48Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "noseratio",
                                                                               "createdAt":  "2023-12-11T01:14:38Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Neme12",
                                                                               "createdAt":  "2024-03-30T17:07:20Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "rpendleton",
                                                                               "createdAt":  "2024-05-07T04:20:04Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "murshex",
                                           "body":  "In .NET 8.0 we can do:\r\n```csharp\r\nawait Task.CompletedTask.ConfigureAwait(ConfigureAwaitOptions.ForceYielding);\r\n```\r\nBut its pretty verbose. A short and concise helper method like this would be nice to have:\r\n```csharp\r\nawait Task.YieldNoContext();\r\n```\r\n",
                                           "updatedAt":  "2023-10-06T19:35:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc544_BZ",
                                           "createdAt":  "2024-03-30T16:15:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODzXCPw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "safakgur",
                                                                               "createdAt":  "2024-09-24T10:35:42Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Neme12",
                                           "body":  "I would just add `Tak.Yield().ConfigureAwait(bool)` anyway, it\u0027s confusing that it isn\u0027t there and it\u0027s confusing in a library (where I have to use `ConfigureAwait(false)` everywhere) whether it means I shouldn\u0027t be using `Task.Yield()` at all given that I can\u0027t set `ConfigureAwait(false)`, or if I should use it anyway and just live with the inconsistency and with the wart of missing it in this one place.\r\n\r\nMaybe only the old-school boolean overload though, `ConfigureAwaitOptions` doesn\u0027t really make sense on `Task.Yield()` since it includes `ConfigureAwaitOptions.ForceYielding` and `ConfigureAwaitOptions.SuppressThrowing`\r\n\r\nOr maybe just `Task.Yield(bool continueOnCapturedContext)` directly without an additional method call and Awaitable.",
                                           "updatedAt":  "2024-03-30T17:15:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc545b2E",
                                           "createdAt":  "2024-03-30T17:20:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODcdeoQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AArnott",
                                                                               "createdAt":  "2024-03-30T22:52:44Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "omariom",
                                                                               "createdAt":  "2024-03-30T23:05:06Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "Neme12",
                                           "body":  "TBH I think we should have both. Both `Task.Yield().ConfigureAwait(bool)` and a way to explicitly switch to the thread pool or to the main thread, like https://github.com/microsoft/vs-threading offers (but I would recommend this library to any UI developer anyway).\r\n\r\nWith vs-threading, you can switch to any `TaskScheduler` by awaiting it, so commonly it would be `await TaskScheduler.Default;` This seems like a feature that should be in-box, along with the `Task.Yield()` thing.",
                                           "updatedAt":  "2024-03-30T17:23:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dkopd",
                                           "createdAt":  "2025-02-07T18:01:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Sergio0694",
                                           "body":  "Merging the proposal from #112257 here (missed this issue):\n\n```csharp\nnamespace System.Threading.Tasks\n{\n    public static class TaskSchedulerExtensions\n    {\n        public static TaskSchedulerYieldAwaiter Yield(this TaskScheduler taskScheduler);\n    }\n}\n\nnamespace System.Threading\n{\n    public static class SynchronizationContextExtensions\n    {\n        public static SynchronizationContextYieldAwaiter Yield(this SynchronizationContext synchronizationContext);\n    }\n}\n```\n\nThe idea being you can do:\n\n```csharp\n// Work on current thread\n\nawait TaskScheduler.Default.Yield();\n\n// Work on thread pool\n\nawait _synchronizationContext.Yield();\n\n// Work on UI thread\n```\n\n---\n\nI see this issue has been open for 8 years now. Are there any specific concerns left to resolve other than the exact API name? It seems there\u0027s a general agreement than some kind of inline `Yield()` semantics is something that would work here? Is there something we can do to help unblock this? Thank you! 🙂",
                                           "updatedAt":  "2025-02-07T18:01:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dk4BR",
                                           "createdAt":  "2025-02-07T18:26:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "NinoFloris",
                                           "body":  "How about:\n\n```csharp\npublic static YieldAwaitable Yield(TaskScheduler continueOn)\n```\n\nTask.Yield is a well known method, so it would be in an expected location. Having Task.Yield take the scheduler solves the semantic issue where calling Yield on non-current schedulers looks wrong. You\u0027re still \u0027yielding\u0027 (suspending) the current task,  just continuing (resuming) elsewhere. Finally, `continueOn` fits with `continueOnCapturedContext`, `ContinueWith` and other TPL naming choices. Adding other overloads for SynchronizationContext or some new thing down the road is also easy.\n\nRegarding `alwaysYield`/`forceYielding` it seems like a ConfigureAwait addressing those and other needs on YieldAwaitable might be most idiomatic?",
                                           "updatedAt":  "2025-02-07T18:26:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dk7Op",
                                           "createdAt":  "2025-02-07T18:34:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AArnott",
                                           "body":  "A `Yield` method API doesn\u0027t allow for awaiting a TaskScheduler and _not_ yielding when you\u0027re already on it.",
                                           "updatedAt":  "2025-02-07T18:34:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dlCw9",
                                           "createdAt":  "2025-02-07T18:54:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "I like the `SwitchTo` suggestion, to me it explicitly expresses the intention.",
                                           "updatedAt":  "2025-02-07T18:54:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dlD48",
                                           "createdAt":  "2025-02-07T18:56:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "NinoFloris",
                                           "body":  "Trying to come up with a good alternative name, that covers all the cases, seems to be why no proposal has been merged in 8 years. It would be nice if we could remove at least one part of the helper methods that we all have defined in our codebases for .NET 10. Even if we may still need to keep around others.\n\nI agree that semantically, and for consistency, any overload of Task.Yield must yield. However, conditional yielding could be enabled in many ways: a bool argument on the method, a flag on some `YieldAwaitable.ConfigureAwait`, or even some new `MigrateAwaitable Task.Migrate(TaskScheduler scheduler)`.\n\nAs always, a guard clause is a decent option too. I personally don\u0027t consider it too burdensome to write:\n\n```cs\nif (TaskScheduler.Current != myScheduler)\n    await Task.Yield(continueOn: myScheduler);\n```",
                                           "updatedAt":  "2025-02-07T18:59:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dl1-q",
                                           "createdAt":  "2025-02-07T19:48:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEFre5Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jnm2",
                                                                               "createdAt":  "2025-02-07T21:18:42Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Sergio0694",
                                           "body":  "I would also recommend to keep in mind both `TaskScheduler` and `SynchronizationContext`. The latter is what is used by almost all GUI frameworks to wrap the UI-thread-specific dispatching functionality. Apps need to be able to easily yield/switch to that too.",
                                           "updatedAt":  "2025-02-07T19:48:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dmQNM",
                                           "createdAt":  "2025-02-07T20:21:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AArnott",
                                           "body":  "await `TaskScheduler` and `SynchronizationContext` are [both supported by the Microsoft.VisualStudio.Threading library](https://learn.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.threading.awaitextensions?view=visualstudiosdk-2022#methods), which any app can use today, FWIW.\n\nThere\u0027s no way to tell if you\u0027re running on a given `SynchronizationContext` so awaiting that _always_ yields.\nFor TaskScheduler, you can await on it directly (which only yields if you\u0027re not already on it) and we have a `SwitchTo(bool alwaysYield)` extension method so you can control the yielding. \n\nPretty simple API that I would say is suitable for inclusion in .NET.",
                                           "updatedAt":  "2025-02-07T20:22:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dmVZO",
                                           "createdAt":  "2025-02-07T20:33:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEFrSMA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AArnott",
                                                                               "createdAt":  "2025-02-07T20:41:03Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "murshex",
                                           "body":  "@AArnott Sorry, but couldn’t SynchronizationContext.Current be used to tell if you’re running on a given SynchronizationContext?\n\nEDIT: I realized that we can’t rely on SynchronizationContext.Current as proof that we are already running on a SynchronizationContext because SynchronizationContext.Current might be set, but it doesn’t mean we are actually running on it.",
                                           "updatedAt":  "2025-02-07T20:40:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dmYlf",
                                           "createdAt":  "2025-02-07T20:41:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEFrZ2A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "murshex",
                                                                               "createdAt":  "2025-02-07T21:03:42Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "AArnott",
                                           "body":  "@murshex Correct. And even if you _are_ running on it, `Current` doesn\u0027t have to be set to the sync context that ran your delegate. In fact it\u0027s extra work for the SyncContext to set Current, and not all do.",
                                           "updatedAt":  "2025-02-07T20:41:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dmnE0",
                                           "createdAt":  "2025-02-07T21:16:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "murshex",
                                           "body":  "@Sergio0694 Does proposal #112257 intend to always yield when TaskScheduler.Default.Yield() is called?",
                                           "updatedAt":  "2025-02-07T21:16:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dmsNE",
                                           "createdAt":  "2025-02-07T21:30:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEFsTMQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "omariom",
                                                                               "createdAt":  "2025-02-08T00:57:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "NinoFloris",
                                                                               "createdAt":  "2025-02-08T01:32:07Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "murshex",
                                           "body":  "I think TaskScheduler should get two new methods.\n\n1. Yield(), which always yields, even if you’re already running on the TaskScheduler.\n\n2. SwitchTo(), which only yields if not already running on the TaskScheduler. _Method name could be different if someone has a better one._\n\nIt is important to support both use cases. We shouldn’t assume what the user wants. I think two separate methods is good for making the intent clear.",
                                           "updatedAt":  "2025-02-07T21:30:50Z"
                                       }
                                   ],
                         "totalCount":  41
                     },
        "title":  "Add awaitable ThreadPool.SwitchTo()",
        "labels":  [
                       "api-needs-work",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/21363",
        "createdAt":  "2017-04-25T14:01:25Z",
        "number":  21363,
        "author":  "tmds",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC2fS8A==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "grisha-kotler",
                                            "createdAt":  "2018-02-28T12:09:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "HighPerfDotNet",
                                            "createdAt":  "2022-01-08T17:47:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "timcassell",
                                            "createdAt":  "2023-04-04T12:47:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "WenceyWang",
                                            "createdAt":  "2023-12-19T21:39:50Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sandersaares",
                                            "createdAt":  "2024-03-13T06:29:39Z"
                                        }
                                    ],
                          "totalCount":  5
                      },
        "updatedAt":  "2021-04-19T19:57:45Z",
        "body":  "**Purpose**\r\n\r\nAllow control of thread affinity.\r\n\r\n**Proposed API**\r\n\r\n```C#\r\nclass Thread\r\n{\r\n    ProcessorSet Affinity { get; set; }\r\n}\r\n```\r\nThe `ProcessorSet` represents a a set of logical processors.\r\nThe underlying APIs for Windows/Posix use bit masks for this.\r\n\r\nWindows: https://msdn.microsoft.com/en-us/library/windows/desktop/ms686247(v=vs.85).aspx\r\nPosix: http://man7.org/linux/man-pages/man3/pthread_setaffinity_np.3.html\r\n\r\nOn Windows, systems with more than 64 processors are split into groups. Threads cannot use processors which belong to multiple groups. `ProcessorSet` can store the group info.\r\n\r\n```C#\r\nstruct ProcessorSet\r\n{\r\n   int Group { get; set; }                  // get/set group\r\n   bool this[int processor] { get; set; }   // get/set/clear processor\r\n\r\n   ProcessorSet(minCapacity);               // actual capacity may be higher\r\n   int Capacity { get; }                    // indexer is valid from [0-Capacity[\r\n\r\n   // string representation, see below\r\n   string ToString();\r\n   static ProcessorSet Parse(string);\r\n   static bool TryParse(string, out ProcessorSet);\r\n\r\n   static ProcessorSet ForProcessor(int group, int processor); // set with single processor\r\n   static ProcessorSet ForProcessor(int processor);            // set with single processor\r\n}\r\n```\r\n\r\nThe string representation can be a comma separated list of processors and ranges, prefixed with an optional processor group. E.g: `1`, `1-3,5`, `1:8-10`.\r\n\r\n**Example**\r\n\r\n```\r\nvar thread = new Thread(threadStart);\r\nthread.Affinity = ProcessorSet.Parse(\"0-3\");\r\nthread.Start();\r\n```\r\n\r\n**Remarks**\r\n\r\nThis proposal does not consider retrieving information from the OS like the number of groups and the number of processors per group. The total number of processors can be read from `Environment.ProcessorCount`.\r\n\r\nPosix threads inherit the calling thread affinity. It may be preferable to allow new Threads to run on all processors to avoid surprises. Threads that want to inherit the calling thread priority can explicitly do so:\r\n\r\n```c#\r\nnewThread.Affinity = Thread.CurrentThread.Affinity;\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOMQoVvw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI5NzA3NDEzOQ==",
                                           "createdAt":  "2017-04-25T15:47:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "svick",
                                           "body":  "There is already `ProcessThread.ProcessorAffinity`. Do I get it right that this proposal is better because of the following reasons?\r\n\r\n* `ProcessThread.ProcessorAffinity` throws `PlatformNotSupportedException` on Unix.\r\n* Mapping between `Thread` and `ProcessThread` is difficult.\r\n* `ProcessThread.ProcessorAffinity` does not support groups.",
                                           "updatedAt":  "2017-04-25T15:47:04Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI5NzEyNDI5Mw==",
                                           "createdAt":  "2017-04-25T18:33:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "@svick Yes, x-plat and more than 64 processors. Limited to the current executing process (compared to ProcessThread).",
                                           "updatedAt":  "2017-04-25T18:33:43Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM0Mjc2OTYxMQ==",
                                           "createdAt":  "2017-11-08T10:04:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "damageboy",
                                           "body":  "There\u0027s a definite need for having support for affinities \u003e 64 processors...\r\nThe undelying Windows/Posix APIs do expose these abilities...\r\n\r\nI\u0027d love to have that...\r\n![image](https://user-images.githubusercontent.com/125730/32542967-f4caff84-c47c-11e7-9a02-7c7fda4542d9.png)\r\n",
                                           "updatedAt":  "2017-11-08T10:04:40Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwMDcxNjY0OQ==",
                                           "createdAt":  "2019-06-11T07:11:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "Closing due to limited interest.",
                                           "updatedAt":  "2019-06-11T07:11:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwMDk1NjUxMg==",
                                           "createdAt":  "2019-06-11T18:01:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "I think this is something that would be very useful for certain high-performance apps.",
                                           "updatedAt":  "2019-06-11T18:01:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NDgzODcyOA==",
                                           "createdAt":  "2020-01-15T20:19:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "redwyre",
                                           "body":  "AFAIK, there is currently no way to handle more than 64 core using .net even on windows. In fact without access to processor groups the process will end up with access to _less_ cores. We sorely need something like this. AMD is currently pushing core count and it wont be long before 64 core is something we need to handle.\r\n\r\n@tmds can you reopen this?",
                                           "updatedAt":  "2020-01-15T20:23:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY3ODUzMTU1Mg==",
                                           "createdAt":  "2020-08-21T21:50:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ddrinka",
                                           "body":  "Even without support for ProcessorSets, .Net should support `Thread.ProcessorAffinity` as a bit mask, similar to Process.ProcessorAffinity.  There is no alternative cross-platform API besides rolling our own based on `sched_setaffinity` and `SetThreadAffinityMask`.",
                                           "updatedAt":  "2020-08-21T21:50:48Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyMjAxODQ4NQ==",
                                           "createdAt":  "2021-04-18T16:23:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "john-h-k",
                                           "body":  "\u003e Even without support for ProcessorSets, .Net should support `Thread.ProcessorAffinity` as a bit mask, similar to Process.ProcessorAffinity. There is no alternative cross-platform API besides rolling our own based on `sched_setaffinity` and `SetThreadAffinityMask`.\r\n\r\nYep, which fully verges on undefined behaviour bc we don\u0027t know if `Thread` is backed by a single native OS thread",
                                           "updatedAt":  "2021-04-18T16:23:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyMjA2ODQ0NQ==",
                                           "createdAt":  "2021-04-18T21:57:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "\u003e we don\u0027t know if `Thread` is backed by a single native OS thread\n\nThere is [Thread.BeginThreadAffinity](https://docs.microsoft.com/dotnet/api/system.threading.thread.beginthreadaffinity?view=net-5.0) for asking the host not to move the managed thread to a different OS thread. \u003chttps://github.com/dotnet/runtime/blob/2f740adc1457e8a28c1c072993b66f515977eb51/src/libraries/System.Private.CoreLib/src/System/Threading/Thread.cs#L209-L214\u003e",
                                           "updatedAt":  "2021-04-18T21:57:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyMjA2OTY5Ng==",
                                           "createdAt":  "2021-04-18T22:06:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "That isn\u0027t quite the same as enforcing a thread always executes on a given CPU core, which is the intent for the proposed API.",
                                           "updatedAt":  "2021-04-18T22:06:46Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyMjE1ODQ2Mw==",
                                           "createdAt":  "2021-04-19T04:32:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "I meant, if an application is going to call OS functions to set the CPU affinity of the OS thread, it ought to call Thread.BeginThreadAffinity first. The implementation seems to be a no-op in .NET 5 but the documentation does not promise that.\n\nIf an API for setting the CPU affinity of a managed thread is added and the application calls that, I imagine the runtime will have to avoid running the managed thread on an OS thread that has a different CPU affinity, and the application won\u0027t need to call Thread.BeginThreadAffinity for that purpose.",
                                           "updatedAt":  "2021-04-19T04:32:26Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyMjc0NDUxMQ==",
                                           "createdAt":  "2021-04-19T19:57:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODXilmw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "yossika-tr",
                                                                               "createdAt":  "2021-06-15T08:24:18Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "thefringeninja",
                                                                               "createdAt":  "2021-10-18T19:31:23Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "piotr-alpha",
                                                                               "createdAt":  "2021-10-20T20:56:04Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "HighPerfDotNet",
                                                                               "createdAt":  "2022-01-08T17:28:51Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "quixoticaxis",
                                                                               "createdAt":  "2022-01-08T23:38:41Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "sfiruch",
                                                                               "createdAt":  "2022-06-06T15:14:09Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "DominikKDev",
                                                                               "createdAt":  "2024-02-20T19:11:25Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  7
                                                         },
                                           "author":  "ddrinka",
                                           "body":  "Our .Net Framework code utilizes `BeginThreadAffinity` to bind a .Net thread to an OS thread, and then iterates through `Process.GetCurrentProcess().Threads` until finding the `ProcessThread` who\u0027s ID matches `AppDomain.GetCurrentThreadId()`.  We can then manage the affinity of that ProcessThread.\r\n\r\nOur modern code uses the following PInvokes, which also work fine:\r\n\r\n```csharp\r\npublic static void SetThreadProcessorAffinity(params int[] processors)\r\n{\r\n    Thread.BeginThreadAffinity();\r\n\r\n    var mask = ComputeProcessorMask(processors);\r\n\r\n    if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))\r\n    {\r\n        sched_setaffinity(0, new IntPtr(sizeof(ulong)), new[] { mask });\r\n    }\r\n    else if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))\r\n    {\r\n        var currentThread = GetCurrentThread();\r\n        SetThreadAffinityMask(currentThread, mask);\r\n    }\r\n    else\r\n    {\r\n        throw new NotSupportedException();\r\n    }\r\n}\r\n```\r\n\r\nHowever, we believe this capability should be included in the runtime.",
                                           "updatedAt":  "2021-04-19T19:57:44Z"
                                       }
                                   ],
                         "totalCount":  12
                     },
        "title":  "Support controlling thread affinity",
        "labels":  [
                       "enhancement",
                       "api-needs-work",
                       "area-System.Threading",
                       "os-linux"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/9649",
        "createdAt":  "2018-02-02T13:43:03Z",
        "number":  9649,
        "author":  "ayende",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOASZueg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rvhuang",
                                            "createdAt":  "2018-02-04T02:08:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "redknightlois",
                                            "createdAt":  "2018-02-07T19:50:53Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2024-10-10T05:49:09Z",
        "body":  "For performance reasons, it is very common to use thread local values. Under load, the thread pool might be spawning new threads and running requests on them.\r\nThat will cause our code to allocate some resources for this.\r\n\r\nAfter the load it over, the thread pool will start reducing the number of active threads, but we have to rely on the GC to clean up such resources, usually by relying on the GC collecting the thread static values and then running the finalizers.\r\n\r\nOur code is structured so we\u0027ll have very little GC runs (hence the need to do thread local stuff), and it can take a long time for the GC to actually get around to cleaning these.\r\n\r\nIdeally, I would like to have `ThreadPool.CurrentThreadPoolThreadClosing` event that would:\r\n\r\n* Be called as one of the last stages of closing a thread pool thread.\r\n* Allow us to proactively cleanup any manged / unamanged resources for that thread early on.\r\n\r\nFor that matter, the corollary for that, `ThreadPool.CurrentThreadPoolThreadStarting` might also be useful, because we can do the initialization of state there, and save up on checks. But that is of far less importance, I think.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOj0uBjQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM2MjkzMTg0OQ==",
                                           "createdAt":  "2018-02-04T19:18:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "When you are doing this level of micromanagement, would it make more sense for you to have your own threadpool instead?",
                                           "updatedAt":  "2018-02-04T19:18:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM2Mjk2NTUwMg==",
                                           "createdAt":  "2018-02-05T02:30:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ayende",
                                           "body":  "Probably so, I do have one for our own needs, but things like Kestrel uses the default pool, and a lot of the infrastructure too. If I\u0027m calling something that uses `Task.Run`, for example. ",
                                           "updatedAt":  "2018-02-05T02:30:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6PSyjz",
                                           "createdAt":  "2024-10-10T05:35:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ayende",
                                           "body":  "I would absolutely still love to have this feature. Note that since I opened that, there has been a lot of activity on performance and the level of detail you need to ensure that.\n\nThread Local is heavily used, and it is something that can make managing performance much more efficent.",
                                           "updatedAt":  "2024-10-10T05:35:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6PS4GN",
                                           "createdAt":  "2024-10-10T05:49:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD1jpbQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "ayende",
                                                                               "createdAt":  "2024-10-10T09:24:53Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "En3Tho",
                                           "body":  "@ayende 7 years flew by :D",
                                           "updatedAt":  "2024-10-10T05:49:08Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Provide ThreadPool a way to notify that a thread has shut down",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/26255",
        "createdAt":  "2018-05-23T09:22:22Z",
        "number":  26255,
        "author":  "kurtschelfthout",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC9i90w==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kronic",
                                            "createdAt":  "2021-09-14T16:17:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "auduchinok",
                                            "createdAt":  "2023-10-20T10:06:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sandersaares",
                                            "createdAt":  "2023-11-24T07:26:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "WalkerCodeRanger",
                                            "createdAt":  "2024-12-17T18:37:43Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2025-08-21T20:55:40Z",
        "body":  "`LazyInitializer.EnsureInitialized` is a great API to do thread-safe lazy initialization, in cases where the allocation of a `Lazy` instance is undesirable, i.e. to reduce memory pressure.\r\n\r\nHowever, `EnsureInitialized` only takes a delegate of type `Func\u003cT\u003e` to initialize the target, which doesn\u0027t work well for initializing fields that are dependent on other arguments. In that case, a closure is allocated on each call to `EnsureInitialized`. \r\n\r\nIt\u0027s easy to fall into this trap if you\u0027re lazily initializing a field based on other fields in an object, for example:\r\n\r\n```csharp\r\npublic class Example {\r\n    private readonly int _a; // e.g. given as ctor argument\r\n    private int[] _expensiveToCalculate;\r\n    public int[] ExpensiveCachedValue =\u003e LazyInitializer.EnsureInitialized(ref _expensiveToCalculate, () =\u003e ExpensiveCalculation());\r\n    private int[] ExpensiveCalculation() {\r\n        // an instance method that does something with _a etc\r\n    }\r\n}\r\n```\r\nSo in this example we potentially replaced `Lazy` with something that actually allocates way more in the form of closure objects. Though all the allocations are Gen 0, in our scenario that was actually harmful and pretty much brought the server to a halt at times!\r\n\r\nWhat\u0027s more, with the existing API there is no way out of this conundrum as far as I can tell - except by manually inlining the code in `LazyInitializer`. This makes me sad.\r\n\r\n*Proposed API change*\r\n\r\n```csharp\r\n// existing overloads (there are also two other existing overloads which initialize T based on its default ctor)\r\npublic static T EnsureInitialized\u003cT\u003e (ref T target, Func\u003cT\u003e valueFactory) where T : class;\r\npublic static T EnsureInitialized\u003cT\u003e (ref T target, ref bool initialized, ref object syncLock, Func\u003cT\u003e valueFactory);\r\n\r\n// suggested new overloads\r\npublic static T EnsureInitialized\u003cT, TArg\u003e (ref T target, TArg arg, Func\u003cTArg, T\u003e valueFactory) where T : class;\r\npublic static T EnsureInitialized\u003cT, TArg\u003e (ref T target, ref bool initialized, ref object syncLock, TArg arg, Func\u003cTArg, T\u003e valueFactory);\r\n```\r\n\r\nI\u0027ll add that elsewhere in the framework the extra delegate argument is typically typed as `object`, I think that\u0027s also fine but I don\u0027t know the reasoning behind it, so suggested what I believe to be the natural API.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOv3Pp8A==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5MTMxODk4MA==",
                                           "createdAt":  "2018-05-23T11:51:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "svick",
                                           "body":  "```c#\r\npublic static T EnsureInitialized\u003cT, TArg\u003e (ref T target, Func\u003cT, TArg\u003e valueFactory) where T : class;\r\n```\r\n\r\nWas this supposed to be:\r\n\r\n```c#\r\npublic static T EnsureInitialized\u003cT, TArg\u003e (ref T target, TArg arg, Func\u003cTArg, T\u003e valueFactory) where T : class;\r\n```",
                                           "updatedAt":  "2018-05-23T11:51:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5MTMzNjczMw==",
                                           "createdAt":  "2018-05-23T12:57:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kurtschelfthout",
                                           "body":  "@svick Yes! My bad. Corrected in the original post. Thank you.",
                                           "updatedAt":  "2018-05-23T12:57:14Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5MTM4MDYyOQ==",
                                           "createdAt":  "2018-05-23T15:02:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD_XuXg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "WalkerCodeRanger",
                                                                               "createdAt":  "2024-12-17T18:39:04Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "mburbea",
                                           "body":  "Would `object` be sufficient? That way we don\u0027t need a generic overload. Since your state object is likely to be ref type, the cast is basically free anyway. \r\nI would also say if we add this overload, we should add it to `Lazy\u003cT\u003e`.",
                                           "updatedAt":  "2018-05-23T15:02:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5MTQwMTg1OQ==",
                                           "createdAt":  "2018-05-23T16:00:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kurtschelfthout",
                                           "body":  "\u003e Would object be sufficient? That way we don\u0027t need a generic overload.\r\n\r\nobject is ok, but what\u0027s wrong with a generic overload?\r\n\r\n\u003e I would also say if we add this overload, we should add it to Lazy\u003cT\u003e.\r\n\r\nThere is no reason to add this to `Lazy\u003cT\u003e`, because the valueFactory delegate in `Lazy\u003cT\u003e`\u0027s case is only allocated once and then stored as a field on the Lazy instance, which is stored in turn in an enclosing field. It makes no difference to store an extra arg as an extra field in the Lazy instance, or as a field in the valueFactory closure.",
                                           "updatedAt":  "2018-05-23T16:01:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5MTQzNDI1NA==",
                                           "createdAt":  "2018-05-23T17:34:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mburbea",
                                           "body":  "I just figure there is prior art in things like `Task.ContinueWith(Action\u003cT, object\u003e, object)` or task factory.\r\nIt helps reduce the method bloat, if this becomes very common.\r\n\r\n\r\nAs for why the other Lazy approach, you might want to create many new Lazy\u0027s, and avoid the delegate cost, as `(o)=\u003e((MyStateObj)o).DoIt();` is a reusable delegate.",
                                           "updatedAt":  "2018-05-23T17:34:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5MTY0NzU3OA==",
                                           "createdAt":  "2018-05-24T09:19:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kurtschelfthout",
                                           "body":  "\u003e As for why the other Lazy approach, you might want to create many new Lazy\u0027s, and avoid the delegate cost, as (o)=\u003e((MyStateObj)o).DoIt(); is a reusable delegate.\r\n\r\nThat\u0027s an unrealistic use case. If you\u0027re ok with allocating Lazy instances, the extra allocations of closures is not going to matter to you. It\u0027s likely you\u0027ll hold on to the Lazy instances for a long time anyway and so all the objects will get to Gen2 and be more or less out of the way. With LazyInitializer on the other hand, the whole point is to avoid allocations - so by definition you care - and what\u0027s more the closures will be allocated and GC\u0027ed almost immediately in Gen0, which creates a lot of GC churn.",
                                           "updatedAt":  "2018-05-24T09:19:37Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4MjEyOTMzMw==",
                                           "createdAt":  "2021-02-19T15:01:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODNjxyA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "sandersaares",
                                                                               "createdAt":  "2023-11-24T20:36:36Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "roji",
                                           "body":  "For anyone reaching this, here\u0027s the [NonCapturingLazyInitializer](https://github.com/dotnet/efcore/blob/6d9770807009dcd5fb6e838f1cd5180b62fb4bf1/src/Shared/NonCapturingLazyInitializer.cs) we use in EF Core. It would be great if this functionality could make it into LazyInitializer.\r\n",
                                           "updatedAt":  "2021-02-19T15:01:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6_c8hA",
                                           "createdAt":  "2025-08-21T20:51:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xtqqczze",
                                           "body":  "\u003e What\u0027s more, with the existing API there is no way out of this conundrum as far as I can tell - except by manually inlining the code in LazyInitializer. This makes me sad.\n\nIf performance is a priority, using `Interlocked.CompareExchange` directly isn’t too heavy, and with the C# 14 field keyword it ends up being fairly convenient:\n\n```cs\npublic class Example {\n    private readonly int _a; // e.g. given as ctor argument\n    public int[] ExpensiveCachedValue =\u003e\n        field ?? Interlocked.CompareExchange(ref field, ExpensiveCalculation(), null) ?? field;\n    private int[] ExpensiveCalculation() {\n        // an instance method that does something with _a etc\n    }\n}\n```\n\nI’m not sure that adding new overloads with additional type parameters would provide enough benefit to justify the complexity.\n\ncc: @stephentoub",
                                           "updatedAt":  "2025-08-21T20:51:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6_c-nw",
                                           "createdAt":  "2025-08-21T20:55:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mburbea",
                                           "body":  "This can cause multiple threads to do the same expensive work. There are\r\ncases where you don\u0027t want the closure, but do want a lock to prevent two\r\nexpensive ops (or if the op has a side effect like writing to a file or a\r\nDB).\r\n\r\nOn Thu, Aug 21, 2025, 4:52 PM xtqqczze ***@***.***\u003e wrote:\r\n\r\n\u003e *xtqqczze* left a comment (dotnet/runtime#26255)\r\n\u003e \u003chttps://github.com/dotnet/runtime/issues/26255#issuecomment-3212036160\u003e\r\n\u003e\r\n\u003e What\u0027s more, with the existing API there is no way out of this conundrum\r\n\u003e as far as I can tell - except by manually inlining the code in\r\n\u003e LazyInitializer. This makes me sad.\r\n\u003e\r\n\u003e If performance is a priority, using Interlocked.CompareExchange directly\r\n\u003e isn’t too heavy, and with the C# 14 field keyword it ends up being fairly\r\n\u003e convenient:\r\n\u003e\r\n\u003e public class Example {\r\n\u003e     private readonly int _a; // e.g. given as ctor argument\r\n\u003e     public int[] ExpensiveCachedValue =\u003e\r\n\u003e         field ?? Interlocked.CompareExchange(ref field, ExpensiveCalculation(), null) ?? field;\r\n\u003e     private int[] ExpensiveCalculation() {\r\n\u003e         // an instance method that does something with _a etc\r\n\u003e     }}\r\n\u003e\r\n\u003e I’m not sure that adding new overloads with additional type parameters\r\n\u003e would provide enough benefit to justify the complexity.\r\n\u003e\r\n\u003e cc: @stephentoub \u003chttps://github.com/stephentoub\u003e\r\n\u003e\r\n\u003e —\r\n\u003e Reply to this email directly, view it on GitHub\r\n\u003e \u003chttps://github.com/dotnet/runtime/issues/26255#issuecomment-3212036160\u003e,\r\n\u003e or unsubscribe\r\n\u003e \u003chttps://github.com/notifications/unsubscribe-auth/AABUB4NOL2PY3PV37ZFIFUT3OYWPXAVCNFSM6AAAAACEPZMRP2VHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZTEMJSGAZTMMJWGA\u003e\r\n\u003e .\r\n\u003e You are receiving this because you commented.Message ID:\r\n\u003e ***@***.***\u003e\r\n\u003e\r\n",
                                           "updatedAt":  "2025-08-21T20:55:40Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "Add LazyInitializer.EnsureInitialized overloads that take a Func\u003cTArg,T\u003e to avoid closure allocations",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/10752",
        "createdAt":  "2018-07-23T16:56:12Z",
        "number":  10752,
        "author":  "vancem",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-04T17:36:28Z",
        "body":  "A number of different users have noted a large amount of time in the .NET ThreadPool WorkStealingQueue.TrySteal method (Being called from [ThredPoolWorkQueue.Dequeue](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/src/System/Threading/ThreadPool.cs#L465)  method).    \r\n\r\nFrom what we can tell the scenario that causes is bursty workloads.   For bursty workloads our guidance is to set a MinWorkerThreads high enough so that there are threads available to handle the burst.   For high scale machines (e.g. 16 Proc), it is not uncommon then to set this minimum in the 160-320 thread range.   \r\n\r\nWhen a burst  (lets say it needs 100 threads to do the work), then those 100 threads do the work, then calle Dequeue to get the next work.   However the burst is over, and thus they all don\u0027t find any work left, and go through a loop lin the [ThredPoolWorkQueue.Dequeue](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/src/System/Threading/ThreadPool.cs#L465)  method to find work to steal from other threads.  (which will fail).\r\n\r\nThus you have 100 threads spinning through 160-320 worker threads looking for more work, thus requring 16K to 32K checks.   These threads \u0027fight\u0027 over the memory to check that the queues are empty, and thus even though the check is short, it consumes a non-trivial amount of CPU time.    If these bursts come frequently (e.g. every 10-100 msec), then the CPU adds up.   \r\n\r\nHere is where we see the CPU time spent (This is on Desktop framework, but the code is very similar  for .NET core).  Here is the code in Dequeue. \r\n```\r\n                   if (null == callback)\r\n                   {\r\n100.0 |                WorkStealingQueue[] otherQueues = allThreadQueues.Current;\r\n  1.9K|                int i = tl.random.Next(otherQueues.Length);\r\n                       int c = otherQueues.Length;\r\n                       while (c \u003e 0)\r\n                       {\r\n 49.1K|                    WorkStealingQueue otherQueue = Volatile.Read(ref otherQueues[i % otherQueues.Length]);\r\n141.2K|                    if (otherQueue != null \u0026\u0026\r\n                               otherQueue != wsq \u0026\u0026\r\n                               otherQueue.TrySteal(out callback, ref missedSteal))\r\n```\r\nAnd here we see the hot code in TrySteal (That 141K, broken down) \r\n```\r\n                   private bool TrySteal(out IThreadPoolWorkItem obj, ref bool missedSteal, int millisecondsTimeout)\r\n                   {\r\n 23.8K|                obj = null;\r\n       \r\n                       while (true)\r\n                       {\r\n 92.5K|                    if (m_headIndex \u003e= m_tailIndex)\r\n  8.1K|                        return false;\r\n```\r\n\r\nIn .NET Core the code is a bit different because we have created a helper called \u0027CanSteal\u0027 that does m_headIndex \u003e= m_tailIndex, and we call this helper in Dequeue before calling TrySteal.  This helps cut the cost per iteration, but does not mitigate the fact that we are doing an O(n) operation, and we have to \u0027fight\u0027 over the memory representing m_headIndex and m_tailIndex variables)   Thus on .NET Core the problem will not show up in TrySteal and should be less severe, but probably still problematic.  \r\n\r\nTo really fix the problem we need to be less aggressive about checking for stealing.   Ideally want to do some checking, but we want to be much less aggressive if we know that other threads will shortly come along and do a more aggressive check.   This avoids O(N) behavior, which is the fundamental problem.  \r\n\r\nThe solutions probably looks like only looking for work to steal for a subset unless we have been asked to be \u0027aggressive\u0027.   We are aggressive only after a certain amount of time. \r\n\r\n@kouvel @stephentoub \r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHONLrJjg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQwNzkwNzI4MA==",
                                           "createdAt":  "2018-07-25T21:47:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vancem",
                                           "body":  "https://github.com/dotnet/coreclr/pull/18403 would naturally fix this problem because it would cut the number of work stealing queues to the number of processors which is modest.  ",
                                           "updatedAt":  "2018-07-25T21:47:26Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQwNzkxODQyOA==",
                                           "createdAt":  "2018-07-25T22:36:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "There were some attempts at fixing the aggressiveness of checking other threads\u0027 local queues, but they didn\u0027t pan out. See https://github.com/dotnet/coreclr/issues/14017 and items linked to it. My understanding as described in that issue is that it is currently aggressive to compensate for necessary synchronization, which when added, decreases work item throughput.\r\n\r\nI was thinking about https://github.com/dotnet/coreclr/pull/18403 but to me some issues are that threads can move from core to core, and checking which core it\u0027s currently on looks like it would need a p/invoke which would likely regress work item throughput.\r\n\r\nAnother thing I was thinking about is having a linked list that contains thread-local queues that contain items, and have threads link and unlink an item to/from the list upon going from empty to non-empty or vice versa. It would probably regress short-burst work throughput (which is not uncommon) but it would hopefully replace the O(n) work with a lock and O(1) work.",
                                           "updatedAt":  "2018-07-25T22:36:43Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQwNzkxOTM3MA==",
                                           "createdAt":  "2018-07-25T22:41:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "\u003e it is currently aggressive to compensate for necessary synchronization\r\n\r\nThis is made worse by the fact that more than one thread is requested for each work item up to procCount threads, for the same reason.",
                                           "updatedAt":  "2018-07-25T22:46:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNDMwMjMwOQ==",
                                           "createdAt":  "2020-05-05T20:57:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBDRBnQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "benaadams",
                                                                               "createdAt":  "2020-05-05T22:14:11Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "mangod9",
                                           "body":  "This came up in some discussions so will determine feasibility to do in .net 5",
                                           "updatedAt":  "2020-05-05T20:57:54Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczMzk3MTE1Mg==",
                                           "createdAt":  "2020-11-25T22:20:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "joaocpaiva",
                                           "body":  "This problem is exacerbated on multi-core machines and the impact is exponential as we double the number of cores.\r\n\r\nThis stack is taking 2% of CPU on 4 core machines in Microsoft Graph and \u003e6% of CPU on 8 core machines.\r\n\r\nMoving from 4 cores to 8 cores, doubles MinWorkerThread, but the lock contention is about 3 times worse. We use MinWorkerThread=100 (per core). Based on #threads metrics, I think we might have some room to adjust this value down as a workaround to soften some of the impact but we can only go down so much.\r\n\r\nThis likely impacts many high throughput services. Does it not make the cut for .NET 6 @StephenBonikowsky @stephentoub ?",
                                           "updatedAt":  "2020-11-26T00:09:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczNDAxMzc5MA==",
                                           "createdAt":  "2020-11-26T00:58:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "@joaocpaiva https://github.com/dotnet/runtime/pull/44265 may have helped with this? ",
                                           "updatedAt":  "2020-11-26T00:58:46Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczNjEzMDk4Mw==",
                                           "createdAt":  "2020-12-01T00:11:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "joaocpaiva",
                                           "body":  "\u003e @joaocpaiva #44265 may have helped with this?\r\n\r\n@benaadams yes but that fix was applied to ConcurrentQueueSegment, however ThreadPoolWorkQueue implementation seems to use an internal QueueSegment implementation, which still has the busy wait.",
                                           "updatedAt":  "2020-12-01T00:11:43Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2NzI0MjYxOQ==",
                                           "createdAt":  "2021-01-26T02:26:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "joaocpaiva",
                                           "body":  "As expected, setting **MinWorkerThreads** from **100** down to **50** helped bring down the cost close to 3% (as opposed to 6%). We don\u0027t have more room to reduce it further, without taking a risk of causing issues and performance degradation during bursty workloads.",
                                           "updatedAt":  "2021-01-26T02:26:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc40usmO",
                                           "createdAt":  "2021-07-22T05:00:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "This is no longer a partner ask. ",
                                           "updatedAt":  "2021-07-22T05:00:14Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "Reduce time in .NET Threadpool\u0027s WorkStealingQueue.TrySteal method and ThreadPoolWorkQueue.Dequeue methods.  ",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/924",
        "createdAt":  "2018-08-24T07:57:14Z",
        "number":  924,
        "author":  "odhanson",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC1m_8A==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aetos382",
                                            "createdAt":  "2024-02-02T14:40:48Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2022-06-14T16:24:18Z",
        "body":  "Due to the tight coupling with windows API, many of the current System.Threading IPC constructs do not support the \"Named\" flavours on all platforms. This leaves out important IPC objects such as Semaphores, shared memory and events. Writing cross platform applications that deal with multiple processes that need to communicate with each other, definitely lack these APIs.\r\n\r\nI propose to add a new namespace that defines a set of IPC classes with an API that is designed to be truly cross platform. There are similar APIs out there, for example [Boost interprocess](https://www.boost.org/doc/libs/1_63_0/doc/html/interprocess.html).\r\n\r\n### Proposed API\r\n```c#\r\nnamespace System.Interprocess\r\n{\r\n    public interface IWaitable\r\n    {\r\n        // Waits infinitely\r\n        void Wait();\r\n\r\n        // Waits with timeout. Returns true if wait succeeded\r\n        bool Wait(TimeSpan timeout);\r\n\r\n        // Waits with timeout. Returns true if wait succeeded\r\n        bool Wait(int timeoutMs);\r\n    }\r\n\r\n    public class NamedSemaphore : IWaitable, IDisposable\r\n    {\r\n        public NamedSemaphore(string Name);\r\n        public NamedSemaphore(string Name, int initialValue);\r\n        public void Release();\r\n\r\n        #region IWaitable\r\n        public void Wait();\r\n        public bool Wait(TimeSpan timeout);\r\n        public bool Wait(int timeoutMs);\r\n        #endregion\r\n\r\n        #region IDisposable\r\n        public void Dispose();\r\n        #endregion\r\n    }\r\n\r\n    public interface IEvent\r\n    {\r\n        public void Set();\r\n        public void Reset();\r\n    }\r\n\r\n    public class ManualResetNamedEvent : IWaitable, IEvent, IDisposable\r\n    {\r\n        public ManualResetNamedEvent(string Name);\r\n        public ManualResetNamedEvent(string Name, bool initialValue);\r\n\r\n        #region IEvent\r\n        public void Set();\r\n        public void Reset();\r\n        #endregion\r\n\r\n        #region IWaitable\r\n        public void Wait();\r\n        public bool Wait(TimeSpan timeout);\r\n        public bool Wait(int timeoutMs);\r\n        #endregion\r\n\r\n        #region IDisposable\r\n        public void Dispose();\r\n        #endregion\r\n    }\r\n\r\n    public class AutoResetNamedEvent : IWaitable, IEvent, IDisposable\r\n    {\r\n        public AutoResetNamedEvent(string Name);\r\n        public AutoResetNamedEvent(string Name, bool initialValue);\r\n\r\n        #region IEvent\r\n        public void Set();\r\n        public void Reset();\r\n        #endregion\r\n\r\n        #region IWaitable\r\n        public void Wait();\r\n        public bool Wait(TimeSpan timeout);\r\n        public bool Wait(int timeoutMs);\r\n        #endregion\r\n\r\n        #region IDisposable\r\n        public void Dispose();\r\n        #endregion\r\n    }\r\n\r\n    // This is a counter that can be incremented and decremented. Wait operations block until \r\n    // counter is 0. Its kind of the opposite of a semaphore.\r\n    public class WaitableCounter : IWaitable, IDisposable\r\n    {\r\n        public WaitableCounter(string Name);\r\n        public WaitableCounter(string Name, int initialValue);\r\n\r\n        public void Increment();\r\n\r\n        // Returns false if counter would go below zero\r\n        public bool Decrement();\r\n\r\n        #region IWaitable\r\n        public void Wait();\r\n        public bool Wait(TimeSpan timeout);\r\n        public bool Wait(int timeoutMs);\r\n        #endregion\r\n\r\n        #region IDisposable\r\n        public void Dispose();\r\n        #endregion\r\n    }\r\n\r\n    public class SharedMemory : IDisposable\r\n    {\r\n        // will create the shared memory area if it doesn\u0027t already exist. Else it will just open it\r\n        public SharedMemory(string name, long size);\r\n\r\n        // constructor requires just a name, opens the shared memory\r\n        // area if it exists, or throws an exception if it doesn\u0027t\r\n        public SharedMemory(string name);\r\n\r\n        public Memory\u003cbyte\u003e Data { get; }\r\n\r\n        #region IDisposable\r\n        public void Dispose();\r\n        #endregion\r\n    }\r\n}\r\n\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHORN5WLQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQxNjMyNjE4MQ==",
                                           "createdAt":  "2018-08-27T18:41:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "@jkotas @stephentoub ",
                                           "updatedAt":  "2018-08-27T18:41:21Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQxNzkyNTE5NQ==",
                                           "createdAt":  "2018-09-02T11:51:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "svick",
                                           "body":  "Is there a reason why the API is synchronous? Would it be possible to make it asynchronous? ",
                                           "updatedAt":  "2018-09-02T11:51:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQxNzkyNTYxNw==",
                                           "createdAt":  "2018-09-02T11:58:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "odhanson",
                                           "body":  "@svick we are trying to find the common denominator for all platforms.  AFAIK the posix APIs are synchronous and most of the use cases too. \r\n\r\nI dont see any problem wrapping these APIs with Tasks if you need to make them Async. ",
                                           "updatedAt":  "2018-09-02T11:58:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5E3lYt",
                                           "createdAt":  "2022-06-14T16:24:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "deeprobin",
                                           "body":  "I think we should add at least CancellationTokens to the Wait-APIs",
                                           "updatedAt":  "2022-06-14T16:24:18Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "API Proposal for System.Interprocess namespace",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading",
                       "os-linux"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/28194",
        "createdAt":  "2018-12-13T17:47:34Z",
        "number":  28194,
        "author":  "MgSam",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODOE4uw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AnderssonPeter",
                                            "createdAt":  "2021-04-27T17:53:06Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "momvart",
                                            "createdAt":  "2021-06-24T17:10:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ascott18",
                                            "createdAt":  "2021-08-11T16:39:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "vslee",
                                            "createdAt":  "2021-10-16T19:23:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rodion-m",
                                            "createdAt":  "2022-02-07T18:46:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "xanth",
                                            "createdAt":  "2022-05-30T02:07:25Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "amis92",
                                            "createdAt":  "2022-07-22T13:46:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "danielchalmers",
                                            "createdAt":  "2022-09-11T16:00:45Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mahara",
                                            "createdAt":  "2022-09-25T16:41:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "cremor",
                                            "createdAt":  "2023-02-26T07:47:17Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "crozone",
                                            "createdAt":  "2023-07-13T02:07:06Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "svick",
                                            "createdAt":  "2023-07-13T10:26:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Leon99",
                                            "createdAt":  "2024-03-27T05:06:42Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "JSGInray",
                                            "createdAt":  "2024-04-11T06:31:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "swimmesberger",
                                            "createdAt":  "2024-05-29T08:30:04Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Charlieface",
                                            "createdAt":  "2024-06-11T12:05:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "idg10",
                                            "createdAt":  "2024-07-17T07:35:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dystopiandev",
                                            "createdAt":  "2024-07-17T09:04:51Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "julealgon",
                                            "createdAt":  "2024-07-17T14:20:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "vladd",
                                            "createdAt":  "2024-10-17T08:16:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "CSymes",
                                            "createdAt":  "2025-09-03T06:55:36Z"
                                        }
                                    ],
                          "totalCount":  21
                      },
        "updatedAt":  "2024-07-17T14:22:47Z",
        "body":  "Please add @stephentoub\u0027s excellent [AsyncLock ](https://blogs.msdn.microsoft.com/pfxteam/2012/02/12/building-async-coordination-primitives-part-6-asynclock/) and async primitive friends into Core FX. \r\n\r\nI searched and was surprised not to find this suggested before. Feel free to close this if it was and I just couldn\u0027t find it. \r\n\r\nWhile it is true that Stephen Cleary has added this to his great [AsyncEx](https://github.com/StephenCleary/AsyncEx/wiki/AsyncLock) library, I think this is a common enough need that it should be part of the framework itself.\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOhR_MiA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ0NzgzMDUwMw==",
                                           "createdAt":  "2018-12-17T12:35:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ichensky",
                                           "body":  "`SemaphoreSlim` already have implemented method: `WaitAsync`, that return `Task`.",
                                           "updatedAt":  "2018-12-17T12:35:02Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ0NzkyMjk1MA==",
                                           "createdAt":  "2018-12-17T17:11:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAgg3VQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MgSam",
                                                                               "createdAt":  "2018-12-17T17:54:29Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "@ichensky - The primary benefit of `AsyncLock` would be having an `IDisposable` implementation, so that unlocks are automatic at the end of a scope.  Probably, you\u0027d build it around a `SemaphoreSlim`, yes (although something making use of `ValueTask` might perform better).\r\n\r\nNote, however, that although an async lock is useful/necessary in some situations, blind use makes it really easy to lead to deadlocks.  For instance, if you have another async call inside the scope of an `AsyncLock`... the lock is retained for the duration of the suspension.  Which is normally necessary, but is lengthening the time the lock is held, which is troublesome.",
                                           "updatedAt":  "2018-12-17T17:11:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ0NzkzNzM2Mg==",
                                           "createdAt":  "2018-12-17T17:55:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MgSam",
                                           "body":  "@Clockwork-Muse I\u0027d argue *any* locking can easily lead to deadlocks. Or race conditions. \r\n\r\nObviously, its far better to avoid writing to shared data structures with multi-threaded code, and if you do, use a framework type. But sometimes that\u0027s just not possible and you need to lock on something.",
                                           "updatedAt":  "2018-12-17T17:55:46Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ0Nzk3NzYxNg==",
                                           "createdAt":  "2018-12-17T19:56:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "Oh, no, I agree, sometimes you really need to do something like that.  For instance, I was messing with something that was doing multi-threaded writes to a shared TCP connection (in response to received messages, no less).\r\n\r\nIt\u0027s just that the way continuations work means that the potential for deadlock is much higher, because of the assumption of safety, and the types of resources being accessed.",
                                           "updatedAt":  "2018-12-17T19:56:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4MjI1MjAxMQ==",
                                           "createdAt":  "2019-04-11T18:54:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCfKg8A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "ROCKET",
                                                                               "user":  "JohnKiller",
                                                                               "createdAt":  "2019-10-13T13:29:08Z"
                                                                           },
                                                                           {
                                                                               "content":  "ROCKET",
                                                                               "user":  "momvart",
                                                                               "createdAt":  "2021-06-24T17:16:45Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "xanth",
                                                                               "createdAt":  "2022-05-30T02:07:49Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "sakno",
                                           "body":  "It would be nice to add asynchronous version of `ReaderWriterLockSlim` and, probably, `AutoResetEvent`/`ManualResetEvent`. IMHO, these classes should have the same public methods as their blocking friends with one exception - lock acquisition methods are asynchronous and return `Task`. **AsyncLock** can provide abstraction over all asynchronous locks (not only exclusive lock) which allows to acquire and release the lock with **using** statement.\r\n\r\nI would like to propose ready-to-use implementations of these locks as a proof of concept. [AsyncExclusiveLock](https://github.com/sakno/dotNext/blob/master/src/DotNext.Threading/Threading/AsyncExclusiveLock.cs), [AsyncReaderWriteLock](https://github.com/sakno/dotNext/blob/master/src/DotNext.Threading/Threading/AsyncReaderWriterLock.cs), [AsyncManualResetEvent](https://github.com/sakno/dotNext/blob/master/src/DotNext.Threading/Threading/AsyncManualResetEvent.cs) and [AsyncAutolResetEvent](https://github.com/sakno/dotNext/blob/master/src/DotNext.Threading/Threading/AsyncAutoResetEvent.cs) are asynchronous versions of `Monitor`, `ReaderWriterLockSlim`, `ManualResetEvent` and `AutoResetEvent` respectively. [AsyncLock](https://github.com/sakno/dotNext/blob/master/src/DotNext.Threading/Threading/AsyncLock.cs#L38) represents acquired asynchronous lock regardless of its type using [extension methods](https://github.com/sakno/dotNext/blob/master/src/DotNext.Threading/Threading/AsyncLockAcquisition.cs).\r\n```csharp\r\nvar readerWriterLock = new AsyncReaderWriteLock();\r\n\r\nusing(await readerWriterLock.AcquireReadLock(CancellationToken.None))\r\n{\r\n  //reader\r\n}\r\n\r\nusing(await readerWriterLock.AcquireWriteLock(TimeSpan.FromSeconds(1))\r\n{\r\n  //writer\r\n}\r\n\r\nusing(await readerWriterLock.AcquireUpgradeableLock(TimeSpan.FromSeconds(1), CancellationToken.None)\r\n{\r\n  //code protected by upgradeable lock\r\n}\r\n\r\nvar exclusiveLock = new AsyncExclusiveLock();\r\n\r\nusing(await exclusiveLock.AcquireLock(CancellationToken.None))\r\n{\r\n  //code protected by mutually exclusive lock\r\n}\r\n\r\nvar sem = new SemaphoreSlim(0, 42);\r\n\r\nusing(await sem.AcquireLockAsync(CancellationToken.None))\r\n{\r\n\r\n}\r\n```\r\nDuring the implementation I found that usage of `ValueTask` was unnecessary. It seems to me that .NET team has come to the same conclusion during implementation of `SemaphoreSlim`. @Clockwork-Muse, let me explain why.\r\n\r\nAccording with official [doc](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.valuetask-1):\r\n\u003e A method may return an instance of this value type when it\u0027s likely that the result of its operation will be available synchronously\r\n\r\nIt means that a) `ValueTask` valuable in the context of **async** method declaration which is b) likely to be completed synchronously. Async method is implemented as state machine. [AsyncValueTaskMethodBuilder](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.asyncvaluetaskmethodbuilder-1) is used if **async** method returns `ValueTask`. In this case, the builder will not allocate task instance on the heap if method has been completed synchronously, in contrast to `Task`-based method. For such kind of methods, [AsyncTaskMethodBuilder](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.asynctaskmethodbuilder-1) is used instead. If the method completes synchronously then it calls [SetResult](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.asynctaskmethodbuilder-1.setresult) but the Task instance was already allocated on the heap. As a result, the completed task instance is not cached and created for each call of async method. \r\n\r\nAsynchronous lock acquisition methods in `SemaphoreSlim` and proposed implementations from my side do not use async method builders and handle lock contention more accurately. If there is no lock contention then cached completed task will be returned. Look at [here](https://github.com/dotnet/corefx/blob/master/src/Common/src/CoreLib/System/Threading/SemaphoreSlim.cs#L632), [here](https://github.com/dotnet/corefx/blob/master/src/Common/src/CoreLib/System/Threading/SemaphoreSlim.cs#L637) and [here](https://github.com/sakno/dotNext/blob/master/src/DotNext.Threading/Threading/QueuedSynchronizer.cs#L129) and you\u0027ll see optimization that I\u0027m talking about. If there is a lock contention then new instance of task will be allocated. Moreover, you need to have some kind of dynamic data structure to store queue of waiters. In case of `SemaphoreSlim`, it is linked list. Each node is allocated on the heap so there is no benefits to use `ValueTask` in case of lock contention.",
                                           "updatedAt":  "2019-05-07T18:43:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNTEwMzYyMA==",
                                           "createdAt":  "2020-05-07T08:16:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "quinmars",
                                           "body":  "The advantage of `ValueTask` is that, unlike `Task`, it is not disposable, so you cannot accidently forget to await it.\r\n\r\n```\r\nusing (locker.LockAsync())  // oops, Task is disposable\r\n{\r\n// ...\r\n}\r\n```",
                                           "updatedAt":  "2020-05-07T08:16:01Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2MTIyMzAzMw==",
                                           "createdAt":  "2021-06-15T06:43:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "RainingNight",
                                           "body":  "Any news?",
                                           "updatedAt":  "2021-06-15T06:43:22Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2NzgyMDMzMA==",
                                           "createdAt":  "2021-06-24T17:27:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODEOk9Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "xanth",
                                                                               "createdAt":  "2022-05-30T02:08:27Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ArminShoeibi",
                                                                               "createdAt":  "2022-08-04T20:09:12Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "slang25",
                                                                               "createdAt":  "2023-07-17T22:23:00Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MineCake147E",
                                                                               "createdAt":  "2023-08-21T06:46:44Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "momvart",
                                           "body":  "After this long time passed since adding tasks, I want to add a vote to this issue to have synchronization primitives in task-based codes.\r\nAlso, it may be worth mentioning that the Visual Studio team has implemented this in [Microsoft.VisualStudio.Threading](https://github.com/microsoft/vs-threading).",
                                           "updatedAt":  "2021-06-24T17:34:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5hXGnX",
                                           "createdAt":  "2023-07-13T02:26:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODAi35Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "RainingNight",
                                                                               "createdAt":  "2023-07-13T03:40:34Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "crozone",
                                           "body":  "No updates?\r\n\r\nIn the meantime I\u0027ve just been using a small modification of Stephen Toub\u0027s version based around `SemaphoreSlim`:\r\n\r\n```csharp\r\npublic class AsyncLock\r\n{\r\n    private readonly SemaphoreSlim semaphore = new SemaphoreSlim(1, 1);\r\n    private readonly Task\u003cIDisposable\u003e releaser;\r\n\r\n    public AsyncLock()\r\n    {\r\n        releaser = Task.FromResult((IDisposable)new AsyncLockReleaser(this));\r\n    }\r\n\r\n    public Task\u003cIDisposable\u003e LockAsync(CancellationToken cancellationToken)\r\n    {\r\n        Task wait = semaphore.WaitAsync(cancellationToken);\r\n        return wait.IsCompletedSuccessfully\r\n            ? releaser\r\n            : wait.ContinueWith(\r\n                (_, state) =\u003e (IDisposable)state!,\r\n                releaser.Result,\r\n                CancellationToken.None,\r\n                TaskContinuationOptions.ExecuteSynchronously,\r\n                TaskScheduler.Default);\r\n    }\r\n\r\n    private sealed class AsyncLockReleaser : IDisposable\r\n    {\r\n        private readonly AsyncLock toRelease;\r\n\r\n        internal AsyncLockReleaser(AsyncLock toRelease) {\r\n            this.toRelease = toRelease;\r\n        }\r\n\r\n        public void Dispose()\r\n        {\r\n            toRelease.semaphore.Release();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nIt would be really nice if an equivalent was included in .NET given how commonly this pattern is used.\r\n\r\n**EDIT: ** Changed `IsCompleted` to `IsCompletedSuccessfully` to fix case when cancellation token is already cancelled.",
                                           "updatedAt":  "2024-04-24T06:10:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5tkIm-",
                                           "createdAt":  "2023-12-04T09:51:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "molinch",
                                           "body":  "@crozone While the semaphore does not need to be disposed when we don\u0027t call `AvailableWaitHandle`, I believe that the finalizer will still kick-in which has minor performance impact.",
                                           "updatedAt":  "2023-12-04T09:51:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc561akO",
                                           "createdAt":  "2024-04-17T09:30:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antmjones",
                                           "body":  "\u003e In the meantime I\u0027ve just been using a small modification of Stephen Toub\u0027s version based around `SemaphoreSlim`:\r\n\r\nThis is broken for the case that the cancellation token is cancelled.\r\n\r\nIn the uncontented case, ```.IsCompleted``` will return true and the cached releaser task will be returned (rather than returning a cancelled task). In the contended case ```.ContinueWith(...)``` will execute the continuation function even if the task returned by semaphore.WaitAsync is in the cancelled state. \r\n\r\nIn both cases, this will lead to code being executed without the lock being held, and then when ```.Dispose()``` is called on the ```AsyncLockReleaser``` a ```SemaphoreFullException``` will be thrown.\r\n",
                                           "updatedAt":  "2024-04-17T09:30:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc563Aox",
                                           "createdAt":  "2024-04-17T13:17:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antmjones",
                                           "body":  "Further to my previous comment, I\u0027d also add that it appears that many of the implementations of AsyncLock that are based on Stephen Toub\u0027s original (but with added support for cancellation) also have similar bugs. For example just by searching under the Microsoft organistation on Github:\r\n\r\nhttps://github.com/microsoft/azure-sdk-for-net-ace/blob/3d338076b1e5802b88a808c500b9b3c97d880dc9/sdk/eventhub/Microsoft.Azure.EventHubs/src/Primitives/AsyncLock.cs#L55\r\n\r\nhttps://github.com/microsoft/sqltoolsservice/blob/6864eb5d95fe0cff9bcf7ef82b8c9d2957039d64/src/Microsoft.SqlTools.Hosting/Utility/AsyncLock.cs#L64\r\n\r\nhttps://github.com/microsoft/electionguard-core2/blob/ae1362bb8846f566ba817daae8fbf854d3b9569c/bindings/netstandard/ElectionGuard/ElectionGuard.ElectionSetup/Concurrency/AsyncLock.cs#L19\r\n\r\nOrleans at least appears to get it correct (uses ```IsCompletedSuccessfully``` rather than ```IsCompleted``` and also avoids ```.ContinueWith```):\r\n\r\nhttps://github.com/dotnet/orleans/blob/deda4baa2892174d0ca2c9fb470f0082ec33a679/src/Orleans.Core/Async/AsyncLock.cs#L67\r\n\r\nAlthough the Orleans implementation always allocates even on the successful case (presumably the motivation for having a separate ```LockReleaser``` object for each call is to make multiple calls to ```LockReleaser.Dispose``` safe).\r\n\r\nAll this seems to me to be evidence that it would be worth having a properly tested and supported primitive shipped with .NET.",
                                           "updatedAt":  "2024-04-17T13:17:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc563D1l",
                                           "createdAt":  "2024-04-17T13:23:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "cremor",
                                           "body":  "@antmjones What do you think about https://github.com/BalassaMarton/AsyncExtensions by @BalassaMarton?\r\nI\u0027ve found it in https://github.com/StephenCleary/AsyncEx/issues/265#issuecomment-2046076100",
                                           "updatedAt":  "2024-04-17T13:23:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc563oqV",
                                           "createdAt":  "2024-04-17T14:31:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antmjones",
                                           "body":  "@cremor For a start, personally I\u0027m not keen on supporting reentrancy over async/await, for the reasons described here:\r\n\r\nhttps://itnext.io/reentrant-recursive-async-lock-is-impossible-in-c-e9593f4aa38a\r\n\r\n(and arguably it\u0027s a bad idea even in the non-async case, see https://blog.stephencleary.com/2013/04/recursive-re-entrant-locks.html)\r\n\r\nApart from that it\u0027s *far* more complex than the solutions based on Stephen Toub\u0027s original example (so more chance of bugs), and I personally wouldn\u0027t want to use any synchronization primitives described as \"experimental\"!\r\n",
                                           "updatedAt":  "2024-04-17T14:31:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc565DG3",
                                           "createdAt":  "2024-04-17T16:59:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "BalassaMarton",
                                           "body":  "@antmjones my repo is not published, nor is production-ready, but might be useful for someone who\u0027s trying to build an async locking library. The key idea is the locking token which you can pass down to subsequent methods that need to take the lock.",
                                           "updatedAt":  "2024-04-17T16:59:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57oA3e",
                                           "createdAt":  "2024-04-24T05:47:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "crozone",
                                           "body":  "\u003e \u003e In the meantime I\u0027ve just been using a small modification of Stephen Toub\u0027s version based around `SemaphoreSlim`:\r\n\u003e \r\n\u003e This is broken for the case that the cancellation token is cancelled.\r\n\u003e \r\n\u003e In the uncontented case, `.IsCompleted` will return true and the cached releaser task will be returned (rather than returning a cancelled task). In the contended case `.ContinueWith(...)` will execute the continuation function even if the task returned by semaphore.WaitAsync is in the cancelled state.\r\n\r\nAhh of course. I think simply changing it to `.IsCompletedSuccessfully` would fix it?\r\n",
                                           "updatedAt":  "2024-04-24T05:47:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57oSXH",
                                           "createdAt":  "2024-04-24T06:23:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antmjones",
                                           "body":  "Using ```.IsCompletedSuccessfully``` or ```.Status == TaskStatus.RanToCompletion``` would fix the uncontended case, but you would also need to include ```TaskContinuationOptions.OnlyOnRanToCompletion``` in the call to ```.ContinueWith()``` or alternatively have a separate method to call in the contended case:\r\n\r\n```\r\n            Task wait = semaphore.WaitAsync(cancellationToken);\r\n\r\n            static async Task\u003cIDisposable\u003e Await(Task semaphoreWaitTask, IDisposable result) {\r\n                await semaphoreWaitTask.ConfigureAwait(false);\r\n                return result;\r\n            }\r\n\r\n            Task\u003cIDisposable\u003e result = wait.IsCompletedSuccessfully ? releaser : Await(wait, releaser.Result);\r\n```\r\n\r\nNote that if using ```.ContinueWith``` I also believe that you **don\u0027t** want to pass the cancellation token as an argument to ```.ContinueWith```, because once the task returned by ```semaphore.WaitAsync``` has completed successfully you *always* want to return a disposable or the semphore won\u0027t get released (i.e. at that point it\u0027s too late to throw an ```OperationCancelledException``` without leaking).\r\n",
                                           "updatedAt":  "2024-04-24T06:23:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6FE0It",
                                           "createdAt":  "2024-07-17T07:35:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEbAaiQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "julealgon",
                                                                               "createdAt":  "2024-07-17T14:20:15Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "dystopiandev",
                                                                               "createdAt":  "2024-07-17T17:56:38Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "BalassaMarton",
                                                                               "createdAt":  "2025-07-17T21:10:59Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "idg10",
                                           "body":  "Just to add another vote towards building something of this kind into .NET, the prototype for AsyncRx.NET currently finds itself obliged to provide its own implementation of this type.\r\n\r\nWorse, that implementation needs to be public. (This is because classic Rx.NET\u0027s `Synchronize` operators have overloads accepting any `object`, enabling applications to supply a single object that synchronizes the operation of any number of observables and observes, and also to synchronize application code too. To get equivalent functionality in AsyncRx.NET, there needs to be some type that can be passed in as the optional `gate` argument which a) AsyncRx.NET can use for locking purposes and b) which the application itself can also lock.)\r\n\r\nWe would really much rather not be in the business of defining thread synchronization primitives. We\u0027ve already had requests to enhance the capability of our `AsyncGate` (and specifically to [add cancellation](https://github.com/dotnet/reactive/issues/2148), something that seems to trip up every project that attempts to solve this same problem for itself).\r\n\r\nThe recurrence of this problem (and the fact that so many projects get it wrong when they bring their own implementation) seems like an argument in favour of building such a thing into the .NET runtime libraries.",
                                           "updatedAt":  "2024-07-17T07:35:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6FH8yI",
                                           "createdAt":  "2024-07-17T14:22:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD2szsg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "dystopiandev",
                                                                               "createdAt":  "2024-07-17T17:56:47Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alexeyshockov",
                                                                               "createdAt":  "2024-07-27T08:04:25Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "vladd",
                                                                               "createdAt":  "2024-10-17T08:18:07Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "julealgon",
                                           "body":  "Would be nice if the behavior was unified on top of the recently introduced `Lock` dedicated type:\r\n- https://github.com/dotnet/runtime/issues/34812",
                                           "updatedAt":  "2024-07-17T14:22:46Z"
                                       }
                                   ],
                         "totalCount":  19
                     },
        "title":  "AsyncLock",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/1435",
        "createdAt":  "2020-01-08T02:36:49Z",
        "number":  1435,
        "author":  "dmitriyse",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOBF5n9Q==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AceHack",
                                            "createdAt":  "2020-05-31T16:43:09Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-07-10T07:04:30Z",
        "body":  "Lock-free algorithms are very popular and all of them are basing on the CAS-like CPU instructions:\r\n```CSharp\r\n    public class RefCounterTests\r\n    {\r\n        private long _state = 10;\r\n\r\n        [MethodImpl(MethodImplOptions.NoInlining)]\r\n        public void LockFreeMethod()\r\n        {\r\n            Debugger.Break();\r\n\r\n            // Classic lock-free state update pattern\r\n            long observedValue = _state;\r\n            long updatedValue, compareValue;\r\n            do\r\n            {\r\n                // Some lock-free update operation\r\n\r\n                updatedValue = observedValue;\r\n                if (observedValue % 2 == 0)\r\n                {\r\n                    updatedValue = observedValue * 3 + 11;\r\n                }\r\n\r\n                compareValue = observedValue;\r\n                observedValue = Interlocked.CompareExchange(ref _state, updatedValue, compareValue);\r\n            }\r\n            while (observedValue != compareValue);\r\n        }\r\n    }\r\n```\r\n\r\nRelease, x86-64 CPU, .Net Core 3.1 JIT Tier1 compiles it to the next CPU instructions:\r\n```Asm\r\n            Debugger.Break();\r\n00007FF9CCC33C62  sub         esp,30h  \r\n00007FF9CCC33C65  mov         rsi,rcx  \r\n00007FF9CCC33C68  call        00007FF9CB3760A8  \r\n\r\n            long observedValue = _state;\r\n00007FF9CCC33C6D  mov         rax,qword ptr [rsi+8]  \r\n00007FF9CCC33C71  add         rsi,8  \r\n            long updatedValue, compareValue;\r\n            do\r\n            {\r\n                // Some lock-free update operation\r\n\r\n                updatedValue = observedValue;\r\n00007FF9CCC33C75  mov         rdx,rax  \r\n                if (observedValue % 2 == 0)\r\n00007FF9CCC33C78  mov         rcx,rdx  \r\n00007FF9CCC33C7B  shr         rcx,3Fh  \r\n00007FF9CCC33C7F  add         rcx,rdx  \r\n00007FF9CCC33C82  and         rcx,0FFFFFFFFFFFFFFFEh  \r\n00007FF9CCC33C86  mov         r8,rdx  \r\n00007FF9CCC33C89  sub         r8,rcx  \r\n00007FF9CCC33C8C  jne         00007FF9CCC33C96  \r\n                {\r\n                    updatedValue = observedValue * 3 + 11;\r\n00007FF9CCC33C8E  lea         rdx,[rax+rax*2]  \r\n                {\r\n                    updatedValue = observedValue * 3 + 11;\r\n00007FF9CCC33C92  add         rdx,0Bh  \r\n                }\r\n\r\n                compareValue = observedValue;\r\n00007FF9CCC33C96  mov         qword ptr [rsp+28h],rax  \r\n00007FF9CCC33C9B  lock cmpxchg qword ptr [rsi],rdx  \r\n            }\r\n            while (observedValue != compareValue);\r\n00007FF9CCC33CA0  cmp         rax,qword ptr [rsp+28h]  \r\n00007FF9CCC33CA5  jne         00007FF9CCC33C75  \r\n00007FF9CCC33CA7  add         rsp,30h  \r\n00007FF9CCC33CAB  pop         rsi  \r\n00007FF9CCC33CAC  ret  \r\n```\r\nCurrently JIT does not re-use ```ZF``` (ZFlag) that is set by ```LOCK CMPXCHG``` instruction and put redundant CMP instruction.\r\nSo the current Interlocked.CompareExchange have some room for optimizations at CPU instruction level.\r\n\r\nWith the additional ```Interlocked.CompareExchange``` overload:\r\n```CSharp \r\n    public static class Interlocked\r\n    {\r\n        [MethodImplAttribute(MethodImplOptions.InternalCall)]        \r\n        public static bool CompareExchange(ref long location1, long @value, ref long comparand)\r\n        {\r\n            // Just logic, it\u0027s a Hardware intrinsics method.\r\n            var comparandLocal = comparand;\r\n            comparand = Interlocked.CompareExchange(ref location1, value, comparandLocal);\r\n            return comparandLocal == comparand;\r\n        }\r\n    }\r\n```\r\n\r\nThe classic lock-free state update loop can be implemented this way:\r\n```CSharp\r\n            var observedValue = Volatile.Read(ref _state);\r\n            long updatedValue;\r\n            do\r\n            {\r\n                // Some lock-free update operation\r\n                updatedValue = observedValue;\r\n                if (observedValue % 2 == 0)\r\n                {\r\n                    updatedValue = observedValue * 3 + 11;\r\n                }\r\n            }\r\n            while (!Interlocked.CompareExchange(ref _state, updatedValue, ref observedValue));\r\n```\r\nAnd the JIT could easily map the new ```bool Interlocked.CompareExchange(ref long, long, ref long)``` version of CAS to the optimal CPU instructions:\r\n```Asm\r\n            Debugger.Break();\r\n00007FF9CCC33C62  sub         esp,30h  \r\n00007FF9CCC33C65  mov         rsi,rcx  \r\n00007FF9CCC33C68  call        00007FF9CB3760A8  \r\n\r\n            long observedValue = _state;\r\n00007FF9CCC33C6D  mov         rax,qword ptr [rsi+8]  \r\n00007FF9CCC33C71  add         rsi,8  \r\n            long updatedValue, compareValue;\r\n            do\r\n            {\r\n                // Some lock-free update operation\r\n\r\n                updatedValue = observedValue;\r\n00007FF9CCC33C75  mov         rdx,rax  \r\n                if (observedValue % 2 == 0)\r\n00007FF9CCC33C78  mov         rcx,rdx  \r\n00007FF9CCC33C7B  shr         rcx,3Fh  \r\n00007FF9CCC33C7F  add         rcx,rdx  \r\n00007FF9CCC33C82  and         rcx,0FFFFFFFFFFFFFFFEh  \r\n00007FF9CCC33C86  mov         r8,rdx  \r\n00007FF9CCC33C89  sub         r8,rcx  \r\n00007FF9CCC33C8C  jne         00007FF9CCC33C96  \r\n                {\r\n                    updatedValue = observedValue * 3 + 11;\r\n00007FF9CCC33C8E  lea         rdx,[rax+rax*2]  \r\n                {\r\n                    updatedValue = observedValue * 3 + 11;\r\n00007FF9CCC33C92  add         rdx,0Bh  \r\n                }\r\n              \r\n            }\r\n            while (!InterlockedEx.CompareExchange(ref _state, updatedValue, ref observedValue));\r\n// Optimized-Out 00007FF9CCC33C96  mov         qword ptr [rsp+28h],rax  \r\n00007FF9CCC33C9B  lock cmpxchg qword ptr [rsi],rdx  \r\n// Optimized-Out 00007FF9CCC33CA0  cmp         rax,qword ptr [rsp+28h]  \r\n00007FF9CCC33CA5  jne         00007FF9CCC33C75  \r\n00007FF9CCC33CA7  add         rsp,30h  \r\n00007FF9CCC33CAB  pop         rsi  \r\n00007FF9CCC33CAC  ret  \r\n```\r\n\r\nThe proposed ```Interlockd.CompareExchange``` overloads in any case could give benefits to simplify lock-free code.\r\nBut also could help JIT to generate more optimal CPU instructions. (It\u0027s very hard to predict how this JIT improvement will improve the performance, but probably non more than 1%).",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOhE404w==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3MTg2NjA1NA==",
                                           "createdAt":  "2020-01-08T02:40:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dmitriyse",
                                           "body":  "This issue is also related to the https://github.com/dotnet/corefx/issues/10481",
                                           "updatedAt":  "2020-01-08T02:40:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3MTg3ODE1Mg==",
                                           "createdAt":  "2020-01-08T03:42:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "scalablecory",
                                           "body":  "Your \"classic pattern\" isn\u0027t optimal and is inflating the gains. I would instead implement it as:\r\n\r\n```c#\r\n            long observedValue = _state;\r\n            long updatedValue, compareValue;\r\n            do\r\n            {\r\n                // Some lock-free update operation\r\n\r\n                updatedValue = observedValue;\r\n                if (observedValue % 2 == 0)\r\n                {\r\n                    updatedValue = observedValue * 3 + 11;\r\n                }\r\n\r\n                compareValue = observedValue;\r\n                observedValue = Interlocked.CompareExchange(ref _state, updatedValue, compareValue);\r\n            }\r\n            while (observedValue != compareValue);\r\n```\r\n\r\nI think ideally JIT would optimize this properly, but even VC++ had a hard time doing it for a long time.",
                                           "updatedAt":  "2020-01-08T03:42:37Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3MTg4MDY3MQ==",
                                           "createdAt":  "2020-01-08T03:55:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBF5n7A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "scalablecory",
                                                                               "createdAt":  "2020-01-08T13:24:22Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AceHack",
                                                                               "createdAt":  "2020-05-31T16:42:58Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "dmitriyse",
                                           "body":  "@scalablecory, thank you for the tip about lock-free update pattern. (I have updated the issue)\r\n```Asm\r\n            long observedValue = _state;\r\n00007FF9CCC33C6D  mov         rax,qword ptr [rsi+8]  \r\n00007FF9CCC33C71  add         rsi,8  \r\n            long updatedValue, compareValue;\r\n            do\r\n            {\r\n                // Some lock-free update operation\r\n\r\n                updatedValue = observedValue;\r\n00007FF9CCC33C75  mov         rdx,rax  \r\n                if (observedValue % 2 == 0)\r\n00007FF9CCC33C78  mov         rcx,rdx  \r\n00007FF9CCC33C7B  shr         rcx,3Fh  \r\n00007FF9CCC33C7F  add         rcx,rdx  \r\n00007FF9CCC33C82  and         rcx,0FFFFFFFFFFFFFFFEh  \r\n00007FF9CCC33C86  mov         r8,rdx  \r\n00007FF9CCC33C89  sub         r8,rcx  \r\n00007FF9CCC33C8C  jne         00007FF9CCC33C96  \r\n                {\r\n                    updatedValue = observedValue * 3 + 11;\r\n00007FF9CCC33C8E  lea         rdx,[rax+rax*2]  \r\n                {\r\n                    updatedValue = observedValue * 3 + 11;\r\n00007FF9CCC33C92  add         rdx,0Bh  \r\n                }\r\n\r\n                compareValue = observedValue;\r\n00007FF9CCC33C96  mov         qword ptr [rsp+28h],rax  \r\n00007FF9CCC33C9B  lock cmpxchg qword ptr [rsi],rdx  \r\n            }\r\n            while (observedValue != compareValue);\r\n00007FF9CCC33CA0  cmp         rax,qword ptr [rsp+28h]  \r\n00007FF9CCC33CA5  jne         00007FF9CCC33C75  \r\n00007FF9CCC33CA7  add         rsp,30h  \r\n00007FF9CCC33CAB  pop         rsi  \r\n00007FF9CCC33CAC  ret  \r\n```\r\nYour version is little bit more optimal in the beginning of the loop, but the ending part compiles totally the same way.",
                                           "updatedAt":  "2020-01-08T04:16:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ERaMy",
                                           "createdAt":  "2024-07-10T00:28:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Due to lack of recent activity, this issue has been marked as a candidate for backlog cleanup.  It will be closed if no further activity occurs within 14 more days. Any new comment (by anyone, not necessarily the author) will undo this process.\n\nThis process is part of our [issue cleanup automation](https://github.com/dotnet/runtime/blob/main/docs/issue-cleanup.md).\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-07-10T00:28:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ETjTj",
                                           "createdAt":  "2024-07-10T07:04:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dmitriyse",
                                           "body":  "@stephentoub, can you please look at this proposal? .Net runtime uses LOCK CMPXCHG extensively. This proposal can save up to two instructions per Interlocked.CompareExchange call. Even if it\u0027s not a major runtime optimization, it may be worth implementing it. Together with other optimizations of a similar kind, each .Net version has a significant performance jump each version.",
                                           "updatedAt":  "2024-07-10T07:04:29Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "[Perf Optimization] Optimized Interlocked.CompareExchange JIT/CodeGeneration with ZF flag respect",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/2382",
        "createdAt":  "2020-01-30T10:05:41Z",
        "number":  2382,
        "author":  "ayende",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCrkUgQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "speshuric",
                                            "createdAt":  "2020-02-27T06:37:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "reyang",
                                            "createdAt":  "2022-11-22T16:24:58Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2022-09-26T18:46:05Z",
        "body":  "The problem below reproduce an issue that we have run into in production.\r\n\r\nWe have a lot of ThreadLocal instances and quite a number of threads and we noticed very high latency for GC / CPU time spent collecting.\r\n\r\nThe code below creates a large number of `ThreadLocal\u003cWeakReference\u003e` and uses them from a number of threads. We manually induce GC into the system to measure its costs on a frequent basis.\r\n\r\nOur observations is that while we are doing active work, we are seeing GC times that exceed 1 second at times (average of about 500 ms) and when there is _no work at all_, all threads are idle and only the GC is running, we are seeing \u003e 250 ms for GC runs.\r\n\r\nOur current assumption is that the lattice like nature of `ThreadLocal` with thread static arrays with each item linked to the next thread, is causing the GC to spend a lot of time in the mark phase. \r\n\r\n\r\n\r\n```c#\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics;\r\nusing System.Runtime;\r\nusing System.Text;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace RavenTicket\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            Console.WriteLine($\"GC ServerMode: {GCSettings.IsServerGC }, LOH Compact: {GCSettings.LargeObjectHeapCompactionMode}, Latency: {GCSettings.LatencyMode} \");\r\n\r\n            int running = 0, stopped = 0;\r\n            var abc = new string(\u0027*\u0027, 1024*2024);\r\n\r\n            var task = Task.Run(() =\u003e\r\n            {\r\n                var foregroundColor = Console.ForegroundColor;\r\n                while (true)\r\n                {\r\n                    var sp = Stopwatch.StartNew();\r\n                    GC.Collect(2);\r\n                    var gc = sp.ElapsedMilliseconds;\r\n                    sp.Restart();\r\n                    GC.WaitForPendingFinalizers();\r\n                    var run = Volatile.Read(ref running);\r\n                    var stop = Volatile.Read(ref stopped);\r\n                    if (gc \u003e 200)\r\n                    {\r\n                        Console.ForegroundColor= ConsoleColor.Red;\r\n                    }\r\n                    Console.WriteLine($\"{gc} - {sp.ElapsedMilliseconds} - {run} - {stop} - {run - stop:#,#;;0}\");\r\n                    if (gc \u003e 200)\r\n                    {\r\n                        Console.ForegroundColor = foregroundColor;\r\n                    }\r\n                    Thread.Sleep(500);\r\n                }\r\n            });\r\n\r\n            var list = new List\u003cThreadLocal\u003cWeakReference\u003e\u003e();\r\n            var threads = new List\u003cThread\u003e();\r\n\r\n            const int numberOfThreadLocals = 10_000;\r\n            const int numberOfThreads = 2500;\r\n            const int numberOfActiveThreads = 64;\r\n\r\n\r\n            for (int i = 0; i \u003c numberOfThreadLocals; i++)\r\n            {\r\n                list.Add(new ThreadLocal\u003cWeakReference\u003e());\r\n            }\r\n            var stageOne= new CountdownEvent(numberOfThreads);\r\n            var stageTwo = new SemaphoreSlim(0, numberOfActiveThreads);\r\n            for (int i = 0; i \u003c numberOfThreads; i++)\r\n            {\r\n                var copy = i;\r\n                threads.Add(new Thread(() =\u003e\r\n                {\r\n                    for (var index = copy; index \u003c list.Count; index += (copy % 10) + 1)\r\n                    {\r\n                        list[index].Value = null;\r\n                    }\r\n                    stageOne.Signal();\r\n                    stageTwo.Wait();\r\n                    Interlocked.Increment(ref running);\r\n                    string s = null;\r\n                    if (copy % 128 == 0)\r\n                        s = AllocateLotsOfMemory();\r\n                    for (var index = copy; index \u003c numberOfThreadLocals; index += 16)\r\n                    {\r\n                        var t = list[index];\r\n                        if (index % 2 == 0)\r\n                        {\r\n                            t.Value = new WeakReference(list);\r\n                        }\r\n                        else if ((index % 5) == 0)\r\n                        {\r\n                            t.Value = new WeakReference(abc);\r\n                        }\r\n                        else if ((index % 51) == 0)\r\n                        {\r\n                            t.Value =\r\n                                new WeakReference(s);\r\n                        }\r\n                        else\r\n                        {\r\n                            t.Value =\r\n                              new WeakReference(AllocateLotsOfMemory());\r\n                        }\r\n                    }\r\n\r\n                    s = null;\r\n                    stageTwo.Release();\r\n                    Interlocked.Increment(ref stopped);\r\n                    threads[copy].Join();\r\n                })\r\n                {\r\n                    IsBackground = true\r\n                });\r\n            }\r\n            threads.ForEach(t =\u003e t.Start());\r\n            Console.WriteLine(\"Init...\");\r\n            stageOne.Wait();\r\n            Console.WriteLine(\"Starting..\");\r\n            stageTwo.Release(64);\r\n            \r\n\r\n\r\n            Task.Run(() =\u003e // force some additional memory traffic\r\n            {\r\n                for (int i = 0; i \u003c 200_000; i++)\r\n                {\r\n                    AllocateLotsOfMemory();\r\n                }\r\n            });\r\n\r\n            task.Wait();\r\n            Console.WriteLine(abc);\r\n        }\r\n\r\n        private static string AllocateLotsOfMemory()\r\n        {\r\n            var sb = new StringBuilder();\r\n            for (int j = 0; j \u003c 10_000; j++)\r\n            {\r\n                sb.Append(j);\r\n            }\r\n\r\n            var s1 = sb.ToString();\r\n            return s1;\r\n        }\r\n    }\r\n}\r\n\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOSwKVFw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4MDE4NjQ4Ng==",
                                           "createdAt":  "2020-01-30T10:23:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ayende",
                                           "body":  "Here is another reproduction, this time without `ThreadLocal` or any threading work, which shows interesting results.\r\n\r\nWe created a lattice like structure, many arrays that are forming doubly linked list to other nodes in the same index on the other arrays.\r\n\r\nThe cost of GC here is around 250 ms.\r\nRemoving the `Prev / Next` references removes 20% of the cost, and removing the `Array` as well reduce the cost by half.\r\n\r\n\r\n```c#\r\nclass Program\r\n{\r\n    struct Item\r\n    {\r\n        public Node Node;\r\n    }\r\n\r\n    class Node\r\n    {\r\n        public Node Next, Prev;\r\n        public Item[] Array;\r\n    }\r\n\r\n    static void Main(string[] args)\r\n    {\r\n        var lattice = new List\u003cItem[]\u003e();\r\n\r\n        const int x = 4096;\r\n        const int y = 8192;\r\n\r\n        for (int i = 0; i \u003c x; i++)\r\n        {\r\n            lattice.Add(new Item[y]);\r\n        }\r\n\r\n        for (int i = 0; i \u003c x; i++)\r\n        {\r\n            var cur = new Node\r\n            {\r\n                Array = lattice[i]\r\n            };\r\n            lattice[i][0] = new Item { Node = cur };\r\n            for (int j = 1; j \u003c y; j += 2)\r\n            {\r\n                var next = new Node\r\n                {\r\n                    Prev = cur,\r\n                    Array = lattice[i],\r\n                };\r\n\r\n                lattice[i][j] = new Item { Node = next };\r\n\r\n                cur.Next = next;\r\n                cur = next;\r\n            }\r\n        }\r\n\r\n        for (int i = 0; i \u003c 5; i++)\r\n        {\r\n            var sp = Stopwatch.StartNew();\r\n\r\n            GC.Collect(2);\r\n\r\n            System.Console.WriteLine(sp.ElapsedMilliseconds);\r\n        }\r\n\r\n        Console.ReadLine();\r\n        GC.KeepAlive(lattice);\r\n\r\n    }\r\n}\r\n```",
                                           "updatedAt":  "2020-02-12T18:56:22Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4MDE4OTY5Nw==",
                                           "createdAt":  "2020-01-30T10:31:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "cc: @Maoni0 ",
                                           "updatedAt":  "2020-01-30T10:31:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4MTc1NjM3OA==",
                                           "createdAt":  "2020-02-04T06:01:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Maoni0",
                                           "body":  "@cshung could you please take a look? ",
                                           "updatedAt":  "2020-02-04T06:01:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4MjAzNTIyMw==",
                                           "createdAt":  "2020-02-04T17:55:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "cshung",
                                           "body":  "I am taking a first look at the issue using the 2nd repro. First, I am able to reproduce the described latency, on my machine, it is around 300ms.\r\n\r\nThe profile indicates that these two functions are using most of the time (The time range to analyze is set to be the duration of `GC.Collect`.\r\n\r\n| Name | Exc % | Exc | Inc % | Inc |\r\n| --- | --- | --- | --- | --- |\r\n| coreclr!WKS::gc_heap::mark_object_simple1 | 69.6 | 1,340 | 69.8 | 1,343 |\r\n| coreclr!WKS::gc_heap::plan_phase | 25.0 | 482 | 25.5 | 491|\r\n\r\nThese functions do not call anything else, and together they spend 95.3% of the time.\r\n\r\nRoughly speaking, the `mark_object_simple1` function spend time proportional to the size of the object graph (i.e. the number of objects + number of references), and the `plan_phase` is spending time proportional to the number of objects.\r\n\r\nYou are creating approximately 4k x 8k = 32M objects, and the algorithm is processing them in 250ms. Therefore the speed is 32M/250m, which is approximately 0.1 objects per nanosecond.\r\n\r\nThat number looks like a very high speed to me. I am not sure how much more we could speed this up. \r\n\r\nThe garbage collector is obligated to manage the memory at the object level. With many objects, it is going to be slow. Is there a way to reduce the number of objects? \r\n",
                                           "updatedAt":  "2020-02-04T22:38:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4MjExNzYwMA==",
                                           "createdAt":  "2020-02-04T21:13:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Maoni0",
                                           "body":  "are you looking at the 2nd or the 1st case? I\u0027m guessing the 2nd?\r\n\r\nthe 1st case sounds more interesting to me especially this:\r\n\r\n\u003e Our observations is that while we are doing active work, we are seeing GC times that exceed 1 second at times (average of about 500 ms) and when there is no work at all, all threads are idle and only the GC is running, we are seeing \u003e 250 ms for GC runs.\r\n\r\nwould be good to see what active work would cause GC to be so much longer? also is this using WKS or SVR GC? \r\n",
                                           "updatedAt":  "2020-02-04T21:13:14Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4MjE1ODQ4Nw==",
                                           "createdAt":  "2020-02-04T23:03:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "cshung",
                                           "body":  "@Maoni0, the analysis above is based on the 2nd repro.\r\nFor the 1st repro, the analysis is not as clear cut, but it is more or less than the same conclusion.\r\n\r\nThe repro code is measuring the time spent during `GC.Collect()`. These induced `GC` should not run concurrently with user code? \r\n\r\nI tried to set the time range so that `GC.Collect()` is on the stack. The process is spending 22.5% of its time doing garbage collection, out of that, 19.3% of time is spent on `coreclr!WKS::gc_heap::mark_object_simple1`. \r\n\r\nAgain, we have the same problem of having too many objects.\r\n\r\nOne thing that catches my eyes is the abundance of `Allocated too much during BGC, waiting for BGC to finish`. This happens a lot.",
                                           "updatedAt":  "2020-02-04T23:03:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4MjE2MjMxOQ==",
                                           "createdAt":  "2020-02-04T23:15:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Maoni0",
                                           "body":  "\u003e The repro code is measuring the time spent during GC.Collect(). These induced GC should not run concurrently with user code?\r\n\r\nit doesn\u0027t run concurrently with the managed threads in the same process; there can be native threads running in the same process; or threads from other processes can be running of course. \r\n\r\nif it\u0027s WKS GC, it\u0027s just a normal priority thread so other threads could be affecting it, if it runs on the same core. \r\n\r\n\u003e One thing that catches my eyes is the abundance of Allocated too much during BGC, waiting for BGC to finish. This happens a lot.\r\n\r\nyes this is by design - for a test that just does allocation it\u0027s not surprising. ",
                                           "updatedAt":  "2020-02-04T23:15:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4MjMzNTQ2MQ==",
                                           "createdAt":  "2020-02-05T10:13:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ayende",
                                           "body":  "This is running on SVR GC, I believe that my test case here is basically doing nothing, and causing high GC because of the number of objects / references we see.\r\n\r\nWhen we run it for real, we aren\u0027t running GC constantly but letting it run at its own pace. The server is loaded, so when we need to do a real GC run, it has real work to do. I think that the real work + the lattice structure I have here is causing it to stall for a very long time.\r\n\r\nNote that this is something that we typically see after multiple weeks of running on a high load scenario, so it is hard to reproduce the 1+ sec stall times. In my tests, especially with the thread local, I did see some 1+ sec pause times, but they aren\u0027t consistent.\r\n\r\nWe have a proc dump (linux, 100+GB) of the real situation, and will be happy to provide any information from it you need.\r\n",
                                           "updatedAt":  "2020-02-05T10:13:43Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4MjMzNjI1Mw==",
                                           "createdAt":  "2020-02-05T10:15:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ayende",
                                           "body":  "I don\u0027t know if anything can be done with regards to the second case. I think that this is just a case where we put a lot of work on the GC. \r\nBut for the second case, with `ThreadLocal` is more concerning. The problem is that if you have lots of instances of that / lots of threads, you end up in this situation.\r\n\r\nThis can happen easily if you are running using `ConcurrentBag` to do something, which will end up causing slowdowns.",
                                           "updatedAt":  "2020-02-05T10:15:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4MzA2NDk5OQ==",
                                           "createdAt":  "2020-02-06T19:16:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "cshung",
                                           "body":  "Running the first repro with server GC, here is a profile with the time range set to a particular induced GC.\r\n\r\nName | Exc % | Exc | Inc % | Inc\r\n-- | -- | -- | -- | --\r\ncoreclr!SVR::gc_heap::mark_object_simple1 | 47.0 | 1,423 | 47.6 | 1,441\r\ncoreclr!SVR::gc_heap::relocate_address | 16.1 | 486 | 16.1 | 487\r\ncoreclr!SVR::gc_heap::relocate_in_large_objects | 14.3 | 433 | 21.1 | 639\r\ncoreclr!SVR::gc_heap::relocate_survivor_helper | 8.4 | 253 | 17.3 | 523\r\ncoreclr!SVR::gc_heap::plan_phase | 6.8 | 207 | 47.8 | 1,445.182\r\n\r\nNothing stands out in the trace related to the use of `ThreadLocal`. Taking a deeper look into what is actually happening in a debugger.",
                                           "updatedAt":  "2020-02-06T19:16:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4MzE5ODA4Mg==",
                                           "createdAt":  "2020-02-07T01:55:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOA7GGvA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Maoni0",
                                                                               "createdAt":  "2020-02-07T20:41:40Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "NightOwl888",
                                                                               "createdAt":  "2020-02-09T06:33:03Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "cshung",
                                           "body":  "Using `List\u003cThreadLocal\u003cWeakReference\u003e\u003e` seems to blow up the number of objects quite a bit.\r\n\r\nIgnoring the objects like the `List` and the underlying array, the `FinalizerHelper` in `ThreadLocal`, and so on. These objects don\u0027t have a high count.\r\n\r\nAssuming there are `T` threads and all threads have some thread-specific value.\r\n\r\nA `ThreadLocal\u003cT\u003e` internally manages a linked list of slots for each value it manages. So `ThreadLocal\u003cT\u003e` translates into `T` objects.\r\nNow each of them the `T` is a `WeakReference`, which is a class, so we have 2`T` values.\r\nA `WeakReference` has a target, so we have `3T` values.\r\nRepeat this for `L` instances of `ThreadLocal\u003cWeakReference\u003e`, you have `3LT` objects.\r\n\r\nLooking into the `ConcurrentBag\u003cT\u003e`\u0027s implementation, there is a single instance of `ThreadLocal\u003cWorkStealingQueue\u003e` is indeed used there. The application code might have created a list of `ConcurrentBag\u003cT\u003e`s.\r\n\r\n`ThreadLocal\u003cT\u003e` implements `IDisposable`. The idea is that you can dispose of a `ThreadLocal\u003cT\u003e` instance and it will reclaim the thread static slot for others. Normally you expect only one thread to call `Dispose()`, but all the values for all threads should be available for garbage collection. It is for this reason why we needed to keep a linked list for all the slots so that we can null out the values. The `ConcurrentBag\u003cT\u003e` implementation never dispose of the `ThreadLocal\u003cWorkStealingQueue\u003e` it owns, so that level of bookkeeping is wasted. (And the slot is forever leaked)\r\n\r\nAfter researching for a while already, I stumbled upon [this](http://download.microsoft.com/download/B/C/F/BCFD4868-1354-45E3-B71B-B851CD78733D/PerformanceCharacteristicsOfThreadSafeCollection.pdf) paper, which basically validated what I just said.\r\n\r\nWhen I search about `ConcurrentBag\u003cT\u003e` leak, I found [this](https://ayende.com/blog/156097/the-high-cost-of-concurrentbag-in-net-4-0?key=742a9bdb-d633-4779-8a43-a5393c97c75a\u0026utm_source=feedburner\u0026utm_medium=twitter\u0026utm_campaign=Feed%3a%20AyendeRahien%20%28Ayende%20@%20Rahien%29) too. \r\n\r\nAt the end of the day, GC performance in your scenario is basically dictated by the number of objects. Reducing object count seems to be the way to go (it may be hard, I don\u0027t know ...)\r\n\r\nThe same scenario can probably be implemented with a `ThreadStatic` weak `GCHandle` array. `GCHandle` being a struct, you have only 1 thread static array with `LT` objects that you need.",
                                           "updatedAt":  "2020-02-07T01:55:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4MzgyMDk2Mg==",
                                           "createdAt":  "2020-02-09T08:51:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOA7L8kQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "cshung",
                                                                               "createdAt":  "2020-02-10T17:29:16Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "ayende",
                                           "body":  "We wrote a different impl of thread local, you can see it here: \r\nhttps://github.com/ravendb/ravendb/blob/v4.2/src/Sparrow/Threading/LightWeightThreadLocal.cs\r\n\r\nThe idea here is to avoid the kind of lattice structure and help to deal with large number of `ThreadLocal` instances.",
                                           "updatedAt":  "2020-02-09T08:51:53Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4NTM5ODIwNw==",
                                           "createdAt":  "2020-02-12T20:18:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBMJgmw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "noocyte",
                                                                               "createdAt":  "2020-02-13T09:46:46Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "krapans",
                                                                               "createdAt":  "2020-08-02T09:57:37Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "cshung",
                                           "body":  "I am glad to share with this thread some numbers I achieved with [my change](https://github.com/dotnet/runtime/pull/31940) for scenario 1.\r\n\r\nhttps://github.com/dotnet/runtime/pull/31940#issuecomment-585365740\r\n\r\nThe GC latency reduced significantly.\r\n\r\n@ayende, if you could take my patch and see if that improves your real scenario and report that, that would be great.\r\n\r\n**Here is my plan:**\r\n\r\nThe last few CI failures are hard, I am looking for expert to help. Since you implemented your own `ThreadLocal\u003cT\u003e` as well, if you could figure out what gone wrong there, that would be great.\r\n\r\nNext, I plan to wait for you to report back the result and see if my fix helped with your actual scenario. \r\n\r\nIf it helped with your actual scenario, and the CI failures are fixed, we will merge the PR, together with that, I will close this issue.\r\n\r\nIs this plan good for you?\r\n\r\nSince you were developing benchmarks, you might be interested in our [performance](https://github.com/dotnet/performance) repo. There we keep all the benchmark we cared about to keep them running fast. If you wanted to make sure your scenario stays fast too, you might consider contributing there.\r\n\r\n",
                                           "updatedAt":  "2020-02-12T20:18:14Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4NTc5MTI2NQ==",
                                           "createdAt":  "2020-02-13T14:46:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ayende",
                                           "body":  "This looks good to me.",
                                           "updatedAt":  "2020-02-13T14:46:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5LAH_h",
                                           "createdAt":  "2022-09-26T16:38:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "andreminelli",
                                           "body":  "@cshung and @ayende, this issue hasn\u0027t been solved on version 6.0, right?\r\n",
                                           "updatedAt":  "2022-09-26T16:38:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5LALJN",
                                           "createdAt":  "2022-09-26T16:49:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "cshung",
                                           "body":  "\u003e @cshung and @ayende, this issue hasn\u0027t been solved on version 6.0, right?\r\n\r\nYes, sadly. The root cause is well understood, and I had a [PR](https://github.com/dotnet/runtime/pull/31940) for it that gives some promising wins. It wasn\u0027t completed because we had some unknown bug in that change that blocks CI.\r\n\r\n@andreminelli, if you could help with following up with that, it would be great.",
                                           "updatedAt":  "2022-09-26T16:49:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5LAPvM",
                                           "createdAt":  "2022-09-26T17:08:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "andreminelli",
                                           "body":  "@cshung , I sure can try, but I had never contributed to this repo before.\r\n\r\nDo you have some hints you can give me to try speed things up? \r\nFor instance, is there an \"specially representative\" error on CI I should focus my attention first?\r\n",
                                           "updatedAt":  "2022-09-26T17:08:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5LApUX",
                                           "createdAt":  "2022-09-26T18:46:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "cshung",
                                           "body":  "\u003e @cshung , I sure can try, but I had never contributed to this repo before.\r\n\u003e \r\n\u003e Do you have some hints you can give me to try speed things up? For instance, is there an \"specially representative\" error on CI I should focus my attention first?\r\n\r\nIt\u0027s great that you are interested.\r\n\r\nOur first challenge is that this PR is fairly old, so I would suggest the step one is to resurrect the code first.\r\n\r\nFortunately, while the PR branch is deleted, I still have a copy pushed on my private branch [here](https://github.com/cshung/runtime/tree/private/optimize-thread-local-allocation), I left a note for myself that it has some conflicts with another change [here](https://github.com/dotnet/runtime/pull/56956). The only commit that matter is https://github.com/cshung/runtime/commit/9f9cfd85fe68f66abf899ed2098d6ba48f0bd798, the scripts and notes are irrelevant. \r\n\r\nOnce we have the conflict merged so that the code is targetting the latest main, we can just make a PR (maybe draft?) so that we can run the CI to figure out what was failing.\r\n\r\nWe would also like to resurrect the idea of what I was trying to achieve. Fortunately, the PR\u0027s description show gives a rough idea about that.\r\n\r\nI vaguely recall the CI failure has something to do with `Task\u003cT\u003e`. The conservation history of the PR seems to have something related to the test failure, we may want to experiment along those lines.\r\n\r\nThis PR was quite some time ago and I have forgotten some details, sorry about that.\r\n\r\nI guess you may need these, for typical workflow, you can take a look at our documentation.\r\n\r\nThe build instruction should be clear about how to [install the prerequisites](https://github.com/dotnet/runtime/blob/main/docs/workflow/requirements/windows-requirements.md), [build the product](https://github.com/dotnet/runtime/tree/main/docs/workflow/building/coreclr) and [run the tests](https://github.com/dotnet/runtime/blob/main/docs/workflow/testing/coreclr/windows-test-instructions.md). \r\n\r\nLet me know if you need anything else, happy to help!",
                                           "updatedAt":  "2022-09-26T18:46:05Z"
                                       }
                                   ],
                         "totalCount":  18
                     },
        "title":  "Very high latency for GC when using (lots of) ThreadLocal",
        "labels":  [
                       "area-System.Threading",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/31911",
        "createdAt":  "2020-02-07T03:51:50Z",
        "number":  31911,
        "author":  "scalablecory",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC9u1wQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "samsosa",
                                            "createdAt":  "2020-02-07T16:22:09Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jageall",
                                            "createdAt":  "2020-02-20T09:05:44Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "nsentinel",
                                            "createdAt":  "2020-04-05T20:45:32Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pentp",
                                            "createdAt":  "2020-04-24T19:40:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "viktor-svub",
                                            "createdAt":  "2021-01-21T12:02:49Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Sergio0694",
                                            "createdAt":  "2021-02-01T21:26:05Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "reflectronic",
                                            "createdAt":  "2021-02-01T21:26:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "omariom",
                                            "createdAt":  "2021-04-30T11:42:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sunkin351",
                                            "createdAt":  "2021-07-19T05:15:20Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "timcassell",
                                            "createdAt":  "2022-01-24T23:15:31Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "grbell-ms",
                                            "createdAt":  "2022-02-03T00:44:37Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "GSPP",
                                            "createdAt":  "2022-10-09T20:31:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MihaZupan",
                                            "createdAt":  "2022-12-04T01:10:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hexawyz",
                                            "createdAt":  "2023-03-16T12:29:55Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-04-19T00:19:45Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "neon-sunset",
                                            "createdAt":  "2024-12-26T17:48:28Z"
                                        }
                                    ],
                          "totalCount":  16
                      },
        "updatedAt":  "2021-07-19T05:23:05Z",
        "body":  "A CAS that operates atomically on two pointers at once is useful for writing lock-free algorithms.\r\n\r\nThis would be an intrinsic for `CMPXCHG8B`, `CMPXCHG16B`, `CASPAL` instructions\r\n\r\nSomething like:\r\n\r\n```c#\r\nstruct AtomicPair\u003cTFirst, TSecond\u003e where TFirst:class, TSecond:class\r\n{\r\n    public TFirst First;\r\n    public TSecond Second;\r\n}\r\n\r\nstruct AtomicPair\u003cT\u003e where T:class\r\n{\r\n    public T First;\r\n    public nint Second;\r\n}\r\n\r\nstruct AtomicPair\r\n{\r\n    public nint First;\r\n    public nint Second;\r\n}\r\n\r\nclass Interlocked\r\n{\r\n    // upon return, comparand is updated to the value that was in location1.\r\n    public static bool CompareExchange(ref AtomicPair location1, AtomicPair value, ref AtomicPair comparand);\r\n    public static bool CompareExchange\u003cT\u003e(ref AtomicPair\u003cT\u003e location1, AtomicPair\u003cT\u003e value, ref AtomicPair\u003cT\u003e comparand);\r\n    public static bool CompareExchange\u003cTFirst, TSecond\u003e(ref AtomicPair\u003cTFirst, TSecond\u003e location1, AtomicPair\u003cTFirst, TSecond\u003e value, ref AtomicPair\u003cTFirst, TSecond\u003e comparand);\r\n}\r\n```\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHONJYIzA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4MzM2ODU3Ng==",
                                           "createdAt":  "2020-02-07T12:24:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Our `ConcurrentStack\u003cT\u003e` is unable to reuse its nodes today due to typical ABA issues. That would be a good test bed to validate this API, with `CS\u003cT\u003e` maintaining a free list and using tagged pointers/references.",
                                           "updatedAt":  "2020-02-07T12:24:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5MzgxMzM1NA==",
                                           "createdAt":  "2020-03-03T07:47:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "scalablecory",
                                           "body":  "\u003e Our `ConcurrentStack\u003cT\u003e` is unable to reuse its nodes today due to typical ABA issues. That would be a good test bed to validate this API, with `CS\u003cT\u003e` maintaining a free list and using tagged pointers/references.\r\n\r\nUnfortunately I don\u0027t know that `ConcurrentStack` could be updated to do this (at least, not without extra overhead) as `GetEnumerator` and `Count` depend on nodes not being recycled.",
                                           "updatedAt":  "2020-03-03T07:47:04Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5MzkyMDk4NA==",
                                           "createdAt":  "2020-03-03T12:15:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEBJXrQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "viktor-svub",
                                                                               "createdAt":  "2021-06-14T07:01:47Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "GSPP",
                                                                               "createdAt":  "2022-10-09T21:24:44Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hexawyz",
                                                                               "createdAt":  "2023-03-17T20:47:10Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pentp",
                                                                               "createdAt":  "2025-01-06T09:25:00Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e at least, not without extra overhead\r\n\r\nWe have a similar issue in ConcurrentQueue (whether to clear a dequeued element and allow its slot to be reused), and the extra meaningful overhead there is incurred only as part of the operations doing the iterating, e.g. GetEnumerator and Count, by setting a flag while such an operation is in progress and only performing the problematic operation if one isn\u0027t. They should be rare compared to push and pop.\r\n\r\nA concurrent stack is the poster child for a primitive like this. It\u0027d be a shame if ours couldn\u0027t use it.",
                                           "updatedAt":  "2020-03-03T12:15:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc40lgjM",
                                           "createdAt":  "2021-07-19T05:23:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODe9Uvg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "timcassell",
                                                                               "createdAt":  "2024-04-21T08:05:41Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "sunkin351",
                                           "body":  "Can we overload `Interlocked.Exchange()` in a similar fashion?",
                                           "updatedAt":  "2021-07-19T05:23:05Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Add DCAS overload of Interlocked.CompareExchange",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/33773",
        "createdAt":  "2020-03-19T16:42:34Z",
        "number":  33773,
        "author":  "terrajobst",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODCPBzQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "JC3",
                                            "createdAt":  "2021-05-22T23:00:17Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "NN---",
                                            "createdAt":  "2021-08-27T15:33:44Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "svick",
                                            "createdAt":  "2022-06-05T10:50:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "theodorzoulias",
                                            "createdAt":  "2022-06-10T11:30:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2024-05-10T19:09:42Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-08-14T22:32:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "carlreinke",
                                            "createdAt":  "2025-03-11T22:04:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "LeaFrock",
                                            "createdAt":  "2025-04-16T02:50:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "littletoxic",
                                            "createdAt":  "2025-05-10T07:48:37Z"
                                        }
                                    ],
                          "totalCount":  9
                      },
        "updatedAt":  "2025-03-11T22:09:52Z",
        "body":  "`SpinLock` is a mutable struct, meant only for advanced scenarios.  Accidentally making a `SpinLock` field `readonly` can result in silent but significant problems,  as any mutations to the instance (e.g. Enter, Exit) will be done on a compiler-generated copy and thus be ignored, making the lock an expensive nop. (It might make sense to extend this analyzer to additional mutable struct types where storing them in a `readonly` field is likely a bug, e.g. `GCHandle`.)\n\n**Category**: Reliability",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOoeALSw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYwMTc4MTY5MA==",
                                           "createdAt":  "2020-03-20T16:10:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Closely related / duplicative: https://github.com/dotnet/roslyn-analyzers/issues/2811",
                                           "updatedAt":  "2020-03-20T16:10:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYwMTk2NTE3NA==",
                                           "createdAt":  "2020-03-21T00:30:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "Estimates:\r\n* Analyzer: Small\r\n* Fixer: Small",
                                           "updatedAt":  "2020-03-21T00:30:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYwMjc1Mjg3OQ==",
                                           "createdAt":  "2020-03-23T17:42:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "terrajobst",
                                           "body":  "Seems related to #33772",
                                           "updatedAt":  "2020-03-23T17:42:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczNjA5MzA5Mg==",
                                           "createdAt":  "2020-11-30T22:25:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "This analyzer has a long discussion here already: https://github.com/dotnet/roslyn-analyzers/issues/2811 which @mavasani already approved.\r\nThere\u0027s even an PR out trying to get it fixed: https://github.com/dotnet/roslyn-analyzers/pull/2831\r\n\r\nDo we want this issue to go through the dotnet/runtime API review process anyway?",
                                           "updatedAt":  "2020-11-30T22:25:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg0NTU1NzY5OA==",
                                           "createdAt":  "2021-05-20T23:58:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBr2V-Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "JC3",
                                                                               "createdAt":  "2021-05-22T23:04:44Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "sharwell",
                                           "body":  "@carlossanlop I think a review would be good. The proposed rule only indirectly addresses the underlying problem, and we have a large number of related cases in #50389.",
                                           "updatedAt":  "2021-05-20T23:58:14Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg0NjUwODAyMQ==",
                                           "createdAt":  "2021-05-23T05:48:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBtg6Ag==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "GSPP",
                                                                               "createdAt":  "2021-06-05T06:07:31Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "JC3",
                                           "body":  "Along those lines, storing `SpinLock` and other such values in `Nullable`, e.g.:\r\n\r\n    SpinLock? example;\r\n\r\nThat\u0027d be covered implicitly with non-read-only constraints, but should probably have a modified error description so that a warning / failure message makes reasonable sense.",
                                           "updatedAt":  "2021-05-23T05:48:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6h4AtL",
                                           "createdAt":  "2025-03-11T22:09:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlreinke",
                                           "body":  "I just got bit by making a `readonly ManualResetValueTaskSourceCore\u003cTResult\u003e` field.\n\nCan this be marked as ready-for-review?",
                                           "updatedAt":  "2025-03-11T22:09:51Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "Do not hold SpinLock in fields marked as readonly",
        "labels":  [
                       "api-needs-work",
                       "area-System.Threading",
                       "code-analyzer",
                       "code-fixer"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/33832",
        "createdAt":  "2020-03-19T23:03:16Z",
        "number":  33832,
        "author":  "AArnott",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOA-5Ddg==",
                          "nodes":  [
                                        {
                                            "content":  "EYES",
                                            "user":  "paulomorgado",
                                            "createdAt":  "2020-03-23T19:19:14Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-10-11T00:38:53Z",
        "body":  "When an IAsyncEnumerable\u003cT\u003e iterator method is invoked from a threadpool thread, and internally the iterator method switches to some SynchronizationContext (e.g. the main thread in an application) and calls \"yield return\" from it, the MoveNextAsync caller is (sometimes!) resumed on the main thread instead of the threadpool where they started.\r\n\r\nThis enumerating method (the one that calls the async iterator method) has nothing but ordinary-looking awaits in it. Per behavior seen from awaiting `Task` or *typical* `ValueTask`, I expect this method to *remain* on the threadpool where it started the await. Instead, on the *second* iteration of the loop, the method unexpectedly resumes *on the main thread* instead of the threadpool.\r\nNo idea why it didn\u0027t happen on the first iteration. But IMO it shouldn\u0027t happen at all. Its context shouldn\u0027t be altered by the implementation detail of the async iterator method switching to the main thread.\r\n\r\nAs @stephentoub described it:\r\n\r\n\u003e There’s a corner-case check when awaiting a Task that says effectively “if `await t;` was performed when there wasn’t any custom SynchronizationContext / TaskScheduler but upon t’s completion there is a custom SynchronizationContext / TaskScheduler, be conservative and assume this is a bad place to invoke the continuation”.  That same check does not currently exist in the implementation underneath async iterators, which don’t return Tasks, but rather ValueTasks, which wrap arbitrary IValueTaskSource implementations that can do whatever they want but should generally try to behave like Tasks.  I need to look into how breaking it would be to “fix” that, both in terms of functionality and perf. Even if we change it though, I suspect it would only be for .NET 5.\r\n\r\n## Repro\r\n\r\nCompile the following netcoreapp3.1 console application with the following reference:\r\n```xml\r\n    \u003cPackageReference Include=\"Microsoft.VisualStudio.Threading\" Version=\"16.5.132\" /\u003e\r\n```\r\n\r\nAnd this source code:\r\n\r\n```cs\r\nusing Microsoft.VisualStudio.Threading;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\n\r\nclass Program\r\n{\r\n    static JoinableTaskFactory jtf;\r\n\r\n    static void Main(string[] args)\r\n    {\r\n        var syncContext = new SingleThreadedSynchronizationContext();\r\n        var frame = new SingleThreadedSynchronizationContext.Frame();\r\n        syncContext.Post(async s =\u003e\r\n        {\r\n            Thread.CurrentThread.Name = \"Main thread\";\r\n            Console.WriteLine(\"The main thread is: \" + Environment.CurrentManagedThreadId);\r\n            var jtc = new JoinableTaskContext();\r\n            jtf = jtc.Factory;\r\n            try\r\n            {\r\n                await MainThread();\r\n            }\r\n            finally\r\n            {\r\n                frame.Continue = false;\r\n            }\r\n        }, null);\r\n        syncContext.PushFrame(frame);\r\n    }\r\n\r\n    private static async Task MainThread()\r\n    {\r\n        var mainSyncContext = SynchronizationContext.Current;\r\n        await TaskScheduler.Default;\r\n        Console.WriteLine(\"Switched to threadpool before entering await foreach loop. Now on: \" + Environment.CurrentManagedThreadId);\r\n        await foreach (int item in GetItemsAsync())\r\n        {\r\n            // We do NOT expect to be on the main thread within this loop since we never switched back to it.\r\n            // But the AsyncEnumerable method we\u0027re looping over DID need the main thread so it switched to it.\r\n            // And that \u0027leaks\u0027 out to the enumerating foreach here! (gah!)\r\n            Console.WriteLine(\"foreach loop iteration now on thread: \" + Environment.CurrentManagedThreadId);\r\n        }\r\n    }\r\n\r\n    private static async IAsyncEnumerable\u003cint\u003e GetItemsAsync()\r\n    {\r\n        await jtf.SwitchToMainThreadAsync();\r\n        Console.WriteLine(\"Iterator method switched to main thread: \" + Environment.CurrentManagedThreadId);\r\n        yield return 0;\r\n        await jtf.SwitchToMainThreadAsync();\r\n        yield return 1;\r\n    }\r\n}\r\n```\r\n\r\n### Generated output:\r\n\r\n```\r\nThe main thread is: 1\r\nSwitched to threadpool before entering await foreach loop. Now on: 4\r\nIterator method switched to main thread: 1\r\nforeach loop iteration now on thread: 5\r\nforeach loop iteration now on thread: 1\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOj21cLg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6PbVwu",
                                           "createdAt":  "2024-10-11T00:38:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEQ3_lQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "D3-LucaPiombino",
                                                                               "createdAt":  "2024-10-11T18:26:41Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "fedeAlterio",
                                                                               "createdAt":  "2025-05-05T22:14:08Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "AArnott",
                                           "body":  "This still repros on .NET 8. And I still feel like it\u0027s very unexpected that `await foreach` would switch the context of the caller. IMO this should be fixed.",
                                           "updatedAt":  "2024-10-11T00:38:40Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "\"await IAsyncEnumerator.MoveNextAsync\" should not change thread context of caller",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/34800",
        "createdAt":  "2020-04-10T02:24:51Z",
        "number":  34800,
        "author":  "benaadams",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODFbw0g==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lindexi",
                                            "createdAt":  "2025-07-02T11:58:53Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2022-09-08T02:42:56Z",
        "body":  "There is a high misprediction rate for the common path in JIT_MonExit_Portable\r\n\r\n![image](https://user-images.githubusercontent.com/1142958/78956120-3a21b180-7ad9-11ea-9dea-b10ecc10934a.png)\r\n\r\nWith the common path `action == AwareLock::LeaveHelperAction_None` not being arranged as the common path in asm.\r\n\r\nhttps://github.com/dotnet/runtime/blob/8640eed087d0155fbd76c2ded706b2599e06410a/src/coreclr/src/vm/jithelpers.cpp#L3932-L3936\r\n\r\n![image](https://user-images.githubusercontent.com/1142958/78949849-ce354e00-7ac4-11ea-9597-0a724cd3885a.png)\r\n\r\nI\u0027ve tried rearranging this in the C++; however it seems quite resistant to ordering change; perhaps PGO is incorrectly enforcing the order here?\r\n\r\nAside: I assume it needs to be a `cmpxchg` rather than just a volatile write because it may have changed from a lock to a lock+hashcode or perhaps signaling? Would there be any scope to having a lock object type that doesn\u0027t allow a hashcode or signaling, so it could just be a volatile write to unlock a non-recursive non-signaled lock? (as `JIT_MonExit_Portable` is quite expensive in the code I\u0027m looking at as 3rd highest cost method)",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOSeq-PQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYxMTg5NTg0Mg==",
                                           "createdAt":  "2020-04-10T06:15:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Would there be any scope to having a lock object type that doesn\u0027t allow a hashcode or signaling\r\n\r\nDo you mean having a first class lock type (e.g. `System.Threading.Lock`) that is a simple lock without the syncblock baggage? I think that would be useful.",
                                           "updatedAt":  "2020-04-10T06:15:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYxMTk2NjY1NA==",
                                           "createdAt":  "2020-04-10T09:58:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "\u003e Do you mean having a first class lock type (e.g. `System.Threading.Lock`) that is a simple lock without the syncblock baggage?\r\n\r\nExactly. Have raised issue https://github.com/dotnet/runtime/issues/34812",
                                           "updatedAt":  "2020-04-10T09:58:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5J6r49",
                                           "createdAt":  "2022-09-08T01:45:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "The first image seems to indicate that the bad speculation is mostly caused by machine clears and not branch misprediction. I\u0027m not sure what exactly would be causing those, perhaps just the `cmpxchg` or false sharing with other data? In .NET 6 too I don\u0027t see the ideal code ordering. Was this happening on a benchmark?\r\n\r\n\u003e Aside: I assume it needs to be a cmpxchg rather than just a volatile write because it may have changed from a lock to a lock+hashcode or perhaps signaling? Would there be any scope to having a lock object type that doesn\u0027t allow a hashcode or signaling, so it could just be a volatile write to unlock a non-recursive non-signaled lock?\r\n\r\nThe fast paths for exiting `AwareLock` and `LowLevelLock` also currently use CAS to determine if a waiter needs to be signaled. It may be possible to use a volatile write with another full memory barrier instead.",
                                           "updatedAt":  "2022-09-08T02:42:56Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Bad speculation in JIT_MonExit_Portable",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/35962",
        "createdAt":  "2020-05-07T13:19:20Z",
        "number":  35962,
        "author":  "john-h-k",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODEUCiA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "GSPP",
                                            "createdAt":  "2021-08-03T05:29:57Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "magol",
                                            "createdAt":  "2021-09-03T11:17:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "IGx89",
                                            "createdAt":  "2021-10-11T19:15:45Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ESipalis",
                                            "createdAt":  "2022-03-12T10:06:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Germs2004",
                                            "createdAt":  "2022-04-29T03:11:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "darkguy2008",
                                            "createdAt":  "2022-06-26T06:39:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "saul",
                                            "createdAt":  "2022-07-14T14:02:04Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rick-palmsens",
                                            "createdAt":  "2022-09-06T14:02:49Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "rick-palmsens",
                                            "createdAt":  "2022-09-06T14:03:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SteveDunn",
                                            "createdAt":  "2022-09-28T06:36:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "giggio",
                                            "createdAt":  "2022-11-03T00:50:37Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DevSelchow",
                                            "createdAt":  "2022-11-03T08:44:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lucasteles",
                                            "createdAt":  "2022-12-01T02:39:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dFarkhod",
                                            "createdAt":  "2022-12-09T03:44:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "JSkimming",
                                            "createdAt":  "2023-01-12T13:12:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "akirayamamoto",
                                            "createdAt":  "2023-02-13T01:22:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "shonk-msft",
                                            "createdAt":  "2023-02-15T23:14:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jez9999",
                                            "createdAt":  "2023-02-25T21:14:36Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "N0D4N",
                                            "createdAt":  "2023-02-28T08:59:52Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aaron-ai",
                                            "createdAt":  "2023-03-06T02:58:25Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "YZahringer",
                                            "createdAt":  "2023-09-19T13:11:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ceztko",
                                            "createdAt":  "2023-10-06T09:16:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Sibusten",
                                            "createdAt":  "2023-11-08T21:56:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "fhelwanger",
                                            "createdAt":  "2023-12-14T13:10:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "exyi",
                                            "createdAt":  "2024-04-23T08:44:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "perlun",
                                            "createdAt":  "2024-06-25T10:49:44Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "piju3",
                                            "createdAt":  "2024-09-11T20:52:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ChadNedzlek",
                                            "createdAt":  "2025-02-23T21:41:20Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "h3xds1nz",
                                            "createdAt":  "2025-05-10T19:59:49Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jbhelm",
                                            "createdAt":  "2025-06-19T18:59:15Z"
                                        }
                                    ],
                          "totalCount":  30
                      },
        "updatedAt":  "2024-09-06T19:56:51Z",
        "body":  "We have `SemaphoreSlim`, with `WaitAsync`, but it is inherently different because it has counting semantics. Some form of MRE or MRESlim with a `WaitOneAsync()` would be useful. Searched for an issue but couldn\u0027t see one directly about this",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOiykN3A==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNTI1MDcxMg==",
                                           "createdAt":  "2020-05-07T13:19:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Dotnet-GitSync-Bot",
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. Please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2020-05-07T13:19:22Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY2MjM1MDI2NA==",
                                           "createdAt":  "2020-07-22T09:33:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "adams85",
                                           "body":  "@john-h-k FYI, plain `WaitHandle`s (including `ManualResetEvent`) can be wrapped with an awaitable `Task` by means of `ThreadPool.RegisterWaitForSingleObject` as it\u0027s shown by Stephen Cleary in his excellent [AsyncEx library](https://github.com/StephenCleary/AsyncEx/blob/v5.0.0/src/Nito.AsyncEx.Interop.WaitHandles/Interop/WaitHandleAsyncFactory.cs). For the moment, I follow this approach when I need an awaitable `AutoResetEvent`/`ManualResetEvent`, however, I\u0027m not sure it can be considered as a best practice. @jkotas Could you (or someone on your team) give us some pointers regarding this? Would an async-enabled MRE be a better choice?\r\n\r\nAs a side note, as for AREs I\u0027m aware of another workaround: although it has different semantics, [using a binary `SemaphoreSlim` we can simulate an awaitable ARE](https://stackoverflow.com/questions/8215380/why-no-autoreseteventslim-in-bcl/25823389#answer-25823389). This approach has a shortcoming though: when this simulated ARE is \"set\" via `SemaphoreSlim.Release`, it may throw a `SemaphoreFullException` if its counter has already reached the maximum, and these unwanted exceptions may hurt performance. Of course, the semaphore\u0027s counter could be checked before `Release` but not even this can completely eliminate the unwanted exceptions in heavily multi-threaded situations because check+release cannot be done atomically. However, a non-throwing `TryRelease` method would solve this problem and at least we\u0027d have a viable solution for async AREs. @jkotas What are your thoughts on this? Would this idea of `SemaphoreSlim.TryRelease` be worth an API proposal by chance?\r\n",
                                           "updatedAt":  "2020-07-22T10:05:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY2MjgzMDQxNg==",
                                           "createdAt":  "2020-07-23T05:50:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e I follow approach when I need an awaitable AutoResetEvent/ManualResetEvent, however, I\u0027m not sure it can be considered as a best practice.\r\n\r\nIt works if you really need the full power of AutoResetEvent/ManualResetEvent for your scenario.\r\n\r\nIf you just need to signal that a work got finished via a Task, `TaskCompletionSource` is the most lightweight way to do that. Note that #17393 added a non-generic version of `TaskCompletionSource` for .NET 5 so it won\u0027t be necessary to use a dummy generic result argument anymore.\r\n\r\n\u003e Would this idea of `SemaphoreSlim.TryRelease` be worth an API proposal\r\n\r\nThis does not look like a great API to me.",
                                           "updatedAt":  "2020-07-23T05:50:51Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY2Mjk0MTY1Mg==",
                                           "createdAt":  "2020-07-23T10:54:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "adams85",
                                           "body":  "@jkotas Alright, thanks for the info.",
                                           "updatedAt":  "2020-07-23T10:54:14Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5OTQ5MDcwMQ==",
                                           "createdAt":  "2020-09-26T12:42:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tactical-drone",
                                           "body":  "@john-h-k , @adams85 , @jkotas @stephentoub \r\n\r\nI have been trying to find a .net framework *ZERO* GC pressure semaphore that plays nice with `async/await`, but could not find one.\r\n\r\nThe best option right now is `asyncautoresetevent`, but that uses `TaskCompletionSource`. There is no support for a `IValueTaskSource` mutex/semaphore in the framework that I can find.\r\n\r\nTherefor, I have been trying to build my own. My first attempt was based on trying to use the supplied `ManualResetValueTaskSourceCore`. But that leads to dark places.\r\n\r\nMy second iteration is a \"native\" semaphore instead. It depends on Spinlock. It is hot of the press and not fully tested. In fact I don\u0027t know how to test it. And I still need to add `ExecutionContext` logic to it. You could probably get rid of the dependence on `Spinlock` by using `Interlocked.CompareExchange` instead. I required `Spinlock` to implement auto scaling. So far it seems to be working well. \r\n\r\nBut it would be cool if seasoned .net veterans can look at this and tell me if it is a bad idea or not. Maybe help test. Maybe use it as an Idea for your next superior synchronization primitives. \r\n\r\nHere is the source: https://gitlab.com/unimatrix-one/zero/-/blob/net5/zero.core/patterns/semaphore/core/IoZeroSemaphore.cs",
                                           "updatedAt":  "2020-09-30T00:01:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg3NDU2NTk0MQ==",
                                           "createdAt":  "2021-07-06T08:26:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kiminuo",
                                           "body":  "Will this make .NET 6?",
                                           "updatedAt":  "2021-07-06T08:26:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg3NDkwMTI0Mw==",
                                           "createdAt":  "2021-07-06T16:20:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Will this make .NET 6?\r\n\r\nUnlikely.  For starters, it needs a concrete API proposal.",
                                           "updatedAt":  "2021-07-06T16:20:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg3NTAwODMzOQ==",
                                           "createdAt":  "2021-07-06T19:01:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tactical-drone",
                                           "body":  "@stephentoub I was wondering if you had a look at the code? Does it make sense?",
                                           "updatedAt":  "2021-07-06T19:01:20Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg3NTAxMjU3Ng==",
                                           "createdAt":  "2021-07-06T19:07:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kiminuo",
                                           "body":  "\u003e \u003e Will this make .NET 6?\r\n\u003e \r\n\u003e Unlikely. For starters, it needs a concrete API proposal.\r\n\r\n😢 ",
                                           "updatedAt":  "2021-07-06T19:07:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5WJCKs",
                                           "createdAt":  "2023-02-25T21:19:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jez9999",
                                           "body":  "I\u0027m a bit surprised at the lack of a `WaitAsync` in `ManualResetEventSlim`, too.  Does anyone know whether just using `Wait` would have significant performance penalties in comparison?\r\n\r\nI\u0027m almost tempted to hack a `SemaphoreSlim` to act like a MRE by setting it to 0 and then releasing a very large number to mimic the \"set\" of a MRE (obviously assuming the number of threads waiting on the `SemaphoreSlim` is less than the very large number).",
                                           "updatedAt":  "2023-02-25T21:19:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5WJCrw",
                                           "createdAt":  "2023-02-25T21:33:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "What\u0027s your use case? Why not just use a TaskCompletionSource? You need reset in a way that can\u0027t be accomplished by just replacing the instance? ",
                                           "updatedAt":  "2023-02-25T21:33:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5WJC6S",
                                           "createdAt":  "2023-02-25T21:39:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jez9999",
                                           "body":  "Sorry, what do you mean replacing the instance?",
                                           "updatedAt":  "2023-02-25T21:39:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5WJESL",
                                           "createdAt":  "2023-02-25T22:19:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "_if_ you need to reset back from set to unset, creating a new TaskCompletionSource and swapping it back in. ",
                                           "updatedAt":  "2023-02-25T22:19:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5WJEgI",
                                           "createdAt":  "2023-02-25T22:26:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jez9999",
                                           "body":  "I guess that would work.  Is that a complete replacement for ManualResetEventSlim then?  Or are these some things the latter can do that a TCS can\u0027t?",
                                           "updatedAt":  "2023-02-25T22:26:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5WJFos",
                                           "createdAt":  "2023-02-25T23:00:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Is there something about it that doesn\u0027t work for you? ",
                                           "updatedAt":  "2023-02-25T23:00:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5WJHCu",
                                           "createdAt":  "2023-02-25T23:47:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jez9999",
                                           "body":  "I suppose where it\u0027s different is if some code holds a reference to the old TCS.  The old TCS gets set, then replaced with a new one, but the code is still referencing the old one, and so if it awaits again it won\u0027t block.  If it had been a MRE, resetting it would cause the code to block again even if it held onto the reference.  In other words, for the \"replace the instance\" to work, the code has to always actively get the TCS instance from the right place when it waits for the signal.",
                                           "updatedAt":  "2023-02-25T23:47:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5WOwsG",
                                           "createdAt":  "2023-02-27T17:07:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jez9999",
                                           "body":  "@stephentoub Also, what if one needs to block on a MRE in both sync and async code?  With `SemaphoreSlim` there\u0027s `Wait` and `WaitAsync` but awaiting a TCS is going to require an async context, isn\u0027t it?  How could you use that like an MRE that could block both sync code and async code (with an await)?",
                                           "updatedAt":  "2023-02-27T17:07:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5WOyL0",
                                           "createdAt":  "2023-02-27T17:11:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e In other words, for the \"replace the instance\" to work, the code has to always actively get the TCS instance from the right place when it waits for the signal.\r\n\r\nYes. But it cuts both ways. It\u0027s not uncommon for code to expect such transitions are one-way only, i.e. that you never reset, and `TaskCompletionSource` allows someone to depend on that: they know that once they\u0027ve observed it set, they can observe it any number of additional times and it\u0027ll never show as unset.  It really comes down to your scenario what you need, but in general if you support resets you need to be really careful about race conditions that can result from a thread missing a signal.\r\n\r\nMy question, though, wasn\u0027t about the general case; it was about your specific needs. Is there something about this that doesn\u0027t work for _you_?\r\n\r\n\u003e but awaiting a TCS is going to require an async context, isn\u0027t it?\r\n\r\n`tcs.Task.Wait();`",
                                           "updatedAt":  "2023-02-27T17:11:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5WO4YG",
                                           "createdAt":  "2023-02-27T17:26:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jez9999",
                                           "body":  "I guess that would work then.  So how come `ManualResetEventSlim` can\u0027t just do that internally to allow sync and async wait?  :smile: ",
                                           "updatedAt":  "2023-02-27T17:26:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5WO43R",
                                           "createdAt":  "2023-02-27T17:27:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "It _could_... it would make every `ManualResetEventSlim` heavier weight and every operation performed on it more expensive.",
                                           "updatedAt":  "2023-02-27T17:27:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5WPAhZ",
                                           "createdAt":  "2023-02-27T17:49:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jez9999",
                                           "body":  "I say it\u0027s worth it, especially considering it\u0027d give parity with `SemaphoreSlim`.",
                                           "updatedAt":  "2023-02-27T17:49:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5WPT2k",
                                           "createdAt":  "2023-02-27T18:35:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jez9999",
                                           "body":  "@stephentoub I\u0027m trying to create a generalized manual reset event class that allows for both sync and async waiting; does this look right to you?\r\n\r\n```\r\nusing System.Threading.Tasks;\r\n\r\nnamespace UtilsCommon.Lib;\r\n\r\npublic sealed class ManualResetEventAsyncable {\r\n\tprivate TaskCompletionSource _tcs;\r\n\r\n\t/// \u003csummary\u003e\r\n\t/// Initializes a new instance of the ManualResetEventAsyncable class with an initial state of nonsignaled.\r\n\t/// \u003c/summary\u003e\r\n\tpublic ManualResetEventAsyncable() : this(false) { }\r\n\r\n\t/// \u003csummary\u003e\r\n\t/// Initializes a new instance of the ManualResetEventAsyncable class with a Boolean value indicating whether\r\n\t/// to set the initial state to signaled.\r\n\t/// \u003c/summary\u003e\r\n\t/// \u003cparam name=\"initialState\"\u003e\r\n\t/// If true, indicates that the initial state will be set to signaled.\r\n\t/// If false, indicates that the initial state will be set to nonsignaled.\r\n\t/// \u003c/param\u003e\r\n\tpublic ManualResetEventAsyncable(bool initialState) {\r\n\t\t_tcs = new TaskCompletionSource();\r\n\t\tif (initialState) {\r\n\t\t\t_tcs.SetResult();\r\n\t\t}\r\n\t}\r\n\r\n\t/// \u003csummary\u003e\r\n\t/// Gets whether the event is set.\r\n\t/// \u003c/summary\u003e\r\n\tpublic bool IsSet =\u003e _tcs.Task.Status == TaskStatus.RanToCompletion;\r\n\r\n\t/// \u003csummary\u003e\r\n\t/// Sets the state of the event to nonsignaled, which causes threads to block.\r\n\t/// \u003c/summary\u003e\r\n\tpublic void Reset() {\r\n\t\tif (IsSet) {\r\n\t\t\t_tcs = new TaskCompletionSource();\r\n\t\t}\r\n\t}\r\n\r\n\t/// \u003csummary\u003e\r\n\t/// Sets the state of the event to signaled, which allows one or more threads waiting on the event to proceed.\r\n\t/// \u003c/summary\u003e\r\n\tpublic void Set() {\r\n\t\t_tcs.TrySetResult();\r\n\t}\r\n\r\n\t/// \u003csummary\u003e\r\n\t/// Blocks the current thread until the current ManualResetEventAsyncable is set.\r\n\t/// \u003c/summary\u003e\r\n\tpublic void WaitSync() {\r\n\t\t_tcs.Task.Wait();\r\n\t}\r\n\r\n\t/// \u003csummary\u003e\r\n\t/// Asynchronously waits for the current ManualResetEventAsyncable to be set.\r\n\t/// \u003c/summary\u003e\r\n\t/// \u003creturns\u003eA task that will complete when the current ManualResetEventAsyncable has been set.\u003c/returns\u003e\r\n\tpublic Task WaitAsync() {\r\n\t\treturn _tcs.Task;\r\n\t}\r\n}\r\n```",
                                           "updatedAt":  "2023-02-27T18:35:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5WR1Ub",
                                           "createdAt":  "2023-02-28T03:24:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Looks reasonable.\r\n\r\nYou might also read https://devblogs.microsoft.com/pfxteam/building-async-coordination-primitives-part-1-asyncmanualresetevent/.\r\n\r\nAlso several nuget packages provide an async MRE, e.g. https://learn.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.threading.asyncmanualresetevent?view=visualstudiosdk-2022",
                                           "updatedAt":  "2023-02-28T03:25:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5WS7fJ",
                                           "createdAt":  "2023-02-28T08:57:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jez9999",
                                           "body":  "Heh, yeah I must confess I spotted your blog post a few hours after making my comment.  That link seems to be Visual Studio (or is it C++??) specific.  How come such classes are under Microsoft.VisualStudio when they\u0027re not VS-specific at all?",
                                           "updatedAt":  "2023-02-28T09:11:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5WUxeB",
                                           "createdAt":  "2023-02-28T14:31:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "It\u0027s not specific to Visual Studio.  It was just written by the team that works on Visual Studio and is used by Visual Studio.\r\n\r\nIt\u0027s also not specific to C++; that page is just defaulting to showing code samples in C++.  You can change the language for the samples in the language drop down on the upper right.",
                                           "updatedAt":  "2023-02-28T14:31:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5WU-8E",
                                           "createdAt":  "2023-02-28T15:02:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jez9999",
                                           "body":  "Ah, I see.  Fair enough.\r\n\r\nBy the way, did you ever implement a reader/writer lock with both sync and async lock methods?  I\u0027ve been creating something based on your [blog post](https://devblogs.microsoft.com/pfxteam/building-async-coordination-primitives-part-7-asyncreaderwriterlock/) which seems to work but only has async lock methods:\r\n\r\n```\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace UtilsCommon.Lib;\r\n\r\n/// \u003csummary\u003e\r\n/// Class that provides (optionally async-safe) read/write locking using internal task completion source.\r\n/// Bear in mind that all code executed inside the using statement must finish before the next thread is able to\r\n/// start executing it, so long-running code should be avoided inside the using statement if at all possible.\r\n///\r\n/// Example usage for async:\r\n/// using (mutex.[Read/Write]LockAsync()) {\r\n///     // ... code here which can use await calls and handle a shared resource one-thread-at-a-time ...\r\n///     return[ result];\r\n/// }\r\n/// \u003c/summary\u003e\r\npublic sealed class ReadWriteMutexAsyncable {\r\n\t#region Internal classes\r\n\r\n\tprivate sealed class Releaser : IDisposable {\r\n\t\tprivate readonly ReadWriteMutexAsyncable _toRelease;\r\n\t\tprivate readonly bool _isWriter;\r\n\t\tinternal Releaser(ReadWriteMutexAsyncable toRelease, bool isWriter) {\r\n\t\t\t_toRelease = toRelease;\r\n\t\t\t_isWriter = isWriter;\r\n\t\t}\r\n\t\tpublic void Dispose() {\r\n\t\t\tif (_isWriter) { _toRelease.writerRelease(); }\r\n\t\t\telse { _toRelease.readerRelease(); }\r\n\t\t}\r\n\t}\r\n\r\n\t#endregion\r\n\r\n\tprivate readonly Task\u003cIDisposable\u003e _readerReleaser;\r\n\tprivate readonly Task\u003cIDisposable\u003e _writerReleaser;\r\n\tprivate readonly Queue\u003cTaskCompletionSource\u003cReleaser\u003e\u003e _waitingWriters = new();\r\n\tprivate TaskCompletionSource\u003cReleaser\u003e _waitingReader = new();\r\n\tprivate int _readersWaiting;\r\n\tprivate int _status;\r\n\t// ^ If -1, locked for a writer.  If 0, no locks acquired.  If positive, indicates number of readers with lock.\r\n\r\n\t/// \u003csummary\u003e\r\n\t/// Creates a new ReadWriteMutexAsyncable instance.\r\n\t/// \u003c/summary\u003e\r\n\tpublic ReadWriteMutexAsyncable() {\r\n\t\t// Releaser instances that\u0027ll allow us to have the option of immediately returning completed tasks if\r\n\t\t// the lock was acquired immediately.\r\n\t\t_readerReleaser = Task.FromResult((IDisposable)new Releaser(this, false));\r\n\t\t_writerReleaser = Task.FromResult((IDisposable)new Releaser(this, true));\r\n\t}\r\n\r\n\tprivate void readerRelease() {\r\n\t\tTaskCompletionSource\u003cReleaser\u003e? toWake = null;\r\n\r\n\t\tlock (_waitingWriters) {\r\n\t\t\t_status--;\r\n\t\t\tif (_status == 0 \u0026\u0026 _waitingWriters.Count \u003e 0) {\r\n\t\t\t\t_status = -1;\r\n\t\t\t\ttoWake = _waitingWriters.Dequeue();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\ttoWake?.SetResult(new Releaser(this, true));\r\n\t}\r\n\r\n\tprivate void writerRelease() {\r\n\t\tTaskCompletionSource\u003cReleaser\u003e? toWake = null;\r\n\t\tbool toWakeIsWriter = false;\r\n\r\n\t\tlock (_waitingWriters) {\r\n\t\t\tif (_waitingWriters.Count \u003e 0) {\r\n\t\t\t\ttoWake = _waitingWriters.Dequeue();\r\n\t\t\t\ttoWakeIsWriter = true;\r\n\t\t\t}\r\n\t\t\telse if (_readersWaiting \u003e 0) {\r\n\t\t\t\ttoWake = _waitingReader;\r\n\t\t\t\t_status = _readersWaiting;\r\n\t\t\t\t_readersWaiting = 0;\r\n\t\t\t\t_waitingReader = new TaskCompletionSource\u003cReleaser\u003e();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t_status = 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\ttoWake?.SetResult(new Releaser(this, toWakeIsWriter));\r\n\t}\r\n\r\n\t/// \u003csummary\u003e\r\n\t/// Obtains a read lock asynchronously.\r\n\t/// \u003c/summary\u003e\r\n\t/// \u003creturns\u003eAn IDisposable that will release the obtained read lock upon being disposed.\u003c/returns\u003e\r\n\tpublic Task\u003cIDisposable\u003e ReadLockAsync() {\r\n\t\tlock (_waitingWriters) {\r\n\t\t\tif (_status \u003e= 0 \u0026\u0026 _waitingWriters.Count == 0) {\r\n\t\t\t\t_status++;\r\n\t\t\t\treturn _readerReleaser;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t_readersWaiting++;\r\n\t\t\t\treturn _waitingReader.Task.ContinueWith(t =\u003e (IDisposable)t.Result);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/// \u003csummary\u003e\r\n\t/// Obtains a write lock asynchronously.\r\n\t/// \u003c/summary\u003e\r\n\t/// \u003creturns\u003eAn IDisposable that will release the obtained write lock upon being disposed.\u003c/returns\u003e\r\n\tpublic Task\u003cIDisposable\u003e WriteLockAsync() {\r\n\t\tlock (_waitingWriters) {\r\n\t\t\tif (_status == 0) {\r\n\t\t\t\t_status = -1;\r\n\t\t\t\treturn _writerReleaser;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar waiter = new TaskCompletionSource\u003cReleaser\u003e();\r\n\t\t\t\t_waitingWriters.Enqueue(waiter);\r\n\t\t\t\treturn waiter.Task.ContinueWith(t =\u003e (IDisposable)t.Result);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\nI started writing sync versions of the lock methods but presumably the blocking on `Task.Wait()` within the `lock` is going to cause deadlock:\r\n\r\n```\r\n\tpublic IDisposable ReadLockSync() {\r\n\t\tlock (_waitingWriters) {\r\n\t\t\tif (_status \u003e= 0 \u0026\u0026 _waitingWriters.Count == 0) {\r\n\t\t\t\t_status++;\r\n\t\t\t\treturn _readerReleaser.Result;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t_readersWaiting++;\r\n\t\t\t\t_waitingReader.Task.Wait();\r\n\t\t\t\treturn _waitingReader.Task.Result;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic IDisposable WriteLockSync() {\r\n\t\tlock (_waitingWriters) {\r\n\t\t\tif (_status == 0) {\r\n\t\t\t\t_status = -1;\r\n\t\t\t\treturn _writerReleaser.Result;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar waiter = new TaskCompletionSource\u003cReleaser\u003e();\r\n\t\t\t\t_waitingWriters.Enqueue(waiter);\r\n\t\t\t\twaiter.Task.Wait();\r\n\t\t\t\treturn waiter.Task.Result;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n```\r\n\r\nHow would you implement the sync methods?",
                                           "updatedAt":  "2023-02-28T15:03:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ExNmn",
                                           "createdAt":  "2024-07-14T21:51:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "FWIW, I implemented all the synchronization primitives supporting both async and sync in my [promise library](https://github.com/timcassell/ProtoPromise/blob/023c3d5e83f595d508b4dc7b8346ef14cd0ba746/Docs/Guides/async-synchronization-primitives.md). Feel free to check the [source code](https://github.com/timcassell/ProtoPromise/tree/023c3d5e83f595d508b4dc7b8346ef14cd0ba746/Package/Core/Threading) and [tests](https://github.com/timcassell/ProtoPromise/tree/023c3d5e83f595d508b4dc7b8346ef14cd0ba746/Package/Tests/CoreTests/APIs/Threading) [(and concurrency tests)](https://github.com/timcassell/ProtoPromise/tree/023c3d5e83f595d508b4dc7b8346ef14cd0ba746/Package/Tests/CoreTests/Concurrency/Threading) if you\u0027re having troubling implementing your own.",
                                           "updatedAt":  "2024-07-14T21:56:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6LJttz",
                                           "createdAt":  "2024-09-06T18:09:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODxUR8Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "CONFUSED",
                                                                               "user":  "En3Tho",
                                                                               "createdAt":  "2024-09-06T18:43:42Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "lostmsu",
                                           "body":  "@jez9999 @stephentoub omg, how does it look reasonable? Don\u0027t give bad advise like that please. The code sample has no memory barriers and threads other than the one that called `Reset` may never see the new value of `_tcs`",
                                           "updatedAt":  "2024-09-06T18:11:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6LKQ3c",
                                           "createdAt":  "2024-09-06T19:56:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jez9999",
                                           "body":  "@lostmsu Yeah, I just use AsyncEx now.  Bit annoying that .NET doesn\u0027t have this stuff built in but that works well.",
                                           "updatedAt":  "2024-09-06T19:56:50Z"
                                       }
                                   ],
                         "totalCount":  29
                     },
        "title":  "Consider providing async methods to, or an async alternative to, ManualResetEvent/ManualResetEventSlim",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/37423",
        "createdAt":  "2020-06-04T16:23:18Z",
        "number":  37423,
        "author":  "john-h-k",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC9-ZMA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SupinePandora43",
                                            "createdAt":  "2023-08-14T17:05:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MichelZ",
                                            "createdAt":  "2024-05-05T05:59:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Xpl0itR",
                                            "createdAt":  "2024-06-22T09:46:20Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "TickThunder",
                                            "createdAt":  "2024-11-18T06:37:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "daniDevKr",
                                            "createdAt":  "2025-01-08T17:03:09Z"
                                        }
                                    ],
                          "totalCount":  5
                      },
        "updatedAt":  "2023-03-14T22:54:35Z",
        "body":  "## Background and Motivation\r\n\r\nFor native interop, it can be incredibly useful to have access to the underlying thread handle value. For example\r\n* Working with native fibres\r\n* Creating custom fibre libraries\r\n* Performing operations like setting thread affinity\r\n\r\n## Proposed API\r\n\r\n```diff\r\npublic class Thread\r\n{\r\n+    public IntPtr GetNativeHandle();\r\n+    public bool TryGetNativeHandle(out IntPtr handle);\r\n}\r\n```\r\n\r\n`GetNativeHandle` would throw an exception (not sure which one) if the `Thread` object wasn\u0027t a true thread (currently afaik they all are, but in the future they could be fibers etc), whereas `TryGetNativeHandle` would return false\r\n\r\n## Usage Examples\r\n\r\n```cs\r\nvar thread = ...;\r\n\r\n// lock the thread to the first logical processor\r\nWin32.SetThreadAffinityMask(thread.GetNativeHandle(), 1);\r\n```\r\n\r\n## Alternative Designs\r\n\r\nYou could, in this case, just expose `SetThreadAffinity` - but it doesn\u0027t make sense if a thread isn\u0027t always a \"real\" thread\r\n\r\n## Risks\r\n\r\nIt isn\u0027t a breaking change. If misused, I am sure the handle could do some messy things, but that applies to a lot of the framework 😄 ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHORlspJw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzODk2MjczNg==",
                                           "createdAt":  "2020-06-04T16:23:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Dotnet-GitSync-Bot",
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. Please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2020-06-04T16:23:22Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzODk2Mjk1OQ==",
                                           "createdAt":  "2020-06-04T16:23:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "john-h-k",
                                           "body":  "cc @tannergooding ",
                                           "updatedAt":  "2020-06-04T16:23:48Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzODk3NDcyOA==",
                                           "createdAt":  "2020-06-04T16:45:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "What is this API going to return on non-Windows?",
                                           "updatedAt":  "2020-06-04T16:45:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzODk3ODYxMg==",
                                           "createdAt":  "2020-06-04T16:53:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "john-h-k",
                                           "body":  "I would assume the `pthread_t*` on linux systems, and on other systems the type the runtime uses to create them with the OS",
                                           "updatedAt":  "2020-06-04T16:53:10Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzODk3ODk4OQ==",
                                           "createdAt":  "2020-06-04T16:53:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "@kouvel fyi..",
                                           "updatedAt":  "2020-06-04T16:53:51Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzODk5MTYwMA==",
                                           "createdAt":  "2020-06-04T17:18:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "The problem is that there are typically number of different kinds of thread handles. For example, OSX has `pthread_t*`, `mach_port_t` and TID. Even `pthread_t*` on Linux is not the ubiquitous thread ID. For example, the Linux OS syscalls take `pid_t`, not `pthread_t*`.\r\n\r\n\u003e Working with native fibres\r\n\u003e Creating custom fibre libraries\r\n\r\n.NET does not work with Windows fibres for fundamendal reasons. This API won\u0027t make it possible.",
                                           "updatedAt":  "2020-06-04T17:18:43Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzODk5NDA1Mw==",
                                           "createdAt":  "2020-06-04T17:23:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "Isn\u0027t `pid_t` the process ID and not the thread handle?",
                                           "updatedAt":  "2020-06-04T17:23:35Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzODk5NTMyMQ==",
                                           "createdAt":  "2020-06-04T17:26:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC4G8jQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tannergooding",
                                                                               "createdAt":  "2020-06-04T17:26:50Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2023-03-19T14:36:01Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "janvorli",
                                           "body":  "`pid_t` is used for both process id and thread id (`gettid()` returns it for current thread, for example)",
                                           "updatedAt":  "2020-06-04T17:26:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzODk5NjQ2Ng==",
                                           "createdAt":  "2020-06-04T17:28:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "Thanks! For reference: https://man7.org/linux/man-pages/man2/gettid.2.html\r\n\r\n\u003e In a single-threaded process, the thread ID is equal to the process ID (PID, as returned by getpid(2)).  In a multithreaded process, all threads have the same PID, but each one has a unique TID. \r\n\u003e ...\r\n\u003e The thread ID returned by this call is not the same thing as a POSIX thread ID (i.e., the opaque value returned by pthread_self(3)).",
                                           "updatedAt":  "2020-06-04T17:28:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzOTAwMDQ1NQ==",
                                           "createdAt":  "2020-06-04T17:35:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "john-h-k",
                                           "body":  "\u003e .NET does not work with Windows fibres for fundamendal reasons. This API won\u0027t make it possible.\r\n\r\nis it specific to how the win32 fibre implementation works? - or is it fundamentally impossible to use fibres at all in .NET",
                                           "updatedAt":  "2020-06-04T17:37:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzOTAwMjEyNw==",
                                           "createdAt":  "2020-06-04T17:39:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e  or is it fundamentally impossible to use fibres at all in .NET\r\n\r\nCorrect. We do not support running managed code on fibers. If you run managed code on fibers, you will get arbitrary crashes.",
                                           "updatedAt":  "2020-06-04T17:39:09Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzOTAwMzAwOQ==",
                                           "createdAt":  "2020-06-04T17:40:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEDjvvw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "danmoseley",
                                                                               "createdAt":  "2020-06-04T19:17:48Z"
                                                                           },
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "MihaZupan",
                                                                               "createdAt":  "2020-06-04T21:16:34Z"
                                                                           },
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "saucecontrol",
                                                                               "createdAt":  "2021-03-20T20:18:11Z"
                                                                           },
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "Joe4evr",
                                                                               "createdAt":  "2021-03-21T13:00:48Z"
                                                                           },
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "theodorzoulias",
                                                                               "createdAt":  "2021-03-27T07:00:00Z"
                                                                           },
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "GSPP",
                                                                               "createdAt":  "2022-01-20T09:20:06Z"
                                                                           },
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2023-03-19T14:36:05Z"
                                                                           },
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "MichelZ",
                                                                               "createdAt":  "2024-05-05T05:57:34Z"
                                                                           },
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "Kuinox",
                                                                               "createdAt":  "2025-01-22T12:21:46Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  9
                                                         },
                                           "author":  "john-h-k",
                                           "body":  "\u003e If you run managed code on fibers, you will get arbitrary crashes.\r\n\r\nAh, my code already does that so it\u0027s fine 😆 ",
                                           "updatedAt":  "2023-03-14T22:54:34Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzOTA2MTgwMA==",
                                           "createdAt":  "2020-06-04T19:12:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "john-h-k",
                                           "body":  "Being able to do things like set affinity would still be useful, I think. Althought, there could be a managed API to do that specific thing\r\n",
                                           "updatedAt":  "2020-06-04T19:12:40Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwMzQ1MjkyNw==",
                                           "createdAt":  "2021-03-20T19:40:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "HighPerfDotNet",
                                           "body":  "I think I\u0027ve run into changed behavior related to this when trying to port .NET Framework application that was successful at setting ideal processor affinity but that no longer works in .NET 5, the following code no longer matches current thread id:\r\n\r\n/*  --------------------------------------------------------------------------------- */\r\n\r\n// note: it\u0027s obsolte, but the same value can be had via Thread.CurrentThread.ManagedThreadId - \r\n// giving exact code as it worked for 10+ years.\r\n\r\nint iCurThreadID=AppDomain.GetCurrentThreadId();\r\n\r\nforeach (ProcessThread oPT in Process.GetCurrentProcess().Threads)\r\n{\r\n\r\n\tif (oPT.Id==iCurThreadID)\r\n\t{\r\n\t\toPT.PriorityBoostEnabled=true;\r\n\t\toPT.IdealProcessor=iProcAffinity;\r\n\t\toPT.ProcessorAffinity=new IntPtr(1L\u003c\u003ciProcAffinity);\r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\n/*  --------------------------------------------------------------------------------- */\r\n\r\nHow are we supported to set processor affinity for current managed thread?",
                                           "updatedAt":  "2021-03-20T19:43:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GWyCj",
                                           "createdAt":  "2022-07-11T12:57:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "deeprobin",
                                           "body":  "API-Shape looks good to me.\r\nImo, we should consider using the CallerMustBeUnsafe (see [proposal](https://github.com/dotnet/runtime/issues/31354)) attribute.",
                                           "updatedAt":  "2022-07-11T12:57:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GWykn",
                                           "createdAt":  "2022-07-11T12:59:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "deeprobin",
                                           "body":  "Alternative: A property called `NativeHandle`, `UnderlyingHandle` or just `Handle` to be conform with https://github.com/dotnet/winforms/issues/8833.",
                                           "updatedAt":  "2023-03-14T22:54:35Z"
                                       }
                                   ],
                         "totalCount":  16
                     },
        "title":  "Provide a method to retrieve the native handle for a Thread object",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/38930",
        "createdAt":  "2020-07-08T14:00:30Z",
        "number":  38930,
        "author":  "JesperTreetop",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-08-12T19:37:32Z",
        "body":  "Some parts of the runtime and BCL depend on spin-waiting or spin-waiting-based locks, and both are vended publicly as part of the System.Threading namespace. Spin-waiting is already an optimization to be used judiciously, but increasingly .NET will be available on platforms where the CPU has an asymmetric configuration, where there are low energy \"efficiency\" cores and high performance cores which might upset the assumptions the optimization is based on.\r\n\r\nThis arrangement of cores is known in ARM world as \"big.LITTLE\" and has been in use for several years in high volume devices. Recently, Intel has launched a Lakefield Atom processor [which contains the same type of arrangement](https://www.anandtech.com/show/15877/intel-hybrid-cpu-lakefield-all-you-need-to-know/5), Apple is gearing up to move future Macs to their ARM instruction set CPUs, and an increasing number of Windows laptops and tablets are using ARM so there\u0027s reason to believe that this arrangement will be more common in the future. (Note that this isn\u0027t a universal feature of ARM SoCs; many phones have them and many don\u0027t, the Raspberry Pi doesn\u0027t, etc. [See \"big.LITTLE role\" as an illustration](https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores).)\r\n\r\nAs part of Apple\u0027s porting advice, they outright [recommend against spin-waiting](https://developer.apple.com/documentation/os/workgroups/tuning_your_code_s_performance_for_apple_silicon):\r\n\r\n\u003e When you keep a thread active but doing nothing, you prevent a CPU core from doing other work. On Apple silicon, this behavior exacerbates performance issues in producer-consumer algorithms when the consumer thread runs on a p-core and the producer runs on an e-core. Instead, eliminate spin locks and other spin-wait code that causes your thread to hold on to a core. Replace them with an os_unfair_lock, a condition variable, or a standard mutex that lets your thread block.\r\n\r\nOS-specific resolution aside, this line of reasoning and these consequences seem like they would be broadly applicable to any such asymmetric configuration.\r\n\r\nI don\u0027t have a pull request or a suggestion for what to do, and anything involving that also involves performance and backward compatibility. I\u0027m out of my depth here so this isn\u0027t even a question, but I wanted to raise the issue that it might be worth broadly considering this subject and, if possible, provide a way to check if the architecture of the processor makes spin-waiting a good idea or not. ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOJxZ5ZQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY1NTU1NjA0Nw==",
                                           "createdAt":  "2020-07-08T14:29:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "@kouvel",
                                           "updatedAt":  "2020-07-08T14:29:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY1NTczNjk5Nw==",
                                           "createdAt":  "2020-07-08T20:23:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "scalablecory",
                                           "body":  "While a pure dumb spin wait is very often a bad idea on multi-threaded systems, the `SpinWait` type is not that. It will yield back to the OS periodically to avoid the problems outlined in that article.\r\n\r\nIf you have some examples of a non-yielding spin wait happening within .NET, I agree those should be looked at with suspicion.",
                                           "updatedAt":  "2020-07-08T20:24:22Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY1NTc4NDI5Mw==",
                                           "createdAt":  "2020-07-08T22:10:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "JesperTreetop",
                                           "body":  "I don\u0027t have any concrete examples of that.\r\n\r\nI remember SpinWait and SpinLock being introduced over a decade ago, and I know that they were built to power scenarios like the ones mentioned in the quote (to avoid the cost of synchronization in hot queues), so I figured that there would be some adaptation necessary, since the SpinWait struct according to its documentation [tries to do smart things depending on the processor\u0027s core composition already](https://docs.microsoft.com/en-us/dotnet/api/system.threading.spinwait?view=netcore-3.1#remarks) (hyper-threading).\r\n\r\nIt\u0027s quite possible that the existing code, due to the periodic yielding you mention, does entirely the right thing exactly as written already. I have no idea - if so, great news for everyone! My reason for writing an issue was just to bring it to the attention, in the odd case that it hadn\u0027t come up, of people who would know all these distinctions, and also know if there\u0027s reason to take another look at some things, since [it\u0027s used in various concurrency-critical code](https://source.dot.net/#System.Private.CoreLib/SpinWait.cs,e030659599d0fa3f,references).\r\n\r\nAlso, I thought one of the issues with yielding was of being returned on a differently capable core, which sounds like it could lead to some jumpy and unpredictable performance.",
                                           "updatedAt":  "2020-07-08T22:15:48Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Spin-waiting on asymmetric CPU configurations",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/41416",
        "createdAt":  "2020-08-18T10:04:32Z",
        "number":  41416,
        "author":  "JasonjhHuang",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-10-08T17:12:05Z",
        "body":  "# IO port access ok with thread but fail with timer\r\n\r\nWe are using a 3rd party library to do hardware monitor, such as read voltage / temperate every 5 seconds. However, it\u0027s working when we implement the periodically HWM with thread but will crash with timer.\r\n\r\n# Code Segment \r\n\r\n---\r\n### Crash when using timer\r\n\r\n\tvar key = Console.ReadKey();\r\n\tTimer timer = new Timer((state) =\u003e\r\n\t{\r\n\t\thelper.Initialize();\r\n\t\tReadValues(helper);\r\n\t}, null, 500, 5000);\r\n\r\n\twhile (key.Key != ConsoleKey.Q)\r\n\t{\r\n\t\tkey = Console.ReadKey();\r\n\t\tif (key.Key == ConsoleKey.Q)\r\n\t\t{\r\n\t\t\ttimer.Change(Timeout.Infinite, Timeout.Infinite);\r\n\t\t\tThread.Sleep(500);\r\n\t\t\ttimer.Dispose();\r\n\t\t}\r\n\t}\r\n\r\n---\r\n### Safe when using thead\r\n\r\n\twhile (key.Key != ConsoleKey.Q)\r\n\t{\r\n\t\tmanualResetEvent.Reset();\r\n\t\tvar thread = new Thread(() =\u003e\r\n\t\t{\r\n\t\t\tif (!initializeOnce || !initialize)\r\n\t\t\t{\r\n\t\t\t\thelper.Initialize();\r\n\t\t\t\tinitialize = initializeOnce;\r\n\t\t\t}\r\n\t\t\tReadValues(helper);\r\n\t\t\tmanualResetEvent.Set();\r\n\t\t});\r\n\r\n\t\tthread.Start();\r\n\t\tmanualResetEvent.WaitOne();\r\n\t\tkey = Console.ReadKey();\r\n\t}\r\n\r\n# Test Environment\r\n\r\nUbuntu 18.04 x64\r\n.NET Core 3.1\r\n.NET 5 Preview 6 \u0026 Preview 7\r\n\r\n# Suspect\r\n\r\nThe 3rd party library uses io port to access Super IO HWM information and the crash message looks like the ioperm is not working when using timer. However, I can\u0027t modify the 3rd party library code and can\u0027t confirm my suspect. Is anyway for you to check this case?\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOKPCtqA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY4MTA2NzczMA==",
                                           "createdAt":  "2020-08-26T19:07:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Dotnet-GitSync-Bot",
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2020-08-26T19:07:09Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY4MTE1NDM2MA==",
                                           "createdAt":  "2020-08-26T22:22:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "@JasonjhHuang would you be able to provide a repro and/or dump to diagnose the issue further? ",
                                           "updatedAt":  "2020-08-26T22:22:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY4MTI2MDc3NQ==",
                                           "createdAt":  "2020-08-27T01:40:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "JasonjhHuang",
                                           "body":  "@mangod9 \r\n\r\nThis library actually is from vendor, so it\u0027s hard to provide a repro to you. However, the crash message in dmesg is like this:\r\n\r\n`[2497637.480662] traps: .NET ThreadPool[32490] general protection fault ip:7f6ba3dcf3d7 sp:7f6b3973a498 error:0 in libXXXX.so[7f6ba3d95000+5b000]`\r\n`[2567674.665142] traps: .NET ThreadPool[5138] general protection fault ip:7fb5a62243d7 sp:7fb5a5984498 error:0 in libXXXX.so[7fb5a61ea000+5b000]`\r\n\r\nDoes this information help?",
                                           "updatedAt":  "2020-08-27T01:40:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY4MzIxNzAyNA==",
                                           "createdAt":  "2020-08-29T01:49:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "If you could capture a dump when the process crashes that would be useful, otherwise would be difficult to diagnose. ",
                                           "updatedAt":  "2020-08-29T01:49:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY4MzUxMzcwOQ==",
                                           "createdAt":  "2020-08-31T02:08:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "JasonjhHuang",
                                           "body":  "What dump tool should I use? dotnet-dump? or gdb dump? Because the vendor was providing binary library, I think it\u0027s hard to provide gdb dump file. As for dontet-dump tool,  do you have any tutorial page to share? I can only find [this page](https://docs.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-dump#dotnet-dump-collect).",
                                           "updatedAt":  "2020-08-31T02:08:26Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY4MzU4NzU0Nw==",
                                           "createdAt":  "2020-08-31T06:30:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "Perhaps the library calls `ioperm` only the first time it is used, but the timer callbacks then run on thread-pool threads that would need their own `ioperm` calls. The `strace` program should show which threads call `ioperm` and which thread gets the fatal signal. You could add a `Console.WriteLine` call immediately before `ReadValues` to make it easy to find in the output of `strace`.",
                                           "updatedAt":  "2020-08-31T06:30:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY4MzY1OTIwNQ==",
                                           "createdAt":  "2020-08-31T09:03:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "JasonjhHuang",
                                           "body":  "I add a initialize call before calling `ReadValues` in timer case, but it still crashed. I use `strace` to get some information, does this help? BTW, in thread and timer cases, you can see I do initialize before calling `ReadValues` but only timer case will crash. This is pretty strange. \r\n\r\n---\r\nstrace: Process 21762 attached\r\nread(0, \"\\r\", 1024)                     = 1\r\nfutex(0x563cc6bbdb90, FUTEX_WAKE_PRIVATE, 1) = 1\r\nfutex(0x563cc6bbdb40, FUTEX_WAKE_PRIVATE, 1) = 1\r\nlstat(\"/snap\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/snap/dotnet-sdk\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/snap/dotnet-sdk/97\", {st_mode=S_IFDIR|0755, st_size=249, ...}) = 0\r\nlstat(\"/snap/dotnet-sdk/97/shared\", {st_mode=S_IFDIR|0755, st_size=88, ...}) = 0\r\nlstat(\"/snap/dotnet-sdk/97/shared/Microsoft.NETCore.App\", {st_mode=S_IFDIR|0755, st_size=47, ...}) = 0\r\nlstat(\"/snap/dotnet-sdk/97/shared/Microsoft.NETCore.App/5.0.0-preview.8.20407.11\", {st_mode=S_IFDIR|0755, st_size=6682, ...}) = 0\r\nstat(\"/snap/dotnet-sdk/97/shared/Microsoft.NETCore.App/5.0.0-preview.8.20407.11/System.Runtime.InteropServices.dll\", {st_mode=S_IFREG|0644, st_size=39936, ...}) = 0\r\nopenat(AT_FDCWD, \"/snap/dotnet-sdk/97/shared/Microsoft.NETCore.App/5.0.0-preview.8.20407.11/System.Runtime.InteropServices.dll\", O_RDONLY) = 26\r\nfcntl(26, F_SETFD, FD_CLOEXEC)          = 0\r\nfstat(26, {st_mode=S_IFREG|0644, st_size=39936, ...}) = 0\r\nfcntl(26, F_DUPFD_CLOEXEC, 0)           = 28\r\nfstat(28, {st_mode=S_IFREG|0644, st_size=39936, ...}) = 0\r\nmmap(NULL, 39936, PROT_READ, MAP_SHARED, 28, 0) = 0x7f96880ad000\r\nmunmap(0x7f96880ad000, 39936)           = 0\r\nclose(28)                               = 0\r\npread64(26, \"MZ\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0\"..., 64, 0) = 64\r\npread64(26, \"PE\\0\\0\\35\\375\\3\\0I\\10\\217\\251\\0\\0\\0\\0\\0\\0\\0\\0\\360\\0\\\" \\v\\2\\v\\0\\0\\0\\0\\0\"..., 264, 128) = 264\r\nmmap(0x7f9612b60000, 4096, PROT_READ, MAP_PRIVATE|MAP_FIXED, 26, 0) = 0x7f9612b60000\r\nmmap(0x7f9612b70000, 2048, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED, 26, 0) = 0x7f9612b70000\r\nmmap(0x7f9612b80000, 39424, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED, 26, 0) = 0x7f9612b80000\r\nmmap(0x7f9612b99000, 3072, PROT_READ, MAP_PRIVATE|MAP_FIXED, 26, 0x9000) = 0x7f9612b99000\r\nmprotect(0x7f9612ba0000, 4096, PROT_READ|PROT_WRITE) = 0\r\nmadvise(0x7f9612ba0000, 4096, MADV_DODUMP) = 0\r\nmprotect(0x7f9612a8d000, 4096, PROT_READ|PROT_WRITE) = 0\r\nmadvise(0x7f9612a8d000, 4096, MADV_DODUMP) = 0\r\nmprotect(0x7f9612a8e000, 8192, PROT_READ|PROT_WRITE) = 0\r\nmadvise(0x7f9612a8e000, 8192, MADV_DODUMP) = 0\r\nmprotect(0x7f9612bb0000, 4096, PROT_READ|PROT_WRITE) = 0\r\nmadvise(0x7f9612bb0000, 4096, MADV_DODUMP) = 0\r\nwrite(19, \"\\r\", 1)                      = 1\r\nmprotect(0x7f9612ba1000, 4096, PROT_READ|PROT_WRITE) = 0\r\nmadvise(0x7f9612ba1000, 4096, MADV_DODUMP) = 0\r\nmprotect(0x7f9612811000, 4096, PROT_READ|PROT_WRITE) = 0\r\nmadvise(0x7f9612811000, 4096, MADV_DODUMP) = 0\r\nmprotect(0x7f9612811000, 4096, PROT_READ|PROT_WRITE|PROT_EXEC) = 0\r\nmprotect(0x7f9612bb1000, 4096, PROT_READ|PROT_WRITE) = 0\r\nmadvise(0x7f9612bb1000, 4096, MADV_DODUMP) = 0\r\nmprotect(0x7f9612ba2000, 4096, PROT_READ|PROT_WRITE) = 0\r\nmadvise(0x7f9612ba2000, 4096, MADV_DODUMP) = 0\r\nfutex(0x563cc6bbdb94, FUTEX_WAKE_PRIVATE, 1) = 1\r\nfutex(0x563cc6bbdb40, FUTEX_WAKE_PRIVATE, 1) = 1\r\nread(0,  \u003cunfinished ...\u003e)              = ?\r\n+++ killed by SIGSEGV (core dumped) +++\r\n\r\n",
                                           "updatedAt":  "2020-08-31T09:03:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY4MzcwMDA3Mw==",
                                           "createdAt":  "2020-08-31T10:34:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "I don\u0027t see any `ioperm` calls in that trace. I think it would be better to run your program via `strace -f` than attach to an existing process.",
                                           "updatedAt":  "2020-08-31T10:34:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY4NDE0MzczOQ==",
                                           "createdAt":  "2020-09-01T01:52:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "JasonjhHuang",
                                           "body":  "[timer.txt](https://github.com/dotnet/runtime/files/5153430/timer.txt)\r\n[timer_24862.txt](https://github.com/dotnet/runtime/files/5153431/timer_24862.txt)\r\n[timer_24863.txt](https://github.com/dotnet/runtime/files/5153432/timer_24863.txt)\r\n\r\nI did `strace -f` again to get these information, I think pid 24862 is main process and 24863 is timer thread. You can see `After Initialize` in 24863.txt, it means done calling initialization function and then crash when calling `ReadValues`.\r\n\r\n[thread.txt](https://github.com/dotnet/runtime/files/5153433/thread.txt)\r\n[thread_25017.txt](https://github.com/dotnet/runtime/files/5153434/thread_25017.txt)\r\n[thread_25018.txt](https://github.com/dotnet/runtime/files/5153436/thread_25018.txt)\r\n\r\nI also attached log when using thread, you can see few `Temperature value` shows which means it can read value and end normally.",
                                           "updatedAt":  "2020-09-01T01:52:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY4NTg1MDEzOA==",
                                           "createdAt":  "2020-09-02T16:27:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "I see references to `/sys/` and `ioperm` in thread_25018.txt but not in your other logs. Perhaps initialization has already happened before you attach with `strace -p`.\r\n\r\nDoes the documentation of the library say whether it is safe to use from multiple threads, and whether applications need to do anything special for that? If it does not mention such things, it might be best to ask the vendor of the library.",
                                           "updatedAt":  "2020-09-02T16:27:43Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY4Njg2MTczNg==",
                                           "createdAt":  "2020-09-04T02:24:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "JasonjhHuang",
                                           "body":  "[timer_15494.txt](https://github.com/dotnet/runtime/files/5172273/timer_15494.txt)\r\n[timer_15495.txt](https://github.com/dotnet/runtime/files/5172274/timer_15495.txt)\r\n\r\nI made some delay before calling initialization function in timer test, you can see the initialize procedure is almost identical with thread_25018.txt. However, it still crashed when using timer.\r\n\r\nThis issue doesn\u0027t related to multi-thread access, I just use the same APIs (initial \u0026 readvalue) in thread and timer mode, and it only crashed when in timer mode. The vendor said they made extra API to execute additional ioperm before calling readvalue and it works in timer mode but they think this issue should belong to .NET not to their library. Is it possible to create a simple library to reproduce this, like ioperm in initial function and inb in read function?",
                                           "updatedAt":  "2020-09-04T02:24:12Z"
                                       }
                                   ],
                         "totalCount":  11
                     },
        "title":  "IO port access ok with thread but fail with timer",
        "labels":  [
                       "area-System.Threading",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/41417",
        "createdAt":  "2020-08-26T20:49:58Z",
        "number":  41417,
        "author":  "WizardBrony",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOBQMkdw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "strangeman375",
                                            "createdAt":  "2020-08-27T11:42:45Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "GSPP",
                                            "createdAt":  "2020-09-12T08:52:38Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2021-07-21T02:01:41Z",
        "body":  "Some time ago, `Threading.Timer` was enhanced to make the firing of the native timer more efficient. This was done by introducing the \"short\" and \"long\" lists within `TimerQueue`: `Timer`s with short due times will end up on the short list, and the rest will end up on the long list. The idea is that the long list doesn\u0027t need to be processed every time the native timer fires, only after a given threshold of time has elapsed (detected by checking against the `_currentAbsoluteThreshold`, which is updated before every time the long list is processed). Thus, after periodic `Timer`s fire for their first time, they need to be examined to see if they are still on the correct list. This is handled by the following logic:\r\n\r\nhttps://github.com/dotnet/runtime/blob/afa4b2f344192c3609dd3c1419f68d99d10d7d62/src/libraries/System.Private.CoreLib/src/System/Threading/Timer.cs#L180-L192\r\n\r\nI agree that this logic needs to exist. My concern is that the comparison is made against `_currentAbsoluteThreshold` which, during the processing of the short list, could be anywhere in its interval. As a result, `Timer`s with periods less than `ShortTimersThresholdMilliseconds` can end up jumping between the short and long lists. For example:\r\n\r\n```cs\r\n[TestMethod]\r\npublic void TimerListTest()\r\n{\r\n    object timerQueueTimer = null;\r\n    var timer = new Timer(WriteIsOnShortList);\r\n\r\n    var timerHolder = typeof(Timer).GetField(\"_timer\", BindingFlags.Instance | BindingFlags.NonPublic)\r\n        .GetValue(timer);\r\n    timerQueueTimer = timerHolder.GetType().GetField(\"_timer\", BindingFlags.Instance | BindingFlags.NonPublic)\r\n        .GetValue(timerHolder);\r\n\r\n    bool GetIsOnShortList() =\u003e (bool) timerQueueTimer.GetType()\r\n        .GetField(\"_short\", BindingFlags.Instance | BindingFlags.NonPublic).GetValue(timerQueueTimer);\r\n\r\n    void WriteIsOnShortList(object state) =\u003e Console.WriteLine(GetIsOnShortList());\r\n\r\n    timer.Change(0, Period);\r\n\r\n    Thread.Sleep(10000);\r\n}\r\n```\r\n\r\nIf `Period` is, for example, 350 milliseconds, the output will be all `False`s. However, for a value like 250 milliseconds, an example run on my machine results in: `True` `True` `False` `False` `True` `False` `False` `False` `True` `False`....\r\n\r\nI don\u0027t quite understand why the logic isn\u0027t simply based on `ShortTimersThresholdMilliseconds`, such as:\r\n\r\n```cs\r\nbool targetShortList = timer._dueTime \u003c= ShortTimersThresholdMilliseconds;\r\n```\r\n\r\nHowever, I also understand that a lot of thought went into the existing design, so my guess is that I am most likely missing something. If someone could please give me some thoughts regarding this issue, I would really appreciate it.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  null,
                         "nodes":  [

                                   ],
                         "totalCount":  0
                     },
        "title":  "Threading.Timer: list thrashing",
        "labels":  [
                       "question",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/42684",
        "createdAt":  "2020-09-24T15:38:12Z",
        "number":  42684,
        "author":  "AArnott",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODAgFcQ==",
                          "nodes":  [
                                        {
                                            "content":  "HEART",
                                            "user":  "devsko",
                                            "createdAt":  "2020-09-24T15:48:33Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "slang25",
                                            "createdAt":  "2020-09-24T18:17:25Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "pinkfloydx33",
                                            "createdAt":  "2020-09-25T08:24:01Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "sharwell",
                                            "createdAt":  "2020-10-01T18:46:08Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "LinuxDoku",
                                            "createdAt":  "2020-11-19T11:32:11Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "tullo-x86",
                                            "createdAt":  "2021-02-17T20:48:03Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "batkaevruslan",
                                            "createdAt":  "2024-04-10T12:57:58Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "cklutz",
                                            "createdAt":  "2025-03-26T04:25:57Z"
                                        }
                                    ],
                          "totalCount":  8
                      },
        "updatedAt":  "2025-04-04T01:02:39Z",
        "body":  "## Background and Motivation\r\n\r\nThe `StackTrace` class can be instantiated at any time to get the CLR to talk the thread\u0027s callstack and capture the result in an object that can be stored or shared. Similar to stacks captured by thrown exceptions, this can be *very* useful--useful enough for the API in the first place, so I\u0027ll forebear explaining all the reasons why it\u0027s good.\r\n\r\nBut its usefulness has substantially degraded in the async world, where the literal callstack is often not helpful. With stack traces in exceptions it\u0027s better (although very hard to read as captured by #4996) for the final rethrown exception because as the exception is thrown and rethrown down the async continuation chain, the logical \"return stack\" is reassembled so the stack trace contains the whole picture. \r\n\r\nThe VS debugger has gotten better. Its Callstack tool window actually does some work to walk not only the callstack but also the async continuation stack/tree to suggest who the async callers are. The Parallel Stacks tool window has a new Tasks view that is also pretty good at representing this information.\r\n\r\nBut when just using `new StackTrace()` none of this is available. So when I try to use this (e.g. under special debug/instrumented mode for an application in order to establish ownership of an object) it can be useless.\r\n\r\nWhat I propose is an `AsyncStackTrace` class that understands common continuations/awaiter patterns just like the VS debugger does to reconstruct the async return stack. \r\n\r\nSee also: dotnet/runtime#14434\r\n\r\n## Proposed API\r\n\r\nI\u0027m not sure yet what would make sense to expose. We might want to allow custom awaiters to register themselves as helpers so that async stacks can be stitched together by this class as well as the built-in recognized ones. Hey, if we do this well, maybe the debugger can even use this to help with stitching to do a more complete job.\r\n\r\n```diff\r\nnamespace System.Diagnostics\r\n{\r\n+    public class AsyncStackTrace {\r\n+        public AsyncStackTrace() { }\r\n+        public static void RegisterCustomAwaiter\u003cTAwaiter\u003e(Func\u003cTAwaiter, Action\u003e awaiterToContinuation);\r\n+        /// \u003csummary\u003eGets the async and sync frames in the call/return stack.\u003c/summary\u003e\r\n+        public ReadOnlyMemory\u003cStackFrame\u003e Frames { get; }\r\n+    }\r\n}\r\n```\r\n\r\n\r\n## Usage Examples\r\n\r\nConsumption of the API should be straightforward:\r\n\r\n```cs\r\nclass Foo\r\n{\r\n    AsyncStackTrace owner;\r\n\r\n    public Foo()\r\n    {\r\n        this.owner = new AsyncStackTrace();\r\n    }\r\n}\r\n```\r\n\r\nLater, when debugging and finding a `Foo` instance somewhere, it\u0027s trivial to see what stack (including logical async frames) created the object by inspecting the `AsyncStackTrace` field.\r\n\r\nCustom awaiters should define a static constructor to register themselves. This ensures that the right owner registers each custom awaiter and that it happens exactly once:\r\n\r\n```cs\r\npublic struct MyCustomAwaiter : INotifyCompletion\r\n{\r\n    private Action continuation;\r\n    static MyCustomAwaiter()\r\n    {\r\n        AsyncStackTrace.RegisterCustomAwaiter\u003cMyCustomAwaiter\u003e(self =\u003e self.continuation);\r\n    }\r\n\r\n    public bool IsCompleted =\u003e false;\r\n    public void OnCompleted(Action continuation) =\u003e this.continuation = continuation;\r\n    public void GetResult() { }\r\n}\r\n```\r\n\r\n## Alternative Designs\r\n\r\nAwaiters may have `OnCompleted(Action)` called multiple times, so we may want to offer an API that acknowledges that. And maybe the `AsyncStackTrace` class should represent a *tree* of continuation frames instead of assuming a stack representation as `StackTrace` does.\r\n\r\n## Risks\r\n\r\nTBD after some initial discussion",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOpYpoSQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6limhJ",
                                           "createdAt":  "2025-04-04T01:02:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AArnott",
                                           "body":  "Seems like a worthwhile idea to reconsider in light of upcoming \"async 2.0\".",
                                           "updatedAt":  "2025-04-04T01:02:27Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "AsyncStackTrace class that can walk continuations",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/42994",
        "createdAt":  "2020-10-02T21:42:43Z",
        "number":  42994,
        "author":  "dje-dev",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-08-02T17:02:07Z",
        "body":  "\r\n[Linux_threadpool_perf.txt](https://github.com/dotnet/runtime/files/5320411/Linux_threadpool_perf.txt)\r\n\r\n### Description\r\nA large C# application makes extensive use of multithreading (including ThreadPool) and runs well on Windows but degrades to 1/3 speed on Linux.\r\n\r\nThe attached standalone C# benchmark code demonstrates the apparent problem. It is based mostly on a performance benchmark written by a member of the mono team:\r\nhttps://github.com/mono/mono/pull/17387.\r\n\r\n### Configuration\r\n.NET 5.0 RC1 running Windows 10 (2004)\r\nFor Linux test, running Ubuntu 20.04 via WSL2\r\nIntel 2 sockets of 16 physical cores each\r\n\r\n### Regression?\r\n\r\nUnknown.\r\n\r\n### Data\r\n\r\nWindows runtime: 5 seconds (70 seconds CPU)\r\nLinux runtime: 35 seconds (280 seconds CPU time)\r\n\r\n### Analysis\r\nAttempts such as modifying the threadpool minimum size, or setting processor affinity to only one socket did not meaningfully change the results.\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOM3HDbA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMjk3NDMzNA==",
                                           "createdAt":  "2020-10-02T21:54:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "Is it possible to measure with 3.1 to help check whether this is a regression in 5.0? That would make it more time critical if it is.\r\n@kouvel ",
                                           "updatedAt":  "2020-10-02T21:54:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMjk3NTEwNw==",
                                           "createdAt":  "2020-10-02T21:57:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dje-dev",
                                           "body":  "Apologies, I should have already noted that.  Not a regression, similar behavior was noted on .NET 3.1 (therefore unfortunately but understandably I guess you will have to treat it as less time critical...)",
                                           "updatedAt":  "2020-10-02T21:57:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMjk3Nzk0MQ==",
                                           "createdAt":  "2020-10-02T22:06:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "As well as investigating it would be nice to know whether we are missing interesting coverage in dotnet/performance. As I do not recall this showing up when @adamsitnik  compare results by OS.",
                                           "updatedAt":  "2020-10-02T22:06:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMzU3MjQxNg==",
                                           "createdAt":  "2020-10-05T11:30:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "hi @dje-dev \r\n\r\n\u003e WSL2\r\n\r\nWSL2 might add some non-trivial overhead. Have you tried to run the benchmark without it?\r\n\r\n\u003e  2 sockets \r\n\r\nWe had some issues in the past that were specific to hardware with multiple sockets. Have you tried to run in on a machine with a single socket?\r\n\r\n\u003e The attached standalone C# benchmark code demonstrates\r\n\r\nIs there any chance that you could contribute it to https://github.com/dotnet/performance repo? Benchmarks added to this repo are used to ensure that we don\u0027t introduce any regressions to .NET",
                                           "updatedAt":  "2020-10-05T11:30:05Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMzU3MzQyMw==",
                                           "createdAt":  "2020-10-05T11:32:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "\u003e we are missing interesting coverage in dotnet/performance\r\n\r\nyes, we should most probably add more ThreadPool benchmarks to the perf repo.\r\n\r\nCurrently we have only one: https://github.com/dotnet/performance/blob/master/src/benchmarks/micro/libraries/System.Threading.ThreadPool/Perf.ThreadPool.cs\r\n\r\nAnd it performs much better on Linux compared to Windows: 2.29 vs 3.33 seconds\r\n\r\nhttps://pvscmdupload.blob.core.windows.net/reports/allTestHistory%2frefs%2fheads%2fmaster_x64_ubuntu%2018.04%2fSystem.Threading.Tests.Perf_ThreadPool.QueueUserWorkItem_WaitCallback_Throughput(WorkItemsPerCore%3a%2020000000).html\r\n\r\nhttps://pvscmdupload.blob.core.windows.net/reports/allTestHistory%2frefs%2fheads%2fmaster_x64_Windows%2010.0.18362%2fSystem.Threading.Tests.Perf_ThreadPool.QueueUserWorkItem_WaitCallback_Throughput(WorkItemsPerCore%3a%2020000000).html",
                                           "updatedAt":  "2020-10-05T11:32:08Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwNDYwNzg2Mw==",
                                           "createdAt":  "2020-10-06T23:35:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "\u003e WSL2 might add some non-trivial overhead.\r\n\r\nI was recently debugging a problem in a .NET Core app and I\u0027ve noticed that under WSL2, that app was about 40% slower than in a VM on the same machine. The Linux distro in both the VM and WSL2 was the same. But I have no idea whether it is a general trend or if that app had some specific functionality that was interacting badly with WSL2. It was an app of another party, so I didn\u0027t know much of its internals.",
                                           "updatedAt":  "2020-10-06T23:35:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwNTgyNDQ4OA==",
                                           "createdAt":  "2020-10-08T21:08:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dje-dev",
                                           "body":  "Some progress with the help of the comments and suggestions:\r\n\r\n1. Testing has been moved to a single socket machine to eliminate that potential confounding factor.\r\n2. All performance tests from the following folders were run on (a) native Windows and (b) WSL2 and (c) Hyper-V running Linux from:\r\n    performance/src/benchmarks/micro/libraries/System.Threading\r\n    performance/src/benchmarks/micro/libraries/System.Threading.ThreadPool\r\n\r\n1. Native Windows and Linux via Hyper-V yield about the same (good performance).\r\n2. However the existing ThreadPool performance test (QueueUserWorkItem_WaitCallback_Throughput) confirms the circa 5x slower performance under WSL2\r\n3. The threading microbenchmarks mostly only moderately slower under WSL2. An exception is GetThreadStatic (8.3ns vs 2.6ns).\r\n\r\nTentative conclusion is that highly multithreaded .NET code is likely to run very slowly on WSL2. I suggest we focus on the most simple case of understanding why GetThreadStatic (a very simple operation) is so much slower.\r\n\r\nHow would you suggest we proceed? It gets complex because of the interaction with WSL2.\r\n\r\n(full WSL2 and native Windows tests results below)\r\n\r\n```\r\n*** WSL2 ***\r\nBenchmarkDotNet=v0.12.1, OS=ubuntu 20.04\r\nIntel Core i7-9750H CPU 2.60GHz, 1 CPU, 12 logical and 6 physical cores\r\n.NET Core SDK=5.0.100-rc.1.20452.10\r\n  [Host]     : .NET Core 5.0.0 (CoreCLR 5.0.20.45114, CoreFX 5.0.20.45114), X64 RyuJIT\r\n  Job-OGDZSD : .NET Core 5.0.0 (CoreCLR 5.0.20.45114, CoreFX 5.0.20.45114), X64 RyuJIT\r\n\r\n\r\n| Read_double                    | 0.0000 ns | 0.0000 ns | 0.0000 ns | 0.0000 ns |\r\n| Write_double                   | 0.0032 ns | 0.0037 ns | 0.0053 ns | 0.0015 ns |\r\n\r\n| GetThreadStatic                |  8.333 ns | 0.0290 ns | 0.0397 ns |\r\n| SetThreadStatic                | 10.357 ns | 0.0436 ns | 0.0652 ns |\r\n\r\n| EnterExit                      | 14.361 ns | 0.1072 ns | 0.1538 ns | 14.444 ns |\r\n| TryEnterExit                   | 14.318 ns | 0.1324 ns | 0.1857 ns | 14.309 ns |\r\n| TryEnter_Fail                  |  3.514 ns | 0.0113 ns | 0.0162 ns |  3.515 ns |\r\n| EnterExit                      | 21.14 ns  | 0.045 ns | 0.066 ns | 21.14 ns |\r\n| TryEnterExit                   | 23.13 ns  | 0.342 ns | 0.502 ns | 23.43 ns |\r\n\r\n| Increment_int                  | 4.764 ns  | 0.0174 ns | 0.0260 ns |\r\n| CompareExchange_object_NoMatch | 6.709 ns  | 0.0231 ns | 0.0324 ns |\r\n\r\n| Set_Reset                      | 355.5 ns  | 3.49 ns | 5.00 ns |\r\n| RegisterAndUnregister_Serial   |  60.72 ns | 0.878 ns | 1.231 ns |\r\n| RegisterAndUnregister_Parallel |  20.27 ns | 0.256 ns | 0.366 ns |\r\n\r\n|                         Cancel | 206.36 ns | 3.070 ns | 4.403 ns |\r\n|       CreateLinkedTokenSource1 |  73.22 ns | 0.280 ns | 0.384 ns |\r\n|       CreateLinkedTokenSource2 | 123.81 ns | 2.889 ns | 4.324 ns |\r\n|       CreateLinkedTokenSource3 | 199.87 ns | 1.823 ns | 2.728 ns |\r\n\r\n| QueueUserWorkItem_WaitCallback_Throughput |         20000000 | 11.89 s | 0.181 s | 0.411 s | 12.12 s |\r\n\r\n\r\n*** Native Windows ***\r\nBenchmarkDotNet=v0.12.1, OS=Windows 10.0.19041.508 (2004/?/20H1)\r\nIntel Core i7-9750H CPU 2.60GHz, 1 CPU, 12 logical and 6 physical cores\r\n.NET Core SDK=5.0.100-rc.1.20452.10\r\n  [Host]     : .NET Core 5.0.0 (CoreCLR 5.0.20.45114, CoreFX 5.0.20.45114), X64 RyuJIT\r\n  Job-LFGVEJ : .NET Core 5.0.0 (CoreCLR 5.0.20.45114, CoreFX 5.0.20.45114), X64 RyuJIT\r\n\r\n| Read_double  \t                 | 0.0461 ns | 0.0063 ns | 0.0095 ns |\r\n| Write_double                   | 0.2393 ns | 0.0096 ns | 0.0141 ns |\r\n\r\n| GetThreadStatic                | 2.591 ns | 0.1606 ns | 0.2404 ns |\r\n| SetThreadStatic                | 5.252 ns | 0.1517 ns | 0.2407 ns |\r\n\r\n| EnterExit                      | 14.549 ns | 0.0751 ns | 0.1124 ns |\r\n| TryEnterExit                   | 14.134 ns | 0.0815 ns | 0.1195 ns |\r\n| TryEnter_Fail                  |  4.095 ns | 0.1863 ns | 0.2551 ns |\r\n|  EnterExit                     | 14.84 ns | 0.063 ns | 0.093 ns |\r\n| TryEnterExit                   | 15.39 ns | 0.087 ns | 0.121 ns |\r\n\r\n| Increment_int                  | 4.774 ns | 0.0192 ns | 0.0287 ns |\r\n| CompareExchange_object_NoMatch | 5.088 ns | 0.0361 ns | 0.0540 ns |\r\n\r\n| Set_Reset                      | 1.227 us | 0.0042 us | 0.0061 us |\r\n|   RegisterAndUnregister_Serial |  46.817 ns | 0.6051 ns | 0.8283 ns |\r\n| RegisterAndUnregister_Parallel |   8.211 ns | 0.2663 ns | 0.7107 ns |\r\n\r\n|                         Cancel | 148.132 ns | 0.9243 ns | 1.3548 ns |\r\n|       CreateLinkedTokenSource1 |  54.312 ns | 0.2988 ns | 0.4379 ns |\r\n|       CreateLinkedTokenSource2 | 103.057 ns | 1.2763 ns | 1.8707 ns |\r\n|       CreateLinkedTokenSource3 | 156.846 ns | 1.3350 ns | 1.9146 ns |\r\n\r\n| QueueUserWorkItem_WaitCallback_Throughput |         20000000 | 2.531 s | 0.0261 s | 0.0349 s |\r\n```",
                                           "updatedAt":  "2020-10-08T21:08:37Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwNTgzMTE4OQ==",
                                           "createdAt":  "2020-10-08T21:23:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "@dje-dev just curious, could you tell us more about the scenario here -- are you deploying a product to run on WSL2? I think generally I have been thinking of that as more of a developer platform, not a deployment platform: for testing and developing software to later deploy on a \"regular\" Linux machine or VM - so raw performance was less critical. What are you using WSL2 for?",
                                           "updatedAt":  "2020-10-08T21:23:08Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwNTg0MDk3NA==",
                                           "createdAt":  "2020-10-08T21:46:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dje-dev",
                                           "body":  "Fair enough, in some places Microsoft does refer to WSL2 as \"primarily a tool for developers.\" But on the other hand, one could get by if it were a 5% or maybe even 50% performance regression, but at 500% it\u0027s no longer viable (at least with some applications) as a developer tool. \r\n\r\nFurther, WSL2 has been described by Microsoft as generally being very close to bare metal. This was confirmed by\r\nPhoronix, who ran a suite of 69 benchmarks(https://www.phoronix.com/scan.php?page=article\u0026item=windows10-may2020-wsl2) including some with multithreading and reported \"Ubuntu 20.04 running bare metal on the same system was faster by just 8%.\"\r\n\r\nThis suggests to me that there is a nontrival possibility that either (a) there is some bad interaction between .NET runtime and WSL2, and/or (b) this performance problem is not intrinsically solvable (albeit possibly involving WSL2 adjustments).\r\n",
                                           "updatedAt":  "2020-10-08T21:46:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwNTg0NTAwOA==",
                                           "createdAt":  "2020-10-08T21:57:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "@dje-dev I\u0027m still curious about your production scenario, do you have one, or just happened to notice it? It would be interesting f there was data suggesting real customers deploy perf sensitive workloads to WSL2. \r\n\r\nBut yes, if it\u0027s essentially a regular VM then perhaps there\u0027s a perf issue to report to them here.",
                                           "updatedAt":  "2020-10-08T21:57:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwNTg1MDg3OQ==",
                                           "createdAt":  "2020-10-08T22:13:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dje-dev",
                                           "body":  "Sure, my scenario is development, I was hoping to leverage awesome tools Microsoft is making available for this (https://devblogs.microsoft.com/dotnet/debug-your-net-core-apps-in-wsl-2-with-visual-studio/).\r\n\r\nOf course Docker for Windows is now based on WSL2 so this will be a common scenario.\r\n\r\nJust not sure how where we take this issue form here.....any thoughts appreciated.",
                                           "updatedAt":  "2020-10-08T22:13:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwNTg2MTY0Mg==",
                                           "createdAt":  "2020-10-08T22:44:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "It would be nice if we could localize this to some API we call, so that we could open an issue against WSL2. But, it is for @kouvel to determine whether or how to proceed as he owns this area.",
                                           "updatedAt":  "2020-10-08T22:44:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwNTg2MTg3MQ==",
                                           "createdAt":  "2020-10-08T22:45:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "(And even for a dev scenario, 5x slower may be unnacceptable, as you say, depending on the scenario.)",
                                           "updatedAt":  "2020-10-08T22:45:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwNTg2MzIyMg==",
                                           "createdAt":  "2020-10-08T22:50:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "The comment above says:\r\n\r\n\u003e GetThreadStatic (a very simple operation) is so much slower.\r\n\r\nI wonder if WSL2 has some perf issue w.r.t. mechanisms used for thread local access. Linux accesses it via `fs` segment.\r\n",
                                           "updatedAt":  "2020-10-08T22:50:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcxMDI5ODc2Ng==",
                                           "createdAt":  "2020-10-16T17:44:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODHEVXQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ca0v",
                                                                               "createdAt":  "2023-09-18T10:41:26Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "dje-dev",
                                           "body":  "Great, so we have isolated at least a part of this apparent problem with WSL2 + .NET to just 2 lines of code (see below) appearing as part of the .NET test suite at: https://github.com/dotnet/performance/blob/74fca49ecd1f0eae51b0172bd121ee7d0fdd2b6d/src/benchmarks/micro/corefx/System.Threading/Perf.ThreadStatic.cs\r\n\r\nFurther, janvorli has conjectured about a potential reason for the performance issue and I have verified the issue exists on two different systems.\r\n\r\nThese two products (WSL2 and .NET) are promoted as working well together, and if we can make sure there are no serious performance problems (such as this 4x to 5x regression in some scenarios) it will be surely helpful to me and others.\r\n\r\nIs there some way we could move this forward?\r\n\r\nThank you.\r\n```\r\n   [ThreadStatic]\r\n    private static object t_threadStaticValue = null;\r\n\r\n   [Benchmark]\r\n   public object GetThreadStatic() =\u003e t_threadStaticValue;\r\n```",
                                           "updatedAt":  "2020-10-16T17:44:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2MzA5MzYxMg==",
                                           "createdAt":  "2021-06-17T09:42:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ShadyNagy",
                                           "body":  "Is that problem still exist on .Net 6?",
                                           "updatedAt":  "2021-06-17T09:42:10Z"
                                       }
                                   ],
                         "totalCount":  16
                     },
        "title":  "Threadpool performance 5x slower under Linux under WSL2 vs. Windows",
        "labels":  [
                       "area-System.Threading",
                       "os-windows-wsl",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/43346",
        "createdAt":  "2020-10-13T07:20:11Z",
        "number":  43346,
        "author":  "carlossanlop",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-07-19T15:29:14Z",
        "body":  "Currently we only have one unit test file testing `MutexSecurity`, and contains only one unit test that verifies the parameterless constructor:\r\nhttps://github.com/dotnet/runtime/blob/6072e4d3a7a2a1493f514cdf4be75a3d56580e84/src/libraries/System.Threading.AccessControl/tests/MutexSecurityTests.cs#L6-L16\r\n\r\nWe also need test classes to verify `SemaphoreSecurity` and `EventWaitHandleSecurity` as well.\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOKkoj9w==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwNzk3MDk3OQ==",
                                           "createdAt":  "2020-10-13T19:51:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBTgZWg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "carlossanlop",
                                                                               "createdAt":  "2020-10-14T20:06:22Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "eugene-shcherbo",
                                           "body":  "Hi, would you mind me working on this? I would love to pick it up. ",
                                           "updatedAt":  "2020-10-13T19:51:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwODAzNTMyOQ==",
                                           "createdAt":  "2020-10-13T22:06:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBTZYlQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "eugene-shcherbo",
                                                                               "createdAt":  "2020-10-14T04:01:35Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "Hi @eugene-shcherbo yes, for sure - I assigned to you.",
                                           "updatedAt":  "2020-10-13T22:06:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwODE0NjU3Nw==",
                                           "createdAt":  "2020-10-14T04:19:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "eugene-shcherbo",
                                           "body":  "Thank you @danmosemsft ",
                                           "updatedAt":  "2020-10-14T04:19:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwOTM2MTEwMw==",
                                           "createdAt":  "2020-10-15T14:24:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "eugene-shcherbo",
                                           "body":  "Hi @carlossanlop, @danmosemsft . I wonder if we want to cover with tests `internal` methods of the mentioned classes. I\u0027m asking because now the assembly with code seems not to expose its internal members to the tests assembly. Therefore I would gladly discuss with you (when you have time) what you think of it and if we should do something with this. \r\n\r\nMy opinion is that it would be good to test them, at least the tests would be like an additional documentation, but I\u0027m not sure what issues addding the  `InternalsVisibleToAttribute` attribute can cause, so looking forward to your opinions or advice, guys. Thanks! ",
                                           "updatedAt":  "2020-10-15T14:31:46Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwOTQ5MTI1MA==",
                                           "createdAt":  "2020-10-15T17:53:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBUSSXQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "eugene-shcherbo",
                                                                               "createdAt":  "2020-10-15T17:58:59Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "carlossanlop",
                                                                               "createdAt":  "2020-10-22T00:02:29Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "@carlossanlop is the code owner. I can say more generally: we try to test only through public API and we should do that if at all possible. Amongst other reasons that makes it easier to refactor the product code. In the rare instances where it isn\u0027t good enough, it is possible to use InternalsvisibleToAttribute but compiling selected product source files into the test assembly is preferable. This is the approach taken to test the `Uri` class. But we should make every effort to test through public API.",
                                           "updatedAt":  "2020-10-15T17:53:37Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwOTQ5ODI5OQ==",
                                           "createdAt":  "2020-10-15T18:05:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "eugene-shcherbo",
                                           "body":  "@danmosemsft I get the idea, makes sense actually. Thank you for the answer, this is very useful to know. And apologizing for mentioning you in the question especially if I distracted you. ",
                                           "updatedAt":  "2020-10-15T18:06:08Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwOTUwMTk0Mw==",
                                           "createdAt":  "2020-10-15T18:12:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBToytA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "eugene-shcherbo",
                                                                               "createdAt":  "2020-10-15T18:15:31Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "You are welcome to mention me any time!",
                                           "updatedAt":  "2020-10-15T18:12:51Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "Unit tests missing for MutexSecurity, SemaphoreSecurity, EventWaitHandleSecurity",
        "labels":  [
                       "area-System.Threading",
                       "test-enhancement"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/44178",
        "createdAt":  "2020-11-03T01:56:31Z",
        "number":  44178,
        "author":  "hrrrrustic",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-07-04T15:42:41Z",
        "body":  "## Background and Motivation\r\nMake simple usages of WaitHandle.Wait(Any/All) with only WaitHandles[] argument a little bit cleaner\r\n\r\n## Proposed API\r\n```C#\r\npublic static bool WaitAny(params WaitHandle[] waitHandles);\r\npublic static bool WaitAll(params WaitHandle[] waitHandles);\r\n```\r\n## Usage Examples\r\n``` C#\r\npublic class SomeClassWithResetEvent\r\n{\r\n    public void SomeMethodWithCancellation(CancellationToken token)\r\n    {\r\n        ...\r\n        WaitHandle.WaitAny(_resetEvent, token.WaitHandle);\r\n        ...\r\n    }\r\n}\r\n```\r\n\r\nFor example, it can be useful [there](https://github.com/dotnet/msbuild/blob/47e6ac1bcff02d4cfbf2ff8ea0c957c072f697cc/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs#L117) and [there](https://github.com/dotnet/msbuild/blob/47e6ac1bcff02d4cfbf2ff8ea0c957c072f697cc/src/Build/BackEnd/Node/InProcNode.cs#L132)\r\n## Alternative Designs\r\nNone. \r\nBut it\u0027s possible to add similar methods for overloads with additional arguments (Timeout, ExitContext). However, it may look weird in IntelliSense due to a params argument must be last, when the old overloads get WaitHandle array on the first place\r\n## Risks\r\nNone",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOKvvTJA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMDg4MDk0Mg==",
                                           "createdAt":  "2020-11-03T03:12:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "Linking sister issue https://github.com/dotnet/runtime/issues/44181.",
                                           "updatedAt":  "2020-11-03T03:12:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMDk0MjA2Mg==",
                                           "createdAt":  "2020-11-03T07:01:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "svick",
                                           "body":  "Do I understand it correctly that this is only about adding `params` to the two existing overloads? I.e. the change is:\r\n\r\n```diff\r\n-public static bool WaitAny(WaitHandle[] waitHandles);\r\n+public static bool WaitAny(params WaitHandle[] waitHandles);\r\n-public static bool WaitAll(WaitHandle[] waitHandles);\r\n+public static bool WaitAll(params WaitHandle[] waitHandles);\r\n```",
                                           "updatedAt":  "2020-11-03T07:01:48Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMTE0NjY2MA==",
                                           "createdAt":  "2020-11-03T14:24:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hrrrrustic",
                                           "body":  "Yep, you\u0027re right, this is the base propose idea\r\nAs I said, I\u0027m not sure about other overloads because an argument order will be mixed up (for other overloads we need to add new method with `params`, replacing is not safe, I think) . If it\u0027s not a problem that some overloads will be with `WaitHandle[]` on the first place and some with on the last (\u0027params\u0027 versions), it may be useful too\r\n```C#\r\npublic static bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout);\r\npublic static bool WaitAll(TimeSpan timeout, params WaitHandle[] waitHandles);\r\n```",
                                           "updatedAt":  "2020-11-03T14:28:16Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Add WaitHandle.Wait(Any/All) overloads with params WaitHandle[] argument",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/44181",
        "createdAt":  "2020-11-03T02:56:40Z",
        "number":  44181,
        "author":  "hrrrrustic",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-07-06T05:17:40Z",
        "body":  "## Background and Motivation\r\nSince calls from all overloads of those methods comes to [this private method](https://source.dot.net/#System.Private.CoreLib/WaitHandle.cs,251) which takes ReadOnlySpan\u003cWaitHandle\u003e, it may be useful to add **public** overloads with ReadOnlySpans (for example to use with ```stackalloc```)\r\n\r\n## Proposed API\r\n\r\n```C#\r\npublic static bool WaitAll(ReadOnlySpan\u003cWaitHandle\u003e waitHandles, int millisecondsTimeout);\r\npublic static bool WaitAll(ReadOnlySpan\u003cWaitHandle\u003e waitHandles, TimeSpan timeout);\r\npublic static bool WaitAll(ReadOnlySpan\u003cWaitHandle\u003e waitHandles);\r\npublic static bool WaitAll(ReadOnlySpan\u003cWaitHandle\u003e waitHandles, int millisecondsTimeout, bool exitContext);\r\npublic static bool WaitAll(ReadOnlySpan\u003cWaitHandle\u003e waitHandles, TimeSpan timeout, bool exitContext);\r\n\r\npublic static int WaitAny(ReadOnlySpan\u003cWaitHandle\u003e waitHandles, int millisecondsTimeout);\r\npublic static int WaitAny(ReadOnlySpan\u003cWaitHandle\u003e waitHandles, TimeSpan timeout);\r\npublic static int WaitAny(ReadOnlySpan\u003cWaitHandle\u003e waitHandles);\r\npublic static int WaitAny(ReadOnlySpan\u003cWaitHandle\u003e waitHandles, int millisecondsTimeout, bool exitContext);\r\npublic static int WaitAny(ReadOnlySpan\u003cWaitHandle\u003e waitHandles, TimeSpan timeout, bool exitContext);\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOKvt1pg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMDk0MzE0NA==",
                                           "createdAt":  "2020-11-03T07:04:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "svick",
                                           "body":  "* Are the overloads taking `int` timeout necessary?\r\n* Could the number of overloads be decreased by using optional parameters?\r\n",
                                           "updatedAt":  "2020-11-03T07:04:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMTEyMjcyNg==",
                                           "createdAt":  "2020-11-03T13:42:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hrrrrustic",
                                           "body":  "- No, I don\u0027t think so. As I see [here](https://github.com/dotnet/runtime/issues/14336), `TimeSpan` version is more prior. Just copied overloads from existing ones :)\r\n- Yeah, it would be great, but it seems like it\u0027s possible only for `int` overloads. Timeout default value is **-1** everywhere, but we can\u0027t use `TimeSpan` as constant for optional parameter.\r\n\r\nSo, we will get **6** proposed overloads in case of removing `int` overloads, and **8** overloads in case of using optional parameters for `int timeout`, but it\u0027s also possible to reduce existing overloads number this way safely\r\n\r\nBtw have no idea about `bool exitContext` argument and its usage",
                                           "updatedAt":  "2020-11-03T14:05:48Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Add overloads for WaitHandle.Wait(Any/All) with ReadOnlySpan\u003cWaitHandle\u003e",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/44407",
        "createdAt":  "2020-11-09T13:29:13Z",
        "number":  44407,
        "author":  "WizardBrony",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOBWJaDg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Joe4evr",
                                            "createdAt":  "2020-11-09T14:04:53Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2022-07-19T15:30:04Z",
        "body":  "When the native timer for a `TimerQueue` fires, the callback sweeps the timers to see which have expired. It does this by first taking a snapshot of the current ticks:\r\n\r\nhttps://github.com/dotnet/runtime/blob/c871e237b00d3f07f76b370c194ae9430137a5d7/src/libraries/System.Private.CoreLib/src/System/Threading/Timer.cs#L135\r\n\r\nIt then uses that value when processing the timers and finally scheduling the native timer again:\r\n\r\nhttps://github.com/dotnet/runtime/blob/c871e237b00d3f07f76b370c194ae9430137a5d7/src/libraries/System.Private.CoreLib/src/System/Threading/Timer.cs#L153-L154\r\n\r\nhttps://github.com/dotnet/runtime/blob/c871e237b00d3f07f76b370c194ae9430137a5d7/src/libraries/System.Private.CoreLib/src/System/Threading/Timer.cs#L216-L220\r\n\r\nhttps://github.com/dotnet/runtime/blob/c871e237b00d3f07f76b370c194ae9430137a5d7/src/libraries/System.Private.CoreLib/src/System/Threading/Timer.cs#L267-L270\r\n\r\nHowever, this assumes that sweeping through the timers takes a negligible amount of time, which for an application with lots and lots of timers may not be the case. It would be more accurate to take another snapshot of the current ticks when re-scheduling the native timer, something to the effect of:\r\n\r\n```c#\r\nEnsureTimerFiresBy(Math.Max(nextTimerDuration - (uint) (TickCount64 - nowTicks), 1));\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOKyftGg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyNDAzNjg5MA==",
                                           "createdAt":  "2020-11-09T14:10:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Joe4evr",
                                           "body":  "I\u0027ve encountered this myself even without \"lots and lots of timers\", just having one or two timers in a process that is continuously on for several days/weeks starts showing a bit of noticeable drift.",
                                           "updatedAt":  "2020-11-09T14:10:50Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Threading.Timer: timer drift",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/44449",
        "createdAt":  "2020-11-10T07:55:59Z",
        "number":  44449,
        "author":  "Rodrigo-Andrade",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOBoWqhg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "phillijw",
                                            "createdAt":  "2021-04-23T14:21:10Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2022-07-19T15:31:29Z",
        "body":  "This is more like a loose question, feel free to close it if its too off-topic.\r\n\r\nFor sometime i always see `System.Threading.ThreadPoolWorkQueue.EnsureThreadRequested()` as a hotspot when profiling my code (a reverse proxy, we do plan to move to YARP once its more mature). \r\n\r\nIts always something like:\r\n\r\n![image](https://user-images.githubusercontent.com/1174384/98645039-23ae3380-2310-11eb-986f-26219cd08c6b.png)\r\n\r\nI see this on a 8 core VM, both in Windows and Linux. No thread starvation or something of the sort. \r\nSince that method seems to call to native code, i have no clue to why this overhead is so big.\r\n\r\nAnything on the matter will as always will be greatly appreciated. \r\n\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOLT7--A==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyNDYyNjMxMA==",
                                           "createdAt":  "2020-11-10T10:54:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "Most likely unrelated, but I noticed that `EnsureThreadRequested` has a few minor codegen issues, here is a simplified repro:\r\n```csharp\r\nprivate int field;\r\n\r\nbool EnsureThreadRequested(int count)\r\n{\r\n    int prev = Interlocked.CompareExchange(ref field, count + 1, count);\r\n    return prev == count;\r\n}\r\n```\r\nCurrent codegen (RyuJIT, Windows x64):\r\n```asm\r\ncmp      dword ptr [rcx], ecx  ; \u003c-- redundant nullcheck, see #44087\r\nadd      rcx, 8\r\nlea      r8d, [rdx+1]\r\nmov      eax, edx\r\nlock     \r\ncmpxchg  dword ptr [rcx], r8d ; \u003c-- cmpxchg modifes EFLAGS so we can get rid of the following cmp\r\ncmp      eax, edx\r\nsete     al\r\nmovzx    rax, al\r\nret \r\n```\r\nCodegen on Mono-LLVM (Linux x64 ABI, AT\u0026T):\r\n```asm\r\npush   %rax\r\nmov    %esi,%eax\r\nlea    0x1(%rax),%ecx\r\nlock cmpxchg %ecx,0x10(%rdi)\r\nsete   %al\r\npop    %rcx\r\nretq\r\n```",
                                           "updatedAt":  "2020-11-10T17:21:20Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyNjI2OTUyNg==",
                                           "createdAt":  "2020-11-12T18:50:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "fyi @kouvel ",
                                           "updatedAt":  "2020-11-12T18:50:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyNjkzNzcwOQ==",
                                           "createdAt":  "2020-11-13T18:19:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBY8q3A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "davidfowl",
                                                                               "createdAt":  "2020-12-04T16:18:46Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "kouvel",
                                           "body":  "In short bursty workloads the thread pool currently releases too many threads too quickly. It\u0027s a known issue, fixing it would involve some tradeoffs but probably would be a better tradeoff. I\u0027m hoping to look into this for .NET 6.",
                                           "updatedAt":  "2020-11-13T18:19:34Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyNzE0MTQyMA==",
                                           "createdAt":  "2020-11-14T04:15:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Rodrigo-Andrade",
                                           "body":  "@kouvel any workarounds for now?",
                                           "updatedAt":  "2020-11-14T04:15:36Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyODU5MjIwMg==",
                                           "createdAt":  "2020-11-17T01:09:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "Are you seeing this in 3.1 or 5? In .NET 5 there has been some improvement to time spent there in async socket operations, though it doesn\u0027t fix the root cause. I\u0027m not aware of any other workarounds that would reduce the CPU time there.",
                                           "updatedAt":  "2020-11-17T01:09:20Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyODgxOTM2NQ==",
                                           "createdAt":  "2020-11-17T09:56:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Rodrigo-Andrade",
                                           "body":  "\u003e Are you seeing this in 3.1 or 5?\r\n\r\nIts dotnet5. \r\n\r\nUsing `DOTNET_SYSTEM_NET_SOCKETS_INLINE_COMPLETIONS` envvar and `UnsafePreferInlineScheduling` on kestrel transport greatly alleviated this (doubled the app performance). I guess its because this makes the app enqueue on the thread pool much  less. But its a bit surprising this overhead has such a great impact (on my app at least).",
                                           "updatedAt":  "2020-11-17T09:56:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyOTA0MTc1Mg==",
                                           "createdAt":  "2020-11-17T16:25:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "I see, yea that would probably use the thread pool a lot less. The overhead probably means that the thread pool queue is remaining a relatively short length such that the active worker thread count remains below the processor count, and since the thread pool awakens more threads currently, it ends up taking the slower path to wake up a thread more frequently. The fix I have in mind would reduce that overhead but it wouldn\u0027t eliminate it.\r\n\r\nAre you seeing better performance with those config options too, or is it just a CPU time issue?",
                                           "updatedAt":  "2020-11-17T16:25:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyOTQ3ODIxMg==",
                                           "createdAt":  "2020-11-18T07:01:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Rodrigo-Andrade",
                                           "body":  "When using dotnet-counters, the thread count on the pool was a stable 8 (on a 8 vcore machine), seldom going to 9. Unless the threads would go up and down so fast that the counter was no picking this up.\r\n\r\n\u003e Are you seeing better performance with those config options too, or is it just a CPU time issue?\r\n\r\nIt doubled throughput, I am running with less than half machines now.\r\n\r\nI had some stalling issues, but I will probably report this on another issue.",
                                           "updatedAt":  "2020-11-18T07:01:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyOTczNjQ2MQ==",
                                           "createdAt":  "2020-11-18T15:01:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "The thread count in counters is just the number of threads that have been created, there may be fewer that are active on average.\r\n\r\n\u003e It doubled throughput, I am running with less than half machines now.\r\n\r\nI see. I\u0027m curious how close the prototype fix would get. Would you be able to try out a prototype fix? If so I can send you a patched runtime and some instructions on using it.",
                                           "updatedAt":  "2020-11-18T15:01:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyOTkwNTgyOA==",
                                           "createdAt":  "2020-11-18T19:32:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Rodrigo-Andrade",
                                           "body":  "Sure!",
                                           "updatedAt":  "2020-11-18T19:32:40Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyOTkwNzQwOA==",
                                           "createdAt":  "2020-11-18T19:35:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "Which OS would you prefer for testing it?",
                                           "updatedAt":  "2020-11-18T19:35:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyOTkwODI5OA==",
                                           "createdAt":  "2020-11-18T19:37:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBYNB4A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "Rodrigo-Andrade",
                                                                               "createdAt":  "2020-11-27T15:31:34Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "kouvel",
                                           "body":  "Btw `DOTNET_SYSTEM_NET_SOCKETS_INLINE_COMPLETIONS` is only applicable to non-Windows platforms. I believe `UnsafePreferInlineScheduling` would work on Windows too, but I\u0027m guessing the results above were on Linux.",
                                           "updatedAt":  "2020-11-18T19:37:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyOTk3NDY1Mg==",
                                           "createdAt":  "2020-11-18T21:43:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Rodrigo-Andrade",
                                           "body":  "its running on amazon linux on a docker container using the mcr.microsoft.com/dotnet/aspnet:5.0.0 image",
                                           "updatedAt":  "2020-11-18T21:43:20Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczODEwNTE2NA==",
                                           "createdAt":  "2020-12-03T16:04:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Rodrigo-Andrade",
                                           "body":  "@kouvel as we are moving more apps to net5.0 the overhead is even more pronounced (i guess the changes to `SocketAsyncEngine` is to blame) making the move from 3.1 to 5 yield no performance improvements, unless we use the inline options, but those are dangerous, so we can\u0027t enable them on all our apps. \r\n\r\nLooks like the main problem is the fact that we run our apps alone (no other apps on the VM) with low cpu (15-25%). When we inline everything on the `SocketAsyncEngine`, the performance skyrockets.\r\n\r\nMaybe an easy fix was to be able to specify the minimum thread number? Since its one app per VM, having the minimum of one  thread per core would be more efficient (i know that even then, less threads would be better for cache locality, but the overhead of waking up the threads offsets this by a big margin)",
                                           "updatedAt":  "2020-12-03T16:07:55Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczODI3MTk2Mg==",
                                           "createdAt":  "2020-12-03T19:56:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "I\u0027m about to build a prototype fix for you to try (sorry for the delay), couple of questions about that:\r\n- Which processor architecture are you using, x64/arm/arm64?\r\n- For the app are you using a self-contained publish, or using the shared framework from the container image?\r\n\r\nDid I understand correctly that the overhead has increased but the perf has not regressed (or improved) in 5.0 compared to 3.1?\r\n\r\n\u003e we run our apps alone (no other apps on the VM) with low cpu (15-25%)\r\n\u003e Maybe an easy fix was to be able to specify the minimum thread number?\r\n\r\nI see. How many procs are assigned to the VM/container? It\u0027s possible to configure the thread pool\u0027s min worker thread count to lower than the proc count. Set the following env vars before starting the app in the same shell:\r\n\r\n```bash\r\nexport COMPlus_ThreadPool_ForceMinWorkerThreads=1\r\nexport COMPlus_HillClimbing_Disable=1\r\n```\r\n\r\nDisabling hill climbing as well since it doesn\u0027t work very well at low thread counts at the moment. Also if it matters note that the thread count specified above is treated as hexadecimal.",
                                           "updatedAt":  "2020-12-03T19:57:20Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczODMzNDk3MQ==",
                                           "createdAt":  "2020-12-03T21:38:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Rodrigo-Andrade",
                                           "body":  "`Which processor architecture are you using, x64/arm/arm64?`\r\n\r\nx64\r\n\r\n`For the app are you using a self-contained publish, or using the shared framework from the container image?`\r\n\r\nshared framework from the container image\r\n\r\n`Did I understand correctly that the overhead has increased but the perf has not regressed (or improved) in 5.0 compared to 3.1?`\r\n\r\nFor cpu intensive apps it\u0027s about the same, for IO intensive, its worse. \r\n\r\n`How many procs are assigned to the VM/container?`\r\n\r\nJust the dotnet process\r\n\r\n`It\u0027s possible to configure the thread pool\u0027s min worker thread count to lower than the proc count.`\r\nVery nice! I\u0027ll try those new settings.\r\n",
                                           "updatedAt":  "2020-12-03T21:38:14Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczODMzNjIwMg==",
                                           "createdAt":  "2020-12-03T21:40:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "Thanks @Rodrigo-Andrade,\r\n\r\n\u003e How many procs are assigned to the VM/container?\r\n\r\nI meant how many processors are assigned to the VM/container? Wondering if it is already limited to a few processors or if it has several available and only the CPU utilization is limited.",
                                           "updatedAt":  "2020-12-03T21:40:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczODMzODI4Mw==",
                                           "createdAt":  "2020-12-03T21:45:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Rodrigo-Andrade",
                                           "body":  "8 vcpus",
                                           "updatedAt":  "2020-12-03T21:45:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczODQ2OTIyMA==",
                                           "createdAt":  "2020-12-04T00:24:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "Here is a link to a patched System.Private.CoreLib.dll with a prototype fix: [RequestFewerThreads50](https://1drv.ms/u/s!AvtRwG9CobRTgvlpRmJpI5_SwQZyGw?e=PH7zok)\r\n\r\nTo try it out, since you\u0027re using a container it probably would be easiest to temporarily replace that file in the shared framework in a temporary modification of the image. Find the path to `dotnet` in the container image, the original file should be in `\u003cpathToDotnet\u003e/shared/Microsoft.NETCore.App/5.0.0`. Replace that file and try out your scenarios. Also make sure to revert the changes to restore the original container image, since this is just a locally built patch and would not be supported.\r\n\r\nYou can try with and without the config vars above, though the prototype fix may not help much with the above config vars set. I\u0027m hoping to at least see some reduction in the overhead in and under `EnsureThreadRequested`, not sure if perf would also increase though. Let me know!",
                                           "updatedAt":  "2020-12-04T00:24:43Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczODg1Mjg3Mg==",
                                           "createdAt":  "2020-12-04T15:39:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Rodrigo-Andrade",
                                           "body":  "I\u0027ll play with it this weekend, thank you!",
                                           "updatedAt":  "2020-12-04T15:39:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MDExNzk1Nw==",
                                           "createdAt":  "2020-12-07T19:05:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Rodrigo-Andrade",
                                           "body":  "@kouvel just a preliminary result:\r\n![image](https://user-images.githubusercontent.com/1174384/101392758-e2745980-38a4-11eb-93b0-76fc0e57806c.png)\r\n\r\nThe orange line is the current app, dotnet 5 **not patched** using `DOTNET_SYSTEM_NET_SOCKETS_INLINE_COMPLETIONS` and kestrel `DangerousInlinePipeScheduling` which avoids most `ThreadPool ` usage (15%-18% cpu usage).\r\n\r\nThe blue line is the experiment.\r\nThe first mound is **your patch** without any parameters (40%-44% cpu usage). \r\nThe second mound is **not patched** without any parameters (stable in 50% cpu usage).\r\n\r\nThey all have the same request/s.\r\n\r\nSo it\u0027s an improvement.\r\n\r\nI\u0027ll try to get some traces soon.\r\n\r\n",
                                           "updatedAt":  "2020-12-07T19:07:26Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MDkyODA4MA==",
                                           "createdAt":  "2020-12-08T19:47:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "Thanks @Rodrigo-Andrade! It\u0027s a bit difficult to compare the blue to the orange line because the work done is a fair bit different, as the inline-completions mode bypasses pipelining and a bunch of other work that makes it unreliable, so there\u0027s more work being done in the blue line. Still though, it looks like there is room for improvement, curious to see how much the overhead under `EnsureThreadRequested` has decreased with the patch.\r\n\r\nMight also want to try with `export COMPlus_HillClimbing_Disable=1` and without configuring the worker thread counts. Hill climbing can add a lot of threads unnecessarily and frequently, oversaturating the container, disabling it might have a noticeable effect in CPU-limited cases.",
                                           "updatedAt":  "2020-12-08T19:48:36Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc1Nzk0OTgyMA==",
                                           "createdAt":  "2021-01-11T13:26:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Rodrigo-Andrade",
                                           "body":  "Sorry for taking so long.\r\n  \r\nTested COMPlus_HillClimbing_Disable and it did not make a difference.\r\n\r\nHere is some numbers that i got:\r\n\r\n![image](https://user-images.githubusercontent.com/1174384/104188126-85b21480-53f7-11eb-876f-b7247ec57021.png)\r\n\r\npatched:\r\n![image](https://user-images.githubusercontent.com/1174384/104188380-ed685f80-53f7-11eb-9607-e8c68ce06b3f.png)\r\n\r\nThe impact in production is greater then this trace suggests.",
                                           "updatedAt":  "2021-01-11T13:30:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc1OTEwMzIyNA==",
                                           "createdAt":  "2021-01-12T23:31:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "Thanks @Rodrigo-Andrade. Since after the patch `RequestWorkerThread` would typically only be called 2 times per batch of work, it looks like the workload is very bursty with short bursts and probably the additional path length of going through the thread pool and pipelining is significant relative to the other work being done. There may be ways to optimize those paths better, especially for CPU-constrained systems but that would probably be investigation for 6.0.",
                                           "updatedAt":  "2021-01-12T23:32:13Z"
                                       }
                                   ],
                         "totalCount":  24
                     },
        "title":  "System.Threading.ThreadPoolWorkQueue.EnsureThreadRequested() hotspot",
        "labels":  [
                       "area-System.Threading",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/45585",
        "createdAt":  "2020-12-04T07:27:06Z",
        "number":  45585,
        "author":  "shravan2x",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-07-21T02:20:55Z",
        "body":  "\u003c!--This is just a template - feel free to delete any and all of it and replace as appropriate.--\u003e\r\n\r\n### Description\r\n\r\nI have a program that runs a set task every x seconds. After the delay, a verification check is performed that _at least_ x seconds have passed. However, it appears that sometimes the `Task.Delay` method returns sooner than x. I tested this using code similar to the snippet below. The amount it\u0027s off by is usually small, around 1-4ms rarely 5ms.\r\n\r\n```\r\nStopwatch sw = Stopwatch.StartNew();\r\nawait Task.Delay(delay, cancellationToken);\r\nif (sw.ElapsedMilliseconds \u003c delay)\r\n    Console.WriteLine(\"delay wrong \" + (delay - sw.ElapsedMilliseconds));\r\n```\r\n\r\nTo be clear, I have no issue with the method taking _more_ time than I schedule it for, as I know there will always be overhead due to context switching etc. However, I don\u0027t think the right behavior for this method is to ever return _sooner_ than the set time.\r\n\r\n### Configuration\r\n\r\n* Which version of .NET is the code running on? .NET Core 3.1\r\n* What OS and version, and what distro if applicable? Ubuntu 18.04\r\n* What is the architecture (x64, x86, ARM, ARM64)? x64 (Intel processor from ~2013 under low load)\r\n* Do you know whether it is specific to that configuration? No\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOLAxOeA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczODYxNzI1Nw==",
                                           "createdAt":  "2020-12-04T07:27:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @tarekgh\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n\u003c!--This is just a template - feel free to delete any and all of it and replace as appropriate.--\u003e\r\n\r\n### Description\r\n\r\nI have a program that runs a set task every x seconds. After the delay, a verification check is performed that _at least_ x seconds have passed. However, it appears that sometimes the `Task.Delay` method returns sooner than x. I tested this using code similar to the snippet below. The amount it\u0027s off by is usually small, around 1-4ms rarely 5ms.\r\n\r\n```\r\nStopwatch sw = Stopwatch.StartNew();\r\nawait Task.Delay(delay, cancellationToken);\r\nif (sw.ElapsedMilliseconds \u003c delay)\r\n    Console.WriteLine(\"delay wrong \" + (delay - sw.ElapsedMilliseconds));\r\n```\r\n\r\nTo be clear, I have no issue with the method taking _more_ time than I schedule it for, as I know there will always be overhead due to context switching etc. However, I don\u0027t think the right behavior for this method is to ever return _sooner_ than the set time.\r\n\r\n### Configuration\r\n\r\n* Which version of .NET is the code running on? .NET Core 3.1\r\n* What OS and version, and what distro if applicable? Ubuntu 18.04\r\n* What is the architecture (x64, x86, ARM, ARM64)? x64\r\n* Do you know whether it is specific to that configuration? No\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eshravan2x\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading.Tasks`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2020-12-04T07:27:09Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczODk2Nzk1OA==",
                                           "createdAt":  "2020-12-04T19:17:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tarekgh",
                                           "body":  "CC @stephentoub ",
                                           "updatedAt":  "2020-12-04T19:17:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczODk3NjExMg==",
                                           "createdAt":  "2020-12-04T19:34:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "This is extremely unlikely to be specific to Task.Delay, rather Timer. And Timer uses Environment.TickCount64 rather than Stopwatch, with the former not having the same precision as the latter (TickCount\u0027s precision is ~15ms on Windows).  I expect if you tested with TickCount instead you wouldn\u0027t see such a discrepancy. ",
                                           "updatedAt":  "2020-12-04T20:02:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczOTAwNDAyNA==",
                                           "createdAt":  "2020-12-04T20:32:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "shravan2x",
                                           "body":  "@stephentoub Oh interesting, though this was tested on Linux. Do you know what the precision there is?\r\n\r\nAnd if we know such a precision loss is possible, could our use of Timer be updated to always round _up_ to the next 15ms mark?",
                                           "updatedAt":  "2020-12-04T20:32:11Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Task.Delay sometimes returns sooner than delay",
        "labels":  [
                       "question",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/45828",
        "createdAt":  "2020-12-09T10:45:00Z",
        "number":  45828,
        "author":  "drewnoakes",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-03-12T23:53:13Z",
        "body":  "Today I came across a property getter which was implemented as:\r\n\r\n```c#\r\nget\r\n{\r\n    return Interlocked.CompareExchange(ref this.someField, this.someField, null);\r\n}\r\n```\r\n\r\nI can\u0027t think of a valid scenario where the `location` argument (first) should also be read for the `value` field.\r\n\r\nThis seems to be asking for trouble, as the read of the field for the second argument races with the cmpxchg.\r\n\r\nMy guess is that the author wanted to achieve what `Volatile.Read` offers.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOLGhknw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MjcxNzQzOQ==",
                                           "createdAt":  "2020-12-10T18:43:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xtqqczze",
                                           "body":  "@drewnoakes Perhaps the author wanted to be consistent by using the same synchronization primitive as elsewhere, and needed the latest value of `someField`;\r\n\r\nNevertheless, the code should probably have been written like this:\r\n\r\n```csharp\r\nget\r\n{\r\n    return Interlocked.CompareExchange(ref this.someField, null, null);\r\n}\r\n```",
                                           "updatedAt":  "2020-12-10T18:43:50Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MzE2Nzk3MQ==",
                                           "createdAt":  "2020-12-11T12:34:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "drewnoakes",
                                           "body":  "I believe the intention was to return the value of the field, rather than swap it out for null. Perhaps a codefix isn\u0027t possible here, but I do think the pattern looks suspicious enough to warrant a diagnostic.",
                                           "updatedAt":  "2020-12-11T12:34:26Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MzIwMjY5Ng==",
                                           "createdAt":  "2020-12-11T13:49:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xtqqczze",
                                           "body":  "\u003e\u003e ```csharp\r\n\u003e\u003e get\r\n\u003e\u003e {\r\n\u003e\u003e     return Interlocked.CompareExchange(ref this.someField, null, null);\r\n\u003e\u003e }\r\n\u003e\u003e ```\r\n\r\n\r\n\u003e I believe the intention was to return the value of the field, rather than swap it out for null. Perhaps a codefix isn\u0027t possible here, but I do think the pattern looks suspicious enough to warrant a diagnostic.\r\n\r\n@drewnoakes In the case that `someField` is `null`, `CompareExchange` will compare `someField` to `null`, succeed, and replace it with `null`, and return `null`. Therefore the value of `someField` is not modified.\r\n\r\nOn 32 bit platforms `Volatile.Read(Int64)` is implemented using this pattern:\r\n\r\nhttps://github.com/dotnet/runtime/blob/574e6259ab0d26cf97c0eca07c8b08948018b07b/src/libraries/System.Private.CoreLib/src/System/Threading/Volatile.cs#L91-L97\r\n",
                                           "updatedAt":  "2020-12-11T13:49:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0NTAzOTAwNw==",
                                           "createdAt":  "2020-12-15T04:08:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "drewnoakes",
                                           "body":  "\u003e In the case that someField is null, CompareExchange will compare someField to null, succeed, and replace it with null, and return null. Therefore the value of someField is not modified.\r\n\r\nYes, and perhaps this could be a second diagnostic. There are two cases which don\u0027t make any sense to me:\r\n\r\n1. `Interlocked.CompareExchange(ref F, F, A);` \u0026mdash; the original scenario\r\n1. `Interlocked.CompareExchange(ref F, A, A);` \u0026mdash; the scenario you have highlighted\r\n\r\n\u003e On 32 bit platforms Volatile.Read(Int64) is implemented using this pattern:\r\n\r\nThat\u0027s only true for `long` which is a 64 bit value, and would be subject to tearing.\r\n\r\n\r\n\r\n",
                                           "updatedAt":  "2020-12-15T04:08:36Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Add analyzer: Interlocked.CompareExchange when \"value\" argument is read from \"location\" argument",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading",
                       "code-analyzer"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/46077",
        "createdAt":  "2020-12-15T16:34:48Z",
        "number":  46077,
        "author":  "kevingosse",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-07-19T15:27:49Z",
        "body":  "I ran into a weird performance issue where having one idle threadpool thread impacted significantly the throughput of the application.\r\n\r\nThe minimum repro is a simple ASP.NET Core MVC app (`dotnet new mvc`) running on a 2 cores instance (Amazon c5.large). When load-testing the `/home` endpoint with enough traffic to overload the server, I get the following results:\r\n - Average CPU usage: 98%\r\n - Request Rate (Count / 10 sec): ~110,000\r\n - ThreadPool Thread Count: oscillates between 2 and 3\r\n\r\nNow if I modify the application and use one threadpool worker for some idle work:\r\n\r\n```csharp\r\n\r\npublic class Startup\r\n{\r\n        // ...\r\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\r\n        {\r\n            // ...\r\n            Task.Run(() =\u003e DoStuff());\r\n        }\r\n\r\n        private static void DoStuff()\r\n        {\r\n                while (true) { System.Threading.Thread.Sleep(10000); }\r\n        }\r\n}\r\n```\r\n\r\nI then get the following results:\r\n - Average CPU usage: 75%\r\n - Request Rate (Count / 10 sec): ~99,000\r\n - ThreadPool Thread Count: oscillates between 2 and 3\r\n\r\nThe size of the threadpool didn\u0027t change despite the wasted worker, and now the server is unable to fully use the CPU to process the requests.\r\n\r\nI know that long-running work shouldn\u0027t be pushed to the threadpool, but that\u0027s a common mistake and I was expecting the number of workers to be adjusted accordingly.\r\n\r\nMetrics are measured using dotnet-counters: `dotnet-counters monitor System.Runtime Microsoft.AspNetCore.Hosting --refresh-interval 10 -p 23328`\r\n\r\nI initially ran into this with .NET Core 3.1.9, but could reproduce with .NET 5.0.1.\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOLIHKLQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0NTQ2NDg3MA==",
                                           "createdAt":  "2020-12-15T18:03:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "/cc @kouvel ",
                                           "updatedAt":  "2020-12-15T18:03:25Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0NTQ3ODMzNw==",
                                           "createdAt":  "2020-12-15T18:27:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCIrb5Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "freddyrios",
                                                                               "createdAt":  "2022-01-05T15:32:40Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "kouvel",
                                           "body":  "An issue I\u0027m aware of in CPU-limited environments is that hill climbing does not work very well in low-thread-count situations, and can be more intrusive than helpful. It can be disabled by starting the process with environment variable `COMPlus_HillClimbing_Disable=1`.  Using up a thread pool thread for long-running work in a CPU-limited environment can have more dire consequences since there are few threads available to begin with, and with hill climbing disabled it could be a bit worse. For instance, in the specific case above with hill climbing disabled since 1 of the 2 worker threads are blocked, only one would be performing work, and it may also prevent the starvation heuristic from kicking in (which checks every 500 ms for whether all thread pool threads are stuck). However, in practice that is relatively rare, if one worker thread gets blocked frequently usually all will fairly quickly. Can you try disabling hill climbing with and without the long-running work item and see how the perf changes?",
                                           "updatedAt":  "2020-12-15T18:27:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0NjEzNjY2MA==",
                                           "createdAt":  "2020-12-16T11:23:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kevingosse",
                                           "body":  "`COMPlus_HillClimbing_Disable=1` makes it worse, which is somewhat consistent with your analysis. \r\n\r\nWith the idle thread and hill climbing disabled, CPU is at 50% and the server processes 84,000 requests per 10 second (down from 99,000 requests with hill climbing). Without the idle thread, CPU is at 98% and the server processes 105,000 requests per 10 seconds (down from 110,000 requests with hill climbing).  ",
                                           "updatedAt":  "2020-12-16T11:23:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0NjcwMzQwNQ==",
                                           "createdAt":  "2020-12-16T17:40:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "Sounds like hill climbing is not compensating for the blocked thread (at least soon enough). I\u0027ll try to get a repro. It should be possible and perhaps better to have the starvation heuristic track starvation on a per-thread basis rather than for the whole pool of worker threads.",
                                           "updatedAt":  "2020-12-16T17:40:13Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Threadpool doesn\u0027t scale optimally at low thread count",
        "labels":  [
                       "area-System.Threading",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/47631",
        "createdAt":  "2021-01-29T15:26:02Z",
        "number":  47631,
        "author":  "stephentoub",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCqSV_A==",
                          "nodes":  [
                                        {
                                            "content":  "HEART",
                                            "user":  "jkotas",
                                            "createdAt":  "2021-01-29T16:24:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jkotas",
                                            "createdAt":  "2021-01-29T16:24:19Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "D3-LucaPiombino",
                                            "createdAt":  "2021-01-30T23:35:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "geoffkizer",
                                            "createdAt":  "2021-02-10T22:21:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2022-08-25T11:16:35Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2022-08-25T11:16:46Z"
                                        }
                                    ],
                          "totalCount":  6
                      },
        "updatedAt":  "2022-08-12T19:37:53Z",
        "body":  "We should investigate / experiment with moving SocketAsyncEngine down to be integrated with the ThreadPool.  Today all of our logic for efficiently waiting on file descriptors (and specifically sockets) via epoll/kqueues is available only through System.Net.Sockets, and handles its own thread management.  We should explore some kind of `ThreadPool.RegisterFileDescriptorForPolling(IntPtr fd, Action\u003cobject\u003e callback, object state)` Unix-specific API that would enable:\r\n- other I/O-related APIs to utilize this waiting support, without needing an artificial dependency on Socket to do so\r\n- the ThreadPool to manage the threads utilized by SocketAsyncEngine today, hopefully more efficiently and _potentially_ avoiding some of the thread hopping we incur today\r\n\r\n(I thought we already had an issue for this, but I can\u0027t find it; someone please feel free to close this as a dup if you find it :)\r\n\r\ncc: @geoffkizer, @kouvel, @jkotas, @davidfowl ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOLlQB0g==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2OTk3MjQzOA==",
                                           "createdAt":  "2021-01-29T18:27:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "Is the proposal missing an `IntPtr` in the callback as the first argument?\r\n\r\n```C#\r\nThreadPool.RegisterFileDescriptorForPolling(IntPtr fd, Action\u003cIntPtr, object\u003e callback, object state)\r\n```\r\n\r\nI think this could also be used for windows IOCP. I wonder if we need to support more than an IntPtr so that we can potentially change the implementation behavior based on the type.\r\n",
                                           "updatedAt":  "2021-01-29T18:27:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2OTk3NTAyMw==",
                                           "createdAt":  "2021-01-29T18:32:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Is the proposal missing an IntPtr in the callback as the first argument?\r\n\r\nI expect it\u0027s missing a bunch of things ;-)",
                                           "updatedAt":  "2021-01-29T18:32:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3MTcxNDgzOA==",
                                           "createdAt":  "2021-02-02T15:27:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "My only concern is that `epoll` does not support regular disk files, so this solution can\u0027t be reused for all kinds of streams.\r\n\r\nI wonder whether we should revisit using `io_uring` again and adapt `ThreadPool` to work with `io_uring` instead. It has the obvious downside of being Linux-specific and supported only by new kernels, but might be more future-proof (it seems that `io_uring` might finally become the async IO done right on Linux).",
                                           "updatedAt":  "2021-02-02T15:27:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3MTcyODk3NA==",
                                           "createdAt":  "2021-02-02T15:46:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "I think we this API should work for both windows and linux and should basically abstract this async IO model for all operating systems. ",
                                           "updatedAt":  "2021-02-02T15:46:25Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3MTc0OTIzMA==",
                                           "createdAt":  "2021-02-02T16:12:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBelGWw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "adamsitnik",
                                                                               "createdAt":  "2021-02-02T17:05:41Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tmds",
                                           "body":  "`SocketAsyncEngine` deals with more than polling. It keeps track of multiple async reads/write that are performed against a `SafeHandle` and executes them in order. It also supports aborting all on-going operations when the `SafeHandle` gets disposed.\r\n\r\nThis requires per `SafeHandle` bookkeeping of on-going async operations.",
                                           "updatedAt":  "2021-02-02T16:12:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3MjgwMDAzOQ==",
                                           "createdAt":  "2021-02-03T20:27:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "\u003e I think we this API should work for both windows and linux and should basically abstract this async IO model for all operating systems.\r\n\r\nI don\u0027t think this is the appropriate level at which to do something like this. The API semantics are quite different between epoll and IOCP; that\u0027s why we have all the `SocketAsyncContext` stuff.\r\n\r\nWe do have something of an IO abstraction in the Socket PAL. It\u0027s not very clean currently, but I think it\u0027s more in line with what you are asking for here.\r\n",
                                           "updatedAt":  "2021-02-03T20:27:01Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3MzA1NDYxNw==",
                                           "createdAt":  "2021-02-04T06:03:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "BTW, I\u0027m very much in favor of doing something like this. \r\n\r\nOne design issue to consider: Epoll (and kqueue) don\u0027t just signal general fd readiness; they specifically signal read readiness or write readiness (or both). And they also signal EOF for both. \r\n\r\nSo we either need a callback that indicates the specific readiness condition, or we need multiple callbacks for different conditions. My suggestion would be to have two callbacks, one for read and one for write, and allow each callback to also signal EOF.\r\n\r\nThere\u0027s some weirdness that exists in SocketAsyncEngine today around handle lifetime management. We should try to clean this up in any new API. I believe part of the problem here is determining when a fd will no longer generate readiness notifications and thus doesn\u0027t need to be tracked any more by the runtime. We should chat about the details here. ",
                                           "updatedAt":  "2021-02-04T06:03:25Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3NzI1NzQyNg==",
                                           "createdAt":  "2021-02-11T07:48:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e I wonder whether we should revisit using io_uring again and adapt ThreadPool to work with io_uring instead\r\n\r\n@adamsitnik we can look at io_uring separate from this issue. A poll readiness API can use io_uring as its backend, and we don\u0027t want to limit io_uring usage to polling.",
                                           "updatedAt":  "2021-02-11T07:48:22Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Investigate consolidating SocketAsyncEngine into ThreadPool",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/48807",
        "createdAt":  "2021-02-26T09:07:07Z",
        "number":  48807,
        "author":  "RemiGaudin",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-06-23T20:29:14Z",
        "body":  "### Description\r\n\r\nDuring the AssemblyLoadContext.Unloading event, if we call Thread.Join(Int32) whereas the thread has already terminated then Join is returning false instead of true.\r\n\r\nI reproduced this issue in this fiddle: https://dotnetfiddle.net/0fnpuk\r\n\r\n- In the first test: Join(Int32) is called **before** the Unloading call and is returning correctly **true**.\r\n- In the second test: Join(Int32) is called **after** the Unloading call and is now returning incorrectly **false**.\r\n\r\nYou can also see a further analysis of this issue in this stack overflow answer: https://stackoverflow.com/a/66379090/4924754\r\n\r\nIn this answer you can see two fiddles that show that Join(Int32) is returning false only if the thread terminated **after** the Unloading call (https://dotnetfiddle.net/RySwSv). If the thread terminated **before** the Unloading call then Join(Int32) returns correctly true even if Join is called **after** the Unloading call (https://dotnetfiddle.net/SzPuLW).\r\n\r\nAll these evidences lead me to think that this is indeed a .NET bug.\r\n\r\n### Configuration\r\n\r\nI was able to reproduce this issue on:\r\n- Docker Desktop v. 3.1.0 for Windows 10 using the docker image mcr.microsoft.com/dotnet/runtime:5.0 on Linux container.\r\n- Azure Kubernetes Service using Kubernetes 1.18.14, Linux Ubuntu 1804 and the docker image mcr.microsoft.com/dotnet/runtime:5.0.\r\n- .NET Fiddle (not sure about the architecture they\u0027re using).\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOLuE56A==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjUxMjM2MA==",
                                           "createdAt":  "2021-02-26T09:07:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-02-26T09:07:10Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Thread.Join(Int32) function called in AssemblyLoadContext.Unloading returns wrong value if the thread has already terminated (.NET 5 / Core)",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/49368",
        "createdAt":  "2021-03-09T09:51:34Z",
        "number":  49368,
        "author":  "anandcta123",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-07-19T15:21:09Z",
        "body":  "Trying to execute below code in .NET Core 2.1, getting issue as \"ThreadAbondonedException\". Please resolve, existing .NET migrated code will break.\r\n\r\n```C#     \r\nusing System;\r\n    using System.Threading;\r\n\r\n    class Program\r\n    {\r\n        // Create a new Mutex. The creating thread owns the Mutex.\r\n        private static Mutex mut = new Mutex(true);\r\n        private const int numIterations = 1;\r\n        private const int numThreads = 3;\r\n\r\n        static void Main()\r\n        {\r\n            try\r\n            {\r\n                Thread[] myThread = new Thread[Program.numThreads];\r\n                // Create the threads that will use the protected resource.\r\n                for (int i = 0; i \u003c numThreads; i++)\r\n                {\r\n                    myThread[i] = new Thread(new ThreadStart(MyThreadProc));\r\n                    myThread[i].Name = String.Format(\"Thread{0}\", i + 1);\r\n                    myThread[i].Start();\r\n                }\r\n\r\n                // Wait one second before allowing other threads to\r\n                // acquire the Mutex.\r\n                Console.WriteLine(\"Creating thread owns the Mutex.\");\r\n                Thread.Sleep(1000);\r\n\r\n                Console.WriteLine(\"Creating thread releases the Mutex.\\r\\n\");\r\n                mut.ReleaseMutex();\r\n\r\n                Console.ReadKey();\r\n            }\r\n            catch (AbandonedMutexException e)\r\n            {\r\n                Console.WriteLine(e.StackTrace);\r\n            }\r\n\r\n        }\r\n\r\n        private static void MyThreadProc()\r\n        {\r\n            for (int i = 0; i \u003c numIterations; i++)\r\n            {\r\n                UseResource();\r\n            }\r\n        }\r\n\r\n        // This method represents a resource that must be synchronized\r\n        // so that only one thread at a time can enter.\r\n        private static void UseResource()\r\n        {\r\n            try\r\n            {\r\n                // Wait until it is safe to enter.\r\n                mut.WaitOne();\r\n\r\n                Console.WriteLine(\"{0} has entered the protected area\",\r\n                    Thread.CurrentThread.Name);\r\n\r\n                // Place code to access non-reentrant resources here.\r\n\r\n                // Simulate some work.\r\n                Thread.Sleep(500);\r\n\r\n                Console.WriteLine(\"{0} is leaving the protected area\\r\\n\",\r\n                    Thread.CurrentThread.Name);\r\n\r\n                // Release the Mutex.\r\n                mut.ReleaseMutex();\r\n            }\r\n            catch (Exception e)\r\n            {\r\n                Console.WriteLine($\"Exception thrown in --\u003e {Thread.CurrentThread.Name}\");\r\n            }\r\n        }\r\n    }\r\n}\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHONB9O-A==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc5NDE3NzAyNA==",
                                           "createdAt":  "2021-03-09T17:10:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-03-09T17:10:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg3NDQ2NzA2NA==",
                                           "createdAt":  "2021-07-06T05:16:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "Hi @anandcta123,\r\n\r\nOn 3.1 I notice that there is an `System.Threading.AbandonedMutexException` thrown, not `ThreadAbondonedException` you note above. In .net core there is a possibility that static initialization is done lazily, so in your case not just the main thread, but any Thread could initialize the mutex. If you move the initialization to a static initializer the code should behave as expected. ",
                                           "updatedAt":  "2021-07-06T05:16:56Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Mutex with initial ownership not working.",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/49518",
        "createdAt":  "2021-03-12T01:20:32Z",
        "number":  49518,
        "author":  "CoffeeFlux",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-12T06:28:28Z",
        "body":  "This isn\u0027t particularly important for Mono since we don\u0027t have COM support, but would block CoreCLR from adopting `WaitHandle.Windows.cs`.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOw7wg1g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc7DvCDW",
                                           "createdAt":  "2025-09-12T06:28:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Due to lack of recent activity, this issue has been marked as a candidate for backlog cleanup.  It will be closed if no further activity occurs within 14 more days. Any new comment (by anyone, not necessarily the author) will undo this process.\n\nThis process is part of our [issue cleanup automation](https://github.com/dotnet/runtime/blob/main/docs/issue-cleanup.md).\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-09-12T06:28:27Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Support reentrant waits in managed WaitHandle implementation",
        "labels":  [
                       "area-System.Threading",
                       "runtime-mono",
                       "no-recent-activity",
                       "backlog-cleanup-candidate"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/50443",
        "createdAt":  "2021-03-30T19:36:01Z",
        "number":  50443,
        "author":  "akoeplinger",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-07-13T19:18:45Z",
        "body":  "`SystemNative_LowLevelMonitor_Wait()` and `SystemNative_LowLevelMonitor_TimedWait()` do not handle spurious wakeups from `pthread_cond_wait`, `pthread_cond_timedwait_relative_np` and `pthread_cond_timedwait`.\r\n\r\nAccording to the [man page](https://linux.die.net/man/3/pthread_cond_wait):\r\n\r\n\u003e When using condition variables there is always a Boolean predicate involving shared variables associated with each condition wait that is true if the thread should proceed. Spurious wakeups from the pthread_cond_timedwait() or pthread_cond_wait() functions may occur. Since the return from pthread_cond_timedwait() or pthread_cond_wait() does not imply anything about the value of this predicate, the predicate should be re-evaluated upon such return.\r\n\r\nWe need to add a loop, similar to what we do in CoreCLR here: https://github.com/dotnet/runtime/blob/79ae74f5ca5c8a6fe3a48935e85bd7374959c570/src/coreclr/gc/unix/events.cpp#L149-L190\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHORUlnBw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxMDUyNTM5MQ==",
                                           "createdAt":  "2021-03-30T19:36:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "akoeplinger",
                                           "body":  "/cc @CoffeeFlux ",
                                           "updatedAt":  "2021-03-30T19:36:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxMDUzMTIwNg==",
                                           "createdAt":  "2021-03-30T19:46:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "The spurious wakeups may be handled by the managed code that calls this already.",
                                           "updatedAt":  "2021-03-30T19:46:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DOVBQ",
                                           "createdAt":  "2022-05-16T15:39:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n`SystemNative_LowLevelMonitor_Wait()` and `SystemNative_LowLevelMonitor_TimedWait()` do not handle spurious wakeups from `pthread_cond_wait`, `pthread_cond_timedwait_relative_np` and `pthread_cond_timedwait`.\r\n\r\nAccording to the [man page](https://linux.die.net/man/3/pthread_cond_wait):\r\n\r\n\u003e When using condition variables there is always a Boolean predicate involving shared variables associated with each condition wait that is true if the thread should proceed. Spurious wakeups from the pthread_cond_timedwait() or pthread_cond_wait() functions may occur. Since the return from pthread_cond_timedwait() or pthread_cond_wait() does not imply anything about the value of this predicate, the predicate should be re-evaluated upon such return.\r\n\r\nWe need to add a loop, similar to what we do in CoreCLR here: https://github.com/dotnet/runtime/blob/79ae74f5ca5c8a6fe3a48935e85bd7374959c570/src/coreclr/gc/unix/events.cpp#L149-L190\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eakoeplinger\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e7.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-05-16T15:39:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5FSWcH",
                                           "createdAt":  "2022-06-21T22:50:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCi_6uA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2022-06-21T23:04:58Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CoffeeFlux",
                                                                               "createdAt":  "2022-06-22T00:53:42Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "janvorli",
                                           "body":  "It doesn\u0027t seem the managed code handles spurious wakes:\r\nhttps://github.com/dotnet/runtime/blob/6a889d234267a4c96ed21d0e1660dce787d78a38/src/libraries/System.Private.CoreLib/src/System/Threading/LowLevelMonitor.cs#L88-L93\r\nhttps://github.com/dotnet/runtime/blob/57bfe474518ab5b7cfe6bf7424a79ce3af9d6657/src/libraries/System.Private.CoreLib/src/System/Threading/LowLevelMonitor.Unix.cs#L42-L45",
                                           "updatedAt":  "2022-06-21T22:50:05Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "pal_threading.c doesn\u0027t handle spurious wakes",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/51166",
        "createdAt":  "2021-04-13T08:16:53Z",
        "number":  51166,
        "author":  "kingcean",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-07-06T06:28:20Z",
        "body":  "## Background and Motivation\r\n\r\nWe invoke handlers everywhere in our apps and services. Most of them are invoked immediately but some may need an appropriate interceptor to determine whether the current invoking action can run right now, later or never. For example, we may throttle a button action, debounce a search box typing, or raise event only after the specified number of clicks.\r\n\r\nThe interceptor need supports following flags.\r\n\r\n- Limitation of invoking times. So we can set an optional minimum count and an optional maximum count as a window to allow the invoking actions.\r\n- The counting duration to auto reset. It is used to reset the above invoking times to zero after a specific time span.\r\n- Delay time span to invoke.\r\n- The interceptor mode to determine which one invokes in the above invoking times limitation, e.g. the first one, the last one or all.\r\n\r\n## Proposed API\r\n\r\nFirstly, we will have a class to config the interceptor policy.\r\n\r\n```csharp\r\nnamespace System.Threading\r\n{\r\n    public class InterceptorPolicy\r\n    {\r\n        public int MinCount { get; set; }\r\n        public int? MaxCount { get; set; } // null for unlimited.\r\n        // Delay to execute.\r\n        public TimeSpan? Delay {get; set; }\r\n        // The duration for interceptor couting cycle.\r\n        public TimeSpan? Duration { get; set; }\r\n        // Timeout after last invoking.\r\n        public TimeSpan? Timeout {get; set; }\r\n        // The mode to control the invoking passing way.\r\n        public InterceptorMode Mode { get; set; }\r\n    }\r\n    public enum InterceptorMode\r\n    {\r\n        // Invoke without any intercept.\r\n        Pass = 0,\r\n        // Invoke for the first one which match the condition defined in the policy.\r\n        Mono = 1,\r\n        // For concurrent pending or invoking, only execute the last one which meets the condition.\r\n        // And execute the ones which are none-concurrent.\r\n        Debounce = 2,\r\n        // Pend the first one to execute until no more invoking concurrently.\r\n        Lock = 3\r\n    }\r\n}\r\n```\r\n\r\nThen we can use the above policy to create an interceptor instance which is used to determine internally whether execute when it is invoked. It also allow users to access its states and add event handler for business.\r\n\r\n```csharp\r\nnamespace System.Threading\r\n{\r\n    public class Interceptor\r\n    {\r\n        public Interceptor();\r\n        public Interceptor(InterceptorPolicy policy);\r\n        public InterceptorPolicy Policy { get; set; }\r\n        public bool IsDisabled { get; set; }\r\n        public event EventHandler\u003cInterceptorEventArgs\u003e Executed;\r\n\r\n        // Current states and information.\r\n        public int TotalCount { get; }\r\n        public DateTime? InitiatedInvokingDate { get; } // First invoking date time per duration.\r\n        public DateTime? LatestInvokeDate { get; }\r\n        public DateTime? LatestExecuteDate { get; }\r\n\r\n        // Invoke but only execute the one match the condition defined by the policy.\r\n        // It returns a value indicating whether it executes.\r\n        public Task\u003cbool\u003e InvokeAsync();\r\n    }\r\n}\r\n```\r\n\r\nHowever, the above class only supports no argument senario. So we will update it as following to add generic arguments supports.\r\n\r\n```csharp\r\nnamespace System.Threading\r\n{\r\n    public abstract class BaseInterceptor\r\n    {\r\n        public Interceptor();\r\n        public Interceptor(InterceptorPolicy policy);\r\n        public InterceptorPolicy Policy { get; set; }\r\n        public bool IsDisabled { get; set; }\r\n        public int TotalCount { get; }\r\n        public DateTime? InitiatedInvokingDate { get; } // First invoking date time per duration.\r\n        public DateTime? LatestInvokeDate { get; }\r\n        public DateTime? LatestExecuteDate { get; }\r\n    }\r\n    public class Interceptor : BaseInterceptor\r\n    {\r\n        public Interceptor();\r\n        public Interceptor(InterceptorPolicy policy);\r\n        public event EventHandler\u003cInterceptorEventArgs\u003e Executed;\r\n        public Task\u003cbool\u003e InvokeAsync();\r\n    }\r\n    public class Interceptor\u003cT\u003e : BaseInterceptor\r\n    {\r\n        public Interceptor();\r\n        public Interceptor(InterceptorPolicy policy);\r\n        public event EventHandler\u003cInterceptorEventArgs\u003cT\u003e\u003e Executed;\r\n        public Task\u003cbool\u003e InvokeAsync(T args);\r\n    }\r\n    public class Interceptor\u003cT1, T2\u003e : BaseInterceptor\r\n    {\r\n        public Interceptor();\r\n        public Interceptor(InterceptorPolicy policy);\r\n        public event EventHandler\u003cInterceptorEventArgs\u003cT1, T2\u003e\u003e Executed;\r\n        public Task\u003cbool\u003e InvokeAsync(T1 args1, T2 args2);\r\n\r\n        // Useful for event handler register especially when T1 = object.\r\n        public void InvokeBegin(T1 args1, T2 args2)\r\n        {\r\n            _ = InvokeAsync(T1 args1, T2 args2);\r\n        }\r\n    }\r\n    public class Interceptor\u003cT1, T2, T3\u003e : BaseInterceptor\r\n    {\r\n        public Interceptor();\r\n        public Interceptor(InterceptorPolicy policy);\r\n        public event EventHandler\u003cInterceptorEventArgs\u003cT1, T2, T3\u003e\u003e Executed;\r\n        public Task\u003cbool\u003e InvokeAsync(T1 args1, T2 args2, T3 args3);\r\n    }\r\n    // Interceptor\u003cT1, T2, T3, T4\u003e, Interceptor\u003cT1, T2, T3, T4, T5\u003e, Interceptor\u003cT1, T2, T3, T4, T5, T6\u003e, etc.\r\n}\r\n```\r\n\r\nFollowing are the accessories.\r\n\r\n```csharp\r\nnamespace System.Threading\r\n{\r\n    public class InterceptorEventArgs : EventArgs {\r\n        public InterceptorEventArgs(int count, DateTime request, DateTime? previous, DateTime first);\r\n        public int Count { get; }\r\n        public DateTime InvokingDate { get; }\r\n        public DateTime? PreviousInvokedDate { get; }\r\n        public DateTime FirstInvokedDate { get; }\r\n    }\r\n    public class InterceptorEventArgs\u003cT\u003e : InterceptorEventArgs {\r\n        public InterceptorEventArgs(int count, DateTime current, DateTime? previous, DateTime first, T arg);\r\n        public T Args { get; }\r\n    }\r\n    public class InterceptorEventArgs\u003cT1, T2\u003e : InterceptorEventArgs {\r\n        public InterceptorEventArgs(int count, DateTime current, DateTime? previous, DateTime first, T1 args1, T2 args2);\r\n        public T1 Args1 { get; }\r\n        public T2 Args2 { get; }\r\n    }\r\n    public class InterceptorEventArgs\u003cT1, T2, T3\u003e : InterceptorEventArgs {\r\n        public InterceptorEventArgs(int count, DateTime current, DateTime? previous, DateTime first, T1 args1, T2 args2, T3 args3);\r\n        public T1 Args1 { get; }\r\n        public T2 Args2 { get; }\r\n        public T3 Args3 { get; }\r\n    }\r\n    // InterceptorEventArgs\u003cT1, T2, T3, T4\u003e, InterceptorEventArgs\u003cT1, T2, T3, T4, T5\u003e, etc.\r\n}\r\n```\r\n\r\nWell, this is just a start. Next, we will provide some interesting extensions. Following contains a lot of static method which will be used for some commonly used senarios, e.g. debounce, throttle, mulitple hit, etc.\r\n\r\n- `Debounce`: Invoke several times in a short time but only the last one should be executed, the previous ones should be ignored. A sample scenario is real-time search.\r\n- `Throttle`: Execute once only in a short time even if invoke several times, the rest will be ignored.\r\n- `Multiple`: Execute for the specific times and it will be reset to count after a while.\r\n- `Times`: Execute at last only when invoke in the specific times range. A sample scenario is double click.\r\n\r\n```csharp\r\nnamespace System.Threading\r\n{\r\n    public class InterceptorPolicy {\r\n        public int MinCount { get; set; }\r\n        public int? MaxCount { get; set; }\r\n        public TimeSpan? Delay {get; set; }\r\n        public TimeSpan? Duration { get; set; }\r\n        public TimeSpan? Timeout {get; set; }\r\n        public InterceptorMode Mode { get; set; }\r\n\r\n        public static InterceptorPolicy Debounce(Action handler, TimeSpan delay) =\u003e new () {\r\n            Mode = InterceptorMode.Debounce,\r\n            Delay = delay\r\n        };\r\n        public static InterceptorPolicy Throttle(Action handler, TimeSpan duration) =\u003e new () {\r\n            Mode = InterceptorMode.Mono,\r\n            Timeout = duration,\r\n            Delay = duration,\r\n            MaxCount = 1\r\n        };\r\n        public static InterceptorPolicy Multiple(Action handler, int min, int? max, TimeSpan timeout) =\u003e new () {\r\n            Timeout = duration,\r\n            MinCount = min,\r\n            MaxCount = max\r\n        };\r\n        public static InterceptorPolicy Times(Action handler, int min, int? max, TimeSpan timeout) =\u003e new () {\r\n            Mode = InterceptorMode.Debounce,\r\n            Delay = timeout\r\n            Timeout = timeout,\r\n            MinCount = min,\r\n            MaxCount = max\r\n        };\r\n        public static InterceptorPolicy Times(Action handler, int count, TimeSpan timeout) =\u003e new () {\r\n            Mode = InterceptorMode.Debounce,\r\n            Delay = timeout\r\n            Timeout = timeout,\r\n            MinCount = count\r\n        };\r\n    }\r\n\r\n    public class Interceptor : BaseInterceptor\r\n    {\r\n        public Interceptor();\r\n        public Interceptor(InterceptorPolicy policy);\r\n        public event EventHandler\u003cInterceptorEventArgs\u003e Executed;\r\n        public Task\u003cbool\u003e InvokeAsync();\r\n\r\n        // Create an interceptor instance for a handler.\r\n        public static Interceptor Create(Action handler, InterceptorPolicy policy)\r\n        {\r\n            var interceptor = new Interceptor(policy);\r\n            interceptor.Executed += (sender, ev) =\u003e handler();\r\n            return interceptor;\r\n        };\r\n        public static Interceptor Create(Action\u003cInterceptorEventArgs\u003e handler, InterceptorPolicy policy)\r\n        {\r\n            var interceptor = new Interceptor(policy);\r\n            interceptor.Executed += (sender, ev) =\u003e handler(ev);\r\n            return interceptor;\r\n        };\r\n\r\n        // Create a debounce interceptor instance for a handler.\r\n        public static Interceptor Debounce(Action handler, TimeSpan delay)\r\n            =\u003e Create(handler, InterceptorPolicy.Debounce(delay);\r\n        public static Interceptor Debounce(Action\u003cInterceptorEventArgs\u003e handler, TimeSpan delay)\r\n            =\u003e Create(handler, InterceptorPolicy.Debounce(delay);\r\n\r\n        // Create a throttle interceptor instance for a handler.\r\n        public static Interceptor Throttle(Action handler, TimeSpan duration)\r\n            =\u003e Create(handler, InterceptorPolicy.Throttle(duration);\r\n        public static Interceptor Throttle(Action\u003cInterceptorEventArgs\u003e handler, TimeSpan duration)\r\n            =\u003e Create(handler, InterceptorPolicy.Throttle(duration);\r\n\r\n        // Create a multiple interceptor instance for a handler.\r\n        public static Interceptor Multiple(Action handler, int min, int? max, TimeSpan timeout)\r\n            =\u003e Create(handler, InterceptorPolicy.Multiple(min, max, timeout);\r\n        public static Interceptor Multiple(Action\u003cInterceptorEventArgs\u003e handler, int min, int? max, TimeSpan timeout)\r\n            =\u003e Create(handler, InterceptorPolicy.Multiple(min, max, timeout);\r\n\r\n        // Create a times interceptor instance for a handler.\r\n        public static Interceptor Times(Action handler, int min, int? max, TimeSpan timeout)\r\n            =\u003e Create(handler, InterceptorPolicy.Times(min, max, timeout);\r\n        public static Interceptor Times(Action\u003cInterceptorEventArgs\u003e handler, int min, int? max, TimeSpan timeout)\r\n            =\u003e Create(handler, InterceptorPolicy.Times(min, max, timeout);\r\n        public static Interceptor Times(Action handler, int count, TimeSpan timeout)\r\n            =\u003e Create(handler, InterceptorPolicy.Times(count, timeout);\r\n        public static Interceptor Times(Action\u003cInterceptorEventArgs\u003e handler, int count, TimeSpan timeout)\r\n            =\u003e Create(handler, InterceptorPolicy.Times(count, timeout);\r\n    }\r\n\r\n    public class Interceptor\u003cT\u003e : BaseInterceptor\r\n    {\r\n        public Interceptor();\r\n        public Interceptor(InterceptorPolicy policy);\r\n        public event EventHandler\u003cInterceptorEventArgs\u003cT\u003e\u003e Executed;\r\n        public Task\u003cbool\u003e InvokeAsync(T args);\r\n\r\n        public static Interceptor Create(Action\u003cT\u003e handler, InterceptorPolicy policy);\r\n        public static Interceptor Create(Action\u003cT, InterceptorEventArgs\u003e handler, InterceptorPolicy policy);\r\n        public static Interceptor Debounce(Action\u003cT\u003e handler, TimeSpan delay);\r\n        public static Interceptor Debounce(Action\u003cT, InterceptorEventArgs\u003e handler, TimeSpan delay);\r\n        public static Interceptor Throttle(Action\u003cT\u003e handler, TimeSpan duration);\r\n        public static Interceptor Throttle(Action\u003cT, InterceptorEventArgs\u003e handler, TimeSpan duration);\r\n        public static Interceptor Multiple(Action\u003cT\u003e handler, int min, int? max, TimeSpan timeout);\r\n        public static Interceptor Multiple(Action\u003cT, InterceptorEventArgs\u003e handler, int min, int? max, TimeSpan timeout);\r\n        public static Interceptor Times(Action\u003cT\u003e handler, int min, int? max, TimeSpan timeout);\r\n        public static Interceptor Times(Action\u003cT, InterceptorEventArgs\u003e handler, int min, int? max, TimeSpan timeout);\r\n        public static Interceptor Times(Action\u003cT\u003e handler, int count, TimeSpan timeout);\r\n        public static Interceptor Times(Action\u003cT, InterceptorEventArgs\u003e handler, int count, TimeSpan timeout);\r\n    }\r\n\r\n    // ...\r\n}\r\n```\r\n\r\n## Usage Examples\r\n\r\n``` C#\r\nvar interceptor = Interceptor.Debounce(() =\u003e {\r\n    // Do something...\r\n}, TimeSpan.FromMilliseconds(200));\r\n\r\n// Somewhere to invoke.\r\ninterceptor.InvokeAsync();\r\n```\r\n\r\nAnother sample.\r\n\r\n``` C#\r\nvar interceptor = Interceptor\u003cobject, RoutedEventArgs\u003e.Times((sender, ev) =\u003e {\r\n    // Do something...\r\n}, 2, 2, TimeSpan.FromMilliseconds(500));\r\n\r\n// Add event to UI.\r\nbutton.Clicked += interceptor.InvokeBegin;\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOMUawTg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxODU0MzM3OA==",
                                           "createdAt":  "2021-04-13T08:16:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-04-13T08:16:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxOTM5ODE0MA==",
                                           "createdAt":  "2021-04-14T10:03:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "I don\u0027t know if you need the whole interceptor concept. Feels like it could be a factory method that takes a delegate of a specific shape and returns a delegate of the same shape with the behavior.",
                                           "updatedAt":  "2021-04-14T10:03:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxOTU4NzgwMQ==",
                                           "createdAt":  "2021-04-14T15:00:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kingcean",
                                           "body":  "\u003e I don\u0027t know if you need the whole interceptor concept. Feels like it could be a factory method that takes a delegate of a specific shape and returns a delegate of the same shape with the behavior.\r\n\r\nGood point! I think we can add helper functions or extension methods to provide these delegate factory or decorators powered by the interceptor implementation in whole concept.\r\n\r\nIt is particularly useful and necessary to provide the whole interceptor concept in the usages of enterprise level development because it needs full supports of diagnostics, logging and middleware. It provides a way (a) to get the sufficient information to log or to determine advanced; (b) to monitor or listen the business procedure; and (c) to append further actions to extend the original business flow.\r\n\r\nBut of course, for most cases, we will use the delegate factory or decorators because it is easy to use.",
                                           "updatedAt":  "2021-04-14T15:00:54Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyNjcxNjIzOA==",
                                           "createdAt":  "2021-04-26T10:25:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kingcean",
                                           "body":  "Following is a picture about the relationship and control logic of following properties.\r\n\r\n- `int MinCount { get; set; }`\r\n- `int? MaxCount { get; set; }`\r\n- `TimeSpan? Delay { get; set; }`\r\n- `TimeSpan? Duration { get; set; }`\r\n- `TimeSpan? Timeout { get; set; }`\r\n- `InterceptorMode Mode { get; set; }` (with enum value `Pass`, `Mono`, `Debounce` and `Lock`)\r\n\r\n![Interceptor Policy](https://user-images.githubusercontent.com/1724940/116101647-95244780-a6e0-11eb-97fc-85cc4825f391.jpg)\r\n\r\nP.S. [Reference implementation](https://github.com/nuscien/trivial/blob/bb26cc6dfeeb82a550c24c4f84b95cf3d03bc808/Core/Tasks/Interceptor/BaseInterceptor.cs).",
                                           "updatedAt":  "2021-06-22T03:52:58Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Handler invoking interceptor",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/51299",
        "createdAt":  "2021-04-15T08:06:50Z",
        "number":  51299,
        "author":  "nov30th",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCf3n4g==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "theodorzoulias",
                                            "createdAt":  "2022-06-02T10:52:22Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2021-04-15T16:00:07Z",
        "body":  "### Description\r\nThe \"OK\" in the console appears only once.\r\n\r\n```C#\r\nvar t = TimeSpan.FromTicks(9999);\r\nvar o = new Timer(s =\u003e Console.WriteLine(\"OK\"), null, t, t);\r\n\r\nConsole.ReadLine();\r\no.Dispose();\r\n```\r\n\r\n### Configuration\r\n\r\n.net 5.0, .netCore 3.1, might be most .net env\r\n\r\n### Regression?\r\n\r\nAFIK ppl usually using a parameter with int/long with Timer that is no problem, once with Timespan, this issue happens.\r\n\r\n### Other information\r\n\r\nref https://github.com/dotnet/reactive/issues/1520",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOMOeVsg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyMDIxNTI1Mw==",
                                           "createdAt":  "2021-04-15T08:06:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-04-15T08:06:54Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyMDMzMTIxNg==",
                                           "createdAt":  "2021-04-15T10:54:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBnUzhg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "stephentoub",
                                                                               "createdAt":  "2021-04-15T11:11:05Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nov30th",
                                                                               "createdAt":  "2021-04-15T14:13:07Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "```csharp\r\nvar t = TimeSpan.FromTicks(9999);\r\nConsole.WriteLine((int)t.TotalMilliseconds);\r\n```\r\n\r\nThis will print 0 since 9999 ticks is less than a millisecond. The above is equivalent to `new Timer(s =\u003e Console.WriteLine(\"OK\"), null, 0, 0);` and that\u0027s documented as \"If period is zero (0) or Timeout.Infinite and dueTime is not Timeout.Infinite, callback is invoked once\". This part of the remarks is missing in the docs for the TimeSpan overload; maybe we should add it.",
                                           "updatedAt":  "2021-04-15T10:54:26Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyMDQ4MzUwNg==",
                                           "createdAt":  "2021-04-15T14:41:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "nov30th",
                                           "body":  "I would suggest there will be a clear notify/warning/exception if period which less than 1 millisecond and larger than 0 could not be executed.",
                                           "updatedAt":  "2021-04-15T14:41:54Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Timer does not work with period less than Timespan.FromTicks(10000)",
        "labels":  [
                       "documentation",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/51362",
        "createdAt":  "2021-04-16T03:01:43Z",
        "number":  51362,
        "author":  "davidfowl",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-03T21:10:23Z",
        "body":  "I was looking at what happens when I spin up 100,000 concurrent websocket connections on the server side all doing ping pongs. They each have their own periodic timer that fires on an interval (default 2 mins in ASP.NET Core). This will spawn 100,000 thread pool work items to fire timer callbacks (well 99,999) and I think it would be interesting to experiment with batching these callbacks the same way we do with socket continuations. The idea would be to keep a separate `IThreadPoolWorkItem` and a `ConcurrentQueue\u003cTimerQueueTimer\u003e` that mimics this https://github.com/dotnet/runtime/blob/31c28fc379ec6f581c101f630a3a81e0f215c1ea/src/libraries/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncEngine.Unix.cs#L198-L262. In theory, this would reduce the threadpool overhead for firing lots of timers that typically fire together.\r\n\r\nThis is something I\u0027m gonna try out but I\u0027d like to get some of your thoughts @stephentoub and @kouvel  (anyone else that wants to join in !)",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOQ3xfyw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyODIxNTQyMw==",
                                           "createdAt":  "2021-04-28T07:25:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "How about making the timer work items local? Might be more efficient, and that would also allow a timer tracking an in-flight work item to fire and the callback to be processed before having to deplete other global work items first.",
                                           "updatedAt":  "2021-04-28T07:25:05Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyODIxODY0NA==",
                                           "createdAt":  "2021-04-28T07:29:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "\u003e and that would also allow a timer tracking an in-flight work item to fire and the callback to be processed before having to deplete other global work items first.\r\n\r\nMy only concern with using local queues is the work stealing scaling problem we currently have, but this does sound interesting. Is ordering a concern at all (LIFO vs FIFO)?",
                                           "updatedAt":  "2021-04-28T07:29:26Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyODI5ODY1NA==",
                                           "createdAt":  "2021-04-28T09:20:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "I think the work stealing scaling problem is more prominent when the queues are frequently depleted (undesirable scaling for each thread to see that there is no work), which exists despite local queues not being used. For that issue anyway I was experimenting with a fix but hadn\u0027t completed it yet. I don\u0027t think using the local queues would make the scaling worse.\r\n\r\nRegarding ordering, I don\u0027t think the order matters between each of the timer callbacks in a batch that have elapsed their due time, new timers are already inserted/processed in LIFO order, and I don\u0027t think we make any guarantee about the order in which they run. It\u0027s possible that while processing some timer callbacks that timers with a later due time tick, then due to the LIFO order of the local work items that new batch of callbacks would be processed before the callbacks queued earlier from an earlier due time. I think it\u0027s a very slim chance since there\u0027s a decent amount of time (at least 1 ms) between batches, and it\u0027s not dissimilar from delaying the first batch until the later due time such as if the callback to schedule callbacks is delayed, so even then the order shouldn\u0027t matter.",
                                           "updatedAt":  "2021-04-28T20:08:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5CFYhv",
                                           "createdAt":  "2022-04-25T15:14:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "@kouvel Should we try this in .NET 7?",
                                           "updatedAt":  "2022-04-25T15:14:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5CGpqN",
                                           "createdAt":  "2022-04-25T21:05:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCZu2ZQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "davidfowl",
                                                                               "createdAt":  "2022-04-25T21:07:56Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "kouvel",
                                           "body":  "Marked it for 7.0 for now, will take a look",
                                           "updatedAt":  "2022-04-25T21:05:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DfF_L",
                                           "createdAt":  "2022-05-19T21:30:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCd18xQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "davidfowl",
                                                                               "createdAt":  "2022-05-20T07:30:12Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "kouvel",
                                           "body":  "Actually you might be right about work stealing being a problem. If only one or few threads queue a whole bunch of timers locally and the thread pool is mostly idle, then all other threads would have to rely on work stealing to get that work. Batching may be more efficient when the thread pool is idle, so maybe that\u0027s a better solution for this case. But we also have proc count `TimerQueue`s so it may work out. Will try it out.",
                                           "updatedAt":  "2022-05-19T21:31:35Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "Reduce thread pool pressure by batching workitems if multiple timers need to fire",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/51987",
        "createdAt":  "2021-04-28T13:36:38Z",
        "number":  51987,
        "author":  "e-davidson",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-05-01T05:16:55Z",
        "body":  "## Background and Motivation\r\n\r\n\u003c!--\r\nWe welcome API proposals! We have a process to evaluate the value and shape of new API. There is an overview of our process [here](https://github.com/dotnet/runtime/blob/main/docs/project/api-review-process.md). This template will help us gather the information we need to start the review process.\r\nFirst, please describe the purpose and value of the new API here.\r\n--\u003e\r\n\r\nThe goal is to have an ambient context with asynchronous control flow and be able to deterministically cleanup its resources.\r\nSo we need to get notified when the execution context will no longer get used.\r\n\r\nGenerally you would use `using var scope = provider.CreateScope();`. However, if you don\u0027t want to wait for the task to complete that wont work. An example where you don\u0027t want to wait is in an http request that can trigger a longer running process. You want the request to return right away if you don\u0027t need to wait for the result. The issue is then the httpContext\u0027s scope gets disposed while  you may want the asynchronous process to use the same scope. For example to use the same userId or Unit of work. You can create middleware that will add the scoped service provider to an AsyncLocal, but then you can\u0027t call dispose when all the async tasks return.\r\n\r\n\r\n## Proposed API\r\n```\r\n    internal interface IAsyncLocal\r\n    {\r\n        void OnValueChanged(object? previousValue, object? currentValue, bool contextChanged);\r\n        void OnExecutionContextDisposed(object? value);\r\n    }\r\n ```\r\nand for AsyncLocal\u003cT\u003e\r\n\r\n```\r\n        public AsyncLocal(Action\u003cAsyncLocalValueChangedArgs\u003cT\u003e\u003e? valueChangedHandler, Action\u003cT\u003e? onDispose)\r\n        {\r\n                ...\r\n        }\r\n```\r\n\r\nWhen the execution context changes and the previous context completed so it\u0027ll never get used again and no execution context are holding the AsyncLocalMap holding the AsyncLocal value the onDispose callback should get called.\r\n\r\n## Usage Examples\r\n\r\n```\r\nstatic AsyncLocal\u003cIServiceScope\u003e AmbientServiceProvidor = new(null, serviceScope =\u003e serviceScope.Dispose() );\r\n```\r\n\u003c!--\r\nPlease provide code examples that highlight how the proposed API additions are meant to be consumed.\r\nThis will help suggest whether the API has the right shape to be functional, performant and useable.\r\nYou can use code blocks like this:\r\n``` C#\r\n// some lines of code here\r\n```\r\n--\u003e\r\n\r\n\r\n\r\n## Risks\r\nSince the execution context is used heavily in async/await it\u0027s a hot path that can affect performance.\r\n\r\n\u003c!--\r\nPlease mention any risks that to your knowledge the API proposal might entail, such as breaking changes, performance regressions, etc.\r\n--\u003e\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOMWFQ_w==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyODQ2MTMxMQ==",
                                           "createdAt":  "2021-04-28T13:36:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-04-28T13:36:41Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "AsyncLocal with IDisposable for ambient context cleanup",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/52701",
        "createdAt":  "2021-05-13T13:52:36Z",
        "number":  52701,
        "author":  "kouvel",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCrRB0g==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "patricksuo",
                                            "createdAt":  "2021-05-15T13:57:49Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "viktor-svub",
                                            "createdAt":  "2022-11-02T08:47:20Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2025-09-04T17:36:00Z",
        "body":  "- [ ] Using less power when appropriate on machines with heterogenous cores\r\n  - The thread pool parallelizes fairly quickly and likely causes cores to be unparked or for threads to be switched to a performance core. The goal is to experiment with a couple of ideas that may work and to measure the effects.\r\n  - [ ] Identify a mobile device scenario to improve and measure the current performance and power\r\n  - [ ] Experiment with using the online core count to limit concurrency while still being able to unpark cores if necessary for performance\r\n  - [ ] Experiment with spin-waiting less and measure power usage\r\n- [ ] Further investigate the perf regressions from processing IO events at higher priority on Unixes. https://github.com/dotnet/runtime/issues/77665\r\n- [ ] Hill climbing\r\n  - [ ] Disable hill climbing by default for a few previews and gather feedback\r\n  - [ ] Consider an alternative, to identify individual threads that appear to be stalled and responding more quickly similarly to cooperative blocking\r\n- [ ] The overhead of work stealing is high, especially in bursty scenarios or in cases where the thread count is high, when threads are all trying to determine that there is no work left. https://github.com/dotnet/runtime/issues/10752\r\n\r\n#### Completed\r\n\r\n- [x] Remove the native thread pool. Move timer implementation to libraries. https://github.com/dotnet/runtime/pull/71719\r\n- [x] The thread pool\u0027s global queue does not scale well on machines with a large number of processors with one or more numa nodes. Attempt to make work items more local with appropriate ordering, or other techniques. https://github.com/dotnet/runtime/issues/67845, https://github.com/dotnet/runtime/pull/69386\r\n- [x] Add Windows IO completion handling to the portable thread pool. https://github.com/dotnet/runtime/pull/64834\r\n- [x] Thread pool requests too many threads. Thread pool\u0027s thread request code is logically flawed (https://github.com/dotnet/runtime/issues/8951). It performs poorly in bursty scenarios and in low-load situations.\r\n- [x] Spin-waiting on arm processors is insufficient. Actionable, dependency for next item due to perf regressions. https://github.com/dotnet/runtime/issues/39559\r\n- [x] Change spin-waiting normalization to not depend on values measured at startup. https://github.com/dotnet/runtime/issues/53509\r\n- [x] Increase rate of thread injection for blocking due to sync-over-async. https://github.com/dotnet/runtime/issues/52558\r\n- [x] Fix `Environment.ProcessorCount` to behave on Windows similarly to Linux in CPU-limited environments. Make the value configurable. https://github.com/dotnet/runtime/issues/47427, https://github.com/dotnet/runtime/issues/48094",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOczmykA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg0MDYwNjIwMA==",
                                           "createdAt":  "2021-05-13T14:38:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "@kouvel do you want to link some of the other work items.",
                                           "updatedAt":  "2021-05-13T14:38:50Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg0MTQwNDUyNQ==",
                                           "createdAt":  "2021-05-14T17:49:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "Thanks for listing these. Couple of questions: \r\n1. Are these in priority order? \r\n2. Would be good to determine which will make it into .net 6 preview 7 timeframe\r\n3. First and last items are basically the same? ",
                                           "updatedAt":  "2021-05-14T17:49:47Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg0MTUwNDM1Mg==",
                                           "createdAt":  "2021-05-14T21:08:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "\u003e Are these in priority order?\r\n\r\nThese are not in any particular order, I believe they are all worth doing.\r\n\r\n\u003e Would be good to determine which will make it into .net 6 preview 7 timeframe\r\n\r\nOther than the checked item, \"Increase rate of thread injection for blocking due to sync-over-async\" and \"Fix spin-waiting to not depend on values measured at startup\" are the currently scheduled items.\r\n\r\n\u003e First and last items are basically the same?\r\n\r\nThe last one is specific to sync-over-async and works a bit differently. There is some overlap between them.",
                                           "updatedAt":  "2021-05-14T21:08:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5I0PtM",
                                           "createdAt":  "2022-08-22T00:21:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCwMyFQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "ROCKET",
                                                                               "user":  "epeshk",
                                                                               "createdAt":  "2022-11-25T13:51:23Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "This list is awesome. There are only 2 open work items. Great work all. We made lots of progress on the thread pool over the years.",
                                           "updatedAt":  "2022-08-22T00:21:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5zMqiZ",
                                           "createdAt":  "2024-02-07T19:11:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeremysimmons",
                                           "body":  "I was interested in the event for ThreadPool mentioned in #11008, does this exist?\r\nI don\u0027t see an item tracking this\r\n https://learn.microsoft.com/en-us/dotnet/api/system.threading.threadpool?view=net-8.0 doesn\u0027t have any events listed.",
                                           "updatedAt":  "2024-02-07T19:11:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5zObKQ",
                                           "createdAt":  "2024-02-08T00:22:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "\u003e I was interested in the event for ThreadPool mentioned in https://github.com/dotnet/runtime/issues/11008, does this exist?\r\n\r\nThis event indicates when starvation is detected (when `Reason` is `Starvation`): https://learn.microsoft.com/en-us/dotnet/fundamentals/diagnostics/runtime-thread-events#threadpoolworkerthreadadjustmentadjustment-event",
                                           "updatedAt":  "2024-02-08T00:22:27Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "Tracking issue for threading work items",
        "labels":  [
                       "area-System.Threading",
                       "tracking"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/54037",
        "createdAt":  "2021-06-05T04:02:21Z",
        "number":  54037,
        "author":  "ahdung",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-07-06T06:19:55Z",
        "body":  "Type: System.Threading.CountdownEvent\r\n\r\nNeed add method:\r\n```c#\r\npublic bool TrySignal(); //goal is `Signal` if it can, without exception.\r\n```\r\n\r\n`AddCount()` Don\u0027t throw exception when CountdownEvent setted.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOMz1ERg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NTE3OTEyMA==",
                                           "createdAt":  "2021-06-05T04:02:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one area label.",
                                           "updatedAt":  "2021-06-05T04:02:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1OTE0MDQ2Nw==",
                                           "createdAt":  "2021-06-10T23:02:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-06-10T23:02:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1OTE0NDUzNA==",
                                           "createdAt":  "2021-06-10T23:10:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "For what reason? Can you share the larger scenario that requires this?",
                                           "updatedAt":  "2021-06-10T23:10:20Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1OTIzNDk1MQ==",
                                           "createdAt":  "2021-06-11T03:26:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ahdung",
                                           "body":  "There have a Channel for storage some items, some threads add item into the Channel, I don\u0027t want immediately process each item when it come in, if items come in very quickly, I hope wait a few time and batch process them.\r\n\r\nSo I use a CountdownEvent `cde`, when adding item, I let `cde.AddCount()`, and 3 senconds later, let `cde.Signal()`:\r\n```c#\r\n// cde.AddCount(); Cannot call AddCount directly is a Bad design, AddCount() should not throw exception\r\n// when CurrentCount is 0, just let it add, developer know he doing what!!\r\n\r\nlock (cde) {\r\n  if (!cde.TryAddCount())\r\n    cde.Reset(1);\r\n}\r\ntry {\r\n  await channelWriter.WriteAsync(item);\r\n}\r\nfinally {\r\n  Task.Delay(3000).ContinueWith(_=\u003ecde.Signal()); // TrySignal need here\r\n}\r\n```\r\nIn process method, I use a loop like this:\r\n```c#\r\nwhile (await channelReader.WaitToReadAsync()) {\r\n  // if one item come in, just hold on, wait 3 seconds, if during this period another item come in,\r\n  // wait 3 secs again, until no one come in, here we go, like a bus.\r\n  cde.Wait();\r\n\r\n  // read all items in Channel and process them.\r\n}\r\n```\r\n\r\nIf there have better solution for this scene, please tell me, Thank you.",
                                           "updatedAt":  "2021-06-11T03:49:47Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1OTUyODk0MQ==",
                                           "createdAt":  "2021-06-11T11:56:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "I\u0027m not totally following,  but what you describe appears to be ripe with race conditions.  If all you\u0027re trying to do is track the number of outstanding operations, you can Interlocked.Increment/Decrement some integer, and do whatever you want in response to Decrement returning 0.",
                                           "updatedAt":  "2021-06-11T11:56:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1OTY1MzE5MA==",
                                           "createdAt":  "2021-06-11T15:15:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nType: System.Threading.CountdownEvent\r\n\r\nNeed add method:\r\n```c#\r\npublic bool TrySignal(); //goal is `Signal` if it can, without exception.\r\n```\r\n\r\n`AddCount()` Don\u0027t throw exception when CountdownEvent setted.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eahdung\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-06-11T15:15:55Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "Improve CountdownEvent API",
        "labels":  [
                       "question",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/55049",
        "createdAt":  "2021-07-02T00:02:02Z",
        "number":  55049,
        "author":  "WizardBrony",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCf3lAg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "theodorzoulias",
                                            "createdAt":  "2022-06-02T10:47:04Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2022-07-19T15:19:53Z",
        "body":  "## Background and Motivation\r\n\r\n.NET 6 currently includes an API addition to `CancellationTokenSource` called `TryReset`:\r\n\r\n[Add CancellationTokenSource.TryReset() #48492](https://github.com/dotnet/runtime/issues/48492)\r\n\r\nThe primary motivation for `Threading.Timer.TryReset` is the same: reusing instances rather than disposing them. There are use cases for `Timer` where it would be advantageous to be able to safely reset and reuse instances rather than repeatedly disposing them and instantiating new ones. For example, say you are developing an asynchronous scheduler and you want to implement timeout functionality by using a `Timer` to queue some custom logic after timing out. Most of the time, the `Timer` will never fire. However, one cannot simply call `Change(Timeout.Infinite, Timeout.Infinite)` and safely reuse the instance as it\u0027s possible that the callback got queued just before the call to `Change`, which could then incorrectly run the timeout logic for an unrelated operation. `TryReset` would only return true after calling `Change(Timeout.Infinite, Timeout.Infinite)` if the `Timer`\u0027s callback has never been queued. This would be enough for the caller to correctly assume that the callback will never be queued as a result of a previous call to `Change`/`Timer`\u0027s constructor, and therefore the instance can be safely reused for subsequent operations.\r\n\r\nImplementation detail: The implementation can make use of an addition to `TimerQueueTimer` as a result of implementing `CancellationTokenSource.TryReset`: `_everQueued`.\r\n\r\n```diff\r\nnamespace System.Threading\r\n{\r\n    internal sealed class TimerQueueTimer : IThreadPoolWorkItem\r\n    {\r\n+        public bool TryReset() =\u003e Change(Timeout.UnsignedInfinite, Timeout.UnsignedInfinite) \u0026\u0026 !_everQueued;\r\n    }\r\n}\r\n```\r\n\r\nThis would enable the following lines of `CancellationTokenSource.TryReset`:\r\n\r\nhttps://github.com/dotnet/runtime/blob/e3dd9857748814c2d56672838657a367b70c2452/src/libraries/System.Private.CoreLib/src/System/Threading/CancellationTokenSource.cs#L399-L401\r\n\r\nto be simplified to:\r\n\r\n``` C#\r\n                bool reset = _timer is not TimerQueueTimer timer || timer.TryReset();\r\n```\r\n\r\n## Proposed API\r\n\r\n```diff\r\nnamespace System.Threading\r\n{\r\n    public sealed class Timer : MarshalByRefObject, IDisposable, IAsyncDisposable\r\n    {\r\n+        public bool TryReset() =\u003e _timer._timer.TryReset();\r\n    }\r\n}\r\n```\r\n\r\n## Usage Examples\r\n\r\n``` C#\r\n// After the operation completes:\r\nif (!_timeoutTimer.TryReset())\r\n{\r\n    _timeoutTimer.Dispose();\r\n    _timeoutTimer = new Timer(_callback);\r\n}\r\n// else, reuse _timeoutTimer\r\n```\r\n\r\n## Alternative Designs\r\n\r\nAn alternative could be simply exposing `TimerQueueTimer._everQueued`, though this may be more cumbersome for consumers:\r\n\r\n```diff\r\nnamespace System.Threading\r\n{\r\n    public sealed class Timer : MarshalByRefObject, IDisposable, IAsyncDisposable\r\n    {\r\n+        public bool EverQueued =\u003e Volatile.Read(ref _timer._timer._everQueued);\r\n    }\r\n}\r\n```\r\n\r\n## Risks\r\n\r\nThe only risk I see is confusion about why `Timer.TryReset` would return `false` (for example, after having fired once before). But between documentation, and also general alignment with `CancellationTokenSource.TryReset`, I don\u0027t see this as significant.\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHONAMhrQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg3MjYyMDQ2MQ==",
                                           "createdAt":  "2021-07-02T00:02:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n## Background and Motivation\r\n\r\n.NET 6 currently includes an API addition to `CancellationTokenSource` called `TryReset`:\r\n\r\n[Add CancellationTokenSource.TryReset() #48492](https://github.com/dotnet/runtime/issues/48492)\r\n\r\nThe primary motivation for `Threading.Timer.TryReset` is the same: reusing instances rather than disposing them. There are use cases for `Timer` where it would be advantageous to be able to safely reset and reuse instances rather than repeatedly disposing them and instantiating new ones. For example, say you are developing an asynchronous scheduler and you want to implement timeout functionality by using a `Timer` to queue some custom logic after timing out. Most of the time, the `Timer` will never fire. However, one cannot simply call `Change(Timeout.Infinite, Timeout.Infinite)` and safely reuse the instance as it\u0027s possible that the callback got queued just before the call to `Change`, which could then incorrectly run the timeout logic for an unrelated operation. `TryReset` would only return true after calling `Change(Timeout.Infinite, Timeout.Infinite)` if the `Timer`\u0027s callback has never been queued. This would be enough for the caller to correctly assume that the callback will never be queued as a result of a previous call to `Change`/`Timer`\u0027s constructor, and therefore the instance can be safely reused for subsequent operations.\r\n\r\nImplementation detail: The implementation can make use of an addition to `TimerQueueTimer` as a result of implementing `CancellationTokenSource.TryReset`: `_everQueued`.\r\n\r\n```diff\r\nnamespace System.Threading\r\n{\r\n    internal sealed class TimerQueueTimer : IThreadPoolWorkItem\r\n    {\r\n+        public bool TryReset() =\u003e Change(Timeout.UnsignedInfinite, Timeout.UnsignedInfinite) \u0026\u0026 !_everQueued;\r\n    }\r\n}\r\n```\r\n\r\nThis would enable the following lines of `CancellationTokenSource.TryReset`:\r\n\r\nhttps://github.com/dotnet/runtime/blob/e3dd9857748814c2d56672838657a367b70c2452/src/libraries/System.Private.CoreLib/src/System/Threading/CancellationTokenSource.cs#L399-L401\r\n\r\nto be simplified to:\r\n\r\n``` C#\r\n                bool reset = _timer is not TimerQueueTimer timer || timer.TryReset();\r\n```\r\n\r\n## Proposed API\r\n\r\n```diff\r\nnamespace System.Threading\r\n{\r\n    public sealed class Timer : MarshalByRefObject, IDisposable, IAsyncDisposable\r\n    {\r\n+        public bool TryReset() =\u003e _timer._timer.TryReset();\r\n    }\r\n}\r\n```\r\n\r\n## Usage Examples\r\n\r\n``` C#\r\n// After the operation completes:\r\nif (!_timeoutTimer.TryReset())\r\n{\r\n    _timeoutTimer.Dispose();\r\n    _timeoutTimer = new Timer(_callback);\r\n}\r\n// else, reuse _timeoutTimer\r\n```\r\n\r\n## Alternative Designs\r\n\r\nAn alternative could be simply exposing `TimerQueueTimer._everQueued`, though this may be more cumbersome for consumers:\r\n\r\n```diff\r\nnamespace System.Threading\r\n{\r\n    public sealed class Timer : MarshalByRefObject, IDisposable, IAsyncDisposable\r\n    {\r\n+        public bool EverQueued =\u003e Volatile.Read(ref _timer._timer._everQueued);\r\n    }\r\n}\r\n```\r\n\r\n## Risks\r\n\r\nThe only risk I see is confusion about why `Timer.TryReset` would return `false` (for example, after having fired once before). But between documentation, and also general alignment with `CancellationTokenSource.TryReset`, I don\u0027t see this as significant.\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eWizardBrony\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-07-02T00:02:08Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Add Threading.Timer.TryReset",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/55330",
        "createdAt":  "2021-07-08T13:00:43Z",
        "number":  55330,
        "author":  "WizardBrony",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-03-07T18:18:49Z",
        "body":  "In `SemaphoreSlim.Release`, the following logic handles notifying synchronous waiters that counts have become available:\r\n\r\nhttps://github.com/dotnet/runtime/blob/1ca17cd7f7b16b5dfe7703e8e676d645da86af4d/src/libraries/System.Private.CoreLib/src/System/Threading/SemaphoreSlim.cs#L799-L823\r\n\r\nI understand how `m_countOfWaitersPulsedToWake` can be less than the number of threads that have actually been pulsed to wake as a result of waits timing out. But I don\u0027t see how `waitersToNotify` could become greater than `releaseCount`, since even in the timeout case, `Wait` still decrements `m_waitCount` and the current count (if available).",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOdkPfkA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg3NjQxOTIyNw==",
                                           "createdAt":  "2021-07-08T13:00:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nIn `SemaphoreSlim.Release`, the following logic handles notifying synchronous waiters that counts have become available:\r\n\r\nhttps://github.com/dotnet/runtime/blob/1ca17cd7f7b16b5dfe7703e8e676d645da86af4d/src/libraries/System.Private.CoreLib/src/System/Threading/SemaphoreSlim.cs#L799-L823\r\n\r\nI understand how `m_countOfWaitersPulsedToWake` can be less than the number of threads that have actually been pulsed to wake as a result of waits timing out. But I don\u0027t see how `waitersToNotify` could become greater than `releaseCount`, since even in the timeout case, `Wait` still decrements `m_waitCount` and the current count (if available).\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eWizardBrony\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-07-08T13:00:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc52Q9-Q",
                                           "createdAt":  "2024-03-07T18:18:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "WizardBrony",
                                           "body":  "Introduced by this commit:\r\nhttps://github.com/dotnet/runtime/commit/5670ded8080530f5849baa71ddc43b4c11373af1",
                                           "updatedAt":  "2024-03-07T18:18:47Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "SemaphoreSlim: rationale for notify limit logic in Release",
        "labels":  [
                       "question",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/55562",
        "createdAt":  "2021-07-13T10:21:40Z",
        "number":  55562,
        "author":  "twilker",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-07-20T02:12:38Z",
        "body":  "\u003c!--This is just a template - feel free to delete any and all of it and replace as appropriate.--\u003e\r\n\r\n### Description\r\n\r\n\u003c!--\r\n* Please share a clear and concise description of the problem.\r\n* Include minimal steps to reproduce the problem if possible. E.g.: the smallest possible code snippet; or a small repo to clone, with steps to run it.\r\n* What behavior are you seeing, and what behavior would you expect?\r\n  --\u003e\r\n\r\nI have simplified the scenario as that I have as good as possible. Down below you find the complete code with which you can test the program yourself. In my use case I have to wait for a reset event from another Thread. In this simplified version I signal the reset event after 200ms. This is implemented in the `SingleWaits` method.\r\n\r\nThis example works as expected. The output for me is\r\n\r\n    Test single waits - Timer\r\n    Set reset event 218\r\n    Main 222 ms\r\n    Thread: 222 ms\r\n\r\nWell the 20ms is still a heavy price, but it becomes far worse, when I increase the number of waits - this is closer to the scenario I have in my program. In the method `MultipleWaits` I create 15 threads that wait for the reset event - which should be set after 200 ms. \r\n\r\n    Test multiple waits - Timer\r\n    Set reset event 745\r\n    Thread 7: 745 ms\r\n    Main 745 ms\r\n    Thread 0: 745 ms\r\n    Thread 10: 746 ms\r\n    Thread 11: 747 ms\r\n    Thread 9: 746 ms\r\n    Thread 5: 745 ms\r\n    Thread 4: 745 ms\r\n    Thread 3: 745 ms\r\n    Thread 6: 745 ms\r\n    Thread 2: 745 ms\r\n    Thread 1: 745 ms\r\n    Thread 8: 745 ms\r\n    Thread 12: 750 ms\r\n    Thread 13: 750 ms\r\n    Thread 14: 750 ms\r\n\r\nThe interesting part here is, that the `Set\\Wait` method of the reset event does not produce the time gap. It seems that in this case the timer cannot execute after the designated time.\r\n\r\nOf course in my application these are no timers, but things like I/O access, computation and the like. But the effect is the same. There is a visible time gap in the execution where seemingly nothing happens. I had the issue in other scenarios as well (overly use of async/await for example). But there I could not reproduce it in a small example. And now to the code I used - I have kept it as low tech as possible:\r\n\r\n```C#\r\n  class Program\r\n  {\r\n      static void Main(string[] args)\r\n      {\r\n          SingleWaits();\r\n          Thread.Sleep(100);\r\n          Console.WriteLine(\"=============================\");\r\n          MultipleWaits();\r\n      }\r\n\r\n      private static void SingleWaits()\r\n      {\r\n          Console.WriteLine(\"Test single waits - Timer\");\r\n          ManualResetEventSlim resetEvent = new ManualResetEventSlim(false);\r\n          Stopwatch watch = new Stopwatch();\r\n          watch.Start();\r\n          ThreadPool.QueueUserWorkItem(state =\u003e\r\n          {\r\n              resetEvent.Wait();\r\n              Console.WriteLine($\"Thread: {watch.ElapsedMilliseconds} ms\");\r\n          });\r\n\r\n          using Timer timer = new Timer(state =\u003e\r\n                                        {\r\n                                            Console.WriteLine($\"Set reset event {watch.ElapsedMilliseconds}\");\r\n                                            resetEvent.Set();\r\n                                        }, null, 200,\r\n                                        Timeout.Infinite);\r\n          resetEvent.Wait();\r\n          Console.WriteLine($\"Main {watch.ElapsedMilliseconds} ms\");\r\n      }\r\n\r\n      private static void MultipleWaits()\r\n      {\r\n          Console.WriteLine(\"Test multiple waits\");\r\n          ManualResetEventSlim resetEvent = new ManualResetEventSlim(false);\r\n          Stopwatch watch = new Stopwatch();\r\n          watch.Start();\r\n          for (int j = 0; j \u003c 15; j++)\r\n          {\r\n              ThreadPool.QueueUserWorkItem(state =\u003e\r\n              {\r\n                  resetEvent.Wait();\r\n                  Console.WriteLine($\"Thread {state}: {watch.ElapsedMilliseconds} ms\");\r\n              }, j);\r\n          }\r\n\r\n          using Timer timer = new Timer(state =\u003e\r\n                                        {\r\n                                            Console.WriteLine($\"Set reset event {watch.ElapsedMilliseconds}\");\r\n                                            resetEvent.Set();\r\n                                        }, null, 200,\r\n                                        Timeout.Infinite);\r\n          resetEvent.Wait();\r\n          Console.WriteLine($\"Main {watch.ElapsedMilliseconds} ms\");\r\n      }\r\n  }\r\n```\r\n\r\n### Configuration\r\n\r\n\u003c!--\r\n* Which version of .NET is the code running on?\r\n* What OS and version, and what distro if applicable?\r\n* What is the architecture (x64, x86, ARM, ARM64)?\r\n* Do you know whether it is specific to that configuration?\r\n* If you\u0027re using Blazor, which web browser(s) do you see this issue in?\r\n  --\u003e\r\n\r\n- net5.0\r\n- Windows x64\r\n- I have seen the issue in other configurations as well\r\n\r\n### Regression?\r\n\r\n\u003c!--\r\n* Did this work in a previous build or release of .NET Core, or from .NET Framework? If you can try a previous release or build to find out, that can help us narrow down the problem. If you don\u0027t know, that\u0027s OK.\r\n  --\u003e\r\n\r\nI have seen the issue first back in .net Core 2.1, again in 3.0 and 3.1 and now in 5.0. Only now was I able to construct a simple example.\r\n\r\n### Other information\r\n\r\n\u003c!--\r\n* Please include any relevant stack traces or error messages. If possible please include text as text rather than images (so it shows up in searches).\r\n* If you have an idea where the problem might lie, let us know that here. Please include any pointers to code, relevant changes, or related issues you know of.\r\n* Do you know of any workarounds?\r\n  --\u003e\r\n\r\nWhen I keep the main thread alive with Thread.Sleep or SpinWaits It executes in 203 ms almost regardsless of the number of threads - I used 30 at that time. So it seem to be a problem, that once the main thread is interruppted it take a huge amount of time before it returns.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHONGW3qg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg3ODk2NzA5Mw==",
                                           "createdAt":  "2021-07-13T10:21:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-07-13T10:21:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg3OTA4MTM4Ng==",
                                           "createdAt":  "2021-07-13T13:19:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n\u003c!--This is just a template - feel free to delete any and all of it and replace as appropriate.--\u003e\r\n\r\n### Description\r\n\r\n\u003c!--\r\n* Please share a clear and concise description of the problem.\r\n* Include minimal steps to reproduce the problem if possible. E.g.: the smallest possible code snippet; or a small repo to clone, with steps to run it.\r\n* What behavior are you seeing, and what behavior would you expect?\r\n  --\u003e\r\n\r\nI have simplified the scenario as that I have as good as possible. Down below you find the complete code with which you can test the program yourself. In my use case I have to wait for a reset event from another Thread. In this simplified version I signal the reset event after 200ms. This is implemented in the `SingleWaits` method.\r\n\r\nThis example works as expected. The output for me is\r\n\r\n    Test single waits - Timer\r\n    Set reset event 218\r\n    Main 222 ms\r\n    Thread: 222 ms\r\n\r\nWell the 20ms is still a heavy price, but it becomes far worse, when I increase the number of waits - this is closer to the scenario I have in my program. In the method `MultipleWaits` I create 15 threads that wait for the reset event - which should be set after 200 ms. \r\n\r\n    Test multiple waits - Timer\r\n    Set reset event 745\r\n    Thread 7: 745 ms\r\n    Main 745 ms\r\n    Thread 0: 745 ms\r\n    Thread 10: 746 ms\r\n    Thread 11: 747 ms\r\n    Thread 9: 746 ms\r\n    Thread 5: 745 ms\r\n    Thread 4: 745 ms\r\n    Thread 3: 745 ms\r\n    Thread 6: 745 ms\r\n    Thread 2: 745 ms\r\n    Thread 1: 745 ms\r\n    Thread 8: 745 ms\r\n    Thread 12: 750 ms\r\n    Thread 13: 750 ms\r\n    Thread 14: 750 ms\r\n\r\nThe interesting part here is, that the `Set\\Wait` method of the reset event does not produce the time gap. It seems that in this case the timer cannot execute after the designated time.\r\n\r\nOf course in my application these are no timers, but things like I/O access, computation and the like. But the effect is the same. There is a visible time gap in the execution where seemingly nothing happens. I had the issue in other scenarios as well (overly use of async/await for example). But there I could not reproduce it in a small example. And now to the code I used - I have kept it as low tech as possible:\r\n\r\n```C#\r\n  class Program\r\n  {\r\n      static void Main(string[] args)\r\n      {\r\n          SingleWaits();\r\n          Thread.Sleep(100);\r\n          Console.WriteLine(\"=============================\");\r\n          MultipleWaits();\r\n      }\r\n\r\n      private static void SingleWaits()\r\n      {\r\n          Console.WriteLine(\"Test single waits - Timer\");\r\n          ManualResetEventSlim resetEvent = new ManualResetEventSlim(false);\r\n          Stopwatch watch = new Stopwatch();\r\n          watch.Start();\r\n          ThreadPool.QueueUserWorkItem(state =\u003e\r\n          {\r\n              resetEvent.Wait();\r\n              Console.WriteLine($\"Thread: {watch.ElapsedMilliseconds} ms\");\r\n          });\r\n\r\n          using Timer timer = new Timer(state =\u003e\r\n                                        {\r\n                                            Console.WriteLine($\"Set reset event {watch.ElapsedMilliseconds}\");\r\n                                            resetEvent.Set();\r\n                                        }, null, 200,\r\n                                        Timeout.Infinite);\r\n          resetEvent.Wait();\r\n          Console.WriteLine($\"Main {watch.ElapsedMilliseconds} ms\");\r\n      }\r\n\r\n      private static void MultipleWaits()\r\n      {\r\n          Console.WriteLine(\"Test multiple waits\");\r\n          ManualResetEventSlim resetEvent = new ManualResetEventSlim(false);\r\n          Stopwatch watch = new Stopwatch();\r\n          watch.Start();\r\n          for (int j = 0; j \u003c 15; j++)\r\n          {\r\n              ThreadPool.QueueUserWorkItem(state =\u003e\r\n              {\r\n                  resetEvent.Wait();\r\n                  Console.WriteLine($\"Thread {state}: {watch.ElapsedMilliseconds} ms\");\r\n              }, j);\r\n          }\r\n\r\n          using Timer timer = new Timer(state =\u003e\r\n                                        {\r\n                                            Console.WriteLine($\"Set reset event {watch.ElapsedMilliseconds}\");\r\n                                            resetEvent.Set();\r\n                                        }, null, 200,\r\n                                        Timeout.Infinite);\r\n          resetEvent.Wait();\r\n          Console.WriteLine($\"Main {watch.ElapsedMilliseconds} ms\");\r\n      }\r\n  }\r\n```\r\n\r\n### Configuration\r\n\r\n\u003c!--\r\n* Which version of .NET is the code running on?\r\n* What OS and version, and what distro if applicable?\r\n* What is the architecture (x64, x86, ARM, ARM64)?\r\n* Do you know whether it is specific to that configuration?\r\n* If you\u0027re using Blazor, which web browser(s) do you see this issue in?\r\n  --\u003e\r\n\r\n- net5.0\r\n- Windows x64\r\n- I have seen the issue in other configurations as well\r\n\r\n### Regression?\r\n\r\n\u003c!--\r\n* Did this work in a previous build or release of .NET Core, or from .NET Framework? If you can try a previous release or build to find out, that can help us narrow down the problem. If you don\u0027t know, that\u0027s OK.\r\n  --\u003e\r\n\r\nI have seen the issue first back in .net Core 2.1, again in 3.0 and 3.1 and now in 5.0. Only now was I able to construct a simple example.\r\n\r\n### Other information\r\n\r\n\u003c!--\r\n* Please include any relevant stack traces or error messages. If possible please include text as text rather than images (so it shows up in searches).\r\n* If you have an idea where the problem might lie, let us know that here. Please include any pointers to code, relevant changes, or related issues you know of.\r\n* Do you know of any workarounds?\r\n  --\u003e\r\n\r\nWhen I keep the main thread alive with Thread.Sleep or SpinWaits It executes in 203 ms almost regardsless of the number of threads - I used 30 at that time. So it seem to be a problem, that once the main thread is interruppted it take a huge amount of time before it returns.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003etwilker\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-07-13T13:19:18Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Extensive use of waiting threads leads to time gaps in execution",
        "labels":  [
                       "question",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/57713",
        "createdAt":  "2021-08-19T05:50:25Z",
        "number":  57713,
        "author":  "avparuch",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-07-19T16:18:06Z",
        "body":  "I\u0027m trying to set a COMPlus environment variable. https://github.com/steveharter/dotnet_coreclr/blob/master/Documentation/project-docs/clr-configuration-knobs.md\r\n\r\nThis is my code:\r\n\r\n```\r\nusing System;\r\nusing System.Threading;\r\n\r\nnamespace minthreads\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            Environment.SetEnvironmentVariable(\"COMPlus_ThreadPool_ForceMinWorkerThreads\", \"0x32\");\r\n            ThreadPool.GetMinThreads(out int workerThreads, out int ioThreads);\r\n            Console.WriteLine(workerThreads);\r\n            Console.WriteLine(ioThreads);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\nThe workerThreads variable does not return 50. It returns 8, which is the number of processors on my machine. Does this mean coreCLR does not read the environment variables after the application has already started.\r\n\r\nHowever, setting the same environment variable via command line or powershell like this $env:COMPlus_ThreadPool_ForceMinWorkerThreads = \u00270x32\u0027 before the application is started does work: the workerThreads does return 50.\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHONchrrg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc41vcce",
                                           "createdAt":  "2021-08-19T05:50:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-08-19T05:50:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41wncn",
                                           "createdAt":  "2021-08-19T13:55:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Does this mean coreCLR does not read the environment variables after the application has already started.\r\n\r\nCorrect. All environment variables that affect the runtime has to be set before the process starts.",
                                           "updatedAt":  "2021-08-19T13:55:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41woEd",
                                           "createdAt":  "2021-08-19T13:58:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "You can use `ThreadPool.SetMinThreads` to change the min threads setting in running process.",
                                           "updatedAt":  "2021-08-19T13:58:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41w_cC",
                                           "createdAt":  "2021-08-19T16:01:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "avparuch",
                                           "body":  "\u003e \u003e Does this mean coreCLR does not read the environment variables after the application has already started.\r\n\u003e \r\n\u003e Correct. All environment variables that affect the runtime has to be set before the process starts.\r\n\r\nThank you for the confirmation. ",
                                           "updatedAt":  "2021-08-19T16:01:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41xAU-",
                                           "createdAt":  "2021-08-19T16:06:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "avparuch",
                                           "body":  "\u003e You can use `ThreadPool.SetMinThreads` to change the min threads setting in running process.\r\n\r\nWhen I use the `ThreadPool.SetMinThreads` API, the thread pool still starts off at processor count. It just grows unthrottled till the minthreads count and then settles down to its normal algorithm if/when it crosses the minthreads threshold. I\u0027m trying to force a minimum from the get-go.. Are there other techniques to warm up the thread pool to a certain number of threads before application starts taking a burst of traffic? ",
                                           "updatedAt":  "2021-08-19T16:06:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41xCT1",
                                           "createdAt":  "2021-08-19T16:16:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Are there other techniques to warm up the thread pool to a certain number of threads\r\n\r\nThis will force the threadpool to create certain number of threads:\r\n```csharp\r\nWarmUpThreadPool(100);\r\nConsole.WriteLine(ThreadPool.ThreadCount);\r\n\r\nstatic void WarmUpThreadPool(int threads)\r\n{\r\n    ThreadPool.SetMinThreads(threads, threads);\r\n    var tasks = new Task[threads];\r\n    var barrier = new Barrier(threads);\r\n    for (int i = 0; i \u003c tasks.Length; i++) tasks[i] = Task.Run(() =\u003e barrier.SignalAndWait());\r\n    Task.WaitAll(tasks);\r\n}\r\n```",
                                           "updatedAt":  "2021-08-19T16:16:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41xejR",
                                           "createdAt":  "2021-08-19T18:59:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "avparuch",
                                           "body":  "\u003e \u003e Are there other techniques to warm up the thread pool to a certain number of threads\r\n\u003e \r\n\u003e This will force the threadpool to create certain number of threads:\r\n\u003e \r\n\u003e ```cs\r\n\u003e WarmUpThreadPool(100);\r\n\u003e Console.WriteLine(ThreadPool.ThreadCount);\r\n\u003e \r\n\u003e static void WarmUpThreadPool(int threads)\r\n\u003e {\r\n\u003e     ThreadPool.SetMinThreads(threads, threads);\r\n\u003e     var tasks = new Task[threads];\r\n\u003e     var barrier = new Barrier(threads);\r\n\u003e     for (int i = 0; i \u003c tasks.Length; i++) tasks[i] = Task.Run(() =\u003e barrier.SignalAndWait());\r\n\u003e     Task.WaitAll(tasks);\r\n\u003e }\r\n\u003e ```\r\n\r\nThank you, works like a charm!\r\nAlso, I noticed that after X seconds, the threadpool count settles down to an appropriate steady state level. It scales down from the warmed up threadpool count, if there is no work to do. Is there a way to force a minimum number of threads to always be there even if there is no work to do? (in anticipation of future work).",
                                           "updatedAt":  "2021-08-19T18:59:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41xjtG",
                                           "createdAt":  "2021-08-19T19:31:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e  Is there a way to force a minimum number of threads to always be there even if there is no work to do?\r\n\r\nI do not know. @kouvel ?",
                                           "updatedAt":  "2021-08-19T19:31:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41xju2",
                                           "createdAt":  "2021-08-19T19:31:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nI\u0027m trying to set a COMPlus environment variable. https://github.com/steveharter/dotnet_coreclr/blob/master/Documentation/project-docs/clr-configuration-knobs.md\r\n\r\nThis is my code:\r\n\r\n```\r\nusing System;\r\nusing System.Threading;\r\n\r\nnamespace minthreads\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            Environment.SetEnvironmentVariable(\"COMPlus_ThreadPool_ForceMinWorkerThreads\", \"0x32\");\r\n            ThreadPool.GetMinThreads(out int workerThreads, out int ioThreads);\r\n            Console.WriteLine(workerThreads);\r\n            Console.WriteLine(ioThreads);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\nThe workerThreads variable does not return 50. It returns 8, which is the number of processors on my machine. Does this mean coreCLR does not read the environment variables after the application has already started.\r\n\r\nHowever, setting the same environment variable via command line or powershell like this $env:COMPlus_ThreadPool_ForceMinWorkerThreads = \u00270x32\u0027 before the application is started does work: the workerThreads does return 50.\r\n\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eavparuch\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`question`, `area-System.Threading`, `area-VM-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-08-19T19:31:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41xl8n",
                                           "createdAt":  "2021-08-19T19:45:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "@avparuch are you noticing that for your scenario the thread \"creation\" is causing measurable perf degradation after a period of no activity?  ",
                                           "updatedAt":  "2021-08-19T19:45:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41yFbb",
                                           "createdAt":  "2021-08-19T23:38:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "\u003e Is there a way to force a minimum number of threads to always be there even if there is no work to do? (in anticipation of future work).\r\n\r\nThere isn\u0027t a way to force the threads to remain running at the moment. Threads exit after about 20 seconds of being inactive currently.",
                                           "updatedAt":  "2021-08-19T23:38:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41yF_k",
                                           "createdAt":  "2021-08-19T23:43:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "avparuch",
                                           "body":  "\u003e \u003e Is there a way to force a minimum number of threads to always be there even if there is no work to do? (in anticipation of future work).\r\n\u003e \r\n\u003e There isn\u0027t a way to force the threads to remain running at the moment. Threads exit after about 20 seconds of being inactive currently.\r\n\r\nYes, I\u0027m noticing that around 20th second of inactivity, threads exit. Thank you for confirming. ",
                                           "updatedAt":  "2021-08-19T23:43:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41yGuu",
                                           "createdAt":  "2021-08-19T23:52:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "It would probably make sense to keep at least one thread around, though I\u0027m not sure how much it would help. On my Windows machine it takes around 200 us to create a thread and around 5 us to release a waiting thread. It\u0027s a large difference but still may be unnoticeable for latency. Did you find a case where it would help to keep threads around?",
                                           "updatedAt":  "2021-08-19T23:52:40Z"
                                       }
                                   ],
                         "totalCount":  13
                     },
        "title":  "Does setting a COMPlus_ environment variable after the application has already started take effect?",
        "labels":  [
                       "question",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/57751",
        "createdAt":  "2021-08-19T18:15:19Z",
        "number":  57751,
        "author":  "ViktorHofer",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-08-23T16:17:06Z",
        "body":  "Configuration: `net6.0-windows-Release-x86-CoreCLR_release-Windows.7.Amd64.Open`\r\n\r\nConsole: https://helixre8s23ayyeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-heads-main-ba682e275827487daf/System.Threading.Tasks.Tests/1/console.cd7d4d5f.log?sv=2019-07-07\u0026se=2021-09-02T05%3A41%3A20Z\u0026sr=c\u0026sp=rl\u0026sig=3%2BNS2Pg%2BbC3b8eMj8b%2FwjkyfF9OQjb0excO11zGNt5k%3D\r\n\r\nDump: https://helixre8s23ayyeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-heads-main-ba682e275827487daf/System.Threading.Tasks.Tests/1/dotnet.exe.3996.dmp?sv=2019-07-07\u0026se=2021-09-02T05%3A41%3A20Z\u0026sr=c\u0026sp=rl\u0026sig=3%2BNS2Pg%2BbC3b8eMj8b%2FwjkyfF9OQjb0excO11zGNt5k%3D\r\n\r\nBuild: https://dev.azure.com/dnceng/public/_build/results?buildId=1291774\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=38121666\u0026resultId=198580\u0026paneView=dotnet-dnceng.dnceng-build-release-tasks.helix-test-information-tab\r\n\r\n```\r\n  Discovering: System.Threading.Tasks.Tests (method display = ClassAndMethod, method display options = None)\r\n  Discovered:  System.Threading.Tasks.Tests (found 574 of 752 test cases)\r\n  Starting:    System.Threading.Tasks.Tests (parallel test collections = on, max threads = 2)\r\nProcess terminated. Look at the created dump\r\n   at System.Environment.FailFast(System.String)\r\n   at System.Threading.Tasks.Tests.AsyncTaskMethodBuilderTests+\u003cAsyncMethodsDropsStateMachineAndExecutionContextUponCompletion\u003ed__32.MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Threading.Tasks.Tests.AsyncTaskMethodBuilderTests+\u003cAsyncMethodsDropsStateMachineAndExecutionContextUponCompletion\u003ed__32, System.Threading.Tasks.Tests, Version=6.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51]].ExecutionContextCallback(System.Object)\r\n   at System.Threading.ExecutionContext.RunFromThreadPoolDispatchLoop(System.Threading.Thread, System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Threading.Tasks.Tests.AsyncTaskMethodBuilderTests+\u003cAsyncMethodsDropsStateMachineAndExecutionContextUponCompletion\u003ed__32, System.Threading.Tasks.Tests, Version=6.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51]].MoveNext(System.Threading.Thread)\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Threading.Tasks.Tests.AsyncTaskMethodBuilderTests+\u003cAsyncMethodsDropsStateMachineAndExecutionContextUponCompletion\u003ed__32, System.Threading.Tasks.Tests, Version=6.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51]].ExecuteFromThreadPool(System.Threading.Thread)\r\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\r\n   at System.Threading.PortableThreadPool+WorkerThread.WorkerThreadStart()\r\n   at System.Threading.Thread.StartCallback()\r\n----- end Fri 08/13/2021  6:00:45.93 ----- exit code -2146232797 ----------------------------------------------------------\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHONd7pLA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc41xX7A",
                                           "createdAt":  "2021-08-19T18:15:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nConfiguration: `net6.0-windows-Release-x86-CoreCLR_release-Windows.7.Amd64.Open`\r\n\r\nConsole: https://helixre8s23ayyeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-heads-main-ba682e275827487daf/System.Threading.Tasks.Tests/1/console.cd7d4d5f.log?sv=2019-07-07\u0026se=2021-09-02T05%3A41%3A20Z\u0026sr=c\u0026sp=rl\u0026sig=3%2BNS2Pg%2BbC3b8eMj8b%2FwjkyfF9OQjb0excO11zGNt5k%3D\r\n\r\nDump: https://helixre8s23ayyeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-heads-main-ba682e275827487daf/System.Threading.Tasks.Tests/1/dotnet.exe.3996.dmp?sv=2019-07-07\u0026se=2021-09-02T05%3A41%3A20Z\u0026sr=c\u0026sp=rl\u0026sig=3%2BNS2Pg%2BbC3b8eMj8b%2FwjkyfF9OQjb0excO11zGNt5k%3D\r\n\r\nBuild: https://dev.azure.com/dnceng/public/_build/results?buildId=1291774\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=38121666\u0026resultId=198580\u0026paneView=dotnet-dnceng.dnceng-build-release-tasks.helix-test-information-tab\r\n\r\n```\r\n  Discovering: System.Threading.Tasks.Tests (method display = ClassAndMethod, method display options = None)\r\n  Discovered:  System.Threading.Tasks.Tests (found 574 of 752 test cases)\r\n  Starting:    System.Threading.Tasks.Tests (parallel test collections = on, max threads = 2)\r\nProcess terminated. Look at the created dump\r\n   at System.Environment.FailFast(System.String)\r\n   at System.Threading.Tasks.Tests.AsyncTaskMethodBuilderTests+\u003cAsyncMethodsDropsStateMachineAndExecutionContextUponCompletion\u003ed__32.MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Threading.Tasks.Tests.AsyncTaskMethodBuilderTests+\u003cAsyncMethodsDropsStateMachineAndExecutionContextUponCompletion\u003ed__32, System.Threading.Tasks.Tests, Version=6.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51]].ExecutionContextCallback(System.Object)\r\n   at System.Threading.ExecutionContext.RunFromThreadPoolDispatchLoop(System.Threading.Thread, System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Threading.Tasks.Tests.AsyncTaskMethodBuilderTests+\u003cAsyncMethodsDropsStateMachineAndExecutionContextUponCompletion\u003ed__32, System.Threading.Tasks.Tests, Version=6.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51]].MoveNext(System.Threading.Thread)\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Threading.Tasks.Tests.AsyncTaskMethodBuilderTests+\u003cAsyncMethodsDropsStateMachineAndExecutionContextUponCompletion\u003ed__32, System.Threading.Tasks.Tests, Version=6.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51]].ExecuteFromThreadPool(System.Threading.Thread)\r\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\r\n   at System.Threading.PortableThreadPool+WorkerThread.WorkerThreadStart()\r\n   at System.Threading.Thread.StartCallback()\r\n----- end Fri 08/13/2021  6:00:45.93 ----- exit code -2146232797 ----------------------------------------------------------\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eViktorHofer\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-08-19T18:15:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41xd-y",
                                           "createdAt":  "2021-08-19T18:55:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOB3HEsA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "adamsitnik",
                                                                               "createdAt":  "2021-08-20T05:09:54Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "I\u0027ve tried multiple times to make this test reliable, and apparently still have not succeeded.  Invariably I end up debugging a dump that shows the object is unreachable but not yet finalized.  Will just disable it for now.",
                                           "updatedAt":  "2021-08-19T18:55:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41yhNO",
                                           "createdAt":  "2021-08-20T05:11:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "@stephentoub have you tried to repro https://github.com/dotnet/runtime/issues/57331 ? Should we disable it as well?",
                                           "updatedAt":  "2021-08-20T05:11:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41zCMe",
                                           "createdAt":  "2021-08-20T09:41:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ViktorHofer",
                                           "body":  "Happened again in https://dev.azure.com/dnceng/public/_build/results?buildId=1301031\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=38343962\u0026resultId=198394\u0026paneView=dotnet-dnceng.dnceng-build-release-tasks.helix-test-information-tab.",
                                           "updatedAt":  "2021-08-20T09:41:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc410dFS",
                                           "createdAt":  "2021-08-20T20:35:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Happened again\r\n\r\nIt\u0027s been disabled.  Presumably this run is just from before that happened?",
                                           "updatedAt":  "2021-08-20T20:35:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc410dJY",
                                           "createdAt":  "2021-08-20T20:35:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e have you tried to repro #57331 ? Should we disable it as well?\r\n\r\nThat\u0027s likely a similar cause; I\u0027ve been unable to make either of these stable, for unknown reasons.  I can disable it as well.",
                                           "updatedAt":  "2021-08-20T20:35:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc413rPk",
                                           "createdAt":  "2021-08-23T13:49:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ViktorHofer",
                                           "body":  "\u003e It\u0027s been disabled. Presumably this run is just from before that happened?\r\n\r\nThe test ran on \"8/18/2021, 12:57:36 PM\" (main).",
                                           "updatedAt":  "2021-08-23T13:49:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc413uks",
                                           "createdAt":  "2021-08-23T14:02:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOB3Ycpw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ViktorHofer",
                                                                               "createdAt":  "2021-08-23T14:25:53Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "And it was disabled on the 19th.",
                                           "updatedAt":  "2021-08-23T14:02:23Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "System.Threading.Tasks.Tests FailFast",
        "labels":  [
                       "area-System.Threading",
                       "disabled-test"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/58050",
        "createdAt":  "2021-08-24T18:07:07Z",
        "number":  58050,
        "author":  "CeSun",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-08-09T02:53:32Z",
        "body":  "I am a C++ programmer, mainly developing stateful services. In C++, I use the network to drive asynchronous callback functions. The program is single-threaded.\nBut the callback is really annoyed.\nSo I want to use c# to do this work and replace the callback function with await/async.\n\nThe default c# coroutine will take idle threads from the thread pool to run, but I want to run the coroutines on a single thread to ensure the safety of critical resources.\n\nI did the following:\n\nhttps://github.com/CeSun/Server/blob/master/Frame/SingleThreadSynchronizationContext.cs\n\n```\nvoid Main(string[] args)\n{\n   var ctx = new SingleThreadSynchronizationContext();\n   SynchronizationContext.SetCurrentContext(ctx);\n   ctx.RunNew(() =\u003e {\n      _ = MainSync();\n   });\n   while(true)\n   {\n       ctx.Run();\n    }\n}\n\nTask MainSync()\n{\n    \n     \n}\n\n```\n\nThe Run function only takes 10 to 20 functions to execute in order to guarantee the number of cycles per second.  I will do some update operations before the loop starts. For example, the timer may need to be updated here.\n\nBut the final performance is not high, I want to know if it is written incorrectly and does not meet the specifications.  The server QPS is only 60...",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOY5L_Nw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc417xjy",
                                           "createdAt":  "2021-08-24T18:07:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nI am a C++ programmer, mainly developing stateful services. In C++, I use the network to drive asynchronous callback functions. The program is single-threaded.\nBut the callback is really annoyed.\nSo I want to use c# to do this work and replace the callback function with await/async.\n\nThe default c# coroutine will take idle threads from the thread pool to run, but I want to run the coroutines on a single thread to ensure the safety of critical resources.\n\nI did the following:\n\nhttps://github.com/CeSun/Server/blob/master/Frame/SingleThreadSynchronizationContext.cs\n\n```\nvoid Main(string[] args)\n{\n   var ctx = new SingleThreadSynchronizationContext();\n   SynchronizationContext.SetCurrentContext(ctx);\n   ctx.RunNew(() =\u003e {\n      _ = MainSync();\n   });\n   while(true)\n   {\n       ctx.Run();\n    }\n}\n\nTask MainSync()\n{\n    \n     \n}\n\n```\n\nThe Run function only takes 10 to 20 functions to execute in order to guarantee the number of cycles per second.  I will do some update operations before the loop starts. For example, the timer may need to be updated here.\n\nBut the final performance is not high, I want to know if it is written incorrectly and does not meet the specifications.  The server QPS is only 60...\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eCeSun\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-08-24T18:07:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Es9pa",
                                           "createdAt":  "2022-06-10T18:43:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CeSun",
                                           "body":  "Is there any progress?",
                                           "updatedAt":  "2022-06-10T18:43:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5jkv83",
                                           "createdAt":  "2023-08-09T02:53:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "\u003e but I want to run the coroutines on a single thread to ensure the safety of critical resources.\r\n\r\n\u003e The server QPS is only 60...\r\n\r\nI believe this is actually the reason. Cross-thread scheduling is costful.",
                                           "updatedAt":  "2023-08-09T02:53:32Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "How to let coroutine on a single thread",
        "labels":  [
                       "question",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/59639",
        "createdAt":  "2021-09-27T08:31:16Z",
        "number":  59639,
        "author":  "Dolfik1",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODEUSNQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2025-06-19T20:11:15Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2023-03-16T19:36:20Z",
        "body":  "\u003c!--This is just a template - feel free to delete any and all of it and replace as appropriate.--\u003e\r\n\r\n### Description\r\n\r\nSemaphoreSlim\u0027s method `WaitAsync(CancellationToken)` will never finished if semaphore is disposed immediately after `Cancel`:\r\n\r\n```csharp\r\nclass Program\r\n{\r\n    static async Task\u003cint\u003e Main(string[] args)\r\n    {\r\n        var semaphore = new SemaphoreSlim(0, 1);\r\n        var cts = new CancellationTokenSource();\r\n\r\n        var timer = new System.Timers.Timer(1000);\r\n\r\n        timer.Elapsed += (sender, _) =\u003e\r\n        {\r\n            Console.WriteLine(\"Cancelling...\");\r\n            cts.Cancel();\r\n\r\n            Console.WriteLine(\"Disposing...\");\r\n            semaphore.Dispose();\r\n\r\n        };\r\n\r\n        timer.AutoReset = false;\r\n        timer.Start();\r\n        \r\n        Console.WriteLine(\"Waiting...\");\r\n        await semaphore.WaitAsync(cts.Token);\r\n        \r\n        Console.WriteLine(\"Hello World!\");\r\n        return 0;\r\n    }\r\n}\r\n```\r\n#### Expected behavior\r\nThe program is finished with `System.OperationCanceledException`.\r\n\r\n#### Actual behavoir\r\nThe program is never finished.\r\n\r\n\r\n### Configuration\r\n\r\n* .Net Core 3.1 / .Net 5.0 / .Net 6.0\r\n* macOS Big Sur / Windows 10\r\n\r\n### Regression?\r\n\r\nThis code works fine on .Net Framework 4.7.2. The program crashes with `System.OperationCanceledException`.\r\n\r\n### Workaround\r\n\r\nInvoke `.Dispose` method  after `.Cancel` with some delay.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOV8aaIQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc43Ssz6",
                                           "createdAt":  "2021-09-27T08:31:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n\u003c!--This is just a template - feel free to delete any and all of it and replace as appropriate.--\u003e\r\n\r\n### Description\r\n\r\nSemaphoreSlim\u0027s method `WaitAsync(CancellationToken)` will never finished if semaphore is disposed immediately after `Cancel`:\r\n\r\n```csharp\r\nclass Program\r\n{\r\n    static async Task\u003cint\u003e Main(string[] args)\r\n    {\r\n        var semaphore = new SemaphoreSlim(0, 1);\r\n        var cts = new CancellationTokenSource();\r\n\r\n        var timer = new System.Timers.Timer(1000);\r\n\r\n        timer.Elapsed += (sender, _) =\u003e\r\n        {\r\n            Console.WriteLine(\"Cancelling...\");\r\n            cts.Cancel();\r\n\r\n            Console.WriteLine(\"Disposing...\");\r\n            semaphore.Dispose();\r\n\r\n        };\r\n\r\n        timer.AutoReset = false;\r\n        timer.Start();\r\n        \r\n        Console.WriteLine(\"Waiting...\");\r\n        await semaphore.WaitAsync(cts.Token);\r\n        \r\n        Console.WriteLine(\"Hello World!\");\r\n        return 0;\r\n    }\r\n}\r\n```\r\n#### Expected behavior\r\nThe program is finished with `System.OperationCanceledException`.\r\n\r\n#### Actual behavoir\r\nThe program is never finished.\r\n\r\n\r\n### Configuration\r\n\r\n* .Net Core 3.1 / .Net 5.0 / .Net 6.0\r\n* macOS Big Sur / Windows 10\r\n\r\n### Regression?\r\n\r\nThis code works fine on .Net Framework 4.7.2. The program crashes with `System.OperationCanceledException`.\r\n\r\n### Workaround\r\n\r\nInvoke `.Dispose` method  after `.Cancel` with some delay.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eDolfik1\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-09-27T08:31:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43Te-T",
                                           "createdAt":  "2021-09-27T13:05:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "`Dispose` on `SemaphoreSlim` is not thread-safe.\r\n\r\nSee https://docs.microsoft.com/en-us/dotnet/api/system.threading.semaphoreslim?view=net-5.0#thread-safety\r\n\r\n\u003e All public and protected members of SemaphoreSlim are thread-safe and may be used concurrently from multiple threads, with the exception of Dispose(), which must be used only when all other operations on the SemaphoreSlim have completed.\r\n\r\nLooking at the code, I suspect this happens because `Dispose` [nulls out the linked list of waiters](https://github.com/dotnet/runtime/blob/0c0bd5a4066bc9b1a165a45e3553dfa14b87729b/src/libraries/System.Private.CoreLib/src/System/Threading/SemaphoreSlim.cs#L896-L897) and then `WaitAsync` [doesn\u0027t see the waiter in the list](https://github.com/dotnet/runtime/blob/0c0bd5a4066bc9b1a165a45e3553dfa14b87729b/src/libraries/System.Private.CoreLib/src/System/Threading/SemaphoreSlim.cs#L728). Thinking it was just removed, it then [waits on a task that can never be completed](https://github.com/dotnet/runtime/blob/0c0bd5a4066bc9b1a165a45e3553dfa14b87729b/src/libraries/System.Private.CoreLib/src/System/Threading/SemaphoreSlim.cs#L735-L737).\r\n\r\nWhile this is documented, is there a reason we couldn\u0027t make it thread-safe instead by signaling all waiters with an `ObjectDisposedException` instead of forgetting them? @stephentoub \r\n",
                                           "updatedAt":  "2021-09-27T13:05:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43ZG4w",
                                           "createdAt":  "2021-09-28T15:16:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e While this is documented, is there a reason we couldn\u0027t make it thread-safe instead by signaling all waiters with an ObjectDisposedException instead of forgetting them?\r\n\r\nI don\u0027t see a reason we \"couldn\u0027t\".  The question would be whether we want to pay the extra cost of taking the lock in order to improve erroneous usage.",
                                           "updatedAt":  "2021-09-28T15:16:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Xxpoh",
                                           "createdAt":  "2023-03-16T19:36:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jasonswearingen",
                                           "body":  "I am also seeing this behavior on `Net7`.   I am very fortunate to have found this issue quickly via web search.\r\n\r\nNot disposing the `SemaphoreSlim` causes the expected (desired) behavior.",
                                           "updatedAt":  "2023-03-16T19:36:20Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "SemaphoreSlim.WaitAsync(CancellationToken) is not cancelled when SemaphoreSlim.Dispose invoked immediately after CancellationTokenSource.Cancel",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/59866",
        "createdAt":  "2021-10-01T16:55:59Z",
        "number":  59866,
        "author":  "Therzok",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCx_9NQ==",
                          "nodes":  [
                                        {
                                            "content":  "HEART",
                                            "user":  "sandyarmstrong",
                                            "createdAt":  "2022-05-13T17:40:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MineCake147E",
                                            "createdAt":  "2023-08-17T04:58:10Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2023-06-23T20:27:57Z",
        "body":  "### Description\r\n\r\nOpening as a performance issue first, because I\u0027m not sure about all the API changes required to get the machinery setup in dotnet, since this would leak into Task APIs since it\u0027s at its core a threading API setting.\r\n\r\nThe issue generally refers to asymmetrical cores (specifically macOS M1), where the cores used to compute work differ based on the quality of service marked on the scheduled work. See [apple docs](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/power_efficiency_guidelines_osx/PrioritizeWorkAtTheTaskLevel.html), specifically the posix extension `pthread_set_qos_class_self_np` introduced in macOS 10.10. There might be equivalent in other targets, but I have not done enough research on that end.\r\n\r\nThe lack of a way to set this from a dotnet API point means that user-submitted work on the dotnet threadpool can\u0027t be marked as such, so users have to setup a dedicated threadpool implementation that submits items to these core on macOS.\r\n\r\n\u003e Subsequent calls to interfaces such as pthread_setschedparam() that are\r\n\u003e incompatible or in conflict with the QOS class system will unset the QOS\r\n\u003e class requested with this interface and pthread_get_qos_class_np() will\r\n\u003e return QOS_CLASS_UNSPECIFIED thereafter. A thread so modified is permanently\r\n\u003e opted-out of the QOS class system and calls to this function to request a QOS\r\n\u003e class for such a thread will fail and return EPERM.\r\n\r\nThe problem is that without these parameters, there is no way to prioritize scheduled work in an energy-efficient context - i.e. laptop on battery - or efficiently using asymmetrical cores.\r\n\r\n### Configuration\r\n\r\nmacOS M1, but might appear on other configurations\r\n\r\n### Regression?\r\n\r\nNot a regression, since there is no way to currently do this unless you avoid dotnet APIs for work item scheduling.\r\n\r\n### Data\r\n\r\nIf needed, I could run some benchmarks with `powermetrics` on native apps that properly schedule work, which would confirm the above hypothesis, if documentation is not enough to confirm.\r\n\r\n### Analysis\r\n\r\n[pthread_setschedparam](https://github.com/dotnet/runtime/blob/dff742a06bb19fbb1a0ccfdefb14eb5379da3742/src/coreclr/pal/src/thread/thread.cpp#L1190) seems to be called here in the runtime, and there\u0027s no priority level surfaced on the [managed APIs](https://github.com/dotnet/runtime/blob/4419d2757100affa1b5ee33564f79c376c3055e4/src/libraries/System.Diagnostics.Process/src/System/Diagnostics/ProcessThread.OSX.cs#L18). So the threadpool threads can\u0027t be used as quality of service tasks, based on the documentation above.\r\n\r\nThat means that the only way to do this is to use native scheduling APIs and avoid any dotnet threadpool usage. That means a custom threadpool needs to be implemented and scheduling would be done via custom APIs - macOS has a threadpool implementation in libdispatch.\r\n\r\nIf we go down this path, we need to define an ExecutionContext to run Task continuations on via SynchronizationContext or any other means. Without it, `await WorkAsync()` would fallback to the default dotnet threadpool.\r\n\r\nThings get tricky when we start using library code, as most of the libraries mark awaited Tasks with `ConfigureAwait(continueOnCapturedContext: false)`. As a result, continuations run on the dotnet threadpool anyway, discarding any quality of service setup that has been done.\r\n\r\nIn short, I think this makes it impossible for quality of service to be implemented on the user-side without runtime support, so the runtime must have some baked-in support for efficient asymmetrical core usage.\r\n\r\n### Asks and problems related to asks\r\n\r\nThe threadpool and possibly Task APIs should support quality of service on systems that have this functionality.\r\n\r\n* Problem 1: non-asymmetrical platforms do not have an equivalent, so this might be redundant for those platforms\r\n* Problem 2: how is this scheduling information preserved, especially in the case of non-captured context continuations\r\n\r\n### Use-cases\r\n\r\nThese examples are tailored for Visual Studio for Mac.\r\n\r\nWhen computing the typesystem for a project, without a cache and no priority set, the M1 battery can be drained fairly quickly, as the operation is resource intensive. When not connected to a power source, a `background` quality of service would ensure the operation would be processed slower, at a lower energy cost.\r\n\r\nWhen editing a file, auto-completion items should quickly presented to the user, so background work done to compute them could be marked as `utility` or `user-initiated`, running on the higher performance cores.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOVNQnwA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc43kzAO",
                                           "createdAt":  "2021-10-01T16:56:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-10-01T16:56:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43k9Bl",
                                           "createdAt":  "2021-10-01T17:47:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "svick",
                                           "body":  ".Net does expose [the `Thread.Priority` property](https://docs.microsoft.com/en-us/dotnet/api/system.threading.thread.priority?view=net-5.0\u0026WT.mc_id=DOP-MVP-5002735), would it make sense to map these priorities to Apple\u0027s QoS classes, instead of exposing a new API?\r\n\r\nThough that doesn\u0027t really address scheduling QoS tasks on the ThreadPool, since you shouldn\u0027t modify the `Priority` of ThreadPool threads.",
                                           "updatedAt":  "2021-10-01T17:47:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43k-jr",
                                           "createdAt":  "2021-10-01T17:57:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\nOpening as a performance issue first, because I\u0027m not sure about all the API changes required to get the machinery setup in dotnet, since this would leak into Task APIs since it\u0027s at its core a threading API setting.\r\n\r\nThe issue generally refers to asymmetrical cores (specifically macOS M1), where the cores used to compute work differ based on the quality of service marked on the scheduled work. See [apple docs](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/power_efficiency_guidelines_osx/PrioritizeWorkAtTheTaskLevel.html), specifically the posix extension `pthread_set_qos_class_self_np` introduced in macOS 10.10. There might be equivalent in other targets, but I have not done enough research on that end.\r\n\r\nThe lack of a way to set this from a dotnet API point means that user-submitted work on the dotnet threadpool can\u0027t be marked as such, so users have to setup a dedicated threadpool implementation that submits items to these core on macOS.\r\n\r\n\u003e Subsequent calls to interfaces such as pthread_setschedparam() that are\r\n\u003e incompatible or in conflict with the QOS class system will unset the QOS\r\n\u003e class requested with this interface and pthread_get_qos_class_np() will\r\n\u003e return QOS_CLASS_UNSPECIFIED thereafter. A thread so modified is permanently\r\n\u003e opted-out of the QOS class system and calls to this function to request a QOS\r\n\u003e class for such a thread will fail and return EPERM.\r\n\r\nThe problem is that without these parameters, there is no way to prioritize scheduled work in an energy-efficient context - i.e. laptop on battery - or efficiently using asymmetrical cores.\r\n\r\n### Configuration\r\n\r\nmacOS M1, but might appear on other configurations\r\n\r\n### Regression?\r\n\r\nNot a regression, since there is no way to currently do this unless you avoid dotnet APIs for work item scheduling.\r\n\r\n### Data\r\n\r\nIf needed, I could run some benchmarks with `powermetrics` on native apps that properly schedule work, which would confirm the above hypothesis, if documentation is not enough to confirm.\r\n\r\n### Analysis\r\n\r\n[pthread_setschedparam](https://github.com/dotnet/runtime/blob/dff742a06bb19fbb1a0ccfdefb14eb5379da3742/src/coreclr/pal/src/thread/thread.cpp#L1190) seems to be called here in the runtime, and there\u0027s no priority level surfaced on the [managed APIs](https://github.com/dotnet/runtime/blob/4419d2757100affa1b5ee33564f79c376c3055e4/src/libraries/System.Diagnostics.Process/src/System/Diagnostics/ProcessThread.OSX.cs#L18). So the threadpool threads can\u0027t be used as quality of service tasks, based on the documentation above.\r\n\r\nThat means that the only way to do this is to use native scheduling APIs and avoid any dotnet threadpool usage. That means a custom threadpool needs to be implemented and scheduling would be done via custom APIs - macOS has a threadpool implementation in libdispatch.\r\n\r\nIf we go down this path, we need to define an ExecutionContext to run Task continuations on via SynchronizationContext or any other means. Without it, `await WorkAsync()` would fallback to the default dotnet threadpool.\r\n\r\nThings get tricky when we start using library code, as most of the libraries mark awaited Tasks with `ConfigureAwait(continueOnCapturedContext: false)`. As a result, continuations run on the dotnet threadpool anyway, discarding any quality of service setup that has been done.\r\n\r\nIn short, I think this makes it impossible for quality of service to be implemented on the user-side without runtime support, so the runtime must have some baked-in support for efficient asymmetrical core usage.\r\n\r\n### Asks and problems related to asks\r\n\r\nThe threadpool and possibly Task APIs should support quality of service on systems that have this functionality.\r\n\r\n* Problem 1: non-asymmetrical platforms do not have an equivalent, so this might be redundant for those platforms\r\n* Problem 2: how is this scheduling information preserved, especially in the case of non-captured context continuations\r\n\r\n### Use-cases\r\n\r\nThese examples are tailored for Visual Studio for Mac.\r\n\r\nWhen computing the typesystem for a project, without a cache and no priority set, the M1 battery can be drained fairly quickly, as the operation is resource intensive. When not connected to a power source, a `background` quality of service would ensure the operation would be processed slower, at a lower energy cost.\r\n\r\nWhen editing a file, auto-completion items should quickly presented to the user, so background work done to compute them could be marked as `utility` or `user-initiated`, running on the higher performance cores.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eTherzok\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `tenet-performance`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-10-01T17:57:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43m-be",
                                           "createdAt":  "2021-10-03T14:34:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Therzok",
                                           "body":  "@svick On macOS, the implementation here does mention that as a possibility:\r\nhttps://github.com/dotnet/runtime/blob/main/src/libraries/System.Diagnostics.Process/src/System/Diagnostics/ProcessThread.OSX.cs#L18\r\n\r\nPriority and QoS are orthogonal concepts, the way I see it, one is work unit allocation scheduling, the other is CPU core scheduling, mapping them to the current Priority values could cause side effects on the qos axis",
                                           "updatedAt":  "2021-10-03T14:34:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5BTzRl",
                                           "createdAt":  "2022-04-11T23:58:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Simonl9l",
                                           "body":  "As a solution developer who happens to be using an M1 Pro, that is developing something that performs intensive multi-concurrent task processing this seems to be a major architecture support issue for the dotnet runtime. \r\n\r\nThe solution we have under development is (by intention) intended to leverage all the cores of what ever system it\u0027s running on, inc the M1 (Max/Pro/Ultra) using the default tread poo. It is very frustrating that it seem to be neigh on impossible to leverage the capabilities of the Apple Silicon performance cores.\r\n\r\nAs it stands any awaited Task\u0027s _seem_ to _only_ get scheduled to the efficiency cores and the other (8x  per M1-Pro/Max) performance cores sit mostly idle. \r\n\r\nThis issue as opened seems have sat here for months, and whilst it is flagged on a 7.0 milestone, show not apparent active work? \r\n\r\nAre there still plans to directly support the Apple Silicon asymmetric core architecture, and how is it possible to create more transparency to progress of resolving this? \r\n\r\nAlso as indicated in the original post, it would be great if we (as developers) did not have to do anything specific to enable any better task scheduling solution for this architecture and the runtime just did the right thing!\r\n\r\nIn reference to the processing solution under development, other similar architectures that are non Apple Silicon running the same code in our implementation can process ~270,000 tasks/sec whereas on the M1-Max its a paltry ~1,500 tasks/sec.\r\n\r\nRight now it seem that dotnet is not a realistic platform to develop/run any multi concurrent task centric solutions that are targeted at Apple Silicon. I\u0027m pretty sure there there may be quite a few others also having this issue, and it begs the question of how many will ditch do-net as a result? \r\n\r\nI\u0027m happy to hold my breath for now...and hope to see more updates soon!\r\n\r\nAlso seems this issue is related - https://github.com/dotnet/runtime/issues/65659\r\n\r\nShould/can this issue be added here [Enable .NET Core on Apple Silicon](https://github.com/orgs/dotnet/projects/18#card-58204786)",
                                           "updatedAt":  "2022-04-12T00:17:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5BY2RV",
                                           "createdAt":  "2022-04-12T18:05:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "\u003e As it stands any awaited Task\u0027s seem to only get scheduled to the efficiency cores and the other (8x per M1-Pro/Max) performance cores sit mostly idle.\r\n\r\nthis seems interesting. Do you have a repro for this? cc @kouvel @janvorli ",
                                           "updatedAt":  "2022-04-12T18:06:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5U1CfA",
                                           "createdAt":  "2023-02-08T20:20:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "I\u0027ve confirmed that the [pthread_setschedparam call here](https://github.com/dotnet/runtime/blob/dff742a06bb19fbb1a0ccfdefb14eb5379da3742/src/coreclr/pal/src/thread/thread.cpp#L1190) causes worker threads to be opted out of QoS, reporting a QoS level of Unspecified. Without it, the threads would have a QoS level of Default. Should probably fix that.\r\n\r\n\u003e As it stands any awaited Task\u0027s _seem_ to _only_ get scheduled to the efficiency cores and the other (8x  per M1-Pro/Max) performance cores sit mostly idle.\r\n\u003e In reference to the processing solution under development, other similar architectures that are non Apple Silicon running the same code in our implementation can process ~270,000 tasks/sec whereas on the M1-Max its a paltry ~1,500 tasks/sec.\r\n\r\nOn an Apple M1 (lab machine, plugged in), CPU-intensive work seems to be scheduled on performance cores with either Default or Unspecified QoS level. I\u0027m not sure if there would be a difference if running on battery, but it would be surprising to me if a thread with Unspecified QoS level that is doing sufficient CPU-intensive work does not get scheduled on performance cores. A repro would be helpful to understand what is happening here.",
                                           "updatedAt":  "2023-02-08T20:20:23Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "Support for asymmetrical core energy efficiency",
        "labels":  [
                       "area-System.Threading",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/60336",
        "createdAt":  "2021-10-13T12:27:43Z",
        "number":  60336,
        "author":  "kefyru",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-07-06T17:06:32Z",
        "body":  "Add attribute ```[SyncContext(contextName)]``` for fields, properties and methods\r\nCompiler will check if member with this attribute using outside ```lock(context) {...}```  block than cause warning ```member should use inside lock(contextName) block```\r\n\r\nExample\r\n```C#\r\npublic class ConsumerProducer\u003cTP, TResult\u003e\r\nwhere TP : IProducer\u003cTResult\u003e // implements Task\u003cTResult\u003e GetResult(object arg) for example\r\n {\r\n    private object _syncContext = new object();\r\n\r\n    [SyncContext(nameof(_syncContext))] // should use in lock(_syncContext) block, or get warning\r\n    private Stack\u003cTP\u003e _pool = new();\r\n\r\n    [SyncContext(nameof(_syncContext))] // should use in lock(_syncContext) block, or get warning\r\n    private Queue\u003c(object arg, TaskCompletionSource\u003cTResult\u003e tcs)\u003e _queue = new();\r\n    \r\n    // process queue\r\n    private void Process() \r\n    {\r\n       (object arg, TaskCompletionSource\u003cTResult\u003e tcs)? consumer;\r\n       TP? producer;\r\n\r\n       lock(_syncContext) {         \r\n          if (_pool.Count * _queue.Count == 0) return;\r\n          // other thread can make _queue or _pool empty here\r\n          // if _queue or _pool using outside lock(_syncContext) block\r\n          consumer = _queue.Dequeue(); // exception if _queue is empty \r\n          producer = _pool.Pop();  //  exception if _pool is empty\r\n       }\r\n \r\n       producer.GetResult(consumer.arg).ContinueWith(task =\u003e {\r\n            consumer.tcs.SetResult(task.Result);\r\n            _pool.Push(producer);  // Compiler warning: _pool should use with lock(_syncContext)\r\n           Process();\r\n       })\r\n    }\r\n    \r\n    // return result or put to queue\r\n    public Task\u003cTResult\u003e GetResult(object arg) \r\n    {\r\n       var tcs = new TaskCompletionSource\u003cTResult\u003e();\r\n       (object arg, TaskCompletionSource\u003cTResult\u003e tcs) consumer = new (arg, tcs); \r\n        _queue.Enqueue(consumer);  // Compiler warning: _queue should use with lock(_syncContext)\r\n       return tcs.Task;\r\n    }\r\n}\r\n\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOOCsqFQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc44KayF",
                                           "createdAt":  "2021-10-13T12:31:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nAdd attribute ```[SyncContext(contextName)]``` for fields, properties and methods\r\nCompiler will check if member with this attribute using outside ```lock(context) {...}```  block than cause warning ```member should use inside lock(contextName) block```\r\n\r\nExample\r\n```C#\r\npublic class ConsumerProducer\u003cTP, TResult\u003e\r\nwhere TP : IProducer\u003cTResult\u003e // implements Task\u003cTResult\u003e GetResult(object arg) for example\r\n {\r\n    private object _syncContext = new object();\r\n\r\n    [SyncContext(nameof(_syncContext))] // should use in lock(_syncContext) block, or get warning\r\n    private Stack\u003cTP\u003e _pool = new();\r\n\r\n    [SyncContext(nameof(_syncContext))] // should use in lock(_syncContext) block, or get warning\r\n    private Queue\u003c(object arg, TaskCompletionSource\u003cTResult\u003e tcs)\u003e _queue = new();\r\n    \r\n    // process queue\r\n    private void Process() \r\n    {\r\n       (object arg, TaskCompletionSource\u003cTResult\u003e tcs)? consumer;\r\n       TP? producer;\r\n\r\n       lock(_syncContext) {         \r\n          if (_pool.Count * _queue.Count == 0) return;\r\n          // other thread can make _queue or _pool empty here\r\n          // if _queue or _pool using outside lock(_syncContext) block\r\n          consumer = _queue.Dequeue(); // exception if _queue is empty \r\n          producer = _pool.Pop();  //  exception if _pool is empty\r\n       }\r\n \r\n       producer.GetResult(consumer.arg).ContinueWith(task =\u003e {\r\n            consumer.tcs.SetResult(task.Result);\r\n            _pool.Push(producer);  // Compiler warning: _pool should use with lock(_syncContext)\r\n           Process();\r\n       })\r\n    }\r\n    \r\n    // return result or put to queue\r\n    public Task\u003cTResult\u003e GetResult(object arg) \r\n    {\r\n       var tcs = new TaskCompletionSource\u003cTResult\u003e();\r\n       (object arg, TaskCompletionSource\u003cTResult\u003e tcs) consumer = new (arg, tcs); \r\n        _queue.Enqueue(consumer);  // Compiler warning: _queue should use with lock(_syncContext)\r\n       return tcs.Task;\r\n    }\r\n}\r\n\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ekefyru\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-10-13T12:31:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc44KyoV",
                                           "createdAt":  "2021-10-13T14:16:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOB-YI6A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "huoyaoyuan",
                                                                               "createdAt":  "2021-10-13T16:10:15Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkoritzinsky",
                                                                               "createdAt":  "2021-10-13T17:57:07Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "SingleAccretion",
                                                                               "createdAt":  "2021-10-13T21:28:51Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pinkfloydx33",
                                                                               "createdAt":  "2021-10-14T09:28:03Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "vcsjones",
                                                                               "createdAt":  "2021-10-14T19:57:06Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  5
                                                         },
                                           "author":  "svick",
                                           "body":  "Why should this be part of the runtime/compiler, when it could be a 3rd party Roslyn analyzer instead?",
                                           "updatedAt":  "2021-10-13T14:16:20Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[SyncContext(contextName)]",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/61308",
        "createdAt":  "2021-11-06T01:49:57Z",
        "number":  61308,
        "author":  "Xyncgas",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-11-10T02:19:27Z",
        "body":  "I want to keep talking about this issue.\r\nIt\u0027s in my opinion a bug, hear me out.\r\nWe can\u0027t pause a thread in blazor because it\u0027s running on one thread and it\u0027s async all the way that was the decision.\r\n\r\nbut, this affects the portability of codes, even when they followed best practice, while they can target .net standard 2.0 - mono.wasm - blazor they are still going to break.\r\n\r\nhow about we fix this by, in my opinion I propose defining what happens when you call .wait() either : block the running thread and let people intentionally make this trade off, or making blazor multi-threaded, or simulate async behavior by forcing it to yield control after timeout that\u0027s decided by the .net rt",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOOX104g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc45XJO0",
                                           "createdAt":  "2021-11-06T01:50:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Xyncgas",
                                           "body":  "I have to maintain two code base now just because my libraries contains Parallel.For which apparently uses Task.wait().\r\nplease take this seriously folks",
                                           "updatedAt":  "2021-11-06T01:51:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc45Z9vz",
                                           "createdAt":  "2021-11-08T12:34:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "javiercn",
                                           "body":  "@Xyncgas thanks for contacting us.\r\n\r\nThe browser is a single threaded runtime (except for wasm threads that are not widely supported on all platforms). If a library blocks the main thread, there\u0027s no additional thread where work can resume and unblock the blocked thread.\r\n\r\nThis is not a decision that we made, it\u0027s a limitation imposed by the environment.",
                                           "updatedAt":  "2021-11-08T12:34:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc45Z9zN",
                                           "createdAt":  "2021-11-08T12:35:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nI want to keep talking about this issue.\r\nIt\u0027s in my opinion a bug, hear me out.\r\nWe can\u0027t pause a thread in blazor because it\u0027s running on one thread and it\u0027s async all the way that was the decision.\r\n\r\nbut, this affects the portability of codes, even when they followed best practice, while they can target .net standard 2.0 - mono.wasm - blazor they are still going to break.\r\n\r\nhow about we fix this by, in my opinion I propose defining what happens when you call .wait() either : block the running thread and let people intentionally make this trade off, or making blazor multi-threaded, or simulate async behavior by forcing it to yield control after timeout that\u0027s decided by the .net rt\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eXyncgas\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-11-08T12:35:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc45fXTi",
                                           "createdAt":  "2021-11-09T20:37:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to \u0027arch-wasm\u0027: @lewing\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nI want to keep talking about this issue.\r\nIt\u0027s in my opinion a bug, hear me out.\r\nWe can\u0027t pause a thread in blazor because it\u0027s running on one thread and it\u0027s async all the way that was the decision.\r\n\r\nbut, this affects the portability of codes, even when they followed best practice, while they can target .net standard 2.0 - mono.wasm - blazor they are still going to break.\r\n\r\nhow about we fix this by, in my opinion I propose defining what happens when you call .wait() either : block the running thread and let people intentionally make this trade off, or making blazor multi-threaded, or simulate async behavior by forcing it to yield control after timeout that\u0027s decided by the .net rt\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eXyncgas\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`arch-wasm`, `area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-11-09T20:37:58Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Blazor WebAssembly Error : Cannot wait on monitors on this runtime. ",
        "labels":  [
                       "arch-wasm",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/63535",
        "createdAt":  "2022-01-08T09:50:18Z",
        "number":  63535,
        "author":  "HighPerfDotNet",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODBvCRg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "GSPP",
                                            "createdAt":  "2022-02-14T13:08:17Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jhudsoncedaron",
                                            "createdAt":  "2025-04-25T20:14:00Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2025-04-25T20:10:22Z",
        "body":  "### Description\r\n\r\nThere are instances where it is beneficial for performance to set explicit thread affinity, for some reason this functionality was not available on Thread level, so historically our .NET FX 4.x application was using the following ugly logic:\r\n\r\n    int iProcAffinity=0;\r\n\r\n    // Usage of GetCurrentThreadId is discouraged now as it could be volatile, but not in our config \r\n    // Thread.CurrentThread.ManagedThreadId can be used instead (EDIT: No, that can\u0027t be used actually as ids won\u0027t match)\r\n    int iCurThreadID=AppDomain.GetCurrentThreadId();\r\n\r\n    foreach(ProcessThread oPT in Process.GetCurrentProcess().Threads)\r\n    {\r\n              if(oPT.Id==iCurThreadID)\r\n              {\r\n                        oPT.PriorityBoostEnabled=true;\r\n                        oPT.IdealProcessor=iProcAffinity;\r\n                        oPT.ProcessorAffinity=new IntPtr(1L\u003c\u003ciProcAffinity);\r\n                        break;\r\n               }\r\n    }\r\n\r\nHowever in .NET 5 (possibly earlier) ProcessThread.Id no longer matched ManagedThreadId, this is a change in behavior compared to .NET FX 4.x (and earlier from at least .NET FX 2).\r\n\r\nThis is a rather old code, so if somebody knows a better way of changing current thread\u0027s processor affinity then I\u0027d be happy with that too.\r\n\r\nEDIT: changed title \r\n\r\n### Reproduction Steps\r\n\r\nSee code snippet above - in .NET FX current thread will be found, but not in .NET 5+\r\n\r\n### Expected behavior\r\n\r\nWell, ideally it should be matching what happened before, however I appreciate that there might have been good reasons for that not to be the case (and perhaps this behavior should have never been relied upon), however in such case there should be some other way to match thread using ManagedThreadId or just being able to set thread affinity right in the Thread object (but that would be more of an API proposal).\r\n\r\n### Actual behavior\r\n\r\nIn list of all ProcessThreads their Id no longer matches ManagedThreadId \r\n\r\n### Regression?\r\n\r\nKind of - it\u0027s certainly a change, perhaps it was dangerous to rely on matching ids in the first place, but there is seemingly no easy good way to change current thread\u0027s processor affinity anyway\r\n\r\n### Known Workarounds\r\n\r\nI had to use ugly workaround which involved setting current managed thread priority to Lowest and then iterating through all the threads to find (hopefully) the only thread with the lowest priority, and then change thread affinity. \r\n\r\n### Configuration\r\n\r\nx64, Win 10, VS 2022\r\n\r\n### Other information\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOb9EwPw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc48E-vI",
                                           "createdAt":  "2022-01-08T09:50:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nThere are instances where it is beneficial for performance to set explicit thread affinity, for some reason this functionality was not available on Thread level, so historically our .NET FX 4.x application was using the following ugly logic:\r\n\r\n    int iProcAffinity=0;\r\n\r\n    // Usage of GetCurrentThreadId is discouraged now as it could be volatile, but not in our config \r\n    // Thread.CurrentThread.ManagedThreadId can be used instead\r\n    int iCurThreadID=AppDomain.GetCurrentThreadId();\r\n\r\n    foreach(ProcessThread oPT in Process.GetCurrentProcess().Threads)\r\n    {\r\n              if(oPT.Id==iCurThreadID)\r\n              {\r\n                        oPT.PriorityBoostEnabled=true;\r\n                        oPT.IdealProcessor=iProcAffinity;\r\n                        oPT.ProcessorAffinity=new IntPtr(1L\u003c\u003ciProcAffinity);\r\n                        break;\r\n               }\r\n    }\r\n\r\nHowever in .NET 5 (possibly earlier) ProcessThread.Id no longer matched ManagedThreadId, this is a change in behavior compared to .NET FX 4.x (and earlier from at least .NET FX 2).\r\n\r\nThis is a rather old code, so if somebody knows a better way of changing current thread\u0027s processor affinity then I\u0027d be happy with that too.\n\n### Reproduction Steps\n\nSee code snippet above - in .NET FX current thread will be found, but not in .NET 5+\n\n### Expected behavior\n\nWell, ideally it should be matching what happened before, however I appreciate that there might have been good reasons for that not to be the case (and perhaps this behavior should have never been relied upon), however in such case there should be some other way to match thread using ManagedThreadId or just being able to set thread affinity right in the Thread object (but that would be more of an API proposal).\n\n### Actual behavior\n\nIn list of all ProcessThreads their Id no longer matches ManagedThreadId \n\n### Regression?\n\nKind of - it\u0027s certainly a change, perhaps it was dangerous to rely on matching ids in the first place, but there is seemingly no easy good way to change current thread\u0027s processor affinity anyway\n\n### Known Workarounds\n\nI had to use ugly workaround which involved setting current managed thread priority to Lowest and then iterating through all the threads to find (hopefully) the only thread with the lowest priority, and then change thread affinity. \n\n### Configuration\n\nx64, Win 10, VS 2022\n\n### Other information\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eHighPerfDotNet\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-01-08T09:50:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48FUdH",
                                           "createdAt":  "2022-01-08T15:33:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "zlatanov",
                                           "body":  "There might be more more managed threads that there are OS threads and their relation is not 1 to 1. \r\n\r\nWhat I think you should be using instead is the Windows API function [GetCurrentThreadId](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getcurrentthreadid). Something like this would work:\r\n\r\n```c#\r\nusing System.Diagnostics;\r\nusing System.Runtime.InteropServices;\r\n\r\nusing var process = Process.GetCurrentProcess();\r\nvar currentThreadId = GetCurrentThreadId();\r\n\r\nforeach (ProcessThread thread in process.Threads)\r\n{\r\n    if (thread.Id == currentThreadId)\r\n    {\r\n        // TODO\r\n    }\r\n}\r\n\r\n[DllImport(\"kernel32.dll\")]\r\nstatic extern int GetCurrentThreadId();\r\n```",
                                           "updatedAt":  "2022-01-08T15:34:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48FYGO",
                                           "createdAt":  "2022-01-08T16:05:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "HighPerfDotNet",
                                           "body":  "Thank you for your suggestion, but I\u0027d prefer to set processor affinity without using specific Windows API (my ugly but working alternative is using cross-platform  .NET only), it always struck me as odd that the Thread object does not have ability to set processor affinity directly, it should not be necessay to enumerate all threads to locate the one you want.",
                                           "updatedAt":  "2022-01-08T16:05:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48FY_z",
                                           "createdAt":  "2022-01-08T16:17:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCJEvDQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "HighPerfDotNet",
                                                                               "createdAt":  "2022-01-08T16:32:32Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "\u003e it always struck me as odd that the Thread object does not have ability to set processor affinity directly\r\n\r\nThat\u0027s \u003chttps://github.com/dotnet/runtime/issues/21363\u003e.",
                                           "updatedAt":  "2022-01-08T16:17:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48FanN",
                                           "createdAt":  "2022-01-08T16:37:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e However in .NET 5 (possibly earlier) ProcessThread.Id no longer matched ManagedThreadId, this is a change in behavior compared to .NET FX 4.x (and earlier from at least .NET FX 2).\r\n\r\nThread.CurrentThread.ManagedThreadId / Environment.CurrentManagedThreadId have never matched the OS thread ID; they\u0027ve always been different numbering spaces, with the .NET runtime assigning ManagedThreadID and the OS assigning process thread ID.  Running this on .NET Framework 4.8:\r\n```C#\r\nusing System;\r\nusing System.Diagnostics;\r\nusing System.Threading;\r\n\r\ninternal class Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        var barrier = new Barrier(20);\r\n        for (int i = 0; i \u003c barrier.ParticipantCount - 1; i++)\r\n        {\r\n            new Thread(() =\u003e\r\n            {\r\n                barrier.SignalAndWait();\r\n                Console.WriteLine($\"Managed: {Thread.CurrentThread.ManagedThreadId}\");\r\n                barrier.SignalAndWait();\r\n                barrier.SignalAndWait();\r\n            }).Start();\r\n        }\r\n\r\n        barrier.SignalAndWait();\r\n        barrier.SignalAndWait();\r\n        foreach (ProcessThread t in Process.GetCurrentProcess().Threads)\r\n        {\r\n            Console.WriteLine($\"ProcessThread: {t.Id}\");\r\n        }\r\n        barrier.SignalAndWait();\r\n    }\r\n}\r\n```\r\nI get this:\r\n```\r\nManaged: 15\r\nManaged: 14\r\nManaged: 13\r\nManaged: 19\r\nManaged: 9\r\nManaged: 17\r\nManaged: 6\r\nManaged: 7\r\nManaged: 18\r\nManaged: 4\r\nManaged: 10\r\nManaged: 20\r\nManaged: 21\r\nManaged: 5\r\nManaged: 3\r\nManaged: 8\r\nManaged: 11\r\nManaged: 12\r\nManaged: 16\r\nProcessThread: 56444\r\nProcessThread: 45176\r\nProcessThread: 47148\r\nProcessThread: 45440\r\nProcessThread: 47268\r\nProcessThread: 55836\r\nProcessThread: 55484\r\nProcessThread: 55660\r\nProcessThread: 25496\r\nProcessThread: 54364\r\nProcessThread: 53084\r\nProcessThread: 49760\r\nProcessThread: 52924\r\nProcessThread: 41152\r\nProcessThread: 16616\r\nProcessThread: 50856\r\nProcessThread: 38880\r\nProcessThread: 20872\r\nProcessThread: 17780\r\nProcessThread: 54552\r\nProcessThread: 58260\r\nProcessThread: 57464\r\nProcessThread: 42248\r\nProcessThread: 4748\r\nProcessThread: 40048\r\n```\r\nAny overlap here would be purely coincidental.",
                                           "updatedAt":  "2022-01-08T16:39:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48FbbK",
                                           "createdAt":  "2022-01-08T16:44:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCJEy8Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "HighPerfDotNet",
                                                                               "createdAt":  "2022-01-08T17:06:43Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "zlatanov",
                                           "body":  "\u003e Thank you for your suggestion, but I\u0027d prefer to set processor affinity without using specific Windows API (my ugly but working alternative is using cross-platform .NET only), it always struck me as odd that the Thread object does not have ability to set processor affinity directly, it should not be necessay to enumerate all threads to locate the one you want.\r\n\r\nThe current thread affinity API is not cross platform: \r\nhttps://github.com/dotnet/runtime/blob/fd33b9eac6f259ef731e0204bcd2aebd534b8ddc/src/libraries/System.Diagnostics.Process/ref/System.Diagnostics.Process.cs#L265-L266",
                                           "updatedAt":  "2022-01-08T16:44:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48FcAA",
                                           "createdAt":  "2022-01-08T16:50:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "HighPerfDotNet",
                                           "body":  "It works for me in .NET 4.7.2, try this -\r\n\r\n  int iCurManagedThreadID=AppDomain.GetCurrentThreadId();\r\n Console.WriteLine(\"Current managed thead id: {0}\",iCurManagedThreadID);\r\n\r\nforeach(ProcessThread oPT in Process.GetCurrentProcess().Threads)\r\n{\r\n    Console.WriteLine(\"{0}{1}\",oPT.Id,oPT.Id==iCurManagedThreadID ? \" (CURRENT THREAD)\" : \"\");\r\n}\r\n\r\nOutput for me:\r\n\r\nCurrent managed thead id: 26620\r\n26620 (CURRENT THREAD)\r\n5844\r\n13168\r\n27376\r\n12972\r\n28956\r\n76\r\n6420\r\n8036\r\n26584\r\n32728\r\n31928\r\n30784\r\n22292\r\n31720\r\n19316\r\n20260\r\n27388\r\n24004\r\n21076\r\n26920\r\n20920\r\n31064\r\n29580\r\n11164\r\n7700\r\n25164\r\n6980\r\n20052\r\n2500\r\n31140",
                                           "updatedAt":  "2022-01-08T16:50:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48FcWg",
                                           "createdAt":  "2022-01-08T16:53:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCJEyIQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "HighPerfDotNet",
                                                                               "createdAt":  "2022-01-08T16:59:25Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Sorry, I thought you were talking about Thread.CurrentThread.ManagedThreadId.\r\n\r\nAppDomain.GetCurrentThreadId is deprecated / [Obsolete], even in .NET Framework:\r\nhttps://docs.microsoft.com/en-us/dotnet/api/system.appdomain.getcurrentthreadid?view=netframework-4.8\r\nhttps://referencesource.microsoft.com/#mscorlib/system/appdomain.cs,2571",
                                           "updatedAt":  "2022-01-08T16:53:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48Fc-G",
                                           "createdAt":  "2022-01-08T16:59:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "HighPerfDotNet",
                                           "body":  "Thread.CurrentThread.ManagedThreadId is sadly not mapping to thread ids used by ProcessThread, but AppDomain.GetCurrentThreadId were \r\n\r\nThe method might be obsolete, but it\u0027s behavior changed between .NET FX and new .NET, hence the report.\r\n",
                                           "updatedAt":  "2022-01-08T16:59:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48FekA",
                                           "createdAt":  "2022-01-08T17:16:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e The method might be obsolete, but it\u0027s behavior changed between .NET FX and new .NET, hence the report.\r\n\r\nYes,  this is by design. The method wasn\u0027t even included in .NET Core 1.0 because it\u0027s been obsolete/deprecated for a decade or more and the docs explicitly advise against using it due to it not being stable. When it was brought back in .NET Core 2.0 to help apps that were calling it migrate/compile, it was made to use Environment.CurrentManagedThreadId:\r\nhttps://github.com/dotnet/corefx/pull/12113#discussion_r80831148",
                                           "updatedAt":  "2022-01-08T17:24:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48FfQH",
                                           "createdAt":  "2022-01-08T17:27:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD1Dteg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "fbenoit-coexya",
                                                                               "createdAt":  "2024-10-07T08:44:23Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "HighPerfDotNet",
                                           "body":  "That explains for sure (even though it would have been better to keep old behavior, obsolete or not - backwards compatibility is very important), the bottom line is that a better way is needed to set thread affinity such as referenced in https://github.com/dotnet/runtime/issues/21363  ",
                                           "updatedAt":  "2022-01-08T17:27:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48Ffll",
                                           "createdAt":  "2022-01-08T17:32:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e even though it would have been better to keep old behavior, obsolete or not - backwards compatibility is very important\r\n\r\nThere wasn\u0027t a guarantee it would consistently return a stable value for the Thread and a value that matched the OS\u0027 concept of thread id; that\u0027s why it was obsoleted.\r\n\r\n\u003e the bottom line is that a better way is needed to set thread affinity such as referenced in #21363\r\n\r\nWe can close this as a duplicate of that then. Thanks. ",
                                           "updatedAt":  "2022-01-08T17:34:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48FhJy",
                                           "createdAt":  "2022-01-08T17:55:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "HighPerfDotNet",
                                           "body":  "Yes, you can close it, but it\u0027s worth pointing out that https://github.com/dotnet/runtime/issues/21363 was created on 25 Apr 2017, which is almost 5 years ago ",
                                           "updatedAt":  "2022-01-08T17:55:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48FmFj",
                                           "createdAt":  "2022-01-08T18:39:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEPs_iw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "HighPerfDotNet",
                                                                               "createdAt":  "2022-01-08T18:40:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "quixoticaxis",
                                                                               "createdAt":  "2022-01-08T23:40:46Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "theodorzoulias",
                                                                               "createdAt":  "2022-02-21T15:48:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colinc74",
                                                                               "createdAt":  "2023-12-06T04:00:09Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "fbenoit-coexya",
                                                                               "createdAt":  "2024-10-07T08:44:32Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jhudsoncedaron",
                                                                               "createdAt":  "2025-04-25T20:12:57Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  6
                                                         },
                                           "author":  "aloraman",
                                           "body":  "\u003e There wasn\u0027t a guarantee it would consistently return a stable value for the Thread and a value that matched the OS\u0027 concept of thread id; that\u0027s why it was obsoleted\r\n\r\nAs I recall, the mismatch was expected to happen when managed thread switches its underlying native thread (hence `Thread.BeginThreadAffinity` API exists). But in practice, that was the case only in CLR-on-SqlServer. So the wisdom of the crowd was to ignore this obsoletion warning, because \"we won\u0027t be running this code on SqlServer anyway\". Better solution was to reimplement this method in your own codebase (P/Invoke call to `GetCurrentThreadId` from `kernel32.dll`)\r\n\r\nNow, current implementation of `AppDomain.GetCurrentThreadId` is weird. It\u0027s not compatible with .NetFramework , because it returns managed thread id, not native thread id. But it is stable and returns the same value as Environment.CurrentManagedThreadId, so it kinda contradicts the obsoletion warning.\r\n\r\nIMHO, the principle of least surprise should be followed, and this method should return either the result of `Thread.GetCurrentOSThreadId` or throw an exception outright. It should not return something completely different and unrelated to previous behavior (see `CultureInfo.ListSeparator` debacle)\r\n",
                                           "updatedAt":  "2022-01-08T19:31:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48FmmB",
                                           "createdAt":  "2022-01-08T18:47:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "HighPerfDotNet",
                                           "body":  "An obsolete method should act exactly as it was before or throw exception - there is zero benefit to provide managed thread id, it\u0027s easily obtainable elsewhere (ie Thread.CurrentThread.ManagedThreadId )",
                                           "updatedAt":  "2022-01-08T18:48:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48GLnC",
                                           "createdAt":  "2022-01-09T08:31:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "Adding a ProcessThread.GetCurrentThread() API (similar to Process.GetCurrentProcess()) could make some sense, too. However, it would have disadvantages:\n\n* Calls would have to be between BeginThreadAffinity and EndThreadAffinity, for compatibility with any future green threads.\n* This could not be used for setting processor affinity, ideal processor, etc. of a thread that has been created but not yet started.",
                                           "updatedAt":  "2022-01-09T08:31:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4-YLM5",
                                           "createdAt":  "2022-02-21T06:45:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCPrBFQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "HighPerfDotNet",
                                                                               "createdAt":  "2022-02-21T17:22:29Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "GSPP",
                                           "body":  "I recently had this situation, too. I settled on making the thread in question query its own ID using `GetCurrentThreadId` and pass that ID to other threads so that those threads could control affinity. The affinity was dynamically assigned by a form of scheduler. Each thread on its own did not have the ability to know the correct affinity mask to use. It had to be global.\r\n\r\nIt would have been easier if there had been:\r\n\r\n```diff\r\npublic class Thread\r\n{\r\n+    public int NativeThreadID { get; }\r\n}\r\n```\r\n\r\nIn the context of possible future green threads, maybe this:\r\n\r\n```diff\r\npublic class Thread\r\n{\r\n+    public int? TryGetNativeThreadID();\r\n}\r\n```\r\n\r\nBeing able to obtain a `ProcessThread` for a given `Thread` would be handy, too.",
                                           "updatedAt":  "2022-02-21T06:45:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5FHXci",
                                           "createdAt":  "2022-06-18T20:45:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODRK3ZQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "HighPerfDotNet",
                                                                               "createdAt":  "2022-06-18T23:04:22Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "uncttao",
                                                                               "createdAt":  "2022-10-12T20:24:33Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "overstained",
                                                                               "createdAt":  "2023-06-27T21:07:54Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colinc74",
                                                                               "createdAt":  "2023-12-06T05:01:42Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "munichmule",
                                                                               "createdAt":  "2024-01-03T21:05:59Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  5
                                                         },
                                           "author":  "ColonelBundy",
                                           "body":  "I also ran into this problem and I came up with a workaround:\r\n```\r\n\r\npublic static class ThreadExtensions\r\n{\r\n    [DllImport(\"kernel32.dll\")]\r\n    private static extern int GetCurrentThreadId();\r\n\r\n    [DllImport(\"libc.so.6\")]\r\n    private static extern int gettid();\r\n\r\n    [SupportedOSPlatform(\"Windows\")]\r\n    [SupportedOSPlatform(\"Linux\")]\r\n    [UnsupportedOSPlatform(\"OSX\")]\r\n    public static int GetCurrentOsThreadId()\r\n    {\r\n        if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))\r\n        {\r\n            return gettid();\r\n        }\r\n\r\n        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))\r\n        {\r\n            return GetCurrentThreadId();\r\n        }\r\n\r\n        throw new NotSupportedException(\"Unable to get current unmanaged thread id on this platform\");\r\n    }\r\n}\r\n```",
                                           "updatedAt":  "2022-06-18T20:45:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5jLDs4",
                                           "createdAt":  "2023-08-03T11:50:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "oold",
                                           "body":  "\u003e As I recall, the mismatch was expected to happen when managed thread switches its underlying native thread (hence `Thread.BeginThreadAffinity` API exists). But in practice, that was the case only in CLR-on-SqlServer.\r\n\r\nNot 100% accurate. I\u0027ve seen that happening for Visual Studio extensions, too.",
                                           "updatedAt":  "2023-08-03T11:50:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5v0TA_",
                                           "createdAt":  "2024-01-03T21:13:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "munichmule",
                                           "body":  "@stephentoub What exactly `ProcessThread.Id` stands for then? It\u0027s neither managed thread id nor reliable os thread id. \r\nHow can I find a `ProcessThread` matching my managed thread then? The suggestion by @ColonelBundy works for some win/linux scenarios, but I was unable to find a proper interop/pinvoke for macOS: ProcessThread.Id matches none of handles I can get from  `pthread_self`, `pthread_threadid_np`, `pthread_mach_thread_np` etc, so I wonder what it stands for and how it can be used/matched...",
                                           "updatedAt":  "2024-01-03T21:19:52Z"
                                       }
                                   ],
                         "totalCount":  20
                     },
        "title":  "AppDomain.GetCurrentThreadId() no longer matches ProcessThread.Id",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/65199",
        "createdAt":  "2022-02-11T17:44:21Z",
        "number":  65199,
        "author":  "kouvel",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-13T15:35:36Z",
        "body":  "`SimpleRWLock` seems to be a purely spin-wait-based data structure, with long spin-waits between attempts. In some cases during contention the spin-waiting CPU time is showing up near the top of methods in exclusive CPU time spent. It should be possible to tweak the spin-waits to be shorter, and maybe also back-off to a full wait in some cases.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOX6uvrA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc49xxZI",
                                           "createdAt":  "2022-02-11T17:44:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n`SimpleRWLock` seems to be a purely spin-wait-based data structure, with long spin-waits between attempts. In some cases during contention the spin-waiting CPU time is showing up near the top of methods in exclusive CPU time spent. It should be possible to tweak the spin-waits to be shorter, and maybe also back-off to a full wait in some cases.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ekouvel\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e7.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-02-11T17:44:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5dSqm8",
                                           "createdAt":  "2023-05-27T02:48:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "What are the hot stacktraces? Would it be better to get rid of this lock in the offending places instead?",
                                           "updatedAt":  "2023-05-27T02:48:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5eJUHQ",
                                           "createdAt":  "2023-06-06T21:54:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "From the history I have, it was apparently contention in the type loader, under JIT_GenericHandleClass / JIT_GenericHandle_Framed, probably during startup. I don\u0027t have any history on whether an RW lock would benefit over a simpler lock in this case. It may be possible to create a small test case to show the issue and measure.",
                                           "updatedAt":  "2023-06-06T21:54:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5eJjO8",
                                           "createdAt":  "2023-06-06T22:50:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e JIT_GenericHandleClass / JIT_GenericHandle_Framed\r\n\r\nHmm, `g_pJitGenericHandleCache` that backs implementation of these APIs is lock-free for read and it does not use SimpleRWLock.\r\n\r\n",
                                           "updatedAt":  "2023-06-06T22:51:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5eJy5L",
                                           "createdAt":  "2023-06-07T00:04:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "Here\u0027s a longer caller stack that I have from before:\r\n\r\n```\r\n- SimpleRWLock::EnterRead\r\n- LoaderAllocator::GetDispatchToken\r\n- VirtualCallStubManager::GetCallStub\r\n- Dictionary::PopulateEntry\r\n- JIT_GenericHandle_Framed\r\n- JIT_GenericHandleClass\r\n```",
                                           "updatedAt":  "2023-06-07T00:04:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5eJzE4",
                                           "createdAt":  "2023-06-07T00:05:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "SimpleRWLock::EnterRead in that case was using about half the CPU time of CLRLifoSemaphore::Wait, which seemed to be high",
                                           "updatedAt":  "2023-06-07T00:05:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5eJ0HU",
                                           "createdAt":  "2023-06-07T00:11:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC9Teig==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kouvel",
                                                                               "createdAt":  "2023-06-07T00:15:24Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "If the dispatch token hashtable is hot in some scenarios, we should be able to switch it to be lock-free on read hashtable.",
                                           "updatedAt":  "2023-06-07T00:11:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5fq6-s",
                                           "createdAt":  "2023-06-23T22:59:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidwrighton",
                                           "body":  "I believe we only use a `SimpleRWLock` in those cases when creating/working with a FatDispatchToken, and I removed the need for fat dispatch tokens on 64 bit platforms with PR #65045. My guess is that we probably don\u0027t have this particular problem with this callstack on X64 or Arm64 platforms anymore.",
                                           "updatedAt":  "2023-06-23T23:00:03Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "`SimpleRWLock::EnterRead` shows up high in CPU usage in some cases",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/66837",
        "createdAt":  "2022-03-18T16:01:42Z",
        "number":  66837,
        "author":  "adamsitnik",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-18T23:32:03Z",
        "body":  "`System.Threading.Tasks.Tests.Perf_AsyncMethods.Yield ` seems to be quite noisy, but it has for sure regressed on ARM64.\r\n\r\nThe reporting system does not show it for [Windows arm64](https://pvscmdupload.blob.core.windows.net/reports/allTestHistory%2frefs%2fheads%2fmain_arm64_Windows%2010.0.19041%2fSystem.Threading.Tasks.Tests.Perf_AsyncMethods.Yield.html) but I am able to constantly reproduce it on Surface Pro X. So it can be caused by something that is enabled in the SDK, but not with corerun (perf lab runs use corerun from local dotnet/runtime build, we are using the SDK that we ship  for the monthly perf runs)\r\n\r\n![image](https://user-images.githubusercontent.com/6011991/159037367-adeaa972-d9b9-4856-9782-52cb25341fe0.png)\r\n\r\nSurprisingly for [Ubuntu arm64](https://pvscmdupload.blob.core.windows.net/reports/allTestHistory%2frefs%2fheads%2fmain_arm64_ubuntu%2018.04%2fSystem.Threading.Tasks.Tests.Perf_AsyncMethods.Yield.html) the reporting system shows an improvement. But this time I\u0027ve not received any Ubuntu arm64 inputs, so I can\u0027t confirm or deny it.\r\n\r\n![image](https://user-images.githubusercontent.com/6011991/159037756-817ddd0a-f4fd-49d2-9a18-b1b0d12f9a97.png)\r\n\r\n@AndyAyersMS you should be able to reproduce it on your M1 \r\n\r\nRepro:\r\n\r\n```cmd\r\ngit clone https://github.com/dotnet/performance.git\r\npy .\\performance\\scripts\\benchmarks_ci.py -f net6.0 net7.0 --filter System.Threading.Tasks.Tests.Perf_AsyncMethods.Yield --architecture arm64\r\n```\r\n\r\n\u003cdetails\u003e\r\n\r\n| Result |    Base |   Diff | Ratio | Modality | Operating System      | Bit   |\r\n| ------ | -------:| ------:| -----:| -------- | --------------------- | ----- |\r\n| Faster | 1295.71 | 520.60 |  2.49 |          | Windows 11            | X64   |\r\n| Faster |  990.40 | 328.88 |  3.01 |          | Windows 11            | X64   |\r\n| Same   |  403.16 | 368.82 |  1.09 |          | Windows 11            | X64   |\r\n| Faster |  588.08 | 294.85 |  1.99 |          | Windows 10            | X64   |\r\n| Faster |  855.19 | 352.81 |  2.42 |          | Windows 11            | X64   |\r\n| Slower |  273.40 | 345.52 |  0.79 | bimodal  | Windows 11            | X64   |\r\n| Faster | 1057.37 | 336.21 |  3.14 |          | ubuntu 18.04          | X64   |\r\n| Faster | 1048.20 | 347.24 |  3.02 |          | ubuntu 20.04          | X64   |\r\n| Faster |  851.95 | 362.10 |  2.35 |          | ubuntu 18.04          | X64   |\r\n| Same   |  551.51 | 575.17 |  0.96 |          | ubuntu 18.04          | X64   |\r\n| Slower |  314.53 | 370.69 |  0.85 |          | pop 20.04             | X64   |\r\n| Same   |  333.26 | 318.63 |  1.05 | several? | alpine 3.13           | X64   |\r\n| Same   |  310.12 | 320.67 |  0.97 |          | debian 11             | X64   |\r\n| Slower |  157.43 | 391.50 |  0.40 |          | macOS Monterey 12.2.1 | Arm64 |\r\n| Slower |  450.64 | 876.74 |  0.51 | bimodal  | Windows 10            | Arm64 |\r\n| Slower |  326.61 | 822.06 |  0.40 |          | Windows 11            | Arm64 |\r\n| Same   |  441.79 | 441.64 |  1.00 | several? | Windows 10            | X86   |\r\n| Same   |  310.05 | 350.47 |  0.88 | bimodal  | Windows 10            | X86   |\r\n| Same   |  370.33 | 348.84 |  1.06 |          | Windows 10            | X86   |\r\n| Slower |  609.16 | 999.41 |  0.61 |          | Windows 10            | Arm   |\r\n| Slower |  262.75 | 312.75 |  0.84 | bimodal  | macOS Big Sur 11.6.3  | X64   |\r\n| Slower |  278.15 | 329.83 |  0.84 |          | macOS Monterey 12.2.1 | X64   |\r\n| Same   |  254.11 | 275.46 |  0.92 |          | macOS Monterey 12.2.1 | X64   |\r\n\r\n\r\n\r\n\u003c/details\u003e\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOP_DHiQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc4_7djY",
                                           "createdAt":  "2022-03-18T16:01:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n`System.Threading.Tasks.Tests.Perf_AsyncMethods.Yield ` seems to be quite noisy, but it has for sure regressed on ARM64.\r\n\r\nThe reporting system does not show it for [Windows arm64](https://pvscmdupload.blob.core.windows.net/reports/allTestHistory%2frefs%2fheads%2fmain_arm64_Windows%2010.0.19041%2fSystem.Threading.Tasks.Tests.Perf_AsyncMethods.Yield.html) but I am able to constantly reproduce it on Surface Pro X. So it can be caused by something that is enabled in the SDK, but not with corerun (perf lab runs use corerun from local dotnet/runtime build, we are using the SDK that we ship  for the monthly perf runs)\r\n\r\n![image](https://user-images.githubusercontent.com/6011991/159037367-adeaa972-d9b9-4856-9782-52cb25341fe0.png)\r\n\r\nSurprisingly for [Ubuntu arm64](https://pvscmdupload.blob.core.windows.net/reports/allTestHistory%2frefs%2fheads%2fmain_arm64_ubuntu%2018.04%2fSystem.Threading.Tasks.Tests.Perf_AsyncMethods.Yield.html) the reporting system shows an improvement. But this time I\u0027ve not received any Ubuntu arm64 inputs, so I can\u0027t confirm or deny it.\r\n\r\n![image](https://user-images.githubusercontent.com/6011991/159037756-817ddd0a-f4fd-49d2-9a18-b1b0d12f9a97.png)\r\n\r\n@AndyAyersMS you should be able to reproduce it on your M1 \r\n\r\nRepro:\r\n\r\n```cmd\r\ngit clone https://github.com/dotnet/performance.git\r\npy .\\performance\\scripts\\benchmarks_ci.py -f net6.0 net7.0 --filter System.Threading.Tasks.Tests.Perf_AsyncMethods.Yield --architecture arm64\r\n```\r\n\r\n\u003cdetails\u003e\r\n\r\n| Result |    Base |   Diff | Ratio | Modality | Operating System      | Bit   |\r\n| ------ | -------:| ------:| -----:| -------- | --------------------- | ----- |\r\n| Faster | 1295.71 | 520.60 |  2.49 |          | Windows 11            | X64   |\r\n| Faster |  990.40 | 328.88 |  3.01 |          | Windows 11            | X64   |\r\n| Same   |  403.16 | 368.82 |  1.09 |          | Windows 11            | X64   |\r\n| Faster |  588.08 | 294.85 |  1.99 |          | Windows 10            | X64   |\r\n| Faster |  855.19 | 352.81 |  2.42 |          | Windows 11            | X64   |\r\n| Slower |  273.40 | 345.52 |  0.79 | bimodal  | Windows 11            | X64   |\r\n| Faster | 1057.37 | 336.21 |  3.14 |          | ubuntu 18.04          | X64   |\r\n| Faster | 1048.20 | 347.24 |  3.02 |          | ubuntu 20.04          | X64   |\r\n| Faster |  851.95 | 362.10 |  2.35 |          | ubuntu 18.04          | X64   |\r\n| Same   |  551.51 | 575.17 |  0.96 |          | ubuntu 18.04          | X64   |\r\n| Slower |  314.53 | 370.69 |  0.85 |          | pop 20.04             | X64   |\r\n| Same   |  333.26 | 318.63 |  1.05 | several? | alpine 3.13           | X64   |\r\n| Same   |  310.12 | 320.67 |  0.97 |          | debian 11             | X64   |\r\n| Slower |  157.43 | 391.50 |  0.40 |          | macOS Monterey 12.2.1 | Arm64 |\r\n| Slower |  450.64 | 876.74 |  0.51 | bimodal  | Windows 10            | Arm64 |\r\n| Slower |  326.61 | 822.06 |  0.40 |          | Windows 11            | Arm64 |\r\n| Same   |  441.79 | 441.64 |  1.00 | several? | Windows 10            | X86   |\r\n| Same   |  310.05 | 350.47 |  0.88 | bimodal  | Windows 10            | X86   |\r\n| Same   |  370.33 | 348.84 |  1.06 |          | Windows 10            | X86   |\r\n| Slower |  609.16 | 999.41 |  0.61 |          | Windows 10            | Arm   |\r\n| Slower |  262.75 | 312.75 |  0.84 | bimodal  | macOS Big Sur 11.6.3  | X64   |\r\n| Slower |  278.15 | 329.83 |  0.84 |          | macOS Monterey 12.2.1 | X64   |\r\n| Same   |  254.11 | 275.46 |  0.92 |          | macOS Monterey 12.2.1 | X64   |\r\n\r\n\r\n\r\n\u003c/details\u003e\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eadamsitnik\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`arch-arm64`, `area-System.Threading.Tasks`, `tenet-performance`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-03-18T16:01:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_7fwp",
                                           "createdAt":  "2022-03-18T16:09:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCTq50A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "adamsitnik",
                                                                               "createdAt":  "2022-03-18T17:14:21Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "All `await Task.Yield()` does is queue a work item to the ThreadPool, so if there\u0027s a regression here, it\u0027s almost certainly around the ThreadPool.\r\ncc: @kouvel",
                                           "updatedAt":  "2022-03-18T16:09:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_8MeJ",
                                           "createdAt":  "2022-03-18T19:39:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n`System.Threading.Tasks.Tests.Perf_AsyncMethods.Yield ` seems to be quite noisy, but it has for sure regressed on ARM64.\r\n\r\nThe reporting system does not show it for [Windows arm64](https://pvscmdupload.blob.core.windows.net/reports/allTestHistory%2frefs%2fheads%2fmain_arm64_Windows%2010.0.19041%2fSystem.Threading.Tasks.Tests.Perf_AsyncMethods.Yield.html) but I am able to constantly reproduce it on Surface Pro X. So it can be caused by something that is enabled in the SDK, but not with corerun (perf lab runs use corerun from local dotnet/runtime build, we are using the SDK that we ship  for the monthly perf runs)\r\n\r\n![image](https://user-images.githubusercontent.com/6011991/159037367-adeaa972-d9b9-4856-9782-52cb25341fe0.png)\r\n\r\nSurprisingly for [Ubuntu arm64](https://pvscmdupload.blob.core.windows.net/reports/allTestHistory%2frefs%2fheads%2fmain_arm64_ubuntu%2018.04%2fSystem.Threading.Tasks.Tests.Perf_AsyncMethods.Yield.html) the reporting system shows an improvement. But this time I\u0027ve not received any Ubuntu arm64 inputs, so I can\u0027t confirm or deny it.\r\n\r\n![image](https://user-images.githubusercontent.com/6011991/159037756-817ddd0a-f4fd-49d2-9a18-b1b0d12f9a97.png)\r\n\r\n@AndyAyersMS you should be able to reproduce it on your M1 \r\n\r\nRepro:\r\n\r\n```cmd\r\ngit clone https://github.com/dotnet/performance.git\r\npy .\\performance\\scripts\\benchmarks_ci.py -f net6.0 net7.0 --filter System.Threading.Tasks.Tests.Perf_AsyncMethods.Yield --architecture arm64\r\n```\r\n\r\n\u003cdetails\u003e\r\n\r\n| Result |    Base |   Diff | Ratio | Modality | Operating System      | Bit   |\r\n| ------ | -------:| ------:| -----:| -------- | --------------------- | ----- |\r\n| Faster | 1295.71 | 520.60 |  2.49 |          | Windows 11            | X64   |\r\n| Faster |  990.40 | 328.88 |  3.01 |          | Windows 11            | X64   |\r\n| Same   |  403.16 | 368.82 |  1.09 |          | Windows 11            | X64   |\r\n| Faster |  588.08 | 294.85 |  1.99 |          | Windows 10            | X64   |\r\n| Faster |  855.19 | 352.81 |  2.42 |          | Windows 11            | X64   |\r\n| Slower |  273.40 | 345.52 |  0.79 | bimodal  | Windows 11            | X64   |\r\n| Faster | 1057.37 | 336.21 |  3.14 |          | ubuntu 18.04          | X64   |\r\n| Faster | 1048.20 | 347.24 |  3.02 |          | ubuntu 20.04          | X64   |\r\n| Faster |  851.95 | 362.10 |  2.35 |          | ubuntu 18.04          | X64   |\r\n| Same   |  551.51 | 575.17 |  0.96 |          | ubuntu 18.04          | X64   |\r\n| Slower |  314.53 | 370.69 |  0.85 |          | pop 20.04             | X64   |\r\n| Same   |  333.26 | 318.63 |  1.05 | several? | alpine 3.13           | X64   |\r\n| Same   |  310.12 | 320.67 |  0.97 |          | debian 11             | X64   |\r\n| Slower |  157.43 | 391.50 |  0.40 |          | macOS Monterey 12.2.1 | Arm64 |\r\n| Slower |  450.64 | 876.74 |  0.51 | bimodal  | Windows 10            | Arm64 |\r\n| Slower |  326.61 | 822.06 |  0.40 |          | Windows 11            | Arm64 |\r\n| Same   |  441.79 | 441.64 |  1.00 | several? | Windows 10            | X86   |\r\n| Same   |  310.05 | 350.47 |  0.88 | bimodal  | Windows 10            | X86   |\r\n| Same   |  370.33 | 348.84 |  1.06 |          | Windows 10            | X86   |\r\n| Slower |  609.16 | 999.41 |  0.61 |          | Windows 10            | Arm   |\r\n| Slower |  262.75 | 312.75 |  0.84 | bimodal  | macOS Big Sur 11.6.3  | X64   |\r\n| Slower |  278.15 | 329.83 |  0.84 |          | macOS Monterey 12.2.1 | X64   |\r\n| Same   |  254.11 | 275.46 |  0.92 |          | macOS Monterey 12.2.1 | X64   |\r\n\r\n\r\n\r\n\u003c/details\u003e\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eadamsitnik\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`arch-arm64`, `area-System.Threading`, `tenet-performance`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-03-18T19:39:28Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "System.Threading.Tasks.Tests.Perf_AsyncMethods.Yield regressed on ARM64",
        "labels":  [
                       "arch-arm64",
                       "area-System.Threading",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/67088",
        "createdAt":  "2022-03-24T09:36:23Z",
        "number":  67088,
        "author":  "KSemenenko",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODBJxDA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ali50m",
                                            "createdAt":  "2022-07-12T00:30:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pedoc",
                                            "createdAt":  "2022-07-21T10:00:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dromer",
                                            "createdAt":  "2023-06-08T19:19:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "proudust",
                                            "createdAt":  "2024-04-24T02:59:09Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "0xfeeddeadbeef",
                                            "createdAt":  "2024-10-05T19:29:33Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rampaa",
                                            "createdAt":  "2025-04-13T12:12:45Z"
                                        }
                                    ],
                          "totalCount":  6
                      },
        "updatedAt":  "2025-08-13T19:38:33Z",
        "body":  "### System timers that can be called once every 1 millisecond.\r\nThis is very difficult to do at the moment,. especially when it comes to cross-platform.\r\nPerhaps we should add such a high-precision system timer, it will come in handy for games or playing MIDI file.\r\n\r\nAs you can see, for small intervals, 15.6 ms is the best average. As you know, this is the standard Windows system timer resolution, which you can read in detail in the document from Microsoft called Timers, Timer Resolution, and Development of Efficient Code (http://download.microsoft.com/download/3/0/2/3027d574-c433-412a-a8b6-5e0a75d5b237/timer-resolution.docx)\r\n\r\n\r\n\u003e The default system-wide timer resolution in Windows is 15.6 ms, which means that every 15.6 ms the operating system \r\n\u003e receives a clock interrupt from the system timer hardware.\r\n\u003e The System.Timers.Timer class has the same resolution as the system clock. \r\n\u003e This means that the Elapsed event will fire at an interval defined by the resolution of the system clock if the Interval property is less than the resolution of the system clock.\r\n\r\nSo as you can see, it cannot be done without using operating system specific functions. or implementing through infinite loop and Task.Wait/Thread.Sleep methods.\r\n\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOvdxMtA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5AODB7",
                                           "createdAt":  "2022-03-24T09:36:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-03-24T09:36:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5AOwVv",
                                           "createdAt":  "2022-03-24T13:09:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### System timers that can be called once every 1 millisecond.\r\nThis is very difficult to do at the moment,. especially when it comes to cross-platform.\r\nPerhaps we should add such a high-precision system timer, it will come in handy for games or playing MIDI file.\r\n\r\nAs you can see, for small intervals, 15.6 ms is the best average. As you know, this is the standard Windows system timer resolution, which you can read in detail in the document from Microsoft called Timers, Timer Resolution, and Development of Efficient Code (http://download.microsoft.com/download/3/0/2/3027d574-c433-412a-a8b6-5e0a75d5b237/timer-resolution.docx)\r\n\r\n\r\n\u003e The default system-wide timer resolution in Windows is 15.6 ms, which means that every 15.6 ms the operating system \r\n\u003e receives a clock interrupt from the system timer hardware.\r\n\u003e The System.Timers.Timer class has the same resolution as the system clock. \r\n\u003e This means that the Elapsed event will fire at an interval defined by the resolution of the system clock if the Interval property is less than the resolution of the system clock.\r\n\r\nSo as you can see, it cannot be done without using operating system specific functions. or implementing through infinite loop and Task.Wait/Thread.Sleep methods.\r\n\r\n\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eKSemenenko\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `tenet-performance`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-03-24T13:09:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5APL4y",
                                           "createdAt":  "2022-03-24T14:58:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCUhKhQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "huoyaoyuan",
                                                                               "createdAt":  "2022-03-24T15:08:40Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tfenise",
                                           "body":  "I don\u0027t think `Thread.Sleep` is helpful here. `Thread.Sleep` is as imprecise.\r\n\r\nQuick test:\r\n```\r\nvar stopwatch = new Stopwatch();\r\nstopwatch.Start();\r\nfor (int i = 0; i \u003c 10; i++)\r\n{\r\n    Thread.Sleep(1);\r\n    Console.WriteLine(stopwatch.ElapsedMilliseconds);\r\n}\r\n```\r\nResults: (Windows x64)\r\n2\r\n17\r\n33\r\n49\r\n64\r\n80\r\n96\r\n111\r\n126\r\n141",
                                           "updatedAt":  "2022-03-24T15:00:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5APqo3",
                                           "createdAt":  "2022-03-24T17:09:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "related\r\nhttps://github.com/dotnet/runtime/issues/27191\r\nhttps://github.com/dotnet/runtime/issues/15207",
                                           "updatedAt":  "2022-03-24T17:09:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5AXTy5",
                                           "createdAt":  "2022-03-27T06:42:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "I\u0027m not sure this is something we can reliably provide as an API due to differing support of various hardware and Operating Systems/platforms.\r\n\r\nMaybe something could be provided with some sort of query that indicates whether such functionality is supported. But even then, OS level thread-scheduling and power management functions might get in the way.\r\n\r\nFor reference, on Windows essentially anything needing higher than `16ms` resolution (the \"default\" time slice) needs to use the \"multimedia\" timers and opt-in. There are then a number of limitations and restrictions around them and it impacts the scheduling/priority of your entire process (and potentially other processes as well).\r\n\r\nSome platforms, such as the `Raspberry PI`, `WASM`, `Android/iOS` in \"power saving mode\", etc, might not support running events this frequently.",
                                           "updatedAt":  "2022-03-27T06:42:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5AgkCx",
                                           "createdAt":  "2022-03-29T19:19:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KSemenenko",
                                           "body":  "For me it would be good, a new type like MultimediaTimer, which will be able to give intervals of 1ms.\r\nOf course it would use the system functions.\r\nAnd of course it will have an impact on the battery, but it will be a conscious choice of the developers if they needs such a timer.\r\n",
                                           "updatedAt":  "2024-10-07T19:04:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5IhiOd",
                                           "createdAt":  "2022-08-16T14:53:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCq4xJA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "GSPP",
                                                                               "createdAt":  "2022-08-18T15:59:31Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "KSemenenko",
                                                                               "createdAt":  "2022-08-21T14:44:18Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "Donis-",
                                           "body":  "Would be nice that such feature could be enabled via `timeBeginPeriod` / `timeEndPeriod` pairs or the not so documented `NtSetTimerResolution`. \r\nTo my surprise, after setting 1ms desired resolution via above APIs, even though Thread.Sleep resolution seems to be affected, the `System.Threading.Timer`s still fire with resolution \u003e10ms.\r\n\r\nOS: Windows 11\r\n.Net 6.0.3\r\n\r\nMy understanding so far:\r\nDefaults observation:\r\nNumber of times one can Thread.Sleep(1) per 1 second: ~64\r\nNumber of GetTickCount64 changes per 1 second: ~64\r\n\r\nAfter setting 1ms resolution via above APIs:\r\nNumber of times one can Thread.Sleep(1) per 1 second: ~666\r\nNumber of GetTickCount64 changes per 1 second: ~64\r\n\r\nSo even though the sleep in timer thread is likely affected correctly by these APIs:\r\n```\r\nvoid ThreadpoolMgr::TimerThreadFire()\r\n..\r\n        SleepEx(timeout, TRUE);\r\n```\r\n\r\nThe problem is that the counts used to determine currentTime elapsing have a resolution of ~10-15ms because GetTickCount / GetTickCount64 is used:\r\n```\r\nDWORD ThreadpoolMgr::FireTimers()\r\n    DWORD currentTime = GetTickCount();\r\n...\r\n            if (TimeExpired(LastTickCount, currentTime, timerInfo-\u003eFiringTime))\r\n            {\r\n```\r\n\r\nWould it be possible to replace `DWORD currentTime = GetTickCount();` with QPC counters / QueryPerformanceCounter if available? or via configuration? ",
                                           "updatedAt":  "2022-08-16T14:53:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JFH3o",
                                           "createdAt":  "2022-08-24T18:24:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCrLcYg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "danmoseley",
                                                                               "createdAt":  "2022-08-24T18:40:28Z"
                                                                           },
                                                                           {
                                                                               "content":  "CONFUSED",
                                                                               "user":  "KSemenenko",
                                                                               "createdAt":  "2022-08-25T21:47:08Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "deeprobin",
                                           "body":  "`NtSetTimerResolution` is undocumented -\u003e we cannot use it.",
                                           "updatedAt":  "2022-08-24T18:24:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JJwt4",
                                           "createdAt":  "2022-08-25T13:54:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KSemenenko",
                                           "body":  "but then how is it done in programs that work with MIDI files, for example?\r\nOr in games?\r\n\r\nAlso, if it\u0027s not a documented feature, can\u0027t Microsoft document it?",
                                           "updatedAt":  "2022-08-25T13:54:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JKPwV",
                                           "createdAt":  "2022-08-25T15:29:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "Many games and other multimedia apps don\u0027t use things like `NtSetTimerResolution`, they actively avoid `sleep` and other \"expensive\" operations.\r\n\r\nInstead they use things like (varying from scenario to scenario of course):\r\n* the high-resolution time stamp APIs (`QueryPerformanceFrequency` and `QueryPerformanceCounter` or `CLOCK_MONOTONIC` on Linux)\r\n* system level fences/events (like `CreateEventW` and `WaitForSingleObject` or `WaitOnAddress`)\r\n* the documented multimedia timer functions (`timeBeginPeriod` and `timeEndPeriod`)\r\n* etc\r\n\r\nDrivers have access to additional APIs (like `ExSetTimerResolution`) and often toggle various settings when you create your first DirectX/Vulkan/OpenGL device.",
                                           "updatedAt":  "2022-08-25T15:29:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JKnl1",
                                           "createdAt":  "2022-08-25T16:49:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "deeprobin",
                                           "body":  "How about emitting `nop`s to make the delay?",
                                           "updatedAt":  "2022-08-25T16:49:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JKwW2",
                                           "createdAt":  "2022-08-25T17:23:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "`nop` takes decoding time but generally no execution time. You wouldn\u0027t want to execute a million `nop` just to wait 0.25-1 millisecond.\r\n\r\nTypically when you want to \"delay\" for a very brief period of time, you emit `pause` (or `yield` on Arm64). On modern CPUs this waits for about 100-140 clock cycles and correctly plays into power management/efficiency settings (which is important for mobile, laptops, and other scenarios).\r\n\r\nIf you need to wait for a longer period of time, but without giving up your time slice, you\u0027d use the system level fences. This is what DirectX12 and Vulkan use in coordination with the GPU fences.",
                                           "updatedAt":  "2022-08-25T17:23:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JLtBA",
                                           "createdAt":  "2022-08-25T22:03:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KSemenenko",
                                           "body":  "```\r\n\r\nwhile (_running)\r\n{\r\n    if (stopwatch.ElapsedMilliseconds - lastTime \u003e= intervalMs)\r\n    {\r\n        callback();\r\n        lastTime = stopwatch.ElapsedMilliseconds;\r\n    }\r\n\r\n    if (!Thread.Yield())\r\n        Thread.Sleep(0);\r\n}\r\n\r\n```",
                                           "updatedAt":  "2022-08-25T22:04:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JLt26",
                                           "createdAt":  "2022-08-25T22:07:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ChrisDenton",
                                           "body":  "On Windows you can also use a waitable timer object with  `CREATE_WAITABLE_TIMER_HIGH_RESOLUTION`. However, this only works since Windows 10 1803 and the actual timer resolution will depend on the underlying hardware.\n\nSee https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createwaitabletimerexw",
                                           "updatedAt":  "2022-08-25T22:07:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JLx4g",
                                           "createdAt":  "2022-08-25T22:35:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCrRHFg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "KSemenenko",
                                                                               "createdAt":  "2022-08-28T20:26:10Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e if (!Thread.Yield())\r\n\u003e         Thread.Sleep(0);\r\n\r\nYou typically don\u0027t want to use `Thread.Yield()` or `Thread.Sleep(0)`, both relinquish the remainder of the allocated time slice and can cause you to not run again until the OS schedule first goes through the queue of equal and higher priority threads waiting to run.\r\n\r\nThe `pause` (x86/x64) and `yield` (Arm32/Arm64) instructions are different from these.\r\n\r\nThis is also why in games you may not want to use the various built-in `System.Threading.*` locking primitives (like `SpinLock`) as these frequently utilize `Yield` or `Sleep` under the hood. Lower level graphics frameworks (like DX12MA) frequently use `SRWLOCK` (Windows) instead, as that provides the relevant behavior without incurring the negative side effects of relinquishing the time slice and thus is suitable for use in such games or other multimedia based applications.\r\n\r\n\r\n\r\n\r\n\r\n",
                                           "updatedAt":  "2022-08-25T22:35:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JSWZz",
                                           "createdAt":  "2022-08-28T20:26:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KSemenenko",
                                           "body":  "Yes, also time for call back excecution.\r\nIt’s timer, so it’s generate event and don’t wait until previous one will be finished ",
                                           "updatedAt":  "2022-08-28T20:26:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JSWjt",
                                           "createdAt":  "2022-08-28T20:29:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KSemenenko",
                                           "body":  "So, only windows api is the blocker?",
                                           "updatedAt":  "2022-08-28T20:29:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JSkx7",
                                           "createdAt":  "2022-08-29T00:47:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "This is not just a Windows limitation, this is a limitation of both hardware and software for almost any platform that might be targeted.\r\n\r\nMost platforms are not designed or oriented around real time execution, targeting sub millisecond execution is not something that really has any guarantees for most platforms and which often requires additional care and work to make partially possible in the first place",
                                           "updatedAt":  "2022-08-29T00:47:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JTxfm",
                                           "createdAt":  "2022-08-29T08:01:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Donis-",
                                           "body":  "\u003e `NtSetTimerResolution` is undocumented -\u003e we cannot use it.\r\n\r\nI\u0027m not advocating that the runtime uses these APIs to change system timers. \r\nUndocumented `NtSetTimerResolution` or documented timeBeginPeriod and timeEndPeriod can be used by the user via pinvoke. \r\n\r\nWhat the user cannot change is the utilization of low resolution GetTickCount / GetTickCount64 in runtime system timers implementation, hence the ask if there could be a use of QueryPerformanceCounter timers, for example:\r\n- Explicitly enabled only via runtime configuration \r\n- Implicitly enabled via OS support ( https://docs.microsoft.com/en-us/windows/win32/sysinfo/acquiring-high-resolution-time-stamps#qpc-support-in-windows-versions )\r\n\r\n\r\n",
                                           "updatedAt":  "2022-08-29T08:01:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JV1Me",
                                           "createdAt":  "2022-08-29T15:15:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "There are many more considerations than simply increasing the timer resolution or utilizing QPC within a timer.\r\n\r\nThis is something that is going to be application specific and which needs to be considered at the very least thread wide for a given process, but more likely also managed even higher at the general process level.\r\n\r\nIt is not something which can be trivially provided by the BCL. The BCL does, however, already expose all the relevant tools such that an interested user could roll their own scenario specific timer after having invoked the relevant platform specific APIs.",
                                           "updatedAt":  "2022-08-29T15:15:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5cv_pw",
                                           "createdAt":  "2023-05-21T05:11:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Slendermid",
                                           "body":  "hello!\r\nif you use timer call from driver (ExSetTimerResolution) all works good. \r\nOnly 1 programm use this timer call is DPC LATENCY CHEKER. just open it and this function is start working.\r\n\r\nbut i have a question. My platform z790 have a 3 timer resoltion in TSC tick. \r\n0.997 0.999 1000\r\nim want use only 1000, but im tired reboot to reboot to get this value. Im want stable 1ms in my system, and i dont want use RTC tick (useplatformtick yes) to get 1ms.\r\nhow to get stable 1000us (not 0.997, 0.999 or like that) on TSC tick?",
                                           "updatedAt":  "2023-05-21T05:11:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5dBNsS",
                                           "createdAt":  "2023-05-24T07:33:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Donis-",
                                           "body":  "@Slendermid sounds like it could be related to \"clock spread spectrum in the BIOS settings\", though not sure. \r\nTry to disable it and retest. ",
                                           "updatedAt":  "2023-05-24T07:33:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5dBQCH",
                                           "createdAt":  "2023-05-24T07:41:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Slendermid",
                                           "body":  "\u003e @Slendermid sounds like it could be related to \"clock spread spectrum in the BIOS settings\", though not sure. Try to disable it and retest.\r\n\r\nim thinking about that, because all z690/z790 on ddr4 memory dont have option to disable bclk spread spectrum, but i have a friend with z790 ddr5 board, and same values. \r\nAlso, base cpu speed is 3.42 not 3.40 like on am4/z390/z490, but if im enable EIST it will be 3.40, anyway, that not resolve problem.\r\nim try to write a driver with 1001 timer res, it give me stable 1000, but after open another program, it decrease to 0.997.\r\nMaybe have any function to stable lock timer to 1000us?",
                                           "updatedAt":  "2023-05-24T07:41:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5dETAL",
                                           "createdAt":  "2023-05-24T15:42:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "\u003e  write a driver\r\n\r\nYou\u0027re trying to write a driver in C#?  Good luck with that - you\u0027d be better off with C/C++ or Rust.\r\n\r\n\u003e Maybe have any function to stable lock timer to 1000us?\r\n\r\nThis is an OS/hardware layer concern, and C# doesn\u0027t natively provide a way to even get a timer at that resolution, and so we\u0027re unlikely to be able to provide something like that in the first place.\r\nI\u0027m not sure such a thing would even actually be provided (at least not on standard consumer hardware/OS) - your driver/whatever is normally expected to handle the actual delta that occurred, not assume it was completely static.",
                                           "updatedAt":  "2023-05-24T15:42:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5dEcgN",
                                           "createdAt":  "2023-05-24T15:54:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Slendermid",
                                           "body":  "my code in driver: (also im not a good coder) \r\n\r\n#include \u003cntddk.h\u003e\r\nNTSTATUS DriverEntry()\r\n{\r\n    ExSetTimerResolution(10000, TRUE);\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\ni know is hardware issue or like that, but if system can get 1000 or 0.9999 randomly (instead of 0.9966) i think we can lock it on 1000. If the system has chosen 0.9966 timer res i can stable it to 1000, but if another programm call timer (1ms), it decrese to 0.9966. Im prefer 0.9999 or 1000 because that values have lowest Kernel Timer Latency. (1-3us vs ~950us). Also RTC tick with always stable 1000 timer res give me 1000us kernel latency. ",
                                           "updatedAt":  "2023-05-24T15:54:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6OwyX9",
                                           "createdAt":  "2024-10-05T18:41:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD1JDrg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "0xfeeddeadbeef",
                                                                               "createdAt":  "2024-10-05T19:29:25Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "neuecc",
                                                                               "createdAt":  "2024-10-07T06:23:19Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "KSemenenko",
                                                                               "createdAt":  "2024-10-07T19:07:04Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "azhmur",
                                           "body":  "Some MS guys just did it for GO on Windows: https://devblogs.microsoft.com/go/high-resolution-timers-windows/\r\n(And it seems it was working for GO on linux for a long time)\r\nI suppose Net can have similar approach implemented as well.",
                                           "updatedAt":  "2024-10-05T18:41:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6O6bSz",
                                           "createdAt":  "2024-10-07T19:08:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KSemenenko",
                                           "body":  "So maybe in .NET 10 then ? 😉",
                                           "updatedAt":  "2024-10-07T19:08:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6O6cwL",
                                           "createdAt":  "2024-10-07T19:11:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "As per the above, there is a \"lot\" of complexity in doing this and doing it correctly. It\u0027s also not something that can be strictly guaranteed across all systems/hardware and the places it is needed are a bit more niche.\r\n\r\nDue to all of that, this isn\u0027t something I can see getting prioritized for .NET 10. However, there is nothing preventing a 3rd party library from being created that provides the functionality in the meantime.",
                                           "updatedAt":  "2024-10-07T19:11:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6f1qAO",
                                           "createdAt":  "2025-02-25T11:29:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOENGzAA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "azhmur",
                                                                               "createdAt":  "2025-02-25T11:34:35Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "KSemenenko",
                                                                               "createdAt":  "2025-02-25T12:14:30Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "airtaxi",
                                                                               "createdAt":  "2025-04-07T01:52:57Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "Uight",
                                           "body":  "I did check the approach from https://devblogs.microsoft.com/go/high-resolution-timers-windows/\nin a little test project i did: https://github.com/Uight/QuickTick\nBasically it works and seems to even be superior to using timeSetEvent winmm api or the newer CreateTimerQueueTimer together with timeBeginPeriod to get sub 15.6ms resolution.\nHowever i can only agree to things said before in this issue. Doing a right implementation is hard and with scheduling/priority problems and windows not being a Realtime-System you can create a timer like this but you shouldnt expect it to really precise. \nE.g. from my tests you regularly get a peak in the interval sometimes even up to 30ms altough setting the timer to 1ms. The only thing you can get with timers like this is that you can achieve an average interval of below 15.6ms but dont try to get a precise 1ms timing because when you set that youll either get zero times or over 1.5ms with an average of 1ms...\nAlso power saving mode seems to play a big role. With this particular implementation completly stopping when your in power saving mode.\nAnother factor as stated above is the cpu or the general system setup. Some of my findings:\n1. Win10 seems to be more precise than Win11\n2. If you use WinDefender for business and dont have an exclude on the particular service timing is completly unpredictible\n3. PCs that can not boost (mostly industry PC with a set cpu clock speed) are way more precise and stable\n\nThis isnt really about .net but more about windows. In dotnet you can get pretty much perfect timers if you use .net8.0 and run it on linux and use one of the mainLine Linux kernels which have the rt patch fully integrated since end of last year. (Provided your cpu has plenty of headroom)\n\nSmall update: \nIt might be a dotnet runtime thing after all. Because you can run the very same code in c++ directily and you get a very very stable timer down to 1ms without a problem. Im not sure exactly how windows or the dotnet runtime handles the the thread that is waiting for GetQueuedCompletionStatus. In c++ that thread can instantly be signaled. giving high timer precision but in .net on the same system this can take significant time to get the thread to be signaled/run. This is evident because you can increase the threads priority and that can increase the timers accurancy greatly. On linux you also dont seem to have that problem (other timer of course) as the dotnet runtime doesnt seem to have the same scheduling overhead as on windows)  \n\n",
                                           "updatedAt":  "2025-02-27T08:54:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6f2IBn",
                                           "createdAt":  "2025-02-25T12:15:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KSemenenko",
                                           "body":  "Wow, thanks for this amazing info!",
                                           "updatedAt":  "2025-02-25T12:15:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6gMa8y",
                                           "createdAt":  "2025-02-27T11:00:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEdw0aw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "azhmur",
                                                                               "createdAt":  "2025-02-27T11:01:28Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "KSemenenko",
                                                                               "createdAt":  "2025-02-27T11:43:16Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "lethek",
                                                                               "createdAt":  "2025-04-01T02:39:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "airtaxi",
                                                                               "createdAt":  "2025-04-07T01:49:55Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nolife99",
                                                                               "createdAt":  "2025-08-10T15:31:46Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  5
                                                         },
                                           "author":  "Uight",
                                           "body":  "I now did clean the code a bit and created a semi clean version  which is also on nuget: https://www.nuget.org/packages/QuickTickLib/\nif you wanna test it or modify the code feel free to do so.\nMaybe theres more to get from this approach. But im definitly not an expert in Windows Api calls or threading/scheduling.\n\nJust be aware that for the timer the event code is currently executed within the internal timing loop as i couldnt get a clean solution for that. The timer is set up in a way that it holds the interval provided as an average and is normaly accurate to within 1ms. Sleeping or delaying for one 1ms typically is more around 1.5ms which i guess is way better than 15.6ms \nCould be a valid approach to get better timers on windows. But for me coming from realtime systems i find it sad that i cant get a accurate timing to lets say 200µs on a multi gigahertz system with .net on windows ;)\n\nUpdate (April 12th 2025): cleanup up that package so its pretty much safe to use now. ",
                                           "updatedAt":  "2025-04-12T13:34:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc693Ey0",
                                           "createdAt":  "2025-08-13T19:38:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEejGaQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "ROCKET",
                                                                               "user":  "KSemenenko",
                                                                               "createdAt":  "2025-08-17T14:35:42Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Uight",
                                           "body":  "So im still working on my timer implementation using the approach the GO team used. And as said before the timer works fine and i guess the Sleep function is actually done.\nBut with the timer i have several problems related to the fallback i want to use when im not on windows (e.g. linux. mac os, android)\nand then i run into a strange problem. Im trying to use the System.Timers.Timer for a fallback because under linux it has a good timing but what i find strange and dont find any information about is basically this:\n\nhttps://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Threading/Timer.cs#L223-L231\n\nthe code in the timer even has documentation about not allowing \"zero ticks\" (that how i call instant refire). This is for example the reason why the timer couldnt even hold the correct average for sub 15.625ms timers. because it reschedules with 1ms and that again would take 15.625ms instead of firing the event code instantly multiple times to catch up. This would in my opinion also be the reason why you wouldnt get a 1ms timer even if you set the system timer to its absolute min of 0.5ms (dont know which functiona llowed that since timebegin perios only goes to 1ms).\nNow with Linux this 1ms limit would cause a problem since linux can hold 1ms and would never catch up if only rescheduling a full milliseconds. But despite the code explicitly stating 1ms in minimum i clearly observed zero ticks with a 1ms timer in linux (not many but still):\n\n\u003cimg width=\"563\" height=\"361\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/9ef022f7-d345-4835-b6c3-ca1d2e605402\" /\u003e\n\n(92 zero ticks)\n\nI couldn\u0027t find any switch in the actual .net code so i assume its done on the runtime level but that would then lead me to the question why allow zero ticks on linux (maybe also ios andoraif (all unix based)) but not on windows?\n\nMy timer implementation currently does zero ticks too (in a test branch you can disable that) but i would like to know if someone could shed light on the timers for all the systems \u003e.net 8 runtime support because there seems to be some mismatches. \n\nIs allowing a \"zero tick\" actually the expected behavior or is the windows implementation where you can never catch up for under 1ms the expected behavior for a timer?  \nNiche question i guess but the issue explicitly says 1ms timer and for 1ms timer the case of missing a tick completly isnt uncommon under any system so what would be the \"accepted\" solution?\n\nBasically what @tannergooding said before:\n\u003e As per the above, there is a \"lot\" of complexity in doing this and doing it correctly. It\u0027s also not something that can be strictly guaranteed across all systems/hardware and the places it is needed are a bit more niche.\n\nBut id still want to know what would be deemed acceptable for all the platforms.",
                                           "updatedAt":  "2025-08-13T19:38:33Z"
                                       }
                                   ],
                         "totalCount":  32
                     },
        "title":  "System Timer with 1 millisecond interval.",
        "labels":  [
                       "area-System.Threading",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/67266",
        "createdAt":  "2022-03-28T22:23:36Z",
        "number":  67266,
        "author":  "kunalspathak",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-03T21:32:51Z",
        "body":  "Today, depending on the number of processors, we create IO completion poller threads. Back then, we did our analysis on older Arm64 machines to come up with the heuristic and they can be different on modern Arm64 machines. We need to revisit them or have some kind of auto-tuning of number of threads creation. \r\n\r\nhttps://github.com/dotnet/runtime/blob/0e35b8d33851efde52e4e7aaadac239f3c2e97d5/src/libraries/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncEngine.Unix.cs#L52-L57\r\n\r\nhttps://github.com/dotnet/runtime/blob/39b3aace26cc8f27e8d1ea1af0b9d234f7b6d867/src/libraries/System.Private.CoreLib/src/System/Threading/PortableThreadPool.IO.Windows.cs#L41-L43\r\n\r\nRelated: https://github.com/dotnet/runtime/issues/67180",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHORq4Tkg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5Acf_6",
                                           "createdAt":  "2022-03-28T22:23:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-03-28T22:23:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5AcgJd",
                                           "createdAt":  "2022-03-28T22:24:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kunalspathak",
                                           "body":  "@mangod9 ",
                                           "updatedAt":  "2022-03-28T22:24:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5AcgJj",
                                           "createdAt":  "2022-03-28T22:24:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nToday, depending on the number of processors, we create IO completion poller threads. Back then, we did our analysis on older Arm64 machines to come up with the heuristic and they can be different on modern Arm64 machines. We need to revisit them or have some kind of auto-tuning of number of threads creation. \r\n\r\nhttps://github.com/dotnet/runtime/blob/0e35b8d33851efde52e4e7aaadac239f3c2e97d5/src/libraries/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncEngine.Unix.cs#L52-L57\r\n\r\nhttps://github.com/dotnet/runtime/blob/39b3aace26cc8f27e8d1ea1af0b9d234f7b6d867/src/libraries/System.Private.CoreLib/src/System/Threading/PortableThreadPool.IO.Windows.cs#L41-L43\r\n\r\nRelated: https://github.com/dotnet/runtime/issues/67180\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ekunalspathak\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-03-28T22:24:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5AcjcU",
                                           "createdAt":  "2022-03-28T22:48:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "@kouvel as fyi. ",
                                           "updatedAt":  "2022-03-28T22:48:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5AeNp_",
                                           "createdAt":  "2022-03-29T09:49:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "cc: @dotnet/ncl ",
                                           "updatedAt":  "2022-03-29T09:49:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Bfcb3",
                                           "createdAt":  "2022-04-14T06:38:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCYCQCw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kunalspathak",
                                                                               "createdAt":  "2022-04-14T08:06:33Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "FWIW I am the person who came up with the magic numbers on Unix. [Here](https://github.com/dotnet/runtime/pull/35800#issuecomment-624719500) you can find the data and reasoning behind it.\r\n\r\nRecently after a conversation with @kunalspathak I wanted to give it a quick try and see how the number of epoll threads affects the throughput of JSON Platform benchmark on the Ampere machine. Currently more than 80% of time is spent in `ConcurrentDictionary.TryDequeue` and we need to solve this blocker (#67845, https://github.com/dotnet/aspnetcore/pull/40476) before we try to change the number of epoll threads.\r\n\r\narm64 with 80 cores::\r\n\r\n![image](https://user-images.githubusercontent.com/6011991/163327493-ecca8e76-6681-48f1-8b0f-7052173d31cd.png)\r\n\r\nx64 with 28 cores:\r\n\r\n![image](https://user-images.githubusercontent.com/6011991/163328131-f903636a-cb7e-4120-96a2-4728a5ffba94.png)\r\n",
                                           "updatedAt":  "2022-04-14T06:38:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5EZ-sY",
                                           "createdAt":  "2022-06-06T16:49:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kunalspathak",
                                           "body":  "@mangod9 - Do you think we will be doing this in .NET 7?",
                                           "updatedAt":  "2022-06-06T16:49:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5EZ_Up",
                                           "createdAt":  "2022-06-06T16:52:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCgahEg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kunalspathak",
                                                                               "createdAt":  "2022-06-06T17:02:23Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "mangod9",
                                           "body":  "yeah we hope to investigate this soon. Might be worth validating again after the concurrent queue fix. ",
                                           "updatedAt":  "2022-06-06T16:52:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GrhOS",
                                           "createdAt":  "2022-07-15T18:46:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCnJmwA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "adamsitnik",
                                                                               "createdAt":  "2022-07-18T10:47:59Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "kouvel",
                                           "body":  "On the Linux Ampere machine, quick tests on JsonPlatform and Json didn\u0027t show any significant improvements from decreasing the IO poller thread counts. It still seems like relatively more IO poller threads are necessary on arm64 platforms than on x64 platforms. Probably the heuristics could be more fine-tuned, and I haven\u0027t done an exhaustive test.",
                                           "updatedAt":  "2022-07-15T18:46:10Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "Arm64: Revisit the heuristics for IO completion poller threads",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/67808",
        "createdAt":  "2022-04-09T17:12:49Z",
        "number":  67808,
        "author":  "medo64",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODB-IdA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SupinePandora43",
                                            "createdAt":  "2022-07-02T09:31:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Enderlook",
                                            "createdAt":  "2022-07-02T10:48:49Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hexawyz",
                                            "createdAt":  "2023-08-28T02:41:44Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kevingosse",
                                            "createdAt":  "2024-01-13T10:52:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Saalvage",
                                            "createdAt":  "2024-12-13T14:16:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jkrejcha",
                                            "createdAt":  "2025-02-13T07:18:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "TFlippy",
                                            "createdAt":  "2025-02-17T20:21:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MichalPetryka",
                                            "createdAt":  "2025-05-02T16:58:00Z"
                                        }
                                    ],
                          "totalCount":  8
                      },
        "updatedAt":  "2023-06-23T20:30:11Z",
        "body":  "### Background and motivation\n\nIf one does interlocked operations, they can do so with uint, int, ulong, and long. However, nint and nuint as native integer sizes do not have their overloads in Interlocked class.\r\n\r\nI believe it would be useful that nint and nuint overloads be added to Interlocked class as updating them in thread safe manners currently requires a lock.\r\n\n\n### API Proposal\n\n```C#\r\nnamespace System.Threading\r\n{\r\n    public static partial class Interlocked\r\n    {\r\n        public static nint Increment(ref nint location) =\u003e\r\n            Add(ref location, 1);\r\n\r\n        public static nuint Increment(ref nuint location) =\u003e\r\n            Add(ref location, 1);\r\n\r\n        public static nint Decrement(ref nint location) =\u003e\r\n            Add(ref location, -1);\r\n\r\n        public static nuint Decrement(ref nuint location) =\u003e\r\n            (nuint)Add(ref Unsafe.As\u003cnuint, nint\u003e(ref location), -1);\r\n\r\n        public static extern nint Exchange(ref nint location1, nint value);\r\n\r\n        public static extern nuint Exchange(ref nuint location1, nuint value) =\u003e\r\n            (nuint)Exchange(ref Unsafe.As\u003cnuint, nint\u003e(ref location1), (nint)value);\r\n\r\n        public static extern nint CompareExchange(ref nint location1, nint value, nint comparand);\r\n\r\n        public static extern nuint CompareExchange(ref nuint location1, nuint value, nuint comparand) =\u003e\r\n            (nuint)CompareExchange(ref Unsafe.As\u003cnuint, nint\u003e(ref location1), (nint)value, (nint)comparand);\r\n\r\n        public static nint Add(ref nint location1, nint value) =\u003e\r\n            ExchangeAdd(ref location1, value) + value;\r\n\r\n        public static nuint Add(ref nuint location1, nuint value) =\u003e\r\n            (nuint)Add(ref Unsafe.As\u003cnuint, nint\u003e(ref location1), (nint)value);\r\n\r\n        private static extern nint ExchangeAdd(ref nint location1, nint value);\r\n\r\n        public static nint And(ref nint location1, nint value);\r\n\r\n        public static nuint Add(ref nuint location1, nuint value) =\u003e\r\n            (nuint)Add(ref Unsafe.As\u003cnuint, nint\u003e(ref location1), (nint)value);\r\n\r\n        public static nint And(ref nint location1, nint value)\r\n\r\n        public static nuint And(ref nuint location1, nuint value) =\u003e\r\n            (nuint)And(ref Unsafe.As\u003cnuint, nint\u003e(ref location1), (nint)value);\r\n\r\n        public static nint Or(ref nint location1, nint value);\r\n\r\n        public static nuint Or(ref nuint location1, nuint value) =\u003e\r\n            (nuint)Or(ref Unsafe.As\u003cnuint, nint\u003e(ref location1), (nint)value);\r\n\r\n    }\r\n}\r\n```\r\n\r\n\n\n### API Usage\n\nAPI would be used as for int/uint types, e.g.\r\n\r\n```C#\r\n// Fancy the value\r\nnint x = 0;\r\nInterlocked.Increment(ref x);\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHORi5I-A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5BNnQQ",
                                           "createdAt":  "2022-04-09T17:12:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nIf one does interlocked operations, they can do so with uint, int, ulong, and long. However, nint and nuint as native integer sizes do not have their overloads in Interlocked class.\r\n\r\nI believe it would be useful that nint and nuint overloads be added to Interlocked class as updating them in thread safe manners currently requires a lock.\r\n\n\n### API Proposal\n\n```C#\r\nnamespace System.Threading\r\n{\r\n    public static partial class Interlocked\r\n    {\r\n        public static nint Increment(ref nint location) =\u003e\r\n            Add(ref location, 1);\r\n\r\n        public static nuint Increment(ref nuint location) =\u003e\r\n            Add(ref location, 1);\r\n\r\n        public static nint Decrement(ref nint location) =\u003e\r\n            Add(ref location, -1);\r\n\r\n        public static nuint Decrement(ref nuint location) =\u003e\r\n            (nuint)Add(ref Unsafe.As\u003cnuint, nint\u003e(ref location), -1);\r\n\r\n        public static extern nint Exchange(ref nint location1, nint value);\r\n\r\n        public static extern nuint Exchange(ref nuint location1, nuint value) =\u003e\r\n            (nuint)Exchange(ref Unsafe.As\u003cnuint, nint\u003e(ref location1), (nint)value);\r\n\r\n        public static extern nint CompareExchange(ref nint location1, nint value, nint comparand);\r\n\r\n        public static extern nuint CompareExchange(ref nuint location1, nuint value, nuint comparand) =\u003e\r\n            (nuint)CompareExchange(ref Unsafe.As\u003cnuint, nint\u003e(ref location1), (nint)value, (nint)comparand);\r\n\r\n        public static nint Add(ref nint location1, nint value) =\u003e\r\n            ExchangeAdd(ref location1, value) + value;\r\n\r\n        public static nuint Add(ref nuint location1, nuint value) =\u003e\r\n            (nuint)Add(ref Unsafe.As\u003cnuint, nint\u003e(ref location1), (nint)value);\r\n\r\n        private static extern nint ExchangeAdd(ref nint location1, nint value);\r\n\r\n        public static nint And(ref nint location1, nint value);\r\n\r\n        public static nuint Add(ref nuint location1, nuint value) =\u003e\r\n            (nuint)Add(ref Unsafe.As\u003cnuint, nint\u003e(ref location1), (nint)value);\r\n\r\n        public static nint And(ref nint location1, nint value)\r\n\r\n        public static nuint And(ref nuint location1, nuint value) =\u003e\r\n            (nuint)And(ref Unsafe.As\u003cnuint, nint\u003e(ref location1), (nint)value);\r\n\r\n        public static nint Or(ref nint location1, nint value);\r\n\r\n        public static nuint Or(ref nuint location1, nuint value) =\u003e\r\n            (nuint)Or(ref Unsafe.As\u003cnuint, nint\u003e(ref location1), (nint)value);\r\n\r\n    }\r\n}\r\n```\r\n\r\n\n\n### API Usage\n\nAPI would be used as for int/uint types, e.g.\r\n\r\n```C#\r\n// Fancy the value\r\nnint x = 0;\r\nInterlocked.Increment(ref x);\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003emedo64\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-04-09T17:12:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5F6Kng",
                                           "createdAt":  "2022-07-02T10:29:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "SupinePandora43",
                                           "body":  "It can be implemented on top of (U)Int(32/64):\r\n```cs\r\npublic static nuint Increment(ref nuint location) =\u003e (nuint)(sizeof(nuint) is sizeof(ulong) ? Interlocked.Increment(ref Unsafe.As\u003cnuint, ulong\u003e(ref location)) : Interlocked.Increment(ref Unsafe.As\u003cnuint, uint\u003e(ref location)));\r\n```\n[sharplab](https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA0AXEBDAzgWwB8ABABgAJiBGAOgCUBXAOwwEt8YaBhCfAB1YAbGFADKIgG6swMXAG4AsACgylWgBUAFrGwATVkwDmipcuIBmNUnLNc2AGYxKAJnJdyAb2XkflS9WsGAwxyAEkmMFgOFgAKWHsbYPJBCDBsNggmAEpyAF4APjCWERSwAGsYXRpwyJhojDiYBNL01kysk18/KxsUoyLa+saEhj7DZNTW9rzC8IwS1IqqmqiYWPiJtIzszt8LHqYglgHV9abyQ6SW7ZyC8hjLliyY3FYALxgIewejjBzWXDkV4fL4xUaZQw5AD8RXmUFKS2qEVODQ2AFUmHZHDQAIK4AA8jwwaF6EPyw02U2yORAsIW5UqSMGa1R5wxWM4eMJvxJv3JG2ubWpHWUAF8gA==)",
                                           "updatedAt":  "2022-07-02T10:39:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GLkj4",
                                           "createdAt":  "2022-07-07T11:15:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "\u003e ```C#\r\n\u003e public static extern nint Exchange(ref nint location1, nint value);\r\n\u003e\r\n\u003e public static extern nuint Exchange(ref nuint location1, nuint value) =\u003e\r\n\u003e     (nuint)Exchange(ref Unsafe.As\u003cnuint, nint\u003e(ref location1), (nint)value);\r\n\u003e\r\n\u003e public static extern nint CompareExchange(ref nint location1, nint value, nint comparand);\r\n\u003e\r\n\u003e public static extern nuint CompareExchange(ref nuint location1, nuint value, nuint comparand) =\u003e\r\n\u003e     (nuint)CompareExchange(ref Unsafe.As\u003cnuint, nint\u003e(ref location1), (nint)value, (nint)comparand);\r\n\u003e ```\r\n\r\n`Interlocked` already provides those methods, given that \u003chttps://github.com/dotnet/csharplang/issues/4385\u003e makes `nint` and `nuint` simply aliases for `IntPtr` and `UIntPtr`:\r\n\r\n- [public static IntPtr Exchange (ref IntPtr location1, IntPtr value)](https://docs.microsoft.com/dotnet/api/system.threading.interlocked.exchange?view=net-7.0#system-threading-interlocked-exchange(system-intptr@-system-intptr))\r\n- [public static UIntPtr Exchange (ref UIntPtr location1, UIntPtr value)](https://docs.microsoft.com/dotnet/api/system.threading.interlocked.exchange?view=net-7.0#system-threading-interlocked-exchange(system-uintptr@-system-uintptr))\r\n- [public static IntPtr CompareExchange (ref IntPtr location1, IntPtr value, IntPtr comparand)](https://docs.microsoft.com/dotnet/api/system.threading.interlocked.compareexchange?view=net-7.0#system-threading-interlocked-compareexchange(system-intptr@-system-intptr-system-intptr))\r\n- [public static UIntPtr CompareExchange (ref UIntPtr location1, UIntPtr value, UIntPtr comparand)](https://docs.microsoft.com/dotnet/api/system.threading.interlocked.compareexchange?view=net-7.0#system-threading-interlocked-compareexchange(system-uintptr@-system-uintptr-system-uintptr))",
                                           "updatedAt":  "2022-07-07T11:15:19Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "[API Proposal]: Interlocked operation should allow for nint",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/67809",
        "createdAt":  "2022-04-09T17:24:50Z",
        "number":  67809,
        "author":  "medo64",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC5Xe4Q==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "GSPP",
                                            "createdAt":  "2022-04-16T06:08:20Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Enderlook",
                                            "createdAt":  "2022-06-02T01:05:50Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sakno",
                                            "createdAt":  "2023-03-24T21:25:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Wraith2",
                                            "createdAt":  "2023-03-24T23:45:33Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hexawyz",
                                            "createdAt":  "2023-08-27T23:41:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "onionhammer",
                                            "createdAt":  "2024-03-13T21:21:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "timcassell",
                                            "createdAt":  "2024-07-14T20:51:17Z"
                                        }
                                    ],
                          "totalCount":  7
                      },
        "updatedAt":  "2023-03-24T21:35:31Z",
        "body":  "### Background and motivation\n\nCurrently Interlocked class contains And and Or logical operations. For completeness, it would be nice if also Xor and Not were supported. Implementation would be exactly the same as for the existing logical operations.\n\n### API Proposal\n\n```C#\r\nnamespace System.Threading\r\n{\r\n    public static partial class Interlocked\r\n    {\r\n\r\n        public static int Xor(ref int location1, int value)\r\n        {\r\n            int current = location1;\r\n            while (true)\r\n            {\r\n                int newValue = current ^ value;\r\n                int oldValue = CompareExchange(ref location1, newValue, current);\r\n                if (oldValue == current)\r\n                {\r\n                    return oldValue;\r\n                }\r\n                current = oldValue;\r\n            }\r\n        }\r\n\r\n        public static uint Xor(ref uint location1, uint value) =\u003e\r\n            (uint)Xor(ref Unsafe.As\u003cuint, int\u003e(ref location1), (int)value);\r\n\r\n        public static long Xor(ref long location1, long value)\r\n        {\r\n            long current = location1;\r\n            while (true)\r\n            {\r\n                long newValue = current ^ value;\r\n                long oldValue = CompareExchange(ref location1, newValue, current);\r\n                if (oldValue == current)\r\n                {\r\n                    return oldValue;\r\n                }\r\n                current = oldValue;\r\n            }\r\n        }\r\n\r\n        public static ulong Xor(ref ulong location1, ulong value) =\u003e\r\n            (ulong)Xor(ref Unsafe.As\u003culong, long\u003e(ref location1), (long)value);\r\n\r\n\r\n        public static int Not(ref int location1)\r\n        {\r\n            int current = location1;\r\n            while (true)\r\n            {\r\n                int newValue = !current;\r\n                int oldValue = CompareExchange(ref location1, newValue, current);\r\n                if (oldValue == current)\r\n                {\r\n                    return oldValue;\r\n                }\r\n                current = oldValue;\r\n            }\r\n        }\r\n\r\n        public static uint Not(ref uint location1) =\u003e\r\n            (uint)Not(ref Unsafe.As\u003cuint, int\u003e(ref location1));\r\n\r\n        public static long Not(ref long location1)\r\n        {\r\n            long current = location1;\r\n            while (true)\r\n            {\r\n                long newValue = !current;\r\n                long oldValue = CompareExchange(ref location1, newValue, current);\r\n                if (oldValue == current)\r\n                {\r\n                    return oldValue;\r\n                }\r\n                current = oldValue;\r\n            }\r\n        }\r\n\r\n        public static ulong Not(ref ulong location1) =\u003e\r\n            (ulong)Not(ref Unsafe.As\u003culong, long\u003e(ref location1));\r\n\r\n    }\r\n}\r\n```\r\n\n\n### API Usage\n\nUsage would be equivalent to usage of And and Or functions.\r\n\r\n```C#\r\nvar x = 42;\r\nInterlocked.Xor(ref x, 42);\r\nInterlocked.Not(ref x);\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOWGtoog==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5BNnwk",
                                           "createdAt":  "2022-04-09T17:24:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-04-09T17:24:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5BNocU",
                                           "createdAt":  "2022-04-09T17:38:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nCurrently Interlocked class contains And and Or logical operations. For completeness, it would be nice if also Xor and Not were supported. Implementation would be exactly the same as for the existing logical operations.\n\n### API Proposal\n\n```C#\r\nnamespace System.Threading\r\n{\r\n    public static partial class Interlocked\r\n    {\r\n\r\n        public static int Xor(ref int location1, int value)\r\n        {\r\n            int current = location1;\r\n            while (true)\r\n            {\r\n                int newValue = current ^ value;\r\n                int oldValue = CompareExchange(ref location1, newValue, current);\r\n                if (oldValue == current)\r\n                {\r\n                    return oldValue;\r\n                }\r\n                current = oldValue;\r\n            }\r\n        }\r\n\r\n        public static uint Xor(ref uint location1, uint value) =\u003e\r\n            (uint)Xor(ref Unsafe.As\u003cuint, int\u003e(ref location1), (int)value);\r\n\r\n        public static long Xor(ref long location1, long value)\r\n        {\r\n            long current = location1;\r\n            while (true)\r\n            {\r\n                long newValue = current ^ value;\r\n                long oldValue = CompareExchange(ref location1, newValue, current);\r\n                if (oldValue == current)\r\n                {\r\n                    return oldValue;\r\n                }\r\n                current = oldValue;\r\n            }\r\n        }\r\n\r\n        public static ulong Xor(ref ulong location1, ulong value) =\u003e\r\n            (ulong)Xor(ref Unsafe.As\u003culong, long\u003e(ref location1), (long)value);\r\n\r\n\r\n        public static int Not(ref int location1)\r\n        {\r\n            int current = location1;\r\n            while (true)\r\n            {\r\n                int newValue = !current;\r\n                int oldValue = CompareExchange(ref location1, newValue, current);\r\n                if (oldValue == current)\r\n                {\r\n                    return oldValue;\r\n                }\r\n                current = oldValue;\r\n            }\r\n        }\r\n\r\n        public static uint Not(ref uint location1) =\u003e\r\n            (uint)Not(ref Unsafe.As\u003cuint, int\u003e(ref location1));\r\n\r\n        public static long Not(ref long location1)\r\n        {\r\n            long current = location1;\r\n            while (true)\r\n            {\r\n                long newValue = !current;\r\n                long oldValue = CompareExchange(ref location1, newValue, current);\r\n                if (oldValue == current)\r\n                {\r\n                    return oldValue;\r\n                }\r\n                current = oldValue;\r\n            }\r\n        }\r\n\r\n        public static ulong Not(ref ulong location1) =\u003e\r\n            (ulong)Not(ref Unsafe.As\u003culong, long\u003e(ref location1));\r\n\r\n    }\r\n}\r\n```\r\n\n\n### API Usage\n\nUsage would be equivalent to usage of And and Or functions.\r\n\r\n```C#\r\nvar x = 42;\r\nInterlocked.Xor(ref x, 42);\r\nInterlocked.Not(ref x);\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003emedo64\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-04-09T17:38:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5BNpPj",
                                           "createdAt":  "2022-04-09T17:55:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e  For completeness\r\n\r\nCan you share some concrete examples in some repos where these would be used? ",
                                           "updatedAt":  "2022-04-09T17:55:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5BNpzD",
                                           "createdAt":  "2022-04-09T18:07:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "medo64",
                                           "body":  "Actually a surprising number of simple hardware devices use either pure XOR for checksums (for example NMEA protocol) or as a part of computation. In my example, I was trying to parallelize CRC32 calculations which essentially consist of a lookup table (thread-safe) and a Xor.\r\n\r\nThat said, it\u0027s not that Interlocked XOR is really irreplaceable but seeing \"And\" and \"Or\" operations without it seems incomplete. :)",
                                           "updatedAt":  "2022-04-09T18:21:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5BNrZL",
                                           "createdAt":  "2022-04-09T18:42:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e it\u0027s not that Interlocked XOR is really irreplaceable but seeing \"And\" and \"Or\" operations without it seems incomplete\r\n\r\nWe discussed Xor when And and Or were added and opted not to include it because of lack of real uses in C#.",
                                           "updatedAt":  "2022-04-09T18:42:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5BNsGU",
                                           "createdAt":  "2022-04-09T19:01:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODptB8w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "medo64",
                                                                               "createdAt":  "2022-04-09T19:18:09Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "giladfrid009",
                                                                               "createdAt":  "2022-04-09T21:24:11Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "theodorzoulias",
                                                                               "createdAt":  "2022-04-10T02:26:06Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "D3-LucaPiombino",
                                                                               "createdAt":  "2022-04-10T13:36:17Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "filipnavara",
                                                                               "createdAt":  "2022-04-11T13:11:13Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "GSPP",
                                                                               "createdAt":  "2022-04-16T06:08:44Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AmrAlSayed0",
                                                                               "createdAt":  "2022-07-02T17:11:00Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hexawyz",
                                                                               "createdAt":  "2023-08-27T23:06:08Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "timcassell",
                                                                               "createdAt":  "2024-07-14T20:52:07Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  9
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "I\u0027m still of the mindset that these \"primitive operations\" are worth adding regardless. It represents functionality that only the JIT can reasonably provide. Users can technically implement some much less efficient version themselves, but for the variants that provide hardware acceleration and are as performant as possible is something that only the runtime can provide.\r\n\r\n`Xor` in particular is necessary for toggling bits and its a functionality that almost all languages that provide interlocked/atomic operations provide as part of their set of built ins. If you just go around and look for usages of `InterlockedXor` for MSVC, you can see its use for things like dealing with which threads or pooled contexts are available vs taken in multithreaded environments. You can see similar usages for `atomic_fetch_xor`. It\u0027s the same thing `xor` is generally used for, just as an efficient \"thread-safe\" operation.",
                                           "updatedAt":  "2022-04-09T19:02:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5BNs2a",
                                           "createdAt":  "2022-04-09T19:21:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCXQEQA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2022-04-10T03:16:10Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "And I\u0027m still of the mindset it doesn\u0027t matter how fast we make something if it\u0027s not used meaningfully (also, And and Or were merged two years ago and still aren\u0027t optimized as intrinsics by the JIT, at least not on x86/64). I\u0027ve also stated numerous times I\u0027m fine adding Interlocked.Xor if folks can share real examples where it\u0027d be used in real .NET apps/services/libraries, e.g. where devs have implemented and are using their own InterlockedXor in C#, and no one has shared such examples. ",
                                           "updatedAt":  "2022-04-09T19:42:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5BNtdJ",
                                           "createdAt":  "2022-04-09T19:38:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Wraith2",
                                           "body":  "\u003e And and Or were merged two years ago and still aren\u0027t optimized as intrinsics by the JIT)\r\n\r\nIs there an issue tracking this? If not then it\u0027s unlikely that the jit team would have the time to do it and no-one else would know about it. ",
                                           "updatedAt":  "2022-04-09T19:38:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5BNtg7",
                                           "createdAt":  "2022-04-09T19:39:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCXN26Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Wraith2",
                                                                               "createdAt":  "2022-04-09T19:50:28Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Yes, there is:\r\nhttps://github.com/dotnet/runtime/issues/32239",
                                           "updatedAt":  "2022-04-09T19:39:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5F6O1o",
                                           "createdAt":  "2022-07-02T12:48:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "TYoung86",
                                           "body":  "\u003e And I\u0027m still of the mindset it doesn\u0027t matter how fast we make something if it\u0027s not used meaningfully (also, And and Or were merged two years ago and still aren\u0027t optimized as intrinsics by the JIT, at least not on x86/64)\r\n\r\nAnd they are purposefully avoided because they don\u0027t emit the desired instructions when examined for use in a hot path.\r\n\r\nYou might see adoption pick up after they\u0027re implemented.",
                                           "updatedAt":  "2022-07-02T12:48:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5F6PIn",
                                           "createdAt":  "2022-07-02T12:57:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e And they are purposefully avoided because they don\u0027t emit the desired instructions when examined for use in a hot path.\r\n\r\nCan you point to specific code on GitHub that would use Interlocked.Xor if it were available? \r\n\r\n",
                                           "updatedAt":  "2022-07-02T12:57:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5F6Pus",
                                           "createdAt":  "2022-07-02T13:13:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "TYoung86",
                                           "body":  "I\u0027m more interested in Interlocked.Or/And for bitwise set and unset, but I was looking for Interlocked.Xor and wondering if/when I could use it; the lack of it made me go with a CompareExchange based loop as And / Or are implemented, and if it gets hot I\u0027ll switch to C/C++.\r\n\r\nIt was going to be used for operations on shared memory made accessible to C#; Interlocked.And, Interlocked.Or, Interlocked.Xor, Interlocked.Add for some operations within the shared memory range.\r\n\r\nPrivate codebase, https://github.com/StirlingLabs/SafeShm, is a C/C++ library, will have a C# wrapper.\r\n\r\n",
                                           "updatedAt":  "2022-07-02T13:14:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5F6P0_",
                                           "createdAt":  "2022-07-02T13:16:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "TYoung86",
                                           "body":  "Can use GitHub search to look for \"Interlocked.CompareExchange\" and Xor nearby for C# codebases.\r\n\r\nStuff like these show up;\r\nhttps://github.com/Tokeiya/XorShiftAddSharp/blob/master/XorShiftAddSharp/XorShiftAddPool.cs\r\nhttps://github.com/Scooletz/Thruster/blob/develop/src/Thruster/Intelocked2.cs\r\n\r\nI think most people that would (have otherwise) consider(ed) using Interlocked (other than CompareExchange, Add, etc.) would evaluate the generated code, be put off and move on.",
                                           "updatedAt":  "2022-07-02T13:21:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5F6XTn",
                                           "createdAt":  "2022-07-02T16:55:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Stuff like these show up;\r\n\r\nThanks. The [first link](https://github.com/Tokeiya/XorShiftAddSharp/blob/master/XorShiftAddSharp/XorShiftAddPool.cs) isn\u0027t using an atomic xor... the CompareExchange is just working on object references as part of object pooling. The [second link](https://github.com/Scooletz/Thruster/blob/develop/src/Thruster/Intelocked2.cs) _is_ using CompareExchange with xor, but from a quick review it\u0027s just using it to turn off bits and would be done more canonically with Interlocked.And (which probably didn\u0027t exist yet when that code was written).\r\n\r\n\u003e I\u0027m more interested in Interlocked.Or/And for bitwise set and unset\r\n\r\nYup. Those do exist now. Happy to see them optimized further for x86/64 when it\u0027s possible in the JIT.",
                                           "updatedAt":  "2022-07-03T02:56:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Ya2ii",
                                           "createdAt":  "2023-03-24T21:35:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODE773w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hexawyz",
                                                                               "createdAt":  "2023-08-27T23:09:25Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "sakno",
                                           "body":  "\u003e Can you share some concrete examples in some repos where these would be used?\r\n\r\n[Here](https://github.com/dotnet/dotNext/blob/master/src/cluster/DotNext.Net.Cluster/Threading/SingleProducerMultipleConsumersCoordinator.cs#L7-L16). I\u0027m using _XOR_ to invert the bit atomically in thread-safe manner. Simply put, it is used by Raft consensus algorithm implementation when explicit replication is requested.",
                                           "updatedAt":  "2023-03-24T21:35:31Z"
                                       }
                                   ],
                         "totalCount":  15
                     },
        "title":  "[API Proposal]: Interlocked class should contain Xor and Not members",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/68776",
        "createdAt":  "2022-05-02T18:17:33Z",
        "number":  68776,
        "author":  "BrennanConroy",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-08-09T19:01:54Z",
        "body":  "This issue is tracking follow up work from the initial implementation of `PartitionedRateLimiter` in https://github.com/dotnet/runtime/pull/67677.\r\n\r\n- [ ] Figure out what interval to use for the internal Timer\r\n  - Dynamically change it based on the intervals of the replenishing limiters?\r\n  - Come up with some \"good enough\" default\r\n  - Make it an option that the user must configure?\r\n- [ ] Background exceptions are currently ignored and not visible to users\r\n  - Check what other libraries like HttpClient do\r\n  - Maybe `ExceptionDispatchInfo.Capture` and dispatch throwing to the threadpool so it\u0027s at least an unhandled exception\r\n- [x] Start using `IdleDuration` to cleanup internal dictionary when limiters aren\u0027t active\r\n  - Probably don\u0027t want to immediately remove limiters when they become idle, likely should wait 10 seconds or something",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYXCc-w==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5CeMV8",
                                           "createdAt":  "2022-05-02T18:17:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThis issue is tracking follow up work from the initial implementation of `PartitionedRateLimiter` in https://github.com/dotnet/runtime/pull/67677.\r\n\r\n- [ ] Figure out what interval to use for the internal Timer\r\n  - Dynamically change it based on the intervals of the replenishing limiters?\r\n  - Come up with some \"good enough\" default\r\n  - Make it an option that the user must configure?\r\n- [ ] Background exceptions are currently ignored and not visible to users\r\n  - Check what other libraries like HttpClient do\r\n  - Maybe `ExceptionDispatchInfo.Capture` and dispatch throwing to the threadpool so it\u0027s at least an unhandled exception\r\n- [ ] Start using `IdleDuration` to cleanup internal dictionary when limiters aren\u0027t active\r\n  - Probably don\u0027t want to immediately remove limiters when they become idle, likely should wait 10 seconds or something\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eBrennanConroy\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003eBrennanConroy\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e7.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-05-02T18:17:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5H8ngF",
                                           "createdAt":  "2022-08-05T22:46:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "since this is tagged under system.threading, checking whether any of this work is still meant for 7? ",
                                           "updatedAt":  "2022-08-05T22:46:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JA4kT",
                                           "createdAt":  "2022-08-23T22:53:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "ok to close this out since its still tagged for 7? ",
                                           "updatedAt":  "2022-08-23T22:53:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5hcJz7",
                                           "createdAt":  "2023-07-13T19:20:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "checking if this is still being looked into for 8?",
                                           "updatedAt":  "2023-07-13T19:20:29Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Follow-up work for PartitionedRateLimiter",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/68832",
        "createdAt":  "2022-05-03T19:12:11Z",
        "number":  68832,
        "author":  "CodeBlanch",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCbJzkw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "theodorzoulias",
                                            "createdAt":  "2022-05-04T08:08:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "FilipToth",
                                            "createdAt":  "2022-05-04T11:46:09Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2022-06-15T22:34:55Z",
        "body":  "### Background and motivation\n\nI ran into this scenario where I am using a `ThreadLocal\u003cT\u003e` to store a class that is tied to some options. When the options change (rare) I want to discard all the current values captured in the `ThreadLocal\u003cT\u003e`. No API to do this at the moment. I could `Dispose` the current `ThreadLocal\u003cT\u003e`, and recreate it, but it seems like that would introduce a race with any code currently accessing the value.\r\n\r\nThought I would put out this proposal to see if anyone else would find this useful.\r\n\r\nExample of the scenario and how the new API would help:\r\n\r\n```csharp\r\ninternal sealed class EventManager : IDisposable\r\n{\r\n\tprivate static readonly ThreadLocal\u003cEventProcessor\u003e s_EventProcessor = new();\r\n\r\n\tprivate readonly IDisposable _OptionsReloadToken;\r\n\tprivate EventProcessingOptions _Options;\r\n\r\n\tpublic EventManager(IOptionsMonitor\u003cEventProcessingOptions\u003e options)\r\n\t{\r\n\t\tReloadOptions(options.CurrentValue);\r\n\t\t_OptionsReloadToken = options.OnChange(ReloadOptions);\r\n\t}\r\n\r\n\tpublic void ProcessEvent(Event e)\r\n\t{\r\n\t\tEventProcessor? eventProcessor = s_EventProcessor.Value;\r\n\t\tif (eventProcessor == null)\r\n\t\t{\r\n\t\t\teventProcessor = new EventProcessor(_Options.BufferSize);\r\n\t\t\ts_EventProcessor.Value = eventProcessor;\r\n\t\t}\r\n\r\n\t\teventProcessor.ProcessEvent(e);\r\n\t}\r\n\r\n\tpublic void Dispose() =\u003e _OptionsReloadToken?.Dispose();\r\n\r\n\t[MemberNotNull(\"_Options\")]\r\n\tprivate void ReloadOptions(EventProcessingOptions options)\r\n\t{\r\n\t\tEventProcessingOptions? oldOptions = _Options;\r\n\r\n\t\t_Options = options;\r\n\r\n\t\tif (oldOptions != null\r\n\t\t\t\u0026\u0026 oldOptions.BufferSize != _Options.BufferSize)\r\n\t\t{\r\n\t\t\t// Using proposed API here.\r\n\t\t\ts_EventProcessor.ClearValues();\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\nThe code could of course do this...\r\n\r\n```csharp\r\n\t\tEventProcessor? eventProcessor = s_EventProcessor.Value;\r\n\t\tif (eventProcessor == null || eventProcessor.BufferSize != _Options.BufferSize)\r\n\t\t{\r\n\t\t\teventProcessor = new EventProcessor(_Options.BufferSize);\r\n\t\t\ts_EventProcessor.Value = eventProcessor;\r\n\t\t}\r\n```\r\n\r\n...but there are two issues with that:\r\n\r\n* Pays a cost on each event checking for a case that is very rare. In this example the check is simple, but there could be many options needing to be checked.\r\n* Requires that there is some way to inspect the options. Meaning if \"EventProcessor\" doesn\u0027t expose back out the options passed in ctor (the buffer size in this example) then this isn\u0027t possible to do.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Threading;\r\n\r\npublic class ThreadLocal\u003cT\u003e\r\n{\r\n    public void ClearValues()\r\n    {\r\n    }\r\n}\r\n```\r\n\n\n### API Usage\n\nSee description.\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOQpJ-aA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5Ci-vQ",
                                           "createdAt":  "2022-05-03T19:12:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-05-03T19:12:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5CjYn_",
                                           "createdAt":  "2022-05-03T20:32:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nI ran into this scenario where I am using a `ThreadLocal\u003cT\u003e` to store a class that is tied to some options. When the options change (rare) I want to discard all the current values captured in the `ThreadLocal\u003cT\u003e`. No API to do this at the moment. I could `Dispose` the current `ThreadLocal\u003cT\u003e`, and recreate it, but it seems like that would introduce a race with any code currently accessing the value.\r\n\r\nThought I would put out this proposal to see if anyone else would find this useful.\r\n\r\nExample of the scenario and how the new API would help:\r\n\r\n```csharp\r\ninternal sealed class EventManager : IDisposable\r\n{\r\n\tprivate static readonly ThreadLocal\u003cEventProcessor\u003e s_EventProcessor = new();\r\n\r\n\tprivate readonly IDisposable _OptionsReloadToken;\r\n\tprivate EventProcessingOptions _Options;\r\n\r\n\tpublic EventManager(IOptionsMonitor\u003cEventProcessingOptions\u003e options)\r\n\t{\r\n\t\tReloadOptions(options.CurrentValue);\r\n\t\t_OptionsReloadToken = options.OnChange(ReloadOptions);\r\n\t}\r\n\r\n\tpublic void ProcessEvent(Event e)\r\n\t{\r\n\t\tEventProcessor? eventProcessor = s_EventProcessor.Value;\r\n\t\tif (eventProcessor == null)\r\n\t\t{\r\n\t\t\teventProcessor = new EventProcessor(_Options.BufferSize);\r\n\t\t\ts_EventProcessor.Value = eventProcessor;\r\n\t\t}\r\n\r\n\t\teventProcessor.ProcessEvent(e);\r\n\t}\r\n\r\n\tpublic void Dispose() =\u003e _OptionsReloadToken?.Dispose();\r\n\r\n\t[MemberNotNull(\"_Options\")]\r\n\tprivate void ReloadOptions(EventProcessingOptions options)\r\n\t{\r\n\t\tEventProcessingOptions? oldOptions = _Options;\r\n\r\n\t\t_Options = options;\r\n\r\n\t\tif (oldOptions != null\r\n\t\t\t\u0026\u0026 oldOptions.BufferSize != _Options.BufferSize)\r\n\t\t{\r\n\t\t\t// Using proposed API here.\r\n\t\t\ts_EventProcessor.ClearValues();\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\nThe code could of course do this...\r\n\r\n```csharp\r\n\t\tEventProcessor? eventProcessor = s_EventProcessor.Value;\r\n\t\tif (eventProcessor == null || eventProcessor.BufferSize != _Options.BufferSize)\r\n\t\t{\r\n\t\t\teventProcessor = new EventProcessor(_Options.BufferSize);\r\n\t\t\ts_EventProcessor.Value = eventProcessor;\r\n\t\t}\r\n```\r\n\r\n...but there are two issues with that:\r\n\r\n* Pays a cost on each event checking for a case that is very rare. In this example the check is simple, but there could be many options needing to be checked.\r\n* Requires that there is some way to inspect the options. Meaning if \"EventProcessor\" doesn\u0027t expose back out the options passed in ctor (the buffer size in this example) then this isn\u0027t possible to do.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Threading;\r\n\r\npublic class ThreadLocal\u003cT\u003e\r\n{\r\n    public void ClearValues()\r\n    {\r\n    }\r\n}\r\n```\r\n\n\n### API Usage\n\nSee description.\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eCodeBlanch\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-05-03T20:32:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Ckn5o",
                                           "createdAt":  "2022-05-04T03:38:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "You could just drop the ThreadLocal instance without disposing it, and its finalizer will dispose it internally. No race condition with that approach.",
                                           "updatedAt":  "2022-05-04T03:38:31Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "[API Proposal]: System.Threading.ThreadLocal\u003cT\u003e ClearValues method",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/69050",
        "createdAt":  "2022-05-09T11:51:20Z",
        "number":  69050,
        "author":  "jerviscui",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-07-20T15:18:54Z",
        "body":  "Hi @msallin\r\nI see your issue [Question: Enviornment.ProcessorCount, Kubernetes/OpenShift and ThreadPool Min Threads #41586](https://github.com/dotnet/runtime/issues/41586), how about this question? Did you find out what the problem was?\r\n\r\nI used dotnet 6.0 in k8s, and I\u0027m having a similar problem.\r\nApplication took too long more than expected.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHORvRb-Q==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5C0Rgi",
                                           "createdAt":  "2022-05-09T11:51:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nHi @msallin\r\nI see your issue [Question: Enviornment.ProcessorCount, Kubernetes/OpenShift and ThreadPool Min Threads #41586](https://github.com/dotnet/runtime/issues/41586), how about this question? Did you find out what the problem was?\r\n\r\nI used dotnet 6.0 in k8s, and I\u0027m having a similar problem.\r\nApplication took too long more than expected.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejerviscui\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `tenet-performance`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-05-09T11:51:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Dru_i",
                                           "createdAt":  "2022-05-24T07:59:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "deeprobin",
                                           "body":  "Is there a good way to profile a .NET App in Kubernetes with collecting the overhead of Kubernetes, Docker, Cgroups, ...?",
                                           "updatedAt":  "2022-05-24T07:59:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DwHgs",
                                           "createdAt":  "2022-05-25T03:32:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jerviscui",
                                           "body":  "@deeprobin \r\nYou can try dotnet-monitor or appmetrics.\r\n\r\nhttps://github.com/dotnet/dotnet-monitor\r\nhttps://github.com/AppMetrics/AppMetrics",
                                           "updatedAt":  "2022-05-25T03:32:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5F-UTC",
                                           "createdAt":  "2022-07-04T15:58:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "deeprobin",
                                           "body":  "@jerviscui Can you share some system details? OS; libc/musl; CPU; Available memory?",
                                           "updatedAt":  "2022-07-04T15:58:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5G7q84",
                                           "createdAt":  "2022-07-20T09:30:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jerviscui",
                                           "body":  "I\u0027m running in CentOS 7 and K8s 1.2.\r\nI test the API, 1% of 1000 http requests will take too long time. \r\nBy means of the log in the method, Time spent between method return and middleware.",
                                           "updatedAt":  "2022-07-20T09:30:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5G7sGs",
                                           "createdAt":  "2022-07-20T09:35:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "deeprobin",
                                           "body":  "@jerviscui \r\nCentOS is a bit special. Do you know if your CentOS uses (g)libc or musl?\r\n\r\nAnd do you see a significant performance difference when running this directly on the host without virtualization?\r\n\r\nCould you tell me some specs of the host system of the k8s-node?\r\nThe count of processors, processor sockets, memory lanes or NUMA nodes could be crucial, since .NET does not yet allocate NUMA-aware so well.",
                                           "updatedAt":  "2022-07-20T09:36:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5G7uRE",
                                           "createdAt":  "2022-07-20T09:43:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "deeprobin",
                                           "body":  "@mangod9 As far as I could see from the fabricbot.json you are responsible for the threading. \r\nDo you have any suggestions or ideas what the problem could be?",
                                           "updatedAt":  "2022-07-20T09:43:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5G8HeD",
                                           "createdAt":  "2022-07-20T11:36:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jerviscui",
                                           "body":  "The node is a Tencent Cloud VIRTUAL machine. \r\nIt has 16 core CPU and 32G memory. And I don\u0027t know accurate hardware specifications.\r\n\r\nOS: CentOS Linux release 7.6.1810 (Core)\r\nKernel: Linux VM-2-19-centos 3.10.0-1160.62.1.el7.x86_64\r\n\r\n\r\nI\u0027ve been busy with work lately and haven\u0027t tested further.\r\nI will test by monitoring system resources and chang the GC Model.",
                                           "updatedAt":  "2022-07-20T11:36:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5G8JC0",
                                           "createdAt":  "2022-07-20T11:42:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "deeprobin",
                                           "body":  "Can you install `numactl` and provide the output of `numactl --hardware`?",
                                           "updatedAt":  "2022-07-20T11:42:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5G9Fv5",
                                           "createdAt":  "2022-07-20T15:18:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "@jerviscui could you please provide additional context on what the issue is? Ideally a simple repro for the issue would be helpful in diagnosing further. Thx. ",
                                           "updatedAt":  "2022-07-20T15:18:54Z"
                                       }
                                   ],
                         "totalCount":  10
                     },
        "title":  "The execution time is too long in Kubernetes",
        "labels":  [
                       "question",
                       "area-System.Threading",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/69556",
        "createdAt":  "2022-05-19T13:32:38Z",
        "number":  69556,
        "author":  "sakno",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-07-07T15:34:35Z",
        "body":  "### Background and motivation\r\n\r\nI would like to return back to #22172 discussion. I faced with the same issue when I can\u0027t propagate user-supplied cancellation token in _OperationCanceledException_.\r\n\r\n### API Proposal\r\n\r\nWe don\u0027t want to introduce a new heavy API and overloads that can impact performance and backward compatibility both. Instead, we can distinguish the order of cancellations and determine which token was canceled first.\r\n\r\n```csharp\r\nnamespace System.Threading;\r\n\r\npublic readonly struct CancellationToken\r\n{\r\n   public long? CancellationSequenceNumber { get; }\r\n}\r\n```\r\nThe number is increasing monotonically for each cancellation happened in the app. The counter is not local to the CTS. It is global static counter which is incremented using _IncrementAndGet_. The property returns **null** if token is not canceled.\r\n\r\n### API Usage\r\n\r\nNow we can easily deal with the example shown by David:\r\n```csharp\r\nvar cts1 = new CancellationTokenSource();\r\nvar cts2 = new CancellationTokenSource();\r\nvar linked = CancellationTokenSource.CreateLinkedTokenSource(cts1.Token, cts2.Token);\r\ntry\r\n{\r\n    cts1.Cancel();\r\n    linked.Token.ThrowIfCancellationRequested();\r\n}\r\ncatch (OperationCanceledException ex)\r\n{\r\n    var seq1 = cts1.Token.CancellationSequenceNumber.GetValueOrDefault();\r\n    var seq2 = cts2.Token.CancellationSequenceNumber.GetValueOrDefault();\r\n\r\n    switch ((cts1.Token.IsCancellationRequested, cts2.Token.IsCancellationRequested))\r\n    {\r\n       case (true, true):\r\n        throw new OperationCanceledException(seq1 \u003c seq2 ? cts1.Token : cts2.Token);\r\n       case (true, false):\r\n        throw new OperationCanceledException(cts1.Token);\r\n       case (false, true):\r\n        throw new OperationCanceledException(cts2.Token);\r\n    }\r\n}\r\n```\r\n\r\n### Alternative Designs\r\n\r\nUse cancellation timestamps.\r\n\r\n### Risks\r\n\r\nThis proposal requires minimal impact on performance because we need a single interlocked operation for that. Increment happens in CTS constructor and _TryReset_ method. Cancellation procedure itself is not affected.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOQ7IkkQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5DdEZv",
                                           "createdAt":  "2022-05-19T13:32:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-05-19T13:32:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DdJ-R",
                                           "createdAt":  "2022-05-19T13:48:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "svick",
                                           "body":  "Why does it matter which token caused the cancellation? If both are cancelled, isn\u0027t it enough to report either one of them?",
                                           "updatedAt":  "2022-05-19T13:48:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DdL0-",
                                           "createdAt":  "2022-05-19T13:54:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCfUFVw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Mrxx99",
                                                                               "createdAt":  "2022-05-30T21:31:06Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "sakno",
                                           "body":  "@svick , in example above, `cts2.Token` can be canceled concurrently after _OperationCanceledException_. So the linked token source was actually triggered by `cts1.Token`. Therefore, _IsCancellationRequested_ returns **true** for both tokens. But we want to propagate a correct cancellation token to the caller.",
                                           "updatedAt":  "2022-05-19T13:54:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DdNGW",
                                           "createdAt":  "2022-05-19T13:59:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sakno",
                                           "body":  "Here is practical example from _HttpClient_ that currently requires workaround:\r\nhttps://github.com/dotnet/runtime/blob/215b39abf947da7a40b0cb137eab4bceb24ad3e3/src/libraries/System.Net.Http/src/System/Net/Http/HttpClient.cs#L594-L613",
                                           "updatedAt":  "2022-05-19T13:59:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DdOWS",
                                           "createdAt":  "2022-05-19T14:03:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Here is practical example from HttpClient\r\n\r\nHow would your proposal materially change that snippet?",
                                           "updatedAt":  "2022-05-19T14:03:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DdOrf",
                                           "createdAt":  "2022-05-19T14:05:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCdsk4g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "svick",
                                                                               "createdAt":  "2022-05-19T14:07:30Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e But we want to propagate a correct cancellation token to the caller.\r\n\r\nHow do you define \"correct\"?  In most of these situations, it doesn\u0027t matter which actually triggered the cancellation; if they\u0027re both canceled, it\u0027s a race condition, either of them could have caused it, and it doesn\u0027t matter which is used.\r\n\r\nThat race still exists with your proposal, by the way.  Just because one has a lower number doesn\u0027t mean it was actually the one to trigger cancellation.  It could have had Cancel called first, but then that thread is suspended, the other is canceled, and is actually the one that results in something being torn down.",
                                           "updatedAt":  "2022-05-19T14:06:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DdcQj",
                                           "createdAt":  "2022-05-19T14:36:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\r\n\r\nI would like to return back to #22172 discussion. I faced with the same issue when I can\u0027t propagate user-supplied cancellation token in _OperationCanceledException_.\r\n\r\n### API Proposal\r\n\r\nWe don\u0027t want to introduce a new heavy API and overloads that can impact performance and backward compatibility both. Instead, we can distinguish the order of cancellations and determine which token was canceled first.\r\n\r\n```csharp\r\nnamespace System.Threading;\r\n\r\npublic readonly struct CancellationToken\r\n{\r\n   public long? CancellationSequenceNumber { get; }\r\n}\r\n```\r\nThe number is increasing monotonically for each cancellation happened in the app. The counter is not local to the CTS. It is global static counter which is incremented using _IncrementAndGet_. The property returns **null** if token is not canceled.\r\n\r\n### API Usage\r\n\r\nNow we can easily deal with the example shown by David:\r\n```csharp\r\nvar cts1 = new CancellationTokenSource();\r\nvar cts2 = new CancellationTokenSource();\r\nvar linked = CancellationTokenSource.CreateLinkedTokenSource(cts1.Token, cts2.Token);\r\ntry\r\n{\r\n    cts1.Cancel();\r\n    linked.Token.ThrowIfCancellationRequested();\r\n}\r\ncatch (OperationCanceledException ex)\r\n{\r\n    var seq1 = cts1.Token.CancellationSequenceNumber.GetValueOrDefault();\r\n    var seq2 = cts2.Token.CancellationSequenceNumber.GetValueOrDefault();\r\n\r\n    switch ((cts1.Token.IsCancellationRequested, cts2.Token.IsCancellationRequested))\r\n    {\r\n       case (true, true):\r\n        throw new OperationCanceledException(seq1 \u003c seq2 ? cts1.Token : cts2.Token);\r\n       case (true, false):\r\n        throw new OperationCanceledException(cts1.Token);\r\n       case (false, true):\r\n        throw new OperationCanceledException(cts2.Token);\r\n    }\r\n}\r\n```\r\n\r\n### Alternative Designs\r\n\r\nUse cancellation timestamps.\r\n\r\n### Risks\r\n\r\nThis proposal requires minimal impact on performance because we need a single interlocked operation for that. Increment happens in CTS constructor and _TryReset_ method. Cancellation procedure itself is not affected.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003esakno\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-05-19T14:36:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DsiSR",
                                           "createdAt":  "2022-05-24T10:36:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCwUcuA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ygoe",
                                                                               "createdAt":  "2022-11-28T22:51:29Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "sakno",
                                           "body":  "@stephentoub , agree, sequence number is not an option here. However, CTS is still able to detect the actual token caused cancellation. We can add extra property to _CancellationToken_ to obtain original token:\r\n```csharp\r\npublic readonly struct CancellationToken\r\n{\r\n   public CancellationToken? Parent { get; }\r\n}\r\n```\r\n\r\nThe property throws _InvalidOperationException_ if the token is not canceled, **null** if there is no parent token caused cancellation and actual token that causes cancellation.",
                                           "updatedAt":  "2022-05-24T10:36:35Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "[API Proposal]: Introduce cancellation sequence numbers to deal with token hiding in linked CTS",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/71583",
        "createdAt":  "2022-07-02T13:23:37Z",
        "number":  71583,
        "author":  "xclud",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-07-09T14:46:05Z",
        "body":  "### Description\n\nI am running an AspNet Core project with a Worker running as a background service.\r\n\r\nVery rare and random I got this exception:\r\n\r\n`Object reference not set to an instance of an object.`\r\n\r\nStacktrace:\r\n`...at System.Threading.ThreadInt64PersistentCounter.get_Count()`\n\n### Reproduction Steps\n\nThis happened very randomly, I don\u0027t know how to reproduce. Just have an aspnet core app with a Worker as a background service. I let it run for several hours in VS 2022 debugger.\n\n### Expected behavior\n\nShould not throw an exception.\n\n### Actual behavior\n\nThrows a null reference exception.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n.NET 7.0 Preview 5.\r\nWindows 11 Insider Build 25151.\r\nIntel Core i3 x64 ([NUC 8](https://www.intel.com/content/www/us/en/products/sku/126150/intel-nuc-kit-nuc8i3beh/specifications.html)).\r\n64 GB of RAM.\r\n2TB Samsung NVMe Pro 980 of Disk Space.\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHORk6ZzQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5F6QCi",
                                           "createdAt":  "2022-07-02T13:23:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-07-02T13:23:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5F6R8-",
                                           "createdAt":  "2022-07-02T14:15:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nI am running an AspNet Core project with a Worker running as a background service.\r\n\r\nVery rare and random I got this exception:\r\n\r\n`Object reference not set to an instance of an object.`\r\n\r\nStacktrace:\r\n`...at System.Threading.ThreadInt64PersistentCounter.get_Count()`\n\n### Reproduction Steps\n\nThis happened very randomly, I don\u0027t know how to reproduce. Just have an aspnet core app with a Worker as a background service. I let it run for several hours in VS 2022 debugger.\n\n### Expected behavior\n\nShould not throw an exception.\n\n### Actual behavior\n\nThrows a null reference exception.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n.NET 7.0 Preview 5.\r\nWindows 11 Insider Build 25151.\r\nIntel Core i3 x64 ([NUC 8](https://www.intel.com/content/www/us/en/products/sku/126150/intel-nuc-kit-nuc8i3beh/specifications.html)).\r\n64 GB of RAM.\r\n2TB Samsung NVMe Pro 980 of Disk Space.\n\n### Other information\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003exclud\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-07-02T14:15:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GSWl-",
                                           "createdAt":  "2022-07-08T17:28:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "It\u0027s not clear to me how this could be happening from the code. Try enabling [just-in-time debugging in VS](https://docs.microsoft.com/en-us/visualstudio/debugger/debug-using-the-just-in-time-debugger?view=vs-2022) and if possible share a crash dump if it happens again.",
                                           "updatedAt":  "2022-07-08T17:28:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GTpnN",
                                           "createdAt":  "2022-07-09T14:46:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xclud",
                                           "body":  "I did enable my just in time debugging. Next time it happens I will provide more information. It didn\u0027t happen since then.\r\n\r\nPlease keep this issue open in case someone encounter the same issue.",
                                           "updatedAt":  "2022-07-09T14:46:05Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Object reference not set to an instance of an object at System.Threading.ThreadInt64PersistentCounter.get_Count()",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/71723",
        "createdAt":  "2022-07-06T18:15:20Z",
        "number":  71723,
        "author":  "aromaa",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOClc1Ug==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SingleAccretion",
                                            "createdAt":  "2022-07-06T18:26:44Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2022-07-07T15:20:46Z",
        "body":  "When running tools like [jit-diff](https://github.com/dotnet/jitutils/blob/main/doc/diffs.md) to compare the generated assembly its important that the JIT is able to output deterministic results. However, the current implementation of the GetCurrentProcessorId on CoreCLR checks for [s_isProcessorNumberReallyFast](https://github.com/dotnet/runtime/blob/c2ec86b1c552ac8a1749f9f98e012f707e325660/src/coreclr/System.Private.CoreLib/src/System/Threading/Thread.CoreCLR.cs#L343) which is assigned based on the return value of a [ProcessorNumberSpeedCheck](https://github.com/dotnet/runtime/blob/57bfe474518ab5b7cfe6bf7424a79ce3af9d6657/src/coreclr/System.Private.CoreLib/src/System/Threading/ProcessorIdCache.cs#L58) method.\r\n\r\nDue to how the returned value is determined, it may cause fluctuation on which underlying implementation is used even on same machine. Because the GetCurrentProcessorId is inlined, its not as obvious what caused the codegen changes.\r\n\r\nIt was attempted to fix this using reflection in dotnet/jitutils#255 but was reverted in dotnet/jitutils#272 due to using reflection hole in the init-only static variables. The fix would require changes in framework code.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHORiCVAg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5GIHDy",
                                           "createdAt":  "2022-07-06T18:15:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-07-06T18:15:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GIJUC",
                                           "createdAt":  "2022-07-06T18:26:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nWhen running tools like [jit-diff](https://github.com/dotnet/jitutils/blob/main/doc/diffs.md) to compare the generated assembly its important that the JIT is able to output deterministic results. However, the current implementation of the GetCurrentProcessorId on CoreCLR checks for [s_isProcessorNumberReallyFast](https://github.com/dotnet/runtime/blob/c2ec86b1c552ac8a1749f9f98e012f707e325660/src/coreclr/System.Private.CoreLib/src/System/Threading/Thread.CoreCLR.cs#L343) which is assigned based on the return value of a [ProcessorNumberSpeedCheck](https://github.com/dotnet/runtime/blob/57bfe474518ab5b7cfe6bf7424a79ce3af9d6657/src/coreclr/System.Private.CoreLib/src/System/Threading/ProcessorIdCache.cs#L58) method.\r\n\r\nDue to how the returned value is determined, it may cause fluctuation on which underlying implementation is used even on same machine. Because the GetCurrentProcessorId is inlined, its not as obvious what caused the codegen changes.\r\n\r\nIt was attempted to fix this using reflection in dotnet/jitutils#255 but was reverted in dotnet/jitutils#272 due to using reflection hole in the init-only static variables. The fix would require changes in framework code.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003earomaa\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-07-06T18:26:56Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "GetCurrentProcessorId may cause non-deterministic asm diffs",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/71751",
        "createdAt":  "2022-07-07T05:44:50Z",
        "number":  71751,
        "author":  "timcassell",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-01-27T03:48:24Z",
        "body":  "### Background and motivation\r\n\r\nA simple property to be able to quickly check if the callback is still registered. Currently, the registration cannot be checked if it\u0027s still registered without unregistering it.\r\n\r\n### API Proposal\r\n\r\n```cs\r\nnamespace System.Threading\r\n{\r\n    public readonly struct CancellationTokenRegistration\r\n    {\r\n        /// \u003csummary\u003e\r\n        /// Returns true if the callback is still waiting for cancelation.\r\n        /// Returns false if the callback has already been invoked,\r\n        /// or if \u003csee cref=\"CancellationTokenSource.TryReset\"/\u003e or \u003csee cref=\"CancellationTokenSource.Dispose\"/\u003e have been called on the associated \u003csee cref=\"CancellationTokenSource\"/\u003e before it was canceled.\r\n        /// \u003c/summary\u003e\r\n        public bool IsRegistered { get; }\r\n    }\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\nSimplified example (my real custom token is much more complex, but this is the gist of it).\r\n\r\n```cs\r\npublic class MyCustomToken\r\n{\r\n    private CancellationToken _token;\r\n    private CancellationTokenRegistration _registration;\r\n    private Action _onCancel;\r\n    private bool _isCanceled;\r\n\r\n    public MyCustomToken(CancellationToken token)\r\n    {\r\n        _token = token;\r\n        HookupCancelation();\r\n    }\r\n\r\n    private void HookupCancelation()\r\n    {\r\n        _registration = _token.Register(() =\u003e\r\n        {\r\n            _isCanceled = true;\r\n            _onCancel();\r\n        });\r\n    }\r\n\r\n    public void AddCallback(Action callback)\r\n    {\r\n        if (_isCanceled)\r\n        {\r\n            callback();\r\n            return;\r\n        }\r\n\r\n        // If registration is not registered, TryReset or Dispose were called on the source,\r\n        // so we must remove current callbacks and re-hookup the cancelation.\r\n        if (!_registration.IsRegistered)\r\n        {\r\n            _onCancel = null;\r\n            HookupCancelation();\r\n        }\r\n        _onCancel += callback;\r\n    }\r\n}\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nThe alternative is to use the existing `Unregister()` API to change this\r\n\r\n```cs\r\nif (!_registration.IsRegistered)\r\n{\r\n    _onCancel = null;\r\n    HookupCancelation();\r\n}\r\n```\r\n\r\nto this\r\n\r\n```cs\r\nif (!_registration.Unregister())\r\n{\r\n    _onCancel = null;\r\n}\r\nHookupCancelation();\r\n```\r\n\r\nAnd cause more work to be done.\r\n\r\n### Risks\r\n\r\nNone",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOU82Sww==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5GKTi-",
                                           "createdAt":  "2022-07-07T05:44:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-07-07T05:44:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GKjBS",
                                           "createdAt":  "2022-07-07T07:01:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\r\n\r\nA simple property to be able to quickly check if the callback is still registered. Currently, the registration cannot be checked if it\u0027s still registered without unregistering it.\r\n\r\n### API Proposal\r\n\r\n```cs\r\nnamespace System.Threading\r\n{\r\n    public readonly struct CancellationTokenRegistration\r\n    {\r\n        /// \u003csummary\u003e\r\n        /// Returns true if the callback is still waiting for cancelation.\r\n        /// Returns false if the callback has already been invoked,\r\n        /// or if \u003csee cref=\"CancellationTokenSource.TryReset\"/\u003e or \u003csee cref=\"CancellationTokenSource.Dispose\"/\u003e have been called on the associated \u003csee cref=\"CancellationTokenSource\"/\u003e before it was canceled.\r\n        /// \u003c/summary\u003e\r\n        public bool IsRegistered { get; }\r\n    }\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\nSimplified example (my real custom token is much more complex, but this is the gist of it).\r\n\r\n```cs\r\npublic class MyCustomToken\r\n{\r\n    private CancellationToken _token;\r\n    private CancellationTokenRegistration _registration;\r\n    private Action _onCancel;\r\n    private bool _isCanceled;\r\n\r\n    public MyCustomToken(CancellationToken token)\r\n    {\r\n        _token = token;\r\n        HookupCancelation();\r\n    }\r\n\r\n    private void HookupCancelation()\r\n    {\r\n        _registration = _token.Register(() =\u003e\r\n        {\r\n            _isCanceled = true;\r\n            _onCancel();\r\n        });\r\n    }\r\n\r\n    public void AddCallback(Action callback)\r\n    {\r\n        if (_isCanceled)\r\n        {\r\n            callback();\r\n            return;\r\n        }\r\n\r\n        // If registration is not registered, TryReset or Dispose were called on the source,\r\n        // so we must remove current callbacks and re-hookup the cancelation.\r\n        if (!_registration.IsRegistered)\r\n        {\r\n            _onCancel = null;\r\n            HookupCancelation();\r\n        }\r\n        _onCancel += callback;\r\n    }\r\n}\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nThe alternative is to use the existing `Unregister()` API to change this\r\n\r\n```cs\r\nif (!_registration.IsRegistered)\r\n{\r\n    _onCancel = null;\r\n    HookupCancelation();\r\n}\r\n```\r\n\r\nto this\r\n\r\n```cs\r\nif (!_registration.Unregister())\r\n{\r\n    _onCancel = null;\r\n}\r\nHookupCancelation();\r\n```\r\n\r\nAnd cause more work to be done.\r\n\r\n### Risks\r\n\r\nNone\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003etimcassell\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-07-07T07:01:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GKjOJ",
                                           "createdAt":  "2022-07-07T07:02:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "Since `CancellationTokenRegistration` is a readonly struct, it can\u0027t carry such information in its own. Querying `IsRegistered` may not be as fast as you want.",
                                           "updatedAt":  "2022-07-07T07:02:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GKksj",
                                           "createdAt":  "2022-07-07T07:10:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "@huoyaoyuan It\u0027s doing the same thing as Unregister, just without the unregister part. It should be at least as fast as that. ",
                                           "updatedAt":  "2022-07-07T07:10:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GLSLU",
                                           "createdAt":  "2022-07-07T10:20:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "The answer could change from true to false the moment after you query it. I don\u0027t see how it helps with your example. With Unregister, if it returns true, it\u0027s also atomically been unregistered.",
                                           "updatedAt":  "2022-07-07T10:20:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GMNqW",
                                           "createdAt":  "2022-07-07T13:22:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "@stephentoub Yes, I know, and that\u0027s perfectly fine. If it immediately changes to false because of TryReset or Dispose, then the callback will just be registered but not invoked (falls in line with the contract even if it\u0027s a race condition), and it will just be re-registered the next time AddCallback is called.\r\nIf it immediately changes to false because it was actually invoked, that\u0027s also fine, and I have synchronization mechanisms in place in my real code to handle that, I just didn\u0027t include all that here for brevity. ",
                                           "updatedAt":  "2022-07-07T13:28:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GMQif",
                                           "createdAt":  "2022-07-07T13:30:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "So this is just a performance optimization?  Can you share details on why it\u0027s important this be optimized to avoid the extra Register call?",
                                           "updatedAt":  "2022-07-07T13:30:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GMR9n",
                                           "createdAt":  "2022-07-07T13:34:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "Correct. It\u0027s because I expect AddCallback to be invoked many times, and the expected result of IsRegistered would be true. IsRegistered returning false is the edge case, and I would rather avoid unregistering and re-registering on every invoke if it can be avoided. ",
                                           "updatedAt":  "2022-07-07T13:34:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GMSvV",
                                           "createdAt":  "2022-07-07T13:36:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Can you share performance traces showing that this is contributing measurably to your usage in real-world usage?\r\n\r\nEven if you use such a property in a way that\u0027s safe, it\u0027s inherently racy to use, which means it\u0027s a pit of failure for anyone not paying really close attention, and we\u0027d only want to expose such a thing if it made a really meaningful difference.",
                                           "updatedAt":  "2022-07-07T13:36:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GMURD",
                                           "createdAt":  "2022-07-07T13:41:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "Sure, makes sense. I haven\u0027t done any performance measurements yet, just intuition. I\u0027ll try to work up a benchmark and get back to you. ",
                                           "updatedAt":  "2022-07-07T13:41:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GRNGE",
                                           "createdAt":  "2022-07-08T12:09:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "Yeah, it\u0027s a huge difference. Would you like me to upload my benchmark project?\r\n\r\n|       Method |      Mean |    Error |   StdDev | Ratio | Allocated |\r\n|------------- |----------:|---------:|---------:|------:|----------:|\r\n|   Unregister | 164.21 ns | 1.489 ns | 1.243 ns |  1.00 |         - |\r\n| IsRegistered |  72.67 ns | 1.023 ns | 0.957 ns |  0.44 |         - |",
                                           "updatedAt":  "2022-07-08T12:09:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GRQxW",
                                           "createdAt":  "2022-07-08T12:25:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "That looks like a microbenchmark just on Unregister, yes? I\u0027d like to understand how those 90 ns compare to the all-up operation being performed. Unless this is part of a really hot path and is the majority cost of that hot path, I would not expect that difference to matter. ",
                                           "updatedAt":  "2022-07-08T12:25:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GRSAt",
                                           "createdAt":  "2022-07-08T12:31:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "That\u0027s a microbenchmark of the `AddCallback` call on my real code (the real method is `Register`), including all necessary synchronization, not just on Unregister itself.\r\n\r\nThis is the benchmark code (without the source of the actual CancellationTokenRegistration changes and custom token, as I would need to upload that separately since it\u0027s several files):\r\n\r\n(`System.Threading.IsRegistered.CancellationTokenSource` is I copied the source code and added the IsRegistered property)\r\n\r\n```cs\r\npublic class RegisterBenchmark\r\n{\r\n    const int invokeCount = 1_000_000;\r\n\r\n    private System.Threading.IsRegistered.CancellationTokenSource unregisterSource;\r\n    private Custom.Cancelations.Unregister.CancelationToken unregisterToken;\r\n    private readonly Custom.Cancelations.Unregister.CancelationRegistration[] unregisterRegistrations = new Custom.Cancelations.Unregister.CancelationRegistration[invokeCount];\r\n\r\n    [IterationSetup(Target = nameof(Unregister))]\r\n    public void SetupUnregister()\r\n    {\r\n        unregisterSource = new System.Threading.IsRegistered.CancellationTokenSource();\r\n        unregisterToken = unregisterSource.Token.ToCancelationToken();\r\n    }\r\n\r\n    [Benchmark(OperationsPerInvoke = invokeCount, Baseline = true)]\r\n    public void Unregister()\r\n    {\r\n        var token = unregisterToken;\r\n        for (int i = 0; i \u003c invokeCount; ++i)\r\n        {\r\n            unregisterRegistrations[i] = token.Register(() =\u003e { });\r\n        }\r\n    }\r\n\r\n    [IterationCleanup(Target = nameof(Unregister))]\r\n    public void CleanupUnregister()\r\n    {\r\n        unregisterSource.Dispose();\r\n        unregisterSource = null;\r\n        unregisterToken = default;\r\n        for (int i = 0; i \u003c invokeCount; ++i)\r\n        {\r\n            unregisterRegistrations[i].Unregister();\r\n            unregisterRegistrations[i] = default;\r\n        }\r\n    }\r\n\r\n    private System.Threading.IsRegistered.CancellationTokenSource isRegisteredSource;\r\n    private Custom.Cancelations.IsRegistered.CancelationToken isRegisteredToken;\r\n    private readonly Custom.Cancelations.IsRegistered.CancelationRegistration[] isRegisteredRegistrations = new Custom.Cancelations.IsRegistered.CancelationRegistration[invokeCount];\r\n\r\n    [IterationSetup(Target = nameof(IsRegistered))]\r\n    public void SetupIsRegistered()\r\n    {\r\n        isRegisteredSource = new System.Threading.IsRegistered.CancellationTokenSource();\r\n        isRegisteredToken = isRegisteredSource.Token.ToCancelationTokenWithIsRegistered();\r\n    }\r\n\r\n    [Benchmark(OperationsPerInvoke = invokeCount)]\r\n    public void IsRegistered()\r\n    {\r\n        var token = isRegisteredToken;\r\n        for (int i = 0; i \u003c invokeCount; ++i)\r\n        {\r\n            isRegisteredRegistrations[i] = token.Register(() =\u003e { });\r\n        }\r\n    }\r\n\r\n    [IterationCleanup(Target = nameof(IsRegistered))]\r\n    public void CleanupIsRegistered()\r\n    {\r\n        isRegisteredSource.Dispose();\r\n        isRegisteredSource = null;\r\n        isRegisteredToken = default;\r\n        for (int i = 0; i \u003c invokeCount; ++i)\r\n        {\r\n            isRegisteredRegistrations[i].Unregister();\r\n            isRegisteredRegistrations[i] = default;\r\n        }\r\n    }\r\n}\r\n```",
                                           "updatedAt":  "2022-07-08T12:47:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TzZLD",
                                           "createdAt":  "2023-01-27T03:48:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "I would not need this anymore if #81255 were to be done.",
                                           "updatedAt":  "2023-01-27T03:48:24Z"
                                       }
                                   ],
                         "totalCount":  14
                     },
        "title":  "[API Proposal]: `CancellationTokenRegistration.IsRegistered`",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/71761",
        "createdAt":  "2022-07-07T10:55:53Z",
        "number":  71761,
        "author":  "ayende",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC1FJXw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "D3-LucaPiombino",
                                            "createdAt":  "2022-07-08T21:29:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "stevehansen",
                                            "createdAt":  "2022-07-11T13:58:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "xaevik",
                                            "createdAt":  "2022-07-11T18:38:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "KuraiAndras",
                                            "createdAt":  "2022-07-11T18:41:36Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pedropita",
                                            "createdAt":  "2022-07-11T20:05:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sandersaares",
                                            "createdAt":  "2022-07-11T21:27:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Xhanti",
                                            "createdAt":  "2022-07-12T06:44:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jhudler",
                                            "createdAt":  "2022-07-12T11:49:58Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "piotr-lasota",
                                            "createdAt":  "2022-07-12T12:03:52Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "maximilien-noal",
                                            "createdAt":  "2022-07-12T13:52:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hkochniss",
                                            "createdAt":  "2022-07-12T15:03:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Turnerj",
                                            "createdAt":  "2022-07-13T07:42:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ejsmith",
                                            "createdAt":  "2022-07-13T15:14:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "spytheman",
                                            "createdAt":  "2022-07-15T14:39:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Jetski5822",
                                            "createdAt":  "2024-01-10T14:04:37Z"
                                        }
                                    ],
                          "totalCount":  15
                      },
        "updatedAt":  "2023-07-03T16:36:23Z",
        "body":  "### Description\n\nThe code here: \r\n\r\nhttps://github.com/dotnet/runtime/blob/main/src/coreclr/vm/threads.cpp#L812\r\n\r\nAssumes that failing to create a thread means that we run out of memory. \r\nThis result in this error:\r\n\r\n```\r\n---\u003e System.OutOfMemoryException: Exception of type \u0027System.OutOfMemoryException\u0027 was thrown.\r\n   at System.Threading.Thread.StartInternal(ThreadHandle t, Int32 stackSize, Int32 priority, Char* pThreadName)\r\n   at System.Threading.Thread.StartCore()\r\n ```\r\n\r\nOn Linux, there are few other options, such as the `TasksMax` limit (at process or user level), global number of processes limit at the kernel level.\n\n### Reproduction Steps\n\nSet a low `TasksMax` limit and create more threads than allowed.\r\n\n\n### Expected behavior\n\nGetting an error saying that the thread failed to start, and either pointing the actual reason for that or listing the various options.\n\n### Actual behavior\n\nGetting a misleading exception pointing in the wrong direction.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\nLinux - `systemd` \r\n\r\nIn particular, running a server which spawns threads on need. You\u0027ll get `OutOfMemoryException` even if you have lots of room available.\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHORi24cA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5GLbhw",
                                           "createdAt":  "2022-07-07T10:56:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nThe code here: \r\n\r\nhttps://github.com/dotnet/runtime/blob/main/src/coreclr/vm/threads.cpp#L812\r\n\r\nAssumes that failing to create a thread means that we run out of memory. \r\nThis result in this error:\r\n\r\n```\r\n---\u003e System.OutOfMemoryException: Exception of type \u0027System.OutOfMemoryException\u0027 was thrown.\r\n   at System.Threading.Thread.StartInternal(ThreadHandle t, Int32 stackSize, Int32 priority, Char* pThreadName)\r\n   at System.Threading.Thread.StartCore()\r\n ```\r\n\r\nOn Linux, there are few other options, such as the `TasksMax` limit (at process or user level), global number of processes limit at the kernel level.\n\n### Reproduction Steps\n\nSet a low `TasksMax` limit and create more threads than allowed.\r\n\n\n### Expected behavior\n\nGetting an error saying that the thread failed to start, and either pointing the actual reason for that or listing the various options.\n\n### Actual behavior\n\nGetting a misleading exception pointing in the wrong direction.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\nLinux - `systemd` \r\n\r\nIn particular, running a server which spawns threads on need. You\u0027ll get `OutOfMemoryException` even if you have lots of room available.\n\n### Other information\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eayende\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-07-07T10:56:03Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Failing to create a thread shouldn\u0027t assume that this an out of memory issue",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/71921",
        "createdAt":  "2022-07-11T07:16:34Z",
        "number":  71921,
        "author":  "BrunoJuchli",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC8aZbg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "anionDev",
                                            "createdAt":  "2024-05-26T19:40:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "adr1enette",
                                            "createdAt":  "2024-09-23T22:51:37Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "NN---",
                                            "createdAt":  "2024-10-02T05:47:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "anime-shed",
                                            "createdAt":  "2024-11-05T13:13:41Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2024-12-13T21:49:25Z",
        "body":  "### Description\r\n\r\nWe\u0027ve just moved some of our software to run on Linux instead of Windows nodes and the CPU usage increased significantly.\r\n\r\nFor our testing system, which is mostly idling:\r\nAverage CPU load:\r\n![image](https://user-images.githubusercontent.com/2090172/178202279-af531f43-3997-45a7-87a8-f49a88373108.png)\r\nWindows: 17mc\r\nLinux: 49-60mc (mostly the bar is at 58)\r\n\r\n95th Percentile CPU load:\r\n![image](https://user-images.githubusercontent.com/2090172/178201696-c9095463-22ba-48e2-93ff-a3887cc16d50.png)\r\nWindows: 41mc\r\nLinux: 226-231mc\r\nFactor of 5.5x\r\n\r\nAnd also in production we can see a similar behavior (I\u0027m not including graphs here because I had to increase the CPU limit for Linux nodes, so the Azure Insights graphs would give a wrong impression):\r\n\r\n- Average CPU Load:\r\n  - Windows: 310 mCPU\r\n  - Linux: 1201 mCPU\r\n  - factor of 3.9x\r\n\r\nI\u0027ve sanity checked the numbers given by Azure Insights using `dotnet-counters` which shows correspondingly high cpu usage (%).\r\n\r\nWe\u0027ve got other software which we\u0027ve had running on .net 6 Linux for a longer time now where we didn\u0027t notice this issue.\r\nThe affected software, 4 different applications, all follow the same pattern. There\u0027s a number of items to be processed periodically and the load is distributed across multiple instances of the application.\r\nThe basic implementation is a `while(true)` loop checking for work; at the end of each iteration there is a `Thread.Sleep(..)` with a sleep time between 200ms and 1s (I also changed this to an async implementation with `Task.Delay` without any obvious effect).\r\nWe\u0027re also using Redis (StackExchange.Redis) for Pub Sub. Because of bad design we\u0027re unnecessarily creating/running 49 `RedisChannel`s, which, at least in the production system, creates some unnecessary load - but does not explain the difference between Windows and Linux. \r\nAlso, for each of the 49 `RedisChannel` instances we create a publish queue (`BlockingCollection`) and a Task which publishes the queued items on the `RedisChannel`. The task is created via `new Task(Action).Start()`. All of these tasks spend most of their time waiting.\r\nThat\u0027s not the end of it, but I don\u0027t know all the wheels in this machine myself yet.\r\n\r\nI searched several hours on the net for known performance deterioration of .net /5/6 on Linux but couldn\u0027t find anything which seemed possibly relevant and actionable (i.E. change something and observe the effects). \r\n\r\n### Configuration\r\nBuild: Release config built on SDK 6.0.301 (on a github Windows Server 2022 machine for deployments built for Windows Nodes and a github Linux machine for stuff deployed to Linux Nodes).\r\n\r\nRuntime:\r\n\r\nRun via Kubernetes 1.23.5 on Azure.\r\nFor testing: B2ms (Windows) and B2s (Linux) nodes respectively.\r\nProduction: F8s_v2 nodes for both and Windows and Linux.\r\n\r\n#### Windows\r\ndotnet 6.0.6, Windows Server Core 2019.\r\nDocker:\r\n\r\n    FROM mcr.microsoft.com/dotnet/runtime:6.0-windowsservercore-ltsc2019\r\n    ...\r\n    ENTRYPOINT [\"dotnet\", \"foo.dll\"]\r\n\r\n#### Linux\r\ndotnet 6.0.6 on Alpine 3.16 amd64.\r\nDocker:\r\n\r\n    FROM mcr.microsoft.com/dotnet/runtime:6.0-alpine\r\n    RUN apk update \u0026\u0026 \\\r\n      apk add --no-cache icu tzdata;\r\n    ENV \\\r\n      DOTNET_SYSTEM_GLOBALIZATION_INVARIANT=false \\\r\n      LC_ALL=en_US.UTF-8 \\\r\n      LANG=en_US.UTF-8\r\n    ENTRYPOINT [\"dotnet\", \"foo.dll\"]\r\n\r\n### Data\r\n\r\n#### Traces\r\nI used dotnet-trace and dotnet-counters to record data for 30 seconds from our test system while it was idling. The following zip file contains this for windows and linux, each.\r\n[traces.zip](https://github.com/dotnet/runtime/files/9086230/traces.zip)\r\n\r\nHere are some additional traces where the same application is under some Redis load.\r\nThe load should be equivalent for win and linux, but CPU usage is 1.5% under windows and 9.4% under linux (average of 1 minute).\r\n[bulkmetersim.zip](https://github.com/dotnet/runtime/files/9103263/bulkmetersim.zip)\r\n\r\n##### Some more traces\r\nNote: Probably best to ignore these since I don\u0027t remember exactly from which system and when I recorded these.\r\n- Linux:\r\n  - Production\r\n    - short: - [dotnet_20220707_125557.zip](https://github.com/dotnet/runtime/files/9081673/dotnet_20220707_125557.zip)\r\n    - long: - (!) I had to cheat with this one; using zip it was too large; it\u0027s compressed using 7z; the 7z file ending is not allowed by github, so I had to rename. [trace2.zip](https://github.com/dotnet/runtime/files/9081692/trace2.zip)\r\n- Windows: \r\n  - running on dev machine for a quick comparison. Unfortunately I\u0027m not sure anymore whether this was a Release or Debug build. [Windows.zip](https://github.com/dotnet/runtime/files/9084019/Windows.zip)\r\n\r\n### Analysis\r\n\r\nFrom my understanding (which is very limited): the trace reports show that most time is spent waiting. I expected about ~50 threads to be waiting, so no surprise there.\r\nHowever, IMO calls like `Monitor.Wait` should not result in (significant) actual cpu usage.\r\n\r\nPossibly related to https://github.com/dotnet/runtime/issues/43063",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOl4qA4g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5GViEb",
                                           "createdAt":  "2022-07-11T07:16:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-07-11T07:16:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GWlQx",
                                           "createdAt":  "2022-07-11T12:02:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\nWe\u0027ve just moved some of our software to run on Linux instead of Windows nodes and the CPU usage increased significantly.\r\n\r\nFor our testing system, which is mostly idling:\r\nAverage CPU load:\r\n![image](https://user-images.githubusercontent.com/2090172/178202279-af531f43-3997-45a7-87a8-f49a88373108.png)\r\nWindows: 17mc\r\nLinux: 49-60mc (mostly the bar is at 58)\r\n\r\n95th Percentile CPU load:\r\n![image](https://user-images.githubusercontent.com/2090172/178201696-c9095463-22ba-48e2-93ff-a3887cc16d50.png)\r\nWindows: 41mc\r\nLinux: 226-231mc\r\nFactor of 5.5x\r\n\r\nAnd also in production we can see a similar behavior (I\u0027m not including graphs here because I had to increase the CPU limit for Linux nodes, so the Azure Insights graphs would give a wrong impression):\r\n\r\n- Average CPU Load:\r\n  - Windows: 310 mCPU\r\n  - Linux: 1201 mCPU\r\n  - factor of 3.9x\r\n\r\nI\u0027ve sanity checked the numbers given by Azure Insights using `dotnet-counters` which shows correspondingly high cpu usage (%).\r\n\r\nWe\u0027ve got other software which we\u0027ve had running on .net 6 Linux for a longer time now where we didn\u0027t notice this issue.\r\nThe affected software, 4 different applications, all follow the same pattern. There\u0027s a number of items to be processed periodically and the load is distributed across multiple instances of the application.\r\nThe basic implementation is a `while(true)` loop checking for work; at the end of each iteration there is a `Thread.Sleep(..)` with a sleep time between 200ms and 1s (I also changed this to an async implementation with `Task.Delay` without any obvious effect).\r\nWe\u0027re also using Redis (StackExchange.Redis) for Pub Sub. Because of bad design we\u0027re unnecessarily creating/running 49 `RedisChannel`s, which, at least in the production system, creates some unnecessary load - but does not explain the difference between Windows and Linux. \r\nAlso, for each of the 49 `RedisChannel` instances we create a publish queue (`BlockingCollection`) and a Task which publishes the queued items on the `RedisChannel`. The task is created via `new Task(Action).Start()`. All of these tasks spend most of their time waiting.\r\nThat\u0027s not the end of it, but I don\u0027t know all the wheels in this machine myself yet.\r\n\r\nI searched several hours on the net for known performance deterioration of .net /5/6 on Linux but couldn\u0027t find anything which seemed possibly relevant and actionable (i.E. change something and observe the effects). \r\n\r\n### Configuration\r\nBuild: Release config built on SDK 6.0.301 (on a github Windows Server 2022 machine for deployments built for Windows Nodes and a github Linux machine for stuff deployed to Linux Nodes).\r\n\r\nRuntime:\r\n\r\nRun via Kubernetes 1.23.5 on Azure.\r\nFor testing: B2ms (Windows) and B2s (Linux) nodes respectively.\r\nProduction: F8s_v2 nodes for both and Windows and Linux.\r\n\r\n#### Windows\r\ndotnet 6.0.6, Windows Server Core 2019.\r\nDocker:\r\n\r\n    FROM mcr.microsoft.com/dotnet/runtime:6.0-windowsservercore-ltsc2019\r\n    ...\r\n    ENTRYPOINT [\"dotnet\", \"foo.dll\"]\r\n\r\n#### Linux\r\ndotnet 6.0.6 on Alpine 3.16 amd64.\r\nDocker:\r\n\r\n    FROM mcr.microsoft.com/dotnet/runtime:6.0-alpine\r\n    RUN apk update \u0026\u0026 \\\r\n      apk add --no-cache icu tzdata;\r\n    ENV \\\r\n      DOTNET_SYSTEM_GLOBALIZATION_INVARIANT=false \\\r\n      LC_ALL=en_US.UTF-8 \\\r\n      LANG=en_US.UTF-8\r\n    ENTRYPOINT [\"dotnet\", \"foo.dll\"]\r\n\r\n### Data\r\n\r\nI used `dotnet-trace` to generate trace reports:\r\n\r\n- [dotnet_20220707_125557.zip](https://github.com/dotnet/runtime/files/9081673/dotnet_20220707_125557.zip)\r\n- (!) I had to cheat with this one; using zip it was too large; it\u0027s compressed using 7z; the 7z file ending is not allowed by github, so I had to rename. [trace2.zip](https://github.com/dotnet/runtime/files/9081692/trace2.zip)\r\n\r\n### Analysis\r\n\r\nFrom my understanding (which is very limited): the trace reports show that most time is spent waiting. I expected about ~50 threads to be waiting, so no surprise there.\r\nHowever, IMO calls like `Monitor.Wait` should not result in (significant) actual cpu usage.\r\n\r\nPossibly related to https://github.com/dotnet/runtime/issues/43063\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eBrunoJuchli\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `tenet-performance`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-07-11T12:02:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GWpbZ",
                                           "createdAt":  "2022-07-11T12:20:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "You attached two traces but both of them seem to be from Linux, was one of them supposed to be windows to compare?",
                                           "updatedAt":  "2022-07-11T12:20:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GWudL",
                                           "createdAt":  "2022-07-11T12:41:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "BrunoJuchli",
                                           "body":  "@EgorBo \r\nNo, they are both from Linux. One\u0027s a bit shorter and the other longer.\r\nI\u0027ve now also added a trace of windows; though I think I took this from my local machine. I\u0027ll retake that one from a test system so that they are better comparable.\r\n\r\nThank you for the hint and sorry for the confusion.",
                                           "updatedAt":  "2022-07-11T12:42:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GX37c",
                                           "createdAt":  "2022-07-11T17:15:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "BrunoJuchli",
                                           "body":  "@EgorBo \r\nI added new traces and counters for linux and windows in comparable idle situation.\r\nFrom the counters I can see now that CPU usage is:\r\n- windows: Average = 0.2%.\r\n- linux: Average  = 1.13%\r\n\r\nWhile there looks like to be a difference when idle it seems under load the difference, in absolute numbers, is much more pronounced. So I\u0027ll try to generate a trace under more load...\r\n",
                                           "updatedAt":  "2022-07-12T06:55:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Gcjzv",
                                           "createdAt":  "2022-07-12T15:16:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "Hi @BrunoJuchli, it appears that the issue only reproduces while using StackExchange.Redis or have you noticed it for other applications without Redis too? ",
                                           "updatedAt":  "2022-07-12T15:16:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GiD6o",
                                           "createdAt":  "2022-07-13T14:59:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "BrunoJuchli",
                                           "body":  "@mangod9 \r\nI have added some additional traces and counters to the intro post where the application is under some StackExchange.Redis load but otherwise idling. Here, the cpu load is 1.5% for windows and 9.4% for linux. This would seem to support your thesis.\r\n\r\nWe have another Linux application also using StackExchange.Redis and looking at Azure Insights cpu usage there is basically unaffected.\r\n~~I\u0027ve looked into it some more and it looks like with the unaffected application we don\u0027t use the `RedisChannel`s (pub sub channels). Connected with that is also our use and creation of the `Tasks` (`new Task(Action).Start()`) as well as timers.\r\nSo it might also be caused by that.~~\r\n\r\nUpdate: on closer inspection we do mostly use the same `RedisChannel`s, especially the one which is clearly generating the most traffic. What is different, however, is that in the other applications we create a `Task` (`new Task(Action).Start()`) and a timer for each `RedisChannel` -- which is something we don\u0027t do in the unaffected application. The timer is reporting prometheus metrics once a minute and the tasks basically block on 100% of the time in `BlockingCollection.Take(..)` (they are superfluous in the affected apps).\r\nIn all the other applications it adds up to 42 Tasks and timers that are created in connection to `RedisChannel`s. But the unaffected application doesn\u0027t have these. It\u0027s also not creating a significant amount of endless Tasks and timers for other reasons.\r\n\r\n-------------\r\n\r\nIs my understanding correct that the traces generated by dotnet-trace don\u0027t directly relate to actual cpu time consumed/cpu-load consumed but rather just show the \"real\" time a thread spends in a given method? i.E. it\u0027s quite difficult to find out what\u0027s causing actual cpu load?",
                                           "updatedAt":  "2022-07-14T13:42:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GmXg4",
                                           "createdAt":  "2022-07-14T13:40:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "BrunoJuchli",
                                           "body":  "@mangod9 \r\nI\u0027ve looked a bit closer at it and had to correct my last comment. At the moment I don\u0027t have a clear indication that would point to StackExchange.Redis - it\u0027s being used in affected and unaffected apps.",
                                           "updatedAt":  "2022-07-14T13:40:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KLX4s",
                                           "createdAt":  "2022-09-12T21:20:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "\u003e Is my understanding correct that the traces generated by dotnet-trace don\u0027t directly relate to actual cpu time consumed/cpu-load consumed but rather just show the \"real\" time a thread spends in a given method? i.E. it\u0027s quite difficult to find out what\u0027s causing actual cpu load?\r\n\r\nYes, `dotnet-trace` samples managed thread stacks and it cannot know whether a thread is blocked or not, so the sample count will include blocked time, which can make it more difficult to analyze on-CPU usage. [`perfcollect`](https://docs.microsoft.com/en-us/dotnet/core/diagnostics/trace-perfcollect-lttng) can produce on-CPU traces that may be easier to analyze for CPU usage.\r\n\r\nI\u0027m not able to open the Linux traces in the latest PerfView, I\u0027m seeing an error:\r\n```\r\nError: Exception EventPipe conversion: System.Exception: Read past end of stream.\r\n[Error: exception while opening EventPipe data.]\r\n```\r\n\r\nIf I try to ignore the errors with `-ContinueOnError`, I\u0027m able to see some events but I\u0027m not able to see sampled stacks. Are you able to open those traces in PerfView?\r\n\r\nI see events indicating thread pool worker thread starvation in both the Windows and Linux traces. Example from the bulkmetersim Windows trace below, there are a few more in the Linux trace:\r\n```\r\nEvent Name                                                                 \t Time MSec\tProcess Name          \tRest  \r\nMicrosoft-Windows-DotNETRuntime/ThreadPoolWorkerThreadAdjustment/Adjustment\t15,513.017\tProcess(14840) (14840)\tThreadID=\"13,424\" ProcessorNumber=\"0\" AverageThroughput=\"0.000\" NewWorkerThreadCount=\"44\" Reason=\"Starvation\" ClrInstanceID=\"0\" \r\n```\r\n\r\nSome callee stacks that appear to be blocking thread pool worker threads:\r\n\r\n```\r\nName                                                                                                                                                                                                                                              \tInc %\t         Inc\r\n System.Private.CoreLib.il!System.Threading.PortableThreadPool+WorkerThread.WorkerThreadStart()                                                                                                                                                   \t 77.2\t   1,481,728\r\n+ System.Private.CoreLib.il!ThreadPoolWorkQueue.Dispatch                                                                                                                                                                                          \t 70.1\t   1,346,848\r\n|+ System.Private.CoreLib.il!Task.ExecuteEntryUnsafe                                                                                                                                                                                              \t 70.1\t   1,346,717\r\n||+ System.Private.CoreLib.il!Task.ExecuteWithThreadLocal                                                                                                                                                                                         \t 70.1\t   1,346,717\r\n|| + System.Private.CoreLib.il!ExecutionContext.RunFromThreadPoolDispatchLoop                                                                                                                                                                     \t 70.1\t   1,346,717\r\n||  + System.Private.CoreLib.il!System.Threading.Tasks.Task+\u003c\u003ec.\u003c.cctor\u003eb__272_0(class System.Object)                                                                                                                                             \t 70.1\t   1,346,717\r\n||   + System.Private.CoreLib.il!Task.InnerInvoke                                                                                                                                                                                                 \t 70.1\t   1,346,717\r\n||    + Datastore.Repositories!Datastore.Repositories.PubQueue`2[System.__Canon,System.Guid].Run()                                                                                                                                                \t 45.7\t     876,932\r\n||    |+ System.Collections.Concurrent.il!System.Collections.Concurrent.BlockingCollection`1[System.__Canon].Take()                                                                                                                               \t 45.7\t     876,932\r\n||    | + System.Collections.Concurrent.il!System.Collections.Concurrent.BlockingCollection`1[System.__Canon].TryTakeWithNoTimeValidation(!0\u0026,int32,value class System.Threading.CancellationToken,class System.Threading.CancellationTokenSource)\t 45.7\t     876,932\r\n||    |  + System.Private.CoreLib.il!SemaphoreSlim.Wait                                                                                                                                                                                           \t 45.7\t     876,932\r\n||    |   + System.Private.CoreLib.il!SemaphoreSlim.WaitUntilCountOrTimeout                                                                                                                                                                       \t 45.7\t     876,932\r\n||    |    + System.Private.CoreLib.il!Monitor.Wait                                                                                                                                                                                               \t 45.7\t     876,932\r\n||    + Datastore.Repositories!Datastore.Repositories.PubQueue`2[System.__Canon,System.Int64].Run()                                                                                                                                               \t 14.7\t     281,871\r\n||    |+ System.Collections.Concurrent.il!System.Collections.Concurrent.BlockingCollection`1[System.__Canon].Take()                                                                                                                               \t 14.7\t     281,871\r\n||    | + System.Collections.Concurrent.il!System.Collections.Concurrent.BlockingCollection`1[System.__Canon].TryTakeWithNoTimeValidation(!0\u0026,int32,value class System.Threading.CancellationToken,class System.Threading.CancellationTokenSource)\t 14.7\t     281,871\r\n||    |  + System.Private.CoreLib.il!SemaphoreSlim.Wait                                                                                                                                                                                           \t 14.7\t     281,871\r\n||    |   + System.Private.CoreLib.il!SemaphoreSlim.WaitUntilCountOrTimeout                                                                                                                                                                       \t 14.7\t     281,871\r\n||    |    + System.Private.CoreLib.il!Monitor.Wait                                                                                                                                                                                               \t 14.7\t     281,871\r\n||    + Datastore.Repositories!Datastore.Repositories.PubQueue`2[System.__Canon,PubSub.Interface.SmartMeConnectPubSubMessage].Run()                                                                                                               \t  6.5\t     125,276\r\n||    |+ System.Collections.Concurrent.il!System.Collections.Concurrent.BlockingCollection`1[System.__Canon].Take()                                                                                                                               \t  6.5\t     125,276\r\n||    | + System.Collections.Concurrent.il!System.Collections.Concurrent.BlockingCollection`1[System.__Canon].TryTakeWithNoTimeValidation(!0\u0026,int32,value class System.Threading.CancellationToken,class System.Threading.CancellationTokenSource)\t  6.5\t     125,276\r\n||    |  + System.Private.CoreLib.il!SemaphoreSlim.Wait                                                                                                                                                                                           \t  6.5\t     125,276\r\n||    |   + System.Private.CoreLib.il!SemaphoreSlim.WaitUntilCountOrTimeout                                                                                                                                                                       \t  6.5\t     125,276\r\n||    |    + System.Private.CoreLib.il!Monitor.Wait                                                                                                                                                                                               \t  6.5\t     125,276\r\n||    + Datastore.Repositories!Datastore.Repositories.PubQueue`2[System.Guid,System.Guid].Run()                                                                                                                                                   \t  1.6\t      31,319\r\n||    |+ System.Collections.Concurrent.il!System.Collections.Concurrent.BlockingCollection`1[System.Guid].Take()                                                                                                                                  \t  1.6\t      31,319\r\n||    | + System.Collections.Concurrent.il!System.Collections.Concurrent.BlockingCollection`1[System.Guid].TryTake(!0\u0026,int32,value class System.Threading.CancellationToken)                                                                      \t  1.6\t      31,319\r\n||    |  + System.Collections.Concurrent.il!System.Collections.Concurrent.BlockingCollection`1[System.Guid].TryTakeWithNoTimeValidation(!0\u0026,int32,value class System.Threading.CancellationToken,class System.Threading.CancellationTokenSource)  \t  1.6\t      31,319\r\n||    |   + System.Private.CoreLib.il!SemaphoreSlim.Wait                                                                                                                                                                                          \t  1.6\t      31,319\r\n||    |    + System.Private.CoreLib.il!SemaphoreSlim.WaitUntilCountOrTimeout                                                                                                                                                                      \t  1.6\t      31,319\r\n||    |     + System.Private.CoreLib.il!Monitor.Wait                                                                                                                                                                                              \t  1.6\t      31,319\r\n```\r\n\r\nBlocking thread pool threads often leads to issues. As you can see in the `Adjustment` event above indicating `Starvation`, the average throughput of queued work items goes to zero. Threads aren\u0027t injected very quickly in those cases. Although I see more frequent starvation in the Linux trace, the event only indicates starvation when all thread pool threads have not completed a work item in ~0.5-1 s. It doesn\u0027t indicate how many threads are blocked on average. How many threads are blocked on average can have an impact on CPU usage. Based on the above callee stacks, I\u0027d suggest switching to an async alternate to `BlockingCollection`, perhaps [`Channels` APIs](https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/).\r\n\r\nI see that the `ThreadPool Completed Work Item Count (Count / 1 sec)` counter shows on average more completed work items per sec on Linux, and larger spikes in the `ThreadPool Queue Length` counter on Windows, a possibility is that threads are blocking more on Windows and leading to less CPU usage.\r\n\r\nA hopefully temporary workaround may be to increase the min worker thread count with `ThreadPool.SetMinThreads` or by other means, such as with an environment config variable ([`DOTNET_ThreadPool_ForceMinWorkerThreads`](https://github.com/steveharter/dotnet_coreclr/blob/master/Documentation/project-docs/clr-configuration-knobs.md#threadpool-configuration-knobs)) or through [project config](https://docs.microsoft.com/en-us/dotnet/core/runtime-config/threading#minimum-threads). Note that the environment variable takes values in hexadecimal. Increasing the min worker thread count may help to avoid starvation but may also increase CPU usage, see below.\r\n\r\nI also noticed that the average throughput of queued work items to the thread pool is not very high. The thread pool may consume more CPU in lower-load scenarios (low load on the thread pool, not on the whole system). It has been improved a bit in .NET 7, and there\u0027s more room for improvement there. Setting the environment variable [`DOTNET_ThreadPool_UnfairSemaphoreSpinLimit=0`](https://github.com/steveharter/dotnet_coreclr/blob/master/Documentation/project-docs/clr-configuration-knobs.md#threadpool-configuration-knobs) before starting the process may help to reduce some of that CPU usage, especially when the min worker thread count is increased through config.",
                                           "updatedAt":  "2022-09-12T21:28:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KUH91",
                                           "createdAt":  "2022-09-14T13:45:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "BrunoJuchli",
                                           "body":  "@kouvel\r\nThank you very much for the time you have taken to investigate and your valuable input.\r\n\r\nIn the meantime we have improved the usage of the ThreadPool. There\u0027s some long-running tasks which were created upon application start and were run on the threadpool and these have lead to the threadpool starvation.\r\nI\u0027ve changed these to run outside of the threadpool. But they are still using sync API so there\u0027s definitively more room for improvement, here. Moving code to async is a work in progress which will take quite some more time to finish.\r\nThis change of running these long running tasks outside of the ThreadPool did not have a significant CPU load impact, however.\r\n\r\nI will try and see what impact [`DOTNET_ThreadPool_UnfairSemaphoreSpinLimit=0`](https://github.com/steveharter/dotnet_coreclr/blob/master/Documentation/project-docs/clr-configuration-knobs.md#threadpool-configuration-knobs) has and also try to collect more data using perfcollect - thanks for the tip!\r\n\r\n-------------\r\n\u003e  Are you able to open those traces in PerfView?\r\n\r\nActually, I also can\u0027t open the linux traces found in the traces.zip and bulkmetersim.zip files in PerfView 3.0.4.\r\nNot sure why this is, I\u0027m sure I looked at all the traces before uploading, but maybe I somehow corrupted these?\r\nThe Linux traces in the other zip files do work however:\r\n\r\n- [dotnet_20220707_125557.zip](https://github.com/dotnet/runtime/files/9081673/dotnet_20220707_125557.zip)\r\n- [trace2.zip](https://github.com/dotnet/runtime/files/9081692/trace2.zip)\r\n\r\n",
                                           "updatedAt":  "2022-09-14T13:48:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KWnsk",
                                           "createdAt":  "2022-09-15T00:47:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "\u003e This change of running these long running tasks outside of the ThreadPool did not have a significant CPU load impact, however.\r\n\r\nIs that on Linux, or Windows, or are both looking the same in CPU usage? I\u0027m curious if the CPU usage equalized after that change.",
                                           "updatedAt":  "2022-09-15T00:47:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KWn3l",
                                           "createdAt":  "2022-09-15T00:49:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "It may be useful to compare CPU profiles of Windows and Linux after that change. `dotnet-trace` may be fine if the thread pool threads are not blocking too much anymore, or otherwise `PerfView`/`perfcollect` to get on-CPU profiles.",
                                           "updatedAt":  "2022-09-15T00:49:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc58GZt0",
                                           "createdAt":  "2024-04-29T07:28:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD5f6ww==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "anionDev",
                                                                               "createdAt":  "2024-05-26T19:45:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "GraCoder",
                                                                               "createdAt":  "2024-10-14T06:29:52Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "anime-shed",
                                                                               "createdAt":  "2024-11-05T13:20:53Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "gregolsky",
                                           "body":  "We observe that even with `DOTNET_ThreadPool_UnfairSemaphoreSpinLimit=0`, `.NET Timer` thread still consumes around 3% CPU on average, which is a big deal for all those very small servers (`B1ls` on Azure or `t3a.nano` on AWS) for which 5% is the baseline CPU limit and going over that consumes the burst credits.\r\n\r\nBelow is a screenshot of top filtered by the main .NET process on the server. The process is an idle server - there\u0027s just some occasional heartbeats and monitoring work going. Yet the .NET timer consumes the most CPU in this scenario.\r\n\r\n![image](https://github.com/dotnet/runtime/assets/1541805/4826a3b4-90d0-4a97-b1bc-52edc9c3d98b)\r\n\r\nIs there anything else we can do to curb down the CPU usage on .NET Timer thread?",
                                           "updatedAt":  "2024-04-29T07:39:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6XioDi",
                                           "createdAt":  "2024-12-13T21:49:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gregolsky",
                                           "body":  "Is there something that the user might be doing to increase the CPU usage in this thread? \n\nLet me explain - we have a 2 different versions of our application, say v5 and v6. They run on the same .NET version - .NET 8. Now v6 is using order of magnitude more CPU in .NET Timer than v5. `DOTNET_ThreadPool_UnfairSemaphoreSpinLimit` is set to 0.\n\nAll it does system-wise is just a ton of constant `futex` calls. What might be different in v6 that might increase the CPU usage in `.NET Timer` thread? Where should we start looking? Please advise.\n",
                                           "updatedAt":  "2024-12-13T21:49:23Z"
                                       }
                                   ],
                         "totalCount":  14
                     },
        "title":  "Much higher CPU Usage on Linux than on Windows",
        "labels":  [
                       "area-System.Threading",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/72153",
        "createdAt":  "2022-07-13T22:00:28Z",
        "number":  72153,
        "author":  "andrewaggb",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODCP8gA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DejanPelzel",
                                            "createdAt":  "2022-11-11T07:08:49Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "huntharo",
                                            "createdAt":  "2023-12-31T00:19:49Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "josephnhtam",
                                            "createdAt":  "2024-05-15T17:53:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MaximeBdrd",
                                            "createdAt":  "2024-06-04T17:19:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "6opuc",
                                            "createdAt":  "2025-01-12T10:40:33Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AndreyPolovodov",
                                            "createdAt":  "2025-05-11T09:57:10Z"
                                        }
                                    ],
                          "totalCount":  6
                      },
        "updatedAt":  "2025-01-13T20:15:21Z",
        "body":  "I\u0027m finding that any form of async tcp or unix socket in c#/.net 6 is using 5-8x the cpu usage compared to using synchronous sockets in c# or doing essentially the same thing in python3, nodejs, or netcat in listen mode.  Async sockets in c# on windows perform fine.  I\u0027ve tried several different forms of async with sockets in c# and they all seem to behave the same.\r\n\r\nIn my test scenario I\u0027m saturating a gigabit ethernet link via netcat because it\u0027s very easy to reproduce.  My production scenario is a video surveillance application receiving many simultaneous hd video feeds.  \r\n\r\nI have experienced this issue in my production application with and without docker, on physical machines and in hyper-v virtual machines, on centos 7.9, rocky 8.6, and ubuntu 20.04.\r\n\r\nMy examples below will all be ubuntu 20.04 with dotnet 6 installed on the host.\r\nHyper-v virtual machine on windows 11 with 4 hyper-v cpus on a ryzen 5600g\r\n\r\nI\u0027m using cpu percentages from the top command and these are all processing the same gigabit traffic (no example here is processing more or less MB/s - they are all a full gigabit link verified with application counters and tools like iftop)\r\n\r\nusing a standard TCP Listener -\u003e NetworkStream with sync reads and a ~1MB buffer\r\n~6-8% cpu usage.  I have no problem with this and as you\u0027ll see below this result is consistent with other tools and programming languages in my test environment.\r\n```\r\n  byte[] buffer = new byte[1048576];\r\n  while ((nBytes **= stream.Read(**buffer, 0, buffer.Length)) \u003e 0)\r\n  {\r\n      totalBytes += nBytes;\r\n  }\r\n```\r\n\r\nusing a standard TCP Listener -\u003e NetworkStream with async reads and a ~1MB buffer.  The only difference is await ReadAsync vs Read\r\n~50-60% cpu usage - **5-8x as much cpu as the synchronous version**. \r\n```\r\n  byte[] buffer = new byte[1048576];\r\n  while((nBytes = **await stream.ReadAsync(**buffer, 0, buffer.Length)) \u003e 0)\r\n  {\r\n      totalBytes += nBytes;\r\n  }\r\n```\r\n\r\nI have also tried socket.BeginReceive with approximately the same 50-60% cpu usage\r\nI have also tried socket.ReceiveAsync with SocketAsyncEventArgs with approximately the same 50-60% cpu usage\r\n\r\nI have tried unix Sockets in c#/.net 6\r\nWith unix sockets the cpu usage for a synchronous read loop is around 6% of cpu (vs 6-8% for tcp sockets).  I piped a netcat receiver into the unix socket to ensure the same amount of data was being processed.\r\n\r\nWith unix sockets the cpu usage for an asynchronous read loop is around 50-60% of cpu (~ the same as async tcp sockets).  I piped a netcat receiver into the unix socket to ensure the same amount of data was being processed.\r\n\r\n\r\n### I ran some comparables\r\nusing netcat as a listener\r\nnc -l 9989 \u003e/dev/null \r\nuses about 8% cpu (same as synchronous sockets in c#)\r\n\r\nusing nodejs and the socket.on data callback\r\nuses about 10% cpu (slightly more than synchronous c# but 5-6x less than async c# and this is async and not re-using a receive buffer so it\u0027s less efficient)\r\n\r\nusing python3 with a synchronous tcp socket receiving into a buffer (very comparable to my c# synchronous example)\r\nuses about 8% cpu (same as synchronous sockets in c#)\r\n\r\nusing golang with a goroutine per connection receiving into a buffer (comparable to my c# synchronous example)\r\nuses about 14% cpu (approximately double synchronous sockets in c#)\r\n\r\nMy basic test methodology is\r\nFrom another machine run netcat to generate a full gigabit/s of ethernet traffic \r\n`cat /dev/zero | nc 192.168.1.93 9989`\r\n\r\nOn the destination machine 192.168.1.93 (the ubuntu 20.04 vm all the tests were run on)\r\n\r\nHigh CPU usage\r\ndotnet run --configuration Release PerfTestTCPListenerAsync\r\n\r\nLow CPU usage\r\ndotnet run --configuration Release PerfTestTCPListener\r\nnc -l 9989 \u003e/dev/null\r\nnodejs jsserver.js\r\npython3 pyserver.py\r\n\r\nI\u0027ve included the most basic c# example Program.cs using the exact same code with a Read vs ReadAsync, a very basic python example pyserver.py and a very basic nodejs example jsserver.js.  All are configured to listen on port 9989 so the same netcat client command can be run against any of the 5 examples.  \r\n\r\nI\u0027ve been monitoring the cpu usage with top and network traffic with iftop.\r\n\r\n[data.zip](https://github.com/dotnet/core/files/9106126/data.zip)\r\n\r\n\r\nAsync version dotnet-counters monitor (I\u0027m note sure if the cpu usage here is quoting all cores but top value shows 52% for this async socket process)\r\n[System.Runtime]\r\n    % Time in GC since last GC (%)                                 0\r\n    Allocation Rate (B / 1 sec)                              244,648\r\n    CPU Usage (%)                                                 16\r\n    Exception Count (Count / 1 sec)                                0\r\n    GC Committed Bytes (MB)                                        9\r\n    GC Fragmentation (%)                                           0.233\r\n    GC Heap Size (MB)                                              6\r\n    Gen 0 GC Count (Count / 1 sec)                                 0\r\n    Gen 0 Size (B)                                                24\r\n    Gen 1 GC Count (Count / 1 sec)                                 0\r\n    Gen 1 Size (B)                                           245,448\r\n    Gen 2 GC Count (Count / 1 sec)                                 0\r\n    Gen 2 Size (B)                                                24\r\n    IL Bytes Jitted (B)                                       48,860\r\n    LOH Size (B)                                           1,048,656\r\n    Monitor Lock Contention Count (Count / 1 sec)                  0\r\n    Number of Active Timers                                        0\r\n    Number of Assemblies Loaded                                   18\r\n    Number of Methods Jitted                                     392\r\n    POH (Pinned Object Heap) Size (B)                         39,976\r\n    ThreadPool Completed Work Item Count (Count / 1 sec)       6,132\r\n    ThreadPool Queue Length                                        0\r\n    ThreadPool Thread Count                                        5\r\n    Time spent in JIT (ms / 1 sec)                                 0\r\n    Working Set (MB)                                              47\r\n\r\n\r\nSynchronous version (top shows cpu usage as around 6%)\r\n[System.Runtime]\r\n    % Time in GC since last GC (%)                                 0\r\n    Allocation Rate (B / 1 sec)                               32,672\r\n    CPU Usage (%)                                                  0\r\n    Exception Count (Count / 1 sec)                                0\r\n    GC Committed Bytes (MB)                                       26\r\n    GC Fragmentation (%)                                           1.105\r\n    GC Heap Size (MB)                                             25\r\n    Gen 0 GC Count (Count / 1 sec)                                 0\r\n    Gen 0 Size (B)                                                24\r\n    Gen 1 GC Count (Count / 1 sec)                                 0\r\n    Gen 1 Size (B)                                         7,806,528\r\n    Gen 2 GC Count (Count / 1 sec)                                 0\r\n    Gen 2 Size (B)                                        12,179,944\r\n    IL Bytes Jitted (B)                                      295,457\r\n    LOH Size (B)                                             287,848\r\n    Monitor Lock Contention Count (Count / 1 sec)                  0\r\n    Number of Active Timers                                        4\r\n    Number of Assemblies Loaded                                  121\r\n    Number of Methods Jitted                                   3,737\r\n    POH (Pinned Object Heap) Size (B)                        195,360\r\n    ThreadPool Completed Work Item Count (Count / 1 sec)           0\r\n    ThreadPool Queue Length                                        0\r\n    ThreadPool Thread Count                                        4\r\n    Time spent in JIT (ms / 1 sec)                                 0\r\n    Working Set (MB)                                             140\r\n\r\nLinux Traces:\r\nI\u0027ve attached 20 second dotnet-trace results from both Synchronous and Asynchronous in Linux.  It appears to me all (or most)of the extra time is spent in LowLevelLifoSemaphore but I\u0027m not sure if that\u0027s expected.\r\n\r\n[Traces.zip](https://github.com/dotnet/core/files/9106253/Traces.zip)\r\n\r\n\r\nVersus Windows (0.1% cpu in async mode, 12700k)\r\n![image](https://user-images.githubusercontent.com/1630971/178843125-d2c47a9f-e7cc-40d7-94b4-0ff6ae614b33.png)\r\n\r\n[TraceAsyncWindows.zip](https://github.com/dotnet/core/files/9106362/TraceAsyncWindows.zip)\r\nOf course the windows trace looks very different as it uses IOCompletion\r\n\r\n\r\nI ran some tests using a similarly spec\u0027d windows 10 hyper-v VM and got pretty lousy numbers.  Both Synchronous and Async used about 50% of the cpu (4 hyper-v cpus on a 5700g) and only got up to about 600mbps.   While it doesn\u0027t invalidate the enormous synchronous vs asynchronous performance discrepancy I observed on linux it may invalidate the windows vs linux argument.  These aren\u0027t heavily loaded hyper-visors so I\u0027m surprised to be honest.  Python3 got 35% cpu usage and 800mbps on the same windows 10 machine.\r\n\r\nUsing a 5700g with windows 11 (not in a hyper-vm) shows similar 0.3%ish cpu usage and full gigabit traffic for .net 6 async and slightly higher cpu usage for python3 (0.4ish) for full gigabit traffic.\r\n\r\nUsing an intel 12400 (non virtualized) rocky linux 8.5 I had 40% cpu usage in async and 1% for synchronous on 100mbit interface and 47% async vs 1% synchronous on a gigabit interface for the same machine.  \r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOmkNLBw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5Gj-JZ",
                                           "createdAt":  "2022-07-14T01:01:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-07-14T01:01:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Gj-Nc",
                                           "createdAt":  "2022-07-14T01:01:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nI\u0027m finding that any form of async tcp or unix socket in c#/.net 6 is using 5-8x the cpu usage compared to using synchronous sockets in c# or doing essentially the same thing in python3, nodejs, or netcat in listen mode.  Async sockets in c# on windows perform fine.  I\u0027ve tried several different forms of async with sockets in c# and they all seem to behave the same.\r\n\r\nIn my test scenario I\u0027m saturating a gigabit ethernet link via netcat because it\u0027s very easy to reproduce.  My production scenario is a video surveillance application receiving many simultaneous hd video feeds.  \r\n\r\nI have experienced this issue in my production application with and without docker, on physical machines and in hyper-v virtual machines, on centos 7.9, rocky 8.6, and ubuntu 20.04.\r\n\r\nMy examples below will all be ubuntu 20.04 with dotnet 6 installed on the host.\r\nHyper-v virtual machine on windows 11 with 4 hyper-v cpus on a ryzen 5600g\r\n\r\nI\u0027m using cpu percentages from the top command and these are all processing the same gigabit traffic (no example here is processing more or less MB/s - they are all a full gigabit link verified with application counters and tools like iftop)\r\n\r\nusing a standard TCP Listener -\u003e NetworkStream with sync reads and a ~1MB buffer\r\n~6-8% cpu usage.  I have no problem with this and as you\u0027ll see below this result is consistent with other tools and programming languages in my test environment.\r\n```\r\n  byte[] buffer = new byte[1048576];\r\n  while ((nBytes **= stream.Read(**buffer, 0, buffer.Length)) \u003e 0)\r\n  {\r\n      totalBytes += nBytes;\r\n  }\r\n```\r\n\r\nusing a standard TCP Listener -\u003e NetworkStream with async reads and a ~1MB buffer.  The only difference is await ReadAsync vs Read\r\n~50-60% cpu usage - **5-8x as much cpu as the synchronous version**. \r\n```\r\n  byte[] buffer = new byte[1048576];\r\n  while((nBytes = **await stream.ReadAsync(**buffer, 0, buffer.Length)) \u003e 0)\r\n  {\r\n      totalBytes += nBytes;\r\n  }\r\n```\r\n\r\nI have also tried socket.BeginReceive with approximately the same 50-60% cpu usage\r\nI have also tried socket.ReceiveAsync with SocketAsyncEventArgs with approximately the same 50-60% cpu usage\r\n\r\nI have tried unix Sockets in c#/.net 6\r\nWith unix sockets the cpu usage for a synchronous read loop is around 6% of cpu (vs 6-8% for tcp sockets).  I piped a netcat receiver into the unix socket to ensure the same amount of data was being processed.\r\n\r\nWith unix sockets the cpu usage for an asynchronous read loop is around 50-60% of cpu (~ the same as async tcp sockets).  I piped a netcat receiver into the unix socket to ensure the same amount of data was being processed.\r\n\r\n\r\n### I ran some comparables\r\nusing netcat as a listener\r\nnc -l 9989 \u003e/dev/null \r\nuses about 8% cpu (same as synchronous sockets in c#)\r\n\r\nusing nodejs and the socket.on data callback\r\nuses about 10% cpu (slightly more than synchronous c# but 5-6x less than async c# and this is async and not re-using a receive buffer so it\u0027s less efficient)\r\n\r\nusing python3 with a synchronous tcp socket receiving into a buffer (very comparable to my c# synchronous example)\r\nuses about 8% cpu (same as synchronous sockets in c#)\r\n\r\n\r\nMy basic test methodology is\r\nFrom another machine run netcat to generate a full gigabit/s of ethernet traffic \r\n`cat /dev/zero | nc 192.168.1.93 9989`\r\n\r\nOn the destination machine 192.168.1.93 (the ubuntu 20.04 vm all the tests were run on)\r\n\r\nHigh CPU usage\r\ndotnet run --configuration Release PerfTestTCPListenerAsync\r\n\r\nLow CPU usage\r\ndotnet run --configuration Release PerfTestTCPListener\r\nnc -l 9989 \u003e/dev/null\r\nnodejs jsserver.js\r\npython3 pyserver.py\r\n\r\nI\u0027ve included the most basic c# example Program.cs using the exact same code with a Read vs ReadAsync, a very basic python example pyserver.py and a very basic nodejs example jsserver.js.  All are configured to listen on port 9989 so the same netcat client command can be run against any of the 5 examples.  \r\n\r\nI\u0027ve been monitoring the cpu usage with top and network traffic with iftop.\r\n\r\n[data.zip](https://github.com/dotnet/core/files/9106126/data.zip)\r\n\r\n\r\nAsync version dotnet-counters monitor (I\u0027m note sure if the cpu usage here is quoting all cores but top value shows 52% for this async socket process)\r\n[System.Runtime]\r\n    % Time in GC since last GC (%)                                 0\r\n    Allocation Rate (B / 1 sec)                              244,648\r\n    CPU Usage (%)                                                 16\r\n    Exception Count (Count / 1 sec)                                0\r\n    GC Committed Bytes (MB)                                        9\r\n    GC Fragmentation (%)                                           0.233\r\n    GC Heap Size (MB)                                              6\r\n    Gen 0 GC Count (Count / 1 sec)                                 0\r\n    Gen 0 Size (B)                                                24\r\n    Gen 1 GC Count (Count / 1 sec)                                 0\r\n    Gen 1 Size (B)                                           245,448\r\n    Gen 2 GC Count (Count / 1 sec)                                 0\r\n    Gen 2 Size (B)                                                24\r\n    IL Bytes Jitted (B)                                       48,860\r\n    LOH Size (B)                                           1,048,656\r\n    Monitor Lock Contention Count (Count / 1 sec)                  0\r\n    Number of Active Timers                                        0\r\n    Number of Assemblies Loaded                                   18\r\n    Number of Methods Jitted                                     392\r\n    POH (Pinned Object Heap) Size (B)                         39,976\r\n    ThreadPool Completed Work Item Count (Count / 1 sec)       6,132\r\n    ThreadPool Queue Length                                        0\r\n    ThreadPool Thread Count                                        5\r\n    Time spent in JIT (ms / 1 sec)                                 0\r\n    Working Set (MB)                                              47\r\n\r\n\r\nSynchronous version (top shows cpu usage as around 6%)\r\n[System.Runtime]\r\n    % Time in GC since last GC (%)                                 0\r\n    Allocation Rate (B / 1 sec)                               32,672\r\n    CPU Usage (%)                                                  0\r\n    Exception Count (Count / 1 sec)                                0\r\n    GC Committed Bytes (MB)                                       26\r\n    GC Fragmentation (%)                                           1.105\r\n    GC Heap Size (MB)                                             25\r\n    Gen 0 GC Count (Count / 1 sec)                                 0\r\n    Gen 0 Size (B)                                                24\r\n    Gen 1 GC Count (Count / 1 sec)                                 0\r\n    Gen 1 Size (B)                                         7,806,528\r\n    Gen 2 GC Count (Count / 1 sec)                                 0\r\n    Gen 2 Size (B)                                        12,179,944\r\n    IL Bytes Jitted (B)                                      295,457\r\n    LOH Size (B)                                             287,848\r\n    Monitor Lock Contention Count (Count / 1 sec)                  0\r\n    Number of Active Timers                                        4\r\n    Number of Assemblies Loaded                                  121\r\n    Number of Methods Jitted                                   3,737\r\n    POH (Pinned Object Heap) Size (B)                        195,360\r\n    ThreadPool Completed Work Item Count (Count / 1 sec)           0\r\n    ThreadPool Queue Length                                        0\r\n    ThreadPool Thread Count                                        4\r\n    Time spent in JIT (ms / 1 sec)                                 0\r\n    Working Set (MB)                                             140\r\n\r\nLinux Traces:\r\nI\u0027ve attached 20 second dotnet-trace results from both Synchronous and Asynchronous in Linux.  It appears to me all (or most)of the extra time is spent in LowLevelLifoSemaphore but I\u0027m not sure if that\u0027s expected.\r\n\r\n[Traces.zip](https://github.com/dotnet/core/files/9106253/Traces.zip)\r\n\r\n\r\nVersus Windows (0.1% cpu in async mode, 12700k)\r\n![image](https://user-images.githubusercontent.com/1630971/178843125-d2c47a9f-e7cc-40d7-94b4-0ff6ae614b33.png)\r\n\r\n[TraceAsyncWindows.zip](https://github.com/dotnet/core/files/9106362/TraceAsyncWindows.zip)\r\nOf course the windows trace looks very different as it uses IOCompletion\r\n\r\n\r\nI ran some tests using a similarly spec\u0027d windows 10 hyper-v VM and got pretty lousy numbers.  Both Synchronous and Async used about 50% of the cpu (4 hyper-v cpus on a 5700g) and only got up to about 600mbps.   While it doesn\u0027t invalidate the enormous synchronous vs asynchronous performance discrepancy I observed on linux it may invalidate the windows vs linux argument.  These aren\u0027t heavily loaded hyper-visors so I\u0027m surprised to be honest.  Python3 got 35% cpu usage and 800mbps on the same windows 10 machine.\r\n\r\nUsing a 5700g with windows 11 (not in a hyper-vm) shows similar 0.3%ish cpu usage and full gigabit traffic for .net 6 async and slightly higher cpu usage for python3 (0.4ish) for full gigabit traffic.\r\n\r\nUsing an intel 12400 (non virtualized) rocky linux 8.5 I had 40% cpu usage in async and 1% for synchronous on 100mbit interface and 47% async vs 1% synchronous on a gigabit interface for the same machine.  \r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eandrewaggb\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-07-14T01:01:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Gkajm",
                                           "createdAt":  "2022-07-14T03:44:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "Can you try setting the environment variable `DOTNET_SYSTEM_NET_SOCKETS_INLINE_COMPLETIONS` to 1 and re-running your test?",
                                           "updatedAt":  "2022-07-14T03:44:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GkjQs",
                                           "createdAt":  "2022-07-14T04:54:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "andrewaggb",
                                           "body":  "\u003e Can you try setting the environment variable `DOTNET_SYSTEM_NET_SOCKETS_INLINE_COMPLETIONS` to 1 and re-running your test?\r\n\r\nI tried setting DOTNET_SYSTEM_NET_SOCKETS_INLINE_COMPLETIONS=1 and running the async example on my intel 12400 bare metal machine running rocky linux 8.5. The async cpu usage went from 47% cpu to 2% cpu.  So that\u0027s pretty huge and puts the performance right where I\u0027d expect.\r\n\r\nI also tried the ubuntu VM that I did my earlier testing in and the cpu usage dropped from about 52% to 7% which is comparable to the synchronous results and better than nodejs.\r\n\r\nIt sounds like that flag is experimental and potentially unstable according to https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5/, I\u0027m guessing that\u0027s still true for .net 6?\r\n",
                                           "updatedAt":  "2022-07-14T04:54:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GklMh",
                                           "createdAt":  "2022-07-14T05:10:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "andrewaggb",
                                           "body":  "I tried my actual application with the flag enabled and while I do see a significant drop in cpu usage for the application as a whole (4-5x) it seems to be unstable as-is with some video feeds reconnecting and whatnot so I\u0027d have to experiment some more and see what works and what doesn\u0027t.  It\u0027s too early to say without further investigation what the actual cpu reduction will be as some feeds might not be getting processed in which case some of that reduction is because it\u0027s doing less. \r\n",
                                           "updatedAt":  "2022-07-14T05:12:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Gm6ra",
                                           "createdAt":  "2022-07-14T15:50:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOECGJJA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AndreyPolovodov",
                                                                               "createdAt":  "2024-03-27T20:14:10Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "6opuc",
                                                                               "createdAt":  "2025-01-12T18:34:10Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "wfurt",
                                           "body":  "triage: we should investigate and perhaps get the INLINE_COMPLETIONS to useable state. ",
                                           "updatedAt":  "2022-07-14T15:50:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Gm6xk",
                                           "createdAt":  "2022-07-14T15:50:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nI\u0027m finding that any form of async tcp or unix socket in c#/.net 6 is using 5-8x the cpu usage compared to using synchronous sockets in c# or doing essentially the same thing in python3, nodejs, or netcat in listen mode.  Async sockets in c# on windows perform fine.  I\u0027ve tried several different forms of async with sockets in c# and they all seem to behave the same.\r\n\r\nIn my test scenario I\u0027m saturating a gigabit ethernet link via netcat because it\u0027s very easy to reproduce.  My production scenario is a video surveillance application receiving many simultaneous hd video feeds.  \r\n\r\nI have experienced this issue in my production application with and without docker, on physical machines and in hyper-v virtual machines, on centos 7.9, rocky 8.6, and ubuntu 20.04.\r\n\r\nMy examples below will all be ubuntu 20.04 with dotnet 6 installed on the host.\r\nHyper-v virtual machine on windows 11 with 4 hyper-v cpus on a ryzen 5600g\r\n\r\nI\u0027m using cpu percentages from the top command and these are all processing the same gigabit traffic (no example here is processing more or less MB/s - they are all a full gigabit link verified with application counters and tools like iftop)\r\n\r\nusing a standard TCP Listener -\u003e NetworkStream with sync reads and a ~1MB buffer\r\n~6-8% cpu usage.  I have no problem with this and as you\u0027ll see below this result is consistent with other tools and programming languages in my test environment.\r\n```\r\n  byte[] buffer = new byte[1048576];\r\n  while ((nBytes **= stream.Read(**buffer, 0, buffer.Length)) \u003e 0)\r\n  {\r\n      totalBytes += nBytes;\r\n  }\r\n```\r\n\r\nusing a standard TCP Listener -\u003e NetworkStream with async reads and a ~1MB buffer.  The only difference is await ReadAsync vs Read\r\n~50-60% cpu usage - **5-8x as much cpu as the synchronous version**. \r\n```\r\n  byte[] buffer = new byte[1048576];\r\n  while((nBytes = **await stream.ReadAsync(**buffer, 0, buffer.Length)) \u003e 0)\r\n  {\r\n      totalBytes += nBytes;\r\n  }\r\n```\r\n\r\nI have also tried socket.BeginReceive with approximately the same 50-60% cpu usage\r\nI have also tried socket.ReceiveAsync with SocketAsyncEventArgs with approximately the same 50-60% cpu usage\r\n\r\nI have tried unix Sockets in c#/.net 6\r\nWith unix sockets the cpu usage for a synchronous read loop is around 6% of cpu (vs 6-8% for tcp sockets).  I piped a netcat receiver into the unix socket to ensure the same amount of data was being processed.\r\n\r\nWith unix sockets the cpu usage for an asynchronous read loop is around 50-60% of cpu (~ the same as async tcp sockets).  I piped a netcat receiver into the unix socket to ensure the same amount of data was being processed.\r\n\r\n\r\n### I ran some comparables\r\nusing netcat as a listener\r\nnc -l 9989 \u003e/dev/null \r\nuses about 8% cpu (same as synchronous sockets in c#)\r\n\r\nusing nodejs and the socket.on data callback\r\nuses about 10% cpu (slightly more than synchronous c# but 5-6x less than async c# and this is async and not re-using a receive buffer so it\u0027s less efficient)\r\n\r\nusing python3 with a synchronous tcp socket receiving into a buffer (very comparable to my c# synchronous example)\r\nuses about 8% cpu (same as synchronous sockets in c#)\r\n\r\n\r\nMy basic test methodology is\r\nFrom another machine run netcat to generate a full gigabit/s of ethernet traffic \r\n`cat /dev/zero | nc 192.168.1.93 9989`\r\n\r\nOn the destination machine 192.168.1.93 (the ubuntu 20.04 vm all the tests were run on)\r\n\r\nHigh CPU usage\r\ndotnet run --configuration Release PerfTestTCPListenerAsync\r\n\r\nLow CPU usage\r\ndotnet run --configuration Release PerfTestTCPListener\r\nnc -l 9989 \u003e/dev/null\r\nnodejs jsserver.js\r\npython3 pyserver.py\r\n\r\nI\u0027ve included the most basic c# example Program.cs using the exact same code with a Read vs ReadAsync, a very basic python example pyserver.py and a very basic nodejs example jsserver.js.  All are configured to listen on port 9989 so the same netcat client command can be run against any of the 5 examples.  \r\n\r\nI\u0027ve been monitoring the cpu usage with top and network traffic with iftop.\r\n\r\n[data.zip](https://github.com/dotnet/core/files/9106126/data.zip)\r\n\r\n\r\nAsync version dotnet-counters monitor (I\u0027m note sure if the cpu usage here is quoting all cores but top value shows 52% for this async socket process)\r\n[System.Runtime]\r\n    % Time in GC since last GC (%)                                 0\r\n    Allocation Rate (B / 1 sec)                              244,648\r\n    CPU Usage (%)                                                 16\r\n    Exception Count (Count / 1 sec)                                0\r\n    GC Committed Bytes (MB)                                        9\r\n    GC Fragmentation (%)                                           0.233\r\n    GC Heap Size (MB)                                              6\r\n    Gen 0 GC Count (Count / 1 sec)                                 0\r\n    Gen 0 Size (B)                                                24\r\n    Gen 1 GC Count (Count / 1 sec)                                 0\r\n    Gen 1 Size (B)                                           245,448\r\n    Gen 2 GC Count (Count / 1 sec)                                 0\r\n    Gen 2 Size (B)                                                24\r\n    IL Bytes Jitted (B)                                       48,860\r\n    LOH Size (B)                                           1,048,656\r\n    Monitor Lock Contention Count (Count / 1 sec)                  0\r\n    Number of Active Timers                                        0\r\n    Number of Assemblies Loaded                                   18\r\n    Number of Methods Jitted                                     392\r\n    POH (Pinned Object Heap) Size (B)                         39,976\r\n    ThreadPool Completed Work Item Count (Count / 1 sec)       6,132\r\n    ThreadPool Queue Length                                        0\r\n    ThreadPool Thread Count                                        5\r\n    Time spent in JIT (ms / 1 sec)                                 0\r\n    Working Set (MB)                                              47\r\n\r\n\r\nSynchronous version (top shows cpu usage as around 6%)\r\n[System.Runtime]\r\n    % Time in GC since last GC (%)                                 0\r\n    Allocation Rate (B / 1 sec)                               32,672\r\n    CPU Usage (%)                                                  0\r\n    Exception Count (Count / 1 sec)                                0\r\n    GC Committed Bytes (MB)                                       26\r\n    GC Fragmentation (%)                                           1.105\r\n    GC Heap Size (MB)                                             25\r\n    Gen 0 GC Count (Count / 1 sec)                                 0\r\n    Gen 0 Size (B)                                                24\r\n    Gen 1 GC Count (Count / 1 sec)                                 0\r\n    Gen 1 Size (B)                                         7,806,528\r\n    Gen 2 GC Count (Count / 1 sec)                                 0\r\n    Gen 2 Size (B)                                        12,179,944\r\n    IL Bytes Jitted (B)                                      295,457\r\n    LOH Size (B)                                             287,848\r\n    Monitor Lock Contention Count (Count / 1 sec)                  0\r\n    Number of Active Timers                                        4\r\n    Number of Assemblies Loaded                                  121\r\n    Number of Methods Jitted                                   3,737\r\n    POH (Pinned Object Heap) Size (B)                        195,360\r\n    ThreadPool Completed Work Item Count (Count / 1 sec)           0\r\n    ThreadPool Queue Length                                        0\r\n    ThreadPool Thread Count                                        4\r\n    Time spent in JIT (ms / 1 sec)                                 0\r\n    Working Set (MB)                                             140\r\n\r\nLinux Traces:\r\nI\u0027ve attached 20 second dotnet-trace results from both Synchronous and Asynchronous in Linux.  It appears to me all (or most)of the extra time is spent in LowLevelLifoSemaphore but I\u0027m not sure if that\u0027s expected.\r\n\r\n[Traces.zip](https://github.com/dotnet/core/files/9106253/Traces.zip)\r\n\r\n\r\nVersus Windows (0.1% cpu in async mode, 12700k)\r\n![image](https://user-images.githubusercontent.com/1630971/178843125-d2c47a9f-e7cc-40d7-94b4-0ff6ae614b33.png)\r\n\r\n[TraceAsyncWindows.zip](https://github.com/dotnet/core/files/9106362/TraceAsyncWindows.zip)\r\nOf course the windows trace looks very different as it uses IOCompletion\r\n\r\n\r\nI ran some tests using a similarly spec\u0027d windows 10 hyper-v VM and got pretty lousy numbers.  Both Synchronous and Async used about 50% of the cpu (4 hyper-v cpus on a 5700g) and only got up to about 600mbps.   While it doesn\u0027t invalidate the enormous synchronous vs asynchronous performance discrepancy I observed on linux it may invalidate the windows vs linux argument.  These aren\u0027t heavily loaded hyper-visors so I\u0027m surprised to be honest.  Python3 got 35% cpu usage and 800mbps on the same windows 10 machine.\r\n\r\nUsing a 5700g with windows 11 (not in a hyper-vm) shows similar 0.3%ish cpu usage and full gigabit traffic for .net 6 async and slightly higher cpu usage for python3 (0.4ish) for full gigabit traffic.\r\n\r\nUsing an intel 12400 (non virtualized) rocky linux 8.5 I had 40% cpu usage in async and 1% for synchronous on 100mbit interface and 47% async vs 1% synchronous on a gigabit interface for the same machine.  \r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eandrewaggb\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net`, `area-System.Net.Sockets`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-07-14T15:50:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GqZRX",
                                           "createdAt":  "2022-07-15T12:55:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "\u003e or doing essentially the same thing in python3, nodejs, or netcat in listen mode\r\n\r\nI\u0027d be interested in the results using golang if you have time to test that. Python3 and nodejs are both single threaded.",
                                           "updatedAt":  "2022-07-15T12:55:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GtbqG",
                                           "createdAt":  "2022-07-16T22:44:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOECGKHw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "6opuc",
                                                                               "createdAt":  "2025-01-12T18:38:06Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "andrewaggb",
                                           "body":  "\u003e \u003e or doing essentially the same thing in python3, nodejs, or netcat in listen mode\r\n\u003e \r\n\u003e I\u0027d be interested in the results using golang if you have time to test that. Python3 and nodejs are both single threaded.\r\n\r\nI put a simple golang example together (attached).  I don\u0027t believe it\u0027s equivalent to the c# async/await as it runs a goroutine per connection so it\u0027s probably more akin to synchronous sockets in c# with a thread per client.  I looked a bit for an async go socket example and didn\u0027t find anything mainstream but I might not be searching for the right thing.\r\n\r\nOn the latest stable go version go1.18.4 linux/amd64 on the same ubuntu VM, I observed 14-15% cpu usage for a comparable example to synchronous c# or synchronous python3 (code attached).  Synchronous sockets in c# were ~6-8% cpu, async c# was ~52% cpu, and async c# with  DOTNET_SYSTEM_NET_SOCKETS_INLINE_COMPLETIONS=1 was ~7% cpu.  In all cases I\u0027m using default socket settings (not adjusting buffers, etc).  Looks to me like go uses twice the cpu (with exception of async c# on linux that was much higher) using the default settings.  \r\n\r\n[GoServer.zip](https://github.com/dotnet/runtime/files/9126684/GoServer.zip)\r\n\r\nI know the expectation in c# is to use async/await for I/O operations and on linux the performance appears to be much worse so I personally think it should be prioritized.  Makes me curious what kestrel is doing socket-wise as I see those web benchmarks that appear to run just fine on linux with many simultaneous connections and presumably pretty high throughput as it scales.\r\n\r\n",
                                           "updatedAt":  "2022-07-16T22:44:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GtcFp",
                                           "createdAt":  "2022-07-16T22:52:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "We\u0027d need traces to confirm, but I expect a significant portion of the extra CPU is due to the thread pool looking for work and not finding any, in which case these cycles are basically spare that wouldn\u0027t otherwise be used (by this process). It\u0027d be interesting to change your test around to be one of scale / load, maxing out CPU in all the environments, and then using a different measure of perf to compare, e.g. overall throughput of the system. I\u0027m in no way saying this isn\u0027t an issue we should improve in the future (we want to), but rather that it may not actually be as impactful as the repro suggests.",
                                           "updatedAt":  "2022-07-16T22:52:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GteEs",
                                           "createdAt":  "2022-07-16T23:21:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "andrewaggb",
                                           "body":  "\u003e We\u0027d need traces to confirm, but I expect a significant portion of the extra CPU is due to the thread pool looking for work and not finding any, in which case these cycles are basically spare that wouldn\u0027t otherwise be used (by this process). It\u0027d be interesting to change your test around to be one of scale / load, maxing out CPU in all the environments, and then using a different measure of perf to compare, e.g. overall throughput of the system. I\u0027m in no way saying this isn\u0027t an issue we should improve in the future (we want to), but rather that it may not actually be as impactful as the repro suggests.\r\n\r\nI suspect most people aren\u0027t getting anywhere near 5-8x higher cpu but I have two very different applications (video surveillance processing, ~50 concurrent video feeds in the 0.5-8Mpbs range) and electric motor power monitoring (sort of a network oscilloscope) that show higher cpu than expected.   As many workloads are in VM\u0027s/docker/cloud etc and essentially everything is networked these days I think it could be substantial cpu cycles even if my scenarios are closer to the worst case.\r\n\r\nI\u0027m going to try modifying my applications to use synchronous sockets in the short term and see how things work out as I don\u0027t need massive scalability (thread per client is fine).\r\n\r\nI did attach some traces in my original post if you are interested.",
                                           "updatedAt":  "2022-07-16T23:21:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Gtvto",
                                           "createdAt":  "2022-07-17T04:48:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "andrewaggb",
                                           "body":  "I replaced the async socket receives with synchronous receives and a new thread per client in my video application and updated a few instances to review the difference.\r\n\r\nSummary:\r\n2.7x-6x lower cpu usage for the entire application for the 3 instances I updated.  For me it\u0027s a no brainer to switch over to separate threads plus synchronous sockets.  I\u0027ve been moving over a few hundred systems from an nginx+rtmp proxy to an integrated c# mpegts receiver (rest of the app was c#/mvc/websockets/etc) and noticed much higher cpu usage.  This change brings the cpu usage down to about where I expected it to be.\r\n\r\nI\u0027m not sure if async await on sockets in httpclient, mvc websockets/signalr, npgsql, etc are also affected but I have to think any app using async sockets might be affected to some degree or another.\r\n\r\n~27% cpu to ~10% cpu processing ~80mbps across 72 connections.  Core i5 7500.  Running in docker on Rocky Linux 8.6 (bare metal).\r\n\r\n~30% cpu to ~5% cpu processing ~34mbps across 51 connections.  Core i5-12400.  Running in docker on Rocky Linux 8.5 (bare metal).\r\n\r\n~12% cpu to 4% cpu.  ~12.5mpbs across 12 connections. Running in docker on Ubuntu 20.04 in a VM. 12 connections.  4 virtual cpus.",
                                           "updatedAt":  "2022-07-17T04:48:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5IgDzt",
                                           "createdAt":  "2022-08-16T09:14:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODwmOaw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "huntharo",
                                                                               "createdAt":  "2023-12-31T00:23:51Z"
                                                                           },
                                                                           {
                                                                               "content":  "ROCKET",
                                                                               "user":  "huntharo",
                                                                               "createdAt":  "2023-12-31T00:23:54Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "mostspb",
                                                                               "createdAt":  "2024-09-01T11:21:11Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "chris-stolarz",
                                           "body":  "\u003e We\u0027d need traces to confirm, but I expect a significant portion of the extra CPU is due to the thread pool looking for work and not finding any, in which case these cycles are basically spare that wouldn\u0027t otherwise be used (by this process).\r\n\r\nyou could try to limit CPU spent by threadpool by changing spin limit:\r\n`DOTNET_ThreadPool_UnfairSemaphoreSpinLimit=0` (or some other, lower than default number)\r\n\r\nit drastically improved the CPU usage of our system, but it does have a negative effect on the max throughput",
                                           "updatedAt":  "2022-08-16T09:18:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5IhnFJ",
                                           "createdAt":  "2022-08-16T15:09:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "andrewaggb",
                                           "body":  "\u003e \r\n\r\nThat makes a large difference for me as well.  It doesn\u0027t bring my results down to near synchronous levels but in my example above (running a single thread async receive loop) the one case drops from around 50-60% to 35%ish.  I didn\u0027t observe a decrease in throughput but I\u0027m sure there are cases where it could.  I don\u0027t suppose there\u0027s a way at runtime to scale this based on load?\r\n",
                                           "updatedAt":  "2022-08-16T15:09:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5IhxwM",
                                           "createdAt":  "2022-08-16T15:42:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "chris-stolarz",
                                           "body":  "I dont think there is: https://github.com/dotnet/runtime/blob/080f708e7018f6c0529b6c875a44d84fc4d74419/src/libraries/System.Private.CoreLib/src/System/Threading/PortableThreadPool.WorkerThread.cs#L34\r\nWe are running this setting in production on a couple of our services, only one showed throughput issues - it could be caused by something else",
                                           "updatedAt":  "2022-08-16T15:42:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JMtUo",
                                           "createdAt":  "2022-08-26T05:26:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "cc @kouvel ",
                                           "updatedAt":  "2022-08-26T05:26:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JYpaH",
                                           "createdAt":  "2022-08-30T06:21:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCrWl1g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "davidfowl",
                                                                               "createdAt":  "2022-08-30T06:27:56Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "kouvel",
                                           "body":  "Another option that may work for you on Linux in .NET 6 is `DOTNET_SYSTEM_NET_SOCKETS_INLINE_COMPLETIONS=1`. It bypasses the worker thread pool and processes IO completions on as many threads as the processor count. There are some downsides to using it (for instance it doesn\u0027t handle stalling). On Windows, from .NET 7 IO completions are handled more similarly to Linux and I see similar higher CPU usage because they go through the worker thread pool. The above config can also be used on Windows from .NET 7.\r\n\r\nI agree the worker thread pool should be using less CPU time in these types of cases. There are likely several opportunities for tuning it for using less CPU time in various types of cases, esp. in cases where the worker thread pool is not fully loaded.",
                                           "updatedAt":  "2022-08-30T06:21:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JYpfO",
                                           "createdAt":  "2022-08-30T06:21:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nI\u0027m finding that any form of async tcp or unix socket in c#/.net 6 is using 5-8x the cpu usage compared to using synchronous sockets in c# or doing essentially the same thing in python3, nodejs, or netcat in listen mode.  Async sockets in c# on windows perform fine.  I\u0027ve tried several different forms of async with sockets in c# and they all seem to behave the same.\r\n\r\nIn my test scenario I\u0027m saturating a gigabit ethernet link via netcat because it\u0027s very easy to reproduce.  My production scenario is a video surveillance application receiving many simultaneous hd video feeds.  \r\n\r\nI have experienced this issue in my production application with and without docker, on physical machines and in hyper-v virtual machines, on centos 7.9, rocky 8.6, and ubuntu 20.04.\r\n\r\nMy examples below will all be ubuntu 20.04 with dotnet 6 installed on the host.\r\nHyper-v virtual machine on windows 11 with 4 hyper-v cpus on a ryzen 5600g\r\n\r\nI\u0027m using cpu percentages from the top command and these are all processing the same gigabit traffic (no example here is processing more or less MB/s - they are all a full gigabit link verified with application counters and tools like iftop)\r\n\r\nusing a standard TCP Listener -\u003e NetworkStream with sync reads and a ~1MB buffer\r\n~6-8% cpu usage.  I have no problem with this and as you\u0027ll see below this result is consistent with other tools and programming languages in my test environment.\r\n```\r\n  byte[] buffer = new byte[1048576];\r\n  while ((nBytes **= stream.Read(**buffer, 0, buffer.Length)) \u003e 0)\r\n  {\r\n      totalBytes += nBytes;\r\n  }\r\n```\r\n\r\nusing a standard TCP Listener -\u003e NetworkStream with async reads and a ~1MB buffer.  The only difference is await ReadAsync vs Read\r\n~50-60% cpu usage - **5-8x as much cpu as the synchronous version**. \r\n```\r\n  byte[] buffer = new byte[1048576];\r\n  while((nBytes = **await stream.ReadAsync(**buffer, 0, buffer.Length)) \u003e 0)\r\n  {\r\n      totalBytes += nBytes;\r\n  }\r\n```\r\n\r\nI have also tried socket.BeginReceive with approximately the same 50-60% cpu usage\r\nI have also tried socket.ReceiveAsync with SocketAsyncEventArgs with approximately the same 50-60% cpu usage\r\n\r\nI have tried unix Sockets in c#/.net 6\r\nWith unix sockets the cpu usage for a synchronous read loop is around 6% of cpu (vs 6-8% for tcp sockets).  I piped a netcat receiver into the unix socket to ensure the same amount of data was being processed.\r\n\r\nWith unix sockets the cpu usage for an asynchronous read loop is around 50-60% of cpu (~ the same as async tcp sockets).  I piped a netcat receiver into the unix socket to ensure the same amount of data was being processed.\r\n\r\n\r\n### I ran some comparables\r\nusing netcat as a listener\r\nnc -l 9989 \u003e/dev/null \r\nuses about 8% cpu (same as synchronous sockets in c#)\r\n\r\nusing nodejs and the socket.on data callback\r\nuses about 10% cpu (slightly more than synchronous c# but 5-6x less than async c# and this is async and not re-using a receive buffer so it\u0027s less efficient)\r\n\r\nusing python3 with a synchronous tcp socket receiving into a buffer (very comparable to my c# synchronous example)\r\nuses about 8% cpu (same as synchronous sockets in c#)\r\n\r\nusing golang with a goroutine per connection receiving into a buffer (comparable to my c# synchronous example)\r\nuses about 14% cpu (approximately double synchronous sockets in c#)\r\n\r\nMy basic test methodology is\r\nFrom another machine run netcat to generate a full gigabit/s of ethernet traffic \r\n`cat /dev/zero | nc 192.168.1.93 9989`\r\n\r\nOn the destination machine 192.168.1.93 (the ubuntu 20.04 vm all the tests were run on)\r\n\r\nHigh CPU usage\r\ndotnet run --configuration Release PerfTestTCPListenerAsync\r\n\r\nLow CPU usage\r\ndotnet run --configuration Release PerfTestTCPListener\r\nnc -l 9989 \u003e/dev/null\r\nnodejs jsserver.js\r\npython3 pyserver.py\r\n\r\nI\u0027ve included the most basic c# example Program.cs using the exact same code with a Read vs ReadAsync, a very basic python example pyserver.py and a very basic nodejs example jsserver.js.  All are configured to listen on port 9989 so the same netcat client command can be run against any of the 5 examples.  \r\n\r\nI\u0027ve been monitoring the cpu usage with top and network traffic with iftop.\r\n\r\n[data.zip](https://github.com/dotnet/core/files/9106126/data.zip)\r\n\r\n\r\nAsync version dotnet-counters monitor (I\u0027m note sure if the cpu usage here is quoting all cores but top value shows 52% for this async socket process)\r\n[System.Runtime]\r\n    % Time in GC since last GC (%)                                 0\r\n    Allocation Rate (B / 1 sec)                              244,648\r\n    CPU Usage (%)                                                 16\r\n    Exception Count (Count / 1 sec)                                0\r\n    GC Committed Bytes (MB)                                        9\r\n    GC Fragmentation (%)                                           0.233\r\n    GC Heap Size (MB)                                              6\r\n    Gen 0 GC Count (Count / 1 sec)                                 0\r\n    Gen 0 Size (B)                                                24\r\n    Gen 1 GC Count (Count / 1 sec)                                 0\r\n    Gen 1 Size (B)                                           245,448\r\n    Gen 2 GC Count (Count / 1 sec)                                 0\r\n    Gen 2 Size (B)                                                24\r\n    IL Bytes Jitted (B)                                       48,860\r\n    LOH Size (B)                                           1,048,656\r\n    Monitor Lock Contention Count (Count / 1 sec)                  0\r\n    Number of Active Timers                                        0\r\n    Number of Assemblies Loaded                                   18\r\n    Number of Methods Jitted                                     392\r\n    POH (Pinned Object Heap) Size (B)                         39,976\r\n    ThreadPool Completed Work Item Count (Count / 1 sec)       6,132\r\n    ThreadPool Queue Length                                        0\r\n    ThreadPool Thread Count                                        5\r\n    Time spent in JIT (ms / 1 sec)                                 0\r\n    Working Set (MB)                                              47\r\n\r\n\r\nSynchronous version (top shows cpu usage as around 6%)\r\n[System.Runtime]\r\n    % Time in GC since last GC (%)                                 0\r\n    Allocation Rate (B / 1 sec)                               32,672\r\n    CPU Usage (%)                                                  0\r\n    Exception Count (Count / 1 sec)                                0\r\n    GC Committed Bytes (MB)                                       26\r\n    GC Fragmentation (%)                                           1.105\r\n    GC Heap Size (MB)                                             25\r\n    Gen 0 GC Count (Count / 1 sec)                                 0\r\n    Gen 0 Size (B)                                                24\r\n    Gen 1 GC Count (Count / 1 sec)                                 0\r\n    Gen 1 Size (B)                                         7,806,528\r\n    Gen 2 GC Count (Count / 1 sec)                                 0\r\n    Gen 2 Size (B)                                        12,179,944\r\n    IL Bytes Jitted (B)                                      295,457\r\n    LOH Size (B)                                             287,848\r\n    Monitor Lock Contention Count (Count / 1 sec)                  0\r\n    Number of Active Timers                                        4\r\n    Number of Assemblies Loaded                                  121\r\n    Number of Methods Jitted                                   3,737\r\n    POH (Pinned Object Heap) Size (B)                        195,360\r\n    ThreadPool Completed Work Item Count (Count / 1 sec)           0\r\n    ThreadPool Queue Length                                        0\r\n    ThreadPool Thread Count                                        4\r\n    Time spent in JIT (ms / 1 sec)                                 0\r\n    Working Set (MB)                                             140\r\n\r\nLinux Traces:\r\nI\u0027ve attached 20 second dotnet-trace results from both Synchronous and Asynchronous in Linux.  It appears to me all (or most)of the extra time is spent in LowLevelLifoSemaphore but I\u0027m not sure if that\u0027s expected.\r\n\r\n[Traces.zip](https://github.com/dotnet/core/files/9106253/Traces.zip)\r\n\r\n\r\nVersus Windows (0.1% cpu in async mode, 12700k)\r\n![image](https://user-images.githubusercontent.com/1630971/178843125-d2c47a9f-e7cc-40d7-94b4-0ff6ae614b33.png)\r\n\r\n[TraceAsyncWindows.zip](https://github.com/dotnet/core/files/9106362/TraceAsyncWindows.zip)\r\nOf course the windows trace looks very different as it uses IOCompletion\r\n\r\n\r\nI ran some tests using a similarly spec\u0027d windows 10 hyper-v VM and got pretty lousy numbers.  Both Synchronous and Async used about 50% of the cpu (4 hyper-v cpus on a 5700g) and only got up to about 600mbps.   While it doesn\u0027t invalidate the enormous synchronous vs asynchronous performance discrepancy I observed on linux it may invalidate the windows vs linux argument.  These aren\u0027t heavily loaded hyper-visors so I\u0027m surprised to be honest.  Python3 got 35% cpu usage and 800mbps on the same windows 10 machine.\r\n\r\nUsing a 5700g with windows 11 (not in a hyper-vm) shows similar 0.3%ish cpu usage and full gigabit traffic for .net 6 async and slightly higher cpu usage for python3 (0.4ish) for full gigabit traffic.\r\n\r\nUsing an intel 12400 (non virtualized) rocky linux 8.5 I had 40% cpu usage in async and 1% for synchronous on 100mbit interface and 47% async vs 1% synchronous on a gigabit interface for the same machine.  \r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eandrewaggb\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003eFuture\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-08-30T06:21:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JapMF",
                                           "createdAt":  "2022-08-30T14:08:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "andrewaggb",
                                           "body":  "\u003e \r\n\r\nI tried that earlier in the thread at David Fowlers request.  It reduced cpu usage to nearly synchronous socket levels in my simple example (async read loop) but in my actual application I found it wasn\u0027t usable as-is.  Connections appeared to be stalling or not responding.  My actual application involves web api, fleck websockets and raw sockets of various kinds, etc so it\u0027s signficantly more complex and varied than my basic example that illustrates the cpu usage difference.",
                                           "updatedAt":  "2022-08-30T14:08:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JbBTz",
                                           "createdAt":  "2022-08-30T15:23:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "Ah ok, missed that. What kind of CPU usage difference do you see in the actual application?",
                                           "updatedAt":  "2022-08-30T15:23:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JbLS0",
                                           "createdAt":  "2022-08-30T15:56:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "Found those numbers above. In .NET 7 the thread pool requests fewer threads, it may help to reduce the CPU usage a bit in the actual application. In the test case, .NET 7 combined with `DOTNET_ThreadPool_UnfairSemaphoreSpinLimit=0` still uses ~3x the CPU on my Linux VM, but that\u0027s because there\u0027s only one connection and it\u0027s kind of a worst case for the thread pool where for each IO completion two extra threads spin up unnecessarily and look for work. In the real app the two extra threads spinning up may not contribute as much by comparison.",
                                           "updatedAt":  "2022-08-30T16:18:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JbzA8",
                                           "createdAt":  "2022-08-30T18:36:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "I\u0027m planning to take a look and (hopefully) get it working for 8.0. It seems like the benefits may be interesting. ",
                                           "updatedAt":  "2022-08-30T18:36:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JcfbU",
                                           "createdAt":  "2022-08-30T21:50:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "andrewaggb",
                                           "body":  "\u003e \r\n\r\nI saw about a 3x cpu usage reduction in my actual application (in various hardware configurations) when switching from async receiving sockets to a thread per connection with synchronous receives model.  The application receives video surveillance feeds over a local network (typically 20-60 connections) and almost always totaling less than 100mbps total bandwidth.\r\n\r\nI didn\u0027t try the DOTNET_ThreadPool_UnfairSemaphoreSpinLimit=0 on my actual app but I could deploy a build with async sockets and try it out in the next few days.\r\n",
                                           "updatedAt":  "2022-08-30T21:50:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Lp--D",
                                           "createdAt":  "2022-10-06T04:32:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "@andrewaggb did you ever try it?",
                                           "updatedAt":  "2022-10-06T04:32:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NB1Ra",
                                           "createdAt":  "2022-10-26T16:47:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AachoLoya",
                                           "body":  "Any update on this? Considering using .NET sockets on linux for a high load/throughput application and wondering if its production ready.",
                                           "updatedAt":  "2022-10-26T16:47:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NB2lj",
                                           "createdAt":  "2022-10-26T16:52:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e wondering if its production ready.\r\n\r\nIt is\r\n\r\n\u003efor a high load/throughput application\r\n\r\nThe increased CPU utilization cited in this issue is when not under high load.",
                                           "updatedAt":  "2022-10-26T16:52:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NB3jo",
                                           "createdAt":  "2022-10-26T16:55:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AachoLoya",
                                           "body":  "So its just idle spin-checking of some sort taking up the cpu? \r\n\r\nI saw David Fowler\u0027s twitter post, from a couple of years ago, about looking into io_uring and aio. Are these integrated in .NET 6?",
                                           "updatedAt":  "2022-10-26T16:55:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NB4hq",
                                           "createdAt":  "2022-10-26T16:59:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e So its just idle spin-checking of some sort taking up the cpu?\r\n\r\nEffectively, yes: it\u0027s primarily the thread pool searching for more work to do when it hasn\u0027t found any.\r\n\r\n\u003e Are these integrated in .NET 6?\r\n\r\nNo.",
                                           "updatedAt":  "2022-10-26T16:59:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NB5Ej",
                                           "createdAt":  "2022-10-26T17:00:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AachoLoya",
                                           "body":  "What\u0027s the current plan for integrating aio or io_uring? Sorry to ask here, but I googled a lot and other than a few open issues on github there isn\u0027t anything definitive out there.",
                                           "updatedAt":  "2022-10-26T17:00:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NB63v",
                                           "createdAt":  "2022-10-26T17:07:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e What\u0027s the current plan for integrating aio or io_uring?\r\n\r\nThere\u0027s no \"plan\" currently; we experimented with doing so in the .NET 5.0 time-frame, and there were both challenges with adapting io_uring at that time to the multithreaded nature of .NET and also limited benefits seen to using it at that time. https://github.com/dotnet/runtime/issues/753 is still open and tracks experimenting with it again in the future.",
                                           "updatedAt":  "2022-10-26T17:07:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5gf6HK",
                                           "createdAt":  "2023-07-03T18:22:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "Can this issue be closed? Doesnt look like there is anything actionable here? ",
                                           "updatedAt":  "2023-07-03T18:22:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5gf_3-",
                                           "createdAt":  "2023-07-03T18:47:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "There are several options @mangod9. One obvious is to get DOTNET_SYSTEM_NET_SOCKETS_INLINE_COMPLETIONS into useable state - but that will probably not happen for 8.0 because of priorities and rescue constrains. ",
                                           "updatedAt":  "2023-07-03T18:47:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ggMQV",
                                           "createdAt":  "2023-07-03T19:34:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "Ok, moving out of 8 for now then. Thx!",
                                           "updatedAt":  "2023-07-03T19:34:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6aIWqA",
                                           "createdAt":  "2025-01-12T19:04:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEgh6gw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "huntharo",
                                                                               "createdAt":  "2025-01-12T23:09:38Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "dimonkov",
                                                                               "createdAt":  "2025-01-13T06:29:01Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "josephnhtam",
                                                                               "createdAt":  "2025-01-13T16:47:05Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AndreyPolovodov",
                                                                               "createdAt":  "2025-05-11T09:58:03Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jmbryan4",
                                                                               "createdAt":  "2025-09-02T15:59:00Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  5
                                                         },
                                           "author":  "6opuc",
                                           "body":  "The issue still reproduces in .net 9. Could you please prioritize?\nComparing to dotnet8, it dropped from 18% CPU to 12% CPU, but still much higher than 2-3% with `DOTNET_SYSTEM_NET_SOCKETS_INLINE_COMPLETIONS=1`",
                                           "updatedAt":  "2025-01-12T19:04:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6aQvQB",
                                           "createdAt":  "2025-01-13T20:02:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "do you have test that can demonstrate it @6opuc ? I know this drags for long time  but it is .... tricky. If anything we should do it early in the release so we have time to spot regressions.",
                                           "updatedAt":  "2025-01-13T20:02:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6aQ0sH",
                                           "createdAt":  "2025-01-13T20:13:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "6opuc",
                                           "body":  "the same test from original description reproduces the problem. I\u0027m more interested in client socket scenario, here is modified version of the test:\n```\nusing System;\nusing System.Diagnostics;\nusing System.Net;\nusing System.Net.Sockets;\n\nnamespace ClientSocketTest\n{\n    public class SocketTest\n    {\n        public static async Task\u003cint\u003e Main(String[] args)\n        {\n            if (args.Any(y =\u003e y == \"Async\" || y == \"1\"))\n            {\n                await PerfTestAsync();\n            }\n            else if (args.Any(y =\u003e y == \"Sync\" || y == \"2\"))\n            {\n                PerfTestSync();\n            }\n            else if (args.Any(y =\u003e y == \"StreamAsync\" || y == \"3\"))\n            {\n                await PerfTestStreamAsync();\n            }\n            else\n            {\n                Console.WriteLine(\"Usage:\");\n                Console.WriteLine(\"./ClientSocketTest StreamAsync\");\n                Console.WriteLine(\"./ClientSocketTest Async\");\n                Console.WriteLine(\"./ClientSocketTest Sync\");\n            }\n            return 0;\n        }\n        private static void PerfTestSync()\n        {\n            var endpoint = new IPEndPoint(IPAddress.Parse(\"127.0.0.1\"), 9989);\n            var socket = new Socket(endpoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n            byte[] buffer = new byte[1048576];\n            socket.ReceiveBufferSize = buffer.Length;\n            socket.SendBufferSize = buffer.Length;\n            socket.Connect(endpoint);\n            \n            Console.WriteLine($\"Connected to {endpoint}\");\n            Stopwatch stp = Stopwatch.StartNew();           \n            \n            long totalBytes = 0;\n            using (var stream = new NetworkStream(socket))\n            {\n                int nBytes;\n                while((nBytes = stream.Read(buffer, 0, buffer.Length)) \u003e 0)\n                {\n                    totalBytes += nBytes;\n                }\n            }\n            stp.Stop();\n            Console.WriteLine($\"Read {(totalBytes / 1048576.0)} MBs in {Math.Round(stp.Elapsed.TotalSeconds, 1)}, {Math.Round(((totalBytes / 1048576.0) / stp.Elapsed.TotalSeconds), 1)} MB/s\");\n        }\n\n              \n        private static async Task PerfTestStreamAsync()\n        {\n            var endpoint = new IPEndPoint(IPAddress.Parse(\"127.0.0.1\"), 9989);\n            var socket = new Socket(endpoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n            byte[] buffer = new byte[1048576];\n            socket.ReceiveBufferSize = buffer.Length;\n            socket.SendBufferSize = buffer.Length;\n            await socket.ConnectAsync(endpoint);\n            \n            Console.WriteLine($\"Connected to {endpoint}\");\n            Stopwatch stp = Stopwatch.StartNew();           \n            \n            long totalBytes = 0;\n            using (var stream = new NetworkStream(socket))\n            {\n                int nBytes;\n                while((nBytes = await stream.ReadAsync(buffer, 0, buffer.Length)) \u003e 0)\n                {\n                    totalBytes += nBytes;\n                }\n            }\n            stp.Stop();\n            Console.WriteLine($\"Read {(totalBytes / 1048576.0)} MBs in {Math.Round(stp.Elapsed.TotalSeconds, 1)}, {Math.Round(((totalBytes / 1048576.0) / stp.Elapsed.TotalSeconds), 1)} MB/s\");\n        }\n        \n        private static async Task PerfTestAsync()\n        {\n            var endpoint = new IPEndPoint(IPAddress.Parse(\"127.0.0.1\"), 9989);\n            var socket = new Socket(endpoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n            byte[] buffer = new byte[1048576];\n            socket.ReceiveBufferSize = buffer.Length;\n            socket.SendBufferSize = buffer.Length;\n            await socket.ConnectAsync(endpoint);\n            \n            Console.WriteLine($\"Connected to {endpoint}\");\n            Stopwatch stp = Stopwatch.StartNew();           \n            \n            long totalBytes = 0;\n            \n                int nBytes;\n                while((nBytes = await socket.ReceiveAsync(buffer)) \u003e 0)\n                {\n                    totalBytes += nBytes;\n                }\n            \n            stp.Stop();\n            Console.WriteLine($\"Read {(totalBytes / 1048576.0)} MBs in {Math.Round(stp.Elapsed.TotalSeconds, 1)}, {Math.Round(((totalBytes / 1048576.0) / stp.Elapsed.TotalSeconds), 1)} MB/s\");\n        }\n    }\n}\n```\n\nand test socket server:\n```\nnc -l 0.0.0.0 9989 -v -c \"cat /dev/zero\"\n```",
                                           "updatedAt":  "2025-01-13T20:15:21Z"
                                       }
                                   ],
                         "totalCount":  36
                     },
        "title":  "async sockets in linux (windows is fine) use 5-8x expected cpu vs synchronous sockets or comparables in other languages",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/73099",
        "createdAt":  "2022-07-30T03:17:38Z",
        "number":  73099,
        "author":  "lostmsu",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODE3Ihw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "janseris",
                                            "createdAt":  "2023-01-10T22:07:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Tan90909090",
                                            "createdAt":  "2023-01-20T12:33:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "0xced",
                                            "createdAt":  "2024-09-09T13:20:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2025-06-26T13:12:44Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2022-07-30T17:00:02Z",
        "body":  "### Description\n\nWhen I tried to switch to `async Task Main` from `void Main` in a WPF app, I got\r\n\r\n\u003e System.InvalidOperationException: \u0027The calling thread must be STA, because many UI components require this.\u0027\r\n\r\nMy `async Task Main` method has `[STAThread]` attribute, but I can see in the debugger, that `ApartmentState` is MTA, which causes the above exception.\n\n### Reproduction Steps\n\n```csharp\r\n[STAThread]\r\nstatic async Task\u003cint\u003e Main() {\r\n  Console.WriteLine(Thread.CurrentThread.ApartmentState);\r\n}\r\n```\n\n### Expected behavior\n\n\"STA\" should be printed\n\n### Actual behavior\n\n\"MTA\" is printed\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nI needed STA for WPF, and got it by creating a secondary thread to run WPF App `Main` function:\r\n\r\n```csharp\r\nvar thread = new Thread(SaveApp.Main) {\r\n    Name = \"UI\",\r\n};\r\nthread.SetApartmentState(ApartmentState.STA);\r\nthread.Start();\r\nthread.Join();\r\n```\n\n### Configuration\n\n.NET 6\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOR4pgxQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5Hh7j7",
                                           "createdAt":  "2022-07-30T03:17:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nWhen I tried to switch to `async Task Main` from `void Main` in a WPF app, I got\r\n\r\n\u003e System.InvalidOperationException: \u0027The calling thread must be STA, because many UI components require this.\u0027\r\n\r\nMy `async Task Main` method has `[STAThread]` attribute, but I can see in the debugger, that `ApartmentState` is MTA, which causes the above exception.\n\n### Reproduction Steps\n\n```csharp\r\n[STAThread]\r\nstatic async Task\u003cint\u003e Main() {\r\n  Console.WriteLine(Thread.CurrentThread.ApartmentState);\r\n}\r\n```\n\n### Expected behavior\n\n\"STA\" should be printed\n\n### Actual behavior\n\n\"MTA\" is printed\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nI needed STA for WPF, and got it by creating a secondary thread to run WPF App `Main` function:\r\n\r\n```csharp\r\nvar thread = new Thread(SaveApp.Main) {\r\n    Name = \"UI\",\r\n};\r\nthread.SetApartmentState(ApartmentState.STA);\r\nthread.Start();\r\nthread.Join();\r\n```\n\n### Configuration\n\n.NET 6\n\n### Other information\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003elostmsu\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-07-30T03:17:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Hh8cy",
                                           "createdAt":  "2022-07-30T03:44:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "As discussed in https://github.com/dotnet/csharplang/issues/97, this is expected behavior. \r\n\r\nAsync Main does not really work well for STAThread anyway. You are guaranteed to be on the STAThread only until the first await. So it is best to not use async Main for UI apps that need to run on STAThread.\r\n\r\n\u003e Known Workarounds\r\n\u003e I needed STA for WPF, and got it by creating a secondary thread to run WPF App Main function:\r\n\r\nIt is cheaper to reset the apartment state on the current thread.\r\n\r\nThread.CurrentThread.SetApartmentState(ApartmentState.Unknown);\r\nThread.CurrentThread.SetApartmentState(ApartmentState.STA);",
                                           "updatedAt":  "2022-07-30T03:45:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HimDF",
                                           "createdAt":  "2022-07-30T16:52:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lostmsu",
                                           "body":  "\u003e Async Main does not really work well for STAThread anyway. You are guaranteed to be on the STAThread only until the first await. \r\n\r\nI understood that. My exact scenario is a GUI app, that can be called with command line arguments to perform utility actions (call self with elevated privileges to perform admin tasks). With no arguments app goes straight to `WpfApp.Main` so the startup thread is used, but with arguments WPF (which requires STA) is never touched, instead it performs commands that have async implementations.\r\n\r\n\u003e It is cheaper to reset the apartment state on the current thread.\r\n\r\nThat may be, but the official documentation for [`SetApartmentState`](https://docs.microsoft.com/en-us/dotnet/api/system.threading.thread.setapartmentstate) says\r\n\r\n\u003e Sets the apartment state of a thread **_before_** it is started.",
                                           "updatedAt":  "2022-07-30T17:00:02Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "`[STAThread]` attribute is ignored when `Main` is asynchronous",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/73231",
        "createdAt":  "2022-08-02T13:47:39Z",
        "number":  73231,
        "author":  "Kahbazi",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-08-03T18:25:02Z",
        "body":  "### Background and motivation\n\n[`RateLimitPartition.Factory`](https://github.com/dotnet/runtime/blob/f3483388f770602373cbf031ffbce108784bcf4a/src/libraries/System.Threading.RateLimiting/src/System/Threading/RateLimiting/RateLimitPartition.T.cs#L31) is used to create the `RateLimiter` for a specific partition. At the moment only partition key is available in the creation but what if the type of the limiter or the values of the limiter is depend on the `TResource` itself? I suggest to add  `TResource` in RateLimitPartition.Factory.\r\n\r\ncc/ @BrennanConroy @halter73 @wtgodbe \n\n### API Proposal\n\n```diff\r\nnamespace System.Threading.RateLimiting;\r\n\r\n- public struct RateLimitPartition\u003cTKey\u003e\r\n+ public struct RateLimitPartition\u003cTResource, TKey\u003e\r\n{\r\n-    public Func\u003cTKey, RateLimiter\u003e Factory { get; }\r\n+    public Func\u003cTResource, TKey, RateLimiter\u003e Factory { get; }\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nPartitionedRateLimiter.Create\u003cHttpContext, string\u003e(context =\u003e\r\n{\r\n    var name = context.GetEndpoint().DisplayName;\r\n\r\n    return RateLimitPartition.CreateSlidingWindowLimiter\u003cstring\u003e(name, (httpContext, key) =\u003e\r\n    {\r\n        var metadata = httpContext.GetEndpoint().Metadata.GetMetadata\u003cIRateLimit\u003e();\r\n        return new SlidingWindowRateLimiterOptions(\r\n            permitLimit: metadata.permitLimit,\r\n            queueProcessingOrder: metadata.QueueProcessingOrder,\r\n            queueLimit: metadata.queueLimit,\r\n            window: metadata.window,\r\n            segmentsPerWindow: metadata.segmentsPerWindow);\r\n    });\r\n});\r\n```\r\n\n\n### Alternative Designs\n\nThis could be achieved now, but it would introduce an allocation because of the closure. \r\n```csharp\r\nPartitionedRateLimiter.Create\u003cHttpContext, string\u003e(context =\u003e\r\n{\r\n    var name = context.GetEndpoint().DisplayName;\r\n\r\n    return RateLimitPartition.CreateSlidingWindowLimiter\u003cstring\u003e(name, key =\u003e\r\n    {\r\n        var metadata = context.GetEndpoint().Metadata.GetMetadata\u003cIRateLimit\u003e();\r\n        return new SlidingWindowRateLimiterOptions(\r\n            permitLimit: metadata.permitLimit,\r\n            queueProcessingOrder: metadata.QueueProcessingOrder,\r\n            queueLimit: metadata.queueLimit,\r\n            window: metadata.window,\r\n            segmentsPerWindow: metadata.segmentsPerWindow);\r\n    });\r\n});\r\n```\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOR7hFrA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5HrlIu",
                                           "createdAt":  "2022-08-02T13:47:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-08-02T13:47:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HsjO5",
                                           "createdAt":  "2022-08-02T15:43:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\n[`RateLimitPartition.Factory`](https://github.com/dotnet/runtime/blob/f3483388f770602373cbf031ffbce108784bcf4a/src/libraries/System.Threading.RateLimiting/src/System/Threading/RateLimiting/RateLimitPartition.T.cs#L31) is used to create the `RateLimiter` for a specific partition. At the moment only partition key is available in the creation but what if the type of the limiter or the values of the limiter is depend on the `TResource` itself? I suggest to add  `TResource` in RateLimitPartition.Factory.\r\n\r\ncc/ @BrennanConroy @halter73 @wtgodbe \n\n### API Proposal\n\n```diff\r\nnamespace System.Threading.RateLimiting;\r\n\r\n- public struct RateLimitPartition\u003cTKey\u003e\r\n+ public struct RateLimitPartition\u003cTResource, TKey\u003e\r\n{\r\n-    public Func\u003cTKey, RateLimiter\u003e Factory { get; }\r\n+    public Func\u003cTResource, TKey, RateLimiter\u003e Factory { get; }\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nPartitionedRateLimiter.Create\u003cHttpContext, string\u003e(context =\u003e\r\n{\r\n    var name = context.GetEndpoint().DisplayName;\r\n\r\n    return RateLimitPartition.CreateSlidingWindowLimiter\u003cstring\u003e(name, (httpContext, key) =\u003e\r\n    {\r\n        var metadata = httpContext.GetEndpoint().Metadata.GetMetadata\u003cIRateLimit\u003e();\r\n        return new SlidingWindowRateLimiterOptions(\r\n            permitLimit: metadata.permitLimit,\r\n            queueProcessingOrder: metadata.QueueProcessingOrder,\r\n            queueLimit: metadata.queueLimit,\r\n            window: metadata.window,\r\n            segmentsPerWindow: metadata.segmentsPerWindow);\r\n    });\r\n});\r\n```\r\n\n\n### Alternative Designs\n\nThis could be achieved now, but it would introduce an allocation because of the closure. \r\n```csharp\r\nPartitionedRateLimiter.Create\u003cHttpContext, string\u003e(context =\u003e\r\n{\r\n    var name = context.GetEndpoint().DisplayName;\r\n\r\n    return RateLimitPartition.CreateSlidingWindowLimiter\u003cstring\u003e(name, key =\u003e\r\n    {\r\n        var metadata = context.GetEndpoint().Metadata.GetMetadata\u003cIRateLimit\u003e();\r\n        return new SlidingWindowRateLimiterOptions(\r\n            permitLimit: metadata.permitLimit,\r\n            queueProcessingOrder: metadata.QueueProcessingOrder,\r\n            queueLimit: metadata.queueLimit,\r\n            window: metadata.window,\r\n            segmentsPerWindow: metadata.segmentsPerWindow);\r\n    });\r\n});\r\n```\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eKahbazi\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-08-02T15:43:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Hs9iV",
                                           "createdAt":  "2022-08-02T16:38:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "BrennanConroy",
                                           "body":  "My issue with this is that once the `key` has been created, the `Factory` will only be called once (not entirely true, but for the purposes of this discussion we\u0027ll assume once). But the factory here changes behavior based on the resource passed in, which would only apply on the first resource for that specific key. And because the factory is called once per key (which hopefully applies to multiple resources/requests), the allocations aren\u0027t a big concern anymore (amortizes to 0 given enough requests).\r\n\r\nThis may be intended behavior if you fully understand how the system works, but I think it starts blurring the lines and most people will not realize the behavior of the factory. We\u0027ve already tried renaming the `RateLimitPartition.Get` methods from `RateLimitPartition.Create` to try making it a little more obvious that it\u0027s not creating a limiter every time. So we already realize this API can be confusing.\r\n\r\nI think a better approach would be to make your `IRateLimit` contain a `RateLimitPartition\u003cTKey\u003e`/`TKey` pair so that you can construct the partition per resource.\r\n\r\n```c#\r\nPartitionedRateLimiter.Create\u003cHttpContext, string\u003e(context =\u003e\r\n{\r\n    var displayName = context.GetEndpoint().DisplayName;\r\n\r\n    var metadata = context.GetEndpoint().Metadata.GetMetadata\u003cIRateLimit\u003e();\r\n    return RateLimitPartition.CreateX(metadata.Key /* or displayName */, metadata.Factory);\r\n    // or\r\n    // return metadata.Partition;\r\n});\r\n```\r\n\r\nThis also has the advantage of not hardcoding the rate limit type to `SlidingWindowRateLimiter` in the `PartitionedRateLimiter`, which the previous example of `IRateLimit` usage did. If that\u0027s intended, then maybe there should be an interface per limiter type like `ISlidingWindowRateLimit`, otherwise the `IRateLimit` interface may need to have a bunch of extra properties on it to support all limiter types.\r\n\r\n-----\r\n\r\nHaving said all that, I am willing to be convinced otherwise if we think we can reduce the confusion somehow.\r\n\r\nOne last idea for how to avoid the closure if you really want the resource inside the factory is to create a custom key type which contains the resource.\r\n```c#\r\nstruct CustomKey\r\n{\r\n    public string Key { get; set; }\r\n    public HttpContext Context { get; set; }\r\n}\r\n\r\nvar customKey = new CustomKey(name, resource);\r\nreturn RateLimitPartition.CreateSlidingWindowLimiter\u003cCustomKey\u003e(customKey, static (key) =\u003e\r\n{\r\n    var metadata = key.Context.GetEndpoint().Metadata.GetMetadata\u003cIRateLimit\u003e();\r\n    var options = new SlidingWindowRateLimiterOptions(\r\n        permitLimit: metadata.permitLimit,\r\n        queueProcessingOrder: metadata.QueueProcessingOrder,\r\n        queueLimit: metadata.queueLimit,\r\n        window: metadata.window,\r\n        segmentsPerWindow: metadata.segmentsPerWindow);\r\n    key.Context = null; // don\u0027t want to hold onto the HttpContext\r\n    return options;\r\n});\r\n```",
                                           "updatedAt":  "2022-08-02T16:38:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HtLFd",
                                           "createdAt":  "2022-08-02T17:35:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Kahbazi",
                                           "body":  "\u003e But the factory here changes behavior based on the resource passed in, which would only apply on the first resource for that specific key.\r\n\r\nYeah I\u0027m aware of that. I would have to guarantee that for each specific resource key, factory have the same behavior.\r\n\r\n\u003e I think a better approach would be to make your IRateLimit contain a RateLimitPartition\u003cTKey\u003e/TKey pair so that you can construct the partition per resource.\r\n\r\nThis would work for hard-coded config, but I was thinking to have `HttpContext.RequestedService` and get the options from database or some configuration. This way I could have dynamic options. I know it won\u0027t affect immediately. \r\n\r\n...Unless, there will be a `RemoveAllRateLimiter` method. 🤔  😅 \r\n\r\n\u003e One last idea for how to avoid the closure if you really want the resource inside the factory is to create a custom key type which contains the resource.\r\n\r\nI have thought of a custom key and it would work for scenarios in application code. But it\u0027s not applicable for rate limiting middleware since the key in there is `HttpContext` and can\u0027t be changed. \r\n\r\n\u003e Having said all that, I am willing to be convinced otherwise if we think we can reduce the confusion somehow.\r\n\r\nYeah these APIs are really hard to follow as it is. I did spend a lot to understand them. I think in conclusion the point of this API change is to reduce closure allocation. Nothing blocks me to do what I want with some extra allocation.",
                                           "updatedAt":  "2022-08-02T17:35:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HuEWs",
                                           "createdAt":  "2022-08-02T22:04:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCqAQoA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Kahbazi",
                                                                               "createdAt":  "2022-08-04T08:08:43Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "BrennanConroy",
                                           "body":  "\u003e But it\u0027s not applicable for rate limiting middleware since the key in there is `HttpContext` and can\u0027t be changed.\r\n\r\nThe key is chosen by the user:\r\n```csharp\r\nbuilder.Services.AddRateLimiter(options =\u003e\r\n{\r\n    options.GlobalLimiter = PartitionedRateLimiter.Create\u003cHttpContext, CustomKey\u003e(context =\u003e\r\n    {\r\n        var customKey = new CustomKey(name, resource);\r\n        return RateLimitPartition.CreateSlidingWindowLimiter\u003cCustomKey\u003e(customKey, static (key) =\u003e\r\n        {\r\n            // ...\r\n        });\r\n    });\r\n});\r\n```\r\n",
                                           "updatedAt":  "2022-08-02T22:04:17Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "[API Proposal]: Add TResource in RateLimitPartition.Factory",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/73513",
        "createdAt":  "2022-08-06T08:55:08Z",
        "number":  73513,
        "author":  "Kahbazi",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-08-08T16:47:09Z",
        "body":  "### Background and motivation\n\nLet\u0027s say we want to chain multiple limiter together. Limiters based on IP, Username and Endpoint. Now if I want to skip limiters for some IPs, I could call `GetNoLimiter()` for them but the chain will continue and those requests could be limited based on username or endpoints.\r\n\r\nI suggest to add an overload for `GetNoLimiter(bool skipChain)`. This limiter could return a leases with certain metadata and `ChainedPartitionedRateLimiter` could skip the chain if the metadata exists.\r\n\r\ncc/ @BrennanConroy @halter73 \n\n### API Proposal\n\n```diff\r\nnamespace System.Threading.RateLimiting;\r\n\r\npublic static class RateLimitPartition\r\n{\r\n+    public static RateLimitPartition\u003cTKey\u003e GetNoLimiter\u003cTKey\u003e(TKey partitionKey, bool skipChain)\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nvar limiter1 = PartitionedRateLimiter.Create\u003cstring, int\u003e(resource =\u003e\r\n{\r\n    if ( _resourceWithNoRateLimit.Contains(resource)\r\n    {\r\n        return RateLimitPartition.GetNoLimiter(resource, skipChain: true);\r\n    }\r\n    else\r\n    {\r\n        return RateLimitPartition.GetConcurrencyLimiter(1, _ =\u003e new ConcurrencyLimiterOptions { ... });\r\n    }\r\n});\r\n\r\nvar limiter2 = PartitionedRateLimiter.Create\u003cstring, int\u003e(resource =\u003e\r\n{\r\n    return RateLimitPartition.GetConcurrencyLimiter(resource, _ =\u003e new ConcurrencyLimiterOptions { ... });\r\n});\r\n\r\nvar chainedLimiter = PartitionedRateLimiter.CreateChained\u003cstring\u003e(limiter1, limiter2);\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOR_Rptg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5H9BHN",
                                           "createdAt":  "2022-08-06T08:55:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-08-06T08:55:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5H9Gm2",
                                           "createdAt":  "2022-08-06T11:44:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nLet\u0027s say we want to chain multiple limiter together. Limiters based on IP, Username and Endpoint. Now if I want to skip limiters for some IPs, I could call `GetNoLimiter()` for them but the chain will continue and those requests could be limited based on username or endpoints.\r\n\r\nI suggest to add an overload for `GetNoLimiter(bool skipChain)`. This limiter could return a leases with certain metadata and `ChainedPartitionedRateLimiter` could skip the chain if the metadata exists.\r\n\r\ncc/ @BrennanConroy @halter73 \n\n### API Proposal\n\n```diff\r\nnamespace System.Threading.RateLimiting;\r\n\r\npublic static class RateLimitPartition\r\n{\r\n+    public static RateLimitPartition\u003cTKey\u003e GetNoLimiter\u003cTKey\u003e(TKey partitionKey, bool skipChain)\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nvar limiter1 = PartitionedRateLimiter.Create\u003cstring, int\u003e(resource =\u003e\r\n{\r\n    if ( _resourceWithNoRateLimit.Contains(resource)\r\n    {\r\n        return RateLimitPartition.GetNoLimiter(resource, skipChain: true);\r\n    }\r\n    else\r\n    {\r\n        return RateLimitPartition.GetConcurrencyLimiter(1, _ =\u003e new ConcurrencyLimiterOptions { ... });\r\n    }\r\n});\r\n\r\nvar limiter2 = PartitionedRateLimiter.Create\u003cstring, int\u003e(resource =\u003e\r\n{\r\n    return RateLimitPartition.GetConcurrencyLimiter(resource, _ =\u003e new ConcurrencyLimiterOptions { ... });\r\n});\r\n\r\nvar chainedLimiter = PartitionedRateLimiter.CreateChained\u003cstring\u003e(limiter1, limiter2);\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eKahbazi\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-08-06T11:44:38Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[API Proposal]: Be able to skip the Chain in ChainedPartitionedRateLimiter",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/74827",
        "createdAt":  "2022-08-30T17:14:44Z",
        "number":  74827,
        "author":  "dewanymca",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-09-15T17:24:36Z",
        "body":  "Description: we have been running a monolith application built on .NET CORE 3.1 as linux container on Azure Kubernetes services. We have been experiencing performance issue due to thread starvation and we have used THREADPOOL.SETMINTHREAD to 150. With this setting our performance issue got mitigated at large. However, sometime we see spike in latency which last for 15-20 minute and impact 2-3k request on a single pod. During this time, number of thread count drops from 120 to 10 and stays there at 10 and after 20 minute, everything gets recovered.\r\n\r\nWe need help on this to look why thread count drop that much. Refer below example from Application Insights:\r\n\r\n\r\n\u003cimg width=\"719\" alt=\"image\" src=\"https://user-images.githubusercontent.com/15336470/187500186-07fc73f5-1f4f-4bab-8f0d-b91d308de666.png\"\u003e\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOSmkAFA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5Jbfqn",
                                           "createdAt":  "2022-08-30T17:14:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-08-30T17:14:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JbmI4",
                                           "createdAt":  "2022-08-30T17:41:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nDescription: we have been running a monolith application built on .NET CORE 3.1 as linux container on Azure Kubernetes services. We have been experiencing performance issue due to thread starvation and we have used THREADPOOL.SETMINTHREAD to 150. With this setting our performance issue got mitigated at large. However, sometime we see spike in latency which last for 15-20 minute and impact 2-3k request on a single pod. During this time, number of thread count drops from 120 to 10 and stays there at 10 and after 20 minute, everything gets recovered.\r\n\r\nWe need help on this to look why thread count drop that much. Refer below example from Application Insights:\r\n\r\n\r\n\u003cimg width=\"719\" alt=\"image\" src=\"https://user-images.githubusercontent.com/15336470/187500186-07fc73f5-1f4f-4bab-8f0d-b91d308de666.png\"\u003e\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003edewanymca\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `tenet-performance`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-08-30T17:41:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JbmRG",
                                           "createdAt":  "2022-08-30T17:42:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "As an aside, in case you\u0027re not aware, 3.1 is in its last months of support. Do you plan to move to 6.0? It would be interesting to know whether you see the same symptoms there.",
                                           "updatedAt":  "2022-08-30T17:42:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Jb1XZ",
                                           "createdAt":  "2022-08-30T18:45:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCrZoxQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "danmoseley",
                                                                               "createdAt":  "2022-08-30T19:25:03Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "dewanymca",
                                           "body":  "@danmoseley - we are aware of this but will not be able to complete this upgrade sooner. ",
                                           "updatedAt":  "2022-08-30T18:45:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JqPs2",
                                           "createdAt":  "2022-09-02T18:54:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "@kouvel in case there is some guidance we can provide around this. ",
                                           "updatedAt":  "2022-09-02T18:54:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JrKX6",
                                           "createdAt":  "2022-09-03T05:18:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dewanymca",
                                           "body":  "Another example of similar pattern happened 2 hour ago:\r\n\u003cimg width=\"714\" alt=\"image\" src=\"https://user-images.githubusercontent.com/15336470/188256966-4e88e77d-c168-4aaf-925e-5d8a684eda8b.png\"\u003e\r\n",
                                           "updatedAt":  "2022-09-03T05:18:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5J9IU-",
                                           "createdAt":  "2022-09-08T14:02:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dewanymca",
                                           "body":  "Any pointer on this will be helpful @kouvel/ @mangod9 ",
                                           "updatedAt":  "2022-09-08T14:02:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5J9tGe",
                                           "createdAt":  "2022-09-08T15:57:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "It might be helpful if you have a way to at least test on .NET 6 - if you don’t see it there that might suggest what the cause might be.",
                                           "updatedAt":  "2022-09-08T15:57:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KEr8v",
                                           "createdAt":  "2022-09-10T14:32:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dewanymca",
                                           "body":  "Thanks @danmoseley , we are working on migration path however will take some time before roll out , in interim I need to support this in production.",
                                           "updatedAt":  "2022-09-10T14:32:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KM5H0",
                                           "createdAt":  "2022-09-13T04:49:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "Thread pool worker threads exit after ~20 s if there is no work for them to do. They would be recreated again if needed. Worker threads are created quickly as needed up to the configured minimum. Also the thread pool thread count seems to go above 150 several times, perhaps starvation is still showing up.\r\n\r\nHave you tried higher values for the minimum worker thread count? Is something blocking thread pool threads for long durations?\r\n\r\nIn the first graph, is the blue line (the one with the spike) the thread pool queue length? It seems to correspond with the thread count increasing, otherwise it\u0027s fairly stable around zero. It seems like there was a burst of work, but it\u0027s a bit odd that the thread count increased slowly to around 150 instead of immediately. Was the first graph taken after the min worker thread count was increased to 150?\r\n\r\nHow do latency spikes correspond with the thread pool thread count dropping? Do you see latency spikes while the thread count remains low during the trough, or does the latency spike correspond with the thread count increasing?\r\n\r\nI\u0027d suggest collecting a perf profile with events using [`dotnet-trace`](https://docs.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-trace) and try to catch the drop and eventual increase in thread pool thread count in the trace. The [`ThreadPoolWorkerThreadAdjustment/Adjustment`](https://docs.microsoft.com/en-us/dotnet/framework/performance/thread-pool-etw-events#threadpoolworkerthreadadjustmentadjustment) event may provide more info on why the thread pool thread count is changing, and whether starvation is still occurring.",
                                           "updatedAt":  "2022-09-13T04:49:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KNh4V",
                                           "createdAt":  "2022-09-13T08:17:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dewanymca",
                                           "body":  "\u003e Thread pool worker threads exit after ~20 s if there is no work for them to do. They would be recreated again if needed. Worker threads are created quickly as needed up to the configured minimum. Also the thread pool thread count seems to go above 150 several times, perhaps starvation is still showing up.\r\n\u003e \r\n\u003e Have you tried higher values for the minimum worker thread count? Is something blocking thread pool threads for long durations?\r\n**\u003eNo I didn\u0027t try higher value, as I was not sure whether increasing further will have any consequences.**\r\n\u003e In the first graph, is the blue line (the one with the spike) the thread pool queue length? It seems to correspond with the thread count increasing, otherwise it\u0027s fairly stable around zero. It seems like there was a burst of work, but it\u0027s a bit odd that the thread count increased slowly to around 150 instead of immediately. Was the first graph taken after the min worker thread count was increased to 150?\r\n**Min Thread was set 150 way before this condition occurred. There was not a burst of request or drop happened during this time. It was normal traffic in range and when it dropped latency spiked in minute for all request being processed via this pod in AKS**\r\n\u003e \r\n\u003e How do latency spikes correspond with the thread pool thread count dropping? Do you see latency spikes while the thread count remains low during the trough, or does the latency spike correspond with the thread count increasing?\r\n**\u003e Latency was there during the trough only otherwise system was working within accepted range.**\r\n\u003e I\u0027d suggest collecting a perf profile with events using [`dotnet-trace`](https://docs.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-trace) and try to catch the drop and eventual increase in thread pool thread count in the trace. The [`ThreadPoolWorkerThreadAdjustment/Adjustment`](https://docs.microsoft.com/en-us/dotnet/framework/performance/thread-pool-etw-events#threadpoolworkerthreadadjustmentadjustment) event may provide more info on why the thread pool thread count is changing, and whether starvation is still occurring.\r\n**Problem is there is no definitive way to know when it will occur so hard to get the profiler or any other traces. Any suggestion wrt scheduling this in POD like CPU or memory stuff.**\r\n\r\n",
                                           "updatedAt":  "2022-09-13T08:17:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KNiCN",
                                           "createdAt":  "2022-09-13T08:17:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dewanymca",
                                           "body":  "@kouvel - i responded to your queries, let me know if you need additional information.",
                                           "updatedAt":  "2022-09-13T08:17:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KRHEA",
                                           "createdAt":  "2022-09-13T22:07:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "\u003e Problem is there is no definitive way to know when it will occur so hard to get the profiler or any other traces. Any suggestion wrt scheduling this in POD like CPU or memory stuff.\r\n\r\n`dotnet-trace` collects information in a circular buffer and it can be configured to limit the types of information it collects to keep the overhead small and make it more likely that the interesting info would be in the buffer. Here\u0027s an example:\r\n\r\n```\r\ndotnet-trace collect --providers \"Microsoft-Windows-DotNETRuntime:0x10000:4,Microsoft-DotNETCore-SampleProfiler:0:1\" --buffersize 1024 --duration 04:00:00 --process-id \u003cpid\u003e\r\n```\r\n\r\nThat collects only informational threading events (including the Adjustment event above), disables sampling, sets the circular buffer size to 1 GB, and automatically stops the trace after 4 hours. The trace can also be stopped manually if a thread count trough is spotted earlier (but wait until the issue goes away before stopping, so that events for the full trough can be collected).\r\n\r\nYou can set the buffer size depending on how much memory is typically available in the container while the app is running, or if possible increase the memory for one instance of the container that would be tracing.\r\n\r\nPerhaps the issue can be caught in the trace after some trials. A minimal trace like this may provide some information on why the thread pool thread counts are changing, though it may not explain everything.\r\n\r\n\u003e No I didn\u0027t try higher value, as I was not sure whether increasing further will have any consequences.\r\n\r\nThread pool thread starvation shouldn\u0027t occur until the configured minimum number of threads is reached, so it\u0027s also possible that something else is going on. Another avenue may be to modify the app to check the process thread count periodically and invoke [`dotnet-dump`](https://docs.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-dump) to collect a full core dump during a thread count trough, the core dump may also provide more info. .NET 6 has a `ThreadPool.ThreadCount` property that could be used instead but it\u0027s not available in .NET 3.1.",
                                           "updatedAt":  "2022-09-13T22:07:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KXwK5",
                                           "createdAt":  "2022-09-15T08:11:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dewanymca",
                                           "body":  "Thanks @kouvel , i tried bumping up thread from 150 to 300 and it trip the system after sometime. With 300, it reaches 300 and drop 90% again and I see latency. This time, other application also got impacted which doesn\u0027t share VM but share db and other resources. My reading is, if I give more , it consume more and with high horsepower it impact other application by putting more pressure on DB. Let me know if my reading is correct.\r\n\r\nso looks like increasing number of thread is not the solution. We need to look why thread starvation is happening and what is blocking. I am able to reproduce same issue in PPE environment without any minThread set and able to capture the trace. I can see events of Thread Starvation but not sure why it happened. can you please take a look at traces and guide me what is breaking here.\r\n\r\nGetting too big file size error let me know how can I upload",
                                           "updatedAt":  "2022-09-15T08:12:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KaQAU",
                                           "createdAt":  "2022-09-15T17:24:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "@dewanymca would you be able to upload the trace to a cloud storage like OneDrive and share it with me at kouvel@microsoft.com?",
                                           "updatedAt":  "2022-09-15T17:24:36Z"
                                       }
                                   ],
                         "totalCount":  15
                     },
        "title":  "Thread Count dropping by 90% in .NET Core 3.1 Linux",
        "labels":  [
                       "area-System.Threading",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/75065",
        "createdAt":  "2022-09-03T21:04:43Z",
        "number":  75065,
        "author":  "Stannieman",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-09-08T10:01:36Z",
        "body":  "### Description\r\n\r\nIn any cross platform UI app (I tried .NET MAUI, Xamarin Cocoa and Avalonia) Task.Delay sometimes takes way to long to return. When this happens the machine is idle.\r\n\r\nIt happens on macOS, never (or is extremely rare?) on Windows, have not tested on Linux.\r\n\r\nSince it occurs on .NET MAUI, Xamarin Cocoa and Avalonia I believe it is a general .NET issue and not specific to any of these UI technologies. It does not repro in a console app though, so it is possible that a dispatcher/event loop-ish thing needs to be in the mix.\r\n\r\nI am not sure if it is Delay that takes long or it scheduling the continuation task to an available thread takes long. My gut feeling says it\u0027s Delay itself.\r\n\r\n### Reproduction Steps\r\n\r\nCreate a new .NET MAUI app from the default template.\r\nIn the MainPage.xaml.cs put this code:\r\n```\r\npublic MainPage()\r\n\t{\r\n\t\tInitializeComponent();\r\n        StartTimer();\r\n    }\r\n\r\n    private async void StartTimer()\r\n    {\r\n        while (true)\r\n        {\r\n            var startTime = DateTime.Now;\r\n\r\n            await Task.Delay(250).ConfigureAwait(false);\r\n\r\n            var duration = DateTime.Now - startTime;\r\n            if (duration \u003e TimeSpan.FromMilliseconds(500))\r\n            {\r\n                Console.WriteLine($\"Too long: {duration}\");\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\nRun the app and watch the console output. After a while, especially when the app is not in focus, it will have logged that some Task.Delays take too long (or it takes too long to find an available thread for the continuation task)?\r\n\r\n### Expected behavior\r\n\r\nTask.Delay takes as long as configured. Some acceptable margin is allowed due to the nature of timers/scheduling.\r\n\r\n### Actual behavior\r\n\r\nTask.Delay(250) sometimes takes 10 (I have even seem 20 seconds in other runs) to return.\r\n\r\nAfter only a few minutes the output of the MAUI repro looks like this:\r\n```\r\n2022-09-03 22:31:57.460 MauiDelayTest[23283:244356] Too long: 00:00:10.2512860\r\n2022-09-03 22:32:07.711 MauiDelayTest[23283:244357] Too long: 00:00:10.2507830\r\n2022-09-03 22:32:17.962 MauiDelayTest[23283:244356] Too long: 00:00:10.2507510\r\n2022-09-03 22:32:28.213 MauiDelayTest[23283:244357] Too long: 00:00:10.2507120\r\n2022-09-03 22:32:38.464 MauiDelayTest[23283:244356] Too long: 00:00:10.2507690\r\n2022-09-03 22:32:48.715 MauiDelayTest[23283:244356] Too long: 00:00:10.2507520\r\n2022-09-03 22:32:58.966 MauiDelayTest[23283:244356] Too long: 00:00:10.2507770\r\n2022-09-03 22:33:09.218 MauiDelayTest[23283:244356] Too long: 00:00:10.2506970\r\n2022-09-03 22:33:19.468 MauiDelayTest[23283:244356] Too long: 00:00:10.2497130\r\n2022-09-03 22:33:29.718 MauiDelayTest[23283:244356] Too long: 00:00:10.2497150\r\n2022-09-03 22:33:39.969 MauiDelayTest[23283:244356] Too long: 00:00:10.2507150\r\n2022-09-03 22:33:50.220 MauiDelayTest[23283:243490] Too long: 00:00:10.2507650\r\n2022-09-03 22:34:00.471 MauiDelayTest[23283:243490] Too long: 00:00:10.2508590\r\n2022-09-03 22:34:10.722 MauiDelayTest[23283:243490] Too long: 00:00:10.2507190\r\n2022-09-03 22:34:20.973 MauiDelayTest[23283:243490] Too long: 00:00:10.2507480\r\n2022-09-03 22:34:31.224 MauiDelayTest[23283:243490] Too long: 00:00:10.2505340\r\n2022-09-03 22:34:41.475 MauiDelayTest[23283:243490] Too long: 00:00:10.2506370\r\n2022-09-03 22:34:51.726 MauiDelayTest[23283:243490] Too long: 00:00:10.2506850\r\n2022-09-03 22:35:01.976 MauiDelayTest[23283:243490] Too long: 00:00:10.2496890\r\n2022-09-03 22:35:12.227 MauiDelayTest[23283:243490] Too long: 00:00:10.2506760\r\n2022-09-03 22:35:22.478 MauiDelayTest[23283:243490] Too long: 00:00:10.2507100\r\n2022-09-03 22:35:32.729 MauiDelayTest[23283:243490] Too long: 00:00:10.2506590\r\n2022-09-03 22:35:42.980 MauiDelayTest[23283:243490] Too long: 00:00:10.2507170\r\n2022-09-03 22:35:53.231 MauiDelayTest[23283:243490] Too long: 00:00:10.2508010\r\n2022-09-03 22:36:03.482 MauiDelayTest[23283:243490] Too long: 00:00:10.2507330\r\n2022-09-03 22:36:13.733 MauiDelayTest[23283:243490] Too long: 00:00:10.2507030\r\n2022-09-03 22:36:23.120 MauiDelayTest[23283:243490] Too long: 00:00:09.3868430\r\n2022-09-03 22:36:25.437 MauiDelayTest[23283:243490] Too long: 00:00:02.3167130\r\nThread finished: \u003cThread Pool\u003e #13\r\nThread finished: \u003cThread Pool\u003e #7\r\nThread started: \u003cThread Pool\u003e #15\r\nThread started: \u003cThread Pool\u003e #16\r\n2022-09-03 22:37:22.757 MauiDelayTest[23283:244357] Too long: 00:00:05.5036820\r\n2022-09-03 22:37:25.361 MauiDelayTest[23283:246194] Too long: 00:00:02.3526560\r\nThread finished: \u003cThread Pool\u003e #10\r\nThread finished: \u003cThread Pool\u003e #15\r\nThread started: \u003cThread Pool\u003e #17\r\nThread started: \u003cThread Pool\u003e #18\r\n2022-09-03 22:38:18.793 MauiDelayTest[23283:244357] Too long: 00:00:00.8700120\r\n2022-09-03 22:38:20.689 MauiDelayTest[23283:246195] Too long: 00:00:01.8955290\r\n2022-09-03 22:38:30.521 MauiDelayTest[23283:246195] Too long: 00:00:08.8909130\r\n2022-09-03 22:38:31.333 MauiDelayTest[23283:247044] Too long: 00:00:00.5599270\r\n2022-09-03 22:38:32.875 MauiDelayTest[23283:247044] Too long: 00:00:01.5424960\r\n2022-09-03 22:38:43.127 MauiDelayTest[23283:247044] Too long: 00:00:10.2511120\r\n2022-09-03 22:38:43.937 MauiDelayTest[23283:244357] Too long: 00:00:00.8094110\r\n2022-09-03 22:38:45.837 MauiDelayTest[23283:244357] Too long: 00:00:01.6490360\r\n2022-09-03 22:38:46.459 MauiDelayTest[23283:244357] Too long: 00:00:00.6195760\r\n2022-09-03 22:38:49.249 MauiDelayTest[23283:244357] Too long: 00:00:02.5393470\r\n2022-09-03 22:38:53.316 MauiDelayTest[23283:247044] Too long: 00:00:04.0666760\r\n2022-09-03 22:38:56.214 MauiDelayTest[23283:244357] Too long: 00:00:02.8973100\r\n2022-09-03 22:39:00.602 MauiDelayTest[23283:247044] Too long: 00:00:04.1365780\r\n2022-09-03 22:39:01.527 MauiDelayTest[23283:246195] Too long: 00:00:00.6737740\r\n2022-09-03 22:39:03.116 MauiDelayTest[23283:246195] Too long: 00:00:01.5881840\r\n2022-09-03 22:39:09.686 MauiDelayTest[23283:247043] Too long: 00:00:06.5694870\r\n2022-09-03 22:39:11.081 MauiDelayTest[23283:244357] Too long: 00:00:01.0149250\r\n2022-09-03 22:39:13.225 MauiDelayTest[23283:247043] Too long: 00:00:01.2112040\r\n2022-09-03 22:39:24.854 MauiDelayTest[23283:244357] Too long: 00:00:10.0398100\r\n2022-09-03 22:39:35.106 MauiDelayTest[23283:244357] Too long: 00:00:10.2509250\r\n2022-09-03 22:39:45.357 MauiDelayTest[23283:244357] Too long: 00:00:10.2509680\r\n2022-09-03 22:39:48.252 MauiDelayTest[23283:244357] Too long: 00:00:02.8946160\r\n2022-09-03 22:39:51.598 MauiDelayTest[23283:247043] Too long: 00:00:03.0960370\r\n2022-09-03 22:39:54.056 MauiDelayTest[23283:247044] Too long: 00:00:02.4579950\r\nThread started: \u003cThread Pool\u003e #19\r\n2022-09-03 22:39:57.507 MauiDelayTest[23283:246195] Too long: 00:00:03.4504030\r\n2022-09-03 22:39:58.554 MauiDelayTest[23283:247813] Too long: 00:00:01.0459420\r\n2022-09-03 22:40:03.526 MauiDelayTest[23283:247813] Too long: 00:00:04.7199670\r\n2022-09-03 22:40:04.576 MauiDelayTest[23283:247043] Too long: 00:00:00.7994130\r\n2022-09-03 22:40:06.049 MauiDelayTest[23283:246195] Too long: 00:00:01.2223240\r\n2022-09-03 22:40:16.771 MauiDelayTest[23283:247813] Too long: 00:00:10.0197910\r\nThread finished: \u003cThread Pool\u003e #17\r\n2022-09-03 22:40:21.189 MauiDelayTest[23283:247813] Too long: 00:00:04.1677580\r\n2022-09-03 22:40:24.520 MauiDelayTest[23283:244357] Too long: 00:00:03.0801290\r\n2022-09-03 22:40:27.925 MauiDelayTest[23283:247043] Too long: 00:00:03.1539760\r\n2022-09-03 22:40:28.864 MauiDelayTest[23283:246195] Too long: 00:00:00.9378790\r\n2022-09-03 22:40:31.402 MauiDelayTest[23283:247043] Too long: 00:00:02.2867030\r\n2022-09-03 22:40:41.652 MauiDelayTest[23283:244357] Too long: 00:00:10.2497740\r\n2022-09-03 22:40:51.903 MauiDelayTest[23283:244357] Too long: 00:00:10.2507660\r\n2022-09-03 22:40:57.705 MauiDelayTest[23283:244357] Too long: 00:00:05.8011160\r\n2022-09-03 22:41:01.518 MauiDelayTest[23283:246195] Too long: 00:00:03.8130040\r\n2022-09-03 22:41:04.591 MauiDelayTest[23283:246195] Too long: 00:00:02.8202210\r\n2022-09-03 22:41:14.841 MauiDelayTest[23283:247813] Too long: 00:00:10.2500510\r\n2022-09-03 22:41:25.093 MauiDelayTest[23283:247813] Too long: 00:00:10.2511610\r\n2022-09-03 22:41:26.828 MauiDelayTest[23283:247813] Too long: 00:00:01.7347410\r\n2022-09-03 22:41:27.971 MauiDelayTest[23283:247813] Too long: 00:00:01.1424190\r\n2022-09-03 22:41:28.842 MauiDelayTest[23283:246195] Too long: 00:00:00.6214750\r\n2022-09-03 22:41:34.432 MauiDelayTest[23283:247813] Too long: 00:00:04.9831190\r\n2022-09-03 22:41:35.365 MauiDelayTest[23283:246195] Too long: 00:00:00.9327160\r\n2022-09-03 22:41:36.158 MauiDelayTest[23283:247043] Too long: 00:00:00.5397260\r\n2022-09-03 22:41:38.909 MauiDelayTest[23283:247043] Too long: 00:00:02.4640730\r\n2022-09-03 22:41:47.983 MauiDelayTest[23283:247813] Too long: 00:00:08.8239100\r\n2022-09-03 22:41:58.234 MauiDelayTest[23283:244357] Too long: 00:00:10.2512480\r\n2022-09-03 22:42:09.802 MauiDelayTest[23283:247813] Too long: 00:00:10.2503670\r\n2022-09-03 22:42:20.054 MauiDelayTest[23283:247813] Too long: 00:00:10.2512390\r\n2022-09-03 22:42:24.603 MauiDelayTest[23283:247813] Too long: 00:00:04.5491280\r\n2022-09-03 22:42:27.985 MauiDelayTest[23283:247813] Too long: 00:00:03.3810670\r\n2022-09-03 22:42:38.236 MauiDelayTest[23283:247813] Too long: 00:00:10.2509440\r\n2022-09-03 22:42:48.487 MauiDelayTest[23283:247813] Too long: 00:00:10.2508650\r\n2022-09-03 22:42:54.343 MauiDelayTest[23283:247813] Too long: 00:00:05.8552770\r\n2022-09-03 22:43:05.938 MauiDelayTest[23283:246195] Too long: 00:00:10.0958650\r\n2022-09-03 22:43:11.410 MauiDelayTest[23283:246195] Too long: 00:00:05.4708810\r\n2022-09-03 22:43:21.661 MauiDelayTest[23283:246195] Too long: 00:00:10.2508480\r\n2022-09-03 22:43:23.677 MauiDelayTest[23283:246195] Too long: 00:00:02.0163600\r\n2022-09-03 22:43:24.305 MauiDelayTest[23283:244357] Too long: 00:00:00.6270310\r\n2022-09-03 22:43:25.614 MauiDelayTest[23283:246195] Too long: 00:00:00.6198100\r\n2022-09-03 22:43:35.865 MauiDelayTest[23283:246195] Too long: 00:00:10.2509390\r\n2022-09-03 22:43:38.302 MauiDelayTest[23283:246195] Too long: 00:00:02.4361650\r\n2022-09-03 22:43:38.812 MauiDelayTest[23283:246195] Too long: 00:00:00.5095610\r\n2022-09-03 22:43:39.366 MauiDelayTest[23283:246195] Too long: 00:00:00.5537190\r\n2022-09-03 22:43:41.351 MauiDelayTest[23283:247813] Too long: 00:00:01.7333440\r\n2022-09-03 22:43:45.567 MauiDelayTest[23283:244357] Too long: 00:00:03.9640070\r\n2022-09-03 22:43:49.043 MauiDelayTest[23283:246195] Too long: 00:00:03.2244240\r\n2022-09-03 22:44:01.753 MauiDelayTest[23283:246195] Too long: 00:00:10.1977830\r\n2022-09-03 22:44:12.004 MauiDelayTest[23283:246195] Too long: 00:00:10.2507470\r\n2022-09-03 22:44:22.256 MauiDelayTest[23283:246195] Too long: 00:00:10.2512430\r\n2022-09-03 22:44:23.284 MauiDelayTest[23283:246195] Too long: 00:00:01.0277340\r\n2022-09-03 22:44:24.125 MauiDelayTest[23283:244357] Too long: 00:00:00.8404410\r\n2022-09-03 22:44:29.162 MauiDelayTest[23283:247043] Too long: 00:00:04.3669020\r\n2022-09-03 22:44:30.617 MauiDelayTest[23283:246195] Too long: 00:00:01.0912190\r\n2022-09-03 22:44:34.406 MauiDelayTest[23283:247043] Too long: 00:00:03.7884600\r\n2022-09-03 22:44:45.384 MauiDelayTest[23283:244357] Too long: 00:00:10.2512320\r\n2022-09-03 22:44:55.635 MauiDelayTest[23283:244357] Too long: 00:00:10.2509780\r\n2022-09-03 22:44:57.643 MauiDelayTest[23283:244357] Too long: 00:00:02.0079630\r\n2022-09-03 22:45:07.896 MauiDelayTest[23283:247043] Too long: 00:00:10.2513030\r\n2022-09-03 22:45:12.647 MauiDelayTest[23283:247043] Too long: 00:00:04.7509200\r\n2022-09-03 22:45:22.898 MauiDelayTest[23283:247043] Too long: 00:00:10.2507910\r\n2022-09-03 22:45:33.149 MauiDelayTest[23283:247043] Too long: 00:00:10.2508030\r\n2022-09-03 22:45:35.894 MauiDelayTest[23283:246195] Too long: 00:00:02.7437330\r\n2022-09-03 22:45:43.939 MauiDelayTest[23283:244357] Too long: 00:00:06.7874840\r\n2022-09-03 22:45:54.240 MauiDelayTest[23283:247043] Too long: 00:00:10.0507740\r\n2022-09-03 22:45:58.618 MauiDelayTest[23283:247813] Too long: 00:00:04.3772470\r\n2022-09-03 22:46:04.652 MauiDelayTest[23283:246195] Too long: 00:00:06.0339020\r\n2022-09-03 22:46:06.637 MauiDelayTest[23283:246195] Too long: 00:00:01.6022470\r\n2022-09-03 22:46:09.058 MauiDelayTest[23283:246195] Too long: 00:00:02.0371930\r\n2022-09-03 22:46:19.310 MauiDelayTest[23283:247043] Too long: 00:00:10.2517280\r\n2022-09-03 22:46:29.561 MauiDelayTest[23283:246195] Too long: 00:00:10.2508650\r\n2022-09-03 22:46:39.813 MauiDelayTest[23283:246195] Too long: 00:00:10.2510900\r\n2022-09-03 22:46:50.064 MauiDelayTest[23283:244357] Too long: 00:00:10.2505510\r\n2022-09-03 22:47:00.315 MauiDelayTest[23283:244357] Too long: 00:00:10.2509090\r\n2022-09-03 22:47:10.567 MauiDelayTest[23283:244357] Too long: 00:00:10.2508690\r\n2022-09-03 22:47:20.818 MauiDelayTest[23283:246195] Too long: 00:00:10.2508620\r\n2022-09-03 22:47:29.747 MauiDelayTest[23283:246195] Too long: 00:00:08.9290060\r\n2022-09-03 22:47:39.999 MauiDelayTest[23283:246195] Too long: 00:00:10.2510950\r\n2022-09-03 22:47:50.251 MauiDelayTest[23283:246195] Too long: 00:00:10.2517560\r\n2022-09-03 22:48:00.502 MauiDelayTest[23283:244357] Too long: 00:00:10.2505570\r\n2022-09-03 22:48:10.753 MauiDelayTest[23283:244357] Too long: 00:00:10.2508490\r\n2022-09-03 22:48:21.003 MauiDelayTest[23283:247813] Too long: 00:00:10.2498750\r\n2022-09-03 22:48:31.254 MauiDelayTest[23283:247813] Too long: 00:00:10.2507390\r\n2022-09-03 22:48:41.555 MauiDelayTest[23283:244357] Too long: 00:00:10.0496930\r\n2022-09-03 22:48:51.806 MauiDelayTest[23283:244357] Too long: 00:00:10.2508870\r\n2022-09-03 22:49:02.058 MauiDelayTest[23283:244357] Too long: 00:00:10.2509680\r\n2022-09-03 22:49:12.309 MauiDelayTest[23283:246195] Too long: 00:00:10.2508630\r\n2022-09-03 22:49:21.962 MauiDelayTest[23283:246195] Too long: 00:00:09.6523650\r\n2022-09-03 22:49:33.468 MauiDelayTest[23283:246195] Too long: 00:00:10.2481990\r\n2022-09-03 22:49:38.371 MauiDelayTest[23283:246195] Too long: 00:00:04.9030040\r\n2022-09-03 22:49:40.508 MauiDelayTest[23283:247043] Too long: 00:00:02.1363810\r\nThread finished: \u003cThread Pool\u003e #19\r\nThread finished: \u003cThread Pool\u003e #16\r\nThread started: \u003cThread Pool\u003e #20\r\nThread started: \u003cThread Pool\u003e #21\r\n2022-09-03 22:50:26.718 MauiDelayTest[23283:247043] Too long: 00:00:10.2533590\r\n2022-09-03 22:50:36.969 MauiDelayTest[23283:244357] Too long: 00:00:10.2509710\r\n2022-09-03 22:50:47.220 MauiDelayTest[23283:252061] Too long: 00:00:10.2508140\r\n2022-09-03 22:50:57.472 MauiDelayTest[23283:244357] Too long: 00:00:10.2508920\r\n2022-09-03 22:51:00.254 MauiDelayTest[23283:244357] Too long: 00:00:02.7823050\r\n2022-09-03 22:51:11.762 MauiDelayTest[23283:252061] Too long: 00:00:10.2503850\r\n2022-09-03 22:51:22.013 MauiDelayTest[23283:252061] Too long: 00:00:10.2508200\r\n2022-09-03 22:51:32.264 MauiDelayTest[23283:244357] Too long: 00:00:10.2508310\r\n2022-09-03 22:51:42.515 MauiDelayTest[23283:244357] Too long: 00:00:10.2507980\r\n2022-09-03 22:51:52.767 MauiDelayTest[23283:244357] Too long: 00:00:10.2511650\r\n2022-09-03 22:52:03.018 MauiDelayTest[23283:244357] Too long: 00:00:10.2508960\r\n2022-09-03 22:52:13.269 MauiDelayTest[23283:244357] Too long: 00:00:10.2508820\r\n2022-09-03 22:52:23.521 MauiDelayTest[23283:244357] Too long: 00:00:10.2509770\r\n2022-09-03 22:52:33.772 MauiDelayTest[23283:252061] Too long: 00:00:10.2508050\r\n2022-09-03 22:52:44.022 MauiDelayTest[23283:252061] Too long: 00:00:10.2496470\r\n2022-09-03 22:52:54.273 MauiDelayTest[23283:252061] Too long: 00:00:10.2507420\r\n2022-09-03 22:53:04.525 MauiDelayTest[23283:247043] Too long: 00:00:10.2512880\r\n2022-09-03 22:53:14.776 MauiDelayTest[23283:244357] Too long: 00:00:10.2509730\r\n2022-09-03 22:53:25.028 MauiDelayTest[23283:244357] Too long: 00:00:10.2508960\r\n2022-09-03 22:53:35.279 MauiDelayTest[23283:244357] Too long: 00:00:10.2508200\r\n2022-09-03 22:53:45.530 MauiDelayTest[23283:244357] Too long: 00:00:10.2509070\r\n2022-09-03 22:53:55.781 MauiDelayTest[23283:244357] Too long: 00:00:10.2510630\r\n2022-09-03 22:54:06.036 MauiDelayTest[23283:244357] Too long: 00:00:10.2545310\r\n2022-09-03 22:54:16.287 MauiDelayTest[23283:244357] Too long: 00:00:10.2506480\r\n2022-09-03 22:54:26.538 MauiDelayTest[23283:244357] Too long: 00:00:10.2510210\r\n2022-09-03 22:54:36.790 MauiDelayTest[23283:252061] Too long: 00:00:10.2509100\r\n2022-09-03 22:54:47.042 MauiDelayTest[23283:252061] Too long: 00:00:10.2514720\r\n2022-09-03 22:54:57.292 MauiDelayTest[23283:247043] Too long: 00:00:10.2498380\r\n2022-09-03 22:55:07.543 MauiDelayTest[23283:247043] Too long: 00:00:10.2508610\r\n2022-09-03 22:55:17.794 MauiDelayTest[23283:247043] Too long: 00:00:10.2508380\r\n2022-09-03 22:55:28.046 MauiDelayTest[23283:247043] Too long: 00:00:10.2508600\r\n2022-09-03 22:55:38.297 MauiDelayTest[23283:252061] Too long: 00:00:10.2509170\r\n2022-09-03 22:55:48.548 MauiDelayTest[23283:252061] Too long: 00:00:10.2511000\r\n2022-09-03 22:55:58.800 MauiDelayTest[23283:247043] Too long: 00:00:10.2508430\r\n2022-09-03 22:56:09.116 MauiDelayTest[23283:252061] Too long: 00:00:10.3165300\r\n2022-09-03 22:56:19.367 MauiDelayTest[23283:252061] Too long: 00:00:10.2506530\r\n2022-09-03 22:56:29.619 MauiDelayTest[23283:252061] Too long: 00:00:10.2510030\r\n2022-09-03 22:56:39.870 MauiDelayTest[23283:252061] Too long: 00:00:10.2508340\r\n2022-09-03 22:56:50.122 MauiDelayTest[23283:252061] Too long: 00:00:10.2509030\r\n2022-09-03 22:57:00.375 MauiDelayTest[23283:247043] Too long: 00:00:10.2514170\r\n2022-09-03 22:57:10.626 MauiDelayTest[23283:252060] Too long: 00:00:10.2509370\r\n2022-09-03 22:57:20.877 MauiDelayTest[23283:252060] Too long: 00:00:10.2508860\r\n2022-09-03 22:57:31.128 MauiDelayTest[23283:247043] Too long: 00:00:10.2508450\r\n2022-09-03 22:57:41.379 MauiDelayTest[23283:252060] Too long: 00:00:10.2498920\r\n2022-09-03 22:57:50.248 MauiDelayTest[23283:252060] Too long: 00:00:08.8694130\r\n2022-09-03 22:57:53.711 MauiDelayTest[23283:252061] Too long: 00:00:03.4626000\r\n```\r\n\r\n### Regression?\r\n\r\nNo idea, only discovered this in .NET 6.\r\n\r\n### Known Workarounds\r\n\r\nNone.\r\n\r\n### Configuration\r\n\r\n* .NET 6\r\n* macOS 12.5.1 (latest)\r\n* x64\r\n* This is an old 2015 MacBook pro. It happens on newer Intel Macs too, although I do not know it happens as often.\r\n\r\n### Other information\r\n\r\nThis was originally discovered when using MQTTnet.\r\nhttps://github.com/dotnet/MQTTnet/issues/1490\r\nWhen debugging this I tried a number of different workarounds like long running task, dedicated thread, System.Timers.Timer, System.Threading.PeriodicTimer. None of them work. This makes me believe the underlying timer mechanism (System.Threading.TimerQueueTimer) is unreliable on macOS.\r\n\r\nUPDATE: Turns out it is caused by App Nap.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOSfCAnw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5JruOt",
                                           "createdAt":  "2022-09-03T21:04:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-09-03T21:04:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JrwEv",
                                           "createdAt":  "2022-09-03T22:12:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nIn any cross platform UI app (I tried .NET MAUI, Xamarin Cocoa and Avalonia) Task.Delay sometimes takes way to long to return. When this happens the machine is idle.\r\n\r\nIt happens on macOS, never (or is extremely rare?) on Windows, have not tested on Linux.\r\n\r\nSince it occurs on .NET MAUI, Xamarin Cocoa and Avalonia I believe it is a general .NET issue and not specific to any of these UI technologies. It does not repro in a console app though, so it is possible that a dispatcher/event loop-ish thing needs to be in the mix.\r\n\r\nI am not sure if it is Delay that takes long or it scheduling the continuation task to an available thread takes long. My gut feeling says it\u0027s Delay itself.\n\n### Reproduction Steps\n\nCreate a new .NET MAUI app from the default template.\r\nIn the MainPage.xaml.cs put this code:\r\n```\r\npublic MainPage()\r\n\t{\r\n\t\tInitializeComponent();\r\n        StartTimer();\r\n    }\r\n\r\n    private async void StartTimer()\r\n    {\r\n        while (true)\r\n        {\r\n            var startTime = DateTime.Now;\r\n\r\n            await Task.Delay(250).ConfigureAwait(false);\r\n\r\n            var duration = DateTime.Now - startTime;\r\n            if (duration \u003e TimeSpan.FromMilliseconds(500))\r\n            {\r\n                Console.WriteLine($\"Too long: {duration}\");\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\nRun the app and watch the console output. After a while, especially when the app is not in focus, it will have logged that some Task.Delays take too long (or it takes too long to find an available thread for the continuation task)?\n\n### Expected behavior\n\nTask.Delay takes as long as configured. Some acceptable margin is allowed due to the nature of timers/scheduling.\n\n### Actual behavior\n\nTask.Delay(250) sometimes takes 10 (I have even seem 20 seconds in other runs) to return.\r\n\r\nAfter only a few minutes the output of the MAUI repro looks like this:\r\n```\r\n2022-09-03 22:31:57.460 MauiDelayTest[23283:244356] Too long: 00:00:10.2512860\r\n2022-09-03 22:32:07.711 MauiDelayTest[23283:244357] Too long: 00:00:10.2507830\r\n2022-09-03 22:32:17.962 MauiDelayTest[23283:244356] Too long: 00:00:10.2507510\r\n2022-09-03 22:32:28.213 MauiDelayTest[23283:244357] Too long: 00:00:10.2507120\r\n2022-09-03 22:32:38.464 MauiDelayTest[23283:244356] Too long: 00:00:10.2507690\r\n2022-09-03 22:32:48.715 MauiDelayTest[23283:244356] Too long: 00:00:10.2507520\r\n2022-09-03 22:32:58.966 MauiDelayTest[23283:244356] Too long: 00:00:10.2507770\r\n2022-09-03 22:33:09.218 MauiDelayTest[23283:244356] Too long: 00:00:10.2506970\r\n2022-09-03 22:33:19.468 MauiDelayTest[23283:244356] Too long: 00:00:10.2497130\r\n2022-09-03 22:33:29.718 MauiDelayTest[23283:244356] Too long: 00:00:10.2497150\r\n2022-09-03 22:33:39.969 MauiDelayTest[23283:244356] Too long: 00:00:10.2507150\r\n2022-09-03 22:33:50.220 MauiDelayTest[23283:243490] Too long: 00:00:10.2507650\r\n2022-09-03 22:34:00.471 MauiDelayTest[23283:243490] Too long: 00:00:10.2508590\r\n2022-09-03 22:34:10.722 MauiDelayTest[23283:243490] Too long: 00:00:10.2507190\r\n2022-09-03 22:34:20.973 MauiDelayTest[23283:243490] Too long: 00:00:10.2507480\r\n2022-09-03 22:34:31.224 MauiDelayTest[23283:243490] Too long: 00:00:10.2505340\r\n2022-09-03 22:34:41.475 MauiDelayTest[23283:243490] Too long: 00:00:10.2506370\r\n2022-09-03 22:34:51.726 MauiDelayTest[23283:243490] Too long: 00:00:10.2506850\r\n2022-09-03 22:35:01.976 MauiDelayTest[23283:243490] Too long: 00:00:10.2496890\r\n2022-09-03 22:35:12.227 MauiDelayTest[23283:243490] Too long: 00:00:10.2506760\r\n2022-09-03 22:35:22.478 MauiDelayTest[23283:243490] Too long: 00:00:10.2507100\r\n2022-09-03 22:35:32.729 MauiDelayTest[23283:243490] Too long: 00:00:10.2506590\r\n2022-09-03 22:35:42.980 MauiDelayTest[23283:243490] Too long: 00:00:10.2507170\r\n2022-09-03 22:35:53.231 MauiDelayTest[23283:243490] Too long: 00:00:10.2508010\r\n2022-09-03 22:36:03.482 MauiDelayTest[23283:243490] Too long: 00:00:10.2507330\r\n2022-09-03 22:36:13.733 MauiDelayTest[23283:243490] Too long: 00:00:10.2507030\r\n2022-09-03 22:36:23.120 MauiDelayTest[23283:243490] Too long: 00:00:09.3868430\r\n2022-09-03 22:36:25.437 MauiDelayTest[23283:243490] Too long: 00:00:02.3167130\r\nThread finished: \u003cThread Pool\u003e #13\r\nThread finished: \u003cThread Pool\u003e #7\r\nThread started: \u003cThread Pool\u003e #15\r\nThread started: \u003cThread Pool\u003e #16\r\n2022-09-03 22:37:22.757 MauiDelayTest[23283:244357] Too long: 00:00:05.5036820\r\n2022-09-03 22:37:25.361 MauiDelayTest[23283:246194] Too long: 00:00:02.3526560\r\nThread finished: \u003cThread Pool\u003e #10\r\nThread finished: \u003cThread Pool\u003e #15\r\nThread started: \u003cThread Pool\u003e #17\r\nThread started: \u003cThread Pool\u003e #18\r\n2022-09-03 22:38:18.793 MauiDelayTest[23283:244357] Too long: 00:00:00.8700120\r\n2022-09-03 22:38:20.689 MauiDelayTest[23283:246195] Too long: 00:00:01.8955290\r\n2022-09-03 22:38:30.521 MauiDelayTest[23283:246195] Too long: 00:00:08.8909130\r\n2022-09-03 22:38:31.333 MauiDelayTest[23283:247044] Too long: 00:00:00.5599270\r\n2022-09-03 22:38:32.875 MauiDelayTest[23283:247044] Too long: 00:00:01.5424960\r\n2022-09-03 22:38:43.127 MauiDelayTest[23283:247044] Too long: 00:00:10.2511120\r\n2022-09-03 22:38:43.937 MauiDelayTest[23283:244357] Too long: 00:00:00.8094110\r\n2022-09-03 22:38:45.837 MauiDelayTest[23283:244357] Too long: 00:00:01.6490360\r\n2022-09-03 22:38:46.459 MauiDelayTest[23283:244357] Too long: 00:00:00.6195760\r\n2022-09-03 22:38:49.249 MauiDelayTest[23283:244357] Too long: 00:00:02.5393470\r\n2022-09-03 22:38:53.316 MauiDelayTest[23283:247044] Too long: 00:00:04.0666760\r\n2022-09-03 22:38:56.214 MauiDelayTest[23283:244357] Too long: 00:00:02.8973100\r\n2022-09-03 22:39:00.602 MauiDelayTest[23283:247044] Too long: 00:00:04.1365780\r\n2022-09-03 22:39:01.527 MauiDelayTest[23283:246195] Too long: 00:00:00.6737740\r\n2022-09-03 22:39:03.116 MauiDelayTest[23283:246195] Too long: 00:00:01.5881840\r\n2022-09-03 22:39:09.686 MauiDelayTest[23283:247043] Too long: 00:00:06.5694870\r\n2022-09-03 22:39:11.081 MauiDelayTest[23283:244357] Too long: 00:00:01.0149250\r\n2022-09-03 22:39:13.225 MauiDelayTest[23283:247043] Too long: 00:00:01.2112040\r\n2022-09-03 22:39:24.854 MauiDelayTest[23283:244357] Too long: 00:00:10.0398100\r\n2022-09-03 22:39:35.106 MauiDelayTest[23283:244357] Too long: 00:00:10.2509250\r\n2022-09-03 22:39:45.357 MauiDelayTest[23283:244357] Too long: 00:00:10.2509680\r\n2022-09-03 22:39:48.252 MauiDelayTest[23283:244357] Too long: 00:00:02.8946160\r\n2022-09-03 22:39:51.598 MauiDelayTest[23283:247043] Too long: 00:00:03.0960370\r\n2022-09-03 22:39:54.056 MauiDelayTest[23283:247044] Too long: 00:00:02.4579950\r\nThread started: \u003cThread Pool\u003e #19\r\n2022-09-03 22:39:57.507 MauiDelayTest[23283:246195] Too long: 00:00:03.4504030\r\n2022-09-03 22:39:58.554 MauiDelayTest[23283:247813] Too long: 00:00:01.0459420\r\n2022-09-03 22:40:03.526 MauiDelayTest[23283:247813] Too long: 00:00:04.7199670\r\n2022-09-03 22:40:04.576 MauiDelayTest[23283:247043] Too long: 00:00:00.7994130\r\n2022-09-03 22:40:06.049 MauiDelayTest[23283:246195] Too long: 00:00:01.2223240\r\n2022-09-03 22:40:16.771 MauiDelayTest[23283:247813] Too long: 00:00:10.0197910\r\nThread finished: \u003cThread Pool\u003e #17\r\n2022-09-03 22:40:21.189 MauiDelayTest[23283:247813] Too long: 00:00:04.1677580\r\n2022-09-03 22:40:24.520 MauiDelayTest[23283:244357] Too long: 00:00:03.0801290\r\n2022-09-03 22:40:27.925 MauiDelayTest[23283:247043] Too long: 00:00:03.1539760\r\n2022-09-03 22:40:28.864 MauiDelayTest[23283:246195] Too long: 00:00:00.9378790\r\n2022-09-03 22:40:31.402 MauiDelayTest[23283:247043] Too long: 00:00:02.2867030\r\n2022-09-03 22:40:41.652 MauiDelayTest[23283:244357] Too long: 00:00:10.2497740\r\n2022-09-03 22:40:51.903 MauiDelayTest[23283:244357] Too long: 00:00:10.2507660\r\n2022-09-03 22:40:57.705 MauiDelayTest[23283:244357] Too long: 00:00:05.8011160\r\n2022-09-03 22:41:01.518 MauiDelayTest[23283:246195] Too long: 00:00:03.8130040\r\n2022-09-03 22:41:04.591 MauiDelayTest[23283:246195] Too long: 00:00:02.8202210\r\n2022-09-03 22:41:14.841 MauiDelayTest[23283:247813] Too long: 00:00:10.2500510\r\n2022-09-03 22:41:25.093 MauiDelayTest[23283:247813] Too long: 00:00:10.2511610\r\n2022-09-03 22:41:26.828 MauiDelayTest[23283:247813] Too long: 00:00:01.7347410\r\n2022-09-03 22:41:27.971 MauiDelayTest[23283:247813] Too long: 00:00:01.1424190\r\n2022-09-03 22:41:28.842 MauiDelayTest[23283:246195] Too long: 00:00:00.6214750\r\n2022-09-03 22:41:34.432 MauiDelayTest[23283:247813] Too long: 00:00:04.9831190\r\n2022-09-03 22:41:35.365 MauiDelayTest[23283:246195] Too long: 00:00:00.9327160\r\n2022-09-03 22:41:36.158 MauiDelayTest[23283:247043] Too long: 00:00:00.5397260\r\n2022-09-03 22:41:38.909 MauiDelayTest[23283:247043] Too long: 00:00:02.4640730\r\n2022-09-03 22:41:47.983 MauiDelayTest[23283:247813] Too long: 00:00:08.8239100\r\n2022-09-03 22:41:58.234 MauiDelayTest[23283:244357] Too long: 00:00:10.2512480\r\n2022-09-03 22:42:09.802 MauiDelayTest[23283:247813] Too long: 00:00:10.2503670\r\n2022-09-03 22:42:20.054 MauiDelayTest[23283:247813] Too long: 00:00:10.2512390\r\n2022-09-03 22:42:24.603 MauiDelayTest[23283:247813] Too long: 00:00:04.5491280\r\n2022-09-03 22:42:27.985 MauiDelayTest[23283:247813] Too long: 00:00:03.3810670\r\n2022-09-03 22:42:38.236 MauiDelayTest[23283:247813] Too long: 00:00:10.2509440\r\n2022-09-03 22:42:48.487 MauiDelayTest[23283:247813] Too long: 00:00:10.2508650\r\n2022-09-03 22:42:54.343 MauiDelayTest[23283:247813] Too long: 00:00:05.8552770\r\n2022-09-03 22:43:05.938 MauiDelayTest[23283:246195] Too long: 00:00:10.0958650\r\n2022-09-03 22:43:11.410 MauiDelayTest[23283:246195] Too long: 00:00:05.4708810\r\n2022-09-03 22:43:21.661 MauiDelayTest[23283:246195] Too long: 00:00:10.2508480\r\n2022-09-03 22:43:23.677 MauiDelayTest[23283:246195] Too long: 00:00:02.0163600\r\n2022-09-03 22:43:24.305 MauiDelayTest[23283:244357] Too long: 00:00:00.6270310\r\n2022-09-03 22:43:25.614 MauiDelayTest[23283:246195] Too long: 00:00:00.6198100\r\n2022-09-03 22:43:35.865 MauiDelayTest[23283:246195] Too long: 00:00:10.2509390\r\n2022-09-03 22:43:38.302 MauiDelayTest[23283:246195] Too long: 00:00:02.4361650\r\n2022-09-03 22:43:38.812 MauiDelayTest[23283:246195] Too long: 00:00:00.5095610\r\n2022-09-03 22:43:39.366 MauiDelayTest[23283:246195] Too long: 00:00:00.5537190\r\n2022-09-03 22:43:41.351 MauiDelayTest[23283:247813] Too long: 00:00:01.7333440\r\n2022-09-03 22:43:45.567 MauiDelayTest[23283:244357] Too long: 00:00:03.9640070\r\n2022-09-03 22:43:49.043 MauiDelayTest[23283:246195] Too long: 00:00:03.2244240\r\n2022-09-03 22:44:01.753 MauiDelayTest[23283:246195] Too long: 00:00:10.1977830\r\n2022-09-03 22:44:12.004 MauiDelayTest[23283:246195] Too long: 00:00:10.2507470\r\n2022-09-03 22:44:22.256 MauiDelayTest[23283:246195] Too long: 00:00:10.2512430\r\n2022-09-03 22:44:23.284 MauiDelayTest[23283:246195] Too long: 00:00:01.0277340\r\n2022-09-03 22:44:24.125 MauiDelayTest[23283:244357] Too long: 00:00:00.8404410\r\n2022-09-03 22:44:29.162 MauiDelayTest[23283:247043] Too long: 00:00:04.3669020\r\n2022-09-03 22:44:30.617 MauiDelayTest[23283:246195] Too long: 00:00:01.0912190\r\n2022-09-03 22:44:34.406 MauiDelayTest[23283:247043] Too long: 00:00:03.7884600\r\n2022-09-03 22:44:45.384 MauiDelayTest[23283:244357] Too long: 00:00:10.2512320\r\n2022-09-03 22:44:55.635 MauiDelayTest[23283:244357] Too long: 00:00:10.2509780\r\n2022-09-03 22:44:57.643 MauiDelayTest[23283:244357] Too long: 00:00:02.0079630\r\n2022-09-03 22:45:07.896 MauiDelayTest[23283:247043] Too long: 00:00:10.2513030\r\n2022-09-03 22:45:12.647 MauiDelayTest[23283:247043] Too long: 00:00:04.7509200\r\n2022-09-03 22:45:22.898 MauiDelayTest[23283:247043] Too long: 00:00:10.2507910\r\n2022-09-03 22:45:33.149 MauiDelayTest[23283:247043] Too long: 00:00:10.2508030\r\n2022-09-03 22:45:35.894 MauiDelayTest[23283:246195] Too long: 00:00:02.7437330\r\n2022-09-03 22:45:43.939 MauiDelayTest[23283:244357] Too long: 00:00:06.7874840\r\n2022-09-03 22:45:54.240 MauiDelayTest[23283:247043] Too long: 00:00:10.0507740\r\n2022-09-03 22:45:58.618 MauiDelayTest[23283:247813] Too long: 00:00:04.3772470\r\n2022-09-03 22:46:04.652 MauiDelayTest[23283:246195] Too long: 00:00:06.0339020\r\n2022-09-03 22:46:06.637 MauiDelayTest[23283:246195] Too long: 00:00:01.6022470\r\n2022-09-03 22:46:09.058 MauiDelayTest[23283:246195] Too long: 00:00:02.0371930\r\n2022-09-03 22:46:19.310 MauiDelayTest[23283:247043] Too long: 00:00:10.2517280\r\n2022-09-03 22:46:29.561 MauiDelayTest[23283:246195] Too long: 00:00:10.2508650\r\n2022-09-03 22:46:39.813 MauiDelayTest[23283:246195] Too long: 00:00:10.2510900\r\n2022-09-03 22:46:50.064 MauiDelayTest[23283:244357] Too long: 00:00:10.2505510\r\n2022-09-03 22:47:00.315 MauiDelayTest[23283:244357] Too long: 00:00:10.2509090\r\n2022-09-03 22:47:10.567 MauiDelayTest[23283:244357] Too long: 00:00:10.2508690\r\n2022-09-03 22:47:20.818 MauiDelayTest[23283:246195] Too long: 00:00:10.2508620\r\n2022-09-03 22:47:29.747 MauiDelayTest[23283:246195] Too long: 00:00:08.9290060\r\n2022-09-03 22:47:39.999 MauiDelayTest[23283:246195] Too long: 00:00:10.2510950\r\n2022-09-03 22:47:50.251 MauiDelayTest[23283:246195] Too long: 00:00:10.2517560\r\n2022-09-03 22:48:00.502 MauiDelayTest[23283:244357] Too long: 00:00:10.2505570\r\n2022-09-03 22:48:10.753 MauiDelayTest[23283:244357] Too long: 00:00:10.2508490\r\n2022-09-03 22:48:21.003 MauiDelayTest[23283:247813] Too long: 00:00:10.2498750\r\n2022-09-03 22:48:31.254 MauiDelayTest[23283:247813] Too long: 00:00:10.2507390\r\n2022-09-03 22:48:41.555 MauiDelayTest[23283:244357] Too long: 00:00:10.0496930\r\n2022-09-03 22:48:51.806 MauiDelayTest[23283:244357] Too long: 00:00:10.2508870\r\n2022-09-03 22:49:02.058 MauiDelayTest[23283:244357] Too long: 00:00:10.2509680\r\n2022-09-03 22:49:12.309 MauiDelayTest[23283:246195] Too long: 00:00:10.2508630\r\n2022-09-03 22:49:21.962 MauiDelayTest[23283:246195] Too long: 00:00:09.6523650\r\n2022-09-03 22:49:33.468 MauiDelayTest[23283:246195] Too long: 00:00:10.2481990\r\n2022-09-03 22:49:38.371 MauiDelayTest[23283:246195] Too long: 00:00:04.9030040\r\n2022-09-03 22:49:40.508 MauiDelayTest[23283:247043] Too long: 00:00:02.1363810\r\nThread finished: \u003cThread Pool\u003e #19\r\nThread finished: \u003cThread Pool\u003e #16\r\nThread started: \u003cThread Pool\u003e #20\r\nThread started: \u003cThread Pool\u003e #21\r\n2022-09-03 22:50:26.718 MauiDelayTest[23283:247043] Too long: 00:00:10.2533590\r\n2022-09-03 22:50:36.969 MauiDelayTest[23283:244357] Too long: 00:00:10.2509710\r\n2022-09-03 22:50:47.220 MauiDelayTest[23283:252061] Too long: 00:00:10.2508140\r\n2022-09-03 22:50:57.472 MauiDelayTest[23283:244357] Too long: 00:00:10.2508920\r\n2022-09-03 22:51:00.254 MauiDelayTest[23283:244357] Too long: 00:00:02.7823050\r\n2022-09-03 22:51:11.762 MauiDelayTest[23283:252061] Too long: 00:00:10.2503850\r\n2022-09-03 22:51:22.013 MauiDelayTest[23283:252061] Too long: 00:00:10.2508200\r\n2022-09-03 22:51:32.264 MauiDelayTest[23283:244357] Too long: 00:00:10.2508310\r\n2022-09-03 22:51:42.515 MauiDelayTest[23283:244357] Too long: 00:00:10.2507980\r\n2022-09-03 22:51:52.767 MauiDelayTest[23283:244357] Too long: 00:00:10.2511650\r\n2022-09-03 22:52:03.018 MauiDelayTest[23283:244357] Too long: 00:00:10.2508960\r\n2022-09-03 22:52:13.269 MauiDelayTest[23283:244357] Too long: 00:00:10.2508820\r\n2022-09-03 22:52:23.521 MauiDelayTest[23283:244357] Too long: 00:00:10.2509770\r\n2022-09-03 22:52:33.772 MauiDelayTest[23283:252061] Too long: 00:00:10.2508050\r\n2022-09-03 22:52:44.022 MauiDelayTest[23283:252061] Too long: 00:00:10.2496470\r\n2022-09-03 22:52:54.273 MauiDelayTest[23283:252061] Too long: 00:00:10.2507420\r\n2022-09-03 22:53:04.525 MauiDelayTest[23283:247043] Too long: 00:00:10.2512880\r\n2022-09-03 22:53:14.776 MauiDelayTest[23283:244357] Too long: 00:00:10.2509730\r\n2022-09-03 22:53:25.028 MauiDelayTest[23283:244357] Too long: 00:00:10.2508960\r\n2022-09-03 22:53:35.279 MauiDelayTest[23283:244357] Too long: 00:00:10.2508200\r\n2022-09-03 22:53:45.530 MauiDelayTest[23283:244357] Too long: 00:00:10.2509070\r\n2022-09-03 22:53:55.781 MauiDelayTest[23283:244357] Too long: 00:00:10.2510630\r\n2022-09-03 22:54:06.036 MauiDelayTest[23283:244357] Too long: 00:00:10.2545310\r\n2022-09-03 22:54:16.287 MauiDelayTest[23283:244357] Too long: 00:00:10.2506480\r\n2022-09-03 22:54:26.538 MauiDelayTest[23283:244357] Too long: 00:00:10.2510210\r\n2022-09-03 22:54:36.790 MauiDelayTest[23283:252061] Too long: 00:00:10.2509100\r\n2022-09-03 22:54:47.042 MauiDelayTest[23283:252061] Too long: 00:00:10.2514720\r\n2022-09-03 22:54:57.292 MauiDelayTest[23283:247043] Too long: 00:00:10.2498380\r\n2022-09-03 22:55:07.543 MauiDelayTest[23283:247043] Too long: 00:00:10.2508610\r\n2022-09-03 22:55:17.794 MauiDelayTest[23283:247043] Too long: 00:00:10.2508380\r\n2022-09-03 22:55:28.046 MauiDelayTest[23283:247043] Too long: 00:00:10.2508600\r\n2022-09-03 22:55:38.297 MauiDelayTest[23283:252061] Too long: 00:00:10.2509170\r\n2022-09-03 22:55:48.548 MauiDelayTest[23283:252061] Too long: 00:00:10.2511000\r\n2022-09-03 22:55:58.800 MauiDelayTest[23283:247043] Too long: 00:00:10.2508430\r\n2022-09-03 22:56:09.116 MauiDelayTest[23283:252061] Too long: 00:00:10.3165300\r\n2022-09-03 22:56:19.367 MauiDelayTest[23283:252061] Too long: 00:00:10.2506530\r\n2022-09-03 22:56:29.619 MauiDelayTest[23283:252061] Too long: 00:00:10.2510030\r\n2022-09-03 22:56:39.870 MauiDelayTest[23283:252061] Too long: 00:00:10.2508340\r\n2022-09-03 22:56:50.122 MauiDelayTest[23283:252061] Too long: 00:00:10.2509030\r\n2022-09-03 22:57:00.375 MauiDelayTest[23283:247043] Too long: 00:00:10.2514170\r\n2022-09-03 22:57:10.626 MauiDelayTest[23283:252060] Too long: 00:00:10.2509370\r\n2022-09-03 22:57:20.877 MauiDelayTest[23283:252060] Too long: 00:00:10.2508860\r\n2022-09-03 22:57:31.128 MauiDelayTest[23283:247043] Too long: 00:00:10.2508450\r\n2022-09-03 22:57:41.379 MauiDelayTest[23283:252060] Too long: 00:00:10.2498920\r\n2022-09-03 22:57:50.248 MauiDelayTest[23283:252060] Too long: 00:00:08.8694130\r\n2022-09-03 22:57:53.711 MauiDelayTest[23283:252061] Too long: 00:00:03.4626000\r\n```\n\n### Regression?\n\nNo idea, only discovered this in .NET 6.\n\n### Known Workarounds\n\nNone.\n\n### Configuration\n\n* .NET 6\r\n* macOS 12.5.1 (latest)\r\n* x64\r\n* This is an old 2015 MacBook pro. It happens on newer Intel Macs too, although I do not know it happens as often.\n\n### Other information\n\nThis was originally discovered when using MQTTnet.\r\nhttps://github.com/dotnet/MQTTnet/issues/1490\r\nWhen debugging this I tried a number of different workarounds like long running task, dedicated thread, System.Timers.Timer, System.Threading.PeriodicTimer. None of them work. This makes me believe the underlying timer mechanism (System.Threading.TimerQueueTimer) is unreliable on macOS.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eStannieman\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-09-03T22:12:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Jr0qH",
                                           "createdAt":  "2022-09-04T00:45:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e When debugging this I tried a number of different workarounds like long running task, dedicated thread, System.Timers.Timer, System.Threading.PeriodicTimer. None of them work. This makes me believe the underlying timer mechanism (System.Threading.TimerQueueTimer) is unreliable on macOS.\r\n\r\nThanks for trying all these approaches. For comparison, what happens if you just Thread.Sleep in a loop... does that exhibit similarly large spikes? Or use await Task.Run(() =\u003e Thread.Sleep(250))? (Or instead of Thread.Sleep, WaitOne(250) on an AutoResetEvent that\u0027s never set?) ",
                                           "updatedAt":  "2022-09-04T00:45:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JsEbs",
                                           "createdAt":  "2022-09-04T08:36:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tactical-drone",
                                           "body":  "I have also had issues with `Task.Delay`. If your thread pool queues are large for whatever reason I think `Task.Delay` wont work which makes sense. \r\n\r\nTry using `PeriodicTimer` instead. ",
                                           "updatedAt":  "2022-09-04T08:36:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JsLhu",
                                           "createdAt":  "2022-09-04T11:38:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Stannieman",
                                           "body":  "Thread.Slee, ResetEvent and PeriodicTimer don\u0027t. Someone in the Avalonia issue suggested it might be due to a macOS feature called App Nap, and YES, disabling App Nap globally resolves the issue! Though this could affect battery life.\r\n`defaults write NSGlobalDomain NSAppSleepDisabled -bool YES`\r\n\r\nhttps://lapcatsoftware.com/articles/prevent-app-nap.html\r\nThis articale describes a way for an app to opt out of this. So we probably need to PInvoke this. Or is there a place in .NET for platform specific APIs where a more convenient way can be added?\r\n",
                                           "updatedAt":  "2022-09-04T11:38:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JsMLv",
                                           "createdAt":  "2022-09-04T11:54:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e and PeriodicTimer don\u0027t\r\n\r\nThat\u0027s surprising, since PeriodicTimer is based in the same Timer-based mechanism as Task.Delay.\r\n\r\n\u003e So we probably need to PInvoke this.\r\n\r\nYeah, I think this is something the app is going to need to choose to do. I don\u0027t think we should make this decision automatically on behalf of all users.\r\n",
                                           "updatedAt":  "2022-09-04T11:54:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JsM10",
                                           "createdAt":  "2022-09-04T12:09:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Stannieman",
                                           "body":  "Ok then I think this can be closed and I will try to add a switch for this to the macOS specific options for Avalonia. Something similar might be useful for MAUI as well.",
                                           "updatedAt":  "2022-09-04T12:09:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JuDsr",
                                           "createdAt":  "2022-09-05T10:16:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "maxkatz6",
                                           "body":  "@Stannieman I think this issue should be kept open with available workaround. For most applications disabling app nap might decrease user experience. And if the issue is in the runtime, and can be fixed, somebody should pick it up one day. ",
                                           "updatedAt":  "2022-09-05T10:16:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JuI5R",
                                           "createdAt":  "2022-09-05T10:38:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Stannieman",
                                           "body":  "Ok reopened.\r\nFor reference a PR for Avalonia is in the making: https://github.com/AvaloniaUI/Avalonia/pull/8894\r\nSo either each UI technology needs to implement something like this on its own or it can be added to .NET itself.",
                                           "updatedAt":  "2022-09-05T10:38:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JuQIT",
                                           "createdAt":  "2022-09-05T11:13:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e And if the issue is in the runtime\r\n\r\nIt\u0027s not if changing the app nap setting fixes it.\r\n\r\nWhat action is left to do in this repo? Open issues need to be actionable. ",
                                           "updatedAt":  "2022-09-05T11:13:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5J8ICf",
                                           "createdAt":  "2022-09-08T10:01:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "maxkatz6",
                                           "body":  "If runtime team says that this issue can\u0027t be fixed without disabling app nap, then I suppose it can be closed.\r\nI don\u0027t have low level threading and unix knowledge to argue with that.\r\n\r\nThough this behavior at least should be mentioned in the related threading documentation.",
                                           "updatedAt":  "2022-09-08T10:01:36Z"
                                       }
                                   ],
                         "totalCount":  11
                     },
        "title":  "Task.Delay in UI app takes too long on macOS",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/75104",
        "createdAt":  "2022-09-06T04:01:47Z",
        "number":  75104,
        "author":  "hungdoan-groove",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-10-25T23:46:38Z",
        "body":  "### Description\r\nI ported my Service Fabric Application from .NET Framework 4.6.1 to .NET 6.0\r\nIt seems, after the migration: \r\n- .NET 6.0 version will make it easier to hit Thread Starvation. \r\n-  In some cases + heavy load, the .NET 6.0 **has less throughput** than the .NET  Framework version. Is this the side effect of Thread Starvation?\r\n\r\nMy questions are: \r\n- Is the reduction of throughput the result of the Thread Starvation ?. \r\n- Is there any change/optimization in .NET 6.0 compare to .NET Framework?. So that It\u0027s fast in some load, but at some (heavy) load, the .NET 6.0 will easier to hit the Thread Starvation issues than the .NET Framework?\r\n\r\n### Configuration\r\nMy system architecture:\r\nUsers  ----(1)HTTP----\u003e  Service A: Web API  ----(2)Service Fabric remoting----\u003e  Service B: Remoting Service. \r\n\r\nThe logic of my test cases is mostly: \r\n- CPU-sensitive task. \r\n- It has some I/O logic to:\r\n    - Save logs to Azure Storage\r\n    - Save integration message to Event Grid or Azure Storage. \r\n\r\nAzure Service Fabric\r\n- OS: Windows Server \r\n- Load balancing in a cluster group of 05 VMs of Standard_E16ds_v4\r\n- Service A - Web API: Use Kestrel \r\n\r\nLoad tested: via K6\r\n\r\n### Regression?\r\nI did a load test and found that: \r\n1/ In a single thread (1 concurrent user) .NET 6.0 is faster.\r\n2/ In the basic case (say 100 concurrent users) .NET 6.0 version has the same or better Throughput than the .NET Framework. \r\nHowever,\r\n- .NET 6.0 version likely hit Thread Starvation issues: increased the concurrent users, Throughput  decreased, and CPU never goes above 70%\r\n- Within the .NET Framework version, the CPU will likely hit 100% at the 100 concurrent users. But in .NET 6.0 version, 100, 200 or 300 users the CPU is just around 70% max.\r\n\r\n3/ In some complex test cases .NET 6.0 has less Throughput than the .NET Framework. It\u0027s about 20-50% less, and the CPU is just around 70%.\r\n\r\n\r\n### Data\r\n\r\nN/A\r\n\r\n### Analysis\r\n1/ It seems there is a Thread Starvation in .NET 6.0\r\n2/ Does that mean It\u0027s easier to hit Thread Starvation than the .NET Framework? \r\n3/ Is there any change/optimization in .NET 6.0 compare to .NET Framework?. So that It\u0027s fast in the usual load, but at some load, the .NET 6.0 will easier to hit the Thread Starvation issues compare to the .NET Framework\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOTPcDqQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5JxMa7",
                                           "createdAt":  "2022-09-06T04:01:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-09-06T04:01:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JxNR6",
                                           "createdAt":  "2022-09-06T04:08:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\nI ported my Service Fabric Application from .NET Framework 4.6.1 to .NET 6.0\r\nIt seems, after the migration: \r\n- .NET 6.0 version will make it easier to hit Thread Starvation. \r\n-  In some cases + heavy load, the .NET 6.0 **has less throughput** than the .NET  Framework version. Is this the side effect of Thread Starvation?\r\n\r\nMy questions are: \r\n- Is the reduction of throughput the result of the Thread Starvation ?. \r\n- Is there any change/optimization in .NET 6.0 compare to .NET Framework?. So that It\u0027s fast in some load, but at some (heavy) load, the .NET 6.0 will easier to hit the Thread Starvation issues compare to the .NET Framework?\r\n\r\n### Configuration\r\nMy system architecture:\r\nUsers  ----(1)HTTP----\u003e  Service A: Web API  ----(2)Service Fabric remoting----\u003e  Service B: Remoting Service. \r\n\r\nThe logic of my test cases is mostly: \r\n- CPU-sensitive task. \r\n- It has some I/O logic to save logs to Azure Storage \r\n\r\nAzure Service Fabric\r\n- OS: Windows Server \r\n- Load balancing in a cluster group of 05 VMs of Standard_E16ds_v4\r\n- Service A - Web API: Use Kestrel \r\n\r\nLoad tested: via K6\r\n\r\n### Regression?\r\nI did a load test and found that: \r\n1/ In a single thread (1 concurrent user) .NET 6.0 is faster.\r\n2/ In the basic case (say 100 concurrent users) .NET 6.0 version has the same or better Throughput than the .NET Framework. \r\nHowever,\r\n- .NET 6.0 version likely hit Thread Starvation issues: increased the concurrent users, Throughput  decreased, and CPU never goes above 70%\r\n- Within the .NET Framework version, the CPU will likely hit 100% at the 100 concurrent users. But in .NET 6.0 version, 100, 200 or 300 users the CPU is just around 70% max.\r\n\r\n3/ In some complex test cases .NET 6.0 has less Throughput than the .NET Framework. It\u0027s about 20-50% less, and the CPU is just around 70%.\r\n\r\n\r\n### Data\r\n\r\nN/A\r\n\r\n### Analysis\r\n1/ It seems there is a Thread Starvation in .NET 6.0\r\n2/ Does that mean It\u0027s easier to hit Thread Starvation than the .NET Framework? \r\n3/ Is there any change/optimization in .NET 6.0 compare to .NET Framework?. So that It\u0027s fast in the usual load, but at some load, the .NET 6.0 will easier to hit the Thread Starvation issues compare to the .NET Framework\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ehungdoan-groove\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `tenet-performance`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-09-06T04:08:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JxNyz",
                                           "createdAt":  "2022-09-06T04:12:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCrxZQA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hungdoan-groove",
                                                                               "createdAt":  "2022-09-07T01:46:14Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "Are you creating (pooling?) threads yourself, queuing work to the thread pool manually, using Tasks, ..?",
                                           "updatedAt":  "2022-09-06T04:12:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Jx-nO",
                                           "createdAt":  "2022-09-06T08:38:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hungdoan-groove",
                                           "body":  "@danmoseley yes there is a `Task.Run()` to queue a thread manually.  I also agree that creating extra threads would lead to Thread Starvation earlier. \r\nBut both the .NET Framework and .NET 6.0 versions have that same logic.\r\n\r\nWhy would .NET 6.0 get Thread Starvation, but .NET Framework?",
                                           "updatedAt":  "2022-09-06T08:39:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5J0_ww",
                                           "createdAt":  "2022-09-06T20:42:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "@kouvel to provide some guidance. ",
                                           "updatedAt":  "2022-09-06T20:42:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KRz2q",
                                           "createdAt":  "2022-09-14T03:23:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "\u003e Is the reduction of throughput the result of the Thread Starvation ?.\r\n\r\nStarvation in the thread pool may result in lower throughput, but lower throughput doesn\u0027t imply that there is starvation.\r\n\r\n\u003e Is there any change/optimization in .NET 6.0 compare to .NET Framework?. So that It\u0027s fast in some load, but at some (heavy) load, the .NET 6.0 will easier to hit the Thread Starvation issues than the .NET Framework?\r\n\r\nI\u0027m not aware of any changes that would cause starvation in the thread pool to be more likely in .NET 6 compared with .NET Framework.\r\n\r\nFor the app running on .NET Framework, does it configure the runtime in some way, either through environment variables, *.exe.config file, or through the registry? For example, enabling server GC, or configuring the thread pool, etc.?\r\n\r\n.NET 6 may need to be configured a bit differently, so make sure those configuration settings are also migrated equivalently.\r\n\r\nIt sounds like it\u0027s relatively easy to reproduce the issue under load testing. I would suggest collecting two perf profiles using [`PerfView`](https://github.com/Microsoft/perfview#perfview-overview), one for the app running on .NET Framework, and one for the app running on .NET 6. So that they can be compared, have the apps under the same amount of load where .NET 6 has lower throughput. A profile using default settings should be fine to start with. Profiling can slow down the app, so check whether the throughput is still lower in .NET 6 while profiling. A comparison of the profiles may tell more about what\u0027s happening, the link above to the `PerfView` overview has some useful links to information on analyzing profiles.\r\n\r\nTo look for thread pool starvation, in the Events views look at the [`ThreadPoolWorkerThreadAdjustment/Adjustment`](https://docs.microsoft.com/en-us/dotnet/framework/performance/thread-pool-etw-events#threadpoolworkerthreadadjustmentadjustment) with `Reason=Starvation`, and [`IOThreadCreate`](https://docs.microsoft.com/en-us/dotnet/framework/performance/thread-pool-etw-events#iothreadcreate_v1) events with `Count` showing a thread count higher than the processor count.",
                                           "updatedAt":  "2022-09-14T03:23:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KR7sL",
                                           "createdAt":  "2022-09-14T04:24:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODEkrYw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "JiriZidek",
                                                                               "createdAt":  "2023-08-23T17:27:18Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "There are reasons like the http.sys request queue helped throttle incoming work so the app could recover. What does the app do? Are you calling blocking APIs? It’s possible you’re now doing sync over async instead of just sync IO. That would make starvation happen more easily.",
                                           "updatedAt":  "2022-09-14T04:24:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KW62k",
                                           "createdAt":  "2022-09-15T03:03:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hungdoan-groove",
                                           "body":  "@kouvel thanks for the useful information,  I will check it out, especially the `server GC` as I think I\u0027m using this mode. \r\n\r\n@davidfowl http.sys was one of my considerations. \r\n- At first, we used the http.sys, and the throughput was not really good. Then I switched to Kestrel as the doc recommends for the throughput, cross-platform \u0026 performance. As the result, the throughput is improved, but that still does not meet expectations. \r\n- I also wonder if the server queue is the problem and tried with race limiter (but It seems a kind of middleware I think - Microsoft.AspNetCore.ConcurrencyLimiter), but there is no improvement and started to receive many 503 errors\r\n\r\np/s @davidfowl Is there any documentation about the queue length/mechanism of http.sys, e.requestQueueLimit or so ?, I tried to look around but see no clear documentation about that - What I\u0027m doing is refer to the code here https://github.com/dotnet/aspnetcore/blob/main/src/Servers/HttpSys/src/HttpSysOptions.cs",
                                           "updatedAt":  "2022-09-15T03:06:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KXKN7",
                                           "createdAt":  "2022-09-15T05:03:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "It\u0027s less about HTTP.sys and more trying to explain where the differences might be coming from. If you were doing blocking IO before, **maybe** the HTTP.sys queue was saving you from really bad cases.\r\n\r\n\u003e I also wonder if the server queue is the problem and tried with race limiter (but It seems a kind of middleware I think - Microsoft.AspNetCore.ConcurrencyLimiter), but there is no improvement and started to receive many 503 errors\r\n\r\nThis should help if this was indeed the problem. Though we\u0027d need to see how you configured it.\r\n\r\n\u003e p/s @davidfowl Is there any documentation about the queue length/mechanism of http.sys, e.requestQueueLimit or so ?, I tried to look around but see no clear documentation about that - What I\u0027m doing is refer to the code here\r\n\r\nSomewhere deep in the guts of windows documentation, I believe the default is 1000 based on this doc https://docs.microsoft.com/en-us/windows/win32/http/configuring-properties-in-http-version-2-0 but @Tratcher can correct me.\r\n\r\n\r\nWhat is your application doing that you are experiencing threadpool starvation? Were you using HttpListener on .NET Framework?",
                                           "updatedAt":  "2022-09-15T05:03:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5M9wOp",
                                           "createdAt":  "2022-10-25T23:46:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xiaomi7732",
                                           "body":  "@hungdoan-groove by chance you have switched the host environment for the application?\r\n\r\n**MinThread** count in the pool by default aligns to the processor number. That might be another different setting to watch for.\r\n\r\nOtherwise, I would suggest taking a `dotnet-trace` to find out whether thread starvation is happening.",
                                           "updatedAt":  "2022-10-25T23:46:38Z"
                                       }
                                   ],
                         "totalCount":  10
                     },
        "title":  "Why does my .NET 6.0 application hit Thread Starvation easier than the .NET Framework ?",
        "labels":  [
                       "area-System.Threading",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/75874",
        "createdAt":  "2022-09-20T03:39:18Z",
        "number":  75874,
        "author":  "VSadov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC73BzA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "GSPP",
                                            "createdAt":  "2022-09-23T18:35:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "davidOSUL",
                                            "createdAt":  "2023-03-19T07:15:06Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hamarb123",
                                            "createdAt":  "2024-10-16T07:59:27Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2022-09-24T16:52:37Z",
        "body":  "### Background and motivation\r\n\r\nUnlike `System.Threading.Volatile.Read`, the `System.Threading.Relaxed.Read` only defeats compiler optimizations. \r\n\r\nThis is basically an official`VolatileReadWithoutBarrier` (see: https://github.com/dotnet/runtime/blob/118a1628c959e5c5895f9971104739c38cdc253b/src/libraries/System.Threading/tests/InterlockedTests.cs#L682)\r\n\r\nThe read will keep its order with respect to other memory operations (in singlethreaded/program order, not in the order of sideeffects), and used reads will not be coalesced with other reads from the same location.\r\n\r\nSuch read would be paired with `Interlocked.MemoryBarrierProcessWide` or could be used to poll a local that could be changed on another thread. \r\nA `Volatile.Read` could be used for the same purpose, but will add unnecessary guarantees of the order of the actual read.\r\n\r\nWe can, optionally, add a requirement that the read is atomic. \r\nA better name than \"Relaxed\" may exist too.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Threading;\r\n\r\npublic class Relaxed\r\n{\r\n    public T Read\u003cT\u003e(ref T location) where T: class;\r\n\r\n    public int Read(ref int location);\r\n\r\n    public double Read(ref double location);\r\n. . .\r\n\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n\r\n\r\n### Alternative Designs\r\n\r\nCan use `Volatile.Read` or hand-written uninlinable methods with sole purpose of reading some variable.\r\n\r\n### Risks\r\n\r\nNo risk, this is completely additive API.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOSpzl3A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5KnOXc",
                                           "createdAt":  "2022-09-20T03:39:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nUnlike `System.Threading.Volatile.Read`, the `System.Threading.Relaxed.Read` only defeats compiler optimizations. \r\n\r\nThis is basically an official`VolatileReadWithoutBarrier` (see: https://github.com/dotnet/runtime/blob/118a1628c959e5c5895f9971104739c38cdc253b/src/libraries/System.Threading/tests/InterlockedTests.cs#L682)\r\n\r\nThe read will not be reordered with other memory operations (in program order, not in the order of sideeffects), and used read will not be coalesced with reads from the same location.\r\n\r\nSuch read would be paired with `Interlocked.MemoryBarrierProcessWide` or could be used to poll a local that could be changed on another thread. \r\nA `Volatile.Read` could be used of the same purpose, but will add unnecessary guarantees of the order of the actual read.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Threading;\r\n\r\npublic class Relaxed\r\n{\r\n    [Intrinsic]\r\n    public T Read(ref T location);\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\n// Fancy the value\r\nvar c = new MyFancyCollection\u003cint\u003e();\r\nc.Fancy(42);\r\n\r\n// Getting the values out\r\nforeach (var v in c)\r\n    Console.WriteLine(v);\r\n```\r\n\n\n### Alternative Designs\n\nCan use `Volatile.Read` or hand-written uninlinable methods with sole purpose of reading some variable.\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eVSadov\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-09-20T03:39:30Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "[API Proposal]:  System.Threading.Relaxed.Read",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading",
                       "memory model"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/75968",
        "createdAt":  "2022-09-21T13:50:50Z",
        "number":  75968,
        "author":  "a74nh",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-09-26T15:10:26Z",
        "body":  "When using Arm64 `Hisilicon D05` (64x Cortex-A72 cores) with Ubuntu 18.04.\r\n\r\nRunning `./src/tests/run.sh Checked`\r\n\r\nThe following tests:\r\n- Interop/UnmanagedCallersOnlyBasic/UnmanagedCallersOnlyBasicTest/UnmanagedCallersOnlyBasicTest.sh\r\n- profiler/unittest/getappdomainstaticaddress/getappdomainstaticaddress.sh\r\n- profiler/unittest/releaseondetach/releaseondetach.sh\r\n\r\nFail with:\r\n```\r\nAssert failure(PID 5742 [0x0000166e], Thread: 5752 [0x1678]): pThread\r\n                   File: /home/alahay01/dotnet/runtime/src/coreclr/vm/threads.inl Line: 43\r\n                   Image: /home/alahay01/dotnet/runtime/artifacts/tests/coreclr/Linux.arm64.Checked/Tests/Core_Root/corerun\r\n```\r\n\r\nCuriously when running in gdb, all the tests fail with the same segfault:\r\n```\r\nThread 11 \"corerun\" received signal SIGSEGV, Segmentation fault.\r\n[Switching to Thread 0xffbf0db9c1d0 (LWP 52198)]\r\n0x0000fffff7e2f478 in ?? () from /usr/lib/aarch64-linux-gnu/libstdc++.so.6\r\n(gdb) bt\r\n#0  0x0000fffff7e2f478 in ?? () from /usr/lib/aarch64-linux-gnu/libstdc++.so.6\r\n#1  0x0000fffff7f80088 in start_thread () from /lib/aarch64-linux-gnu/libpthread.so.0\r\n#2  0x0000fffff7bf80cc in ?? () from /lib/aarch64-linux-gnu/libc.so.6\r\n```\r\n\r\n\r\nWhen running the exact same tests on an Altra with Ubuntu 18.04, these tests pass ok.\r\n\r\nThe Hisilicon D05 is a bit of an obscure box, so I\u0027m not really expecting anyone else to be running dotnet on one. However, running on different types of boxes is a great way of exposing timing related bugs and other issues that will bite eventually.\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOSsqraQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5Kupe5",
                                           "createdAt":  "2022-09-21T13:50:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-09-21T13:50:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Ku1i1",
                                           "createdAt":  "2022-09-21T14:26:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "a74nh",
                                           "body":  "@kunalspathak - not sure if you\u0027ve seen a similar issue anywhere else?\r\n\r\nCurrently running the tests across some our other box types to see if anything else fails.",
                                           "updatedAt":  "2022-09-21T14:26:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Kv_-K",
                                           "createdAt":  "2022-09-21T18:48:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nWhen using Arm64 `Hisilicon D05` (64x Cortex-A72 cores) with Ubuntu 18.04.\r\n\r\nRunning `./src/tests/run.sh Checked`\r\n\r\nThe following tests:\r\n- Interop/UnmanagedCallersOnlyBasic/UnmanagedCallersOnlyBasicTest/UnmanagedCallersOnlyBasicTest.sh\r\n- profiler/unittest/getappdomainstaticaddress/getappdomainstaticaddress.sh\r\n- profiler/unittest/releaseondetach/releaseondetach.sh\r\n\r\nFail with:\r\n```\r\nAssert failure(PID 5742 [0x0000166e], Thread: 5752 [0x1678]): pThread\r\n                   File: /home/alahay01/dotnet/runtime/src/coreclr/vm/threads.inl Line: 43\r\n                   Image: /home/alahay01/dotnet/runtime/artifacts/tests/coreclr/Linux.arm64.Checked/Tests/Core_Root/corerun\r\n```\r\n\r\nCuriously when running in gdb, all the tests fail with the same segfault:\r\n```\r\nThread 11 \"corerun\" received signal SIGSEGV, Segmentation fault.\r\n[Switching to Thread 0xffbf0db9c1d0 (LWP 52198)]\r\n0x0000fffff7e2f478 in ?? () from /usr/lib/aarch64-linux-gnu/libstdc++.so.6\r\n(gdb) bt\r\n#0  0x0000fffff7e2f478 in ?? () from /usr/lib/aarch64-linux-gnu/libstdc++.so.6\r\n#1  0x0000fffff7f80088 in start_thread () from /lib/aarch64-linux-gnu/libpthread.so.0\r\n#2  0x0000fffff7bf80cc in ?? () from /lib/aarch64-linux-gnu/libc.so.6\r\n```\r\n\r\n\r\nWhen running the exact same tests on an Altra with Ubuntu 18.04, these tests pass ok.\r\n\r\nThe Hisilicon D05 is a bit of an obscure box, so I\u0027m not really expecting anyone else to be running dotnet on one. However, running on different types of boxes is a great way of exposing timing related bugs and other issues that will bite eventually.\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ea74nh\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`arch-arm64`, `area-System.Threading`, `os-linux`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-09-21T18:48:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Kyqtp",
                                           "createdAt":  "2022-09-22T09:55:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "a74nh",
                                           "body":  "Interestingly, when run across all the box types in our CI, these tests passed. This included a Hisilicon D05.\r\n\r\nThe difference is that the issue reported here was not run inside a docker image. So this could be due to an issue with a slightly different version of glibc etc. I\u0027ll investigate further.",
                                           "updatedAt":  "2022-09-22T09:55:24Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Pthread assert failures on Arm64 Hisilicon D05",
        "labels":  [
                       "arch-arm64",
                       "area-System.Threading",
                       "os-linux"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/76230",
        "createdAt":  "2022-09-27T06:42:20Z",
        "number":  76230,
        "author":  "pzaj2",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCqwK3Q==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pzaj2",
                                            "createdAt":  "2022-09-27T06:47:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "svick",
                                            "createdAt":  "2022-09-27T13:39:55Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2022-09-28T15:30:47Z",
        "body":  "### Background and motivation\r\n\r\nThe idea for this proposal came to me as I was helping to identify an issue a couple of weeks ago where a complex block of code would not release a semaphore in an edge case.\r\n\r\nI have since then built a library to solve this issue (pending internal company review before being published to NuGet) and raised a change proposal with the #C language (https://github.com/dotnet/csharplang/discussions/6466). \r\n\r\nThe consensus around my initial proposal to add the support directly to the C# language was that it adds value but should instead be implemented in the BCL, so here is my proposal. \r\n\r\nThe premise is that synchronization mechanisms can freeze the whole system when implemented improperly and in many cases may be hard to debug/identify. I would therefore like to propose changing the API to make it safer to consume synchronization primitives [in my example, `SemaphoreSlim`]. Please keep in mind that ideally, all synchronization primitives should be aligned and implement the disposable pattern.\r\n\r\n### API Proposal\r\n\r\nPlease keep in mind that this proposal is merely to depict what I have in mind. Implementing it this way would be a substantial change and therefore, I believe the direction needs to be discussed.\r\n\r\n```csharp\r\nnamespace System.Threading;\r\n\r\ninternal class Guard: IDisposable {\r\n    private readonly SemaphoreSlim _guarded;\r\n    internal Guard(SemaphoreSlim guarded) {\r\n        _guarded = guarded;\r\n    }\r\n\r\n    public void Dispose()\r\n    {\r\n        _guarded.Release();\r\n    }\r\n}\r\n```\r\n\r\n```csharp\r\npublic class SemaphoreSlim : IDisposable {\r\n    ... ctors and existing implementation [minus the modified methods]\r\n\r\n    public IDisposable Wait() { // This would return an instance of `System.Threading.Guard`\r\n\r\n    } \r\n\r\n    public Task\u003cIDisposable\u003e WaitAsync() { // This would return an instance of `System.Threading.Guard`\r\n\r\n    } \r\n\r\n   ... remaining overloads of `Wait` and `WaitAsync`, also modified to return `IDisposable`\r\n}\r\n```\r\n\r\n### API Usage\r\n\r\n```csharp\r\npublic class SynchronizedProcessor {\r\n    private static SemaphoreSlim _sync = new SemaphoreSlim(1, 1);\r\n\r\n    ... ctors, etc.\r\n\r\n    public void Process(params object[] args) {\r\n    \r\n        using (_sync.Wait()) {\r\n            ProcessInternal(args);\r\n        }\r\n    }\r\n\r\n    private void ProcessInternal(params object[] args) {\r\n        ... operations requiring synchronization\r\n    }\r\n}\r\n```\r\n\r\n### Alternative Designs\r\n\r\nSince I appreciate that such a proposal is invasive, I\u0027d be more than happy to consider alternatives. Some of the alternatives that come to my mind are:\r\n- creating a new set of primitives [1:1 with existing primitives] that would follow this convention, implementing the disposable pattern\r\n- creating a set of wrappers around existing primitives that would follow this convention, be referenced by the documentation \u0026 doc comments on the existing primitives as a safer alternative\r\n- extending the existing primitives with a set of new methods that implement the disposable pattern (not sure about naming, for semaphores it could be `Claim` and `ClaimAsync`? Definitely open to suggestions)\r\n\r\n### Risks\r\n\r\nTo my knowledge, the only risk that may proposal introduces is breaking changes to `SemaphoreSlim` and the other synchronization primitives.\r\n\r\nThat said, the alternative designs/proposals eliminate this problem, although they may not be as \"successful\" as the main proposal as they do not enforce the disposable pattern. This could only work if enough effort is put towards promoting this solution as safer and more convenient throughout the documentation, in-code docs and contributions from the community in a form of articles, posts, etc.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOSxSDeQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5LC6Sy",
                                           "createdAt":  "2022-09-27T06:42:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-09-27T06:42:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5LDH6r",
                                           "createdAt":  "2022-09-27T07:40:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\r\n\r\nThe idea for this proposal came to me as I was helping to identify an issue a couple of weeks ago where a complex block of code would not release a semaphore in an edge case.\r\n\r\nI have since then built a library to solve this issue (pending internal company review before being published to NuGet) and raised a change proposal with the #C language (https://github.com/dotnet/csharplang/discussions/6466). \r\n\r\nThe consensus around my initial proposal to add the support directly to the C# language was that it adds value but should instead be implemented in the BCL, so here is my proposal. \r\n\r\nThe premise is that synchronization mechanisms can freeze the whole system when implemented improperly and in many cases may be hard to debug/identify. I would therefore like to propose changing the API to make it safer to consume synchronization primitives [in my example, `SemaphoreSlim`]. Please keep in mind that ideally, all synchronization primitives should be aligned and implement the disposable pattern.\r\n\r\n### API Proposal\r\n\r\nPlease keep in mind that this proposal is merely to depict what I have in mind. Implementing it this way would be a substantial change and therefore, I believe the direction needs to be discussed.\r\n\r\n```csharp\r\nnamespace System.Threading;\r\n\r\ninternal class Guard: IDisposable {\r\n    private readonly SemaphoreSlim _guarded;\r\n    internal Guard(SemaphoreSlim guarded) {\r\n        _guarded = guarded;\r\n    }\r\n\r\n    public void Dispose()\r\n    {\r\n        _guarded.Release();\r\n    }\r\n}\r\n```\r\n\r\n```csharp\r\npublic class SemaphoreSlim : IDisposable {\r\n    ... ctors and existing implementation [minus the modified methods]\r\n\r\n    public IDisposable Wait() { // This would return an instance of `System.Threading.Guard`\r\n\r\n    } \r\n\r\n    public Task\u003cIDisposable\u003e WaitAsync() { // This would return an instance of `System.Threading.Guard`\r\n\r\n    } \r\n\r\n   ... remaining overloads of `Wait` and `WaitAsync`, also modified to return `IDisposable`\r\n}\r\n```\r\n\r\n### API Usage\r\n\r\n```csharp\r\npublic class SynchronizedProcessor {\r\n    private static SemaphoreSlim _sync = new SemaphoreSlim(1, 1);\r\n\r\n    ... ctors, etc.\r\n\r\n    public void Process(params object[] args) {\r\n    \r\n        using (_sync.Wait()) {\r\n            ProcessInternal(args);\r\n        }\r\n    }\r\n\r\n    private void ProcessInternal(params object[] args) {\r\n        ... operations requiring synchronization\r\n    }\r\n}\r\n```\r\n\r\n### Alternative Designs\r\n\r\nSince I appreciate that such a proposal is invasive, I\u0027d be more than happy to consider alternatives. Some of the alternatives that come to my mind are:\r\n- creating a new set of primitives [1:1 with existing primitives] that would follow this convention, implementing the disposable pattern\r\n- creating a set of wrappers around existing primitives that would follow this convention, be referenced by the documentation \u0026 doc comments on the existing primitives as a safer alternative\r\n- extending the existing primitives with a set of new methods that implement the disposable pattern (not sure about naming, for semaphores it could be `Claim` and `ClaimAsync`? Definitely open to suggestions)\r\n\r\n### Risks\r\n\r\nTo my knowledge, the only risk that may proposal introduces is breaking changes to `SemaphoreSlim` and the other synchronization primitives.\r\n\r\nThat said, the alternative designs/proposals eliminate this problem, although they may not be as \"successful\" as the main proposal as they do not enforce the disposable pattern. This could only work if enough effort is put towards promoting this solution as safer and more convenient throughout the documentation, in-code docs and contributions from the community in a form of articles, posts, etc.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003epzaj2\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-09-27T07:40:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5LDH8r",
                                           "createdAt":  "2022-09-27T07:40:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCtc7hQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "svick",
                                                                               "createdAt":  "2022-09-27T10:08:05Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Khitiara",
                                                                               "createdAt":  "2022-10-07T02:17:27Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "Joe4evr",
                                           "body":  "I like the idea, since I\u0027ve also made `IDisposable` wrappers for synchronization primitives on occasion. But I have to point out:\r\n\u003e ```\r\n\u003e    ... remaining overloads of `Wait` and `WaitAsync`, also modified to return `IDisposable`\r\n\u003e ```\r\n\r\nThis is a no-go immediately as changing return types is a [breaking change](https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/breaking-changes.md), so that will never happen. Also, since C# doesn\u0027t support overloading by return type, another name would be needed. (🍝 `WaitLease`/`WaitLeaseAsync`?)\r\n\r\nAdditionally, there\u0027s a strong likelihood these methods should return a public struct so it won\u0027t cost an allocation to use.",
                                           "updatedAt":  "2022-09-27T07:40:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5LDNE9",
                                           "createdAt":  "2022-09-27T08:00:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hez2010",
                                           "body":  "\u003e since C# doesn\u0027t support overloading by return type\n\nC# doesn\u0027t support it, but IL does. ",
                                           "updatedAt":  "2022-09-27T08:00:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5LDwxr",
                                           "createdAt":  "2022-09-27T10:04:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pzaj2",
                                           "body":  "\u003e I like the idea, since I\u0027ve also made `IDisposable` wrappers for synchronization primitives on occasion. But I have to point out:\r\n\u003e \r\n\u003e \u003e ```\r\n\u003e \u003e    ... remaining overloads of `Wait` and `WaitAsync`, also modified to return `IDisposable`\r\n\u003e \u003e ```\r\n\u003e \r\n\u003e This is a no-go immediately as changing return types is a [breaking change](https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/breaking-changes.md), so that will never happen. Also, since C# doesn\u0027t support overloading by return type, another name would be needed. (🍝 `WaitLease`/`WaitLeaseAsync`?)\r\n\u003e \r\n\u003e Additionally, there\u0027s a strong likelihood these methods should return a public struct so it won\u0027t cost an allocation to use.\r\n\r\nI agree that breaking changes may be a no-go, hence my alternative proposals. `WaitLease` seems to make sense, definitely better than `Claim` if you ask me. Overloading by return type would be nice, for sure, but as you said - C# doesn\u0027t support it.\r\n\r\nAs for returning a public struct - my snippets are merely an example. I\u0027m, however, curious as to how this would affect allocation or lack thereof. Any documentation/articles that explain that in more detail? I\u0027m keen to see where this is coming from.\r\n\r\nThanks for the comment, it is definitely a step in the right direction from my point of view.",
                                           "updatedAt":  "2022-09-27T10:05:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5LD0pB",
                                           "createdAt":  "2022-09-27T10:19:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCs4GWA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "pzaj2",
                                                                               "createdAt":  "2022-09-27T11:44:15Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pzaj2",
                                                                               "createdAt":  "2022-09-27T11:44:22Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "svick",
                                           "body":  "\u003e As for returning a public struct - my snippets are merely an example. I\u0027m, however, curious as to how this would affect allocation or lack thereof. Any documentation/articles that explain that in more detail? I\u0027m keen to see where this is coming from.\r\n\r\nIn your snippet, `Guard` is a `class`, so it is allocated on the heap. If you create it every time `WaitLease` is called, then that\u0027s an extra allocation for every call. If you create it once per `SemaphoreSlim`, then that\u0027s still an extra allocation and it increases the size of `SemaphoreSlim` (because it needs to be stored in a field). Just changing `Guard` to a `struct` wouldn\u0027t help, because value types are boxed when converted to an interface like `IDisposable` and boxing requires an allocation.\r\n\r\nBut directly returning a `public struct`, without converting to `IDisposable`, does not make any allocations.",
                                           "updatedAt":  "2022-09-27T10:19:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5LELi8",
                                           "createdAt":  "2022-09-27T11:49:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCs4OYQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pzaj2",
                                                                               "createdAt":  "2022-09-27T12:19:02Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "bjornen77",
                                           "body":  "I agree, returning public struct will reduce allocations. Also returning a ValueTask\u003cT\u003e instead of Task\u003cT\u003e would make this completely allocation free.\r\n\r\n```\r\npublic readonly struct Guard: IDisposable { }\r\n\r\npublic ValueTask\u003cGuard\u003e WaitLeaseAsync()  {  } \r\n```",
                                           "updatedAt":  "2022-09-27T11:50:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5LE8pv",
                                           "createdAt":  "2022-09-27T14:25:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Also returning a ValueTask instead of Task would make this completely allocation free\r\n\r\nOnly when the primitive could be acquired immediately / synchronously.  SemaphoreSlim.WaitAsync itself will allocate a Task if the semaphore can\u0027t currently be acquired, and then the wrapper method returning a ValueTask would also need to either allocate its own continuation task (which is what would happen under the covers if that method were `async ValueTask`), or it would need to entail some kind of pooling, which might reduce allocation but has its own costs to consider.  _If_ we were to add a method like this, making it return `ValueTask` would be fine, I\u0027m just pointing out it wouldn\u0027t be \"completely allocation free\".\r\n\r\n\u003e But directly returning a public struct, without converting to IDisposable, does not make any allocations.\r\n\r\nThis is true, but it\u0027s also one of the reasons we haven\u0027t added such methods to these types in the past.  Generally developers expect IDisposable.Dispose to be idempotent, but without allocating, we wouldn\u0027t be able to guarantee that, and in the case of a type like SemaphoreSlim, multiple disposes would then lead to multiple releases, which could silently lead to corruption (due to allowing more concurrency than was intended to be allowed).\r\n\r\nThat\u0027s not to say we _can\u0027t_ add methods like those proposed, but if we added it with the lease as a class, we\u0027d be allocating, and if we added it with the lease as a struct, we\u0027d risk this kind of misuse.  As such until now we\u0027ve left it for developers to do in their own code bases and choose for themselves which poison they prefer.",
                                           "updatedAt":  "2022-09-27T14:25:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5LFCGg",
                                           "createdAt":  "2022-09-27T14:41:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bjornen77",
                                           "body":  "\u003e I\u0027m just pointing out it wouldn\u0027t be \"completely allocation free\".\r\n\r\nYes, this is true. I meant allocation free in best case scenario :)\r\n\r\n\u003e multiple disposes would then lead to multiple releases,\r\n\r\nCould this be solved in the guard struct by also having a bool field and use that boolean to make sure SemephoreSlim release is called only once using Interlocked exchange?\r\n",
                                           "updatedAt":  "2022-09-27T14:41:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5LFCpN",
                                           "createdAt":  "2022-09-27T14:43:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Could this be solved in the guard struct by also having a bool field and use that boolean to make sure SemephoreSlim release is called only once using Interlocked exchange?\r\n\r\nThat won\u0027t help if the struct is copied.",
                                           "updatedAt":  "2022-09-27T14:43:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5LFGh1",
                                           "createdAt":  "2022-09-27T14:54:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bjornen77",
                                           "body":  "Also true.. There are lot of small things that could go wrong if not careful as you say :)\r\n\r\nIf this will be added I think that documentation on how to use this properly will be important.",
                                           "updatedAt":  "2022-09-27T14:54:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5LFIN5",
                                           "createdAt":  "2022-09-27T14:59:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bjornen77",
                                           "body":  "The \"life time\" of the SemephoreSlim is also returned as it is referenced in the guard class/struct.  Therefore it is necessary to keep that object alive(not disposed) as long as the guard class/struct is used. No problem if it is static, but otherwise. This might not be obvious by user.",
                                           "updatedAt":  "2022-09-27T18:22:46Z"
                                       }
                                   ],
                         "totalCount":  12
                     },
        "title":  "[API Proposal]: Disposable pattern in synchronization primitives",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/76510",
        "createdAt":  "2022-10-02T16:43:28Z",
        "number":  76510,
        "author":  "AliKhalili",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCvaxtQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Denifia",
                                            "createdAt":  "2023-04-12T02:29:02Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2023-08-09T18:56:56Z",
        "body":  "Sliding window is quite similar to the fixed window approach but different in that it also has a segment per window option. Technically, we can consider fix window algorithm as a special case of sliding window algorithm for resource rate limiting. So, regarding DRY and have a more clear code base, I would suggest remove fix window internal implementation and inherit it from the sliding window class.\r\nThe only needed change is on the fix window constructor initialize base class(sliding window instance) with `SegmentsPerWindow = 1`.\r\n \r\n We can also expect not remarkable performance to degrade with using an array with a segment for fix window.\r\n I am keen to know your thoughts. Thanks\r\ncc: @BrennanConroy ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOS2GqqA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5LYY8P",
                                           "createdAt":  "2022-10-02T16:43:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-10-02T16:43:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5LYaqo",
                                           "createdAt":  "2022-10-02T17:18:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nSliding window is quite similar to the fixed window approach but different in that it also has a segment per window option. Technically, we can consider fix window algorithm as a special case of sliding window algorithm for resource rate limiting. So, regarding DRY and have a more clear code base, I would suggest remove fix window internal implementation and inherit it from the sliding window class.\r\nThe only needed change is on the fix window constructor initialize base class(sliding window instance) with `SegmentsPerWindow = 1`.\r\n \r\n We can also expect not remarkable performance to degrade with using an array with a segment for fix window.\r\n I am keen to know your thoughts. Thanks\r\ncc: @BrennanConroy \n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eAliKhalili\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-10-02T17:18:17Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "System.Threading.RateLimiting Sliding vs Fix windows implementation",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/77314",
        "createdAt":  "2022-10-21T11:15:13Z",
        "number":  77314,
        "author":  "a-ctor",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-07-19T19:03:56Z",
        "body":  "### Background and motivation\n\nWith the removal of `CallContext` it is no longer possible to have a value storage similar to `CallContext`illogical storage (`GetData`/`SetData`). `AsyncLocal\u003cT\u003e` is a good replacement for the logical parts of `CallContext` (`LogicalGetData`/`LogicalSetData`) but it cannot replace the illogical storage. This issue proposes adding back support for illogical values in `AsyncLocal\u003cT\u003e`/`ExecutionContext`.\r\n\r\nIn my company, we use the illogical (the non-flowing) parts of `CallContext` to build a key-value storage that is attached to the current thread of execution and gets cleaned up automatically. Because `CallContext` is no longer supported in .NET, we tried using `AsyncLocal\u003cT\u003e` as a replacement. But we found out that `AsyncLocal\u003cT\u003e` has the opposite behavior of what we want to achieve and even with a custom value changed handler the `CallContext` behavior cannot be recreated. \r\n\r\nA lot of our code depends on the old infrastructure and cannot be changed without investing a lot of resources. Our current workarounds require developers to use special APIs when interacting with threads, tasks, etc. to prevent the flow of values across the thread contexts. This solution is far from perfect and we want to get rid of it again. But we have come to the conclusion that it is not possible for us to recreate the illogical value behavior of `CallContext` without requiring changes to `ExecutionContext`.\r\n\r\nWe therefore propose changes to `AsyncLocal\u003cT\u003e` and `ExecutionContext` that allows for illogical values that do not flow across thread boundaries:\r\n\r\n- `AsyncLocal\u003cT\u003e` gets a read-only flag that marks it as illogical. It is opt-in, so the current behavior does not change.\r\n- `ExecutionContext` checks its async values and if any of them are illogical, it marks itself as illogical. \r\n- `ExecutionContext.Capture` is changed for illogical `ExecutionContext`s. Instead of returning a itself, the `ExeuctionContext` is copied and all the illogical values are removed. The resulting `ExecutionContext` is therefore logical again. This prevents illogical values from being included in a captured `ExecutionContext`. No value change handlers are called on the removed `AsyncLocal\u003cT\u003e` values.\r\n\r\nThe proposed changes should have minimal effects on code that does not opt into illogical values. But all `ExecutionContext` related things are complex and there are probably edge cases that require special attention. Happy to hear your thoughts on the matter, and hope that we can start a discussion about the topic. We are also happy to contribute the change if necessary :)\r\n\r\ncc @davidfowl\n\n### API Proposal\n\nPublic API changes are limited to new constructors in `AsyncLocal\u003cT\u003e` that allow it to be marked as illogical:\r\n\r\n```diff\r\nnamespace System.Threading\r\n{\r\n  public sealed class AsyncLocal\u003cT\u003e : IAsyncLocal\r\n  {\r\n    public AsyncLocal();\r\n  \r\n+   public AsyncLocal(bool isIllogicalValue);\r\n\r\n    public AsyncLocal(Action\u003cAsyncLocalValueChangedArgs\u003cT\u003e\u003e? valueChangedHandler);\r\n    \r\n+   public AsyncLocal(Action\u003cAsyncLocalValueChangedArgs\u003cT\u003e\u003e? valueChangedHandler, bool isIllogical);\r\n\r\n    public T Value { get; set; }\r\n  }\r\n}\r\n```\n\n### API Usage\n\nHere is an example of the illogical `AsyncLocal\u003cT\u003e` in action:\r\n\r\n```c#\r\nvar asyncLocal = new AsyncLocal\u003cint\u003e(true); // marked as illogical\r\nasyncLocal.Value = 4;\r\n\r\nTask.Run(\r\n    () =\u003e\r\n    {\r\n      Console.WriteLine(asyncLocal.Value); // prints 0\r\n    }).Wait();\r\n\r\nvar executionContext = ExecutionContext.Capture();\r\nasyncLocal.Value = 8;\r\n\r\nExecutionContext.Run(executionContext,\r\n    _ =\u003e\r\n    {\r\n      Console.WriteLine(asyncLocal.Value); // prints 0\r\n    }, null);\r\n\r\nConsole.WriteLine(asyncLocal.Value); // prints 8\r\n```\r\n\r\nIn this example there is one implicit `ExecutionContext.Capture` (during `Task.Run`) and one explicit `ExecutionContext.Capture`. Since the `AsyncLocal\u003cT\u003e` is marked as illogical a copy of the `ExecutionContext` is returned with the `AsyncLocal\u003cT\u003e` value removed. Thus the values in the callbacks are set to the default value `0`.\n\n### Alternative Designs\n\nAlternatively a separate type could be introduced that mirrors the APIs of `AsyncLocal\u003cT\u003e` but has illogical value behavior. For example:\r\n\r\n```c#\r\nnamespace System.Threading\r\n{\r\n  public sealed class IllogicalAsyncLocal\u003cT\u003e : IAsyncLocal\r\n  {\r\n    public IllogicalAsyncLocal();\r\n  \r\n    public IllogicalAsyncLocal(Action\u003cAsyncLocalValueChangedArgs\u003cT\u003e\u003e? valueChangedHandler);\r\n    \r\n    public T Value { get; set; }\r\n  }\r\n}\r\n```\n\n### Risks\n\nPerformance/Memory impact should be minimal to code that does not use illogical `AsyncLocal\u003cT\u003e` values.\r\n\r\nThis proposal changes the semantics of capturing an `ExecutionContext` as a new instance can be returned. This might break assumptions of existing code which would cause problems. This affects mainly the runtime codebase as it can get access to the `ExecutionContext` instance without calling `ExecutionContext.Capture` (by accessing `Thread._executionContext`).",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOTx8CnA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5Ms0JD",
                                           "createdAt":  "2022-10-21T11:15:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nWith the removal of `CallContext` it is no longer possible to have a value storage similar to `CallContext`illogical storage (`GetData`/`SetData`). `AsyncLocal\u003cT\u003e` is a good replacement for the logical parts of `CallContext` (`LogicalGetData`/`LogicalSetData`) but it cannot replace the illogical storage. This issue proposes adding back support for illogical values in `AsyncLocal\u003cT\u003e`/`ExecutionContext`.\r\n\r\nIn my company, we use the illogical (the non-flowing) parts of `CallContext` to build a key-value storage that is attached to the current thread of execution and gets cleaned up automatically. Because `CallContext` is no longer supported in .NET, we tried using `AsyncLocal\u003cT\u003e` as a replacement. But we found out that `AsyncLocal\u003cT\u003e` has the opposite behavior of what we want to achieve and even with a custom value changed handler the `CallContext` behavior cannot be recreated. \r\n\r\nA lot of our code depends on the old infrastructure and cannot be changed without investing a lot of resources. Our current workarounds require developers to use special APIs when interacting with threads, tasks, etc. to prevent the flow of values across the thread contexts. This solution is far from perfect and we want to get rid of it again. But we have come to the conclusion that it is not possible for us to recreate the illogical value behavior of `CallContext` without requiring changes to `ExecutionContext`.\r\n\r\nWe therefore propose changes to `AsyncLocal\u003cT\u003e` and `ExecutionContext` that allows for illogical values that do not flow across thread boundaries:\r\n\r\n- `AsyncLocal\u003cT\u003e` gets a read-only flag that marks it as illogical. It is opt-in, so the current behavior does not change.\r\n- `ExecutionContext` checks its async values and if any of them are illogical, it marks itself as illogical. \r\n- `ExecutionContext.Capture` is changed for illogical `ExecutionContext`s. Instead of returning a itself, the `ExeuctionContext` is copied and all the illogical values are removed. The resulting `ExecutionContext` is therefore logical again. This prevents illogical values from being included in a captured `ExecutionContext`. No value change handlers are called on the removed `AsyncLocal\u003cT\u003e` values.\r\n\r\nThe proposed changes should have minimal effects on code that does not opt into illogical values. But all `ExecutionContext` related things are complex and there are probably edge cases that require special attention. Happy to hear your thoughts on the matter, and hope that we can start a discussion about the topic. We are also happy to contribute the change if necessary :)\r\n\r\ncc @davidfowl\n\n### API Proposal\n\nPublic API changes are limited to new constructors in `AsyncLocal\u003cT\u003e` that allow it to be marked as illogical:\r\n\r\n```diff\r\nnamespace System.Threading\r\n{\r\n  public sealed class AsyncLocal\u003cT\u003e : IAsyncLocal\r\n  {\r\n    public AsyncLocal();\r\n  \r\n+   public AsyncLocal(bool isIllogicalValue);\r\n\r\n    public AsyncLocal(Action\u003cAsyncLocalValueChangedArgs\u003cT\u003e\u003e? valueChangedHandler);\r\n    \r\n+   public AsyncLocal(Action\u003cAsyncLocalValueChangedArgs\u003cT\u003e\u003e? valueChangedHandler, bool isIllogical);\r\n\r\n    public T Value { get; set; }\r\n  }\r\n}\r\n```\n\n### API Usage\n\nHere is an example of the illogical `AsyncLocal\u003cT\u003e` in action:\r\n\r\n```c#\r\nvar asyncLocal = new AsyncLocal\u003cint\u003e(true); // marked as illogical\r\nasyncLocal.Value = 4;\r\n\r\nTask.Run(\r\n    () =\u003e\r\n    {\r\n      Console.WriteLine(asyncLocal.Value); // prints 0\r\n    }).Wait();\r\n\r\nvar executionContext = ExecutionContext.Capture();\r\nasyncLocal.Value = 8;\r\n\r\nExecutionContext.Run(executionContext,\r\n    _ =\u003e\r\n    {\r\n      Console.WriteLine(asyncLocal.Value); // prints 0\r\n    }, null);\r\n\r\nConsole.WriteLine(asyncLocal.Value); // prints 8\r\n```\r\n\r\nIn this example there is one implicit `ExecutionContext.Capture` (during `Task.Run`) and one explicit `ExecutionContext.Capture`. Since the `AsyncLocal\u003cT\u003e` is marked as illogical a copy of the `ExecutionContext` is returned with the `AsyncLocal\u003cT\u003e` value removed. Thus the values in the callbacks are set to the default value `0`.\n\n### Alternative Designs\n\nAlternatively a separate type could be introduced that mirrors the APIs of `AsyncLocal\u003cT\u003e` but has illogical value behavior. For example:\r\n\r\n```c#\r\nnamespace System.Threading\r\n{\r\n  public sealed class IllogicalAsyncLocal\u003cT\u003e : IAsyncLocal\r\n  {\r\n    public IllogicalAsyncLocal();\r\n  \r\n    public IllogicalAsyncLocal(Action\u003cAsyncLocalValueChangedArgs\u003cT\u003e\u003e? valueChangedHandler);\r\n    \r\n    public T Value { get; set; }\r\n  }\r\n}\r\n```\n\n### Risks\n\nPerformance/Memory impact should be minimal to code that does not use illogical `AsyncLocal\u003cT\u003e` values.\r\n\r\nThis proposal changes the semantics of capturing an `ExecutionContext` as a new instance can be returned. This might break assumptions of existing code which would cause problems. This affects mainly the runtime codebase as it can get access to the `ExecutionContext` instance without calling `ExecutionContext.Capture` (by accessing `Thread._executionContext`).\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ea-ctor\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-10-21T11:15:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5MuVZH",
                                           "createdAt":  "2022-10-21T16:53:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCuX6ug==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Joe4evr",
                                                                               "createdAt":  "2022-10-24T14:17:50Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "It would be helpful to know how you were using `CallContext`, and what kind of values were stored there, and in what context (heh) you were using it in the first place (ie, asp net api, client application, etc).  In some cases the data you\u0027re flowing may already be flowed in other ways with the async context (Culture usually is, for example).\r\n\r\nThat aside... \r\n\u003e A lot of our code depends on the old infrastructure and cannot be changed without investing a lot of resources.\r\n\r\nIt\u0027s possible the recommendation of this team is \"be explicit about the values you\u0027re passing, and don\u0027t rely on an implicit calling context\" (as a point of personal preference, I dislike even culture info being implicitly flowed).  Or some form of \"use `Task\u003cT\u003e`, don\u0027t manually manage threads\".\r\n\r\nnit: `Illogical` is probably not correct here",
                                           "updatedAt":  "2022-10-21T16:53:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5M1hgH",
                                           "createdAt":  "2022-10-24T14:12:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GSPP",
                                           "body":  "Do I understand correctly that you wish to store key-value pairs specific to each thread or task?\r\n\r\nIn that case, you could maintain a `ConditionalWeakTable\u003cThread/Task, Dictionary\u003cobject, object\u003e\u003e`. This would clean up automatically. `Task` would be looked up first. `Thread` would be the fallback.\r\n",
                                           "updatedAt":  "2022-10-24T14:12:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NExsU",
                                           "createdAt":  "2022-10-27T07:18:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "a-ctor",
                                           "body":  "\u003e It would be helpful to know how you were using `CallContext`, and what kind of values were stored there, and in what context (heh) you were using it in the first place (ie, asp net api, client application, etc). In some cases the data you\u0027re flowing may already be flowed in other ways with the async context (Culture usually is, for example).\r\n\r\nIt is not about the values stored in the `CallContext`, but rather the lifetime that these values had. In my example above I used `int` as value but the value behavior would be the same for any other type (just with a different default value).\r\n\r\n\u003e It\u0027s possible the recommendation of this team is \"be explicit about the values you\u0027re passing, and don\u0027t rely on an implicit calling context\" (as a point of personal preference, I dislike even culture info being implicitly flowed). Or some form of \"use `Task\u003cT\u003e`, don\u0027t manually manage threads\".\r\n\r\nAny `AsyncLocal\u003cT\u003e` already relies on the ambient `ExecutionContext` as its value storage. While I agree that overusing ambient values is bad there are also valid use cases for them. Values in the `ExecutionContext` provide a special lifetime that cannot be achieved any other way. This proposal extends the ways `ExecutionContext` can be used to store values and bring back a behavior that was available in .NET Framework.\r\n\r\n\u003e nit: `Illogical` is probably not correct here\r\n\r\nIt was called logical/illogical in the .NET Frameworks `CallContext` so I used the naming in this issue as well. Naming and parameter types are open for discussion though, no need to carry over the .NET Framework naming :p\r\n\r\n\u003e Do I understand correctly that you wish to store key-value pairs specific to each thread or task?\r\n\u003e\r\n\u003e In that case, you could maintain a `ConditionalWeakTable\u003cThread/Task, Dictionary\u003cobject, object\u003e\u003e`. This would clean up automatically. `Task` would be looked up first. `Thread` would be the fallback.\r\n\r\nAs mentioned in the first paragraph the issue is about the lifetime of the value. The value is stored in the `ExecutionContext` and should not flow on capture. It kind of hard to accurately put the desired behavior into words but I think the example I gave above illustrates it well.\r\n\r\n\r\n\r\n",
                                           "updatedAt":  "2022-10-27T07:18:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NG1pH",
                                           "createdAt":  "2022-10-27T14:47:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "\u003e It is not about the values stored in the `CallContext`, but rather the lifetime that these values had.\r\n\r\nOkay, but you haven\u0027t justified that you actually need this behavior other than \"our application currently works this way\".  That\u0027s why all those questions, because our answer might be \"it shouldn\u0027t have been programmed to work that way in the first place\".\r\n\r\n\u003e This proposal extends the ways `ExecutionContext` can be used to store values and bring back a behavior that was available in .NET Framework.\r\n\r\nThis isn\u0027t necessarily sufficient justification; there are a number of areas - including this one, at least partially - where an explicit choice was made to not retain the old behavior.",
                                           "updatedAt":  "2022-10-27T14:47:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NHXsR",
                                           "createdAt":  "2022-10-27T16:24:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GSPP",
                                           "body":  "\u003e As mentioned in the first paragraph the issue is about the lifetime of the value. The value is stored in the ExecutionContext and should not flow on capture. It kind of hard to accurately put the desired behavior into words but I think the example I gave above illustrates it well.\r\n\r\nIt seems that my proposal does just that. The values stored would be specific to a thread or task, meaning that they don\u0027t flow. This scheme seems to give you the semantics from your opening post. Do I misunderstand your requirements?\r\n",
                                           "updatedAt":  "2022-10-27T16:24:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PHukI",
                                           "createdAt":  "2022-11-25T12:39:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC7hO7g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "mbakhoff",
                                                                               "createdAt":  "2023-05-11T09:38:45Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "a-ctor",
                                           "body":  "Sorry for taking so long to respond. Re-reading the issue I realize it might have been better to create this issue as a discussion issue instead of an API proposal. I focused too much on the implementation details leaving the context/motivation a bit behind. Here is my second take to remedy the situation:\r\n\r\nThere are scenarios where ambient values provide better solutions compared to their alternatives. These include, for example, scenarios like tracing, globalization, or security. In such scenarios the alternative of passing state through all (un)concerned objects is not practical. To model ambient values in .NET there are essential three \"lifetime\" choices: \r\n\r\n- `static`: storing the value in a static field\r\n\r\n- `thread-local`: storing the value in a `ThreadLocal\u003cT\u003e` or `[ThreadStatic]`\r\n\r\n- `execution-context`: storing the value in an `AsyncLocal\u003cT\u003e`\r\n\r\n`static` has the downside of only being able to store a single value. `thread-local` allows multiple values but cleanup is necessary lest the values are still available when the thread is reused. In scenarios where an explicit cleanup is not possible, like async scenarios, `execution-context` is the only possible choice left. Because `AsyncLocal\u003cT\u003e` is the only API in .NET that has exposes the `execution-context` lifetime, `AsyncLocal\u003cT\u003e` has to be chosen for ambient value storage. Previously, in .NET Framework additional options for the `execution-context` lifetime were available using `CallContext`.\r\n\r\n`AsyncLocal\u003cT\u003e` values flow by default. This is what enables values to flow across `await`s, but values also flow to started threads, tasks, parallel invocations, ... . Any code that captures the `ExecutionContext` also captures the `AsyncLocal\u003cT\u003e` value. Any value in an `AsyncLocal\u003cT\u003e` can be used on multiple threads and therefore should be thread-safe if not immutable. If the flow-by-default behavior of `AsyncLocal\u003cT\u003e` is not wanted, the only option is to provide a custom value-changed handler to the `AsyncLocal\u003cT\u003e`.\r\n\r\nThe problem with `AsyncLocal\u003cT\u003e`\u0027s value-changed handler is that it does not receive enough information to correctly control the flow of its values. It receives the old and the new value, but from those it is not possible to determine what kind of context switch is happening. The result is an imperfect solution that might cause issues in certain situations. Here is an example of a value-changed handler from the [runtime](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/ActivityTracker.cs#L529) that seems to have similar problems with the value-changed handler. An imperfect handler subtly changes the behavior of the ambient value, which might cause hard to debug bugs.\r\n\r\nIt would be great if there are alternative ways of storage in the `ExecutionContext` that allow other scenarios than flow-by-default. This issue proposes an additional storage of a value which is only available in the current execution. This \"dont-flow-by-default\" behavior models the opposite of `AsyncLocal\u003cT\u003e`s current behavior (and mimics the behavior of the illogical `CallContext` in .NET Framework). Ideally, the value would also be available through awaits making the following code possible:\r\n\r\n```c#\r\nConsole.WriteLine(asyncLocal.Value); // prints 8\r\nawait Task.Delay(10);\r\nx Console.WriteLine(asyncLocal.Value); // prints 8 - would print 0 without async support\r\n```\r\n\r\nCurrently, this issue only proposes adding a \"dont-flow-by-default\" behavior without async support. Support for async is something that requires discussion if it is possible and how. Naively, I think it should be possible to change the async state machine to support async when the \"dont-flow-by-default\" behavior is available. But this is something that the dotnet team is more qualified to answer so their input would be greatly appreciated.\r\n\r\nIf implemented the feature could, for example, improve the [HttpContextAccessor](https://source.dot.net/#Microsoft.AspNetCore.Http/HttpContextAccessor.cs) in ASP.NET Core. Currently, the value is stored in an `AsyncLocal\u003cT\u003e` flowing the `HttpContext` to started thread or tasks as well. This is probably not intended, but is necessary to allow the `HttpContext` to flow correctly in async scenarios. The effect of flow-by-default is minimized by wrapping the `HttpContext`, allowing it to be reset once the request has been processed. With the proposed changes and async support the `HttpContext` could be stored directly in the value container. New threads/tasks would not be able to access the `HttpContext` but it would be available through `await`s.\r\n\r\n`ExecutionContext` provides a very special lifetime that is very useful for ambient values. But at the same time `ExecutionContext` is, for good reasons, a walled-off garden that is not very extensible. The current way of extending its functionality through `AsyncLocal\u003cT\u003e` does not support more complex scenarios that require other types of value flow.\r\n\r\nI hope that clears up the motivation behind the issue a bit more. For brevity I did not go into detail on why `AsyncLocal\u003cT\u003e` value-changed handlers are not enough for complex scenarios, but I can provide that if necessary. Happy to hear your thoughts and ideas on the topic :)",
                                           "updatedAt":  "2022-11-25T12:39:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PHwKc",
                                           "createdAt":  "2022-11-25T12:46:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "a-ctor",
                                           "body":  "\u003e It seems that my proposal does just that. The values stored would be specific to a thread or task, meaning that they don\u0027t flow. This scheme seems to give you the semantics from your opening post. Do I misunderstand your requirements?\r\n\r\nA thread can switch between `ExecutionContext`s which would not work if you assign values to threads/tasks. If you look at the `ExecutionContext.Run` in the API section, the thread is not changed but the value should change because the `ExecutionContext` changed. This cannot be represented using your solution with the `ConditionalWeakTable\u003cThread/Task, Dictionary\u003cobject, object\u003e\u003e`.\r\n\r\nThere is also the issue that you cannot access the `Task` object from a currently executing methods as has not been created yet. So your solution would only work for external observers but not for the currently executing method.",
                                           "updatedAt":  "2022-11-25T12:46:37Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "[API Proposal]: Non-flowing AsyncLocal\u003cT\u003e values similar to the illogical parts of CallContext",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/77541",
        "createdAt":  "2022-10-27T15:17:25Z",
        "number":  77541,
        "author":  "lambdageek",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODBHB4g==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kekekeks",
                                            "createdAt":  "2024-05-14T13:22:20Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MikiraSora",
                                            "createdAt":  "2024-11-25T19:46:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "realybin",
                                            "createdAt":  "2025-04-11T13:10:03Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2024-02-05T10:47:26Z",
        "body":  "This would allow third party library authors to provide different implementation based on whether they\u0027re running on single-threaded or multi-threaded wasm.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOctcVGg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5NHC1c",
                                           "createdAt":  "2022-10-27T15:17:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThis would allow third party library authors to provide different implementation based on whether they\u0027re running on single-threaded or multi-threaded wasm.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003elambdageek\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-10-27T15:17:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NHDLi",
                                           "createdAt":  "2022-10-27T15:18:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lambdageek",
                                           "body":  "Related to https://github.com/dotnet/runtime/issues/76959\r\n",
                                           "updatedAt":  "2022-10-27T15:18:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5y1xUa",
                                           "createdAt":  "2024-02-05T10:47:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to \u0027arch-wasm\u0027: @lewing\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThis would allow third party library authors to provide different implementation based on whether they\u0027re running on single-threaded or multi-threaded wasm.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003elambdageek\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003epavelsavara\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `arch-wasm`, `area-System.Threading`, `os-browser`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003eFuture\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-02-05T10:47:25Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Consider making System.Threading.Thread.IsThreadStartSupported public",
        "labels":  [
                       "api-suggestion",
                       "arch-wasm",
                       "area-System.Threading",
                       "os-browser"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/77622",
        "createdAt":  "2022-10-28T23:13:55Z",
        "number":  77622,
        "author":  "xiaomi7732",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-03-22T20:50:21Z",
        "body":  "Can anyone help understand what do [these events](https://github.com/dotnet/runtime/blob/18f2c31266fe9b3f532e13f1c23343a3ab7bf283/src/libraries/System.Private.CoreLib/src/System/Threading/PortableThreadPool.HillClimbing.cs#L26) mean when captured in a ETW trace?\r\n\r\nA copy of them:\r\n\r\n```csarhp\r\npublic enum StateOrTransition\r\n{\r\n    Warmup,\r\n    Initializing,\r\n    RandomMove,\r\n    ClimbingMove,\r\n    ChangePoint,\r\n    Stabilizing,\r\n    Starvation,\r\n    ThreadTimedOut,\r\n    CooperativeBlocking,\r\n}\r\n```\r\n\r\nIt would be a great help to better understand what those states mean when the thread pool adjusts the workers in the pool. Can someone give some explanations?\r\n\r\nSome of them are easy to guess, on the surface like `Starvation`, but it would still be helpful to give out some examples of when those would happen.\r\nSome of them are not that obvious, like `ThreadTimedOut`, and what does the new `CooperativeBlocking` mean?\r\n\r\nFWIW, there\u0027s not too much info on the doc site either:\r\n* https://learn.microsoft.com/en-us/dotnet/framework/performance/thread-pool-etw-events#threadpoolworkerthreadadjustmentadjustment\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOTVnHcQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5NOcB5",
                                           "createdAt":  "2022-10-28T23:14:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nCan anyone help understand what do [these events](https://github.com/dotnet/runtime/blob/18f2c31266fe9b3f532e13f1c23343a3ab7bf283/src/libraries/System.Private.CoreLib/src/System/Threading/PortableThreadPool.HillClimbing.cs#L26) mean when captured in a ETW trace?\r\n\r\nA copy of them:\r\n\r\n```csarhp\r\npublic enum StateOrTransition\r\n{\r\n    Warmup,\r\n    Initializing,\r\n    RandomMove,\r\n    ClimbingMove,\r\n    ChangePoint,\r\n    Stabilizing,\r\n    Starvation,\r\n    ThreadTimedOut,\r\n    CooperativeBlocking,\r\n}\r\n```\r\n\r\nIt would be a great help to better understand what those states mean when the thread pool adjusts the workers in the pool. Can someone give some explanations?\r\n\r\nSome of them are easy to guess, on the surface like `Starvation`, but it would still be helpful to give out some examples of when those would happen.\r\nSome of them are not that obvious, like `ThreadTimedOut`, and what does the new `CooperativeBlocking` mean?\r\n\r\nFWIW, there\u0027s not too much info on the doc site either:\r\n* https://learn.microsoft.com/en-us/dotnet/framework/performance/thread-pool-etw-events#threadpoolworkerthreadadjustmentadjustment\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003exiaomi7732\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-10-28T23:14:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NUg-8",
                                           "createdAt":  "2022-10-31T15:02:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e what does the new CooperativeBlocking mean?\r\n\r\nAs of .NET 6, some blocking operations (e.g. Task.Wait) are tracked by the thread pool in order to inform its thread-injection heuristics.  CooperativeBlocking indicates compensating for such blocking, e.g.\r\nhttps://github.com/dotnet/runtime/blob/3dbc850af3e8bfd6d529ed90cf00247dc9a24512/src/libraries/System.Private.CoreLib/src/System/Threading/PortableThreadPool.Blocking.cs#L150-L152\r\n\r\n\u003e Some of them are not that obvious, like ThreadTimedOut\r\n\r\nThis means the thread was waiting for work for too long without anything to do, e.g.\r\nhttps://github.com/dotnet/runtime/blob/fc5b91e9ed135f70ecf143ca894da2e9e9337cc5/src/libraries/System.Private.CoreLib/src/System/Threading/PortableThreadPool.WorkerThread.cs#L149-L151",
                                           "updatedAt":  "2022-10-31T15:02:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NWcdx",
                                           "createdAt":  "2022-10-31T21:50:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xiaomi7732",
                                           "body":  "Hi @stephentoub Thanks for the reply. I have some follow-up questions:\r\n\r\n1. From the application perspective, shall we take any action on various events that are spotted?\r\n\r\nFor example, in a dotnet-trace/nettrace file:\r\n\r\n* When **Starvation** is spotted, we probably should look for blocking code. Anything else shall we look for?\r\n\r\n* When **ThreadTimedOut** is spotted, does that mean more workers are in the pool than needed? Will it benefits the performance of the app if we reduce MinThreadCount in theory?\r\n\r\n* When **CooperativeBlocking** is spotted, does that also point to potential blocking code? Shall we treat it as if there were starvation and find out where the blocking is?\r\n\r\n* Is there any other events that we might be able to work on?\r\n\r\nThanks!",
                                           "updatedAt":  "2022-10-31T21:50:54Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "What are these ThreadPoolAdjustment event means",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/77665",
        "createdAt":  "2022-10-31T04:02:56Z",
        "number":  77665,
        "author":  "kouvel",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC9PXHA==",
                          "nodes":  [
                                        {
                                            "content":  "EYES",
                                            "user":  "kevingosse",
                                            "createdAt":  "2022-10-31T08:49:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mangod9",
                                            "createdAt":  "2022-10-31T15:44:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "xsoheilalizadeh",
                                            "createdAt":  "2022-11-15T10:37:18Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "ilmax",
                                            "createdAt":  "2023-01-23T00:04:01Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "MineCake147E",
                                            "createdAt":  "2024-12-06T02:56:33Z"
                                        }
                                    ],
                          "totalCount":  5
                      },
        "updatedAt":  "2023-07-03T18:26:28Z",
        "body":  "This issue tracks some thread pool experiments/investigations that were proposed.\r\n\r\n- [ ] Polling for IO on worker threads\r\n  - There can be some tradeoffs between using dedicated IO poller threads and polling for IO on worker threads. Some issues observed in some cases with dedicated IO pollers is the thread scheduling latency, difficulty of determining a number of IO pollers on machines of various sizes, and the extra thread hop in processing IO events.\r\n  - [ ] Build a prototype for experimenting with and collect some performance data to understand the pros and cons. In progress.\r\n  - [x] Use one global epoll fd and determine an alternate mechanism to assiciate an IO event with a callback\r\n  - [ ] Experiment with some strategies for polling for IO to balance the overhead, such as frequency of polling, batch sizes, etc.\r\n- [ ] Using the Windows thread pool\r\n  - There can be some tradeoffs in using the Windows thread pool, it may be beneficial in cases where other components also use the Windows thread pool. The goal is to experiment with using it and collect some data to understand some of the tradeoffs.\r\n  - [ ] Experiment with using the Windows thread pool in coreclr and measure perf. In progress.\r\n  - [ ] Investigate regressions and determine if they can be reasonably fixed\r\n- [x] Processing IO events at higher priority on Unixes\r\n  - IO events are processed in the same order as global work items, so in cases where the global queues are heavily backed up, in-progress requests could be delayed by processing of new requests. The goal is mainly to try it out and to understand any perf regressions.\r\n  - [x] Build System.Net.Sockets against CoreLib, queue processing of IO events at high priority, and gather some perf data\r\n  - [x] Investigate regressions and determine if they can be reasonably fixed. Most of the ASP.NET benchmarks resulted in regressions. After some investigation and experimentation the regressions appeared to reduce in magnitude on some tests, but still there. Needs further investigation to determine if this can reasonably be done on Unixes without perf regressions.\r\n- [x] Disabling hill climbing\r\n  - This is a quick experiment to just measure the current perf effects of disabling hill climbing. Hill climbing adds some costs and it was seen that it doesn\u0027t help in several kinds of apps.\r\n  - [x] Gather some current perf data to understand the effects of disabling hill climbing. Perf in ASP.NET benchmarks appears to be mostly similar or slightly better. Perf metrics in a large internal service did not change, but with fewer worker threads on average.\r\n\r\nSome leftover work items are tracked in https://github.com/dotnet/runtime/issues/52701.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOVBcJTA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5NRyuo",
                                           "createdAt":  "2022-10-31T04:03:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThis issue tracks some thread pool experiments/investigations that were proposed.\r\n\r\n- [ ] Polling for IO on worker threads\r\n  - There can be some tradeoffs between using dedicated IO poller threads and polling for IO on worker threads. Some issues observed in some cases with dedicated IO pollers is the thread scheduling latency, difficulty of determining a number of IO pollers on machines of various sizes, and the extra thread hop in processing IO events.\r\n  - [ ] Build a prototype for experimenting with and collect some performance data to understand the pros and cons. In progress.\r\n  - [x] Use one global epoll fd and determine an alternate mechanism to assiciate an IO event with a callback\r\n  - [ ] Experiment with some strategies for polling for IO to balance the overhead, such as frequency of polling, batch sizes, etc.\r\n- [ ] Using the Windows thread pool\r\n  - There can be some tradeoffs in using the Windows thread pool, it may be beneficial in cases where other components also use the Windows thread pool. The goal is to experiment with using it and collect some data to understand some of the tradeoffs.\r\n  - [ ] Experiment with using the Windows thread pool in coreclr and measure perf. In progress.\r\n  - [ ] Investigate regressions and determine if they can be reasonably fixed\r\n- [x] Processing IO events at higher priority on Unixes\r\n  - IO events are processed in the same order as global work items, so in cases where the global queues are heavily backed up, in-progress requests could be delayed by processing of new requests. The goal is mainly to try it out and to understand any perf regressions.\r\n  - [x] Build System.Net.Sockets against CoreLib, queue processing of IO events at high priority, and gather some perf data\r\n  - [x] Investigate regressions and determine if they can be reasonably fixed. Most of the ASP.NET benchmarks resulted in regressions. After some investigation and experimentation the regressions appeared to reduce in magnitude on some tests, but still there. Needs further investigation to determine if this can reasonably be done on Unixes without perf regressions.\r\n- [x] Disabling hill climbing\r\n  - This is a quick experiment to just measure the current perf effects of disabling hill climbing. Hill climbing adds some costs and it was seen that it doesn\u0027t help in several kinds of apps.\r\n  - [x] Gather some current perf data to understand the effects of disabling hill climbing. Perf in ASP.NET benchmarks appears to be mostly similar or slightly better. Perf metrics in a large internal service did not change, but with fewer worker threads on average.\r\n\r\nSome leftover work items are tracked in https://github.com/dotnet/runtime/issues/52701.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ekouvel\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003ekouvel, eduardo-vp\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e8.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-10-31T04:03:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NSEUW",
                                           "createdAt":  "2022-10-31T06:05:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCu5NzA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kouvel",
                                                                               "createdAt":  "2022-10-31T06:18:07Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "GSPP",
                                                                               "createdAt":  "2022-11-02T11:44:19Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "\u003e  Using the Windows thread pool\r\n\r\nI\u0027m for this experiment but I would say that no matter what we find, we shouldn\u0027t default to this. ",
                                           "updatedAt":  "2022-10-31T06:05:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NSEnx",
                                           "createdAt":  "2022-10-31T06:06:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "How come some of these are checked? Are those experiments that were already run?",
                                           "updatedAt":  "2022-10-31T06:06:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NSG_7",
                                           "createdAt":  "2022-10-31T06:21:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "\u003e How come some of these are checked? Are those experiments that were already run?\r\n\r\nYea some of these are complete with some leftover work items tracked in https://github.com/dotnet/runtime/issues/52701 for now.",
                                           "updatedAt":  "2022-10-31T06:21:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NUUhJ",
                                           "createdAt":  "2022-10-31T14:26:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e I\u0027m for this experiment but I would say that no matter what we find, we shouldn\u0027t default to this.\r\n\r\nWe should wait for what we find before making calls like this one. For example, what if we find that Windows thread pool is superior in all dimensions?",
                                           "updatedAt":  "2022-10-31T14:26:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NUicy",
                                           "createdAt":  "2022-10-31T15:05:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "\u003e We should wait for what we find before making calls like this one. For example, what if we find that Windows thread pool is superior in all dimensions?\r\n\r\nTo me, it feels like it that decision would fly in the face of attempting to build a consistent platform.  Even though we can\u0027t do this 100% as platform differences always come through in some APIs, our goal should be to make the platform behavior as consistent as possible across platforms where possible. \r\n\r\nEven if it was better on all dimensions, we should default to our managed components over OS ones. We have more control and can provide a more consistent experience. That isn\u0027t just about behavior, but also about configuration. \r\n\r\nThis is why ASP.NET Core has HTTP.sys and Kestrel server implementations but defaults to the managed one (amongst other reasons). We don\u0027t need to educate people about configuring register keys to tweak server behavior because we made a decision to use a windows component that relies on those behaviors.\r\n\r\nWhen I think about the changes we made to the threadpool to work around blocking APIs, I think about the lack of control we would have if we delegated elsewhere. We\u0027d need to wait for a new windows version to get this behavior. Seems like a non-starter IMHO.",
                                           "updatedAt":  "2022-10-31T15:10:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NUp0j",
                                           "createdAt":  "2022-10-31T15:26:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Yes, it is a tradeoff. We often take advantage of platform-specific capabilities in implementation runtime and libraries implementation to maximize the .NET platform value. For example, async I/O works very differently on Windows vs. Linux, and these differences come through in some APIs. It would not make sense to limit async I/O implementation choices to least common denominator in the name of consistent platform.",
                                           "updatedAt":  "2022-10-31T15:26:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NUq4R",
                                           "createdAt":  "2022-10-31T15:29:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e When I think about the changes we made to the threadpool to work around blocking APIs, \r\n\r\nIt is not just that. Windows threadpool is used as an implementation detail for number of Windows subsystems. It means that there are two threadpools running in typical .NET apps. I would expect that switching to Windows threadpool reduces our memory footprint by eliminating the threadpool duplication, especially for smaller apps.",
                                           "updatedAt":  "2022-10-31T15:29:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NUw6S",
                                           "createdAt":  "2022-10-31T15:46:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "\u003e For example, async I/O works very differently on Windows vs. Linux, and these differences come through in some APIs. It would not make sense to limit async I/O implementation choices to least common denominator in the name of consistent platform.\r\n\r\nRight, I mentioned this, but we do a good job unifying how they work which got even better when we moved the windows IO polling code to managed code in .NET 7. That reduced the differences between the OSes implementations. This is similar to what libuv does and really any modern platform that does IO. Now if you want to eek the last drop of performance out of the platform then you can opt-into that specific platform implementation and maximize the performance.\r\n\r\nI\u0027m just talking about defaults; I think we should bias heavily towards managed by default giving users the option to opt-into OS specific implementations as a principle. ",
                                           "updatedAt":  "2022-10-31T15:46:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5UFwlM",
                                           "createdAt":  "2023-01-31T17:35:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "NinoFloris",
                                           "body":  "@kouvel what would \" Polling for IO on worker threads \" look like from where we are today?",
                                           "updatedAt":  "2023-01-31T17:35:23Z"
                                       }
                                   ],
                         "totalCount":  10
                     },
        "title":  "Tracking issue for some thread pool experiments (.NET 8)",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/77669",
        "createdAt":  "2022-10-31T07:25:52Z",
        "number":  77669,
        "author":  "cristipufu",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODGgnNA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "martincostello",
                                            "createdAt":  "2022-11-01T19:29:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hacst",
                                            "createdAt":  "2023-06-06T15:12:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kamilslusarczyk",
                                            "createdAt":  "2023-07-10T06:54:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rstm-sf",
                                            "createdAt":  "2023-09-14T07:21:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "josh-degraw",
                                            "createdAt":  "2024-02-11T22:24:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "marekott",
                                            "createdAt":  "2024-11-04T11:20:51Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "validide",
                                            "createdAt":  "2025-04-23T14:56:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "altso",
                                            "createdAt":  "2025-07-10T14:31:01Z"
                                        }
                                    ],
                          "totalCount":  8
                      },
        "updatedAt":  "2023-06-06T14:54:21Z",
        "body":  "### Background and motivation\n\nHi, I\u0027m working on a Redis extension library on top of `Microsoft.AspNetCore.RateLimiting` (for multi-node deployments), using the new Rate Limiting support added in NET 7: https://github.com/cristipufu/aspnetcore-redis-rate-limiting\r\n\r\nWhen the `ConcurrencyLimiter`\u0027s `ConcurrencyLease` gets disposed, we need to basically decrement the count for that particular policy. At the moment, the current API forces me to use the sync version.\r\n\r\nMy suggestion would be to make `RateLimitLease` implement `IAsyncDisposable`, such that we can call async APIs when the lease is released: https://github.com/cristipufu/aspnetcore-redis-rate-limiting/blob/master/src/RedisRateLimiting/Concurrency/RedisConcurrencyRateLimiter.cs#L114\n\n### API Proposal\n\n```csharp\r\nnamespace System.Threading.RateLimiting\r\n{\r\n    public abstract class RateLimitLease : IDisposable, IAsyncDisposable\r\n    {\r\n        ...\r\n\r\n       protected virtual ValueTask DisposeAsync(bool disposing)\r\n       {\r\n           return default;\r\n       }\r\n\r\n        public ValueTask DisposeAsync()\r\n        {\r\n            return DisposeAsync(true);\r\n        }\r\n    }\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nprivate sealed class RedisConcurrencyLease : RateLimitLease\r\n{\r\n     ...\r\n\r\n    protected override ValueTask DisposeAsync(bool disposing)\r\n    {\r\n        if (_disposed)\r\n        {\r\n            return;\r\n        }\r\n\r\n        _disposed = true;\r\n\r\n        if (_id != null)\r\n        {\r\n            return _limiter?.ReleaseAsync(_id);\r\n        }\r\n\r\n       return default;\r\n    }\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOXhxr-w==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5NSgMI",
                                           "createdAt":  "2022-10-31T07:25:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-10-31T07:25:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NUOb7",
                                           "createdAt":  "2022-10-31T14:08:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nHi, I\u0027m working on a Redis extension library on top of `Microsoft.AspNetCore.RateLimiting` (for multi-node deployments), using the new Rate Limiting support added in NET 7: https://github.com/cristipufu/aspnetcore-redis-rate-limiting\r\n\r\nWhen the `ConcurrencyLimiter`\u0027s `ConcurrencyLease` gets disposed, we need to basically decrement the count for that particular policy. At the moment, the current API forces me to use the sync version.\r\n\r\nMy suggestion would be to make `RateLimitLease` implement `IAsyncDisposable`, such that we can call async APIs when the lease is released: https://github.com/cristipufu/aspnetcore-redis-rate-limiting/blob/master/src/RedisRateLimiting/Concurrency/RedisConcurrencyRateLimiter.cs#L114\n\n### API Proposal\n\n```csharp\r\nnamespace System.Threading.RateLimiting\r\n{\r\n    public abstract class RateLimitLease : IDisposable, IAsyncDisposable\r\n    {\r\n        ...\r\n\r\n       protected virtual ValueTask DisposeAsync(bool disposing)\r\n       {\r\n           return default;\r\n       }\r\n\r\n        public ValueTask DisposeAsync()\r\n        {\r\n            return DisposeAsync(true);\r\n        }\r\n    }\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nprivate sealed class RedisConcurrencyLease : RateLimitLease\r\n{\r\n     ...\r\n\r\n    protected override ValueTask DisposeAsync(bool disposing)\r\n    {\r\n        if (_disposed)\r\n        {\r\n            return;\r\n        }\r\n\r\n        _disposed = true;\r\n\r\n        if (_id != null)\r\n        {\r\n            return _limiter?.ReleaseAsync(_id);\r\n        }\r\n\r\n       return default;\r\n    }\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ecristipufu\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-10-31T14:08:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5OOrAq",
                                           "createdAt":  "2022-11-12T12:31:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "cristipufu",
                                           "body":  "This one should be async as well: https://github.com/dotnet/runtime/blob/main/src/libraries/System.Threading.RateLimiting/src/System/Threading/RateLimiting/RateLimiter.cs#L37",
                                           "updatedAt":  "2022-11-12T12:31:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5eHGv7",
                                           "createdAt":  "2023-06-06T14:54:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "cristipufu",
                                           "body":  "Tagging @BrennanConroy @davidfowl @halter73 @JamesNK for visibility \r\nPlease take a look: https://github.com/cristipufu/aspnetcore-redis-rate-limiting/issues/66",
                                           "updatedAt":  "2023-06-06T14:54:21Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "[API Proposal]: System.Threading.RateLimiting RateLimitLease should implement IAsyncDisposable",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/77945",
        "createdAt":  "2022-11-05T15:08:57Z",
        "number":  77945,
        "author":  "iSazonov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-07T19:35:26Z",
        "body":  "### Description\r\n\r\n`Stopwatch.GetTimestamp()` doesn\u0027t take into account suspend/sleep time on Unix but does on Windows.\r\n\r\nDiscovered in PowerShell repo https://github.com/PowerShell/PowerShell/issues/18469\r\n\r\n### Reproduction Steps\r\n\r\n1. Get `Stopwatch.GetTimestamp()` value\r\n2. Sleep/hibernate your notebook\r\n3. Wait a while and wake up the notebook\r\n4. Get `Stopwatch.GetTimestamp()` value\r\n\r\n### Expected behavior\r\n\r\n`Stopwatch.GetTimestamp()` value takes into account the sleep time.\r\n\r\n### Actual behavior\r\n\r\n`Stopwatch.GetTimestamp()` value doesn\u0027t take into account the sleep time on Unix.\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\n_No response_\r\n\r\n### Other information\r\n\r\nRelated code\r\nhttps://github.com/dotnet/runtime/blob/d320fd90a2976b388169dd51b3732ad01bcb4266/src/native/libs/System.Native/pal_time.c#L84-L97\r\n\r\n~uses `CLOCK_UPTIME_RAW`~ - the bug seems to be right here. Should it be `CLOCK_BOOTTIME`?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOwoyWbQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5NwhID",
                                           "createdAt":  "2022-11-05T15:09:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-11-05T15:09:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NwijV",
                                           "createdAt":  "2022-11-05T15:41:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @tommcdon\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\n`Stopwatch.GetTimestamp()` doesn\u0027t take into account suspend/sleep time on Unix but does on Windows.\r\n\r\nDiscovered in PowerShell repo https://github.com/PowerShell/PowerShell/issues/18469\r\n\r\n### Reproduction Steps\r\n\r\n1. Get `Stopwatch.GetTimestamp()` value\r\n2. Sleep/hibernate your notebook\r\n3. Wait a while and wake up the notebook\r\n4. Get `Stopwatch.GetTimestamp()` value\r\n\r\n### Expected behavior\r\n\r\n`Stopwatch.GetTimestamp()` value takes into account the sleep time.\r\n\r\n### Actual behavior\r\n\r\n`Stopwatch.GetTimestamp()` value doesn\u0027t take into account the sleep time on Unix.\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\n_No response_\r\n\r\n### Other information\r\n\r\nRelated code\r\nhttps://github.com/dotnet/runtime/blob/d320fd90a2976b388169dd51b3732ad01bcb4266/src/native/libs/System.Native/pal_time.c#L84-L97\r\n\r\nuses `CLOCK_UPTIME_RAW` - the bug seems to be right here. Should it be `CLOCK_BOOTTIME`?\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eiSazonov\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Diagnostics`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-11-05T15:41:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Nwv4z",
                                           "createdAt":  "2022-11-05T19:59:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCvG2QA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "iSazonov",
                                                                               "createdAt":  "2022-11-06T09:50:44Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "SteveL-MSFT",
                                                                               "createdAt":  "2022-11-07T02:00:49Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "am11",
                                           "body":  "\u003e uses `CLOCK_UPTIME_RAW` - the bug seems to be right here.\r\n\r\n`clock_gettime_nsec_np(CLOCK_UPTIME_RAW` is only activated on macOS/FreeBSD, while the linked issue is about Linux.\r\n\r\n\u003e Should it be `CLOCK_BOOTTIME`?\r\n\r\nWe can use `CLOCK_BOOTTIME` instead of `CLOCK_MONOTONIC` on Linux if we want to account for the suspend time, like so:\r\n\r\n```diff\r\n- #if HAVE_CLOCK_GETTIME_NSEC_NP \r\n+ #if HAVE_CLOCK_GETTIME_NSEC_NP // macOS, FreeBSD\r\n     return clock_gettime_nsec_np(CLOCK_UPTIME_RAW); \r\n #else \r\n     struct timespec ts; \r\n\r\n+ #ifdef CLOCK_BOOTTIME // Linux, Android\r\n+     int result = clock_gettime(CLOCK_BOOTTIME, \u0026ts); \r\n+ #else // others\r\n     int result = clock_gettime(CLOCK_MONOTONIC, \u0026ts); \r\n+ #endif\r\n```",
                                           "updatedAt":  "2022-11-05T19:59:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Nxn6M",
                                           "createdAt":  "2022-11-06T17:41:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "iSazonov",
                                           "body":  "\u003e \u003e uses `CLOCK_UPTIME_RAW` - the bug seems to be right here.\r\n\u003e \r\n\u003e `clock_gettime_nsec_np(CLOCK_UPTIME_RAW` is only activated on macOS/FreeBSD, while the linked issue is about Linux.\r\n\r\nFor MAC https://github.com/libuv/libuv/issues/2891\r\n",
                                           "updatedAt":  "2022-11-06T17:41:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NyIKd",
                                           "createdAt":  "2022-11-07T02:01:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "SteveL-MSFT",
                                           "body":  "Just to be clear, the current behavior which doesn\u0027t take into account suspended time doesn\u0027t match the `uptime` command which does.",
                                           "updatedAt":  "2022-11-07T02:01:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5cEd2b",
                                           "createdAt":  "2023-05-11T21:01:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\n`Stopwatch.GetTimestamp()` doesn\u0027t take into account suspend/sleep time on Unix but does on Windows.\r\n\r\nDiscovered in PowerShell repo https://github.com/PowerShell/PowerShell/issues/18469\r\n\r\n### Reproduction Steps\r\n\r\n1. Get `Stopwatch.GetTimestamp()` value\r\n2. Sleep/hibernate your notebook\r\n3. Wait a while and wake up the notebook\r\n4. Get `Stopwatch.GetTimestamp()` value\r\n\r\n### Expected behavior\r\n\r\n`Stopwatch.GetTimestamp()` value takes into account the sleep time.\r\n\r\n### Actual behavior\r\n\r\n`Stopwatch.GetTimestamp()` value doesn\u0027t take into account the sleep time on Unix.\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\n_No response_\r\n\r\n### Other information\r\n\r\nRelated code\r\nhttps://github.com/dotnet/runtime/blob/d320fd90a2976b388169dd51b3732ad01bcb4266/src/native/libs/System.Native/pal_time.c#L84-L97\r\n\r\n~uses `CLOCK_UPTIME_RAW`~ - the bug seems to be right here. Should it be `CLOCK_BOOTTIME`?\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eiSazonov\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Diagnostics`, `area-System.Runtime`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-05-11T21:01:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5tfvly",
                                           "createdAt":  "2023-12-02T04:42:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODRq8ew==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "fMichaleczek",
                                                                               "createdAt":  "2024-01-08T22:52:38Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "kilasuit",
                                           "body":  "This seems like shouldn\u0027t be a hard thing to fix and has seemingly looks to have a possible fix identified already above so I hope a PR with a fix will be raised soon",
                                           "updatedAt":  "2023-12-02T04:42:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7CjJZt",
                                           "createdAt":  "2025-09-07T19:34:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-09-07T19:34:09Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Stopwatch.GetTimestamp() doesn\u0027t take into account sleep time on Unix",
        "labels":  [
                       "area-System.Threading",
                       "in-pr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/79375",
        "createdAt":  "2022-12-08T01:42:54Z",
        "number":  79375,
        "author":  "darthwalsh",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-18T23:17:08Z",
        "body":  "### Description\n\nThe call `new  System.Threading.Mutex(false, \"some_text\")` running in multiple processes will throw `System.IO.IOException The system cannot open the device or file specified. : \u0027some_text\u0027` maybe 30% of the time after I\u0027ve rebooted my macbook.\r\n\r\nThis seems to be the root cause of PowerShell/PSReadLine#2658, as `pwsh` PSReadLine process attempts to use a Mutex during setup.\n\n### Reproduction Steps\n\nCreate a new `net6.0` console app that \r\n* calls Mutex ctor\r\n* prints an exception if it happened\r\n* stays open to show output\r\n\r\nProgram.cs: \r\n```csharp\r\ntry {\r\n  using (var m = new Mutex(false, \"darthwalsh_PSReadLine_issues_2658\")) {\r\n    Console.Write(\"created but didn\u0027t take Mutex darthwalsh_PSReadLine_issues_2658   ...\");\r\n    var line = Console.ReadLine();\r\n    Console.WriteLine(\"QUITTING: \" + line);\r\n  }\r\n} catch (Exception e) {\r\n  Console.WriteLine(e.ToString());\r\n\r\n  var line = Console.ReadLine();\r\n  Console.WriteLine(\"QUITTING: \" + line);\r\n}\r\n```\r\n\r\nBuild with `dotnet publish -c Release --self-contained -a x64`\r\n\r\nCreated a new iTerm2 profile that only runs the compiled output, i.e. `/Users/walshca/code/temp/MutexThrow/bin/Release/net6.0/osx-x64/publish/MutexThrow` and open this profile in **10** tabs, each split into **12** instances. (Having 120 processes in parallel is likely overkill, but it seems to guarantee a repro.) (see Actual image)\r\n\r\nEnsure iTerm2 is set up to relaunch with the same tabs.\r\n\r\nReboot macOS. Log in. Find iTerm. Look through all tabs at output messages.\n\n### Expected behavior\n\n120x messages of `created but didn\u0027t take Mutex darthwalsh_PSReadLine_issues_2658   ...` with no exceptions\n\n### Actual behavior\n\nOut of 120 processes, index 0, 2, 5, and 12 failed with message:\r\n\r\n```\r\nSystem.IO.IOException: The system cannot open the device or file specified. : \u0027darthwalsh_PSReadLine_issues_2658\u0027\r\n   at System.Threading.Mutex.CreateMutexCore(Boolean initiallyOwned, String name, Boolean\u0026 createdNew)\r\n   at System.Threading.Mutex..ctor(Boolean initiallyOwned, String name)\r\n   at Program.\u003cMain\u003e$(String[] args) in /Users/walshca/code/temp/MutexThrow/Program.cs:line 2\r\n```\r\n\r\n![image](https://user-images.githubusercontent.com/2829438/206332123-2fa32518-c391-4e06-90af-f176cf806456.png)\r\n\r\n(the screenshot shows the failures, then a couple attempts to reproduce the problem by ownly logging out without rebooting, which did not trigger it.)\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nThe conversation in PowerShell/PSReadLine#2658 discussed whether catching and retrying the exception should be tried, but it\u0027s unclear what is causing Mutex ctor to throw.\n\n### Configuration\n\n- Build with dotnet `6.0.822.36306`\r\n- macOS Monterey 12.6.1 21G217 \r\n- x64 2.3 GHz 8-Core Intel Core i9\r\n- It seems likely OS-specific, unknown about arch or build flags\r\n\n\n### Other information\n\nA related problem dotnet/runtime#36823 can happen if the `/tmp` permissions are incorrect, but that\u0027s not the case here.\r\n\r\nThe [Mutex.ctor() API docs](https://learn.microsoft.com/en-us/dotnet/api/system.threading.mutex.-ctor?view=net-7.0) isn\u0027t clear if this exception is expected and transient, and we should try to catch it and retry Mutex creation?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOuEBvDg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5P-xFt",
                                           "createdAt":  "2022-12-08T01:43:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nThe call `new  System.Threading.Mutex(false, \"some_text\")` running in multiple processes will throw `System.IO.IOException The system cannot open the device or file specified. : \u0027some_text\u0027` maybe 30% of the time after I\u0027ve rebooted my macbook.\r\n\r\nThis seems to be the root cause of PowerShell/PSReadLine#2658, as `pwsh` PSReadLine process attempts to use a Mutex during setup.\n\n### Reproduction Steps\n\nCreate a new `net6.0` console app that \r\n* calls Mutex ctor\r\n* prints an exception if it happened\r\n* stays open to show output\r\n\r\nProgram.cs: \r\n```csharp\r\ntry {\r\n  using (var m = new Mutex(false, \"darthwalsh_PSReadLine_issues_2658\")) {\r\n    Console.Write(\"created but didn\u0027t take Mutex darthwalsh_PSReadLine_issues_2658   ...\");\r\n    var line = Console.ReadLine();\r\n    Console.WriteLine(\"QUITTING: \" + line);\r\n  }\r\n} catch (Exception e) {\r\n  Console.WriteLine(e.ToString());\r\n\r\n  var line = Console.ReadLine();\r\n  Console.WriteLine(\"QUITTING: \" + line);\r\n}\r\n```\r\n\r\nBuild with `dotnet publish -c Release --self-contained -a x64`\r\n\r\nCreated a new iTerm2 profile that only runs the compiled output, i.e. `/Users/walshca/code/temp/MutexThrow/bin/Release/net6.0/osx-x64/publish/MutexThrow` and open this profile in **10** tabs, each split into **12** instances. (Having 120 processes in parallel is likely overkill, but it seems to guarantee a repro.) (see Actual image)\r\n\r\nEnsure iTerm2 is set up to relaunch with the same tabs.\r\n\r\nReboot macOS. Log in. Find iTerm. Look through all tabs at output messages.\n\n### Expected behavior\n\n120x messages of `created but didn\u0027t take Mutex darthwalsh_PSReadLine_issues_2658   ...` with no exceptions\n\n### Actual behavior\n\nOut of 120 processes, index 0, 2, 5, and 12 failed with message:\r\n\r\n```\r\nSystem.IO.IOException: The system cannot open the device or file specified. : \u0027darthwalsh_PSReadLine_issues_2658\u0027\r\n   at System.Threading.Mutex.CreateMutexCore(Boolean initiallyOwned, String name, Boolean\u0026 createdNew)\r\n   at System.Threading.Mutex..ctor(Boolean initiallyOwned, String name)\r\n   at Program.\u003cMain\u003e$(String[] args) in /Users/walshca/code/temp/MutexThrow/Program.cs:line 2\r\n```\r\n\r\n![image](https://user-images.githubusercontent.com/2829438/206332123-2fa32518-c391-4e06-90af-f176cf806456.png)\r\n\r\n(the screenshot shows the failures, then a couple attempts to reproduce the problem by ownly logging out without rebooting, which did not trigger it.)\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nThe conversation in PowerShell/PSReadLine#2658 discussed whether catching and retrying the exception should be tried, but it\u0027s unclear what is causing Mutex ctor to throw.\n\n### Configuration\n\n- Build with dotnet `6.0.822.36306`\r\n- macOS Monterey 12.6.1 21G217 \r\n- x64 2.3 GHz 8-Core Intel Core i9\r\n- It seems likely OS-specific, unknown about arch or build flags\r\n\n\n### Other information\n\nA related problem dotnet/runtime#36823 can happen if the `/tmp` permissions are incorrect, but that\u0027s not the case here.\r\n\r\nThe [Mutex.ctor() API docs](https://learn.microsoft.com/en-us/dotnet/api/system.threading.mutex.-ctor?view=net-7.0) isn\u0027t clear if this exception is expected and transient, and we should try to catch it and retry Mutex creation?\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003edarthwalsh\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-12-08T01:43:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5QDdeM",
                                           "createdAt":  "2022-12-08T17:51:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "@kouvel. Does this repro consistently for you @darthwalsh ?",
                                           "updatedAt":  "2022-12-08T17:51:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5QD0gA",
                                           "createdAt":  "2022-12-08T18:46:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "darthwalsh",
                                           "body":  "@mangod9 yes every time I attempt the repro with at least 10 concurrent processes, about 3 of the processes fail.",
                                           "updatedAt":  "2022-12-08T18:46:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5SloII",
                                           "createdAt":  "2023-01-17T15:23:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "darthwalsh",
                                           "body":  "@mangod9 I\u0027ve kept my repo running through a few more reboots. The first two reboots each had 3 thrown exceptions. The last reboot had 0 exceptions. So during OS startup with dozens of dotnet processes, I\u0027d expect to see a crash about 90% of the time.\r\n\r\nIs there any more investigation I can do to help move this issue forward?\r\n\r\nAlso, do we have a rough idea of what the fix will be? i.e. maybe Mutex ctor() is changed to somehow not throw (i.e. retry on file access error)? Or, would the docs on MSDN be updated to say some exceptions are expected in this situation?",
                                           "updatedAt":  "2023-01-17T15:23:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5U1zls",
                                           "createdAt":  "2023-02-08T23:55:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "darthwalsh",
                                           "body":  "Continuing to update this, my macbook updated to 13.2 Ventura. I am monitoring with 16 processes starting in iTerm. I haven\u0027t had the issue on the two reboots since OS upgrade, but I\u0027m not confident about the cause: Did 13.2 fix something? Did the OS change something about how soon applications are started after booting? Did the race condition get lucky twice in a row?\r\n\r\nIt will still be helpful to get an update to the docs about the exception policy, whether or not this specific issue will not reproduce again.",
                                           "updatedAt":  "2023-02-08T23:55:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5vWPuA",
                                           "createdAt":  "2023-12-22T22:16:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "darthwalsh",
                                           "body":  "Continuing to update this, I\u0027ve since upgraded to macOS 14.1.2 and still regularly see this, as recently as November. I\u0027m not sure if there\u0027s a better way to look at the data, but global-find-substring shows I have seen this error a total of 136 times in my iTerm history in the last 10 months.\r\n\r\nI\u0027ll be upgrading to an Apple Silicon macbook, and probably won\u0027t keep trying to reproduce the issue. As long as dotnet core supports macOS on Intel chips this feels worth fixing :)",
                                           "updatedAt":  "2023-12-22T22:16:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc64QG8O",
                                           "createdAt":  "2025-07-18T23:17:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "darthwalsh",
                                           "body":  "On Apple Silicon I got a very similar error (different message, but same exception type). This happened right after rebooting, and my terminal opened a dozen instances of `pwsh` at the same time\n\n```\nSystem.IO.IOException: The system cannot open the device or file specified. : \u0027PSReadLineHistoryFile_2886463743\u0027. One or more system calls failed: stat(\"/tmp/.dotnet/shm\", ...) == -1; errno == ENOENT;\n   at System.Threading.Mutex.CreateMutexCore(Boolean initiallyOwned, String name, Boolean\u0026 createdNew)\n   at System.Threading.Mutex..ctor(Boolean initiallyOwned, String name)\n   at Microsoft.PowerShell.PSConsoleReadLine.DelayedOneTimeInitialize()\n   at Microsoft.PowerShell.PSConsoleReadLine.Initialize(Runspace runspace, EngineIntrinsics engineIntrinsics)\n   at Microsoft.PowerShell.PSConsoleReadLine.ReadLine(Runspace runspace, EngineIntrinsics engineIntrinsics, CancellationToken cancellationToken, Nullable`1 lastRunStatus)\n```\n\nsystem info:\n```\n$ sw_vers\nProductName:\t\tmacOS\nProductVersion:\t\t15.5\nBuildVersion:\t\t24F74\n\n$ $PSVersionTable\n\nName                           Value\n----                           -----\nPSVersion                      7.5.1\nPSEdition                      Core\nGitCommitId                    7.5.1\nOS                             Darwin 24.5.0 Darwin Kernel Version 24.5.0: Tue Apr 22 19:54:29 PDT 2025; root:xnu-11417.121.6~2/RELEASE_ARM64_T6030\nPlatform                       Unix\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0…}\nPSRemotingProtocolVersion      2.3\nSerializationVersion           1.1.0.1\nWSManStackVersion              3.0\n```\n",
                                           "updatedAt":  "2025-07-18T23:17:08Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "Mutex ctor will often throw IOException immediately after macOS reboot",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/79888",
        "createdAt":  "2022-12-21T18:25:38Z",
        "number":  79888,
        "author":  "wasabii",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-07-24T17:58:42Z",
        "body":  "### Background and motivation\n\nTwo methods that are missing, that seem as if they should exist, are Volatile.Write(ref char, char) and Volatile.Read(ref char).\r\n\r\nI have managed to work around their absence by using Unsafe.As\u003cchar, short\u003e(), and then casting in reverse. But this is less than ideal.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Threading;\r\n\r\npublic static class Volatile\r\n{\r\n    public char Read(ref char location);\r\n    public void Write(ref char location, char value);\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nvar o = new ObjectWithCharField();\r\nVolatile.Write(ref o.charField, \u0027A\u0027);\r\nvar c = Volatile.Read(ref o.charField);\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOUTAhyg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5RK92o",
                                           "createdAt":  "2022-12-21T18:25:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-12-21T18:25:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RLcHd",
                                           "createdAt":  "2022-12-21T19:12:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nTwo methods that are missing, that seem as if they should exist, are Volatile.Write(ref char, char) and Volatile.Read(ref char).\r\n\r\nI have managed to work around their absence by using Unsafe.As\u003cchar, short\u003e(), and then casting in reverse. But this is less than ideal.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Threading;\r\n\r\npublic static class Volatile\r\n{\r\n    public char Read(ref char location);\r\n    public void Write(ref char location, char value);\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nvar o = new ObjectWithCharField();\r\nVolatile.Write(ref o.charField, \u0027A\u0027);\r\nvar c = Volatile.Read(ref o.charField);\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ewasabii\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-12-21T19:12:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RL_N3",
                                           "createdAt":  "2022-12-21T21:16:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "I prefer allowing `volatile` and `Volatile` on any type; it is legal according to ECMA-335.",
                                           "updatedAt":  "2022-12-21T21:16:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RL_v8",
                                           "createdAt":  "2022-12-21T21:19:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wasabii",
                                           "body":  "Prefer? As in instead of?",
                                           "updatedAt":  "2022-12-21T21:19:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RMAbY",
                                           "createdAt":  "2022-12-21T21:23:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "Yes. Though it would require changes at a language level.",
                                           "updatedAt":  "2022-12-21T21:23:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RMAnO",
                                           "createdAt":  "2022-12-21T21:24:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wasabii",
                                           "body":  "Well then it would be unusable in all the cases one makes use of System.Threading.Volatile. And thus unusable for me.",
                                           "updatedAt":  "2022-12-21T21:24:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RMBGm",
                                           "createdAt":  "2022-12-21T21:27:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "alexrp",
                                           "body":  "\u003e I prefer allowing `volatile` and `Volatile` on any type; it is legal according to ECMA-335.\r\n\r\nThere is a very good reason why the C# `volatile` keyword is limited to a narrow subset of types. It currently implies atomicity + acquire/release memory ordering semantics. The memory ordering semantics come from compiling to the `volatile.` CIL opcode (which by itself guarantees nothing about atomicity), while the atomicity comes from a broad CLI guarantee that any properly-aligned loads/stores of any primitive type `T` where `sizeof(T) \u003c= sizeof(void*)` are atomic.\r\n\r\nThis is why `volatile` cannot be applied to `long` or `double`, for example. The C# compiler cannot know whether your program will only ever run on a 64-bit system, so it can\u0027t know for certain that loads/stores of 64-bit types will be atomic. Conversely, `volatile` is allowed on `nint` and `object` because the C# compiler knows that those are pointer-sized and so will be atomic in any case.\r\n\r\n(Note that none of this is relevant to `char` *specifically*. There is no technical reason that `char` can\u0027t be supported by the `volatile` keyword and the `Volatile` class. It\u0027s likely more a case of \"...but why?\".)",
                                           "updatedAt":  "2022-12-21T21:28:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RMB6k",
                                           "createdAt":  "2022-12-21T21:32:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wasabii",
                                           "body":  "\u003e(Note that none of this is relevant to char specifically. There is no technical reason that char can\u0027t be supported by the volatile keyword and the Volatile class. It\u0027s likely more a case of \"...but why?\".)\r\n\r\nI have no particular need for the volatile keyword for `char`. So I\u0027ll not talk about that.\r\n\r\nBut I do have a particular need for System.Threading.Volatile, as I need to be able to do volatile reads and writes on arbitrary pointers to unmanaged memory, char[]s, and also volatile read/writes on fields of type char which are not marked with `volatile`.\r\n\r\nMore specific information: I am the maintainer of IKVM. I am reimplementing `sun.misc.Unsafe`, which provides a `putCharVolatile()` method for doing a volatile update of a char, expressed either as a field, offset into an array, or a pointer to unmanaged memory.\r\n\r\nI managed to get it working by doing `Volatile.Write(ref Unsafe.As\u003cchar, short\u003e(ref l), v)`, which isn\u0027t a problem per-say, but it does feel weird to have this missing primitive type on Volatile.",
                                           "updatedAt":  "2022-12-21T21:32:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RMCHK",
                                           "createdAt":  "2022-12-21T21:33:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "~~What do you mean? As I\u0027m imagining it, you would be able to declare `volatile` fields of any type, and `Volatile.Read/Write` would work with any type (the reference type constraint would be removed). ECMA says that `volatile.` can be used with `ldobj` and `stobj`.~~ Or not, you know better than me. 😅\r\n\r\nBTW here\u0027s a workaround (you are fast!):\r\n\r\n```csharp\r\nusing System.Runtime.CompilerServices;\r\nusing System.Threading;\r\n\r\npublic static class C {\r\n    public static char VolatileRead(ref char c) =\u003e\r\n        (char)Volatile.Read(ref Unsafe.As\u003cchar, short\u003e(ref c));\r\n    public static void VolatileWrite(ref char c, char value) =\u003e\r\n        Volatile.Write(ref Unsafe.As\u003cchar, short\u003e(ref c), (short)value);\r\n}\r\n```",
                                           "updatedAt":  "2022-12-21T21:33:27Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "[API Proposal]: Add Volatile.Write(ref char, char) and char Volatile.Read(ref char)",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/80650",
        "createdAt":  "2023-01-14T06:20:16Z",
        "number":  80650,
        "author":  "Hermholtz",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-07-24T17:59:18Z",
        "body":  "There are two definitions of `PaddingFor32`. They have different cache line size for x86_64 architecture. The effect is memory waste in some (not very common) scenarios.\r\n\r\nMaybe the second one is not needed? Or if it\u0027s needed, maybe it should be updated to have the same contents to not waste memory on x86_64?\r\n\r\n[src/libraries/System.Private.CoreLib/src/Internal/Padding.cs](https://github.com/dotnet/runtime/blob/632f2cd18ac052eb2b4b89cb595221fd4b59a4f4/src/libraries/System.Private.CoreLib/src/Internal/Padding.cs)\r\nand\r\n[src/libraries/Common/src/Internal/Padding.cs](https://github.com/dotnet/runtime/blob/632f2cd18ac052eb2b4b89cb595221fd4b59a4f4/src/libraries/Common/src/Internal/Padding.cs)\r\n\r\nThanks.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOUnL1GA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5Saewp",
                                           "createdAt":  "2023-01-14T06:20:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2023-01-14T06:20:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5SbiiC",
                                           "createdAt":  "2023-01-14T22:33:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCyrVNw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "EgorBo",
                                                                               "createdAt":  "2023-01-15T22:01:45Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "`src/libraries/System.Private.CoreLib/src/Internal/Padding.cs` is more precise definition that assumes that the code is compiled architecture-specific. CoreLib is the only managed library in dotnet/runtime that is compiled as architecture specific.\r\n\r\n`src/libraries/Common/src/Internal/Padding.cs` is conservative architecture-neutral definition. It is meant to be used outside CoreLib.",
                                           "updatedAt":  "2023-01-14T22:33:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Sbiis",
                                           "createdAt":  "2023-01-14T22:33:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThere are two definitions of `PaddingFor32`. They have different cache line size for x86_64 architecture. The effect is memory waste in some (not very common) scenarios.\r\n\r\nMaybe the second one is not needed? Or if it\u0027s needed, maybe it should be updated to have the same contents to not waste memory on x86_64?\r\n\r\n[src/libraries/System.Private.CoreLib/src/Internal/Padding.cs](https://github.com/dotnet/runtime/blob/632f2cd18ac052eb2b4b89cb595221fd4b59a4f4/src/libraries/System.Private.CoreLib/src/Internal/Padding.cs)\r\nand\r\n[src/libraries/Common/src/Internal/Padding.cs](https://github.com/dotnet/runtime/blob/632f2cd18ac052eb2b4b89cb595221fd4b59a4f4/src/libraries/Common/src/Internal/Padding.cs)\r\n\r\nThanks.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eHermholtz\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-01-14T22:33:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ScvUY",
                                           "createdAt":  "2023-01-15T22:07:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "I assume it can be unified if you want to file a PR, just make sure to use `#if SYSTEM_PRIVATE_CORELIB`",
                                           "updatedAt":  "2023-01-15T22:07:15Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Duplicate definition of PaddingFor32 with different cache line size on x86_64",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/80861",
        "createdAt":  "2023-01-19T10:54:34Z",
        "number":  80861,
        "author":  "performanceautofiler",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-06-22T01:41:25Z",
        "body":  "### Run Information\r\n\r\nArchitecture | arm64\r\n-- | --\r\nOS | Windows 10.0.25094\r\nBaseline | [b53dfdf794d0355f2b615290f6763ae34ba88e8a](https://github.com/dotnet/runtime/commit/b53dfdf794d0355f2b615290f6763ae34ba88e8a)\r\nCompare | [99ba09612b31e90e1e7feb5511ee541f9f3ef02b](https://github.com/dotnet/runtime/commit/99ba09612b31e90e1e7feb5511ee541f9f3ef02b)\r\nDiff | [Diff](https://github.com/dotnet/runtime/compare/b53dfdf794d0355f2b615290f6763ae34ba88e8a...99ba09612b31e90e1e7feb5511ee541f9f3ef02b)\r\n\r\n\r\n### Regressions in System.Threading.Tests.Perf_Thread\r\n\r\nBenchmark | Baseline | Test | Test/Base | Test Quality | Edge Detector | Baseline IR | Compare IR | IR Ratio | Baseline ETL | Compare ETL\r\n-- | -- | -- | -- | -- | -- | -- | -- | -- | -- | --\r\n[GetCurrentProcessorId - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_arm64_Windows 10.0.25094/System.Threading.Tests.Perf_Thread.GetCurrentProcessorId.html\u003e) | 1.93 ns | 5.59 ns | 2.90 | 0.89 | False | | |\r\n\r\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/01_19_2023/refs/heads/main_arm64_Windows%2010.0.25094_Regression/System.Threading.Tests.Perf_Thread_1.png\u003e)\r\n[Test Report](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/01_19_2023/refs/heads/main_arm64_Windows%2010.0.25094_Regression/System.Threading.Tests.Perf_Thread.html\u003e)\r\n\r\n### Repro\r\n\r\n```cmd\r\ngit clone https://github.com/dotnet/performance.git\r\npy .\\performance\\scripts\\benchmarks_ci.py -f net8.0 --filter \u0027System.Threading.Tests.Perf_Thread*\u0027\r\n```\r\n\u003cdetails\u003e\r\n\r\n### Payloads\r\n\r\n[Baseline](\u003chttps://helixdi107v0xdeko0k025g8.blob.core.windows.net/helix-job-e9729b3a-cc7b-498c-ab43-7d802951d151195eb393f0247f48c/2356ec65-b926-43be-9c03-80918c6ec150.zip?sv=2021-08-06\u0026se=2023-02-12T11%3A42%3A31Z\u0026sr=c\u0026sp=rl\u0026sig=MdhkGha3dtr40ExlCxT3hwAupHS1v9tSyb%2FBYKW%2BciM%3D\u003e)\r\n[Compare](\u003chttps://helixdi107v0xdeko0k025g8.blob.core.windows.net/helix-job-53e4f4c4-3005-4c7c-97e9-8553ab6cb386e0c61f0b7024fc09d/cb09f8fd-df0b-4fe1-9cfd-f81e23012a6b.zip?sv=2021-08-06\u0026se=2023-02-13T03%3A39%3A36Z\u0026sr=c\u0026sp=rl\u0026sig=k6IR3TGXofnPN3Wcjxbcssf3z%2BzJmYvM%2F7XC11yH0vg%3D\u003e)\r\n### Histogram\r\n\r\n#### System.Threading.Tests.Perf_Thread.GetCurrentProcessorId\r\n\r\n```log\r\n\r\n```\r\n### Description of detection logic\r\n```IsRegressionBase: Marked as regression because the compare was 5% greater than the baseline, and the value was not too small.\r\nIsRegressionChecked: Marked as regression because the three check build points were 0.05 greater than the baseline.\r\nIsImprovementBase: Marked as not an improvement because the compare was not 5% less than the baseline, or the value was too small.\r\nIsRegressionBase: Marked as regression because the compare was 5% greater than the baseline, and the value was not too small.\r\nIsRegressionChecked: Marked as regression because the three check build points were 0.05 greater than the baseline.\r\nIsRegressionWindowed: Marked as regression because 5.590015446048096 \u003e 2.899760743523029.\r\nIsChangePoint: Marked as a change because one of 10/5/2022 3:48:29 AM, 10/11/2022 5:13:36 PM, 1/13/2023 3:30:06 PM, 1/19/2023 1:09:52 AM falls between 1/10/2023 12:53:48 PM and 1/19/2023 1:09:52 AM.\r\nIsRegressionStdDev: Marked as regression because -4.081587394244101 (T) = (0 -8.168585037970475) / Math.Sqrt((2.040771031822769 / (23)) + (26.661786250261294 / (20))) is less than -2.019540970439573 = MathNet.Numerics.Distributions.StudentT.InvCDF(0, 1, (23) + (20) - 2, .025) and -1.4740550483169508 = (3.3016989834269843 - 8.168585037970475) / 3.3016989834269843 is less than -0.05.\r\nIsImprovementBase: Marked as not an improvement because the compare was not 5% less than the baseline, or the value was too small.\r\nIsChangeEdgeDetector: Marked not as a regression because Edge Detector said so.\r\n\r\n```\r\n\r\n### Docs\r\n\r\n[Profiling workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/profiling-workflow-dotnet-runtime.md)\r\n[Benchmarking workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/benchmarking-workflow-dotnet-runtime.md)\r\n\r\n\u003c/details\u003e\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYj_rFw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5TSeBH",
                                           "createdAt":  "2023-01-19T17:29:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Run Information\r\n\r\nArchitecture | arm64\r\n-- | --\r\nOS | Windows 10.0.25094\r\nBaseline | [b53dfdf794d0355f2b615290f6763ae34ba88e8a](https://github.com/dotnet/runtime/commit/b53dfdf794d0355f2b615290f6763ae34ba88e8a)\r\nCompare | [99ba09612b31e90e1e7feb5511ee541f9f3ef02b](https://github.com/dotnet/runtime/commit/99ba09612b31e90e1e7feb5511ee541f9f3ef02b)\r\nDiff | [Diff](https://github.com/dotnet/runtime/compare/b53dfdf794d0355f2b615290f6763ae34ba88e8a...99ba09612b31e90e1e7feb5511ee541f9f3ef02b)\r\n\r\n\r\n### Regressions in System.Threading.Tests.Perf_Thread\r\n\r\nBenchmark | Baseline | Test | Test/Base | Test Quality | Edge Detector | Baseline IR | Compare IR | IR Ratio | Baseline ETL | Compare ETL\r\n-- | -- | -- | -- | -- | -- | -- | -- | -- | -- | --\r\n[GetCurrentProcessorId - Duration of single invocation](\u003chttps://pvscmdupload.blob.core.windows.net/reports/allTestHistory/refs/heads/main_arm64_Windows 10.0.25094/System.Threading.Tests.Perf_Thread.GetCurrentProcessorId.html\u003e) | 1.93 ns | 5.59 ns | 2.90 | 0.89 | False | | |\r\n\r\n![graph](\u003chttps://pvscmdupload.blob.core.windows.net/autofilereport/autofilereports/01_19_2023/refs/heads/main_arm64_Windows%2010.0.25094_Regression/System.Threading.Tests.Perf_Thread_1.png\u003e)\r\n[Test Report](\u003chttps://pvscmdupload.blob.core.windows.net/autofilereport/autofilereports/01_19_2023/refs/heads/main_arm64_Windows%2010.0.25094_Regression/System.Threading.Tests.Perf_Thread.html\u003e)\r\n\r\n### Repro\r\n\r\n```cmd\r\ngit clone https://github.com/dotnet/performance.git\r\npy .\\performance\\scripts\\benchmarks_ci.py -f net8.0 --filter \u0027System.Threading.Tests.Perf_Thread*\u0027\r\n```\r\n\u003cdetails\u003e\r\n\r\n### Payloads\r\n\r\n[Baseline](\u003chttps://helixdi107v0xdeko0k025g8.blob.core.windows.net/helix-job-e9729b3a-cc7b-498c-ab43-7d802951d151195eb393f0247f48c/2356ec65-b926-43be-9c03-80918c6ec150.zip?sv=2021-08-06\u0026se=2023-02-12T11%3A42%3A31Z\u0026sr=c\u0026sp=rl\u0026sig=MdhkGha3dtr40ExlCxT3hwAupHS1v9tSyb%2FBYKW%2BciM%3D\u003e)\r\n[Compare](\u003chttps://helixdi107v0xdeko0k025g8.blob.core.windows.net/helix-job-53e4f4c4-3005-4c7c-97e9-8553ab6cb386e0c61f0b7024fc09d/cb09f8fd-df0b-4fe1-9cfd-f81e23012a6b.zip?sv=2021-08-06\u0026se=2023-02-13T03%3A39%3A36Z\u0026sr=c\u0026sp=rl\u0026sig=k6IR3TGXofnPN3Wcjxbcssf3z%2BzJmYvM%2F7XC11yH0vg%3D\u003e)\r\n### Histogram\r\n\r\n#### System.Threading.Tests.Perf_Thread.GetCurrentProcessorId\r\n\r\n```log\r\n\r\n```\r\n### Description of detection logic\r\n```IsRegressionBase: Marked as regression because the compare was 5% greater than the baseline, and the value was not too small.\r\nIsRegressionChecked: Marked as regression because the three check build points were 0.05 greater than the baseline.\r\nIsImprovementBase: Marked as not an improvement because the compare was not 5% less than the baseline, or the value was too small.\r\nIsRegressionBase: Marked as regression because the compare was 5% greater than the baseline, and the value was not too small.\r\nIsRegressionChecked: Marked as regression because the three check build points were 0.05 greater than the baseline.\r\nIsRegressionWindowed: Marked as regression because 5.590015446048096 \u003e 2.899760743523029.\r\nIsChangePoint: Marked as a change because one of 10/5/2022 3:48:29 AM, 10/11/2022 5:13:36 PM, 1/13/2023 3:30:06 PM, 1/19/2023 1:09:52 AM falls between 1/10/2023 12:53:48 PM and 1/19/2023 1:09:52 AM.\r\nIsRegressionStdDev: Marked as regression because -4.081587394244101 (T) = (0 -8.168585037970475) / Math.Sqrt((2.040771031822769 / (23)) + (26.661786250261294 / (20))) is less than -2.019540970439573 = MathNet.Numerics.Distributions.StudentT.InvCDF(0, 1, (23) + (20) - 2, .025) and -1.4740550483169508 = (3.3016989834269843 - 8.168585037970475) / 3.3016989834269843 is less than -0.05.\r\nIsImprovementBase: Marked as not an improvement because the compare was not 5% less than the baseline, or the value was too small.\r\nIsChangeEdgeDetector: Marked not as a regression because Edge Detector said so.\r\n\r\n```\r\n\r\n### Docs\r\n\r\n[Profiling workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/profiling-workflow-dotnet-runtime.md)\r\n[Benchmarking workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/benchmarking-workflow-dotnet-runtime.md)\r\n\r\n\u003c/details\u003e\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eperformanceautofiler[bot]\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-01-19T17:29:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TSeFz",
                                           "createdAt":  "2023-01-19T17:30:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "cincuranet",
                                           "body":  "Looks PGO related.\r\n\r\ncc @AndyAyersMS ",
                                           "updatedAt":  "2023-01-19T17:30:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iP-sX",
                                           "createdAt":  "2023-07-24T17:57:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "this is mis-labeled into System.Threading. Is there is lable for PGO? ",
                                           "updatedAt":  "2023-07-24T17:57:30Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "[Perf] Windows/arm64: 1 Regression on 1/13/2023 8:11:05 PM",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/80983",
        "createdAt":  "2023-01-21T23:50:35Z",
        "number":  80983,
        "author":  "VSadov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-10-09T23:07:37Z",
        "body":  "\r\nWe tend to saturate the machine and take 100% CPU even for scenarios when 20% CPU would be sufficient.  \r\n\r\nThe reason for the CPU consumption is spinning as a part of spinwaiting or conflict resolution backoffs. The most noticeable case of spinning is the one done in the threadpool as a part of a guarantee that any incoming task will be picked up by a worker. \r\n\r\nAs worker threads could block, we do not consider that workers already executing tasks will pick the new tasks reliably, thus the threadpool ensures that there is an outstanding thread request after a task is enqueued. In scenarios not requiring 100% CPU, such request is quickly satisfied. On the other hand in a steady state the threadpool is nearly empty (since workers are keeping up with tasks), thus many threads will find no work and leave, only to be invited back again. We will have a few lucky workers working and the rest bouncing between the task queue and the threadpool semaphore. The constant churn of threads between the task queue and the semaphore is at best wasteful. We often find ourselves at 100% utilization even when incoming tasks require much less.\r\n\r\nWe need something more intelligent here, but this is a nontrivial problem. There is a lot of concerns that would need to be considered – worker blocking, starvation, workitem latency, …   \r\n\r\nA better detection of blocked threads could be the key to having more options regarding thread wakeups as that could relax the requirements on ensuring a thread wake for every incoming task.\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOU2iGcA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5TaIZw",
                                           "createdAt":  "2023-01-21T23:50:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n\r\nWe tend to saturate the machine and take 100% CPU even for scenarios when 20% CPU would be sufficient.  \r\n\r\nThe reason for the CPU consumption is spinning as a part of spinwaiting or conflict resolution backoffs. The most noticeable case of spinning is the one done in the threadpool as a part of a guarantee that any incoming task will be picked up by a worker. \r\n\r\nAs worker threads could block, we do not consider that workers already executing tasks will pick the new tasks reliably, thus the threadpool ensures that there is an outstanding thread request after a task is enqueued. In scenarios not requiring 100% CPU, such request is quickly satisfied. On the other hand in a steady state the threadpool is nearly empty (since workers are keeping up with tasks), thus many threads will find no work and leave, only to be invited back again. We will have a few lucky workers working and the rest bouncing between the task queue and the threadpool semaphore. The constant churn of threads between the task queue and the semaphore is at best wasteful. We often find ourselves at 100% utilization even when incoming tasks require much less.\r\n\r\nWe need something more intelligent here, but this is a nontrivial problem. There is a lot of concerns that would need to be considered – worker blocking, starvation, workitem latency, …   \r\n\r\nA better detection of blocked threads could be the key to having more options regarding thread wakeups as that could relax the requirements on ensuring a thread wake for every incoming task.\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eVSadov\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-01-21T23:50:44Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Reduce tendency of the threadpool to consume extra CPU resources when it is not helpful.",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/80984",
        "createdAt":  "2023-01-21T23:55:22Z",
        "number":  80984,
        "author":  "VSadov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-10-09T23:04:23Z",
        "body":  "The most noticeable expense is reporting the completion time for every task. Every task writes to a shared variable (Re: `ThreadPool.NotifyWorkItemComplete` ). That is very expensive on a manycore machine as ownership of the variable cache line is constantly transferred from one core to another.  \r\n \r\nWe use the last completion time for:\r\n-\tHill climbing, [which appears to have questionable value](https://github.com/dotnet/runtime/issues/80988), as other experiments also observed.\r\n-\tStarvation/blocking detection, which does not need this value very often \r\n\r\nAn easy workaround would be to record the last completion per thread and make the starvation detection scan through threads.  \r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOU2im0g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5TaIhn",
                                           "createdAt":  "2023-01-21T23:55:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n\r\nThe most noticeable expense is reporting the completion time for every task. Every task writes to a shared variable (Re: `ThreadPool.NotifyWorkItemComplete` ). That is very expensive on a manycore machine as ownership of the variable cache line is constantly transferred from one core to another.  \r\n \r\nWe use the last completion time for:\r\n-\tHill climbing, which appears to have questionable value, as other experiments also observed.\r\n-\tStarvation/blocking detection, which does not need this value very often \r\n\r\nAn easy workaround would be to record the last completion per thread and make the starvation detection scan through threads.  \r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eVSadov\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-01-21T23:55:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TaKbS",
                                           "createdAt":  "2023-01-22T00:41:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "omariom",
                                           "body":  "`An easy workaround would be to record the last completion per thread`\r\n\r\nor per core?",
                                           "updatedAt":  "2023-01-22T00:41:37Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Reduce overhead of the threadpool task dispatching.",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/80988",
        "createdAt":  "2023-01-22T00:20:25Z",
        "number":  80988,
        "author":  "VSadov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCuBC1w==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MarcoRossignoli",
                                            "createdAt":  "2023-01-22T07:21:45Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "strangeman375",
                                            "createdAt":  "2023-01-22T14:23:30Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2023-07-24T18:01:15Z",
        "body":  "\r\nHillClimbing is based on the idea of estimating the needs of the threadpool by making small experiments and observing the long-term reaction of the system. \r\nWhile the idea makes sense in theory, the reaction time appears to be too long to be helpful in typical scenarios when thread pool needs to adjust to varying needs and availability of resources. \r\n\r\nSomething that considers depths of task queues (perhaps with a bit of temporal filtering) could have faster adjustment time and yet sufficient enough in over/under utilization prevention.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOU2nN2w==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5TaJr3",
                                           "createdAt":  "2023-01-22T00:20:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2023-01-22T00:20:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TaJsq",
                                           "createdAt":  "2023-01-22T00:20:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n\r\nHillClimbing is based on the idea of estimating the needs of the threadpool by making small experiments and observing the long-term reaction of the system. \r\nWhile the idea makes sense in theory, the reaction time appears to be too long to be helpful in typical scenarios when thread pool needs to adjust to varying needs and availability of resources. \r\n\r\nSomething that considers depths of task queues (perhaps with a bit of temporal filtering) could have faster adjustment time and yet sufficient enough in over/under utilization prevention.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eVSadov\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-01-22T00:20:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Tac3b",
                                           "createdAt":  "2023-01-22T09:54:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MarcoRossignoli",
                                           "body":  "Is there already a doc design for it?",
                                           "updatedAt":  "2023-01-22T09:54:08Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Replace HillClimbing with more direct feedback-based mechanism.",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/81255",
        "createdAt":  "2023-01-27T03:45:55Z",
        "number":  81255,
        "author":  "timcassell",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-07-24T17:56:29Z",
        "body":  "### Background and motivation\n\nI maintain a custom cancelation token that can be converted to and from `System.Threading.CancellationToken`. Since the `CancellationTokenSource.TryReset` API was introduced in .Net 6, I have had to do some heavy-handed work to re-register my token to keep listening for the cancelation. Being able to listen to an event for when the source is reset would allow me to only re-register at that time, and remove a lot of code.\n\n### API Proposal\n\n```cs\r\nnamespace System.Threading;\r\n\r\npublic struct CancellationToken\r\n{\r\n    public event Action OnReset;\r\n}\r\n```\r\n\n\n### API Usage\n\n```cs\r\npublic class MyCustomToken\r\n{\r\n    public class MyCustomToken(CancellationToken token)\r\n    {\r\n        token.OnReset += () =\u003e token.Register(OnCanceled);\r\n        token.Register(OnCanceled);\r\n    }\r\n    \r\n    private void OnCanceled()\r\n    {\r\n        // Logic for custom cancelation,\r\n        // including handling the case of double registration due to a thread race.\r\n    }\r\n    \r\n    // Other public methods that are irrelevant for this proposal...\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n#60843 Was an idea to have an alternative callback when the callback is unregistered without being invoked, but it wasn\u0027t good because it would increase the cost of other more common operations. This proposal deals with that issue by only raising a global event when `TryReset` is called, instead of individual callbacks for each registration, so other operations aren\u0027t affected (and memory increase for the event is minimal).\n\n### Risks\n\nSlightly increases memory of `CancellationTokenSource`.\r\n\r\nPossible race condition if `TryReset` is called on another thread while registering the first time (but that would be a mis-use of the `TryReset` API, going against the intended use laid out in the documentation, and that\u0027s already a possible race condition today).",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOU82O9Q==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5TzY71",
                                           "createdAt":  "2023-01-27T03:46:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nI maintain a custom cancelation token that can be converted to and from `System.Threading.CancellationToken`. Since the `CancellationTokenSource.TryReset` API was introduced in .Net 6, I have had to do some heavy-handed work to re-register my token to keep listening for the cancelation. Being able to listen to an event for when the source is reset would allow me to only re-register at that time, and remove a lot of code.\n\n### API Proposal\n\n```cs\r\nnamespace System.Threading;\r\n\r\npublic struct CancellationToken\r\n{\r\n    public event Action OnReset;\r\n}\r\n```\r\n\n\n### API Usage\n\n```cs\r\npublic class MyCustomToken\r\n{\r\n    public class MyCustomToken(CancellationToken token)\r\n    {\r\n        token.OnReset += () =\u003e token.Register(OnCanceled);\r\n        token.Register(OnCanceled);\r\n    }\r\n    \r\n    private void OnCanceled()\r\n    {\r\n        // Logic for custom cancelation,\r\n        // including handling the case of double registration due to a thread race.\r\n    }\r\n    \r\n    // Other public methods that are irrelevant for this proposal...\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n#60843 Was an idea to have an alternative callback when the callback is unregistered without being invoked, but it wasn\u0027t good because it would increase the cost of other more common operations. This proposal deals with that issue by only raising a global event when `TryReset` is called, instead of individual callbacks for each registration, so other operations aren\u0027t affected (and memory increase for the event is minimal).\n\n### Risks\n\nSlightly increases memory of `CancellationTokenSource`.\r\n\r\nPossible race condition if `TryReset` is called on another thread while registering the first time (but that would be a mis-use of the `TryReset` API, going against the intended use laid out in the documentation, and that\u0027s already a possible race condition today).\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003etimcassell\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-01-27T03:46:03Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "[API Proposal]: CancellationToken.OnReset event",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/82828",
        "createdAt":  "2023-03-01T12:47:59Z",
        "number":  82828,
        "author":  "enegriy",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-10-13T08:39:47Z",
        "body":  "### Description\r\n\r\nGood afternoon! \r\nI have a problem with the application in production, it freezes periodically. \r\nHelp me please!\r\n\r\nCrash dump\r\n\r\n```\r\nOS Thread Id: 0x1 (0) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x7 (1) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x8 (2) Current frame: libpthread_2_23!waitpid + 0x6b\r\nOS Thread Id: 0x9 (3) Current frame: libpthread_2_23!open64 + 0x2d\r\nOS Thread Id: 0xa (4) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0xb (5) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0xc (6) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0xd (7) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0xe (8) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0xf (9) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x10 (10) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x11 (11) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x12 (12) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x13 (13) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x14 (14) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x15 (15) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x16 (16) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x17 (17) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x18 (18) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x19 (19) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x1b (20) Current frame: libpthread_2_23!read + 0x2d\r\nOS Thread Id: 0x1c (21) Current frame: libpthread_2_23!read + 0x2d\r\nOS Thread Id: 0x1d (22) Current frame: libpthread_2_23!read + 0x2d\r\nOS Thread Id: 0x1e (23) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x20 (24) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x21 (25) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x22 (26) Current frame: libc_2_23!epoll_wait + 0x33\r\nOS Thread Id: 0x24 (27) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x25 (28) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x26 (29) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x27 (30) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x28 (31) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x29 (32) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x2f (33) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x30 (34) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x31 (35) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x32 (36) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x33 (37) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x34 (38) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x35 (39) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x36 (40) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x37 (41) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x38 (42) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x39 (43) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x3a (44) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x3b (45) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x43 (46) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x44 (47) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x45 (48) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x46 (49) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x47 (50) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x48 (51) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x49 (52) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x4a (53) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x4b (54) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x4c (55) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x4d (56) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x4e (57) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x64 (58) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x65 (59) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x66 (60) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x67 (61) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x68 (62) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x69 (63) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x6a (64) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x6b (65) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x6c (66) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x6d (67) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x6e (68) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x6f (69) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x70 (70) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x71 (71) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0xf0a (72) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0xf0b (73) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0xf0c (74) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0xf0d (75) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0xf0e (76) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0xf0f (77) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0xf10 (78) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0xf11 (79) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0xf12 (80) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0xf13 (81) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0xf14 (82) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0xf15 (83) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x1491 (84) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x1497 (85) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x1498 (86) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x149f (87) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14b3 (88) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14bc (89) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14ca (90) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14d4 (91) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14db (92) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14de (93) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14e0 (94) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14e1 (95) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14e3 (96) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14e5 (97) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14ea (98) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14ec (99) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14ed (100) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14ee (101) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14f1 (102) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14f2 (103) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14f3 (104) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14f6 (105) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14f7 (106) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14f8 (107) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14f9 (108) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14fa (109) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14fb (110) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14fc (111) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14fd (112) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14fe (113) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14ff (114) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\n```\r\nOS: ubuntu:xenia\r\nGLIBC: Ubuntu GLIBC 2.23\r\n.Net 6.0\r\n\r\n\r\n\r\n\r\n### Reproduction Steps\r\n\r\n...\r\n```\r\nOS Thread Id: 0xa (4)\r\nTEB information is not available so a stack size of 0xFFFF is assumed\r\nCurrent frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nChild-SP         RetAddr          Caller, Callee\r\n00007F5E1316AB00 00007f5e1514177b libcoreclr!CorUnix::CPalSynchronizationManager::ThreadNativeWait + 0x13b [/__w/1/s/src/coreclr/pal/src/synchmgr/synchmanager.cpp:488], calling libcoreclr + 0x760c0\r\n00007F5E1316AB20 00007f5e153f21d4 libc_2_23!_libc_malloc + 0x54, calling libc_2_23!IO_str_seekoff + 0x4ab0\r\n00007F5E1316AB60 00007f5e15141431 libcoreclr!CorUnix::CPalSynchronizationManager::BlockThread + 0x1d1 [/__w/1/s/src/coreclr/pal/src/synchmgr/synchmanager.cpp:307], calling libcoreclr!CorUnix::CPalSynchronizationManager::ThreadNativeWait [/__w/1/s/src/coreclr/pal/src/synchmgr/synchmanager.cpp:445]\r\n00007F5E1316ABC0 00007f5e15145e12 libcoreclr!CorUnix::InternalWaitForMultipleObjectsEx + 0x872 [/__w/1/s/src/coreclr/pal/src/synchmgr/wait.cpp:646]\r\n00007F5E1316AD60 00007f5e15146121 libcoreclr!WaitForMultipleObjectsEx + 0x51 [/__w/1/s/src/coreclr/pal/src/synchmgr/wait.cpp:206], calling libcoreclr!CorUnix::InternalWaitForMultipleObjectsEx [/__w/1/s/src/coreclr/pal/src/synchmgr/wait.cpp:361]\r\n00007F5E1316ADA0 00007f5e1501fc29 libcoreclr!DebuggerRCThread::MainLoop + 0xf9 [/__w/1/s/src/coreclr/debug/ee/rcthread.cpp:972], calling libcoreclr!WaitForMultipleObjectsEx [/__w/1/s/src/coreclr/pal/src/synchmgr/wait.cpp:191]\r\n00007F5E1316ADE0 00007f5e14cfd9e8 libcoreclr!CrstBase::Leave + 0x48 [/__w/1/s/src/coreclr/vm/crst.cpp:364], calling libcoreclr + 0x75180\r\n00007F5E1316AE20 00007f5e1501fa95 libcoreclr!DebuggerRCThread::ThreadProc + 0x115 [/__w/1/s/src/coreclr/debug/ee/rcthread.cpp:776], calling libcoreclr!DebuggerRCThread::MainLoop [/__w/1/s/src/coreclr/debug/ee/rcthread.cpp:895]\r\n00007F5E1316AE50 00007f5e1501f7dd libcoreclr!DebuggerRCThread::ThreadProcStatic + 0x1d [/__w/1/s/src/coreclr/debug/ee/rcthread.cpp:1361], calling libcoreclr!DebuggerRCThread::ThreadProc [/__w/1/s/src/coreclr/debug/ee/rcthread.cpp:641]\r\n00007F5E1316AE60 00007f5e1514dabe libcoreclr!CorUnix::CPalThread::ThreadEntry + 0x24e [/__w/1/s/src/coreclr/pal/src/thread/thread.cpp:1865]\r\n00007F5E1316AFB0 00007f5e1547551d libc_2_23!clone + 0x6d\r\n```\r\n\r\n...\r\n\r\n```\r\nOS Thread Id: 0x1497 (85)\r\nTEB information is not available so a stack size of 0xFFFF is assumed\r\nCurrent frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nChild-SP         RetAddr          Caller, Callee\r\n00007F56BAFFC670 00007f5e15141766 libcoreclr!CorUnix::CPalSynchronizationManager::ThreadNativeWait + 0x126 [/__w/1/s/src/coreclr/pal/src/synchmgr/synchmanager.cpp:488], calling libcoreclr + 0x76180\r\n00007F56BAFFC6D0 00007f5e15141431 libcoreclr!CorUnix::CPalSynchronizationManager::BlockThread + 0x1d1 [/__w/1/s/src/coreclr/pal/src/synchmgr/synchmanager.cpp:307], calling libcoreclr!CorUnix::CPalSynchronizationManager::ThreadNativeWait [/__w/1/s/src/coreclr/pal/src/synchmgr/synchmanager.cpp:445]\r\n00007F56BAFFC730 00007f5e15145e12 libcoreclr!CorUnix::InternalWaitForMultipleObjectsEx + 0x872 [/__w/1/s/src/coreclr/pal/src/synchmgr/wait.cpp:646]\r\n00007F56BAFFC8D0 00007f5e15145fd4 libcoreclr!PAL_WaitForSingleObjectPrioritized + 0x54 [/__w/1/s/src/coreclr/pal/src/synchmgr/wait.cpp:15732480], calling libcoreclr!CorUnix::InternalWaitForMultipleObjectsEx [/__w/1/s/src/coreclr/pal/src/synchmgr/wait.cpp:361]\r\n00007F56BAFFC900 00007f5e14e18179 libcoreclr!WaitHandleNative::CorWaitOnePrioritizedNative + 0x59 [/__w/1/s/src/coreclr/vm/comwaithandle.cpp:15732480], calling libcoreclr!PAL_WaitForSingleObjectPrioritized [/__w/1/s/src/coreclr/pal/src/synchmgr/wait.cpp:100]\r\n00007F56BAFFC960 00007f5d9b32f457 (MethodDesc 00007f5da056dd98 + 0x67 System.Threading.LowLevelLifoSemaphore.WaitNative(Microsoft.Win32.SafeHandles.SafeWaitHandle, Int32))\r\n00007F56BAFFC9A8 00007f5d9b32f447 (MethodDesc 00007f5da056dd98 + 0x57 System.Threading.LowLevelLifoSemaphore.WaitNative(Microsoft.Win32.SafeHandles.SafeWaitHandle, Int32)), calling libcoreclr!JIT_PInvokeBegin [/__w/1/s/src/coreclr/pal/inc/unixasmmacrosamd64.inc:899]\r\n00007F56BAFFCA20 00007f5da0791e3a (MethodDesc 00007f5da056de50 + 0x3a System.Threading.LowLevelLifoSemaphore.WaitForSignal(Int32)), calling 00007f5d9ff271d0 (stub for System.Threading.LowLevelLifoSemaphore.WaitNative(Microsoft.Win32.SafeHandles.SafeWaitHandle, Int32))\r\n00007F56BAFFCA60 00007f5da078ccd7 (MethodDesc 00007f5da056de20 + 0x257 System.Threading.LowLevelLifoSemaphore.Wait(Int32, Boolean)), calling (MethodDesc 00007f5da056de50 + 0 System.Threading.LowLevelLifoSemaphore.WaitForSignal(Int32))\r\n00007F56BAFFCA98 00007f5da078cc2a (MethodDesc 00007f5da056de20 + 0x1aa System.Threading.LowLevelLifoSemaphore.Wait(Int32, Boolean))\r\n00007F56BAFFCAF0 00007f5da15d8337 (MethodDesc 00007f5da056dc00 + 0x237 System.Threading.PortableThreadPool+WorkerThread.WorkerThreadStart()), calling (MethodDesc 00007f5da056de20 + 0 System.Threading.LowLevelLifoSemaphore.Wait(Int32, Boolean))\r\n00007F56BAFFCB40 00007f5da15d82b5 (MethodDesc 00007f5da056dc00 + 0x1b5 System.Threading.PortableThreadPool+WorkerThread.WorkerThreadStart())\r\n00007F56BAFFCBB0 00007f5e14fb9c67 libcoreclr!CallDescrWorkerInternal + 0x7c [/__w/1/s/src/coreclr/pal/inc/unixasmmacrosamd64.inc:854]\r\n00007F56BAFFCBD0 00007f5e14defaee libcoreclr!DispatchCallSimple + 0xfe [/__w/1/s/src/coreclr/vm/callhelpers.cpp:220], calling libcoreclr!CallDescrWorkerInternal [/__w/1/s/src/coreclr/pal/inc/unixasmmacrosamd64.inc:796]\r\n00007F56BAFFCC60 00007f5e14e08672 libcoreclr!ThreadNative::KickOffThread_Worker + 0x92 [/__w/1/s/src/coreclr/vm/comsynchronizable.cpp:15732480], calling libcoreclr!DispatchCallSimple [/__w/1/s/src/coreclr/vm/callhelpers.cpp:173]\r\n00007F56BAFFCC90 00007f5e14d223c9 libcoreclr!Frame::Push + 0x19 [/__w/1/s/src/coreclr/vm/frames.cpp:383], calling libcoreclr + 0x75180\r\n00007F56BAFFCCB0 00007f5e14db482a libcoreclr!ManagedThreadBase_DispatchOuter + 0x14a [/__w/1/s/src/coreclr/vm/threads.cpp:7549]\r\n00007F56BAFFCDD0 00007f5e14db4e2d libcoreclr!ManagedThreadBase::KickOff + 0x2d [/__w/1/s/src/coreclr/vm/threads.cpp:7604], calling libcoreclr!ManagedThreadBase_DispatchOuter [/__w/1/s/src/coreclr/vm/threads.cpp:7476]\r\n00007F56BAFFCE00 00007f5e14e08747 libcoreclr!ThreadNative::KickOffThread + 0xb7 [/__w/1/s/src/coreclr/vm/comsynchronizable.cpp:230], calling libcoreclr!ManagedThreadBase::KickOff [/__w/1/s/src/coreclr/vm/threads.cpp:7602]\r\n00007F56BAFFCE60 00007f5e1514dabe libcoreclr!CorUnix::CPalThread::ThreadEntry + 0x24e [/__w/1/s/src/coreclr/pal/src/thread/thread.cpp:1865]\r\n00007F56BAFFCFB0 00007f5e1547551d libc_2_23!clone + 0x6d\r\n```\r\n\r\n\r\n### Expected behavior\r\n\r\nDoes not freezed\r\n\r\n### Actual behavior\r\n\r\nfreezed\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\n_No response_\r\n\r\n### Other information\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOaPjZfQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5Wbrjx",
                                           "createdAt":  "2023-03-01T12:48:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nGood afternoon! \r\nI have a problem with the application in production, it freezes periodically. \r\nHelp me please!\r\n\r\nCrash dump\r\n\r\n```\r\nOS Thread Id: 0x1 (0) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x7 (1) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x8 (2) Current frame: libpthread_2_23!waitpid + 0x6b\r\nOS Thread Id: 0x9 (3) Current frame: libpthread_2_23!open64 + 0x2d\r\nOS Thread Id: 0xa (4) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0xb (5) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0xc (6) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0xd (7) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0xe (8) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0xf (9) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x10 (10) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x11 (11) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x12 (12) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x13 (13) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x14 (14) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x15 (15) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x16 (16) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x17 (17) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x18 (18) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x19 (19) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x1b (20) Current frame: libpthread_2_23!read + 0x2d\r\nOS Thread Id: 0x1c (21) Current frame: libpthread_2_23!read + 0x2d\r\nOS Thread Id: 0x1d (22) Current frame: libpthread_2_23!read + 0x2d\r\nOS Thread Id: 0x1e (23) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x20 (24) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x21 (25) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x22 (26) Current frame: libc_2_23!epoll_wait + 0x33\r\nOS Thread Id: 0x24 (27) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x25 (28) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x26 (29) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x27 (30) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x28 (31) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x29 (32) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x2f (33) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x30 (34) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x31 (35) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x32 (36) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x33 (37) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x34 (38) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x35 (39) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x36 (40) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x37 (41) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x38 (42) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x39 (43) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x3a (44) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x3b (45) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x43 (46) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x44 (47) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x45 (48) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x46 (49) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x47 (50) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x48 (51) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x49 (52) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x4a (53) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x4b (54) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x4c (55) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x4d (56) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0x4e (57) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x64 (58) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x65 (59) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x66 (60) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x67 (61) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x68 (62) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x69 (63) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x6a (64) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x6b (65) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x6c (66) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x6d (67) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x6e (68) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x6f (69) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x70 (70) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0x71 (71) Current frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nOS Thread Id: 0xf0a (72) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0xf0b (73) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0xf0c (74) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0xf0d (75) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0xf0e (76) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0xf0f (77) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0xf10 (78) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0xf11 (79) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0xf12 (80) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0xf13 (81) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0xf14 (82) Current frame: libc_2_23!_poll + 0x2d\r\nOS Thread Id: 0xf15 (83) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x1491 (84) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x1497 (85) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x1498 (86) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x149f (87) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14b3 (88) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14bc (89) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14ca (90) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14d4 (91) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14db (92) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14de (93) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14e0 (94) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14e1 (95) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14e3 (96) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14e5 (97) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14ea (98) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14ec (99) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14ed (100) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14ee (101) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14f1 (102) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14f2 (103) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14f3 (104) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14f6 (105) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14f7 (106) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14f8 (107) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14f9 (108) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14fa (109) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14fb (110) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14fc (111) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14fd (112) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14fe (113) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nOS Thread Id: 0x14ff (114) Current frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\n```\r\nOS: ubuntu:xenia\r\nGLIBC: Ubuntu GLIBC 2.23\r\n.Net 6.0\r\n\r\n\r\n\n\n### Reproduction Steps\n\n...\r\nOS Thread Id: 0xa (4)\r\nTEB information is not available so a stack size of 0xFFFF is assumed\r\nCurrent frame: libpthread_2_23!pthread_cond_wait + 0xc0\r\nChild-SP         RetAddr          Caller, Callee\r\n00007F5E1316AB00 00007f5e1514177b libcoreclr!CorUnix::CPalSynchronizationManager::ThreadNativeWait + 0x13b [/__w/1/s/src/coreclr/pal/src/synchmgr/synchmanager.cpp:488], calling libcoreclr + 0x760c0\r\n00007F5E1316AB20 00007f5e153f21d4 libc_2_23!_libc_malloc + 0x54, calling libc_2_23!IO_str_seekoff + 0x4ab0\r\n00007F5E1316AB60 00007f5e15141431 libcoreclr!CorUnix::CPalSynchronizationManager::BlockThread + 0x1d1 [/__w/1/s/src/coreclr/pal/src/synchmgr/synchmanager.cpp:307], calling libcoreclr!CorUnix::CPalSynchronizationManager::ThreadNativeWait [/__w/1/s/src/coreclr/pal/src/synchmgr/synchmanager.cpp:445]\r\n00007F5E1316ABC0 00007f5e15145e12 libcoreclr!CorUnix::InternalWaitForMultipleObjectsEx + 0x872 [/__w/1/s/src/coreclr/pal/src/synchmgr/wait.cpp:646]\r\n00007F5E1316AD60 00007f5e15146121 libcoreclr!WaitForMultipleObjectsEx + 0x51 [/__w/1/s/src/coreclr/pal/src/synchmgr/wait.cpp:206], calling libcoreclr!CorUnix::InternalWaitForMultipleObjectsEx [/__w/1/s/src/coreclr/pal/src/synchmgr/wait.cpp:361]\r\n00007F5E1316ADA0 00007f5e1501fc29 libcoreclr!DebuggerRCThread::MainLoop + 0xf9 [/__w/1/s/src/coreclr/debug/ee/rcthread.cpp:972], calling libcoreclr!WaitForMultipleObjectsEx [/__w/1/s/src/coreclr/pal/src/synchmgr/wait.cpp:191]\r\n00007F5E1316ADE0 00007f5e14cfd9e8 libcoreclr!CrstBase::Leave + 0x48 [/__w/1/s/src/coreclr/vm/crst.cpp:364], calling libcoreclr + 0x75180\r\n00007F5E1316AE20 00007f5e1501fa95 libcoreclr!DebuggerRCThread::ThreadProc + 0x115 [/__w/1/s/src/coreclr/debug/ee/rcthread.cpp:776], calling libcoreclr!DebuggerRCThread::MainLoop [/__w/1/s/src/coreclr/debug/ee/rcthread.cpp:895]\r\n00007F5E1316AE50 00007f5e1501f7dd libcoreclr!DebuggerRCThread::ThreadProcStatic + 0x1d [/__w/1/s/src/coreclr/debug/ee/rcthread.cpp:1361], calling libcoreclr!DebuggerRCThread::ThreadProc [/__w/1/s/src/coreclr/debug/ee/rcthread.cpp:641]\r\n00007F5E1316AE60 00007f5e1514dabe libcoreclr!CorUnix::CPalThread::ThreadEntry + 0x24e [/__w/1/s/src/coreclr/pal/src/thread/thread.cpp:1865]\r\n00007F5E1316AFB0 00007f5e1547551d libc_2_23!clone + 0x6d\r\n\r\n...\r\n\r\nOS Thread Id: 0x1497 (85)\r\nTEB information is not available so a stack size of 0xFFFF is assumed\r\nCurrent frame: libpthread_2_23!pthread_cond_timedwait + 0x129\r\nChild-SP         RetAddr          Caller, Callee\r\n00007F56BAFFC670 00007f5e15141766 libcoreclr!CorUnix::CPalSynchronizationManager::ThreadNativeWait + 0x126 [/__w/1/s/src/coreclr/pal/src/synchmgr/synchmanager.cpp:488], calling libcoreclr + 0x76180\r\n00007F56BAFFC6D0 00007f5e15141431 libcoreclr!CorUnix::CPalSynchronizationManager::BlockThread + 0x1d1 [/__w/1/s/src/coreclr/pal/src/synchmgr/synchmanager.cpp:307], calling libcoreclr!CorUnix::CPalSynchronizationManager::ThreadNativeWait [/__w/1/s/src/coreclr/pal/src/synchmgr/synchmanager.cpp:445]\r\n00007F56BAFFC730 00007f5e15145e12 libcoreclr!CorUnix::InternalWaitForMultipleObjectsEx + 0x872 [/__w/1/s/src/coreclr/pal/src/synchmgr/wait.cpp:646]\r\n00007F56BAFFC8D0 00007f5e15145fd4 libcoreclr!PAL_WaitForSingleObjectPrioritized + 0x54 [/__w/1/s/src/coreclr/pal/src/synchmgr/wait.cpp:15732480], calling libcoreclr!CorUnix::InternalWaitForMultipleObjectsEx [/__w/1/s/src/coreclr/pal/src/synchmgr/wait.cpp:361]\r\n00007F56BAFFC900 00007f5e14e18179 libcoreclr!WaitHandleNative::CorWaitOnePrioritizedNative + 0x59 [/__w/1/s/src/coreclr/vm/comwaithandle.cpp:15732480], calling libcoreclr!PAL_WaitForSingleObjectPrioritized [/__w/1/s/src/coreclr/pal/src/synchmgr/wait.cpp:100]\r\n00007F56BAFFC960 00007f5d9b32f457 (MethodDesc 00007f5da056dd98 + 0x67 System.Threading.LowLevelLifoSemaphore.WaitNative(Microsoft.Win32.SafeHandles.SafeWaitHandle, Int32))\r\n00007F56BAFFC9A8 00007f5d9b32f447 (MethodDesc 00007f5da056dd98 + 0x57 System.Threading.LowLevelLifoSemaphore.WaitNative(Microsoft.Win32.SafeHandles.SafeWaitHandle, Int32)), calling libcoreclr!JIT_PInvokeBegin [/__w/1/s/src/coreclr/pal/inc/unixasmmacrosamd64.inc:899]\r\n00007F56BAFFCA20 00007f5da0791e3a (MethodDesc 00007f5da056de50 + 0x3a System.Threading.LowLevelLifoSemaphore.WaitForSignal(Int32)), calling 00007f5d9ff271d0 (stub for System.Threading.LowLevelLifoSemaphore.WaitNative(Microsoft.Win32.SafeHandles.SafeWaitHandle, Int32))\r\n00007F56BAFFCA60 00007f5da078ccd7 (MethodDesc 00007f5da056de20 + 0x257 System.Threading.LowLevelLifoSemaphore.Wait(Int32, Boolean)), calling (MethodDesc 00007f5da056de50 + 0 System.Threading.LowLevelLifoSemaphore.WaitForSignal(Int32))\r\n00007F56BAFFCA98 00007f5da078cc2a (MethodDesc 00007f5da056de20 + 0x1aa System.Threading.LowLevelLifoSemaphore.Wait(Int32, Boolean))\r\n00007F56BAFFCAF0 00007f5da15d8337 (MethodDesc 00007f5da056dc00 + 0x237 System.Threading.PortableThreadPool+WorkerThread.WorkerThreadStart()), calling (MethodDesc 00007f5da056de20 + 0 System.Threading.LowLevelLifoSemaphore.Wait(Int32, Boolean))\r\n00007F56BAFFCB40 00007f5da15d82b5 (MethodDesc 00007f5da056dc00 + 0x1b5 System.Threading.PortableThreadPool+WorkerThread.WorkerThreadStart())\r\n00007F56BAFFCBB0 00007f5e14fb9c67 libcoreclr!CallDescrWorkerInternal + 0x7c [/__w/1/s/src/coreclr/pal/inc/unixasmmacrosamd64.inc:854]\r\n00007F56BAFFCBD0 00007f5e14defaee libcoreclr!DispatchCallSimple + 0xfe [/__w/1/s/src/coreclr/vm/callhelpers.cpp:220], calling libcoreclr!CallDescrWorkerInternal [/__w/1/s/src/coreclr/pal/inc/unixasmmacrosamd64.inc:796]\r\n00007F56BAFFCC60 00007f5e14e08672 libcoreclr!ThreadNative::KickOffThread_Worker + 0x92 [/__w/1/s/src/coreclr/vm/comsynchronizable.cpp:15732480], calling libcoreclr!DispatchCallSimple [/__w/1/s/src/coreclr/vm/callhelpers.cpp:173]\r\n00007F56BAFFCC90 00007f5e14d223c9 libcoreclr!Frame::Push + 0x19 [/__w/1/s/src/coreclr/vm/frames.cpp:383], calling libcoreclr + 0x75180\r\n00007F56BAFFCCB0 00007f5e14db482a libcoreclr!ManagedThreadBase_DispatchOuter + 0x14a [/__w/1/s/src/coreclr/vm/threads.cpp:7549]\r\n00007F56BAFFCDD0 00007f5e14db4e2d libcoreclr!ManagedThreadBase::KickOff + 0x2d [/__w/1/s/src/coreclr/vm/threads.cpp:7604], calling libcoreclr!ManagedThreadBase_DispatchOuter [/__w/1/s/src/coreclr/vm/threads.cpp:7476]\r\n00007F56BAFFCE00 00007f5e14e08747 libcoreclr!ThreadNative::KickOffThread + 0xb7 [/__w/1/s/src/coreclr/vm/comsynchronizable.cpp:230], calling libcoreclr!ManagedThreadBase::KickOff [/__w/1/s/src/coreclr/vm/threads.cpp:7602]\r\n00007F56BAFFCE60 00007f5e1514dabe libcoreclr!CorUnix::CPalThread::ThreadEntry + 0x24e [/__w/1/s/src/coreclr/pal/src/thread/thread.cpp:1865]\r\n00007F56BAFFCFB0 00007f5e1547551d libc_2_23!clone + 0x6d\r\n\n\n### Expected behavior\n\nDoes not freezed\n\n### Actual behavior\n\nfreezed\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eenegriy\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-03-01T12:48:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5YNGBz",
                                           "createdAt":  "2023-03-22T15:52:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "Hello @enegriy, are you able to share a repro or a dump when the deadlock happens? \r\n\r\n",
                                           "updatedAt":  "2023-03-22T15:52:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5daI0p",
                                           "createdAt":  "2023-05-29T13:19:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "michaldobrodenka",
                                           "body":  "I have probably this problem, occuring randomly in net6 \u0026 net7. Some threads freezes randomly. Not very often, but happen sometimes, I have linux WD checking activity of threads in my IoT apps. For some incidents I have core dumps and I can see that my code stopped on random location, not waiting for anything. Just 40s waiting on something like ```return true``` and then WD timeout.\r\n\r\nI don\u0027t remember this happening with net5, maybe I\u0027ll downgrade to net5 temporarily.\r\n\r\n(I use net6 \u0026 7 on linux-arm)\r\n\r\n",
                                           "updatedAt":  "2023-05-29T14:11:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5eG4mL",
                                           "createdAt":  "2023-06-06T14:22:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "michaldobrodenka",
                                           "body":  "@mangod9 if you want I have some core dumps where WaitOne(50), thread waiting alone on lock(), or simple Timer.Change()  is waiting indefinitely. I run and manage thousands IoT devices running .net, they have systemd \u0026 WD, I know when there is WD timeout and I collect core dumps from these scenarions.\r\n",
                                           "updatedAt":  "2023-06-06T14:26:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iP-Nc",
                                           "createdAt":  "2023-07-24T17:56:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "is this only reproing on linux-arm32 for you? ",
                                           "updatedAt":  "2023-07-24T17:56:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iQI4p",
                                           "createdAt":  "2023-07-24T18:29:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "michaldobrodenka",
                                           "body":  "\u003e is this only reproing on linux-arm32 for you?\r\n\r\n\u0027linux-arm32\u0027 is my only platform used in production so I don\u0027t know. I develop in windows-x64 but this occur very rare so I doubt I will see it on windows. In my case it can reproduced several times a year when running 24/7 ",
                                           "updatedAt":  "2023-07-24T18:29:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5o-Nl9",
                                           "createdAt":  "2023-10-13T08:39:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "michaldobrodenka",
                                           "body":  "I have a suspicion that this bug is fixed in net7.0 branch. I\u0027ve never seen it on net7.0 and regularly on net6.0. But my net7.0 test set is much smaller. In about 2 months I will migrate several hundreds of machines and will able to tell more.",
                                           "updatedAt":  "2023-10-13T08:39:47Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "Deadlock libpthread_2_23!pthread_cond_wait",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/83133",
        "createdAt":  "2023-03-08T12:20:26Z",
        "number":  83133,
        "author":  "MrPippin66",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-06-17T11:35:00Z",
        "body":  "Can https://github.com/dotnet/runtime/pull/78106 be ported to the current stable release? Though this is a minor security issue, it\u0027s not one easily managed on host systems, since if /tmp is volatile, this will re-appear after reboots.\r\n\r\nHaving to wait for the 8.0 release and then wait for PowerShell-core to adopt this will take much longer to address this than should be for a security issue.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOsZ9i7w==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5XBvUM",
                                           "createdAt":  "2023-03-08T12:20:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nCan https://github.com/dotnet/runtime/pull/78106 be ported to the current stable release? Though this is a minor security issue, it\u0027s not one easily managed on host systems, since if /tmp is volatile, this will re-appear after reboots.\r\n\r\nHaving to wait for the 8.0 release and then wait for PowerShell-core to adopt this will take much longer to address this than should be for a security issue.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eMrPippin66\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-03-08T12:20:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XCn8C",
                                           "createdAt":  "2023-03-08T15:09:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vcsjones",
                                           "body":  "It looks like this was fixed for 7.0 here https://github.com/dotnet/runtime/pull/78057 and 6.0 here https://github.com/dotnet/runtime/pull/78051 back in November 2022. /cc @janvorli for any additional details.",
                                           "updatedAt":  "2023-03-08T15:09:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XCtlf",
                                           "createdAt":  "2023-03-08T15:24:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MrPippin66",
                                           "body":  "Cool! Thanks for the information",
                                           "updatedAt":  "2023-03-08T15:24:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XQX_e",
                                           "createdAt":  "2023-03-10T14:47:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MrPippin66",
                                           "body":  "@janvorli\r\n\r\nCan you verify if this was included in the 7.0.3 release?\r\n",
                                           "updatedAt":  "2023-03-10T14:47:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XQjgm",
                                           "createdAt":  "2023-03-10T15:20:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "@MrPippin66 I already did before the release. But I\u0027ve double-checked now. I\u0027ve deleted the /tmp/.dotnet/shm and then ran\r\n```sh\r\ndotnet new console\r\ndotnet run\r\n```\r\nAfter that:\r\n```sh\r\nls -la /tmp/.dotnet/shm/\r\ntotal 12\r\ndrwxrwxrwt 3 janvorli janvorli 4096 bře 10 07:18 .\r\ndrwxrwxrwt 3 janvorli janvorli 4096 bře 10 07:18 ..\r\ndrwx------ 2 janvorli janvorli 4096 bře 10 07:18 session1131269\r\n```\r\nas you can see, the session1131269 has access for my account only.\r\n",
                                           "updatedAt":  "2023-03-10T15:20:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XQ2RD",
                                           "createdAt":  "2023-03-10T16:09:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MrPippin66",
                                           "body":  "@janvorli \r\n\r\nWhat is the permissions on /tmp/.dotnet? Primary issue on my side to validating stickybit was set on that directory. and that is for 7.0.3, correct?",
                                           "updatedAt":  "2023-03-10T16:13:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XRKQj",
                                           "createdAt":  "2023-03-10T17:13:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "The .dotnet doesn\u0027t have the sticky bit set with the change. When I did the ls above, I\u0027ve removed just the shm. Removing /tmp/.dotnet and re-running \"dotnet clean\" \"dotnet build\" creates .dotnet without the sticky bit. The only subdirectory created in this directory is the shm and that can be created by any user. So the sticky bit wouldn\u0027t make sense here.\r\nThis is for 7.0.3, right.",
                                           "updatedAt":  "2023-03-10T17:13:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XRMvc",
                                           "createdAt":  "2023-03-10T17:22:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MrPippin66",
                                           "body":  "Okay, but the text of the original change included the comment \u0027sticky bit is set for the /tmp/.dotnet,\u0027.\r\n\r\nWas that in error, since the primary concern is any directory in /tmp with world write with the sticky bit set from a security standpoint.",
                                           "updatedAt":  "2023-03-10T17:22:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XRPU6",
                                           "createdAt":  "2023-03-10T17:32:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "It was a mistake. I have originally had it set that way, but then I\u0027ve removed the sticky bit on the .dotnet due to the reason mentioned above, but obviously forgotten to modify the comment.\r\nHere is an overview of what the change did to the permissions / sticky bits. The changes are highlighted using bold:\r\nBefore: \r\n/tmp RWX for all users, sticky bit set \r\n/tmp/.dotnet - RWX for all users \r\n/tmp/.dotnet/shm - RWX for all users \r\n/tmp/.dotnet/shm/global - RWX for all users \r\n/tmp/.dotnet/shm/sessionXXXX - RWX for all users \r\n/tmp/.dotnet/shm/global/somemutexfile- RW for all users \r\n/tmp/.dotnet/shm/sessionXXXX/somemutexfile - RW for all users \r\n\r\nAfter: \r\n/tmp - RWX for all users, sticky bit set \r\n/tmp/.dotnet - RWX for all users \r\n/tmp/.dotnet/shm - RWX for all users, **sticky bit set** \r\n/tmp/.dotnet/shm/global - RWX for all users \r\n/tmp/.dotnet/shm/sessionXXXX - **RWX for current user only** \r\n/tmp/.dotnet/shm/global/somemutexfile- RW for all users \r\n/tmp/.dotnet/shm/sessionXXXX/somemutexfile - RW **for current user only** ",
                                           "updatedAt":  "2023-03-10T17:32:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XRYfh",
                                           "createdAt":  "2023-03-10T17:59:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MrPippin66",
                                           "body":  "I appreciate the clarification. Is there a reason to not have the sticky bit set on /tmp/.dotnet?\r\n\r\nAgain, from a Unix/Linux security standpoint, that\u0027s a security issue on world-writable directories.",
                                           "updatedAt":  "2023-03-10T17:59:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XRZgz",
                                           "createdAt":  "2023-03-10T18:02:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "I\u0027ve just mentioned the reason in my comment above. The only subdirectory created in this directory is the shm and that can be created by any user. So the sticky bit wouldn\u0027t make sense here. There is no reason to prevent other users from deleting the shm directory.\r\n",
                                           "updatedAt":  "2023-03-10T18:02:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XRiFj",
                                           "createdAt":  "2023-03-10T18:28:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MrPippin66",
                                           "body":  "Other than this is still a bad security practice and countless tools flag this as a security issue.\r\n\r\nWorld writable directories without the sticky-bit set in Unix should always be avoided.",
                                           "updatedAt":  "2023-03-10T18:28:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XRlfa",
                                           "createdAt":  "2023-03-10T18:36:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "I understand the concern in general, but is seem to me that in this case we don\u0027t have other way. How would you avoid world writable directory where you actually need a directory where everyone can write by design? The machine wide Mutex that uses that is an example. Every user on the machine can run dotnet applications and such application can create / use these global mutexes. ",
                                           "updatedAt":  "2023-03-10T18:36:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XRnQ1",
                                           "createdAt":  "2023-03-10T18:42:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MrPippin66",
                                           "body":  "The issue isn\u0027t expressly about anyone being able to write into a directory. That\u0027s the nature of /tmp and /var/tmp, for that matter. The issue is that having them be world-writable alone allows anyone to remove files in that directory, even if they don\u0027t own the file. That includes renaming file they don\u0027t own as well.\r\n\r\nThat\u0027s why the sticky bit should be added, so that only the owner of a file in a world-writable directory can remove/rename it.\r\n\r\nWhat I\u0027m gathering is a problem with how the \u0027shm\u0027 directory within /tmp/.dotnet is managed.",
                                           "updatedAt":  "2023-03-10T18:42:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XRwAa",
                                           "createdAt":  "2023-03-10T19:10:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "I understand the reasons for avoiding world writable directories and using sticky bits. But I see that as something to avoid doing by accident, since in 99% of cases, you don\u0027t really want world writeable directories without the sticky bits. If you do it by design for a reason, then it seems ok. \r\nIn our case, can you describe a reason for adding the sticky bit to the `.dotnet` directory and thus prevent other users from deleting the `shm` folder? The folder doesn\u0027t logically belong to any user. Imagine a machine with 100 users actively using it. A random user from that groups will be the first one to use .NET and thus the `shm` folder would be created by that user. Since that\u0027s a random user, why should the user own the \"delete rights\" to `shm`?\r\n",
                                           "updatedAt":  "2023-03-10T19:10:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XR2FH",
                                           "createdAt":  "2023-03-10T19:24:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MrPippin66",
                                           "body":  "Because a malicious user (or other un-informed task) can cause a denial of service by removing that directory or renaming it. Y, it can\u0027t be deleted with items within it, and having the sticky bit on SHM prevents anyone but the user from deleting files in \u0027shm\u0027, but any user can rename that folder.\r\n\r\nNow...from what I can tell, once /tmp/.dotnet/shm is created, as long as the permissions on shm are world-writable w/sticky-bit, it doesn\u0027t matter about the permissions for /tmp/.dotnet in regards to the sticky-bit. Upon a session going away, /.dotnet/shm isn\u0027t removed.\r\n\r\nThe issue becomes if there\u0027s a reason a non-priviliged user would need to remove /tmp/.dotnet/shm once it\u0027s created.",
                                           "updatedAt":  "2023-03-10T19:24:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5YAfkb",
                                           "createdAt":  "2023-03-20T16:08:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MrPippin66",
                                           "body":  "Is this still being investigated?",
                                           "updatedAt":  "2023-03-20T16:08:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6xntrI",
                                           "createdAt":  "2025-06-17T11:23:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mitch-lansweeper",
                                           "body":  "[#78106](https://github.com/dotnet/runtime/pull/) has been reverted as part of this change https://github.com/dotnet/runtime/commit/1c4e4c11e4ad514a6a1198ce494873365af4eace. Are there any plans to bring the sticky bit back for /tmp/.dotnet/shm? \n\nSecurity scanners are tripping over Serilog creating a Mutex file that is world writable and missing a sticky bit.",
                                           "updatedAt":  "2025-06-17T11:23:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6xn2Lv",
                                           "createdAt":  "2025-06-17T11:35:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEXCJUQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MathiasEriksen7",
                                                                               "createdAt":  "2025-06-18T09:58:02Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "MrPippin66",
                                           "body":  "Yes, disappointing. This is a very longstanding security issue",
                                           "updatedAt":  "2025-06-17T11:35:00Z"
                                       }
                                   ],
                         "totalCount":  19
                     },
        "title":  "Port \u0027Restrict named mutex files permissions\u0027 pull to current stable release",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/83406",
        "createdAt":  "2023-03-14T17:19:16Z",
        "number":  83406,
        "author":  "stephentoub",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-08-09T19:01:22Z",
        "body":  "With 20/20 hindsight, TaskCanceledException was a mistake.  It derives from OperationCanceledException, and the intent was that it\u0027s just an OperationCanceledException that carries a little more information folks might want to see, namely the Task that was canceled and triggered the exception.  However, it\u0027s very common for the boundary between an OCE and a TCE to be very fluid, where the same operation might result in one or the other depending on when cancellation occurred (e.g. an up-front cancellationToken.IsCancellationRequested check vs an await on a Task manually completed with SetCanceled on its completion source), and that fluidity not only results in race conditions where sometimes you get one exception and sometimes you get the other, changes to the code over time often result in happening to throw one vs the other.\r\n\r\nThe net result of this is that code trying to catch and handle cancellation exception should always do so for OperationCanceledException.  If code does want to do something special for TaskCanceledException, it can do so in addition but shouldn\u0027t do instead of.\r\n\r\nWe should add an analyzer that flags `catch (TaskCanceledException)` if there\u0027s no corresponding `catch (OperationCanceledException)` that would back stop it.\r\n\r\n```C#\r\n// Ok\r\ntry { ... }\r\ncatch (OperationCanceledException) { ... }\r\n\r\n// Ok\r\ntry { ... }\r\ncatch (OperationCanceledException oce)\r\n{\r\n    if (oce is TaskCanceledException tce) { .. }\r\n}\r\n\r\n// Ok\r\ntry { ... }\r\ncatch (TaskCanceledException) { ... }\r\ncatch (OperationCanceledException) { ... }\r\n\r\n// Diagnostic\r\ntry { ... }\r\ncatch (TaskCanceledException) { ... }\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOV4e_hA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5Xh7-E",
                                           "createdAt":  "2023-03-14T17:19:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nWith 20/20 hindsight, TaskCanceledException was a mistake.  It derives from OperationCanceledException, and the intent was that it\u0027s just an OperationCanceledException that carries a little more information folks might want to see, namely the Task that was canceled and triggered the exception.  However, it\u0027s very common for the boundary between an OCE and a TCE to be very fluid, where the same operation might result in one or the other depending on when cancellation occurred (e.g. an up-front cancellationToken.IsCancellationRequested check vs an await on a Task manually completed with SetCanceled on its completion source), and that fluidity not only results in race conditions where sometimes you get one exception and sometimes you get the other, changes to the code over time often result in happening to throw one vs the other.\r\n\r\nThe net result of this is that code trying to catch and handle cancellation exception should always do so for OperationCanceledException.  If code does want to do something special for TaskCanceledException, it can do so in addition but shouldn\u0027t do instead of.\r\n\r\nWe should add an analyzer that flags `catch (TaskCanceledException)` if there\u0027s no corresponding `catch (OperationCanceledException)` that would back stop it.\r\n\r\n```C#\r\n// Ok\r\ntry { ... }\r\ncatch (OperationCanceledException) { ... }\r\n\r\n// Ok\r\ntry { ... }\r\ncatch (OperationCanceledException oce)\r\n{\r\n    if (oce is TaskCanceledException tce) { .. }\r\n}\r\n\r\n// Ok\r\ntry { ... }\r\ncatch (TaskCanceledException) { ... }\r\ncatch (OperationCanceledException) { ... }\r\n\r\n// Diagnostic\r\ntry { ... }\r\ncatch (TaskCanceledException) { ... }\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003estephentoub\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `code-analyzer`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-03-14T17:19:29Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "[Analyzer] Flag catch blocks for TaskCanceledException without OperationCanceledException",
        "labels":  [
                       "area-System.Threading",
                       "code-analyzer"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/83890",
        "createdAt":  "2023-03-24T16:30:52Z",
        "number":  83890,
        "author":  "ezsilmar",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-09-22T19:48:33Z",
        "body":  "### Description\n\nThere\u0027s a sharding mechanism in TimerQueue that selects the queue based on the current CPU id\r\n```csharp\r\n_associatedTimerQueue = TimerQueue.Instances[Thread.GetCurrentProcessorId() % TimerQueue.Instances.Length];\r\n```\r\nThis doesn\u0027t work as expected when the application is bound to specific cores. \r\n\r\nFor instance, with 32-core server you may have 4 numa nodes each containing 8 logical cores, where every pair of logical cores is backed by a single physical core. In this case, the cpuset of first numa node may look like this: `[0, 1, 2, 3, 16, 17, 18, 19]` as Linux enumerates first the physical cores, then their HT counterpart.\r\n\r\nThis leads to underutilization of the timer queues as we\u0027d only use the first 4 due to modulo.\n\n### Reproduction Steps\n\n```csharp\r\nfor (var i = 0; i \u003c 100; i++) \r\n{\r\n   Task.Run(() =\u003e Task.Delay(10*60*1000 + i));\r\n}\r\nConsole.ReadKey();\r\n```\r\n\r\nRun it with \r\n```\r\ntaskset -c 0,1,4,5 dotnet ./TimerRepro.dll\r\n```\r\n\r\nThen take a memory dump of the process and find the timer queues:\r\n```\r\ndotnet-dump ps\r\ndotnet-dump collect -p \u003cpid\u003e\r\ndotnet-dump analyze \u003cdumpfile\u003e\r\n\r\ndumpheap -stat\r\ndo -mt \u003ctimerqueue_mt\u003e\r\ndo \u003ctimerqueue\u003e\r\ndumparray -details \u003ctimerqueue_instances\u003e\r\n```\r\n\r\nYou\u0027ll observe that queues 0 and 1 are utilized while queues 2 and 3 are empty. Sample output (only interesting part):\r\n```\r\n                      MT    Field   Offset                 Type         VT     Attr                    Value     Name\r\n        00007f40f009b3b8  4000b2b       30             System.Int64      1     instance                   86     \u003cActiveCount\u003ek__BackingField\r\n        00007f40f009b3b8  4000b2b       30             System.Int64      1     instance                   14     \u003cActiveCount\u003ek__BackingField\r\n        00007f40f009b3b8  4000b2b       30             System.Int64      1     instance                    0     \u003cActiveCount\u003ek__BackingField\r\n        00007f40f009b3b8  4000b2b       30             System.Int64      1     instance                    0     \u003cActiveCount\u003ek__BackingField\r\n```\n\n### Expected behavior\n\nAll timer queues are utilized \n\n### Actual behavior\n\nDepending on CPU ids only some queues are utilized\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nSome options that comes to mind:\r\n* Introduce more complex logic similar to what GC does with affinity ranges: querying the number of CPUs on the machine, then querying the affinity mask, filtering CPUs to available ones and building a dictionary cpuid =\u003e TimerQueue\r\n* Always create timerqueues equal to the number of total cores on the machine, even if we won\u0027t use all of them\r\n* Not use the CPU id but a thread id or any other sharding key\r\n\n\n### Configuration\n\nObserved on dotnet 6.0.12 WSL2 Ubuntu and dotnet 5.0.x CentOS 7 but the code is the same in newer versions.\n\n### Other information\n\nAre there other places in the runtime where the same sharding is utilized?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOZzubMA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5YZuKR",
                                           "createdAt":  "2023-03-24T17:08:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nThere\u0027s a sharding mechanism in TimerQueue that selects the queue based on the current CPU id\r\n```csharp\r\n_associatedTimerQueue = TimerQueue.Instances[Thread.GetCurrentProcessorId() % TimerQueue.Instances.Length];\r\n```\r\nThis doesn\u0027t work as expected when the application is bound to specific cores. \r\n\r\nFor instance, with 32-core server you may have 4 numa nodes each containing 8 logical cores, where every pair of logical cores is backed by a single physical core. In this case, the cpuset of first numa node may look like this: `[0, 1, 2, 3, 16, 17, 18, 19]` as Linux enumerates first the physical cores, then their HT counterpart.\r\n\r\nThis leads to underutilization of the timer queues as we\u0027d only use the first 4 due to modulo.\n\n### Reproduction Steps\n\n```csharp\r\nfor (var i = 0; i \u003c 100; i++) \r\n{\r\n   Task.Run(() =\u003e Task.Delay(10*60*1000 + i));\r\n}\r\nConsole.ReadKey();\r\n```\r\n\r\nRun it with \r\n```\r\ntaskset -c 0,1,4,5 dotnet ./TimerRepro.dll\r\n```\r\n\r\nThen take a memory dump of the process and find the timer queues:\r\n```\r\ndotnet-dump ps\r\ndotnet-dump collect -p \u003cpid\u003e\r\ndotnet-dump analyze \u003cdumpfile\u003e\r\n\r\ndumpheap -stat\r\ndo -mt \u003ctimerqueue_mt\u003e\r\ndo \u003ctimerqueue\u003e\r\ndumparray -details \u003ctimerqueue_instances\u003e\r\n```\r\n\r\nYou\u0027ll observe that queues 0 and 1 are utilized while queues 2 and 3 are empty. Sample output (only interesting part):\r\n```\r\n                      MT    Field   Offset                 Type         VT     Attr                    Value     Name\r\n        00007f40f009b3b8  4000b2b       30             System.Int64      1     instance                   86     \u003cActiveCount\u003ek__BackingField\r\n        00007f40f009b3b8  4000b2b       30             System.Int64      1     instance                   14     \u003cActiveCount\u003ek__BackingField\r\n        00007f40f009b3b8  4000b2b       30             System.Int64      1     instance                    0     \u003cActiveCount\u003ek__BackingField\r\n        00007f40f009b3b8  4000b2b       30             System.Int64      1     instance                    0     \u003cActiveCount\u003ek__BackingField\r\n```\n\n### Expected behavior\n\nAll timer queues are utilized \n\n### Actual behavior\n\nDepending on CPU ids only some queues are utilized\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nSome options that comes to mind:\r\n* Introduce more complex logic similar to what GC does with affinity ranges: querying the number of CPUs on the machine, then querying the affinity mask, filtering CPUs to available ones and building a dictionary cpuid =\u003e TimerQueue\r\n* Always create timerqueues equal to the number of total cores on the machine, even if we won\u0027t use all of them\r\n* Not use the CPU id but a thread id or any other sharding key\r\n\n\n### Configuration\n\nObserved on dotnet 6.0.12 WSL2 Ubuntu and dotnet 5.0.x CentOS 7 but the code is the same in newer versions.\n\n### Other information\n\nAre there other places in the runtime where the same sharding is utilized?\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eezsilmar\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`, `needs-area-label`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-03-24T17:08:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZlawP",
                                           "createdAt":  "2023-04-11T09:23:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "verdie-g",
                                           "body":  "Hi @stephentoub, I think you might be interested by this. It has become an important issue in some of our services that are using many Task.Delay as a timeout mechanism.\r\n\r\nHaving as many TimerQueue as cores on the machine looks like a simple fix, however I\u0027m not sure if there is already a way to get the total number of cores on the machine from managed code. I\u0027ve seen it\u0027s already used in native code, in the gc for example. Any idea?",
                                           "updatedAt":  "2023-04-11T09:23:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZlfUN",
                                           "createdAt":  "2023-04-11T09:37:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e It has become an important issue in some of our services that are using many Task.Delay as a timeout mechanism.\r\n\r\nAre you sure it\u0027s related to this issue? \r\n\r\nFor example, are you canceling your Task.Delays when the thing you\u0027re using it to timeout completes? What does your code for creating those tasks look like?",
                                           "updatedAt":  "2023-04-11T09:37:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Zlhcy",
                                           "createdAt":  "2023-04-11T09:44:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "verdie-g",
                                           "body":  "I was wondering the same because when looking at the contention events in perfview I can only see FireQueue something. So I\u0027ve compared an instance with the Task.Delay removed and I could see a 40% contention decrease.\r\n![image](https://user-images.githubusercontent.com/9092290/231121774-97b15f73-ed95-4bfa-9471-a7dd8f6d52d5.png)\r\nAll these metrics are collected from [event counters](https://learn.microsoft.com/en-us/dotnet/core/diagnostics/available-counters).",
                                           "updatedAt":  "2023-04-11T09:44:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZljPF",
                                           "createdAt":  "2023-04-11T09:50:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "verdie-g",
                                           "body":  "By the way, this logic found in Timer\r\nhttps://github.com/dotnet/runtime/blob/17ed09116b8750f73d4b96f67fa875659edc98b4/src/libraries/System.Private.CoreLib/src/System/Threading/Timer.cs#L511\r\ncan also be found here\r\nhttps://github.com/dotnet/runtime/blob/17ed09116b8750f73d4b96f67fa875659edc98b4/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/PoolingAsyncValueTaskMethodBuilderT.cs#L359\r\nhttps://github.com/dotnet/runtime/blob/17ed09116b8750f73d4b96f67fa875659edc98b4/src/libraries/System.Private.CoreLib/src/System/Buffers/TlsOverPerCoreLockedStacksArrayPool.cs#L324",
                                           "updatedAt":  "2023-04-11T09:50:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZlkFM",
                                           "createdAt":  "2023-04-11T09:53:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e I can only see FireQueue something\r\n\r\nThat\u0027s my point. Timers used for timeouts should rarely be firing. This sounds like more likely to be a bug in your code failing to cancel those tasks. ",
                                           "updatedAt":  "2023-04-11T09:53:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Zlp61",
                                           "createdAt":  "2023-04-11T10:09:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ezsilmar",
                                           "body":  "But even if we cancel the timer, it would still take a lock on this path creating contention? \r\n\r\nTo give a bit more context, in one other application where we have latency constraints (i.e. it\u0027s better to answer something in 200ms than waiting for the dependency to answer our http request) many timers are created and destroyed frequently. We observe high spikes in thread pool queue (and latency) every couple of minutes, which we connect with two other observations: 95% of all contention events are in `TimerQueue`, and the high number of exceptions (as ~12% of all requests end up cancelled). \r\n\r\nThe affinity issue is one of the mitigations we think of, but we also want to change how we use timeouts in HttpClient to trigger `OperationCancelledException` and `NetworkException` less frequently. Something like this:\r\n```csharp\r\nusing (var cts = new CancellationTokenSource())\r\n{\r\n  cts.CancelAfter(TimeSpan.FromSeconds(5)); // set large timeout here\r\n  \r\n  var realTimeoutTask = Task.Delay(200); // the timeout we actually use\r\n  var responseTask = httpClient.SendAsync(request, cts.Token);\r\n   \r\n  await Task.WhenAny(realTimeoutTask, responseTask);\r\n\r\n  if (!responseTask.IsCompleted)\r\n  {\r\n    responseTask.ContinueWith(x =\u003e { ... }); // read the body to be able to reuse http connection\r\n    return GetTimeoutResult();\r\n  }\r\n}\r\n```\r\n\r\nHowever this solution creates even more timers so we want to fix contention issue in any case.",
                                           "updatedAt":  "2023-04-11T10:09:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Zls-9",
                                           "createdAt":  "2023-04-11T10:17:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e We observe high spikes in thread pool queue (and latency) every couple of minutes\r\n\r\nCanceled timers would not be queuing any work items.\r\n\r\n\u003e var realTimeoutTask = Task.Delay(200);\r\n\r\nThis is how Task.Delay should _not_ be used for timeouts.\r\n\r\nI\u0027d urge you to fix how you\u0027re implementing timeouts before assuming this issue is related. You should also look into using Task.WaitAsync is your goal is to timeout a wait on a Task, as it appears to be.\r\n\r\nWhat OS are you running on? What .NET version? And what evidence do you have that affinity is causing you to use fewer timer queues? \r\n\r\n",
                                           "updatedAt":  "2023-04-11T10:18:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Zlucx",
                                           "createdAt":  "2023-04-11T10:20:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "(I just realized the most recent response was from @ezsilmar... I thought I was responding to @verdie-g. Comments about timeouts still apply, though.)",
                                           "updatedAt":  "2023-04-11T10:20:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Zlwvb",
                                           "createdAt":  "2023-04-11T10:25:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e But even if we cancel the timer, it would still take a lock on this path creating contention\r\n\r\nThe lock is held for much longer when firing than when creating/destroying, and how long it\u0027s held is impacted by how many active timers there are. ",
                                           "updatedAt":  "2023-04-11T10:25:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZlzNb",
                                           "createdAt":  "2023-04-11T10:32:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "Regardless, the modulo scheme will fail to lead to one queue per core, right?",
                                           "updatedAt":  "2023-04-11T10:32:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Zl0Ql",
                                           "createdAt":  "2023-04-11T10:35:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Regardless, the modulo scheme will fail to lead to one queue per core, right?\r\n\r\nIf you affinitize your process to a subset of cores, you might get partitioned into fewer queues than possibly desired.",
                                           "updatedAt":  "2023-04-11T10:35:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Zl386",
                                           "createdAt":  "2023-04-11T10:49:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ezsilmar",
                                           "body":  "Ok sorry for causing confusion, I think we are mixing up different issues here, let me try to explain it.\r\n\r\nFirst, there\u0027s the original issue about affinity and underutilization of timer queues. I\u0027m sure the issue of underutilization is present because there are reliable reproduction steps that we tested on multiple setups (though only Linux). However, the exact performance impact of this issue is unknown: I\u0027m not sure how to measure it correctly, we probably need a machine without hyperthreading to be fair. What concerns me is that CPU id sharding is widely used as @verdie-g pointed out but the affinity case was not taken into account and should theoretically result in worse performance. Also as I point out in the workarounds, I don\u0027t see an easy fix that\u0027s why I think it\u0027s important to discuss :)\r\n\r\nSecondly, there is what led us to the discovery of this underutilization: the issues with some of our apps (we are working at the same company with @verdie-g). I think this is separate issue as our code could be better, and I personally think that in the case I described the exceptions are worse offenders than timer queues. We obviously appreciate any feedback on this but it was not my goal to consume your time with consulting, I just wanted to explain how we ended up here.\r\n\r\n\u003e What OS are you running on? What .NET version?\r\n\r\nWe are using Centos 7 and Centos 8 and we are using runtimes 5.0.9 and 6.0.13.\r\n\r\n\u003e Canceled timers would not be queuing any work items.\r\n\r\nI think we see the thread pool spikes not because we emit more work items but because we get unlucky and have a lock convoy that blocks the thread pool threads. For 8 core container we have 8-9 thread pool threads that looks quite reasonable to me but it also means that any small convoy could lead to a spike, especially as we shard by CPU id and not thread (so more threads won\u0027t make things better).\r\n\r\n\r\nAlso on a side note we use numa and HT aware affinity to isolate the containers as we found it to be much more predictable \r\nthan using other means like time quotas.",
                                           "updatedAt":  "2023-04-11T10:49:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZmGIJ",
                                           "createdAt":  "2023-04-11T11:29:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC5my3g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "verdie-g",
                                                                               "createdAt":  "2023-04-11T12:40:49Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Thanks. I\u0027m not arguing against the original issue existing; affinitizing can impact whether the full range is utilized.\r\n\r\nWhat I\u0027m suggesting is that it\u0027s unlikely to be the actual root cause of your issues. It\u0027s true that timers firing and timers being created/destroyed both need to take the lock. However, that doesn\u0027t mean they equally contribute to cost and contention. When a timer is created/destroyed, it takes the lock, manipulates just a few references, and releases the lock. In contrast, when a timer fires and takes the lock, worst case while holding the lock it can end up traversing a linked list of _all_ timers in that queue. That means worst case it can be O((N / P) ^ 2), where N is the number of active timers and P is the number of queues they\u0027re evenly distributed across, because every one of the N timers firing could iterate through N scheduled timers. There are some mitigations in place to avoid that worst case, but if you have lots of relatively short timers unnecessarily remaining active, you\u0027re actively working to defeat those mitigations. Would increasing P help? A little, but with lots of timers firing, and lots of timers created with relatively short durations (eg 200ms as in your example), its impact will be outweighed significantly by N.\r\n\r\nPlease fix your code to clean up timers that are no longer needed. Then if you still have a problem, we can figure out what\u0027s going on. Cleaning up timers includes canceling any Task.Delays you\u0027ve created for timeouts, and ideally not using Task.Delay for that at all and instead using Task.WaitAsync.",
                                           "updatedAt":  "2023-04-11T11:33:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZnvSg",
                                           "createdAt":  "2023-04-11T15:17:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "\u003e If you affinitize your process to a subset of cores, you might get partitioned into fewer queues than possibly desired.\n\nShould we have a separate issue to discuss fixing that? It seems to me that as far as possible if I affinitize to N cores (in any combination) I expect my app to behave as is the machine has N cores. (Notwithstanding any observable performance dynamics due to eg whether the cores are co located)",
                                           "updatedAt":  "2023-04-11T15:17:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZnwsQ",
                                           "createdAt":  "2023-04-11T15:19:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Should we have a separate issue to discuss fixing that?\r\n\r\nThat\u0027s what this issue is.  I\u0027m not understanding.",
                                           "updatedAt":  "2023-04-11T15:19:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZoFeJ",
                                           "createdAt":  "2023-04-11T16:03:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ezsilmar",
                                           "body":  "Agree with @stephentoub there\u0027s no need to create a separate issue. We should discuss the ways to fix cpu id sharding here, other things are unrelated to the discussion (only provided as an example why we could be interested in fixing it).",
                                           "updatedAt":  "2023-04-11T16:03:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZoQCr",
                                           "createdAt":  "2023-04-11T16:27:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ezsilmar",
                                           "body":  "Speaking of which, I think that the idea to shard by cpu id is a good thing. The problem is it\u0027s not easy to add affinity into the current solution (`cpu_id % cpu_count`). Also I agree with @danmoseley the app should use `cpu_count` queues even in (maybe edge) case of cpu groups.\r\n\r\nOne way to keep the sharding logic simple is to create the queues by the number of real processors (as seen by the OS). The benefit is we\u0027d always shard correctly (even if the affinity changes mid-process). The drawback is we\u0027d probably waste memory on this, even though most of the things are initialized lazily. I wonder if there\u0027s a platform independent way to query the total number of cores in the runtime?\r\n\r\nAlso do you think setting up a benchmark to test perf impact of this issue would be helpful ?",
                                           "updatedAt":  "2023-04-11T16:27:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5nO5sw",
                                           "createdAt":  "2023-09-22T19:48:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "verdie-g",
                                           "body":  "Let\u0027s take a multi-threaded counter for the benchmark for the sake of simplicity.\r\n\r\n```cs\r\n// From https://gist.github.com/EgorBo/427f8332b027f4023c0d125b6d5ace5a\r\nclass ThreadCounter64\r\n{\r\n    private readonly PaddedLong[] _values = new PaddedLong[Environment.ProcessorCount];\r\n\r\n    public void Increment() =\u003e\r\n        Interlocked.Increment(ref _values[Thread.GetCurrentProcessorId() % Environment.ProcessorCount].Value);\r\n    \r\n    /// \u003csummary\u003eTo avoid false sharing.\u003c/summary\u003e\r\n    [StructLayout(LayoutKind.Explicit, Size = 64)]\r\n    private struct PaddedLong\r\n    {\r\n        [FieldOffset(0)]\r\n        public long Value;\r\n    }\r\n}\r\n\r\npublic class Benchmark\r\n{\r\n    private const int Iterations = 10_000_000;\r\n    \r\n    [Benchmark(OperationsPerInvoke = Iterations)]\r\n    public void ThreadCounter64Increment()\r\n    {\r\n        ThreadCounter64 counter = new();\r\n        \r\n        Barrier b = new(Environment.ProcessorCount);\r\n        Parallel.For(0, b.ParticipantCount, _ =\u003e\r\n        {\r\n            b.SignalAndWait();\r\n\r\n            for (int i = 0; i \u003c Iterations; i += 1)\r\n            {\r\n                counter.Increment();\r\n            }\r\n        });\r\n    }\r\n}\r\n```\r\n\r\nThis is the architecture of my CPU\r\n![Screenshot from 2023-09-22 13-59-02](https://github.com/dotnet/runtime/assets/9092290/87be82a6-07dd-4152-8452-c69a5d394772)\r\n\r\n```\r\nBenchmarkDotNet v0.13.8, Pop!_OS 22.04 LTS\r\nAMD Ryzen 7 5800X, 1 CPU, 16 logical and 8 physical cores\r\n\r\n\r\n.NET SDK 7.0.401\r\n  [Host]     : .NET 7.0.11 (7.0.1123.42427), X64 RyuJIT AVX2\r\n  DefaultJob : .NET 7.0.11 (7.0.1123.42427), X64 RyuJIT AVX2\r\n```\r\n\r\n| Method                 | Mean     | Error    | StdDev   |\r\n|----------------------- |---------:|---------:|---------:|\r\n| taskset -c 0-7 | 13.66 ns | 0.255 ns | 0.251 ns |\r\n\r\n\r\n| Method                 | Mean     | Error    | StdDev   |\r\n|----------------------- |---------:|---------:|---------:|\r\n| taskset -c 0-3,8-11 | 38.26 ns | 0.764 ns | 1.277 ns |\r\n\r\nWhen running with `taskset -c 0-7`, each processor maps to a single element of the array in `ThreadCounter64` and we can see it\u0027s 2.8x faster than with `task -c 0-3,8-11`. However this benchmark might be biased because with `0-7`, 8 physical cores are used and only 4 are used with `0-3,8-11`.\r\n\r\nTo cope with that let\u0027s always use `taskset -c 0-7` but change the modulo\r\n```diff\r\n+    private readonly int _modulo = int.Parse(Environment.GetEnvironmentVariable(\"MODULO\")!);\r\n+\r\n    public void Increment() =\u003e\r\n-        Interlocked.Increment(ref _values[Thread.GetCurrentProcessorId() % Environment.ProcessorCount].Value);\r\n+        Interlocked.Increment(ref _values[Thread.GetCurrentProcessorId() % _modulo].Value);\r\n```\r\n\r\n| Method                   | Mean     | Error    | StdDev   | Median   |\r\n|------------------------- |---------:|---------:|---------:|---------:|\r\n| MODULO=8 taskset -c 0-7 | 17.64 ns | 0.489 ns | 1.441 ns | 18.17 ns |\r\n\r\n| Method                   | Mean     | Error    | StdDev   | Median   |\r\n|------------------------- |---------:|---------:|---------:|---------:|\r\n| MODULO=4 taskset -c 0-7 | 84.67 ns | 3.064 ns | 9.033 ns | 88.45 ns |\r\n\r\nNow it\u0027s 4.8x faster when each processor maps to a single element of the array.\r\n\r\nAlso with this method we can use all the cores of my processor\r\n\r\n| Method                   | Mean     | Error    | StdDev   |\r\n|------------------------- |---------:|---------:|---------:|\r\n| MODULO=16 taskset -c 0-15 | 21.56 ns | 0.420 ns | 0.449 ns |\r\n\r\n| Method                   | Mean     | Error    | StdDev   |\r\n|------------------------- |---------:|---------:|---------:|\r\n| MODULO=8 taskset -c 0-15 | 43.21 ns | 0.860 ns | 2.204 ns |\r\n\r\nSurprisingly it\u0027s now only 2x faster.\r\n\r\nAs @ezsilmar mentioned, a fix would be to introduce a\r\n```diff\r\npublic static partial class Environment\r\n{\r\n+     /// \u003csummary\u003e\r\n+     /// Returns the real number of logical cores on the machine, not on the one\r\n+     /// seen by the process like \u003csee cref=\"ProcessCount\" /\u003e.\r\n+     /// \u003c/summary\u003e\r\n+     public static int PhysicalMachineProcessorCount { get; }\r\n}\r\n```\r\nand then replace the `Environment.ProcessCount` with `Environment.PhysicalMachineProcessorCount` in the counter class. The trick here will be to find a name that wouldn\u0027t be fixed with the exisiting `ProcessCount`.",
                                           "updatedAt":  "2023-09-22T19:48:32Z"
                                       }
                                   ],
                         "totalCount":  19
                     },
        "title":  "Underutilization of TimerQueue when application runs with CPU affinity",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/84006",
        "createdAt":  "2023-03-28T01:45:07Z",
        "number":  84006,
        "author":  "v-wenyuxu",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-11T22:05:54Z",
        "body":  "Run: [runtime-coreclr gcstress-extra 20230326.1](https://dev.azure.com/dnceng-public/public/_build/results?buildId=217853\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=4073620\u0026resultId=347720\u0026paneView=debug)\r\n\r\nFailed test:\r\n```\r\ncoreclr windows arm64 Checked gcstress0xc_jitstress1 @ Windows.11.Arm64.Open\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n\r\ncoreclr windows x64 Checked gcstress0xc_zapdisable @ Windows.10.Amd64.Open\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n\r\ncoreclr windows x64 Checked gcstress0xc_jitstress1 @ Windows.10.Amd64.Open\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n\r\ncoreclr windows x86 Checked gcstress0xc_tailcallstress @ Windows.10.Amd64.Open\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n\r\ncoreclr windows arm64 Checked gcstress0xc_jitstress2 @ Windows.11.Arm64.Open\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n\r\ncoreclr windows x86 Checked gcstress0xc_jitstress1 @ Windows.10.Amd64.Open\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n\r\ncoreclr windows x86 Checked gcstress0xc_zapdisable @ Windows.10.Amd64.Open\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n\r\ncoreclr windows x86 Checked gcstress0xc_jitminopts_heapverify1 @ Windows.10.Amd64.Open\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n```\r\n**Error message:**\r\n```\r\ncmdLine:C:hwA05C0952wACDA0907e\baseservices\threading\threading_group1../regressions/2164/foreground-shutdown/foreground-shutdown.cmd Timed Out (timeout in milliseconds: 5400000 from variable __TestTimeout, start: 3/26/2023 11:30:07 PM, end: 3/27/2023 1:00:07 AM)\r\n\r\nReturn code:      -100\r\nRaw output file:      C:hwA05C0952wACDA0907uploads\r\negressions2164\foreground-shutdownoutput.txt\r\nRaw output:\r\nBEGIN EXECUTION\r\n\"C:hwA05C0952pcorerun.exe\" -p \"System.Reflection.Metadata.MetadataUpdater.IsSupported=false\"  foreground-shutdown.dll\r\n\r\ncmdLine:C:hwA05C0952wACDA0907e\baseservices\threading\threading_group1../regressions/2164/foreground-shutdown/foreground-shutdown.cmd Timed Out (timeout in milliseconds: 5400000 from variable __TestTimeout, start: 3/26/2023 11:30:07 PM, end: 3/27/2023 1:00:07 AM)\r\nTest Harness Exitcode is : -100\r\nTo run the test:\r\nSet up CORE_ROOT and run.\r\n\r\nC:hwA05C0952wACDA0907e\baseservices\threading\threading_group1../regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\nExpected: True\r\nActual:   False\r\n\r\n\r\nStack trace\r\n   at Xunit.Assert.True(Nullable`1 condition, String userMessage) in /_/src/xunit.assert/Asserts/BooleanAsserts.cs:line 132\r\n   at TestLibrary.OutOfProcessTest.RunOutOfProcessTest(String basePath, String assemblyPath)\r\n   at Program.\u003c\u003cMain\u003e$\u003eg__TestExecutor2|0_1(StreamWriter tempLogSw, StreamWriter statsCsvSw, \u003c\u003ec__DisplayClass0_0\u0026)\r\n```\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOiHlJTw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5YoRPA",
                                           "createdAt":  "2023-03-28T14:01:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nRun: [runtime-coreclr gcstress-extra 20230326.1](https://dev.azure.com/dnceng-public/public/_build/results?buildId=217853\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=4073620\u0026resultId=347720\u0026paneView=debug)\r\n\r\nFailed test:\r\n```\r\ncoreclr windows arm64 Checked gcstress0xc_jitstress1 @ Windows.11.Arm64.Open\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n\r\ncoreclr windows x64 Checked gcstress0xc_zapdisable @ Windows.10.Amd64.Open\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n\r\ncoreclr windows x64 Checked gcstress0xc_jitstress1 @ Windows.10.Amd64.Open\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n\r\ncoreclr windows x86 Checked gcstress0xc_tailcallstress @ Windows.10.Amd64.Open\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n\r\ncoreclr windows arm64 Checked gcstress0xc_jitstress2 @ Windows.11.Arm64.Open\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n\r\ncoreclr windows x86 Checked gcstress0xc_jitstress1 @ Windows.10.Amd64.Open\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n\r\ncoreclr windows x86 Checked gcstress0xc_zapdisable @ Windows.10.Amd64.Open\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n\r\ncoreclr windows x86 Checked gcstress0xc_jitminopts_heapverify1 @ Windows.10.Amd64.Open\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n```\r\n**Error message:**\r\n```\r\ncmdLine:C:hwA05C0952wACDA0907e\baseservices\threading\threading_group1../regressions/2164/foreground-shutdown/foreground-shutdown.cmd Timed Out (timeout in milliseconds: 5400000 from variable __TestTimeout, start: 3/26/2023 11:30:07 PM, end: 3/27/2023 1:00:07 AM)\r\n\r\nReturn code:      -100\r\nRaw output file:      C:hwA05C0952wACDA0907uploads\r\negressions2164\foreground-shutdownoutput.txt\r\nRaw output:\r\nBEGIN EXECUTION\r\n\"C:hwA05C0952pcorerun.exe\" -p \"System.Reflection.Metadata.MetadataUpdater.IsSupported=false\"  foreground-shutdown.dll\r\n\r\ncmdLine:C:hwA05C0952wACDA0907e\baseservices\threading\threading_group1../regressions/2164/foreground-shutdown/foreground-shutdown.cmd Timed Out (timeout in milliseconds: 5400000 from variable __TestTimeout, start: 3/26/2023 11:30:07 PM, end: 3/27/2023 1:00:07 AM)\r\nTest Harness Exitcode is : -100\r\nTo run the test:\r\nSet up CORE_ROOT and run.\r\n\r\nC:hwA05C0952wACDA0907e\baseservices\threading\threading_group1../regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\nExpected: True\r\nActual:   False\r\n\r\n\r\nStack trace\r\n   at Xunit.Assert.True(Nullable`1 condition, String userMessage) in /_/src/xunit.assert/Asserts/BooleanAsserts.cs:line 132\r\n   at TestLibrary.OutOfProcessTest.RunOutOfProcessTest(String basePath, String assemblyPath)\r\n   at Program.\u003c\u003cMain\u003e$\u003eg__TestExecutor2|0_1(StreamWriter tempLogSw, StreamWriter statsCsvSw, \u003c\u003ec__DisplayClass0_0\u0026)\r\n```\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ev-wenyuxu\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`arch-arm64`, `arch-x86`, `area-System.Threading`, `os-windows`, `GCStress`, `JitStress`, `untriaged`, `needs-area-label`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-03-28T14:01:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZH0YW",
                                           "createdAt":  "2023-04-04T01:45:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "v-wenyuxu",
                                           "body":  "Failed again in: [runtime-coreclr gcstress-extra 20230402.1](https://dev.azure.com/dnceng-public/public/_build/results?buildId=225703\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=4242106\u0026resultId=358162\u0026paneView=debug)\r\n\r\nFailed test:\r\n```\r\ncoreclr windows arm64 Checked gcstress0xc_jitminopts_heapverify1 @ Windows.11.Arm64.Open\r\n\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n\r\ncoreclr windows arm64 Checked gcstress0xc_tailcallstress @ Windows.11.Arm64.Open\r\n\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n\r\ncoreclr windows x64 Checked gcstress0xc_jitminopts_heapverify1 @ Windows.10.Amd64.Open\r\n\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n\r\ncoreclr windows x64 Checked gcstress0xc_zapdisable_jitstress2 @ Windows.10.Amd64.Open\r\n\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n\r\ncoreclr windows x86 Checked gcstress0xc_jitminopts_heapverify1 @ Windows.10.Amd64.Open\r\n\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n\r\ncoreclr windows arm64 Checked gcstress0xc_zapdisable @ Windows.11.Arm64.Open\r\n\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n\r\ncoreclr windows x86 Checked gcstress0xc_zapdisable_jitstress2 @ Windows.10.Amd64.Open\r\n\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n\r\ncoreclr windows arm64 Checked gcstress0xc_zapdisable_heapverify1 @ Windows.11.Arm64.Open\r\n\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n```\r\n**Error message:**\r\n```\r\ncmdLine:C:hwB5E70A07wBF490A41e\baseservices\threading\threading_group1../regressions/2164/foreground-shutdown/foreground-shutdown.cmd Timed Out (timeout in milliseconds: 5400000 from variable __TestTimeout, start: 4/2/2023 11:19:16 PM, end: 4/3/2023 12:49:18 AM)\r\n\r\nReturn code:      -100\r\nRaw output file:      C:hwB5E70A07wBF490A41uploads\r\negressions2164\foreground-shutdownoutput.txt\r\nRaw output:\r\nBEGIN EXECUTION\r\n\"C:hwB5E70A07pcorerun.exe\" -p \"System.Reflection.Metadata.MetadataUpdater.IsSupported=false\"  foreground-shutdown.dll\r\n\r\ncmdLine:C:hwB5E70A07wBF490A41e\baseservices\threading\threading_group1../regressions/2164/foreground-shutdown/foreground-shutdown.cmd Timed Out (timeout in milliseconds: 5400000 from variable __TestTimeout, start: 4/2/2023 11:19:16 PM, end: 4/3/2023 12:49:18 AM)\r\nTest Harness Exitcode is : -100\r\nTo run the test:\r\nSet up CORE_ROOT and run.\r\n\r\nC:hwB5E70A07wBF490A41e\baseservices\threading\threading_group1../regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\nExpected: True\r\nActual:   False\r\n\r\n\r\nStack trace\r\n   at Xunit.Assert.True(Nullable`1 condition, String userMessage) in /_/src/xunit.assert/Asserts/BooleanAsserts.cs:line 132\r\n   at Xunit.Assert.True(Boolean condition, String userMessage) in /_/src/xunit.assert/Asserts/BooleanAsserts.cs:line 116\r\n   at TestLibrary.OutOfProcessTest.RunOutOfProcessTest(String basePath, String assemblyPath)\r\n   at Program.\u003c\u003cMain\u003e$\u003eg__TestExecutor2|0_1(StreamWriter tempLogSw, StreamWriter statsCsvSw, \u003c\u003ec__DisplayClass0_0\u0026)\r\n```",
                                           "updatedAt":  "2023-04-04T01:45:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZYZwl",
                                           "createdAt":  "2023-04-06T20:17:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "JulieLeeMSFT",
                                           "body":  "Hi @mangod9, could you take a look? \r\nFailed in [runtime-jit-experimental](https://dev.azure.com/dnceng-public/public/_build?definitionId=137)\r\nhttps://dev.azure.com/dnceng-public/public/_build/results?buildId=225731\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=4242342\u0026resultId=114995\u0026paneView=debug",
                                           "updatedAt":  "2023-04-06T20:17:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZbaHq",
                                           "createdAt":  "2023-04-07T14:50:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "@kouvel could you please take a look? ",
                                           "updatedAt":  "2023-04-07T14:50:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Zjwci",
                                           "createdAt":  "2023-04-11T01:14:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "v-wenyuxu",
                                           "body":  "Failed again in: [runtime-coreclr gcstress-extra 20230409.1](https://dev.azure.com/dnceng-public/public/_build/results?buildId=232932\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=4426258\u0026resultId=359187\u0026paneView=debug)\r\n\r\nFailed test:\r\n```\r\ncoreclr windows arm64 Checked gcstress0xc_zapdisable_jitstress2 @ Windows.11.Arm64.Open\r\n\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n\r\ncoreclr windows arm64 Checked gcstress0xc_zapdisable_jitstress2 @ Windows.11.Arm64.Open\r\n\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n```\r\n**Error message:**\r\n```\r\ncmdLine:C:hwAA20096AwB6D209CEe\baseservices\threading\threading_group1../regressions/2164/foreground-shutdown/foreground-shutdown.cmd Timed Out (timeout in milliseconds: 5400000 from variable __TestTimeout, start: 4/9/2023 10:42:38 PM, end: 4/10/2023 12:12:41 AM)\r\n\r\nReturn code:      -100\r\nRaw output file:      C:hwAA20096AwB6D209CEuploads\r\negressions2164\foreground-shutdownoutput.txt\r\nRaw output:\r\nBEGIN EXECUTION\r\n\"C:hwAA20096Apcorerun.exe\" -p \"System.Reflection.Metadata.MetadataUpdater.IsSupported=false\" -p \"System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization=true\"  foreground-shutdown.dll\r\n\r\ncmdLine:C:hwAA20096AwB6D209CEe\baseservices\threading\threading_group1../regressions/2164/foreground-shutdown/foreground-shutdown.cmd Timed Out (timeout in milliseconds: 5400000 from variable __TestTimeout, start: 4/9/2023 10:42:38 PM, end: 4/10/2023 12:12:41 AM)\r\nTest Harness Exitcode is : -100\r\nTo run the test:\r\nSet up CORE_ROOT and run.\r\n\u003e C:hwAA20096AwB6D209CEe\baseservices\threading\threading_group1../regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\nExpected: True\r\nActual:   False\r\n\r\n\r\nStack trace\r\n   at TestLibrary.OutOfProcessTest.RunOutOfProcessTest(String basePath, String assemblyPath)\r\n   at Program.\u0026lt;\u0026lt;Main\u0026gt;$\u0026gt;g__TestExecutor2|0_1(StreamWriter tempLogSw, StreamWriter statsCsvSw, \u0026lt;\u0026gt;c__DisplayClass0_0\u0026amp;)\r\n```\r\n",
                                           "updatedAt":  "2023-04-11T01:17:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Z4f2j",
                                           "createdAt":  "2023-04-14T06:20:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kunalspathak",
                                           "body":  "Ping @kouvel ",
                                           "updatedAt":  "2023-04-14T06:20:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5aJCik",
                                           "createdAt":  "2023-04-18T01:47:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "v-wenyuxu",
                                           "body":  "Failed again in: [runtime-coreclr gcstress-extra 20230416.1](https://dev.azure.com/dnceng-public/public/_build/results?buildId=241066\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=4631818\u0026resultId=336501\u0026paneView=debug)\r\n\r\nFailed test:\r\n```\r\ncoreclr windows x64 Checked gcstress0xc_zapdisable @ Windows.10.Amd64.Open\r\n\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n\r\ncoreclr windows x86 Checked gcstress0xc_jitminopts_heapverify1 @ Windows.10.Amd64.Open\r\n\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n\r\ncoreclr windows arm64 Checked gcstress0xc_jitstress1 @ Windows.11.Arm64.Open\r\n\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n\r\ncoreclr windows arm64 Checked gcstress0xc_zapdisable @ Windows.11.Arm64.Open\r\n\r\n- baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n```\r\n**Error message:**\r\n```\r\ncmdLine:C:hwA9D209A7wAA480925e\baseservices\threading\threading_group1../regressions/2164/foreground-shutdown/foreground-shutdown.cmd Timed Out (timeout in milliseconds: 5400000 from variable __TestTimeout, start: 4/16/2023 11:09:55 PM, end: 4/17/2023 12:39:57 AM)\r\n\r\nReturn code:      -100\r\nRaw output file:      C:hwA9D209A7wAA480925uploads\r\negressions2164\foreground-shutdownoutput.txt\r\nRaw output:\r\nBEGIN EXECUTION\r\n\"C:hwA9D209A7pcorerun.exe\" -p \"System.Reflection.Metadata.MetadataUpdater.IsSupported=false\" -p \"System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization=true\"  foreground-shutdown.dll\r\n\r\ncmdLine:C:hwA9D209A7wAA480925e\baseservices\threading\threading_group1../regressions/2164/foreground-shutdown/foreground-shutdown.cmd Timed Out (timeout in milliseconds: 5400000 from variable __TestTimeout, start: 4/16/2023 11:09:55 PM, end: 4/17/2023 12:39:57 AM)\r\nTest Harness Exitcode is : -100\r\nTo run the test:\r\nSet up CORE_ROOT and run.\r\n\u003e C:hwA9D209A7wAA480925e\baseservices\threading\threading_group1../regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\nExpected: True\r\nActual:   False\r\n\r\n\r\nStack trace\r\n   at Xunit.Assert.True(Nullable`1 condition, String userMessage) in /_/src/xunit.assert/Asserts/BooleanAsserts.cs:line 132\r\n   at TestLibrary.OutOfProcessTest.RunOutOfProcessTest(String basePath, String assemblyPath)\r\n   at Program.\u0026lt;\u0026lt;Main\u0026gt;$\u0026gt;g__TestExecutor2|0_1(StreamWriter tempLogSw, StreamWriter statsCsvSw, \u0026lt;\u0026gt;c__DisplayClass0_0\u0026amp;)\r\n```\r\n",
                                           "updatedAt":  "2023-04-18T01:48:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5bpgi9",
                                           "createdAt":  "2023-05-08T01:16:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "v-wenyuxu",
                                           "body":  "**Failed again in:** [runtime-coreclr gcstress0x3-gcstress0xc 20230507.1](https://dev.azure.com/dnceng-public/public/_build/results?buildId=265128\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=5216046\u0026resultId=169061\u0026paneView=debug)\r\n\r\n**Failed tests:**\r\n```\r\ncoreclr windows x64 Checked gcstress0xc @ Windows.10.Amd64.Open\r\n    - baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\n```\r\n\r\n**Error message:**\r\n```\r\n \r\ncmdLine:C:hwA8900954wAADF097Ae\baseservices\threading\threading_group1../regressions/2164/foreground-shutdown/foreground-shutdown.cmd Timed Out (timeout in milliseconds: 3600000 from variable __TestTimeout, start: 5/7/2023 3:30:19 PM, end: 5/7/2023 4:30:20 PM)\r\n\r\nReturn code:      -100\r\nRaw output file:      C:hwA8900954wAADF097Auploads\r\negressions2164\foreground-shutdownoutput.txt\r\nRaw output:\r\nBEGIN EXECUTION\r\n \u0026quot;C:hwA8900954pcorerun.exe\u0026quot; -p \u0026quot;System.Reflection.Metadata.MetadataUpdater.IsSupported=false\u0026quot; -p \u0026quot;System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization=true\u0026quot;  foreground-shutdown.dll \r\n\r\ncmdLine:C:hwA8900954wAADF097Ae\baseservices\threading\threading_group1../regressions/2164/foreground-shutdown/foreground-shutdown.cmd Timed Out (timeout in milliseconds: 3600000 from variable __TestTimeout, start: 5/7/2023 3:30:19 PM, end: 5/7/2023 4:30:20 PM)\r\nTest Harness Exitcode is : -100\r\nTo run the test:\r\nSet up CORE_ROOT and run.\r\n\u0026gt; C:hwA8900954wAADF097Ae\baseservices\threading\threading_group1../regressions/2164/foreground-shutdown/foreground-shutdown.cmd\r\nExpected: True\r\nActual:   False\r\n```\r\n\r\n**Stack trace:**\r\n```\r\n    at Xunit.Assert.True(Nullable`1 condition, String userMessage) in /_/src/xunit.assert/Asserts/BooleanAsserts.cs:line 132\r\n   at TestLibrary.OutOfProcessTest.RunOutOfProcessTest(String basePath, String assemblyPath)\r\n   at Program.\u0026lt;\u0026lt;Main\u0026gt;$\u0026gt;g__TestExecutor2|0_1(StreamWriter tempLogSw, StreamWriter statsCsvSw, \u0026lt;\u0026gt;c__DisplayClass0_0\u0026amp;)\r\n```\r\n\r\n",
                                           "updatedAt":  "2023-05-08T01:16:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5jUHcn",
                                           "createdAt":  "2023-08-04T21:56:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "Moving to 9 since this is disabled. ",
                                           "updatedAt":  "2023-08-04T21:56:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GByui",
                                           "createdAt":  "2024-07-24T18:05:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "From what I can see this is no longer disabled. ",
                                           "updatedAt":  "2024-07-24T18:05:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6IeUlP",
                                           "createdAt":  "2024-08-14T19:14:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "It looks like it\u0027s still disabled here: https://github.com/dotnet/runtime/blob/3eba70227be23baee21c13a7ab9316d58d469b82/src/tests/issues.targets#L30-L32",
                                           "updatedAt":  "2024-08-14T19:14:05Z"
                                       }
                                   ],
                         "totalCount":  11
                     },
        "title":  "Test failure baseservices/threading/regressions/2164/foreground-shutdown/foreground-shutdown.cmd",
        "labels":  [
                       "area-System.Threading",
                       "disabled-test",
                       "os-windows",
                       "GCStress",
                       "JitStress",
                       "blocking-clean-ci-optional"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/84298",
        "createdAt":  "2023-04-04T13:24:29Z",
        "number":  84298,
        "author":  "kamilslusarczyk",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-07-24T18:02:02Z",
        "body":  "Hey,\r\n\r\nI would like to ask if there are any plans to introduce any documentation for [rate limiter library](https://www.nuget.org/packages/System.Threading.RateLimiting) in .NET 4.6.2. There are docs for .NET Core (middleware approach) but couldn\u0027t find anything related to legacy .NET.\r\n\r\nCheers,\r\nKamil",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOW8y8Aw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5ZKqyR",
                                           "createdAt":  "2023-04-04T13:24:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nHey,\r\n\r\nI would like to ask if there are any plans to introduce any documentation for [rate limiter library](https://www.nuget.org/packages/System.Threading.RateLimiting) in .NET 4.6.2. There are docs for .NET Core (middleware approach) but couldn\u0027t find anything related to legacy .NET.\r\n\r\nCheers,\r\nKamil\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ekamilslusarczyk\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-04-04T13:24:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5bx2j0",
                                           "createdAt":  "2023-05-09T09:39:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kamilslusarczyk",
                                           "body":  "Hey @mangod9, can you shed some light on question above?",
                                           "updatedAt":  "2023-05-09T09:39:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5bzLwD",
                                           "createdAt":  "2023-05-09T13:38:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODJb9_w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pmoleri",
                                                                               "createdAt":  "2023-10-12T12:25:58Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "The APIs are delivered in a nuget package.  They\u0027re functionally the same regardless of whether targeting .NET Core or .NET Framework.\r\nhttps://learn.microsoft.com/en-us/dotnet/api/system.threading.ratelimiting",
                                           "updatedAt":  "2023-05-09T13:38:25Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "System.Threading.RateLimiting documentation for .NET 4.6 ",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/84547",
        "createdAt":  "2023-04-09T18:06:52Z",
        "number":  84547,
        "author":  "tkreindler",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODMv8nQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Daniel-Svensson",
                                            "createdAt":  "2025-08-26T20:16:28Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2023-07-24T17:55:11Z",
        "body":  "### Background and motivation\n\nAs we update our applications to asynchronous .Net 6+ based applications one of the most common duplicate patterns I see is that of an async ReaderWriterLock. We have multiple different in-house versions in Substrate alone. The closest thing to an official implementation that I can find is from the [Microsoft.VisualStudio.Threading](https://learn.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.threading.asyncreaderwriterlock?view=visualstudiosdk-2022) NuGet package but that implementation includes a lot of logic from the rest of that NuGet package. In addition, a dependency on that is yet again another dependency on a NuGet with an irregular release schedule.\r\n\r\nI propose a new type AsyncReaderWriterLock (or AsyncReaderWriterLockSlim) which is based on SemaphoreSlim, allowing async reader-writer functionality. I understand the threshold for new types in the runtime is very high but I believe this type would be a great addition to standardizing common patterns.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Threading;\r\n\r\n// API designed loosely off of ReaderWriterLockSlim and SemaphoreSlim. Additional APIs could be filled in.\r\npublic class AsyncReaderWriterLock : IDisposable\r\n{\r\n    public void EnterWriteLock(TimeSpan timeout = default, CancellationToken cancellationToken = default);\r\n\r\n    public ValueTask EnterWriteLockAsync(TimeSpan timeout = default, CancellationToken cancellationToken = default);\r\n\r\n    public void EnterReadLock(TimeSpan timeout = default, CancellationToken cancellationToken = default);\r\n\r\n    public ValueTask EnterReadLockAsync(TimeSpan timeout = default, CancellationToken cancellationToken = default);\r\n\r\n    public void ExitReadLock();\r\n\r\n    public void ExitWriteLock();\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\n// global variables\r\nDictionary\u003cstring, string\u003e dictionary = new ();\r\nusing AsyncReaderWriterLockSlim lock = new ();\r\n\r\n// writer thread/async task\r\nawait lock.EnterWriteLockAsync();\r\ntry\r\n{\r\n    // do writes under lock\r\n    dictionary[\"key\"] = \"value\";\r\n}\r\nfinally\r\n{\r\n    lock.ExitWriteLock();\r\n}\r\n\r\n// reader thread/async task\r\nawait lock.EnterReadLockAsync();\r\ntry\r\n{\r\n    // do reads under lock\r\n    string value = dictionary[\"key\"];\r\n}\r\nfinally\r\n{\r\n    lock.ExitReadLock();\r\n}\r\n\r\n\r\n```\r\n\n\n### Alternative Designs\n\nAlternatively async methods could be added to the existing ReaderWriterLockSlim:\r\n\r\n```csharp\r\nnamespace System.Threading;\r\n\r\n// partial class adding new methods to the existing class\r\npublic partial class ReaderWriterLockSlim : IDisposable\r\n{\r\n    public ValueTask EnterWriteLockAsync(TimeSpan timeout = default, CancellationToken cancellationToken = default);\r\n\r\n    public ValueTask EnterReadLockAsync(TimeSpan timeout = default, CancellationToken cancellationToken = default);\r\n}\r\n```\r\n\r\nThis would reduce runtime bloat by not adding a new type but I\u0027m not sure the implications it could have on backwards compatibility and performance to the existing type. Most implementations of AsyncReaderWriterLock I\u0027ve seen have been based on SemaphoreSlim and I\u0027m not sure if jamming an async implementation into the existing class is even feasible.\n\n### Risks\n\nThe only risk I can think of is the addition of a new type to the runtime causing bloat, but I think the benefits far outweigh this.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOWcAxlQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5Zejx7",
                                           "createdAt":  "2023-04-09T18:07:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nAs we update our applications to asynchronous .Net 6+ based applications one of the most common duplicate patterns I see is that of an async ReaderWriterLock. We have multiple different in-house versions in Substrate alone. The closest thing to an official implementation that I can find is from the [Microsoft.VisualStudio.Threading](https://learn.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.threading.asyncreaderwriterlock?view=visualstudiosdk-2022) NuGet package but that implementation includes a lot of logic from the rest of that NuGet package. In addition, a dependency on that is yet again another dependency on a NuGet with an irregular release schedule.\r\n\r\nI propose a new type AsyncReaderWriterLock (or AsyncReaderWriterLockSlim) which is based on SemaphoreSlim, allowing async reader-writer functionality. I understand the threshold for new types in the runtime is very high but I believe this type would be a great addition to standardizing common patterns.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Threading;\r\n\r\n// API designed loosely off of ReaderWriterLockSlim and SemaphoreSlim. Additional APIs could be filled in.\r\npublic class AsyncReaderWriterLock : IDisposable\r\n{\r\n    public void EnterWriteLock(TimeSpan timeout = default, CancellationToken cancellationToken = default);\r\n\r\n    public ValueTask EnterWriteLockAsync(TimeSpan timeout = default, CancellationToken cancellationToken = default);\r\n\r\n    public void EnterReadLock(TimeSpan timeout = default, CancellationToken cancellationToken = default);\r\n\r\n    public ValueTask EnterReadLockAsync(TimeSpan timeout = default, CancellationToken cancellationToken = default);\r\n\r\n    public void ExitReadLock();\r\n\r\n    public void ExitWriteLock();\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\n// global variables\r\nDictionary\u003cstring, string\u003e dictionary = new ();\r\nusing AsyncReaderWriterLockSlim lock = new ();\r\n\r\n// writer thread/async task\r\nawait lock.EnterWriteLockAsync();\r\ntry\r\n{\r\n    // do writes under lock\r\n    dictionary[\"key\"] = \"value\";\r\n}\r\nfinally\r\n{\r\n    lock.ExitWriteLock();\r\n}\r\n\r\n// reader thread/async task\r\nawait lock.EnterReadLockAsync();\r\ntry\r\n{\r\n    // do reads under lock\r\n    string value = dictionary[\"key\"];\r\n}\r\nfinally\r\n{\r\n    lock.ExitReadLock();\r\n}\r\n\r\n\r\n```\r\n\n\n### Alternative Designs\n\nAlternatively async methods could be added to the existing ReaderWriterLockSlim:\r\n\r\n```csharp\r\nnamespace System.Threading;\r\n\r\n// partial class adding new methods to the existing class\r\npublic partial class ReaderWriterLockSlim : IDisposable\r\n{\r\n    public ValueTask EnterWriteLockAsync(TimeSpan timeout = default, CancellationToken cancellationToken = default);\r\n\r\n    public ValueTask EnterReadLockAsync(TimeSpan timeout = default, CancellationToken cancellationToken = default);\r\n}\r\n```\r\n\r\nThis would reduce runtime bloat by not adding a new type but I\u0027m not sure the implications it could have on backwards compatibility and performance to the existing type. Most implementations of AsyncReaderWriterLock I\u0027ve seen have been based on SemaphoreSlim and I\u0027m not sure if jamming an async implementation into the existing class is even feasible.\n\n### Risks\n\nThe only risk I can think of is the addition of a new type to the runtime causing bloat, but I think the benefits far outweigh this.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003etkreindler\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-04-09T18:07:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZekM8",
                                           "createdAt":  "2023-04-09T18:15:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "alexrp",
                                           "body":  "\u003e Alternatively async methods could be added to the existing ReaderWriterLockSlim:\r\n\r\nNote that `ReaderWriterLockSlim` is thread-affine, so that cannot be done. Adding such methods works for `SemaphoreSlim` because it doesn\u0027t have thread affinity.",
                                           "updatedAt":  "2023-04-09T18:15:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Zek0Q",
                                           "createdAt":  "2023-04-09T18:30:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "\u003e that implementation includes a lot of logic from the rest of that NuGet package\r\n\r\nTrimming can remove the unrelated logic from the package.\r\n\r\n\u003e a dependency on that is yet again another dependency on a NuGet\r\n\r\nWhy is this a bad thing? And moreover it\u0027s a Micrsoft package.\r\n\r\n\u003e with an irregular release schedule\r\n\r\nThis does not mean it\u0027s unsupported.",
                                           "updatedAt":  "2023-04-09T18:30:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZwDGV",
                                           "createdAt":  "2023-04-12T18:52:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODKquhw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tkreindler",
                                                                               "createdAt":  "2023-10-23T17:32:34Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "sakno",
                                           "body":  "[AsyncReaderWriterLock](https://dotnet.github.io/dotNext/api/DotNext.Threading.AsyncReaderWriterLock.html) from .NEXT library which is a member of .NET Foundation. It is mature, optimized (amortized zero alloc of tasks), supports optimistic lock and many other features.",
                                           "updatedAt":  "2023-04-12T18:52:22Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "[API Proposal]: AsyncReaderWriterLock",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/85128",
        "createdAt":  "2023-04-20T22:53:57Z",
        "number":  85128,
        "author":  "danmoseley",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCvn-_A==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kouvel",
                                            "createdAt":  "2023-04-21T00:53:40Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-07-19T00:11:02Z",
        "body":  "lock/Monitor supports recursion but does not seem to document or enforce a limit.\r\n\r\nRight now it uses the object header [up to 64 or so](https://github.com/dotnet/runtime/blob/048467b13160399d493b97a90b2117f58f01ac51/src/coreclr/nativeaot/System.Private.CoreLib/src/System/Threading/ObjectHeader.cs#L416), then transitions to a sync block. That uses a [64 bit counter](https://github.com/dotnet/runtime/blob/048467b13160399d493b97a90b2117f58f01ac51/src/coreclr/vm/syncblk.h#L437).\r\n\r\nCorrectness wise, it looks like the counter will just wrap (and release?) if code hits the limit -- given the size the chance of this is basically zero though.\r\n\r\nBut it might be interesting to pick a maximum recursion count that is less than ulong.MaxValue but greater than any plausible functioning code would need, then throw LockRecursionException when it\u0027s hit. This would expose any buggy code that is recursing without bound.\r\n\r\ncc @kouvel from https://github.com/dotnet/runtime/issues/34812#issuecomment-1516763468",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOWoy2tg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5abB5X",
                                           "createdAt":  "2023-04-20T22:54:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nlock/Monitor supports recursion but does not seem to document or enforce a limit.\r\n\r\nRight now it uses the object header [up to 64 or so](https://github.com/dotnet/runtime/blob/048467b13160399d493b97a90b2117f58f01ac51/src/coreclr/nativeaot/System.Private.CoreLib/src/System/Threading/ObjectHeader.cs#L416), then transitions to a sync block. That uses a [64 bit counter](https://github.com/dotnet/runtime/blob/048467b13160399d493b97a90b2117f58f01ac51/src/coreclr/vm/syncblk.h#L437).\r\n\r\nCorrectness wise, it looks like the counter will just wrap (and release?) if code hits the limit -- that probably doesn\u0027t matter much because it\u0027s implausible that could happen in a reasonable amount of time.\r\n\r\nBut it might be interesting to pick a maximum recursion count that is less than ulong.MaxValue but greater than any plausible functioning code would need, then throw LockRecursionException when it\u0027s hit. This would expose any buggy code that is recursing without bound.\r\n\r\ncc @kouvel \r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003edanmoseley\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-04-20T22:54:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5abC43",
                                           "createdAt":  "2023-04-20T23:00:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "looks like nativeAOT [ will throw ](https://github.com/dotnet/runtime/blob/048467b13160399d493b97a90b2117f58f01ac51/src/coreclr/nativeaot/System.Private.CoreLib/src/System/Threading/Lock.cs#L186) (OverflowException) if recursion fills 32 bits. \r\n",
                                           "updatedAt":  "2023-04-20T23:00:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ahUVH",
                                           "createdAt":  "2023-04-22T15:13:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC63VMg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "danmoseley",
                                                                               "createdAt":  "2023-05-01T00:41:08Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "svick",
                                           "body":  "\u003e This would expose any buggy code that is recursing without bound.\r\n\r\nDo I understand it correctly that the goal here is to cover the (rare?) cases that don\u0027t already throw `StackOverflowException`, like those that are tail-call optimized, or those that call `Monitor.Enter` in a loop?",
                                           "updatedAt":  "2023-04-22T15:13:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ajLa2",
                                           "createdAt":  "2023-04-23T21:21:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "This issue is about one thread entering a lock multiple times without exiting it. There is an inherent limit on the number of such enters after which an exception should be thrown.",
                                           "updatedAt":  "2023-04-23T21:21:46Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Monitor should limit recursion",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/85762",
        "createdAt":  "2023-05-04T10:58:27Z",
        "number":  85762,
        "author":  "petr-horny-bsshop",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-07-24T17:49:31Z",
        "body":  "\u003c!--This is just a template - feel free to delete any and all of it and replace as appropriate.--\u003e\r\n\r\n### Description\r\n\r\nWe operate a web farm with hundreds of websites. We recently modified one background operation to asynchronous code. After updating all the sites, our CPU consumption suddenly increased by a factor of two. \r\nAfter investigating, we found that the problem is caused by replacing the Thread.Sleep() call with Task.Delay().\r\nConsider these two methods:\r\n```csharp\r\nstatic void ThreadSleepLoop()\r\n{\r\n      while (true)\r\n      {\r\n            Thread.Sleep(100);  // consumes negligible amount of CPU\r\n      }\r\n}\r\n\r\nstatic async Task TaskDelayLoop()\r\n{\r\n      while (true)\r\n      {\r\n            await Task.Delay(100);  // consumes lot of CPU\r\n      }\r\n}\r\n```\r\nThe first one consumes negligible amount of CPU, but the second one consumes lot of CPU.\r\n\r\nIt is important to note that this problem can only be induced in the case of a large number of processes (approximately 400 in our case) with one or a small number of threads, not one process with many threads.\r\n\r\n### Steps to reproduce\r\nBuild this console application:\r\n```csharp\r\ninternal class Program\r\n{\r\n    static async Task Main(string[] args)\r\n    {\r\n        if (args.Length == 0)\r\n        {\r\n            Console.WriteLine(\"Invalid arguments\");\r\n            return;\r\n        }\r\n\r\n        // create processes \r\n        if (args.Length == 1)\r\n        {\r\n            const int processesPerCore = 100;\r\n            var totalProcesses = Environment.ProcessorCount * processesPerCore;\r\n            Console.WriteLine($\"total processes: {totalProcesses}, method: {args[0]}, runtime: {Environment.Version}\");\r\n\r\n            ThreadPool.SetMinThreads(totalProcesses, 100);\r\n            \r\n            var executable = Process.GetCurrentProcess().MainModule.FileName;\r\n            \r\n            Parallel.For(0, totalProcesses, _ =\u003e Process.Start(executable, $\"{args[0]} run\"));\r\n            return;\r\n        }\r\n\r\n        if (args[0] == \"TaskDelayLoop\")\r\n        {\r\n            // consumes lot of CPU\r\n            await TaskDelayLoop();\r\n        }\r\n        else if (args[0] == \"ThreadSleepLoop\")\r\n        {\r\n            // consumes negligible amount of CPU\r\n            ThreadSleepLoop();\r\n        }\r\n        else Console.WriteLine(\"Invalid arguments\");\r\n\r\n        Console.ReadLine();\r\n    }\r\n\r\n    static async Task TaskDelayLoop()\r\n    {\r\n        Console.Write(\".\");\r\n        while (true)\r\n        {\r\n            await Task.Delay(100);  // consumes lot of CPU\r\n        }\r\n    }\r\n\r\n    static void ThreadSleepLoop()\r\n    {\r\n        Console.Write(\".\");\r\n        while (true)\r\n        {\r\n            Thread.Sleep(100);  // consumes negligible amount of CPU\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nRun Windows Performance Monitor and measure CPU.\r\nRun `ConsoleApp.exe ThreadSleepLoop` and measure, then kill\r\nRun `ConsoleApp.exe TaskDelayLoop` and measure, then kill\r\n\r\n### Configuration\r\n.NET 7.0.5\r\nWindows Server 2019\r\nIntel Xeon E5-2630L\r\nWe also tried and reproduced this issue on different machines with different OS.\r\n\r\n### Data\r\nHere is a chart with CPU consumption for Thread.Sleep()\r\n![ThreadSleep](https://user-images.githubusercontent.com/102522083/236180855-83db4cdb-fef4-46f3-93be-0c97811b3328.png)\r\n\r\nHere is a chart with CPU consumption for Task.Delay()\r\n![TaskDelay](https://user-images.githubusercontent.com/102522083/236182033-ca4820ee-4afc-42fc-8e0e-45960984ec23.png)\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOW3kQQA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5beFrq",
                                           "createdAt":  "2023-05-04T11:37:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Have you profiled to see where the time is being spent? I susoect this actually has little to do with Task.Delay.and is actually just measuring a thread pool thread that wakes up, processes a tiny amount of work, and then goes in search of other work to do. It won\u0027t find any, so it\u0027ll go back to sleep, only to then be woken again by the next timer, processes a tiny amount of work, and then goes in search of more to do, etc. That searching can be measurable.",
                                           "updatedAt":  "2023-05-04T11:37:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5beQHw",
                                           "createdAt":  "2023-05-04T12:06:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "petr-horny-bsshop",
                                           "body":  "@stephentoub Yes, you are right \"Task.Delay consumes lot of CPU\" is misleading description. Task.Delay as such does not consume CPU time. The thing is if the thread/process is waiting for work it should not consume that much CPU. In our case the CPU utilization was around 50%, which means that half of the available CPU time there was no work to do. After we replaced Thread.Sleep with Task.Delay, the CPU utilization increased to 100%.\r\n\r\nBelow are profiles for Task.Delay and Thread.Sleep in a loop.\r\nThread.Sleep\r\n![flame-thread](https://user-images.githubusercontent.com/102522083/236197512-e05f6960-26f2-49d5-a8a9-4ecd976ec4dc.png)\r\nTask.Delay\r\n![flame-task](https://user-images.githubusercontent.com/102522083/236197539-32dd6197-03db-4dd3-b88e-ff5536e8ec4d.png)\r\n",
                                           "updatedAt":  "2023-05-04T12:06:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5beRBA",
                                           "createdAt":  "2023-05-04T12:08:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n\u003c!--This is just a template - feel free to delete any and all of it and replace as appropriate.--\u003e\r\n\r\n### Description\r\n\r\nWe operate a web farm with hundreds of websites. We recently modified one background operation to asynchronous code. After updating all the sites, our CPU consumption suddenly increased by a factor of two. \r\nAfter investigating, we found that the problem is caused by replacing the Thread.Sleep() call with Task.Delay().\r\nConsider these two methods:\r\n```csharp\r\nstatic void ThreadSleepLoop()\r\n{\r\n      while (true)\r\n      {\r\n            Thread.Sleep(100);  // consumes negligible amount of CPU\r\n      }\r\n}\r\n\r\nstatic async Task TaskDelayLoop()\r\n{\r\n      while (true)\r\n      {\r\n            await Task.Delay(100);  // consumes lot of CPU\r\n      }\r\n}\r\n```\r\nThe first one consumes negligible amount of CPU, but the second one consumes lot of CPU.\r\n\r\nIt is important to note that this problem can only be induced in the case of a large number of processes (approximately 400 in our case) with one or a small number of threads, not one process with many threads.\r\n\r\n### Steps to reproduce\r\nBuild this console application:\r\n```csharp\r\ninternal class Program\r\n{\r\n    static async Task Main(string[] args)\r\n    {\r\n        if (args.Length == 0)\r\n        {\r\n            Console.WriteLine(\"Invalid arguments\");\r\n            return;\r\n        }\r\n\r\n        // create processes \r\n        if (args.Length == 1)\r\n        {\r\n            const int processesPerCore = 100;\r\n            var totalProcesses = Environment.ProcessorCount * processesPerCore;\r\n            Console.WriteLine($\"total processes: {totalProcesses}, method: {args[0]}, runtime: {Environment.Version}\");\r\n\r\n            ThreadPool.SetMinThreads(totalProcesses, 100);\r\n            \r\n            var executable = Process.GetCurrentProcess().MainModule.FileName;\r\n            \r\n            Parallel.For(0, totalProcesses, _ =\u003e Process.Start(executable, $\"{args[0]} run\"));\r\n            return;\r\n        }\r\n\r\n        if (args[0] == \"TaskDelayLoop\")\r\n        {\r\n            // consumes lot of CPU\r\n            await TaskDelayLoop();\r\n        }\r\n        else if (args[0] == \"ThreadSleepLoop\")\r\n        {\r\n            // consumes negligible amount of CPU\r\n            ThreadSleepLoop();\r\n        }\r\n        else Console.WriteLine(\"Invalid arguments\");\r\n\r\n        Console.ReadLine();\r\n    }\r\n\r\n    static async Task TaskDelayLoop()\r\n    {\r\n        Console.Write(\".\");\r\n        while (true)\r\n        {\r\n            await Task.Delay(100);  // consumes lot of CPU\r\n        }\r\n    }\r\n\r\n    static void ThreadSleepLoop()\r\n    {\r\n        Console.Write(\".\");\r\n        while (true)\r\n        {\r\n            Thread.Sleep(100);  // consumes negligible amount of CPU\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nRun Windows Performance Monitor and measure CPU.\r\nRun `ConsoleApp.exe ThreadSleepLoop` and measure, then kill\r\nRun `ConsoleApp.exe TaskDelayLoop` and measure, then kill\r\n\r\n### Configuration\r\n.NET 7.0.5\r\nWindows Server 2019\r\nIntel Xeon E5-2630L\r\nWe also tried and reproduced this issue on different machines with different OS.\r\n\r\n### Data\r\nHere is a chart with CPU consumption for Thread.Sleep()\r\n![ThreadSleep](https://user-images.githubusercontent.com/102522083/236180855-83db4cdb-fef4-46f3-93be-0c97811b3328.png)\r\n\r\nHere is a chart with CPU consumption for Task.Delay()\r\n![TaskDelay](https://user-images.githubusercontent.com/102522083/236182033-ca4820ee-4afc-42fc-8e0e-45960984ec23.png)\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003epetr-horny-bsshop\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `tenet-performance`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-05-04T12:08:23Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Task.Delay consumes lot of CPU",
        "labels":  [
                       "area-System.Threading",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/87112",
        "createdAt":  "2023-06-04T14:26:39Z",
        "number":  87112,
        "author":  "MaciekSwiszczowski",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-15T07:34:12Z",
        "body":  "### Description\r\n\r\nI\u0027ve found that Task.Delay(1) and Task.Delay(2) may take shorter than the expected 1 or 2 milliseconds. This can be observed in the reproduction app. These short delays can be also measured in Visual Studio, when running the application with Debug-\u003ePerformance Profiler-\u003e.NET async.\r\n\r\nThe issue was reproduced on a few Windows 11 machines. It doesn\u0027t appear on lower .NET version.\r\n\r\n\r\n### Reproduction Steps\r\n\r\nTo reproduce, please run this:\r\n``` c#\r\nawait DelayTest(1, 1000);\r\nawait DelayTest(2, 10000);\r\n\r\n    private static async Task DelayTest(int milliseconds, int iterationsCount)\r\n    {\r\n        var stopWatch = new Stopwatch();\r\n        stopWatch.Start();\r\n        var deltas = new TimeSpan[iterationsCount];\r\n        var tick = stopWatch.Elapsed;\r\n\r\n        for (var j = 0; j \u003c iterationsCount; j++)\r\n        {\r\n            await Task.Delay(milliseconds);\r\n\r\n            deltas[j] = stopWatch.Elapsed - tick;\r\n            tick = stopWatch.Elapsed;\r\n\r\n            Thread.SpinWait(10000 + 5 * j);\r\n        }\r\n\r\n        var shortSpans =\r\n            deltas\r\n                .Where(i =\u003e i.TotalMilliseconds \u003c= milliseconds)\r\n                .OrderBy(i =\u003e i)\r\n                .Select(i =\u003e i.TotalMilliseconds)\r\n                .ToList();\r\n\r\n        Console.WriteLine();\r\n        Console.WriteLine(shortSpans.Any() ? string.Join(\" \", shortSpans) : \"No issues found\");\r\n    }\r\n```\r\n### Expected behavior\r\n\r\n`await Task.Delay(expected_milliseconds)` should wait at least `expected_milliseconds`.\r\n\r\n### Actual behavior\r\n\r\n`await Task.Delay(expected_milliseconds)` sometimes waits shorter than  `expected_milliseconds`\r\n\r\n### Regression?\r\n\r\nWorks fine in .NET versions prior to .NET 7\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\ntested on:\r\n- Windows 11,\r\n-  .NET 7 \u0026 8, \r\n- x64 / AnyCPU\r\n\r\n### Other information\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOtyGT7g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5d6ahu",
                                           "createdAt":  "2023-06-04T14:39:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\nI\u0027ve found that Task.Delay(1) and Task.Delay(2) may take shorter than the expected 1 or 2 milliseconds. This can be observed in the reproduction app. These short delays can be also measured in Visual Studio, when running the application with Debug-\u003ePerformance Profiler-\u003e.NET async.\r\n\r\nThe issue was reproduced on a few Windows 11 machines. It doesn\u0027t appear on lower .NET version.\r\n\r\n\r\n### Reproduction Steps\r\n\r\nTo reproduce, please run this:\r\n``` c#\r\nawait DelayTest(1, 1000);\r\nawait DelayTest(2, 10000);\r\n\r\n    private static async Task DelayTest(int milliseconds, int iterationsCount)\r\n    {\r\n        var stopWatch = new Stopwatch();\r\n        stopWatch.Start();\r\n        var deltas = new TimeSpan[iterationsCount];\r\n        var tick = stopWatch.Elapsed;\r\n\r\n        for (var j = 0; j \u003c iterationsCount; j++)\r\n        {\r\n            await Task.Delay(milliseconds);\r\n\r\n            deltas[j] = stopWatch.Elapsed - tick;\r\n            tick = stopWatch.Elapsed;\r\n\r\n            Thread.SpinWait(10000 + 5 * j);\r\n        }\r\n\r\n        var shortSpans =\r\n            deltas\r\n                .Where(i =\u003e i.TotalMilliseconds \u003c= milliseconds)\r\n                .OrderBy(i =\u003e i)\r\n                .Select(i =\u003e i.TotalMilliseconds)\r\n                .ToList();\r\n\r\n        Console.WriteLine();\r\n        Console.WriteLine(shortSpans.Any() ? string.Join(\" \", shortSpans) : \"No issues found\");\r\n    }\r\n\r\n### Expected behavior\r\n\r\n`await Task.Delay(expected_milliseconds)` should wait at least `expected_milliseconds`.\r\n\r\n### Actual behavior\r\n\r\n`await Task.Delay(expected_milliseconds)` sometimes waits shorter than  `expected_milliseconds`\r\n\r\n### Regression?\r\n\r\nWorks fine in .NET versions prior to .NET 7\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\ntested on:\r\n- Windows 11,\r\n-  .NET 7 \u0026 8, \r\n- x64 / AnyCPU\r\n\r\n### Other information\r\n\r\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eMaciekSwiszczowski\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`, `needs-area-label`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-06-04T14:39:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5d6any",
                                           "createdAt":  "2023-06-04T14:41:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "I\u0027ve not tried to repro, but Task.Delay is just wrapping Timer, so presumably you see the same behavior with it directly? ",
                                           "updatedAt":  "2023-06-05T03:33:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5d7HZC",
                                           "createdAt":  "2023-06-04T23:23:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MaciekSwiszczowski",
                                           "body":  "Sure, but that should be documented at least.",
                                           "updatedAt":  "2023-06-04T23:23:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5d9cA6",
                                           "createdAt":  "2023-06-05T08:47:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "RedworkDE",
                                           "body":  "1. Yes this also happens when using Threading.Timer and Timers.Timer, not with Thread.Sleep tho\r\n2. This can happen for any duration not just 1/2 ms\r\n3. For some durations it is pretty likely that the timer is early, eg for 15ms (and small multiples) 10-20% of the waits have ended early\r\n4. The timer is never more than 1ms early\r\n5. What happens is that the timer internally works at ms resolution only and the timer effectively starts at the beginning of the current millisecond and not the time of the call, thus when staring a timer for `t`ms at the end of millisecond `n` and the internal timer fires at the start of millisecond `n+t` the timer will fire after having waited only `t-1`ms\r\n6. A simplified test project (It will only show the issue for some durations, but is way faster):\r\n```cs\r\nasync Task DelayTest(int milliseconds, int iterationsCount)\r\n{\r\n    var stopWatch = new System.Diagnostics.Stopwatch();\r\n    var n = 0;\r\n\r\n    for (var j = 0; j \u003c iterationsCount; j++)\r\n    {\r\n        stopWatch.Restart();\r\n        await Task.Delay(milliseconds);\r\n        stopWatch.Stop();\r\n\r\n        if (stopWatch.Elapsed.TotalMilliseconds \u003c milliseconds)\r\n            n++;\r\n    }\r\n\r\n    Console.WriteLine($\"{milliseconds}ms: {n}/{iterationsCount} {(float)n / iterationsCount:P}\");\r\n}\r\n\r\nfor (int i = 1; i \u003c 35; i++)\r\n{\r\n    await DelayTest(i, 1_00);\r\n}\r\n```",
                                           "updatedAt":  "2023-06-05T08:47:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5d9wxa",
                                           "createdAt":  "2023-06-05T09:43:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MaciekSwiszczowski",
                                           "body":  "Thanks for the explanation!",
                                           "updatedAt":  "2023-06-05T09:43:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5eCoA2",
                                           "createdAt":  "2023-06-06T01:04:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "@kouvel  is there any work here or just docs?",
                                           "updatedAt":  "2023-06-06T01:04:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5eJIoB",
                                           "createdAt":  "2023-06-06T21:07:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "Currently, none of the system clocks used (in the timer thread for waits, or in timer due time tracking) have sub-ms precision. Although the due time tracking could be updated to use a high-precision clock, it is a lot more expensive, and there can be times when the timer thread wakes up only to find that none of the timers\u0027 due times have expired and go back to waiting again. The current behavior seems reasonable for most cases. I think it would be good to update the docs to clarify.",
                                           "updatedAt":  "2023-06-06T21:07:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5eJN3V",
                                           "createdAt":  "2023-06-06T21:27:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "@MaciekSwiszczowski - Are you expecting the delay to be **at least** the indicated 1 or 2 ms?\r\n\r\n(Historically, most things that were delayed, or were dealing with lower-resolution timers, or similar functions, had a 60hz resolution - including things like getting the time from the clock!)\r\n\r\nOtherwise, this feels like a more specific form of \"your application must account for timing issues arising from the vagaries of CPU scheduling and timer resolution\".  Which is a well known (or should be) limitation...",
                                           "updatedAt":  "2023-06-06T21:27:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5eJZWt",
                                           "createdAt":  "2023-06-06T22:09:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MaciekSwiszczowski",
                                           "body":  "@Clockwork-Muse Yes, my understanding of Task.Delay() was that it should wait at least the expected amount of milliseconds. But if I needed such a resolution in production code, I\u0027d make research.\r\n\r\nI\u0027ve just observed this behavior of waiting less than expected, and I\u0027ve checked that I can\u0027t reproduce it for .NET versions 5 and 6, so I thought it\u0027s a regression issue.",
                                           "updatedAt":  "2023-06-06T22:09:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5eJa3t",
                                           "createdAt":  "2023-06-06T22:16:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "Prior to .NET 7 a different Windows API was used for timer due time tracking, which may use a slightly different clock, though it also apparently has similar precision and would have similar issues. I don\u0027t see any reason why the prior implementations would have stronger guarantees.",
                                           "updatedAt":  "2023-06-06T22:16:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5eJ63r",
                                           "createdAt":  "2023-06-07T00:41:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "RedworkDE",
                                           "body":  "IMO this is just an off-by-one error and replacing this `\u003c=` with a `\u003c` should (I didn\u0027t test it) fix the issue by ensuring the minimum wait is until the end of the target millisecond: https://github.com/dotnet/runtime/blob/10222f94e5d89b19959117dd9e5b8576ef63f878/src/libraries/System.Private.CoreLib/src/System/Threading/Timer.cs#L211",
                                           "updatedAt":  "2023-06-07T00:41:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5eJ7eJ",
                                           "createdAt":  "2023-06-07T00:45:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "The resolution of the timers involved are by default ~16 ms, so a difference of 1 ms would not be sufficient to make any guarantees",
                                           "updatedAt":  "2023-06-07T00:45:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5eJ_DX",
                                           "createdAt":  "2023-06-07T00:57:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "Even if the timers were to be configured to have a 1 ms resolution, the timer tick could occur perhaps at most 1 ms earlier than requested.",
                                           "updatedAt":  "2023-06-07T00:57:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5eKAnS",
                                           "createdAt":  "2023-06-07T01:05:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "\u003e replacing this `\u003c=` with a `\u003c`\r\n\r\nThat would probably work if the relevant clocks are configured to have a 1 ms resolution to solve this issue, but otherwise in most other cases it may introduce cases where the timer thread wakes up and doesn\u0027t find any timers to fire due to the same change.",
                                           "updatedAt":  "2023-06-07T01:06:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc63IZPu",
                                           "createdAt":  "2025-07-15T07:34:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Heshyo",
                                           "body":  "Maybe linked to https://github.com/dotnet/runtime/issues/45585 ?",
                                           "updatedAt":  "2025-07-15T07:34:12Z"
                                       }
                                   ],
                         "totalCount":  15
                     },
        "title":  "Timer sometimes fires 1ms early",
        "labels":  [
                       "documentation",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/87974",
        "createdAt":  "2023-06-23T17:00:35Z",
        "number":  87974,
        "author":  "vsfeedback",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-06-26T04:37:17Z",
        "body":  "_This issue has been moved from [a ticket on Developer Community](https://developercommunity.visualstudio.com/t/learn:-how-to-implement-a-client-of-the-/10324907)._\n\n---\n[severity:It\u0027s more difficult to complete my work]\nUsing the code from:\n[learn: how to implement a client of the event based asynchronous pattern](https://learn.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/how-to-implement-a-client-of-the-event-based-asynchronous-pattern),\nI am getting a [platformnotsupportedexception](https://learn.microsoft.com/en-us/dotnet/api/system.platformnotsupportedexception?view=net-7.0) \n\n```\nSystem.PlatformNotSupportedException\n  HResult=0x80131539\n  Message=Operation is not supported on this platform.\n  Source=WinFormsApp1\n  StackTrace:\n   at AsyncPattern.PrimeNumberCalculator.WorkerEventHandler.BeginInvoke(Int32 numberToCheck, AsyncOperation asyncOp, AsyncCallback callback, Object object)\n   at AsyncPattern.PrimeNumberCalculator.CalculatePrimeAsync(Int32 numberToTest, Object taskId) in C:\\my\\learn\\cs\\learn\\components\\prime.number.calculator\\WinFormsApp1\\PrimeNumberCalculatorMain.cs:line 641\n   at AsyncPattern.PrimeNumberCalculatorMain.startAsyncButton_Click(Object sender, EventArgs e) in C:\\my\\learn\\cs\\learn\\components\\prime.number.calculator\\WinFormsApp1\\PrimeNumberCalculatorMain.cs:line 99\n   at System.Windows.Forms.Control.OnClick(EventArgs e)\n   at System.Windows.Forms.Button.OnClick(EventArgs e)\n   at System.Windows.Forms.Button.OnMouseUp(MouseEventArgs mevent)\n   at System.Windows.Forms.Control.WmMouseUp(Message\u0026 m, MouseButtons button, Int32 clicks)\n   at System.Windows.Forms.Control.WndProc(Message\u0026 m)\n   at System.Windows.Forms.ButtonBase.WndProc(Message\u0026 m)\n   at System.Windows.Forms.Button.WndProc(Message\u0026 m)\n   at System.Windows.Forms.Control.ControlNativeWindow.OnMessage(Message\u0026 m)\n   at System.Windows.Forms.Control.ControlNativeWindow.WndProc(Message\u0026 m)\n   at System.Windows.Forms.NativeWindow.Callback(IntPtr hWnd, WM msg, IntPtr wparam, IntPtr lparam)\n```\n\nat\n```\n// Start the asynchronous operation.\nWorkerEventHandler workerDelegate = new WorkerEventHandler( CalculateWorker );\nworkerDelegate.BeginInvoke(\n    numberToTest,\n    asyncOp,\n    null,\n    null );\n```\n\nwhen called from:\n```\nPrimeNumberCalculatorMain.startAsyncButton_Click( object, EventArgs)\n```\n\nThe project file looks like this:\n```\n  \n    WinExe\n    net6.0-windows\n    enable\n    true\n    enable\n  \n```\n\nAnd the main function is:\n```\n[STAThread]\nstatic void Main()\n{\n    ApplicationConfiguration.Initialize();\n    Application.Run( new PrimeNumberCalculatorMain() );\n}\n```\n\nMicrosoft Visual Studio Community 2022 (64-bit) - Version 17.5.3\n\n---\n### Original Comments\n\n#### Feedback Bot on 3/29/2023, 07:03 AM: \n\n(private comment, text removed)\n#### John Qiao [MSFT] on 3/30/2023, 03:30 AM: \n\n(private comment, text removed)\n#### David Hary on 3/30/2023, 06:32 AM: \n\n(private comment, text removed)\n#### Feedback Bot on 3/30/2023, 09:30 AM: \n\n(private comment, text removed)\n\n---\n### Original Solutions\n(no solutions)",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOX6Ovaw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5fo6vA",
                                           "createdAt":  "2023-06-23T17:02:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n_This issue has been moved from [a ticket on Developer Community](https://developercommunity.visualstudio.com/t/learn:-how-to-implement-a-client-of-the-/10324907)._\n\n---\n[severity:It\u0027s more difficult to complete my work]\nUsing the code from:\n[learn: how to implement a client of the event based asynchronous pattern](https://learn.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/how-to-implement-a-client-of-the-event-based-asynchronous-pattern),\nI am getting a [platformnotsupportedexception](https://learn.microsoft.com/en-us/dotnet/api/system.platformnotsupportedexception?view=net-7.0) \n\n```\nSystem.PlatformNotSupportedException\n  HResult=0x80131539\n  Message=Operation is not supported on this platform.\n  Source=WinFormsApp1\n  StackTrace:\n   at AsyncPattern.PrimeNumberCalculator.WorkerEventHandler.BeginInvoke(Int32 numberToCheck, AsyncOperation asyncOp, AsyncCallback callback, Object object)\n   at AsyncPattern.PrimeNumberCalculator.CalculatePrimeAsync(Int32 numberToTest, Object taskId) in C:\\my\\learn\\cs\\learn\\components\\prime.number.calculator\\WinFormsApp1\\PrimeNumberCalculatorMain.cs:line 641\n   at AsyncPattern.PrimeNumberCalculatorMain.startAsyncButton_Click(Object sender, EventArgs e) in C:\\my\\learn\\cs\\learn\\components\\prime.number.calculator\\WinFormsApp1\\PrimeNumberCalculatorMain.cs:line 99\n   at System.Windows.Forms.Control.OnClick(EventArgs e)\n   at System.Windows.Forms.Button.OnClick(EventArgs e)\n   at System.Windows.Forms.Button.OnMouseUp(MouseEventArgs mevent)\n   at System.Windows.Forms.Control.WmMouseUp(Message\u0026 m, MouseButtons button, Int32 clicks)\n   at System.Windows.Forms.Control.WndProc(Message\u0026 m)\n   at System.Windows.Forms.ButtonBase.WndProc(Message\u0026 m)\n   at System.Windows.Forms.Button.WndProc(Message\u0026 m)\n   at System.Windows.Forms.Control.ControlNativeWindow.OnMessage(Message\u0026 m)\n   at System.Windows.Forms.Control.ControlNativeWindow.WndProc(Message\u0026 m)\n   at System.Windows.Forms.NativeWindow.Callback(IntPtr hWnd, WM msg, IntPtr wparam, IntPtr lparam)\n```\n\nat\n```\n// Start the asynchronous operation.\nWorkerEventHandler workerDelegate = new WorkerEventHandler( CalculateWorker );\nworkerDelegate.BeginInvoke(\n    numberToTest,\n    asyncOp,\n    null,\n    null );\n```\n\nwhen called from:\n```\nPrimeNumberCalculatorMain.startAsyncButton_Click( object, EventArgs)\n```\n\nThe project file looks like this:\n```\n  \n    WinExe\n    net6.0-windows\n    enable\n    true\n    enable\n  \n```\n\nAnd the main function is:\n```\n[STAThread]\nstatic void Main()\n{\n    ApplicationConfiguration.Initialize();\n    Application.Run( new PrimeNumberCalculatorMain() );\n}\n```\n\nMicrosoft Visual Studio Community 2022 (64-bit) - Version 17.5.3\n\n---\n### Original Comments\n\n#### Feedback Bot on 3/29/2023, 07:03 AM: \n\n(private comment, text removed)\n#### John Qiao [MSFT] on 3/30/2023, 03:30 AM: \n\n(private comment, text removed)\n#### David Hary on 3/30/2023, 06:32 AM: \n\n(private comment, text removed)\n#### Feedback Bot on 3/30/2023, 09:30 AM: \n\n(private comment, text removed)\n\n---\n### Original Solutions\n(no solutions)\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003evsfeedback\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`, `needs-area-label`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-06-23T17:02:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5fo69r",
                                           "createdAt":  "2023-06-23T17:03:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "Comment from the user:\r\n\r\n\u003e Meanwhile, I implemented this using the Task-Based pattern.\r\nStill, it might help others if the learn topic could be either fixed, removed or the cause of the platform exception be elucidated.\r\nWould it make sense to add a note to the learning topic regarding this issue once confirmed.",
                                           "updatedAt":  "2023-06-23T17:03:36Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "learn: how to implement a client of the event based asynchronous pattern throws a platform not supported exception",
        "labels":  [
                       "documentation",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/88020",
        "createdAt":  "2023-06-25T16:50:10Z",
        "number":  88020,
        "author":  "dombrovsky",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-06-26T04:36:50Z",
        "body":  "### Background and motivation\n\nTo be able to easily use standard .NET event pattern in async/await flow.\r\n\r\nTask returned form Task.WaitForEventAsync will complete when event fired. Failed when `initializeFunc `failed. Cancelled when provided CancellationToken cancelled.\r\n\n\n### API Proposal\n\n```csharp\r\nnamespace System.Threading.Tasks;\r\n\r\npublic static Task WaitForEventAsync(Action\u003cEventHandler\u003e subscribe, Action\u003cEventHandler\u003e unsubscribe, Func\u003cCancellationToken, ValueTask\u003e initializeFunc, CancellationToken cancellationToken = default);\r\n\r\n/// \u003cparam name=\"initializeFunc\"\u003eFunction to be called immediately after subscribing to event.\u003c/param\u003e\r\n/// \u003cparam name=\"argFilter\"\u003ePredicate to specify in what state \u003ctypeparamref name=\"TArgs\"/\u003e must be for task to complete.\u003c/param\u003e\r\npublic static Task\u003cTArgs\u003e WaitForEventAsync\u003cTArgs\u003e(Action\u003cEventHandler\u003cTArgs\u003e\u003e subscribe, Action\u003cEventHandler\u003cTArgs\u003e\u003e unsubscribe, Func\u003cCancellationToken, ValueTask\u003e initializeFunc, Func\u003cTArgs, bool\u003e argFilter, CancellationToken cancellationToken = default) where TArgs : EventArgs;\r\n\r\n// overloads\r\npublic static Task WaitForEventAsync(Action\u003cEventHandler\u003e subscribe, Action\u003cEventHandler\u003e unsubscribe, CancellationToken cancellationToken = default);\r\npublic static Task\u003cTArgs\u003e WaitForEventAsync\u003cTArgs\u003e(Action\u003cEventHandler\u003cTArgs\u003e\u003e subscribe, Action\u003cEventHandler\u003cTArgs\u003e\u003e unsubscribe, CancellationToken cancellationToken = default);\r\npublic static Task\u003cTArgs\u003e WaitForEventAsync\u003cTArgs\u003e(Action\u003cEventHandler\u003cTArgs\u003e\u003e subscribe, Action\u003cEventHandler\u003cTArgs\u003e\u003e unsubscribe, Func\u003cTArgs, bool\u003e argFilter, CancellationToken cancellationToken = default);\r\npublic static Task\u003cTArgs\u003e WaitForEventAsync\u003cTArgs\u003e(Action\u003cEventHandler\u003cTArgs\u003e\u003e subscribe, Action\u003cEventHandler\u003cTArgs\u003e\u003e unsubscribe, Func\u003cCancellationToken, ValueTask\u003e initializeFunc, CancellationToken cancellationToken = default);\r\n```\r\n\n\n### API Usage\n\n```csharp\r\ninterface IFoo\r\n{\r\n    event EventHandler Initialized;\r\n\r\n    event EventHandler\u003cFooStatusEventArgs\u003e StatusChanged;\r\n}\r\n\r\nasync WaitForFooStatusFinishedAsync(IFoo foo, CancellationToken cancellationToken)\r\n{\r\n    await Task.WaitForEventAsync(\r\n        handler =\u003e foo.Initialized += handler,\r\n        handler =\u003e foo.Initialized -= handler,\r\n        cancellationToken)\r\n        .ConfigureAwait(false);\r\n\r\n    await Task.WaitForEventAsync\u003cFooStatusEventArgs\u003e(\r\n        handler =\u003e foo.StatusChanged += handler,\r\n        handler =\u003e foo.StatusChanged -= handler,\r\n        args =\u003e arg.Status = FooStatus.Finished,\r\n        cancellationToken)\r\n        .ConfigureAwait(false);\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n```\r\nTask.Factory.WaitForEventAsync\r\nTask.FromEvent\r\nTask.Factory.FromEvent\r\n```\n\n### Risks\n\nThe following pattern to loop and continuously wait for event may not work as intended, because it would miss event raised after previous task completed and new one subsribed:\r\n```csharp\r\nwhile (true)\r\n{\r\n    await Task.WaitForEventAsync\u003cFooStatusEventArgs\u003e(\r\n        handler =\u003e foo.StatusChanged += handler,\r\n        handler =\u003e foo.StatusChanged -= handler,\r\n        args =\u003e arg.Status = FooStatus.Finished,\r\n        cancellationToken)\r\n        .ConfigureAwait(false);\r\n\r\n    DoSomethingWhenStatusFinished();\r\n}\r\n```\r\nSo proposed approach may be suitable only for waiting for single event. For reacting to continuous stream of events it is better to use Rx library.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOX7wEXA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5fu_u-",
                                           "createdAt":  "2023-06-25T16:50:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nTo be able to easily use standard .NET event pattern in async/await flow.\r\n\r\nTask returned form Task.WaitForEventAsync will complete when event fired. Failed when `initializeFunc `failed. Cancelled when provided CancellationToken cancelled.\r\n\n\n### API Proposal\n\n```csharp\r\nnamespace System.Threading.Tasks;\r\n\r\npublic static Task WaitForEventAsync(Action\u003cEventHandler\u003e subscribe, Action\u003cEventHandler\u003e unsubscribe, Func\u003cCancellationToken, ValueTask\u003e initializeFunc, CancellationToken cancellationToken = default);\r\n\r\n/// \u003cparam name=\"initializeFunc\"\u003eFunction to be called immediately after subscribing to event.\u003c/param\u003e\r\n/// \u003cparam name=\"argFilter\"\u003ePredicate to specify in what state \u003ctypeparamref name=\"TArgs\"/\u003e must be for task to complete.\u003c/param\u003e\r\npublic static Task\u003cTArgs\u003e WaitForEventAsync\u003cTArgs\u003e(Action\u003cEventHandler\u003cTArgs\u003e\u003e subscribe, Action\u003cEventHandler\u003cTArgs\u003e\u003e unsubscribe, Func\u003cCancellationToken, ValueTask\u003e initializeFunc, Func\u003cTArgs, bool\u003e argFilter, CancellationToken cancellationToken = default) where TArgs : EventArgs;\r\n\r\n// overloads\r\npublic static Task WaitForEventAsync(Action\u003cEventHandler\u003e subscribe, Action\u003cEventHandler\u003e unsubscribe, CancellationToken cancellationToken = default);\r\npublic static Task\u003cTArgs\u003e WaitForEventAsync\u003cTArgs\u003e(Action\u003cEventHandler\u003cTArgs\u003e\u003e subscribe, Action\u003cEventHandler\u003cTArgs\u003e\u003e unsubscribe, CancellationToken cancellationToken = default);\r\npublic static Task\u003cTArgs\u003e WaitForEventAsync\u003cTArgs\u003e(Action\u003cEventHandler\u003cTArgs\u003e\u003e subscribe, Action\u003cEventHandler\u003cTArgs\u003e\u003e unsubscribe, Func\u003cTArgs, bool\u003e argFilter, CancellationToken cancellationToken = default);\r\npublic static Task\u003cTArgs\u003e WaitForEventAsync\u003cTArgs\u003e(Action\u003cEventHandler\u003cTArgs\u003e\u003e subscribe, Action\u003cEventHandler\u003cTArgs\u003e\u003e unsubscribe, Func\u003cCancellationToken, ValueTask\u003e initializeFunc, CancellationToken cancellationToken = default);\r\n```\r\n\n\n### API Usage\n\n```csharp\r\ninterface IFoo\r\n{\r\n    event EventHandler Initialized;\r\n\r\n    event EventHandler\u003cFooStatusEventArgs\u003e StatusChanged;\r\n}\r\n\r\nasync WaitForFooStatusFinishedAsync(IFoo foo, CancellationToken cancellationToken)\r\n{\r\n    await Task.WaitForEventAsync(\r\n        handler =\u003e foo.Initialized += handler,\r\n        handler =\u003e foo.Initialized -= handler,\r\n        cancellationToken)\r\n        .ConfigureAwait(false);\r\n\r\n    await Task.WaitForEventAsync\u003cFooStatusEventArgs\u003e(\r\n        handler =\u003e foo.StatusChanged += handler,\r\n        handler =\u003e foo.StatusChanged -= handler,\r\n        args =\u003e arg.Status = FooStatus.Finished,\r\n        cancellationToken)\r\n        .ConfigureAwait(false);\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n```\r\nTask.Factory.WaitForEventAsync\r\nTask.FromEvent\r\nTask.Factory.FromEvent\r\n```\n\n### Risks\n\nThe following pattern to loop and continuously wait for event may not work as intended, because it would miss event raised after previous task completed and new one subsribed:\r\n```csharp\r\nwhile (true)\r\n{\r\n    await Task.WaitForEventAsync\u003cFooStatusEventArgs\u003e(\r\n        handler =\u003e foo.StatusChanged += handler,\r\n        handler =\u003e foo.StatusChanged -= handler,\r\n        args =\u003e arg.Status = FooStatus.Finished,\r\n        cancellationToken)\r\n        .ConfigureAwait(false);\r\n\r\n    DoSomethingWhenStatusFinished();\r\n}\r\n```\r\nSo proposed approach may be suitable only for waiting for single event. For reacting to continuous stream of events it is better to use Rx library.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003edombrovsky\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-06-25T16:50:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5fvARc",
                                           "createdAt":  "2023-06-25T17:00:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODCJVlg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "huoyaoyuan",
                                                                               "createdAt":  "2023-06-26T05:42:42Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CooperMidnight",
                                                                               "createdAt":  "2023-07-29T01:14:22Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "Sergio0694",
                                           "body":  "Just a thought — this proposal reminds me of the `File.TryOpen`/`File.TryOpenAsync` proposals, which on paper sound great, but unfortunately there\u0027s basically no way to get them to have a method signature that doesn\u0027t feel extremely clunky to use, due to current language limitations. This feels the same: the concept is pretty common and the methods are definitely useful, but because C# today doesn\u0027t let you pass a reference to an event in any way, we end up having to use incredibly awkward workarounds like passing a series of callbacks to register/unregister (which also have their own downsides, ie. code bloat) 🥲",
                                           "updatedAt":  "2023-06-25T17:00:20Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[API Proposal]: Task.WaitForEventAsync",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/88403",
        "createdAt":  "2023-07-05T03:37:51Z",
        "number":  88403,
        "author":  "mavasani",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-03-12T23:15:26Z",
        "body":  "Issue #33774 was used to implement the rule [CA2016](https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca2016) (Forward the CancellationToken parameter to methods that take one), via PR https://github.com/dotnet/roslyn-analyzers/pull/3641. This rule flags invocations where cancellation token wasn\u0027t being passed, when one was available in the context of the invocation.\r\n\r\nI\u0027d like to propose either an extension to this rule or a new rule to detect when the wrong cancellation token is being passed, when multiple tokens are available in scope.\r\n\r\n1. Pattern 1: For example, an async method that takes a cancellation token parameter, say `ct1`, defines a lambda or a local function that takes another cancellation token parameter, say `ct2`, and an invocation within this lambda or local function uses `ct1` instead of `ct2`. This inevitably indicates a functional bug. We were bitten by this very recently in Roslyn - see https://github.com/dotnet/roslyn/pull/68859, and using the wrong cancellation token in a code fixer led to a very subtle, hard to diagnose bug.\r\n\r\n2. Pattern 2: Another pattern that we may want to consider to detect is when a type defines a field of type `CancellationToken` and also has an async method that takes a `CancellationToken` parameter, and an invocation within this method uses the cancellation token field instead of the parameter. This pattern may or may not indicate a bug, but still definitely indicates code smell and bad design - it should be recommended to either always have `CancellationToken` be a method parameter OR a field, but not both within the same type.\r\n\r\nProposed category: Reliability\r\nProposed severity: IDE suggestion\r\nCode fixer: Should be trivial to implement",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYJ4O-g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5gng76",
                                           "createdAt":  "2023-07-05T03:38:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nIssue #33774 was used to implement the rule [CA2016](https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca2016)(Forward the CancellationToken parameter to methods that take one), via PR https://github.com/dotnet/roslyn-analyzers/pull/3641. This rule flags invocations where cancellation token wasn\u0027t being passed, when one was available in the context of the invocation.\r\n\r\nI\u0027d like to propose either an extension to this rule or a new rule to detect when the wrong cancellation token is being passed. For example, an async method that takes a cancellation token parameter, say `ct1`, defines a lambda or a local function that takes another cancellation token parameter, say `ct2`, and an invocation within this lambda or local function uses `ct1` instead of `ct2`. This inevitably indicates a functional bug. We were bitten by this very recently in Roslyn - see https://github.com/dotnet/roslyn/pull/68859, and using the wrong cancellation token in a code fixer led a very subtle, hard to diagnose bug.\r\n\r\nAnother pattern that we may want to consider to detect is when a type defines a field of type `CancellationToken` and also has an async method that takes a `CancellationToken` parameter, and an invocation within this method uses the cancellation token field instead of the parameter. This pattern may or may not indicate a bug, but still definitely indicates code smell and bad design - it should be recommended to either always have `CancellationToken` be a method parameter OR a field, but not both within the same type.\r\n\r\nProposed category: Reliability\r\nProposed severity: IDE suggestion\r\nCode fixer: Should be trivial to implement\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003emavasani\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `feature-request`, `code-analyzer`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-07-05T03:38:00Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Analyzer proposal: Detect wrong CancellationToken being used when multiple tokens are available in scope",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading",
                       "feature-request",
                       "code-analyzer"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/88434",
        "createdAt":  "2023-07-05T18:23:04Z",
        "number":  88434,
        "author":  "JoeMarkov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-07-19T19:02:28Z",
        "body":  "### Description\r\n\r\n\r\nI am currently writing some training exercises for the Task CancellationToken feature in .NET 7, all is well except for one thing that puzzles me.\r\nThe proper  way to use Task.Run with a CancellationToken Is to do the following:\r\n```\r\nvar cts = new CancellationTokenSource(5000); \r\nvar token = cts.Token;\r\n\r\nt1 = Task.Run(() =\u003e \r\n{ \r\n    while (true) \r\n    { \r\n        Console.WriteLine(\"Working...\"); \r\n        Thread.Sleep(500); \r\n        token.ThrowIfCancellationRequested(); \r\n    } \r\n}, token);\r\n\r\n```\r\nPassing the token to the Lambda and as a parameter to the task run method.\r\n\r\nBut, I want to trigger the other behavior, what happens when you forget to pass the token to the run method, ie:\r\n```\r\nt1 = Task.Run(() =\u003e \r\n{ \r\n    while (true) \r\n    { \r\n        Console.WriteLine(\"Working...\"); \r\n        Thread.Sleep(500); \r\n        token.ThrowIfCancellationRequested(); \r\n    } \r\n} /*, token*/ );\r\n```\r\n\r\nYou then expect the task to have these properties:\r\n\r\n```\r\nTask.Status Faulted\r\nTask.IsCanceled False\r\nTask.IsFaulted True\r\n```\r\n\r\nBut, I do get back that it is canceled\r\n\r\n```\r\nTask.Status Canceled\r\nTask.IsCanceled True\r\nTask.IsFaulted False\r\n```\r\nNot what I expect when I don’t call the Run method with the cancellation token as a parameter.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Reproduction Steps\r\n\r\nThe following code snippet will return the task as cancelled (No token to the Run method).\r\n\r\n```\r\nvar cts = new CancellationTokenSource(5000);\r\nvar token = cts.Token;\r\n\r\nTask t1 = null;\r\n\r\n\r\nt1 = Task.Run(() =\u003e\r\n{\r\n\twhile (true)\r\n\t{\r\n\t\tConsole.WriteLine(\"Working...\");\r\n\t\tThread.Sleep(500);\r\n\t\ttoken.ThrowIfCancellationRequested();\r\n\t}\r\n});\r\n\r\ntry\r\n{\r\n\tt1.Wait();\r\n}\r\ncatch (Exception ex)\r\n{\r\n\tConsole.WriteLine(ex);\r\n\r\n\tConsole.WriteLine(\"Task.Status \" + t1.Status);\r\n\tConsole.WriteLine(\"Task.IsCanceled \" + t1.IsCanceled);\r\n\tConsole.WriteLine(\"Task.IsFaulted \" + t1.IsFaulted);\r\n\r\n}\r\n\r\nConsole.WriteLine(\"Press a key to cancel\");\r\nConsole.ReadKey();\r\n```\r\n\r\n\r\n### Expected behavior\r\n\r\nI expect the code to return faulted\r\n\r\n```\r\nTask.Status Faulted\r\nTask.IsCanceled False\r\nTask.IsFaulted True\r\nPress a key to cancel\r\n```\r\n\r\nBut it does not!\r\n\r\n\r\n### Actual behavior\r\n\r\nSo, what I eventually figured out is if the Task.Run lambda contains a **return** statement, then it works;\r\n\r\n\r\nso, this method returns faulted:\r\n\r\n```\r\nt1 = Task.Run(() =\u003e\r\n{\r\n\twhile (true)\r\n\t{\r\n\t\tConsole.WriteLine(\"Working...\");\r\n\t\tThread.Sleep(500);\r\n\t\ttoken.ThrowIfCancellationRequested();\r\n\t}\r\n\r\n\t**return;**\r\n});\r\n```\r\n\r\nwhile this method return task cancelled: (no return in the lambda).\r\n\r\n```\r\nt1 = Task.Run(() =\u003e\r\n{\r\n\twhile (true)\r\n\t{\r\n\t\tConsole.WriteLine(\"Working...\");\r\n\t\tThread.Sleep(500);\r\n\t\ttoken.ThrowIfCancellationRequested();\r\n\t}\r\n});\r\n```\r\n\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\n```\r\nC:\\\u003edotnet --list-sdks\r\n7.0.304 [C:\\Program Files\\dotnet\\sdk]\r\n7.0.305 [C:\\Program Files\\dotnet\\sdk]\r\n7.0.400-preview.23274.1 [C:\\Program Files\\dotnet\\sdk]\r\n```\r\n\r\nMicrosoft.NETCore.App 7.0.8 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n\r\n### Other information\r\n\r\nSo, just so confused, to why adding an empty return statement inside the Task.Run lambda, results in a different task state.\r\n\r\n\r\nI am working on some training material, to show the importance of adding the token to the run method, but being able to trigger the differences properly has been a struggle. \r\n\r\nThe core is, why:\r\n\r\n```\r\nt1 = Task.Run(() =\u003e\r\n{\r\n\twhile (true)\r\n\t{\r\n\t\tThread.Sleep(500);\r\n\t\ttoken.ThrowIfCancellationRequested();\r\n\t}\r\n     \r\n  /* return; */\r\n});\r\n```\r\n\r\nwith and without a return statement at the end results in that the task after the cancellation is either Faulted or Cancelled. \r\n\r\nPerhaps the documentation could be clarified if this is actually by design.\r\n\r\nI want to trigger what the documentation says here:\r\nhttps://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/task-cancellation\r\n\r\n_If the token\u0027s [IsCancellationRequested](https://learn.microsoft.com/en-us/dotnet/api/system.threading.cancellationtoken.iscancellationrequested) property returns false or if the exception\u0027s token doesn\u0027t match the Task\u0027s token, the [OperationCanceledException](https://learn.microsoft.com/en-us/dotnet/api/system.operationcanceledexception) is treated like a normal exception, causing the Task to transition to the Faulted state._\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYMBSvg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5gsbiD",
                                           "createdAt":  "2023-07-05T18:23:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\n\r\nI am currently writing some training exercises for the Task CancellationToken feature in .NET 7, all is well except for one thing that puzzles me.\r\nThe proper  way to use Task.Run with a CancellationToken Is to do the following:\r\nvar cts = new CancellationTokenSource(5000); \r\nvar token = cts.Token;\r\n\r\nt1 = Task.Run(() =\u003e \r\n{ \r\n    while (true) \r\n    { \r\n        Console.WriteLine(\"Working...\"); \r\n        Thread.Sleep(500); \r\n        token.ThrowIfCancellationRequested(); \r\n    } \r\n}, token);\r\n\r\nPassing the token both to the Lambda and as a parameter to task run.\r\n\r\nBut, I want to trigger is the other behavior, what happens when you forget to pass the token to the run method, ie:\r\nt1 = Task.Run(() =\u003e \r\n{ \r\n    while (true) \r\n    { \r\n        Console.WriteLine(\"Working...\"); \r\n        Thread.Sleep(500); \r\n        token.ThrowIfCancellationRequested(); \r\n    } \r\n} /*, token*/ );\r\n\r\nYou then expect the task to have these properties:\r\n\r\nTask.Status Faulted\r\nTask.IsCanceled False\r\nTask.IsFaulted True\r\n\r\nBut, I do get back that it is canceled\r\n\r\nTask.Status Canceled\r\nTask.IsCanceled True\r\nTask.IsFaulted False\r\nNot what I expect when I don’t call the Run method with the cancellation token as a parameter.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n### Reproduction Steps\n\nThe following code snippet will return the task as cancelled (No token to the Run method).\r\n\r\nvar cts = new CancellationTokenSource(5000);\r\nvar token = cts.Token;\r\n\r\nTask t1 = null;\r\n\r\n\r\nt1 = Task.Run(() =\u003e\r\n{\r\n\twhile (true)\r\n\t{\r\n\t\tConsole.WriteLine(\"Working...\");\r\n\t\tThread.Sleep(500);\r\n\t\ttoken.ThrowIfCancellationRequested();\r\n\t}\r\n});\r\n\r\ntry\r\n{\r\n\tt1.Wait();\r\n}\r\ncatch (Exception ex)\r\n{\r\n\tConsole.WriteLine(ex);\r\n\r\n\tConsole.WriteLine(\"Task.Status \" + t1.Status);\r\n\tConsole.WriteLine(\"Task.IsCanceled \" + t1.IsCanceled);\r\n\tConsole.WriteLine(\"Task.IsFaulted \" + t1.IsFaulted);\r\n\r\n}\r\n\r\nConsole.WriteLine(\"Press a key to cancel\");\r\nConsole.ReadKey();\r\n\n\n### Expected behavior\n\nI expect the code to return faulted\r\n\r\nTask.Status Faulted\r\nTask.IsCanceled False\r\nTask.IsFaulted True\r\nPress a key to cancel\r\n\r\nBut it does not!\r\n\n\n### Actual behavior\n\nSo, what eventually figured out is if the Task.Run lambda contains a return statement;, then it works;:\r\n\r\n\r\nso, this method returns faulted:\r\n\r\nt1 = Task.Run(() =\u003e\r\n{\r\n\twhile (true)\r\n\t{\r\n\t\tConsole.WriteLine(\"Working...\");\r\n\t\tThread.Sleep(500);\r\n\t\ttoken.ThrowIfCancellationRequested();\r\n\t}\r\n\r\n\t**return;**\r\n});\r\n\r\nwhile this method return cancelled: (no return in the lambda).\r\n\r\nt1 = Task.Run(() =\u003e\r\n{\r\n\twhile (true)\r\n\t{\r\n\t\tConsole.WriteLine(\"Working...\");\r\n\t\tThread.Sleep(500);\r\n\t\ttoken.ThrowIfCancellationRequested();\r\n\t}\r\n});\r\n\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\nC:\\\u003edotnet --list-sdks\r\n7.0.304 [C:\\Program Files\\dotnet\\sdk]\r\n7.0.305 [C:\\Program Files\\dotnet\\sdk]\r\n7.0.400-preview.23274.1 [C:\\Program Files\\dotnet\\sdk]\r\n\r\nMicrosoft.NETCore.App 7.0.8 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\n\n### Other information\n\nSo, just so confused, to why adding an empty return statement inside the Task.Run lambda, results in a different task state.\r\n\r\n\r\nI am working on some training material, to show the importance of adding the token to the run method, but being able to trigger the differences properly has been a struggle. \r\n\r\nThe core is, why:\r\n\r\nt1 = Task.Run(() =\u003e\r\n{\r\n\twhile (true)\r\n\t{\r\n\t\tThread.Sleep(500);\r\n\t\ttoken.ThrowIfCancellationRequested();\r\n\t}\r\n     \r\n  /* return; */\r\n});\r\n\r\nwith and without a return statement at the end results in that the task after the cancellation is either Faulted or Cancelled. \r\n\r\nPerhaps the documentation could be clarified if this is actually by design.\r\n\r\nI want to trigger what the documentation says here:\r\nhttps://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/task-cancellation\r\n\r\n_If the token\u0027s [IsCancellationRequested](https://learn.microsoft.com/en-us/dotnet/api/system.threading.cancellationtoken.iscancellationrequested) property returns false or if the exception\u0027s token doesn\u0027t match the Task\u0027s token, the [OperationCanceledException](https://learn.microsoft.com/en-us/dotnet/api/system.operationcanceledexception) is treated like a normal exception, causing the Task to transition to the Faulted state._\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eJoeMarkov\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-07-05T18:23:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5gsdPm",
                                           "createdAt":  "2023-07-05T18:28:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC_7eXA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "JoeMarkov",
                                                                               "createdAt":  "2023-07-05T19:19:59Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e why adding an empty return statement inside the Task.Run lambda, results in a different task state\r\n\r\nBecause it changes which overload of Task.Run you\u0027re binding to.  Hover over Run in VS to see which overload is being called, and you\u0027ll see it change between `Func\u003cTask\u003e` and `Action` based on whether that `return;` is there.\r\n\r\nThe `Func\u003cTask\u003e`-based overload is then adopting async method semantics, where any OperationCanceledException is treated as Canceled. In contrast, the Action-based overload will only treat an OperationCanceledException as Canceled if the contained token matches the one supplied.",
                                           "updatedAt":  "2023-07-05T18:28:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5gstJu",
                                           "createdAt":  "2023-07-05T19:19:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "JoeMarkov",
                                           "body":  "Thanks for your answer, if it is by design, then you can close this issue.",
                                           "updatedAt":  "2023-07-05T19:19:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5gswjH",
                                           "createdAt":  "2023-07-05T19:27:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "JoeMarkov",
                                           "body":  "Perhaps the subtle differences between Func\u003cTask\u003e and Action in Task.Run could be highlighted somewhere? As the differences are a bit \"subtle and unexpected\" and hard to figure out when you are dealing with cancellationtokens :-) You would expect the cod to behave the same :-)",
                                           "updatedAt":  "2023-07-05T19:27:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5gs6jc",
                                           "createdAt":  "2023-07-05T19:42:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "Would you like to offer a PR tweaking the docs? (Just click pencil icon on the doc page)",
                                           "updatedAt":  "2023-07-05T19:42:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5gwFK-",
                                           "createdAt":  "2023-07-06T08:30:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "JoeMarkov",
                                           "body":  "@danmoseley Sorry, doubt I would be qualified to write a correct explanation on this issue :-)",
                                           "updatedAt":  "2023-07-06T08:30:36Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "Wierd Task cancellation token behavior",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/88592",
        "createdAt":  "2023-07-10T06:51:39Z",
        "number":  88592,
        "author":  "kamilslusarczyk",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODGgnsw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "cristipufu",
                                            "createdAt":  "2023-09-01T10:11:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "altso",
                                            "createdAt":  "2025-07-10T14:31:45Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2023-07-24T17:48:48Z",
        "body":  "### Background and motivation\r\n\r\nDue to multiple cases of thread pool exhaustion when using `RateLimiter.GetStatistics` with Redis backplane (related to hanging `Redis` commands) we need to introduce asynchronous version of this method.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\npublic abstract class RateLimiter : IAsyncDisposable, IDisposable\r\n{\r\n...\r\n   public abstract ValueTask\u003cRateLimiterStatistics?\u003e GetStatisticsAsync()\r\n...\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\nvar globalLimiter = options.Value.GlobalLimiter;\r\nstatistics = await globalLimiter?.GetStatisticsAsync(context);\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYQ6hWQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5hDpsX",
                                           "createdAt":  "2023-07-10T06:51:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nDue to multiple cases of thread pool exhaustion when using `RateLimiter.GetStatistics` (related to hanging `Redis` commands) we need to introduce asynchronous version of this method.\n\n### API Proposal\n\n```csharp\r\npublic abstract class RateLimiter : IAsyncDisposable, IDisposable\r\n{\r\n...\r\n   public abstract ValueTask\u003cRateLimiterStatistics?\u003e GetStatisticsAsync()\r\n...\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nvar globalLimiter = options.Value.GlobalLimiter;\r\nstatistics = await globalLimiter?.GetStatisticsAsync(context);\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ekamilslusarczyk\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-07-10T06:51:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5hDqFZ",
                                           "createdAt":  "2023-07-10T06:53:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODAN8sg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "cristipufu",
                                                                               "createdAt":  "2023-07-10T07:09:42Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "kamilslusarczyk",
                                           "body":  "Tagging @cristipufu.",
                                           "updatedAt":  "2023-07-10T06:53:10Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[API Proposal]: Introduce asynchronous version of RateLimiter.GetStatistics",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/89669",
        "createdAt":  "2023-07-29T12:08:17Z",
        "number":  89669,
        "author":  "Khhs167",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-08-14T19:45:50Z",
        "body":  "Hello!\r\n\r\nI am currently working on a game in C#.\r\n\r\nIn this game, I(like most games) need to measure frame delta. Issue is: there\u0027s no way for me to reliably do that.\r\n\r\nMy method of measuring frame delta is via a stopwatch being reset at the start of a frame, and then I get the elapsed milliseconds, to calculate how long last frame took, which works good enough.\r\n\r\nBut, whenever I hit a breakpoint, or I pause the program, this stopwatch keeps on going, and going, and going, making the frame delta huge, and causing lag, or in the worst case scenario: a crash due to the amount of stuff the game needs to catch up on.\r\n\r\nSo, how could we solve this?\r\n\r\nMy idea is that we add a timer thread to .net that keeps track of program-relative time. It pauses whenever the debugger pauses, and resumes whenever the debugger resumes. This way, timers(and other program components) could sync to this timer instead, hence pausing the timers whenever the program itself pauses.\r\n\r\n\r\nThe main issue with this solution is that programs that use stopwatches/some other timer function to reliably measure real-world time could break, as they expect these timers to not pause on debugging.\r\n\r\nThe solution is however very simple: Either a compiler flag, or a property on the stopwatches etc(I\u0027m thinking something like, `RealTime`), or both. In the case of both, the compiler flag could set the default value of the aforementioned `RealTime` property.\r\n\r\nHope I put this in the right place!",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYtnZ1w==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5iv5aM",
                                           "createdAt":  "2023-07-29T12:48:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nHello!\r\n\r\nI am currently working on a game in C#.\r\n\r\nIn this game, I(like most games) need to measure frame delta. Issue is: there\u0027s no way for me to reliably do that.\r\n\r\nMy method of measuring frame delta is via a stopwatch being reset at the start of a frame, and then I get the elapsed milliseconds, to calculate how long last frame took, which works good enough.\r\n\r\nBut, whenever I hit a breakpoint, or I pause the program, this stopwatch keeps on going, and going, and going, making the frame delta huge, and causing lag, or in the worst case scenario: a crash due to the amount of stuff the game needs to catch up on.\r\n\r\nSo, how could we solve this?\r\n\r\nMy idea is that we add a timer thread to .net that keeps track of program-relative time. It pauses whenever the debugger pauses, and resumes whenever the debugger resumes. This way, timers(and other program components) could sync to this timer instead, hence pausing the timers whenever the program itself pauses.\r\n\r\n\r\nThe main issue with this solution is that programs that use stopwatches/some other timer function to reliably measure real-world time could break, as they expect these timers to not pause on debugging.\r\n\r\nThe solution is however very simple: Either a compiler flag, or a property on the stopwatches etc(I\u0027m thinking something like, `RealTime`), or both. In the case of both, the compiler flag could set the default value of the aforementioned `RealTime` property.\r\n\r\nHope I put this in the right place!\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eKhhs167\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-07-29T12:48:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iv_H6",
                                           "createdAt":  "2023-07-29T14:48:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e So, how could we solve this?\r\n\r\nThere are many reasons why the time between frames could spike and appear higher than normal and they aren\u0027t limited to just the debugger. They can also appear due to other expensive programs running in the background, unexpected latency/lag, etc.\r\n\r\nA fairly standard way to solve this more generally is to provide a cap for your maximum delta time. Unity provides this via https://docs.unity3d.com/ScriptReference/Time-maximumDeltaTime.html. Xna provided a similar feature, as does the mini engine used by the official DirectX samples repo: https://github.com/microsoft/DirectX-Graphics-Samples/blob/master/Samples/Desktop/D3D12Multithreading/src/StepTimer.h#L92-L96 if you want some MIT licensed reference.\r\n\r\nProviding such functionality can help handle any kind of larger than expected delta times and ultimately make your app more robust.\r\n\r\n",
                                           "updatedAt":  "2023-07-29T14:48:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5i2dnX",
                                           "createdAt":  "2023-07-31T14:07:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AirmanAJK",
                                           "body":  "The standard practice is to just never let the timer go above a certain threshold. That\u0027s why demanding games running on an under-powered computer will appear to move in slow motion, even in modern game engines. If your game requires high-precision or deterministic physics the delta should be fixed at an exact framerate (often the refresh rate of the display). If variable deltas are acceptable you should cap it (usually with something at or higher than the display\u0027s refresh rate).\r\n\r\nGlitches related to this have always been around. Such as rapidly pausing and unpausing in racing games to manipulate the acceleration. Tricks to gain more enemy hits are also used by manipulating refresh rates during certain battles.\r\n\r\nYou, nor .NET, will be able to mark timestamps of when threads have context switches as that\u0027s managed by the OS and your code, by definition, can\u0027t execute anything with the needed precision to track those events. Anything you implement will need to be at the application level.",
                                           "updatedAt":  "2023-07-31T14:07:19Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Pause timers on debug pause",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/90866",
        "createdAt":  "2023-08-21T02:05:41Z",
        "number":  90866,
        "author":  "fbrosseau",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCyFWBQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "poizan42",
                                            "createdAt":  "2023-08-21T18:52:25Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "NN---",
                                            "createdAt":  "2023-08-21T19:55:35Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2024-07-03T21:16:25Z",
        "body":  "Hello,\r\n\r\nA known limitation and significant design choice in Windows is the hardcoded limit of 64 (MAXIMUM_WAIT_OBJECTS) waitable objects in all kernel wait primitives (WaitForMultipleObjects and all derivatives). This limitation will never change. Waitable objects include events/semaphores obviously, but also processes, threads, and more. \r\n\r\nWhat ends up happening is that people who need to wait on very-many, or unbounded, number of waitable objects will shard wait requests into batches of 64 and have 1 thread per batch. This is exactly the implementation of dotnet\u0027s PortableThreadPool today. This technically scales infinitely, but one thread per 64 can end up meaning a lot, plus the fact every single register/unregister operation needs to wake up the WaiterThread so that it updates its wait list. \r\n\r\nOne little-known gem of Windows 8 is that the kernel finally makes this truly scalable by adding the ability for registered waits to directly post a packet to a given IOCP, removing the need to have _any thread at all_. This is how CreateThreadpoolWait is implemented as of Win8+.\r\n\r\nApplied to dotnet, because CreateThreadpoolWait implicitly binds the wait to the win32 threadpool\u0027s own IOCP, this means you would still need a tiny hoop between the Win32 threadpool callback, back into the dotnet threadpool, but this is still a clear improvement over having a custom pool of waiter threads that constantly need to be woken up to adjust their wait list. \r\n\r\nConsidering AOT already has a formal implementation that uses CreateThreadpoolWait, it sounds like reusing that code in all cases for Windows should not increase the overall code complexity?\r\n\r\nSidenote1: Richter\u0027s book says CreateThreadpoolWait simply delegates to a pool of threads that wait for 64 items - this was true as of the publishing of that book (vista and win7), but is no longer true today. Windows Internals 7ed briefly confirms this new improvement in the threadpool chapter. \r\n\r\nSidenote2: technically, the Win32 threadpool could be bypassed and registered waits could post directly to dotnet\u0027s own IOCP, making this even more efficient, but the relevant NT apis are undocumented and there is no Win32 API for this feature, other than CreateThreadPoolWait which forces you to have a jump through the Win32 pool. \r\n\r\nSidenote3: I am not breaking news about internal APIs (NtAssociateWaitCompletionPacket and all) here - you will find similar interest online for this feature from the `tokio` folks, `golang` folks, etc. There have also been public requests to the OS team to document the few NT APIs about this, which were denied, but I think the requests might not have fallen upon the right ears. Could this usecase justify asking OS team to document and/or add Win32 API? Even if not, I would still guesstimate that the Win32 threadpool jump still is better than the current custom implementation. \r\n\r\nSidenote4: even legacy RegisterWaitForSingleObject benefits from this, but if you are going to wait multiple times in a row CreateThreadpoolWait amortizes the setup cost. \r\n\r\nTagging @eduardo-vp since I saw that they made Win32 versus portable threadpool changes in recent history.\r\n\r\nThanks!",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOZHbUvg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5kdtS-",
                                           "createdAt":  "2023-08-21T02:05:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nHello,\r\n\r\nA known limitation and significant design choice in Windows is the hardcoded limit of 64 (MAXIMUM_WAIT_OBJECTS) waitable objects in all kernel wait primitives (WaitForMultipleObjects and all derivatives). This limitation will never change. Waitable objects include events/semaphores obviously, but also processes, threads, and more. \r\n\r\nWhat ends up happening is that people who need to wait on very-many, or unbounded, number of waitable objects will shard wait requests into batches of 64 and have 1 thread per batch. This is exactly the implementation of dotnet\u0027s PortableThreadPool today. This technically scales infinitely, but one thread per 64 can end up meaning a lot, plus the fact every single register/unregister operation needs to wake up the WaiterThread so that it updates its wait list. \r\n\r\nOne little-known gem of Windows 8 is that the kernel finally makes this truly scalable by adding the ability for registered waits to directly post a packet to a given IOCP, removing the need to have _any thread at all_. This is how CreateThreadpoolWait is implemented as of Win8+.\r\n\r\nApplied to dotnet, because CreateThreadpoolWait implicitly binds the wait to the win32 threadpool\u0027s own IOCP, this means you would still need a tiny hoop between the Win32 threadpool callback, back into the dotnet threadpool, but this is still a clear improvement over having a custom pool of waiter threads that constantly need to be woken up to adjust their wait list. \r\n\r\nConsidering AOT already has a formal implementation that uses CreateThreadpoolWait, it sounds like reusing that code in all cases for Windows should not increase the overall code complexity?\r\n\r\nSidenote1: Richter\u0027s book says CreateThreadpoolWait simply delegates to a pool of threads that wait for 64 items - this was true as of the publishing of that book (vista and win7), but is no longer true today. Windows Internals 7ed briefly confirms this new improvement in the threadpool chapter. \r\n\r\nSidenote2: technically, the Win32 threadpool could be bypassed and registered waits could post directly to dotnet\u0027s own IOCP, making this even more efficient, but the relevant NT apis are undocumented and there is no Win32 API for this feature, other than CreateThreadPoolWait which forces you to have a jump through the Win32 pool. \r\n\r\nSidenote3: I am not breaking news about internal APIs (NtAssociateWaitCompletionPacket and all) here - you will find similar interest online for this feature from the `tokio` folks, `golang` folks, etc. There have also been public requests to the OS team to document the few NT APIs about this, which were denied, but I think the requests might not have fallen upon the right ears. Could this usecase justify asking OS team to document and/or add Win32 API? Even if not, I would still guesstimate that the Win32 threadpool jump still is better than the current custom implementation. \r\n\r\nSidenote4: even legacy RegisterWaitForSingleObject benefits from this, but if you are going to wait multiple times in a row CreateThreadpoolWait amortizes the setup cost. \r\n\r\nTagging @eduardo-vp since I saw that they made Win32 versus portable threadpool changes in recent history.\r\n\r\nThanks!\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003efbrosseau\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `tenet-performance`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-08-21T02:05:53Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Should RegisteredWaitHandle always use Win32 TP?",
        "labels":  [
                       "area-System.Threading",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/91005",
        "createdAt":  "2023-08-23T18:03:01Z",
        "number":  91005,
        "author":  "scalablecory",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC1s2Ng==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Lightczx",
                                            "createdAt":  "2023-08-24T02:40:36Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "divyeshio",
                                            "createdAt":  "2024-02-07T07:25:06Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2023-08-31T19:00:44Z",
        "body":  "### Background and motivation\r\n\r\nI frequently find my use of PeriodicTimer to look something like:\r\n\r\n```c#\r\nasync Task RunPeriodicTimer(CancellationToken token)\r\n{\r\n    using PeriodicTimer timer = new(period: TimeSpan.FromSeconds(1));\r\n    using CancellationTokenRegistration reg = token.UnsafeRegister(static o =\u003e ((PeriodicTimer)o!).Dispose(), timer);\r\n\r\n    while(await timer.WaitForNextTickAsync())\r\n    {\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\nI wonder if a constructor to build a cancellable `PeriodicTimer` would be useful to others.\r\n\r\n### API Proposal\r\n\r\n```diff\r\nnamespace System.Threading;\r\n\r\npublic class PeriodicTimer\r\n{\r\n     public PeriodicTimer(TimeSpan period);\r\n+    public PeriodicTimer(TimeSpan period, CancellationToken cancellationToken);\r\n     public PeriodicTimer(TimeSpan period, TimeProvider timeProvider);\r\n+    public PeriodicTimer(TimeSpan period, TimeProvider timeProvider, CancellationToken cancellationToken);\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```c#\r\nasync Task RunPeriodicTimer(CancellationToken token)\r\n{\r\n    using PeriodicTimer timer = new(TimeSpan.FromSeconds(1), token);\r\n\r\n    while(await timer.WaitForNextTickAsync())\r\n    {\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\nUpon cancellation, `WaitForNextTickAsync()` will behave as if `Dispose()` has been called, still returning `false` rather than throwing.\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOZMGBhA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5kwYGE",
                                           "createdAt":  "2023-08-23T18:03:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nI frequently find my use of PeriodicTimer to look something like:\r\n\r\n```c#\r\nasync Task RunPeriodicTimer(CancellationToken token)\r\n{\r\n    using PeriodicTimer timer = new(period: TimeSpan.FromSeconds(1));\r\n    using CancellationTokenRegistration reg = token.UnsafeRegister(static o =\u003e ((PeriodicTimer)o!).Dispose(), timer);\r\n\r\n    while(await timer.WaitForNextTickAsync())\r\n    {\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\nI wonder if a constructor to build a cancellable `PeriodicTimer` would be useful to others.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Threading;\r\n\r\npublic class PeriodicTimer\r\n{\r\n    public PeriodicTimer(TimeSpan period, CancellationToken cancellationToken);\r\n    public PeriodicTimer(TimeSpan period, TimeProvider timeProvider, CancellationToken cancellationToken);\r\n}\r\n```\r\n\n\n### API Usage\n\n```c#\r\nasync Task RunPeriodicTimer(CancellationToken token)\r\n{\r\n    using PeriodicTimer timer = new(TimeSpan.FromSeconds(1), token);\r\n\r\n    while(await timer.WaitForNextTickAsync())\r\n    {\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\nUpon cancellation, `WaitForNextTickAsync()` will behave as if `Dispose()` has been called, still returning `false` rather than throwing.\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003escalablecory\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-08-23T18:03:10Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "[API Proposal]: PeriodicTimer with CancellationToken support",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/91147",
        "createdAt":  "2023-08-25T23:07:15Z",
        "number":  91147,
        "author":  "kouvel",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-07T17:55:10Z",
        "body":  "- By default, named synchronization objects (mutexes, semaphores, and events) are usable by multiple users. This could be problematic on systems where untrusted users may run code.\r\n- It would be useful to provide support for named synchronization objects that are restricted to the user that created the synchronization object. For instance, in scenarios where the user would like to protect with a mutex a user-specific resource. Such scenarios already exist and are likely common. On Windows, there are Windows-specific APIs that can be used, but the code would not be portable, and on Unixes there is no alternative. This could be done in various ways, like a new prefix in the name, new API, etc., in a way that works on all OSes.\r\n- On Unixes, only named mutexes are supported, so providing a user-specific named mutex would be sufficient",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOZRsiqA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5k-LND",
                                           "createdAt":  "2023-08-25T23:07:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n- By default, named synchronization objects (mutexes, semaphores, and events) are usable by multiple users. This could be problematic on systems where untrusted users may run code.\r\n- It would be useful to provide support for named synchronization objects that are restricted to the user that created the synchronization object. For instance, in scenarios where the user would like to protect with a mutex a user-specific resource. Such scenarios already exist and are likely common. On Windows, there are Windows-specific APIs that can be used, but the code would not be portable, and on Unixes there is no alternative. This could be done in various ways, like a new prefix in the name, new API, etc., in a way that works on all OSes.\r\n- On Unixes, only named mutexes are supported, so providing a user-specific named mutex would be sufficient\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ekouvel\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003ekouvel\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e9.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-08-25T23:07:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5lA2pg",
                                           "createdAt":  "2023-08-27T17:38:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODFCoqw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kouvel",
                                                                               "createdAt":  "2023-08-28T19:42:11Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "fbrosseau",
                                           "body":  "in netcore, named pipes added the `PipeOptions.CurrentUserOnly` for this purpose (in replacement of netfx having the nightmarish full API for setting up ACLs). CurrentUserOnly is high-level enough that it allows the runtime to implement this concept the best way possible for each platform.\r\n\r\nIf I use named kernel objects, I would not be expecting the runtime to customize my name in any way (at least on Windows). The other program using my object may very well not be dotnet code. So at least for Windows, I would expect the implementation to just be setting up ACLs on my behalf.",
                                           "updatedAt":  "2023-08-27T17:38:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5lGyKo",
                                           "createdAt":  "2023-08-28T19:42:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "\u003e If I use named kernel objects, I would not be expecting the runtime to customize my name in any way (at least on Windows). The other program using my object may very well not be dotnet code. So at least for Windows, I would expect the implementation to just be setting up ACLs on my behalf.\r\n\r\nThat\u0027s what I was thinking as well. Adding something like `PipeOptions.CurrentUserOnly` would work too, regarding adding a new prefix to the name, I intended for it to just be a way of conveying that it is to be restricted to the creating user, the prefix doesn\u0027t have to actually be in the underlying name. Another possibility is to add some user prefix to the real name of the named mutex (in a clearly documented way) to help give those a somewhat different namespace, but that\u0027s probably not too important, and it complicates opening an existing user-specific mutex that doesn\u0027t have the prefix.\r\n\r\nI think a new API approach may be better, as it would help to incentivize people to use user-specific named mutexes where possible (along with having a warning for all-user named mutexes), and it may even be possible in the future to deprecate the current APIs in favor of the one with an enum.",
                                           "updatedAt":  "2023-08-29T17:38:20Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Add support for named synchronization objects that are restricted to the creating user (where applicable)",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/91165",
        "createdAt":  "2023-08-27T00:12:13Z",
        "number":  91165,
        "author":  "PJB3005",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC4odNw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "gkarabin",
                                            "createdAt":  "2024-06-14T12:23:27Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-07-19T00:09:38Z",
        "body":  "Out of the box, `Thread.Priority` does nothing on Linux. This has been discussed in another issue: #60114. The core problem mentioned there is that Linux\u0027 default scheduler policy, `SCHED_OTHER`, ignores priority values. From [the man page](https://man7.org/linux/man-pages/man7/sched.7.html):\r\n\r\n       For threads scheduled under one of the normal scheduling policies\r\n       (SCHED_OTHER, SCHED_IDLE, SCHED_BATCH), sched_priority is not\r\n       used in scheduling decisions (it must be specified as 0).\r\n\r\nExcept, that\u0027s not the only way to influence CPU scheduling on Linux. You can also change the `nice` value:\r\n\r\n       The nice value is an attribute that can be used to influence the\r\n       CPU scheduler to favor or disfavor a process in scheduling\r\n       decisions.  It affects the scheduling of SCHED_OTHER and\r\n       SCHED_BATCH (see below) processes.  The nice value can be\r\n       modified using nice(2), setpriority(2), or sched_setattr(2).\r\n\r\nNow, nice values on Linux are not as absolute as Windows\u0027 thread priorities (according to the respective documentation), so I can understand that the behavior wouldn\u0027t be the same. But I do wonder if it makes sense to just map priority values to nice anyways?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOaQaXjA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5lAH26",
                                           "createdAt":  "2023-08-27T00:24:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nOut of the box, `Thread.Priority` does nothing on Linux. This has been discussed in another issue: #60114. The core problem mentioned there is that Linux\u0027 default scheduler policy, `SCHED_OTHER`, ignores priority values. From [the man page](https://man7.org/linux/man-pages/man7/sched.7.html):\r\n\r\n       For threads scheduled under one of the normal scheduling policies\r\n       (SCHED_OTHER, SCHED_IDLE, SCHED_BATCH), sched_priority is not\r\n       used in scheduling decisions (it must be specified as 0).\r\n\r\nExcept, that\u0027s not the only way to influence CPU scheduling on Linux. You can also change the `nice` value:\r\n\r\n       The nice value is an attribute that can be used to influence the\r\n       CPU scheduler to favor or disfavor a process in scheduling\r\n       decisions.  It affects the scheduling of SCHED_OTHER and\r\n       SCHED_BATCH (see below) processes.  The nice value can be\r\n       modified using nice(2), setpriority(2), or sched_setattr(2).\r\n\r\nNow, nice values on Linux are not as absolute as Windows\u0027 thread priorities (according to the respective documentation), so I can understand that the behavior wouldn\u0027t be the same. But I do wonder if it makes sense to just map priority values to nice anyways?\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ePJB3005\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-08-27T00:24:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5la6Lf",
                                           "createdAt":  "2023-08-31T18:24:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "@PJB3005 thank you for bringing this up. I\u0027ve been also recently thinking about trying setting the nice values for the priority of GC threads where we also keep them on the same level as other threads on Unix. Sounds like it would make sense for the case you\u0027ve mentioned too. I am assigning this to myself.",
                                           "updatedAt":  "2023-08-31T18:25:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5pBpeM",
                                           "createdAt":  "2023-10-13T18:54:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "piju3",
                                           "body":  "Thread.Priority should definitely set nice, since that\u0027s what most developers will expect and it\u0027s the closest concept in Linux, even if it doesn\u0027t perfectly match Windows\u0027 priorities. The documentation does say \"The scheduling algorithm used to determine the order of thread execution varies with each operating system.\"\r\n\r\nIf not, the documentation should at least warn that it does nothing on Linux. As it is right now it\u0027s just broken.\r\n\r\nFor what it\u0027s worth, the _setpriority_ and _getpriority_ POSIX calls actually do set the nice value, so it\u0027s not unreasonable to use that word.",
                                           "updatedAt":  "2023-10-13T18:54:35Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Should Thread.Priority set nice on Linux?",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/91987",
        "createdAt":  "2023-09-13T06:55:59Z",
        "number":  91987,
        "author":  "lonix1",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODJDXig==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "BinToss",
                                            "createdAt":  "2025-07-29T22:41:08Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-09-21T00:00:40Z",
        "body":  "### Description\r\n\r\nIn a CI build, in the official sdk docker image, I run `dotnet nuget locals all --clear`, and get this:\r\n\r\n```\r\nRUN dotnet nuget locals all --clear\r\nSystem.IO.IOException: The system cannot open the device or file specified. : \u0027NuGet-Migrations\u0027\r\n   at System.Threading.Mutex.CreateMutexCore(Boolean initiallyOwned, String name, Boolean\u0026 createdNew)\r\n   at System.Threading.Mutex..ctor(Boolean initiallyOwned, String name)\r\n   at NuGet.Common.Migrations.MigrationRunner.Run()\r\n   at Microsoft.DotNet.Configurer.DotnetFirstTimeUseConfigurer.Configure()\r\n   at Microsoft.DotNet.Cli.Program.ConfigureDotNetForFirstTimeUse(IFirstTimeUseNoticeSentinel firstTimeUseNoticeSentinel, IAspNetCertificateSentinel aspNetCertificateSentinel, IFileSentinel toolPathSentinel, Boolean isDotnetBeingInvokedFromNativeInstaller, DotnetFirstRunConfiguration dotnetFirstRunConfiguration, IEnvironmentProvider environmentProvider, Dictionary`2 performanceMeasurements)\r\n   at Microsoft.DotNet.Cli.Program.ProcessArgs(String[] args, TimeSpan startupTime, ITelemetry telemetryClient)\r\n   at Microsoft.DotNet.Cli.Program.Main(String[] args)\r\nERROR: process \"/bin/sh -c dotnet nuget locals all --clear\" did not complete successfully: exit code: 1\r\n```\r\n\r\n### Reproduction Steps\r\n\r\ninside the sdk container:\r\n```\r\nRUN \\\r\n  export DOTNET_SKIP_FIRST_TIME_EXPERIENCE=1 \u0026\u0026 \\\r\n  dotnet nuget locals all --clear\r\n```\r\n\r\n\r\n### Expected behavior\r\n\r\nNo error\r\n\r\n### Actual behavior\r\n\r\nError\r\n\r\n### Regression?\r\n\r\nuknown\r\n\r\n### Known Workarounds\r\n\r\nnone\r\n\r\n### Configuration\r\n\r\nmcr.microsoft.com/dotnet/sdk:7.0.400-bookworm-slim-amd64\r\n\r\n\r\n### Other information\r\n\r\nMight be related to https://github.com/NuGet/Home/issues/12159 and https://github.com/dotnet/runtime/issues/80619, but those have been locked.\r\n\r\nIf I remove that offending line, I can build the docker image. If I then run that image and do something as simple as `dotnet nuget` it will give the same error as above.\r\n\r\n```json\r\n{\r\n  \"ErrorMessage\": \"The system cannot open the device or file specified. : \u0027NuGet-Migrations\u0027\",\r\n  \"BuildRetry\": false,\r\n  \"ErrorPattern\": \"\",\r\n  \"ExcludeConsoleLog\": false\r\n}\r\n```\r\n\r\n\u003c!-- Known issue validation start --\u003e\r\n ### Known issue validation\r\n**Build: :mag_right:** https://dev.azure.com/dnceng-public/public/_build/results?buildId=426482\r\n**Error message validated:** `The system cannot open the device or file specified. : \u0027NuGet-Migrations\u0027`\r\n**Result validation: :white_check_mark:** Known issue matched with the provided build.\r\n**Validation performed at:** 10/4/2023 1:44:58 AM UTC\r\n\u003c!-- Known issue validation end --\u003e\r\n\u003c!--Known issue error report start --\u003e\r\n\r\n### Report\r\n#### Summary\r\n|24-Hour Hit Count|7-Day Hit Count|1-Month Count|\r\n|---|---|---|\r\n|0|0|0|\r\n\u003c!--Known issue error report end --\u003e",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOhU0JoQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5mX1vd",
                                           "createdAt":  "2023-09-13T12:24:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lonix1",
                                           "body":  "Update: when I run the container as root, the problem disappears.\r\n\r\nBut even so, that error is misleading.",
                                           "updatedAt":  "2023-09-13T12:24:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5mZJsM",
                                           "createdAt":  "2023-09-13T15:34:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\nIn a CI build, in the official sdk docker image, I run `dotnet nuget locals all --clear`, and get this:\r\n\r\n```\r\nRUN dotnet nuget locals all --clear\r\nSystem.IO.IOException: The system cannot open the device or file specified. : \u0027NuGet-Migrations\u0027\r\n   at System.Threading.Mutex.CreateMutexCore(Boolean initiallyOwned, String name, Boolean\u0026 createdNew)\r\n   at System.Threading.Mutex..ctor(Boolean initiallyOwned, String name)\r\n   at NuGet.Common.Migrations.MigrationRunner.Run()\r\n   at Microsoft.DotNet.Configurer.DotnetFirstTimeUseConfigurer.Configure()\r\n   at Microsoft.DotNet.Cli.Program.ConfigureDotNetForFirstTimeUse(IFirstTimeUseNoticeSentinel firstTimeUseNoticeSentinel, IAspNetCertificateSentinel aspNetCertificateSentinel, IFileSentinel toolPathSentinel, Boolean isDotnetBeingInvokedFromNativeInstaller, DotnetFirstRunConfiguration dotnetFirstRunConfiguration, IEnvironmentProvider environmentProvider, Dictionary`2 performanceMeasurements)\r\n   at Microsoft.DotNet.Cli.Program.ProcessArgs(String[] args, TimeSpan startupTime, ITelemetry telemetryClient)\r\n   at Microsoft.DotNet.Cli.Program.Main(String[] args)\r\nERROR: process \"/bin/sh -c dotnet nuget locals all --clear\" did not complete successfully: exit code: 1\r\n```\r\n\r\n### Reproduction Steps\r\n\r\ninside the sdk container:\r\n```\r\nRUN \\\r\n  export DOTNET_SKIP_FIRST_TIME_EXPERIENCE=1 \u0026\u0026 \\\r\n  dotnet nuget locals all --clear\r\n```\r\n\r\n\r\n### Expected behavior\r\n\r\nNo error\r\n\r\n### Actual behavior\r\n\r\nError\r\n\r\n### Regression?\r\n\r\nuknown\r\n\r\n### Known Workarounds\r\n\r\nnone\r\n\r\n### Configuration\r\n\r\nmcr.microsoft.com/dotnet/sdk:7.0.400-bookworm-slim-amd64\r\n\r\n\r\n### Other information\r\n\r\nMight be related to https://github.com/NuGet/Home/issues/12159 and https://github.com/dotnet/runtime/issues/80619, but those have been locked.\r\n\r\nIf I remove that offending line, I can build the docker image. If I then run that image and do something as simple as `dotnet nuget` it will give the same error as above.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003elonix1\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`, `needs-area-label`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-09-13T15:34:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5mZJxB",
                                           "createdAt":  "2023-09-13T15:35:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "cc @kouvel ",
                                           "updatedAt":  "2023-09-13T15:35:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5miKyW",
                                           "createdAt":  "2023-09-14T22:24:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODG4GTg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "lonix1",
                                                                               "createdAt":  "2023-09-15T01:03:02Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "kouvel",
                                           "body":  "This could be similar to https://github.com/dotnet/runtime/issues/80619. If the container get set up as root or some other user and then a different user uses the container, a workaround may be to delete the `/tmp/.dotnet/shm` and `/tmp/.dotnet/lockfiles` directories as root as the last step before switching to a different user. There is a fix that is targeting the next servicing versions for [.NET 7](https://github.com/dotnet/runtime/pull/90343) and [.NET 6](https://github.com/dotnet/runtime/pull/90344) that may help if it\u0027s the same issue.\r\n\r\n\u003e But even so, that error is misleading.\r\n\r\nThere is an issue for that, which would hopefully be addressed soon: https://github.com/dotnet/runtime/issues/89090",
                                           "updatedAt":  "2023-09-14T22:25:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5mil_i",
                                           "createdAt":  "2023-09-15T01:05:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lonix1",
                                           "body":  "Thanks. I\u0027ll try the new version when it\u0027s released to see if it fixes this.\r\n\r\nIs it one of those fixes that\u0027s released every month or so?",
                                           "updatedAt":  "2023-09-15T01:05:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5mi7jY",
                                           "createdAt":  "2023-09-15T03:29:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "\u003e Is it one of those fixes that\u0027s released every month or so?\r\n\r\nYes, the change should be in the next version that is [released](https://dotnet.microsoft.com/en-us/download/dotnet), 6.0.23 and 7.0.12.",
                                           "updatedAt":  "2023-09-15T03:29:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5oEbw8",
                                           "createdAt":  "2023-10-04T01:34:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "@kouvel this might not be a System.Threading specific issue.\r\n\r\nI\u0027m also seeing this failure in 7.0 CI runs for JIT HardwareIntrinsics in WASM like this one (completely unrelated):\r\n\r\n- 7.0 PR: https://github.com/dotnet/runtime/pull/92970\r\n- Queue: `Build Browser wasm Linux Release AllSubsets_Mono_RuntimeTests`\r\n- Build: https://dev.azure.com/dnceng-public/public/_build/results?buildId=426482\u0026view=logs\u0026j=190ad6c8-5950-568c-cadd-f2dfb7d5a79f\u0026t=c0f6fdc1-ac5d-583c-8ae1-a18de0846552\u0026l=37\r\n- Log: https://helixre107v0xd1eu3ibi6ka.blob.core.windows.net/dotnet-runtime-refs-pull-92970-merge-dd168e95f4c34310ba/JIT.HardwareIntrinsics.X86.Aes/1/console.3ae4e55e.log?helixlogtype=result\r\n\u003cdetails\u003e\u003csummary\u003eOutput (Expand):\u003c/summary\u003e\r\n\r\n```\r\nMicrosoft.DotNet.XUnitConsoleRunner v2.5.0 (64-bit .NET 7.0.10)\r\n  Discovering: JIT.HardwareIntrinsics.XUnitWrapper (method display = ClassAndMethod, method display options = None)\r\n  Discovered:  JIT.HardwareIntrinsics.XUnitWrapper (found 2 of 362 test cases)\r\n  Starting:    JIT.HardwareIntrinsics.XUnitWrapper (parallel test collections = on, max threads = 2)\r\n    JIT/HardwareIntrinsics/X86/Aes/Aes_r/Aes_r.sh [FAIL]\r\n      System.IO.IOException: The system cannot open the device or file specified. : \u0027NuGet-Migrations\u0027\r\n         at System.Threading.Mutex.CreateMutexCore(Boolean initiallyOwned, String name, Boolean\u0026 createdNew)\r\n         at System.Threading.Mutex..ctor(Boolean initiallyOwned, String name)\r\n         at NuGet.Common.Migrations.MigrationRunner.Run()\r\n         at Microsoft.DotNet.Configurer.DotnetFirstTimeUseConfigurer.Configure()\r\n         at Microsoft.DotNet.Cli.Program.ConfigureDotNetForFirstTimeUse(IFirstTimeUseNoticeSentinel firstTimeUseNoticeSentinel, IAspNetCertificateSentinel aspNetCertificateSentinel, IFileSentinel toolPathSentinel, Boolean isDotnetBeingInvokedFromNativeInstaller, DotnetFirstRunConfiguration dotnetFirstRunConfiguration, IEnvironmentProvider environmentProvider, Dictionary`2 performanceMeasurements)\r\n         at Microsoft.DotNet.Cli.Program.ProcessArgs(String[] args, TimeSpan startupTime, ITelemetry telemetryClient)\r\n         at Microsoft.DotNet.Cli.Program.Main(String[] args)\r\n      \r\n      Return code:      1\r\n      Raw output file:      /datadisks/disk1/work/B3D809D6/w/C9020AAE/uploads/Reports/JIT.HardwareIntrinsics/X86/Aes/Aes_r/Aes_r.output.txt\r\n      Raw output:\r\n      BEGIN EXECUTION\r\n      Test Harness Exitcode is : 1\r\n      To run the test:\r\n      \u003e set CORE_ROOT=/datadisks/disk1/work/B3D809D6/p\r\n      \u003e /datadisks/disk1/work/B3D809D6/w/C9020AAE/e/JIT/HardwareIntrinsics/X86/Aes/Aes_r/Aes_r.sh\r\n      Expected: True\r\n      Actual:   False\r\n      Stack Trace:\r\n           at JIT_HardwareIntrinsics._X86_Aes_Aes_r_Aes_r_._X86_Aes_Aes_r_Aes_r_sh()\r\n           at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)\r\n           at System.Reflection.MethodInvoker.Invoke(Object obj, IntPtr* args, BindingFlags invokeAttr)\r\n      Output:\r\n        System.IO.IOException: The system cannot open the device or file specified. : \u0027NuGet-Migrations\u0027\r\n           at System.Threading.Mutex.CreateMutexCore(Boolean initiallyOwned, String name, Boolean\u0026 createdNew)\r\n           at System.Threading.Mutex..ctor(Boolean initiallyOwned, String name)\r\n           at NuGet.Common.Migrations.MigrationRunner.Run()\r\n           at Microsoft.DotNet.Configurer.DotnetFirstTimeUseConfigurer.Configure()\r\n           at Microsoft.DotNet.Cli.Program.ConfigureDotNetForFirstTimeUse(IFirstTimeUseNoticeSentinel firstTimeUseNoticeSentinel, IAspNetCertificateSentinel aspNetCertificateSentinel, IFileSentinel toolPathSentinel, Boolean isDotnetBeingInvokedFromNativeInstaller, DotnetFirstRunConfiguration dotnetFirstRunConfiguration, IEnvironmentProvider environmentProvider, Dictionary`2 performanceMeasurements)\r\n           at Microsoft.DotNet.Cli.Program.ProcessArgs(String[] args, TimeSpan startupTime, ITelemetry telemetryClient)\r\n           at Microsoft.DotNet.Cli.Program.Main(String[] args)\r\n        \r\n        Return code:      1\r\n        Raw output file:      /datadisks/disk1/work/B3D809D6/w/C9020AAE/uploads/Reports/JIT.HardwareIntrinsics/X86/Aes/Aes_r/Aes_r.output.txt\r\n        Raw output:\r\n        BEGIN EXECUTION\r\n        Test Harness Exitcode is : 1\r\n        To run the test:\r\n        \u003e set CORE_ROOT=/datadisks/disk1/work/B3D809D6/p\r\n        \u003e /datadisks/disk1/work/B3D809D6/w/C9020AAE/e/JIT/HardwareIntrinsics/X86/Aes/Aes_r/Aes_r.sh\r\n  Finished:    JIT.HardwareIntrinsics.XUnitWrapper\r\n=== TEST EXECUTION SUMMARY ===\r\n```\r\n\u003c/details\u003e",
                                           "updatedAt":  "2023-10-04T01:34:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5oEeIB",
                                           "createdAt":  "2023-10-04T01:47:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODIxCjA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "carlossanlop",
                                                                               "createdAt":  "2023-10-05T19:53:14Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "kouvel",
                                           "body":  "My understanding was that some of these tests in WASM have a build portion that runs as part of the test run. The exception is being thrown under `Microsoft.DotNet.Cli.Program.ConfigureDotNetForFirstTimeUse`. It\u0027s a decent suspicion currently that it\u0027s the same issue, and once the SDK used in the CI is updated to patched versions hopefully these kind of issues would disappear.",
                                           "updatedAt":  "2023-10-04T01:58:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5pestK",
                                           "createdAt":  "2023-10-19T00:03:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "~~Not sure what\u0027s happening to KnownBuildError today, but it\u0027s not tagging all the hits~~ (apparently it\u0027s just taking forever, but it works).\r\n\r\nHere\u0027s another one from today, found in 6.0:\r\n\r\n- PR: https://github.com/dotnet/runtime/pull/93697\r\n- Queue: `Build Browser wasm Release AllSubsets_Mono_RuntimeTests`\r\n- Build: https://dev.azure.com/dnceng-public/public/_build/results?buildId=443151\u0026view=logs\u0026j=2296eecc-f5ab-523f-c15d-f45eef1bfdea\u0026t=d328b091-66a6-5d96-5a21-3cf77f57f009\u0026l=70\r\n- Log file: https://helixre107v0xd1eu3ibi6ka.blob.core.windows.net/dotnet-runtime-refs-pull-93697-merge-70fceb6d2d9d424093/JIT.Methodical.eE/1/console.35d20077.log?helixlogtype=result\r\n- Output:\r\n```\r\n  Discovering: JIT.Methodical.XUnitWrapper (method display = ClassAndMethod, method display options = None)\r\n  Discovered:  JIT.Methodical.XUnitWrapper (found 113 of 695 test cases)\r\n  Starting:    JIT.Methodical.XUnitWrapper (parallel test collections = on, max threads = 2)\r\n    JIT/Methodical/explicit/rotate/_relrotarg_valref/_relrotarg_valref.sh [FAIL]\r\n      System.IO.IOException: The system cannot open the device or file specified. : \u0027NuGet-Migrations\u0027\r\n         at System.Threading.Mutex.CreateMutexCore(Boolean initiallyOwned, String name, Boolean\u0026 createdNew)\r\n         at System.Threading.Mutex..ctor(Boolean initiallyOwned, String name)\r\n         at NuGet.Common.Migrations.MigrationRunner.Run()\r\n         at Microsoft.DotNet.Configurer.DotnetFirstTimeUseConfigurer.Configure()\r\n         at Microsoft.DotNet.Cli.Program.ConfigureDotNetForFirstTimeUse(IFirstTimeUseNoticeSentinel firstTimeUseNoticeSentinel, IAspNetCertificateSentinel aspNetCertificateSentinel, IFileSentinel toolPathSentinel, Boolean isDotnetBeingInvokedFromNativeInstaller, DotnetFirstRunConfiguration dotnetFirstRunConfiguration, IEnvironmentProvider environmentProvider, Dictionary`2 performanceMeasurements)\r\n         at Microsoft.DotNet.Cli.Program.ProcessArgs(String[] args, TimeSpan startupTime, ITelemetry telemetryClient)\r\n         at Microsoft.DotNet.Cli.Program.Main(String[] args)\r\n      \r\n      Return code:      1\r\n      Raw output file:      /datadisks/disk1/work/B49409A4/w/C50E0A37/uploads/Reports/JIT.Methodical/explicit/rotate/_relrotarg_valref/_relrotarg_valref.output.txt\r\n      Raw output:\r\n      BEGIN EXECUTION\r\n      Test Harness Exitcode is : 1\r\n      To run the test:\r\n      \u003e set CORE_ROOT=/datadisks/disk1/work/B49409A4/p\r\n      \u003e /datadisks/disk1/work/B49409A4/w/C50E0A37/e/JIT/Methodical/explicit/rotate/_relrotarg_valref/_relrotarg_valref.sh\r\n      Expected: True\r\n      Actual:   False\r\n      Stack Trace:\r\n           at JIT_Methodical._explicit_rotate__relrotarg_valref__relrotarg_valref_._explicit_rotate__relrotarg_valref__relrotarg_valref_sh()\r\n      Output:\r\n        System.IO.IOException: The system cannot open the device or file specified. : \u0027NuGet-Migrations\u0027\r\n           at System.Threading.Mutex.CreateMutexCore(Boolean initiallyOwned, String name, Boolean\u0026 createdNew)\r\n           at System.Threading.Mutex..ctor(Boolean initiallyOwned, String name)\r\n           at NuGet.Common.Migrations.MigrationRunner.Run()\r\n           at Microsoft.DotNet.Configurer.DotnetFirstTimeUseConfigurer.Configure()\r\n           at Microsoft.DotNet.Cli.Program.ConfigureDotNetForFirstTimeUse(IFirstTimeUseNoticeSentinel firstTimeUseNoticeSentinel, IAspNetCertificateSentinel aspNetCertificateSentinel, IFileSentinel toolPathSentinel, Boolean isDotnetBeingInvokedFromNativeInstaller, DotnetFirstRunConfiguration dotnetFirstRunConfiguration, IEnvironmentProvider environmentProvider, Dictionary`2 performanceMeasurements)\r\n           at Microsoft.DotNet.Cli.Program.ProcessArgs(String[] args, TimeSpan startupTime, ITelemetry telemetryClient)\r\n           at Microsoft.DotNet.Cli.Program.Main(String[] args)\r\n        \r\n        Return code:      1\r\n        Raw output file:      /datadisks/disk1/work/B49409A4/w/C50E0A37/uploads/Reports/JIT.Methodical/explicit/rotate/_relrotarg_valref/_relrotarg_valref.output.txt\r\n        Raw output:\r\n        BEGIN EXECUTION\r\n        Test Harness Exitcode is : 1\r\n        To run the test:\r\n        \u003e set CORE_ROOT=/datadisks/disk1/work/B49409A4/p\r\n        \u003e /datadisks/disk1/work/B49409A4/w/C50E0A37/e/JIT/Methodical/explicit/rotate/_relrotarg_valref/_relrotarg_valref.sh\r\n  Finished:    JIT.Methodical.XUnitWrapper\r\n=== TEST EXECUTION SUMMARY ===\r\n   JIT.Methodical.XUnitWrapper  Total: 113, Errors: 0, Failed: 1, Skipped: 0, Time: 103.139s\r\n```",
                                           "updatedAt":  "2023-10-19T00:03:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ply-F",
                                           "createdAt":  "2023-10-19T18:35:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "That unfortunate. It seems the release/6.0 branch is currently using the latest runtime that would have the fix. The fix may not fix things if the permissions issue is retained, such as if this ran on a VM where an unfixed runtime was used, and would be unlikely if a container is being used (unless the permissions issue occurred during container setup). PR https://github.com/dotnet/runtime/pull/92603 added some additional diagnostics info, if this happens in .NET 9 CIs hopefully we\u0027ll get more info about what\u0027s happening.",
                                           "updatedAt":  "2023-10-19T18:36:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5rTgZ5",
                                           "createdAt":  "2023-11-07T22:14:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "@kouvel One more hit in 6.0, now in the branding PR for 6.0.26:\r\n\r\n- PR: https://github.com/dotnet/runtime/pull/94482\r\n- Build: https://dev.azure.com/dnceng-public/public/_build/results?buildId=462335\u0026view=results\r\n- Queue: `Build Browser wasm Release AllSubsets_Mono_RuntimeTests`\r\n- Job: https://dev.azure.com/dnceng-public/public/_build/results?buildId=462335\u0026view=logs\u0026j=2296eecc-f5ab-523f-c15d-f45eef1bfdea\u0026t=d328b091-66a6-5d96-5a21-3cf77f57f009\r\n- Log file: https://helixre107v0xd1eu3ibi6ka.blob.core.windows.net/dotnet-runtime-refs-pull-94482-merge-fa96aba7885d4c37b2/JIT.Methodical.eE/1/console.940c0e2b.log?helixlogtype=result\r\n- Output:\r\n```\r\n    JIT/Methodical/explicit/basic/_il_relrefloc_r8/_il_relrefloc_r8.sh [FAIL]\r\n      System.IO.IOException: The system cannot open the device or file specified. : \u0027NuGet-Migrations\u0027\r\n         at System.Threading.Mutex.CreateMutexCore(Boolean initiallyOwned, String name, Boolean\u0026 createdNew)\r\n         at System.Threading.Mutex..ctor(Boolean initiallyOwned, String name)\r\n         at NuGet.Common.Migrations.MigrationRunner.Run()\r\n         at Microsoft.DotNet.Configurer.DotnetFirstTimeUseConfigurer.Configure()\r\n         at Microsoft.DotNet.Cli.Program.ConfigureDotNetForFirstTimeUse(IFirstTimeUseNoticeSentinel firstTimeUseNoticeSentinel, IAspNetCertificateSentinel aspNetCertificateSentinel, IFileSentinel toolPathSentinel, Boolean isDotnetBeingInvokedFromNativeInstaller, DotnetFirstRunConfiguration dotnetFirstRunConfiguration, IEnvironmentProvider environmentProvider, Dictionary`2 performanceMeasurements)\r\n         at Microsoft.DotNet.Cli.Program.ProcessArgs(String[] args, TimeSpan startupTime, ITelemetry telemetryClient)\r\n         at Microsoft.DotNet.Cli.Program.Main(String[] args)\r\n      \r\n      Return code:      1\r\n      Raw output file:      /datadisks/disk1/work/B3750922/w/BC5D0A34/uploads/Reports/JIT.Methodical/explicit/basic/_il_relrefloc_r8/_il_relrefloc_r8.output.txt\r\n      Raw output:\r\n      BEGIN EXECUTION\r\n      Test Harness Exitcode is : 1\r\n      To run the test:\r\n      \u003e set CORE_ROOT=/datadisks/disk1/work/B3750922/p\r\n      \u003e /datadisks/disk1/work/B3750922/w/BC5D0A34/e/JIT/Methodical/explicit/basic/_il_relrefloc_r8/_il_relrefloc_r8.sh\r\n      Expected: True\r\n      Actual:   False\r\n      Stack Trace:\r\n           at JIT_Methodical._explicit_basic__il_relrefloc_r8__il_relrefloc_r8_._explicit_basic__il_relrefloc_r8__il_relrefloc_r8_sh()\r\n      Output:\r\n        System.IO.IOException: The system cannot open the device or file specified. : \u0027NuGet-Migrations\u0027\r\n           at System.Threading.Mutex.CreateMutexCore(Boolean initiallyOwned, String name, Boolean\u0026 createdNew)\r\n           at System.Threading.Mutex..ctor(Boolean initiallyOwned, String name)\r\n           at NuGet.Common.Migrations.MigrationRunner.Run()\r\n           at Microsoft.DotNet.Configurer.DotnetFirstTimeUseConfigurer.Configure()\r\n           at Microsoft.DotNet.Cli.Program.ConfigureDotNetForFirstTimeUse(IFirstTimeUseNoticeSentinel firstTimeUseNoticeSentinel, IAspNetCertificateSentinel aspNetCertificateSentinel, IFileSentinel toolPathSentinel, Boolean isDotnetBeingInvokedFromNativeInstaller, DotnetFirstRunConfiguration dotnetFirstRunConfiguration, IEnvironmentProvider environmentProvider, Dictionary`2 performanceMeasurements)\r\n           at Microsoft.DotNet.Cli.Program.ProcessArgs(String[] args, TimeSpan startupTime, ITelemetry telemetryClient)\r\n           at Microsoft.DotNet.Cli.Program.Main(String[] args)\r\n        \r\n        Return code:      1\r\n        Raw output file:      /datadisks/disk1/work/B3750922/w/BC5D0A34/uploads/Reports/JIT.Methodical/explicit/basic/_il_relrefloc_r8/_il_relrefloc_r8.output.txt\r\n        Raw output:\r\n```",
                                           "updatedAt":  "2023-11-07T22:14:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53IErP",
                                           "createdAt":  "2024-03-14T22:47:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "Continues affecting 6.0. Example: https://github.com/dotnet/runtime/pull/99787\r\n\r\n- Build: https://dev.azure.com/dnceng-public/public/_build/results?buildId=603897\r\n- Queue: `Build Browser wasm Release AllSubsets_Mono_RuntimeTests`\r\n- Job result: https://dev.azure.com/dnceng-public/public/_build/results?buildId=603897\u0026view=logs\u0026j=2296eecc-f5ab-523f-c15d-f45eef1bfdea\u0026t=d328b091-66a6-5d96-5a21-3cf77f57f009\u0026l=69\r\n- Log file: https://helixre107v0xd1eu3ibi6ka.blob.core.windows.net/dotnet-runtime-refs-pull-99787-merge-72b2efd66b064faca7/JIT.Methodical.eE/1/console.13eabec1.log?helixlogtype=result\r\n- Output:\r\n```\r\n+ dotnet /datadisks/disk1/work/B8260A01/p/xunit/xunit.console.dll JIT/Methodical/JIT.Methodical.XUnitWrapper.dll -parallel collections -nocolor -noshadow -xml testResults.xml -trait TestGroup=JIT.Methodical.eE\r\nMicrosoft.DotNet.XUnitConsoleRunner v2.5.0 (64-bit .NET 6.0.27)\r\n  Discovering: JIT.Methodical.XUnitWrapper (method display = ClassAndMethod, method display options = None)\r\n  Discovered:  JIT.Methodical.XUnitWrapper (found 113 of 695 test cases)\r\n  Starting:    JIT.Methodical.XUnitWrapper (parallel test collections = on, max threads = 2)\r\n    JIT/Methodical/explicit/basic/_relrefarg_o/_relrefarg_o.sh [FAIL]\r\n      System.IO.IOException: The system cannot open the device or file specified. : \u0027NuGet-Migrations\u0027\r\n         at System.Threading.Mutex.CreateMutexCore(Boolean initiallyOwned, String name, Boolean\u0026 createdNew)\r\n         at System.Threading.Mutex..ctor(Boolean initiallyOwned, String name)\r\n         at NuGet.Common.Migrations.MigrationRunner.Run()\r\n         at Microsoft.DotNet.Configurer.DotnetFirstTimeUseConfigurer.Configure()\r\n         at Microsoft.DotNet.Cli.Program.ConfigureDotNetForFirstTimeUse(IFirstTimeUseNoticeSentinel firstTimeUseNoticeSentinel, IAspNetCertificateSentinel aspNetCertificateSentinel, IFileSentinel toolPathSentinel, Boolean isDotnetBeingInvokedFromNativeInstaller, DotnetFirstRunConfiguration dotnetFirstRunConfiguration, IEnvironmentProvider environmentProvider, Dictionary`2 performanceMeasurements)\r\n         at Microsoft.DotNet.Cli.Program.ProcessArgs(String[] args, TimeSpan startupTime, ITelemetry telemetryClient)\r\n         at Microsoft.DotNet.Cli.Program.Main(String[] args)\r\n      \r\n      Return code:      1\r\n      Raw output file:      /datadisks/disk1/work/B8260A01/w/9FD208F8/uploads/Reports/JIT.Methodical/explicit/basic/_relrefarg_o/_relrefarg_o.output.txt\r\n      Raw output:\r\n      BEGIN EXECUTION\r\n      Test Harness Exitcode is : 1\r\n      To run the test:\r\n      \u003e set CORE_ROOT=/datadisks/disk1/work/B8260A01/p\r\n      \u003e /datadisks/disk1/work/B8260A01/w/9FD208F8/e/JIT/Methodical/explicit/basic/_relrefarg_o/_relrefarg_o.sh\r\n      Expected: True\r\n      Actual:   False\r\n      Stack Trace:\r\n           at JIT_Methodical._explicit_basic__relrefarg_o__relrefarg_o_._explicit_basic__relrefarg_o__relrefarg_o_sh()\r\n      Output:\r\n        System.IO.IOException: The system cannot open the device or file specified. : \u0027NuGet-Migrations\u0027\r\n           at System.Threading.Mutex.CreateMutexCore(Boolean initiallyOwned, String name, Boolean\u0026 createdNew)\r\n           at System.Threading.Mutex..ctor(Boolean initiallyOwned, String name)\r\n           at NuGet.Common.Migrations.MigrationRunner.Run()\r\n           at Microsoft.DotNet.Configurer.DotnetFirstTimeUseConfigurer.Configure()\r\n           at Microsoft.DotNet.Cli.Program.ConfigureDotNetForFirstTimeUse(IFirstTimeUseNoticeSentinel firstTimeUseNoticeSentinel, IAspNetCertificateSentinel aspNetCertificateSentinel, IFileSentinel toolPathSentinel, Boolean isDotnetBeingInvokedFromNativeInstaller, DotnetFirstRunConfiguration dotnetFirstRunConfiguration, IEnvironmentProvider environmentProvider, Dictionary`2 performanceMeasurements)\r\n           at Microsoft.DotNet.Cli.Program.ProcessArgs(String[] args, TimeSpan startupTime, ITelemetry telemetryClient)\r\n           at Microsoft.DotNet.Cli.Program.Main(String[] args)\r\n        \r\n        Return code:      1\r\n        Raw output file:      /datadisks/disk1/work/B8260A01/w/9FD208F8/uploads/Reports/JIT.Methodical/explicit/basic/_relrefarg_o/_relrefarg_o.output.txt\r\n        Raw output:\r\n        BEGIN EXECUTION\r\n        Test Harness Exitcode is : 1\r\n        To run the test:\r\n        \u003e set CORE_ROOT=/datadisks/disk1/work/B8260A01/p\r\n        \u003e /datadisks/disk1/work/B8260A01/w/9FD208F8/e/JIT/Methodical/explicit/basic/_relrefarg_o/_relrefarg_o.sh\r\n  Finished:    JIT.Methodical.XUnitWrapper\r\n```",
                                           "updatedAt":  "2024-03-14T22:47:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc54erla",
                                           "createdAt":  "2024-03-26T19:32:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEc0AAA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "gbtb",
                                                                               "createdAt":  "2024-06-25T09:05:39Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Eyliess",
                                                                               "createdAt":  "2025-03-08T21:23:39Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "terrymun",
                                                                               "createdAt":  "2025-08-01T14:23:02Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "Namanl2001",
                                           "body":  "@carlossanlop I\u0027m facing the same issue with 8.0.2 do you know any workaround for this? thanks!",
                                           "updatedAt":  "2024-03-26T19:32:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6FTQmh",
                                           "createdAt":  "2024-07-18T12:51:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEdFiBw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "lindexi",
                                                                               "createdAt":  "2024-10-31T13:22:10Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "iph",
                                                                               "createdAt":  "2025-01-11T18:32:39Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Eyliess",
                                                                               "createdAt":  "2025-03-08T21:23:41Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "mrgrain",
                                                                               "createdAt":  "2025-04-03T10:17:55Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "BinToss",
                                                                               "createdAt":  "2025-07-29T22:23:56Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "terrymun",
                                                                               "createdAt":  "2025-08-01T14:21:23Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "johnwason",
                                                                               "createdAt":  "2025-08-05T01:00:25Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  7
                                                         },
                                           "author":  "criemen",
                                           "body":  "We\u0027re seeing\n```\nRunning command in /home/runner/work/semmle-code/semmle-code/target/codeql-csharp-integration-tests/ql/csharp/ql/integration-tests/all-platforms/cshtml: [dotnet, build]\n[2024-07-18 11:48:16] [build-stderr] System.IO.IOException: The system cannot open the device or file specified. : \u0027NuGet-Migrations\u0027\n[2024-07-18 11:48:16] [build-stderr]    at System.Threading.Mutex.CreateMutexCore(Boolean initiallyOwned, String name, Boolean\u0026 createdNew)\n[2024-07-18 11:48:16] [build-stderr]    at System.Threading.Mutex..ctor(Boolean initiallyOwned, String name)\n[2024-07-18 11:48:16] [build-stderr]    at NuGet.Common.Migrations.MigrationRunner.Run(String migrationsDirectory)\n[2024-07-18 11:48:16] [build-stderr]    at Microsoft.DotNet.Configurer.DotnetFirstTimeUseConfigurer.Configure()\n[2024-07-18 11:48:16] [build-stderr]    at Microsoft.DotNet.Cli.Program.ConfigureDotNetForFirstTimeUse(IFirstTimeUseNoticeSentinel firstTimeUseNoticeSentinel, IAspNetCertificateSentinel aspNetCertificateSentinel, IFileSentinel toolPathSentinel, Boolean isDotnetBeingInvokedFromNativeInstaller, DotnetFirstRunConfiguration dotnetFirstRunConfiguration, IEnvironmentProvider environmentProvider, Dictionary`2 performanceMeasurements)\n[2024-07-18 11:48:16] [build-stderr]    at Microsoft.DotNet.Cli.Program.ProcessArgs(String[] args, TimeSpan startupTime, ITelemetry telemetryClient)\n[2024-07-18 11:48:16] [build-stderr]    at Microsoft.DotNet.Cli.Program.Main(String[] args)\n```\nwith 8.0.101 on our CI (linux, ubuntu 22.04, GitHub actions). Is there any progress on this issue?",
                                           "updatedAt":  "2024-07-18T12:51:11Z"
                                       }
                                   ],
                         "totalCount":  14
                     },
        "title":  "The system cannot open the device or file specified \u0027NuGet-Migrations\u0027",
        "labels":  [
                       "area-System.Threading",
                       "Known Build Error"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/92442",
        "createdAt":  "2023-09-21T23:05:38Z",
        "number":  92442,
        "author":  "verdie-g",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-04-12T22:57:21Z",
        "body":  "### Background and motivation\r\n\r\nWhen using a counter from the OpenTelemetry API you can either directly increment a [Counter\u003cT\u003e](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.metrics.counter-1) as such\r\n```cs\r\nCounter\u003clong\u003e c = Meter.CreateCounter\u003clong\u003e(\"my_metric\");\r\nc.Add(1);\r\n```\r\nbut performance-wise it\u0027s not great. When performance matters it\u0027s better to use an [ObservableCounter\u003cT\u003e](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.metrics.observablecounter-1) + [Interlocked.Increment](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked.increment):\r\n```cs\r\nprivate long _count;\r\n// ...\r\nObservableCounter\u003clong\u003e c = Meter.CreateObservableCounter(\"my_metric\",\r\n    () =\u003e new Measurement\u003clong\u003e(Volatile.Read(ref _count)));\r\n// ...\r\nInterlocked.Increment(ref _count);\r\n```\r\nIt\u0027s way more performant but still it doesn\u0027t scale very well on high number of concurrent increments. For example let\u0027s say you want to a hit rate metric for your cache, [Interlocked.Increment](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked.increment) will greatly impact the performance.\r\n```cs\r\npublic class InstrumentedDictionary\r\n{\r\n    private const int Iterations = 10_000_000;\r\n    \r\n    private readonly ConcurrentDictionary\u003cint, int\u003e _dictionary = new(Enumerable.Range(0, 100_000).ToDictionary(n =\u003e n));\r\n\r\n    private long _hits;\r\n    private long _misses;\r\n    \r\n    [Benchmark(OperationsPerInvoke = Iterations)]\r\n    public long WithMetrics()\r\n    {\r\n        long dontEliminateMyCodePlease = 0;\r\n        \r\n        Barrier b = new(Environment.ProcessorCount - 1);\r\n        Parallel.For(0, b.ParticipantCount, _ =\u003e\r\n        {\r\n            Random random = new();\r\n            b.SignalAndWait();\r\n\r\n            long sum = 0;\r\n            for (int i = 0; i \u003c Iterations; i += 1)\r\n            {\r\n                if (_dictionary.TryGetValue(random.Next(50_000), out var n))\r\n                {\r\n                    sum += n;\r\n                    Interlocked.Increment(ref _hits);\r\n                }\r\n                else\r\n                {\r\n                    Interlocked.Increment(ref _misses);\r\n                }\r\n            }\r\n\r\n            dontEliminateMyCodePlease = sum;\r\n        });\r\n\r\n        return dontEliminateMyCodePlease;\r\n    }\r\n\r\n    [Benchmark(OperationsPerInvoke = Iterations)]\r\n    public long WithoutMetrics()\r\n    {\r\n        long dontEliminateMyCodePlease = 0;\r\n        \r\n        Barrier b = new(Environment.ProcessorCount - 1);\r\n        Parallel.For(0, b.ParticipantCount, _ =\u003e\r\n        {\r\n            Random random = new();\r\n            b.SignalAndWait();\r\n\r\n            long sum = 0;\r\n            for (int i = 0; i \u003c Iterations; i += 1)\r\n            {\r\n                if (_dictionary.TryGetValue(random.Next(50_000), out var n))\r\n                {\r\n                    sum += n;\r\n                }\r\n            }\r\n\r\n            dontEliminateMyCodePlease = sum;\r\n        });\r\n\r\n        return dontEliminateMyCodePlease;\r\n    }\r\n}\r\n```\r\n\r\nThat benchmark yields\r\n\r\n| Method         | Mean      | Error    | StdDev   |\r\n|--------------- |----------:|---------:|---------:|\r\n| WithMetrics    | 448.53 ns | 0.679 ns | 0.602 ns |\r\n| WithoutMetrics |  21.32 ns | 0.066 ns | 0.059 ns |\r\n\r\nIt would be great if .NET could provide a way to have an atomic counter with highly performant writes using thread locals.\r\n\r\nI saw two use-cases in the .NET runtime itself where [Interlocked.Increment](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked.increment) is not enough:\r\n- [PortableThreadPool.CompletedWorkItemCount](https://github.com/dotnet/runtime/blob/13a97c8cdfb552fa2fb2a8a43164e139d00c91b8/src/libraries/System.Private.CoreLib/src/System/Threading/ThreadInt64PersistentCounter.cs#L14-L15)\r\n- [MemoryCache.GetCurrentStatistics](https://github.com/dotnet/runtime/blob/13a97c8cdfb552fa2fb2a8a43164e139d00c91b8/src/libraries/Microsoft.Extensions.Caching.Memory/src/MemoryCache.cs#L29)\r\n\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Threading;\r\n\r\npublic class LowReadHighWriteAtomicCounter\r\n{\r\n    // Slow operation.\r\n    public long Count { get; }\r\n\r\n    // Fast operations.\r\n    public void Increment();\r\n    public void Decrement();\r\n    public void Add(long value);\r\n}\r\n```\r\n\r\n1. Could implement [IBinaryInteger](https://learn.microsoft.com/en-us/dotnet/api/system.numerics.ibinaryinteger-1) so a counter of any number type (`int`, `long`, `short`) could be created. Not exactly sure what would be the benefit though.\r\n2.  Increment/Decrement might not be needed but it would help the implementation if it is using Interlocked.\r\n3. Example implementation: https://gist.github.com/verdie-g/77b58548fa772fef42a710e4aea49576\r\n\r\n### API Usage\r\n\r\n```csharp\r\nprivate readonly LowReadHighWriteAtomicCounter _counter = new();\r\n// ...\r\nObservableCounter\u003clong\u003e c = Meter.CreateObservableCounter(\"my_metric\",\r\n    () =\u003e new Measurement\u003clong\u003e(_counter.Value));\r\n// ...\r\n_counter.Increment();\r\n```\r\n\r\n### Alternative Designs\r\n\r\n#### Move the fast counter in `System.Diagnostics.Metrics.Counter\u003cT\u003e.Add`\r\n\r\nAs an alternative that counter could reside in [Counter\u003cT\u003e.Add](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.metrics.counter-1.add) but that method actually just notify the listeners about a new measurement. So the code should rather be in the OpenTelemetry SDK but there would be a non-negligible amount of code between the `Add` and the fast counter increment.\r\n\r\n#### Create a new System.Diagnostics.Metrics counter\r\n\r\nIf it\u0027s identified that this fast low-read-high-writer counter is only useful for metrics, a new metric counter could be introduced that only accepts tags on creation:\r\n```cs\r\nnamespace System.Diagnostics.Metrics;\r\n\r\npublic class Meter\r\n{\r\n    public FastCounter\u003cT\u003e CreateFastCounter\u003cT\u003e(string name, string? unit = null, string? description = null,\r\n        IEnumerable\u003cSystem.Collections.Generic.KeyValuePair\u003cstring,object?\u003e\u003e tags) where T : struct;\r\n}\r\n\r\npublic sealed class FastCounter\u003cT\u003e : Instrument\u003cT\u003e where T : struct\r\n{\r\n    public void Add(T delta);\r\n}\r\n```\r\n\r\nWhat I dislike about this solution is that it\u0027s a complete custom extension of the OpenTelemetry API (CreateCounter and CreateObservableCounter [are in the standard](https://github.com/open-telemetry/opentelemetry-specification/blob/fd59a218278e357f111eb19eb3f3d2ca73cf06c4/specification/metrics/api.md#meter-operations)).\r\n\r\n\r\n### Risks\r\n\r\nThat class could be too niche of a use-case, and would give a reason to introduce other niche classes.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOptZmwg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5nJN2g",
                                           "createdAt":  "2023-09-21T23:08:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "Looks like a dup of https://github.com/dotnet/runtime/issues/91319\r\n\r\nNot sure why I closed it since it\u0027s not resolved actually via TLS",
                                           "updatedAt":  "2023-09-21T23:08:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5nJpix",
                                           "createdAt":  "2023-09-22T00:59:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\r\n\r\nWhen using a counter from the OpenTelemetry API you can either directly increment a [Counter\u003cT\u003e](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.metrics.counter-1) as such\r\n```cs\r\nCounter\u003clong\u003e c = Meter.CreateCounter\u003clong\u003e(\"my_metric\");\r\nc.Add(1);\r\n```\r\nbut performance-wise it\u0027s not great. When performance matters it\u0027s better to use an [ObservableCounter\u003cT\u003e](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.metrics.observablecounter-1) + [Interlocked.Increment](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked.increment):\r\n```cs\r\nprivate long _count;\r\n// ...\r\nObservableCounter\u003clong\u003e c = Meter.CreateObservableCounter(\"my_metric\",\r\n    () =\u003e new Measurement\u003clong\u003e(Volatile.Read(ref _count)));\r\n// ...\r\nInterlocked.Increment(ref _count);\r\n```\r\nIt\u0027s way more performant but still it doesn\u0027t scale very well on high number of concurrent increments. For example let\u0027s say you want to a hit rate metric for your cache, [Interlocked.Increment](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked.increment) will greatly impact the performance.\r\n```cs\r\npublic class InstrumentedDictionary\r\n{\r\n    private const int Iterations = 10_000_000;\r\n    \r\n    private readonly ConcurrentDictionary\u003cint, int\u003e _dictionary = new(Enumerable.Range(0, 100_000).ToDictionary(n =\u003e n));\r\n\r\n    private long _hits;\r\n    private long _misses;\r\n    \r\n    [Benchmark(OperationsPerInvoke = Iterations)]\r\n    public long WithMetrics()\r\n    {\r\n        long dontEliminateMyCodePlease = 0;\r\n        \r\n        Barrier b = new(Environment.ProcessorCount - 1);\r\n        Parallel.For(0, b.ParticipantCount, _ =\u003e\r\n        {\r\n            Random random = new();\r\n            b.SignalAndWait();\r\n\r\n            long sum = 0;\r\n            for (int i = 0; i \u003c Iterations; i += 1)\r\n            {\r\n                if (_dictionary.TryGetValue(random.Next(50_000), out var n))\r\n                {\r\n                    sum += n;\r\n                    Interlocked.Increment(ref _hits);\r\n                }\r\n                else\r\n                {\r\n                    Interlocked.Increment(ref _misses);\r\n                }\r\n            }\r\n\r\n            dontEliminateMyCodePlease = sum;\r\n        });\r\n\r\n        return dontEliminateMyCodePlease;\r\n    }\r\n\r\n    [Benchmark(OperationsPerInvoke = Iterations)]\r\n    public long WithoutMetrics()\r\n    {\r\n        long dontEliminateMyCodePlease = 0;\r\n        \r\n        Barrier b = new(Environment.ProcessorCount - 1);\r\n        Parallel.For(0, b.ParticipantCount, _ =\u003e\r\n        {\r\n            Random random = new();\r\n            b.SignalAndWait();\r\n\r\n            long sum = 0;\r\n            for (int i = 0; i \u003c Iterations; i += 1)\r\n            {\r\n                if (_dictionary.TryGetValue(random.Next(50_000), out var n))\r\n                {\r\n                    sum += n;\r\n                }\r\n            }\r\n\r\n            dontEliminateMyCodePlease = sum;\r\n        });\r\n\r\n        return dontEliminateMyCodePlease;\r\n    }\r\n}\r\n```\r\n\r\nThat benchmark yields\r\n\r\n| Method         | Mean      | Error    | StdDev   |\r\n|--------------- |----------:|---------:|---------:|\r\n| WithMetrics    | 448.53 ns | 0.679 ns | 0.602 ns |\r\n| WithoutMetrics |  21.32 ns | 0.066 ns | 0.059 ns |\r\n\r\nIt would be great if .NET could provide a way to have an atomic counter with highly performant writes using thread locals.\r\n\r\nI saw two use-cases in the .NET runtime itself where [Interlocked.Increment](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked.increment) is not enough:\r\n- [PortableThreadPool.CompletedWorkItemCount](https://github.com/dotnet/runtime/blob/13a97c8cdfb552fa2fb2a8a43164e139d00c91b8/src/libraries/System.Private.CoreLib/src/System/Threading/ThreadInt64PersistentCounter.cs#L14-L15)\r\n- [MemoryCache.GetCurrentStatistics](https://github.com/dotnet/runtime/blob/13a97c8cdfb552fa2fb2a8a43164e139d00c91b8/src/libraries/Microsoft.Extensions.Caching.Memory/src/MemoryCache.cs#L29)\r\n\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Threading;\r\n\r\npublic class LowReadHighWriteAtomicCounter\r\n{\r\n    // Slow operation.\r\n    public long Count { get; }\r\n\r\n    // Fast operations.\r\n    public void Increment();\r\n    public void Add(long value);\r\n}\r\n```\r\n\r\nNot super familiar with generic math yet, but maybe it should implement [IBinaryInteger](https://learn.microsoft.com/en-us/dotnet/api/system.numerics.ibinaryinteger-1) so a counter of any number type (`int`, `long`, `short`) could be created.\r\n\r\n### API Usage\r\n\r\n```csharp\r\nprivate readonly LowReadHighWriteAtomicCounter _counter = new();\r\n// ...\r\nObservableCounter\u003clong\u003e c = Meter.CreateObservableCounter(\"my_metric\",\r\n    () =\u003e new Measurement\u003clong\u003e(_counter.Value));\r\n// ...\r\n_counter.Increment();\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\n#### Move the fast counter in `System.Diagnostics.Metrics.Counter\u003cT\u003e.Add`\r\n\r\nAs an alternative that counter could reside in [Counter\u003cT\u003e.Add](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.metrics.counter-1.add) but that method actually just notify the listeners about a new measurement. So the code should rather be in the OpenTelemetry SDK but there would be a non-negligible amount of code between the `Add` and the fast counter increment.\r\n\r\n#### Create a new System.Diagnostics.Metrics counter\r\n\r\nIf it\u0027s identified that this fast low-read-high-writer counter is only useful for metrics, a new metric counter could be introduced that only accepts tags on creation:\r\n```cs\r\nnamespace System.Diagnostics.Metrics;\r\n\r\npublic class Meter\r\n{\r\n    public FastCounter\u003cT\u003e CreateFastCounter\u003cT\u003e(string name, string? unit = null, string? description = null,\r\n        IEnumerable\u003cSystem.Collections.Generic.KeyValuePair\u003cstring,object?\u003e\u003e tags) where T : struct;\r\n}\r\n\r\npublic sealed class FastCounter\u003cT\u003e : Instrument\u003cT\u003e where T : struct\r\n{\r\n    public void Add(T delta);\r\n}\r\n```\r\n\r\nWhat I dislike about this solution is that it\u0027s a complete custom extension of the OpenTelemetry API (CreateCounter and CreateObservableCounter [are in the standard](https://github.com/open-telemetry/opentelemetry-specification/blob/fd59a218278e357f111eb19eb3f3d2ca73cf06c4/specification/metrics/api.md#meter-operations)).\r\n\r\n\r\n### Risks\r\n\r\nThat class could be too niche of a use-case, and would give a reason to introduce other niche classes.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003everdie-g\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-09-22T00:59:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5nKOlb",
                                           "createdAt":  "2023-09-22T02:55:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "Not sure what\u0027s the correct area label. Noticed after I applied it.",
                                           "updatedAt":  "2023-09-22T02:55:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5nWaBh",
                                           "createdAt":  "2023-09-25T15:15:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "@tarekgh @noahfalk ",
                                           "updatedAt":  "2023-09-25T15:15:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5nXex6",
                                           "createdAt":  "2023-09-25T17:50:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tarekgh",
                                           "body":  "`Counter\u003cT\u003e` is working in a push mode. meaning when publishing any counter value using `counter.Add(...)`, it will need to notify all counter listeners with the reported value. This operation is done with every published value. `ObservableCounter` is working in pull mode which does nothing till someone requests the metrics value to report. So, the perf cost will be paid only when the value is requested. You cannot compare the perf between these models as each model are used for a different scenarios. \r\n\r\n.NET already provides the way for atomic incrementing values ([Interlocked.Increment](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked.increment)) as you indicated in your description. You mentioned `It\u0027s way more performant but still it doesn\u0027t scale very well on high number of concurrent increments. ` which is not clear why this is not scalable? and how your proposal `LowReadHighWriteAtomicCounter` will be scalable while the implementation is going to use `Interlocked.Increment` anyway? It is not clear to be why we need to provide such atomic incrementing API while .NET already have one for that. \r\n\r\nCC @noahfalk ",
                                           "updatedAt":  "2023-09-25T17:50:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5nXe2u",
                                           "createdAt":  "2023-09-25T17:50:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "This issue has been marked `needs-author-action` and may be missing some important information.",
                                           "updatedAt":  "2023-09-25T17:50:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5nXnPS",
                                           "createdAt":  "2023-09-25T18:15:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODhecpQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2023-09-25T18:33:05Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "acaly",
                                                                               "createdAt":  "2023-10-21T05:23:31Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "PaulusParssinen",
                                                                               "createdAt":  "2024-05-11T08:03:56Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "\u003e .NET already provides the way for atomic incrementing values ([Interlocked.Increment](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked.increment)) as you indicated in your description. You mentioned It\u0027s way more performant but still it doesn\u0027t scale very well on high number of concurrent increments.  which is not clear why this is not scalable? and how your proposal LowReadHighWriteAtomicCounter will be scalable while the implementation is going to use Interlocked.Increment anyway? It is not clear to be why we need to provide such atomic incrementing API while .NET already have one for that.\r\n\r\nWhen multipe cores increment the same variable in parallel it creates a huge cache contention as it jumps between caches + false sharing. It\u0027s enough to ruin one\u0027s perf, e.g. it\u0027s one of the reason of https://github.com/dotnet/aspnetcore/issues/50412\r\nWhat this issue (and https://github.com/dotnet/runtime/issues/91319) suggests is to use per-core/per-thread counters and sum them together on timer\u0027s tick.",
                                           "updatedAt":  "2023-09-25T18:15:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5nXoyA",
                                           "createdAt":  "2023-09-25T18:20:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tarekgh",
                                           "body":  "@EgorBo does https://github.com/dotnet/runtime/issues/91319 already addressing this issue? `and sum them together on timer\u0027s tick.` this is the missing part not supported yet? I am seeing this is more generic for threading namespace than metrics APIs. Can you reactivate #91319? or you\u0027ll track it through this issue?",
                                           "updatedAt":  "2023-09-25T18:26:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5nXqPL",
                                           "createdAt":  "2023-09-25T18:25:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\r\n\r\nWhen using a counter from the OpenTelemetry API you can either directly increment a [Counter\u003cT\u003e](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.metrics.counter-1) as such\r\n```cs\r\nCounter\u003clong\u003e c = Meter.CreateCounter\u003clong\u003e(\"my_metric\");\r\nc.Add(1);\r\n```\r\nbut performance-wise it\u0027s not great. When performance matters it\u0027s better to use an [ObservableCounter\u003cT\u003e](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.metrics.observablecounter-1) + [Interlocked.Increment](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked.increment):\r\n```cs\r\nprivate long _count;\r\n// ...\r\nObservableCounter\u003clong\u003e c = Meter.CreateObservableCounter(\"my_metric\",\r\n    () =\u003e new Measurement\u003clong\u003e(Volatile.Read(ref _count)));\r\n// ...\r\nInterlocked.Increment(ref _count);\r\n```\r\nIt\u0027s way more performant but still it doesn\u0027t scale very well on high number of concurrent increments. For example let\u0027s say you want to a hit rate metric for your cache, [Interlocked.Increment](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked.increment) will greatly impact the performance.\r\n```cs\r\npublic class InstrumentedDictionary\r\n{\r\n    private const int Iterations = 10_000_000;\r\n    \r\n    private readonly ConcurrentDictionary\u003cint, int\u003e _dictionary = new(Enumerable.Range(0, 100_000).ToDictionary(n =\u003e n));\r\n\r\n    private long _hits;\r\n    private long _misses;\r\n    \r\n    [Benchmark(OperationsPerInvoke = Iterations)]\r\n    public long WithMetrics()\r\n    {\r\n        long dontEliminateMyCodePlease = 0;\r\n        \r\n        Barrier b = new(Environment.ProcessorCount - 1);\r\n        Parallel.For(0, b.ParticipantCount, _ =\u003e\r\n        {\r\n            Random random = new();\r\n            b.SignalAndWait();\r\n\r\n            long sum = 0;\r\n            for (int i = 0; i \u003c Iterations; i += 1)\r\n            {\r\n                if (_dictionary.TryGetValue(random.Next(50_000), out var n))\r\n                {\r\n                    sum += n;\r\n                    Interlocked.Increment(ref _hits);\r\n                }\r\n                else\r\n                {\r\n                    Interlocked.Increment(ref _misses);\r\n                }\r\n            }\r\n\r\n            dontEliminateMyCodePlease = sum;\r\n        });\r\n\r\n        return dontEliminateMyCodePlease;\r\n    }\r\n\r\n    [Benchmark(OperationsPerInvoke = Iterations)]\r\n    public long WithoutMetrics()\r\n    {\r\n        long dontEliminateMyCodePlease = 0;\r\n        \r\n        Barrier b = new(Environment.ProcessorCount - 1);\r\n        Parallel.For(0, b.ParticipantCount, _ =\u003e\r\n        {\r\n            Random random = new();\r\n            b.SignalAndWait();\r\n\r\n            long sum = 0;\r\n            for (int i = 0; i \u003c Iterations; i += 1)\r\n            {\r\n                if (_dictionary.TryGetValue(random.Next(50_000), out var n))\r\n                {\r\n                    sum += n;\r\n                }\r\n            }\r\n\r\n            dontEliminateMyCodePlease = sum;\r\n        });\r\n\r\n        return dontEliminateMyCodePlease;\r\n    }\r\n}\r\n```\r\n\r\nThat benchmark yields\r\n\r\n| Method         | Mean      | Error    | StdDev   |\r\n|--------------- |----------:|---------:|---------:|\r\n| WithMetrics    | 448.53 ns | 0.679 ns | 0.602 ns |\r\n| WithoutMetrics |  21.32 ns | 0.066 ns | 0.059 ns |\r\n\r\nIt would be great if .NET could provide a way to have an atomic counter with highly performant writes using thread locals.\r\n\r\nI saw two use-cases in the .NET runtime itself where [Interlocked.Increment](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked.increment) is not enough:\r\n- [PortableThreadPool.CompletedWorkItemCount](https://github.com/dotnet/runtime/blob/13a97c8cdfb552fa2fb2a8a43164e139d00c91b8/src/libraries/System.Private.CoreLib/src/System/Threading/ThreadInt64PersistentCounter.cs#L14-L15)\r\n- [MemoryCache.GetCurrentStatistics](https://github.com/dotnet/runtime/blob/13a97c8cdfb552fa2fb2a8a43164e139d00c91b8/src/libraries/Microsoft.Extensions.Caching.Memory/src/MemoryCache.cs#L29)\r\n\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Threading;\r\n\r\npublic class LowReadHighWriteAtomicCounter\r\n{\r\n    // Slow operation.\r\n    public long Count { get; }\r\n\r\n    // Fast operations.\r\n    public void Increment();\r\n    public void Decrement();\r\n    public void Add(long value);\r\n}\r\n```\r\n\r\n1. Could implement [IBinaryInteger](https://learn.microsoft.com/en-us/dotnet/api/system.numerics.ibinaryinteger-1) so a counter of any number type (`int`, `long`, `short`) could be created. Not exactly sure what would be the benefit though.\r\n2.  Increment/Decrement might not be needed but it would help the implementation if it is using Interlocked.\r\n3. Example implementation: https://gist.github.com/verdie-g/77b58548fa772fef42a710e4aea49576\r\n\r\n### API Usage\r\n\r\n```csharp\r\nprivate readonly LowReadHighWriteAtomicCounter _counter = new();\r\n// ...\r\nObservableCounter\u003clong\u003e c = Meter.CreateObservableCounter(\"my_metric\",\r\n    () =\u003e new Measurement\u003clong\u003e(_counter.Value));\r\n// ...\r\n_counter.Increment();\r\n```\r\n\r\n### Alternative Designs\r\n\r\n#### Move the fast counter in `System.Diagnostics.Metrics.Counter\u003cT\u003e.Add`\r\n\r\nAs an alternative that counter could reside in [Counter\u003cT\u003e.Add](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.metrics.counter-1.add) but that method actually just notify the listeners about a new measurement. So the code should rather be in the OpenTelemetry SDK but there would be a non-negligible amount of code between the `Add` and the fast counter increment.\r\n\r\n#### Create a new System.Diagnostics.Metrics counter\r\n\r\nIf it\u0027s identified that this fast low-read-high-writer counter is only useful for metrics, a new metric counter could be introduced that only accepts tags on creation:\r\n```cs\r\nnamespace System.Diagnostics.Metrics;\r\n\r\npublic class Meter\r\n{\r\n    public FastCounter\u003cT\u003e CreateFastCounter\u003cT\u003e(string name, string? unit = null, string? description = null,\r\n        IEnumerable\u003cSystem.Collections.Generic.KeyValuePair\u003cstring,object?\u003e\u003e tags) where T : struct;\r\n}\r\n\r\npublic sealed class FastCounter\u003cT\u003e : Instrument\u003cT\u003e where T : struct\r\n{\r\n    public void Add(T delta);\r\n}\r\n```\r\n\r\nWhat I dislike about this solution is that it\u0027s a complete custom extension of the OpenTelemetry API (CreateCounter and CreateObservableCounter [are in the standard](https://github.com/open-telemetry/opentelemetry-specification/blob/fd59a218278e357f111eb19eb3f3d2ca73cf06c4/specification/metrics/api.md#meter-operations)).\r\n\r\n\r\n### Risks\r\n\r\nThat class could be too niche of a use-case, and would give a reason to introduce other niche classes.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003everdie-g\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading`, `needs-author-action`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003eFuture\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-09-25T18:25:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5nXuW2",
                                           "createdAt":  "2023-09-25T18:37:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "https://github.com/dotnet/runtime/blob/dc5225d9afb08952d1a8685852c6c261857cd1e9/src/libraries/System.Private.CoreLib/src/System/Threading/ThreadInt64PersistentCounter.cs is a scalable counter like this that we is used internally by the threadpool.",
                                           "updatedAt":  "2023-09-25T18:37:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5njI-1",
                                           "createdAt":  "2023-09-27T12:08:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "Adding a few thoughts:\r\n\r\n- I think whether the BCL offers a public API for a raw counter primitive like `LowReadHighWriteAtomicCounter` is orthogonal from whether OpenTelemetry (or other subscribers) use those implementation techniques as the backing store for Counter\\\u003cT\u003e. Its possible to do either or both. The best place to track having OpenTelemetry use a lower latency backing store would be an issue in the [OpenTelemetry-dotnet](https://github.com/open-telemetry/opentelemetry-dotnet) repo.\r\n- There are some other factors aside from perf which might encourage someone to want Counter\\\u003cT\u003e vs ObservableCounter\\\u003cT\u003e. I expect for some situations it will be an easy alternative to switch and in others the tradeoffs will feel onerous. A couple reasons someone might want to keep using Counter\\\u003cT\u003e:\r\n    - [exemplar support](https://github.com/open-telemetry/opentelemetry-dotnet/blob/main/docs/metrics/exemplars/README.md) requires Counter\\\u003cT\u003e\r\n    - if your data is multi-dimensional managing the set of counts can be substantially more difficult.\r\n- I do think OpenTelemetry (and MetricsEventSource) would be well served to offer a lower latency backing storage, but given the potentially large increase in backing memory needed (10-100x seems common for per-thread storage) I doubt it is a policy that could be enabled by default. Instead I would imagine this is either something a developer opts into, or something that instrumentation authors opt specific metrics into using some addition to the [advice api](https://github.com/open-telemetry/opentelemetry-specification/blob/4ac43da9d746fea42523187685f341321a1d6ee1/specification/metrics/api.md#instrument-advice)\r\n    \r\n- `LowReadHighWriteAtomicCounter` feels somewhat niche and once you start going down this path there a bunch of different tradeoffs you can make. I don\u0027t know if there is enough critical mass behind one specific implementation option to justify having it in the BCL? Some different ways to implement such a counter with different tradeoffs:\r\n    - counter per thread\r\n    - counter per CPU core\r\n    - counter with fixed number of shards, or combination of fixed and per-thread/per-core limits\r\n    - counters that sacrifice accuracy instead of memory for speed (non-atomic updates or probabilistic updates)\r\n- Even if we didn\u0027t have a new `LowReadHighWriteAtomicCounter`, I think it could still be worthwhile to help users write such counters easily on top of ThreadLocal. Most of the support is already there as shown in [@stephentoub\u0027s example](https://github.com/dotnet/runtime/issues/91319#issuecomment-1699279717) however if I am remembering correctly there is an issue where counts are being lost if the threads which did those increments later exit. I think ThreadLocal would need some option to handle exiting threads so that data isn\u0027t lost and IMO that would be a nice improvement for the BCL to have.",
                                           "updatedAt":  "2023-09-27T12:09:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5njLyM",
                                           "createdAt":  "2023-09-27T12:16:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e ThreadLocal. Most of the support is already there as shown in https://github.com/dotnet/runtime/issues/91319#issuecomment-1699279717 however if I am remembering correctly there is an issue where counts are being lost if the threads which did those increments later exit. I think ThreadLocal would need some option to handle exiting threads so that data isn\u0027t lost and IMO that would be a nice improvement for the BCL to have\r\n\r\nThreadLocal already provides that. You can opt-in to it tracking all values, even after threads have gone away, and all of the values are available via the Values property. The challenge of using that here, though, is it does exactly what it says it\u0027ll do: it keeps the values even after the thread has gone away. If you have a continuous stream of threads being added, updating the ThreadLocal, and then terminating, this could amount to a slow leak.",
                                           "updatedAt":  "2023-09-27T12:16:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5pNiyT",
                                           "createdAt":  "2023-10-16T19:42:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "verdie-g",
                                           "body":  "\u003e ThreadLocal would need some option to handle exiting threads so that data isn\u0027t lost\r\n\r\nWhat do you think about something like that instead\r\n```diff\r\npublic class ThreadLocal\u003cT\u003e : IDisposable\r\n{\r\n+    public event ThreadExitedEventHandler\u003cT\u003e ThreadExited;\r\n}\r\n\r\n+ public delegate void ThreadExitedEventHandler\u003cT\u003e(object sender, ThreadExitedEventArgs\u003cT\u003e e);\r\n+ \r\n+ public class ThreadExitedEventArgs\u003cT\u003e : EventArgs\r\n+ {\r\n+    \u003csummary\u003eThe id of the exiting thread.\u003c/summary\u003e\r\n+    public int ThreadId { get; }\r\n+    \u003csummary\u003eThe value of the thread local on the exiting thread.\u003c/summary\u003e\r\n+    public T Value { get; }\r\n+}\r\n```\r\n\r\nWhen a thread exits, it would raise the ThreadExited on all its `ThreadLocal`. I\u0027m not sure if a thread can easily get all thread locals though.",
                                           "updatedAt":  "2023-10-16T19:42:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5pNl25",
                                           "createdAt":  "2023-10-16T19:51:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "\u003e When a thread exits, it would raise the ThreadExited on all its `ThreadLocal`.\r\n\r\nI don\u0027t think this would work with threads that were created in native code.",
                                           "updatedAt":  "2023-10-16T19:51:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5puCws",
                                           "createdAt":  "2023-10-21T05:31:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "acaly",
                                           "body":  "\u003e this could amount to a slow leak\n\nCan this be solved by adding a check on creating new slots in the thread local object? When the number exceeds a specific limit, it clears the dead slots and update a global value. Synchronization is nontrivial, but I think it\u0027s possible.",
                                           "updatedAt":  "2023-10-21T05:31:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6m1mbC",
                                           "createdAt":  "2025-04-12T22:57:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "verdie-g",
                                           "body":  "I found a bug in the MemoryCache counters https://github.com/dotnet/runtime/issues/108333 which shows that\u0027s not easy to implement a performant counter. The .NET SDK should probably provide something to help with that.",
                                           "updatedAt":  "2025-04-12T22:57:20Z"
                                       }
                                   ],
                         "totalCount":  16
                     },
        "title":  "[API Proposal]: Low Read High Write Counter",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/92557",
        "createdAt":  "2023-09-24T11:28:33Z",
        "number":  92557,
        "author":  "aleksatoroman",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODBfT0g==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kapral",
                                            "createdAt":  "2025-04-22T05:00:16Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-11-20T20:38:57Z",
        "body":  "### Description\r\n\r\nWhen using the `FixedWindowRateLimiter`, the value set for the `Retry-After` header reflects the entire time window specified in the policy configuration rather than the remaining time until the next permissible request.\r\n\r\n### Reproduction Steps\r\n\r\n1. Utilize the official example provided [here](https://learn.microsoft.com/en-gb/aspnet/core/performance/rate-limit?view=aspnetcore-8.0). The relevant code snippet is:\r\n\r\n```cs\r\n_rateLimiterOptions.OnRejected = (context, token) =\u003e\r\n{\r\n    if (context.Lease.TryGetMetadata(MetadataName.RetryAfter, out var retryAfter))\r\n    {\r\n        context.HttpContext.Response.Headers.RetryAfter =\r\n            ((int) retryAfter.TotalSeconds).ToString(NumberFormatInfo.InvariantInfo);\r\n    }\r\n\r\n    return ValueTask.CompletedTask;\r\n};\r\n```\r\n\r\n2.\r\n\r\nConfigure a `Window` option for, let\u0027s say, `00:01:00`. After reaching the maximum request limit for this window, inspect the Retry-After header. A visual representation of the issue can be found\r\n\r\n![image](https://github.com/dotnet/runtime/assets/114148475/0c1c1cb5-ee04-4808-886a-d14cf48d32fe)\r\n\r\n\r\n### Expected behavior\r\n\r\nThe `Retry-After` header should reflect the remaining time until the next request is permissible, like some other implementations are doing, such as Redis-based rate limiting that is built on top of this one  found [here](https://github.com/cristipufu/aspnetcore-redis-rate-limiting).\r\n\r\n### Actual behavior\r\n\r\nThe `Retry-After` header only reflects the static window value defined in the policy\u0027s configuration, ignoring the elapsed time.\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\n_No response_\r\n\r\n### Other information\r\n\r\nThis `RateLimiting` middleware is used in combination with my `YARP` reverse proxy gateway based on the following documentation: [YARP rate limiting](https://microsoft.github.io/reverse-proxy/articles/rate-limiting.html) ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOlGLDUw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5nRU_Z",
                                           "createdAt":  "2023-09-24T15:20:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\nWhen using the `FixedWindowRateLimiter`, the value set for the `Retry-After` header reflects the entire time window specified in the policy configuration rather than the remaining time until the next permissible request.\r\n\r\n### Reproduction Steps\r\n\r\n1. Utilize the official example provided [here](https://learn.microsoft.com/en-gb/aspnet/core/performance/rate-limit?view=aspnetcore-8.0). The relevant code snippet is:\r\n\r\n```cs\r\n_rateLimiterOptions.OnRejected = (context, token) =\u003e\r\n{\r\n    if (context.Lease.TryGetMetadata(MetadataName.RetryAfter, out var retryAfter))\r\n    {\r\n        context.HttpContext.Response.Headers.RetryAfter =\r\n            ((int) retryAfter.TotalSeconds).ToString(NumberFormatInfo.InvariantInfo);\r\n    }\r\n\r\n    return ValueTask.CompletedTask;\r\n};\r\n```\r\n\r\n2.\r\n\r\nConfigure a `Window` option for, let\u0027s say, `00:01:00`. After reaching the maximum request limit for this window, inspect the Retry-After header. A visual representation of the issue can be found\r\n\r\n![image](https://github.com/dotnet/runtime/assets/114148475/0c1c1cb5-ee04-4808-886a-d14cf48d32fe)\r\n\r\n\r\n### Expected behavior\r\n\r\nThe `Retry-After` header should reflect the remaining time until the next request is permissible, like some other implementations are doing, such as Redis-based rate limiting that is built on top of this one  found [here](https://github.com/cristipufu/aspnetcore-redis-rate-limiting).\r\n\r\n### Actual behavior\r\n\r\nThe `Retry-After` header only reflects the static window value defined in the policy\u0027s configuration, ignoring the elapsed time.\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\n_No response_\r\n\r\n### Other information\r\n\r\nThis `RateLimiting` middleware is used in combination with my `YARP` reverse proxy gateway based on the following documentation: [YARP rate limiting](https://microsoft.github.io/reverse-proxy/articles/rate-limiting.html) \n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ealeksatoroman\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-09-24T15:20:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5n68kw",
                                           "createdAt":  "2023-10-02T18:10:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "@BrennanConroy ",
                                           "updatedAt":  "2023-10-02T18:10:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6UYsNT",
                                           "createdAt":  "2024-11-20T20:38:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEhVcuQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hexxone",
                                                                               "createdAt":  "2025-09-08T16:08:34Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "asbjornvad",
                                           "body":  "### Background and motivation\n\nWhen using the FixedWindowRateLimiter, the value set for the Retry-After header reflects the entire time window specified in the options rather than the remaining time until the next permissible request.\n\nOne would most likely expect to get back the time at which new permits are available.\n\n### Reproduction steps\nThe following slighty modified test passes, which means the metadata is the same, even after a significant delay.\n```csharp\n[Fact]\npublic async Task CorrectRetryMetadataWithQueuedItem()\n{\n    var options = new FixedWindowRateLimiterOptions\n    {\n        PermitLimit = 2,\n        QueueProcessingOrder = QueueProcessingOrder.OldestFirst,\n        QueueLimit = 1,\n        Window = TimeSpan.FromSeconds(20),\n        AutoReplenishment = false\n    };\n    var limiter = new FixedWindowRateLimiter(options);\n\n    using var lease = limiter.AttemptAcquire(2);\n    // Queue item which changes the retry after time for failed items\n    var wait = limiter.AcquireAsync(1);\n    Assert.False(wait.IsCompleted);\n\n    await Task.Delay(19*1000);\n    using var failedLease = await limiter.AcquireAsync(2);\n    Assert.False(failedLease.IsAcquired);\n    Assert.True(failedLease.TryGetMetadata(MetadataName.RetryAfter, out var typedMetadata));\n    Assert.Equal(options.Window.Ticks, typedMetadata.Ticks);\n}\n```\n\nSay we were to set a timer to retry getting the permit at the specified RetryAfter:\nThe test passes since the new request simply undercuts the old request.\n```csharp\n[Fact]\npublic async Task NewRequestUndercutsOldRequest()\n{\n    var options = new FixedWindowRateLimiterOptions\n    {\n        PermitLimit = 1,\n        QueueProcessingOrder = QueueProcessingOrder.OldestFirst,\n        QueueLimit = 0,\n        Window = TimeSpan.FromSeconds(5),\n        AutoReplenishment = true\n    };\n    var limiter = new FixedWindowRateLimiter(options);\n\n    using var lease = limiter.AttemptAcquire(1);\n    Assert.True(lease.IsAcquired);\n\n    Thread.Sleep(4*1000); // 1 second left of the window\n    var failedLease = await limiter.AcquireAsync(1);\n    Assert.False(failedLease.IsAcquired);\n    failedLease.TryGetMetadata(MetadataName.RetryAfter, out var retryAfterValue);\n\n    var tasks = new List\u003cTask\u003e();\n\n    // Task to wait for the RetryAfter duration and then send a request.\n    tasks.Add(Task.Run(async () =\u003e\n    {\n        await Task.Delay(retryAfterValue); // Wait for RetryAfter (5 seconds).\n\n        using var oldLease = await limiter.AcquireAsync(1);\n        Assert.False(oldLease.IsAcquired);\n    }));\n\n    // Task to send a new request 1 second into the new window.\n    tasks.Add(Task.Run(async () =\u003e\n    {\n        await Task.Delay(2 * 1000); // 1 second into the new window\n        using var newLease = await limiter.AcquireAsync(1);\n        Assert.True(newLease.IsAcquired);\n    }));\n\n    // Wait for all tasks to complete.\n    await Task.WhenAll(tasks);\n}\n```\n\n### Expected behavior\nThe Retry-After header should reflect the remaining time until the next request is permissible.\nIn test 1 it should be ~1 second.\n\nIn test 2 the old request should have gotten the permit.\n\n### Actual behavior\nThe Retry-After header only reflects the static window value defined in the options, ignoring the elapsed time.\n\nIn test 2 this results in a new request getting the permit.\n\n### Considerations\nIf the queue is full and QueueLimit is greater than PermitLimit, then a RetryAfter value that is longer than the Window is returned. This could result in request1 getting told to wait out the current window and a future window, which potentially could result in request1 being undercut by say request2 that managed to request permit just as a new window started, thus putting request2 in the queue.\\\nRequest1 might never get its permit since it could continue being undercut by newer requests being put in the queue.\n\nTheoretically a request could stay in limbo forever(if a timer is set to the RetryAfter value):\\\nWindow = 10 seconds and PermitLimit = 10.\\\nThe window refreshes in 1 second and no permits are available. Request1 requests a permit but is told to wait 10 seconds before requesting again, instead of 1 second. After the window is refreshed and before Request1 tries again, all 10 permits are granted to newer requests. Request1 ask for a permit 1 second before the window refreshes and so on.\n\n\n### Proposed change\nA barbaric but fair solution:\n\nLet all requests have a fair fight for the permits. All the requests get a RetryAfter value that represents when the window is refreshed. This way all requests know when they can ask for a permit and have pretty equal chances of either getting the permit or being put in queue.\nI realise that, in terms of queue times, in wont have any significant effect if there are no new requests to take the leases. But wouldnt it make more sense to be put in queue, rather than hope to maybe get a permit?\n\nRemove the permit parameter from the function and only return the remaining time.\n```csharp\nprivate FixedWindowLease CreateFailedWindowLease()\n{\n    // Return the remaining time \n    TimeSpan? remainingTime = _options.Window - RateLimiterHelper.GetElapsedTime(_lastReplenishmentTick);\n    return new FixedWindowLease(false, remainingTime);\n}\n```\n\n### Risks\nAs pointed out in Issue-77991, the suggested solution is quite difficult to unit test, since the RetryAfter most likely won\u0027t be exactly the same every run.\nAn example of a test failing:\\\nAssert.Equal() Failure: Values differ\\\nExpected: 200000000\\\nActual:   199999954\\\n\nThe overall risk of being in limbo is still there, but is greatly minimised since a request would try again as soon as a new window is available, thereby reducing the chance of being undercut by newer requests.\n\nSome timer issues might cause a denied request to rerequest a permit just before a new window is created, thus setting the RetryAfter to something small like 0.001 second(pure speculation).\n\n### Related issues\nIssue 92557(this)\\\nIssue 77991\n",
                                           "updatedAt":  "2024-11-20T20:38:56Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "FixedWindowRateLimiter miscalculates `Retry-After` value",
        "labels":  [
                       "area-System.Threading",
                       "untriaged"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/92804",
        "createdAt":  "2023-09-29T01:04:36Z",
        "number":  92804,
        "author":  "carlossanlop",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-21T00:00:39Z",
        "body":  "### Error Blob\n\n```json\r\n{\r\n  \"ErrorMessage\": \"System.Threading.RateLimiting.Test.ConcurrencyLimiterTests.DoesNotDeadlockCleaningUpCanceledRequestedLease_Post [FAIL]\",\r\n  \"BuildRetry\": false,\r\n  \"ErrorPattern\": \"\",\r\n  \"ExcludeConsoleLog\": true\r\n}\r\n```\r\n\n\n### Reproduction Steps\n\n- Affected 8.0 PR: https://github.com/dotnet/runtime/pull/92762\r\n- Run: `Libraries Test Run checked coreclr windows x86 Debug`\r\n- Job: https://dev.azure.com/dnceng-public/public/_build/results?buildId=421749\u0026view=logs\u0026j=f1f3e473-935f-5de7-3348-701fec448dfb\u0026t=0644e1d9-cbee-5379-e020-5995b9f78358\u0026l=56\r\n- Artifacts: https://dev.azure.com/dnceng-public/public/_build/results?buildId=421749\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=9265494\u0026resultId=162839\u0026paneView=dotnet-dnceng.dnceng-build-release-tasks.helix-test-information-tab\r\n- Log file: https://helixre107v0xd1eu3ibi6ka.blob.core.windows.net/dotnet-runtime-refs-pull-92762-merge-7b1c426ed16c4d42ab/System.Threading.RateLimiting.Tests/1/console.20a587af.log?helixlogtype=result\r\n- Output:\r\n```\r\n===========================================================================================================\r\n\r\nC:\\h\\w\\B0F0099E\\w\\AA000950\\e\u003e\"C:\\h\\w\\B0F0099E\\p\\dotnet.exe\" exec --runtimeconfig System.Threading.RateLimiting.Tests.runtimeconfig.json --depsfile System.Threading.RateLimiting.Tests.deps.json xunit.console.dll System.Threading.RateLimiting.Tests.dll -xml testResults.xml -nologo -nocolor -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing  \r\n  Discovering: System.Threading.RateLimiting.Tests (method display = ClassAndMethod, method display options = None)\r\n  Discovered:  System.Threading.RateLimiting.Tests (found 275 test cases)\r\n  Starting:    System.Threading.RateLimiting.Tests (parallel test collections = on, max threads = 4)\r\n    System.Threading.RateLimiting.Test.ConcurrencyLimiterTests.DoesNotDeadlockCleaningUpCanceledRequestedLease_Post [FAIL]\r\n      Assert.Same() Failure\r\n      Expected: Task { Status = Running }\r\n      Actual:   Task { Status = RanToCompletion }\r\n      Stack Trace:\r\n        /_/src/libraries/System.Threading.RateLimiting/tests/ConcurrencyLimiterTests.cs(167,0): at System.Threading.RateLimiting.Test.ConcurrencyLimiterTests.DoesNotDeadlockCleaningUpCanceledRequestedLease(Action`2 attachHook)\r\n        --- End of stack trace from previous location ---\r\n  Finished:    System.Threading.RateLimiting.Tests\r\n=== TEST EXECUTION SUMMARY ===\r\n   System.Threading.RateLimiting.Tests  Total: 275, Errors: 0, Failed: 1, Skipped: 0, Time: 6.134s\r\n----- end Thu 09/28/2023 13:42:41.57 ----- exit code 1 ----------------------------------------------------------\r\n```\r\n\u003c!-- Known issue validation start --\u003e\r\n ### Known issue validation\r\n**Build: :mag_right:** https://dev.azure.com/dnceng-public/public/_build/results?buildId=421749\r\n**Error message validated:** `System.Threading.RateLimiting.Test.ConcurrencyLimiterTests.DoesNotDeadlockCleaningUpCanceledRequestedLease_Post [FAIL]`\r\n**Result validation: :x:** Known issue did not match with the provided build.\r\n**Validation performed at:** 9/29/2023 1:06:18 AM UTC\r\n\u003c!-- Known issue validation end --\u003e\r\n\u003c!--Known issue error report start --\u003e\r\n\r\n### Report\r\n#### Summary\r\n|24-Hour Hit Count|7-Day Hit Count|1-Month Count|\r\n|---|---|---|\r\n|0|0|0|\r\n\u003c!--Known issue error report end --\u003e",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOdCu7WA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5nuPz8",
                                           "createdAt":  "2023-09-29T01:04:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Error Blob\n\n```json\r\n{\r\n  \"ErrorMessage\": \"System.Threading.RateLimiting.Test.ConcurrencyLimiterTests.DoesNotDeadlockCleaningUpCanceledRequestedLease_Post [FAIL]\",\r\n  \"BuildRetry\": false,\r\n  \"ErrorPattern\": \"\",\r\n  \"ExcludeConsoleLog\": true\r\n}\r\n```\r\n\n\n### Reproduction Steps\n\n- Affected 8.0 PR: https://github.com/dotnet/runtime/pull/92762\r\n- Run: `Libraries Test Run checked coreclr windows x86 Debug`\r\n- Job: https://dev.azure.com/dnceng-public/public/_build/results?buildId=421749\u0026view=logs\u0026j=f1f3e473-935f-5de7-3348-701fec448dfb\u0026t=0644e1d9-cbee-5379-e020-5995b9f78358\u0026l=56\r\n- Artifacts: https://dev.azure.com/dnceng-public/public/_build/results?buildId=421749\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=9265494\u0026resultId=162839\u0026paneView=dotnet-dnceng.dnceng-build-release-tasks.helix-test-information-tab\r\n- Log file: https://helixre107v0xd1eu3ibi6ka.blob.core.windows.net/dotnet-runtime-refs-pull-92762-merge-7b1c426ed16c4d42ab/System.Threading.RateLimiting.Tests/1/console.20a587af.log?helixlogtype=result\r\n- Output:\r\n```\r\n===========================================================================================================\r\n\r\nC:\\h\\w\\B0F0099E\\w\\AA000950\\e\u003e\"C:\\h\\w\\B0F0099E\\p\\dotnet.exe\" exec --runtimeconfig System.Threading.RateLimiting.Tests.runtimeconfig.json --depsfile System.Threading.RateLimiting.Tests.deps.json xunit.console.dll System.Threading.RateLimiting.Tests.dll -xml testResults.xml -nologo -nocolor -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing  \r\n  Discovering: System.Threading.RateLimiting.Tests (method display = ClassAndMethod, method display options = None)\r\n  Discovered:  System.Threading.RateLimiting.Tests (found 275 test cases)\r\n  Starting:    System.Threading.RateLimiting.Tests (parallel test collections = on, max threads = 4)\r\n    System.Threading.RateLimiting.Test.ConcurrencyLimiterTests.DoesNotDeadlockCleaningUpCanceledRequestedLease_Post [FAIL]\r\n      Assert.Same() Failure\r\n      Expected: Task { Status = Running }\r\n      Actual:   Task { Status = RanToCompletion }\r\n      Stack Trace:\r\n        /_/src/libraries/System.Threading.RateLimiting/tests/ConcurrencyLimiterTests.cs(167,0): at System.Threading.RateLimiting.Test.ConcurrencyLimiterTests.DoesNotDeadlockCleaningUpCanceledRequestedLease(Action`2 attachHook)\r\n        --- End of stack trace from previous location ---\r\n  Finished:    System.Threading.RateLimiting.Tests\r\n=== TEST EXECUTION SUMMARY ===\r\n   System.Threading.RateLimiting.Tests  Total: 275, Errors: 0, Failed: 1, Skipped: 0, Time: 6.134s\r\n----- end Thu 09/28/2023 13:42:41.57 ----- exit code 1 ----------------------------------------------------------\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ecarlossanlop\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `blocking-clean-ci`, `Known Build Error`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-09-29T01:04:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5n68P7",
                                           "createdAt":  "2023-10-02T18:09:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "@BrennanConroy are you tracking these failures in 8? ",
                                           "updatedAt":  "2023-10-02T18:09:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5n7EBg",
                                           "createdAt":  "2023-10-02T18:30:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "BrennanConroy",
                                           "body":  "I am for 9. I guess we\u0027ll want to backport to 8 once we fix it?",
                                           "updatedAt":  "2023-10-02T18:30:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5n7GNK",
                                           "createdAt":  "2023-10-02T18:32:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "@carlossanlop can comment whether its disrupting runs on 8 for the fix to be backported ",
                                           "updatedAt":  "2023-10-02T18:32:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc50K7tY",
                                           "createdAt":  "2024-02-16T18:11:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffschwMSFT",
                                           "body":  "removing blocking-clean-ci as it has not been hit in 30 days\r\n\r\n24-Hour Hit Count | 7-Day Hit Count | 1-Month Count\r\n-- | -- | --\r\n0 | 0 | 0",
                                           "updatedAt":  "2024-02-16T18:11:41Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "[8.0] \u0027RanToCompletion\u0027 failure in System.Threading.RateLimiting.Test.ConcurrencyLimiterTests.DoesNotDeadlockCleaningUpCanceledRequestedLease_Post",
        "labels":  [
                       "area-System.Threading",
                       "Known Build Error"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/93234",
        "createdAt":  "2023-10-09T15:31:09Z",
        "number":  93234,
        "author":  "kouvel",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODM827A==",
                          "nodes":  [
                                        {
                                            "content":  "HEART",
                                            "user":  "ericsampson",
                                            "createdAt":  "2023-12-01T19:18:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mriehm",
                                            "createdAt":  "2025-08-27T23:15:18Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2025-09-04T19:09:13Z",
        "body":  "- Currently, the thread pool allows too many threads to spin-wait simultaneously, which in some scenarios causes higher CPU usage when similar performance can be achieved with fewer spin-waiters and less CPU. There are several scenarios where the `ThreadPool_UnfairSemaphoreSpinLimit` config var is used to disable spin-waiting as a result. Part of the problem in some cases is too many thread requests (https://github.com/dotnet/runtime/issues/93028), but there are also other cases where there is too much spin-waiting.\r\n- On larger machines, it may be possible to find a reasonably high limit that does not regress performance when the thread pool is heavily loaded, and allows for similar performance at lower loads with lower CPU usage\r\n- On smaller machines and containers, hill climbing may substantially increase the active number of worker threads beyond the processor count. Spin-waiting on more threads than the processor count is unlikely to be beneficial.\r\n- The limit of simultaneous spin-waiters should be made configurable. There are many scenarios where spin-waiting helps but either the machine or the thread pool is not fully loaded, and tuning for that with the existing `ThreadPool_UnfairSemaphoreSpinLimit` config var does not yield the best results.\r\n- There may be opportunities for automatically tuning the spin-waiting using some types of feedback, for instance spin-waits failing very frequently may indicate that spin-waiting is less beneficial. This kind of heuristic can be challenging to balance though, there can be tradeoffs, and auto-tuning by default may regress some scenarios. Could either keep the heuristic simpler and more conservative to limit the chance of regressions along with an opt-out, or explore a less conservative solution and make it opt-in for folks to try when experiencing high CPU usage due to spin-waiting.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOaIAzHw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5ogDMf",
                                           "createdAt":  "2023-10-09T15:31:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n- Currently, the thread pool allows too many threads to spin-wait simultaneously, which in some scenarios causes higher CPU usage when similar performance can be achieved with fewer spin-waiters\r\n- On larger machines, it may be possible to find a reasonably high limit that does not regress performance when the thread pool is heavily loaded\r\n- On smaller machines and containers, hill climbing may substantially increase the active number of worker threads beyond the processor count. Spin-waiting on more threads than the processor count is unlikely to be beneficial.\r\n- The limit of simultaneous spin-waiters should be made configurable. There are many scenarios where spin-waiting helps but either the machine or the thread pool is not fully loaded, and tuning for that with the existing `ThreadPool_UnfairSemaphoreSpinLimit` config var does not yield the best results.\r\n- There may be opportunities for automatically tuning the spin-waiting using some types of feedback. There can be tradeoffs and auto-tuning by default may regress some scenarios. Making an opt-in version available in the future may be useful for folks to try when experiencing high CPU usage due to spin-waiting.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ekouvel\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003ekouvel\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e9.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-10-09T15:31:16Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Reduce the limit of simultaneous spin-waiters in the thread pool",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/93265",
        "createdAt":  "2023-10-09T23:36:04Z",
        "number":  93265,
        "author":  "kouvel",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-04T19:08:35Z",
        "body":  "- The thread pool is capable of releasing threads very quickly for a burst of work. Even with spin-waiting disabled, already-created threads can be released at a rate in the order of one per ~10-15 microseconds, or ~60-100 per millisecond, as long as processors are available for scheduling those threads immediately.\r\n- Services often get work in waves (or otherwise the thread pool often does), and services often don\u0027t push the CPU to its limits to avoid latency issues. There can be various types of work items queued to the thread pool, some of which that prefer latency, and others that prefer lower CPU usage. In cases where the thread pool frequently runs out of work, a burst of work may be more efficiently handled with fewer threads than are currently released. There can be tradeoffs, for instance running a short burst of work items on fewer threads may lead to that work taking more wall-clock time to complete, while using less CPU time. In other cases, due to contention and other multithreading bottlenecks, a short burst of work run on fewer threads may actually lead to that work taking less wall-clock time to complete. And in yet other cases where the bursts of work are likely larger, releasing threads quickly may be most optimal.\r\n- Evaluate opportunities for slowing down the release of threads using some types of feedback, for instance, a thread that is released and does not find any work may indicate that there are a sufficient number of threads to handle the current workload, and may trigger relatively slight throttling of further thread releases, balanced by other opposing feedback criteria.\r\n- As there may be tradeoffs involved, either the heuristics should be conservative enough to enable by default, or an opt-in solution may be considered to enable folks experiencing the relevant issues to try it out.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOaIzYyg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5ojNjK",
                                           "createdAt":  "2023-10-09T23:36:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n- The thread pool is capable of releasing threads very quickly for a burst of work. Even with spin-waiting disabled, already-created threads can be released at a rate in the order of one per ~10-15 microseconds, or ~60-100 per millisecond, as long as processors are available for scheduling those threads immediately.\r\n- Services often get work in waves (or otherwise the thread pool often does), and services often don\u0027t push the CPU to its limits to avoid latency issues. There can be various types of work items queued to the thread pool, some of which that prefer latency, and others that prefer lower CPU usage. In cases where the thread pool frequently runs out of work, a burst of work may be more efficiently handled with fewer threads than are currently released. There can be tradeoffs, for instance running a short burst of work items on fewer threads may lead to that work taking more wall-clock time to complete, while using less CPU time. In other cases, due to contention and other multithreading bottlenecks, a short burst of work run on fewer threads may actually lead to that work taking less wall-clock time to complete. And in yet other cases where the bursts of work are likely larger, releasing threads quickly may be most optimal.\r\n- Evaluate opportunities for slowing down the release of threads using some types of feedback, for instance, a thread that is released and does not find any work may indicate that there are a sufficient number of threads to handle the current workload, and may trigger relatively slight throttling of further thread releases, balanced by other opposing feedback criteria.\r\n- As there may be tradeoffs involved, either the heuristics should be conservative enough to enable by default, or an opt-in solution may be considered to enable folks experiencing the relevant issues to try it out.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ekouvel\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e9.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-10-09T23:36:08Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Evaluate opportunities for slowing down the rate at which threads are released in the thread pool, informed by feedback criteria",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/94727",
        "createdAt":  "2023-11-14T18:05:33Z",
        "number":  94727,
        "author":  "colejohnson66",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODBwQdg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "timcassell",
                                            "createdAt":  "2024-04-08T11:04:42Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hasnik",
                                            "createdAt":  "2025-04-26T19:19:37Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2024-05-02T21:35:01Z",
        "body":  "### Background and motivation\r\n\r\nNormally, one would use `Volatile.Read` and `Volatile.Write` to handle interlocking of numeric values between tasks. Sometimes it\u0027s beneficial to use enums in these cases, but we are prevented from doing so due to limitations in the API. Currently, one must cast their enum values back and forth when reading and writing:\r\n\r\n```csharp\r\nMyEnum nextState = default;\r\nTask task = Task.Run(() =\u003e\r\n{\r\n    ...\r\n    Volatile.Write(ref nextState, success ? (int)MyEnum.SuccessState : (int)MyEnum.FailureState);\r\n});\r\n\r\n...\r\n\r\ntask.Wait();\r\nMyEnum newState = (MyEnum)Volatile.Read(ref nextState);\r\n```\r\n\r\nHaving overloads that take enums would be beneficial in these cases to avoid issues that occur when casting enum values (such as using incorrect numeric or enum types). For example, a `ulong` backed enum _must_ be cast to either `long` or `ulong` lest you lose 32 bits of data. Casting to `int` above would throw away such data.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Threading;\r\n\r\npublic static class Volatile\r\n{\r\n    public static TEnum ReadEnum\u003cTEnum\u003e(ref TEnum location)\r\n        where TEnum : struct, Enum;\r\n    public static void WriteEnum\u003cTEnum\u003e(ref TEnum location, TEnum value)\r\n        where TEnum : struct, Enum;\r\n}\r\n```\r\n\r\nIn each function, `sizeof(TEnum)` would be used to determine the size of the enum. Then `Unsafe.As` and normal `Volatile` methods would be used to massage out the value. For example, an implementation of `ReadEnum` that only handled single-byte-backed enums would look like\r\n\r\n```csharp\r\npublic static TEnum ReadEnum\u003cTEnum\u003e(ref TEnum location)\r\n    where TEnum : struct, Enum\r\n{\r\n    if (sizeof(TEnum) == sizeof(byte))\r\n    {\r\n        byte value = Volatile.Read(ref Unsafe.As\u003cTEnum, byte\u003e(ref location));\r\n        return Unsafe.As\u003cbyte, TEnum\u003e(ref value);\r\n    }\r\n\r\n    throw new NotSupportedException(\"Unsupported enum underlying type.\");\r\n}\r\n```\r\n\r\n### API Usage\r\n\r\n```csharp\r\nMyEnum nextState = default;\r\nTask task = Task.Run(() =\u003e\r\n{\r\n    ...\r\n    Volatile.WriteEnum(ref nextState, success ? MyEnum.SuccessState : MyEnum.FailureState);\r\n});\r\n\r\n...\r\n\r\ntask.Wait();\r\nMyEnum newState = Volatile.ReadEnum(ref nextState);\r\n```\r\n\r\n### Alternative Designs\r\n\r\nAlternatively, `Volatile.Read\u003cT\u003e(ref T)` and `Volatile.Write\u003cT\u003e(ref T, T)` can have their generic constraint removed and replaced with runtime checks (a la #99205 and #100842):\r\n\r\n```csharp\r\nnamespace System.Threading;\r\n\r\npublic static class Volatile\r\n{\r\n    public static T Read\u003cT\u003e(ref T location)\r\n        /* where T : class */;\r\n    public static void Write\u003cT\u003e(ref T location, T value)\r\n        /* where T : class */;\r\n}\r\n```\r\n\r\nIf `T : class`, it operates the same. However, if `T : struct, Enum`, it would now operate as proposed. This is a non-breaking change, as it relaxes a generic constraint to allow previously non-compilable code.\r\n\r\nIt could be extended even further to work on *any* unmanaged struct that\u0027s eight bytes or fewer. In other words, `Volatile.Read(ref myFourByteStruct)` would now be legal.\r\n\r\nThis alternate design is probably undesirable. Despite being non-breaking, it can be risky. Say I have a four-byte struct and use `Volatile.(Read|Write)` on it. If, in the future, I change it to be, say, 12 bytes large, the code will still compile without warnings, but would always throw at runtime. If this alternate design is chosen, a source analyzer *should* be included. It would detect `T` types that are greater than eight bytes and raise a compile-time warning.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHObBWbkA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5r7219",
                                           "createdAt":  "2023-11-14T18:09:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "colejohnson66",
                                           "body":  "Ideally, this would just be `Read` and `Write`, but because C# does not support overloading on generic constraints, this would interfere with the existing `T Read\u003cT\u003e(ref T) where T:class` and `void Write\u003cT\u003e(ref T, T) where T:class` methods",
                                           "updatedAt":  "2023-11-14T18:09:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5r8XXx",
                                           "createdAt":  "2023-11-14T19:05:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODdYqqA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2023-11-14T20:47:23Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "PaulusParssinen",
                                                                               "createdAt":  "2023-11-15T12:16:16Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "mikechristiansenvae",
                                                                               "createdAt":  "2023-11-16T15:32:07Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MineCake147E",
                                                                               "createdAt":  "2023-12-07T04:06:48Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "timcassell",
                                                                               "createdAt":  "2024-04-08T11:04:55Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  5
                                                         },
                                           "author":  "DaZombieKiller",
                                           "body":  "These APIs can be implemented with `sizeof(T)` dispatch rather than `typeof(T).GetEnumUnderlyingType()`:\r\n```cs\r\nstatic unsafe T ReadEnum\u003cT\u003e(ref T location)\r\n    where T : struct, Enum\r\n{\r\n    T result;\r\n#pragma warning disable 8500\r\n    if (sizeof(T) == sizeof(byte))\r\n        *(byte*)\u0026result = Volatile.Read(ref Unsafe.As\u003cT, byte\u003e(ref location));\r\n    else if (sizeof(T) == sizeof(ushort))\r\n        *(ushort*)\u0026result = Volatile.Read(ref Unsafe.As\u003cT, ushort\u003e(ref location));\r\n    else if (sizeof(T) == sizeof(uint))\r\n        *(uint*)\u0026result = Volatile.Read(ref Unsafe.As\u003cT, uint\u003e(ref location));\r\n    else if (sizeof(T) == sizeof(ulong))\r\n        *(ulong*)\u0026result = Volatile.Read(ref Unsafe.As\u003cT, ulong\u003e(ref location));\r\n    else\r\n        throw new NotSupportedException();\r\n    return result;\r\n#pragma warning restore 8500\r\n}\r\n```\r\nWhich provides [much nicer codegen](https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA0AXEBDAzgWwB8ABAJgEYBYAKGIAYACY8gOgBUALWbAEwEsAdgHMA3DXpNWAJQCuAjH3wwWAYQj4ADnwA2MKAGU9ANz5gYuMdRoBtfR2xQNAGWzAWs+YuUApPhgDiMAJ6pgAUGACeGjAQAGahAEIRGDAAogIy+ACUWQC64uRIDHK42LEwDGwMUjC86ZkAPGwAfKGwsZUM2hBg2AoQAlk0DCMMAO4cehVVIAy4GFAyYBhoDPX4NADew6NVsLgy2hiWAMQaUNhC+NjjDgKCQgz8pcC6DAAcAKx0dDsjfB1Qrg+AAvGLxNhZBgAXmhc1B4NCwGSMByf1GIwAVEiUZisgAyfaHDAwhgANQg2j6OmUNV4bRgHQAqgJSuUWABBXBNVbIlKtdpdHrUgY5SwYmDaXAVAEMIEIuKhSEwuHAsGKmS4DjQDBo6gYjHYzXaqAYPGE8zE0kUqkKXTuWo8BnM1llZRcnnFLU6gWMoW9fqDLLi0aS6UMWXy9UQqGw+HR0IyQS6ob6g1YxPJ81Eo7WynU+10p2Clls93ctirJPyX0dboBvii4PosMywFqxHKuMdjXdYR69MZw4DITZy25uE2gu0x3Ohilt2citVvtCWv+kVBkMjVvojEYLgQMYMYLHgByEAw+hkGg0OpgPFSCDMGkDoWbaZGxAA7Awc8caDOC4rhuMY7geP9zAwaAKi+H4aAAXxoGggkyBgkhSdYGFmPkKk2BCgA) and doesn\u0027t rely on the very recent (.NET 8) [`GetEnumUnderlyingType` optimization](https://github.com/dotnet/runtime/pull/71685), so you get the nice codegen on .NET 7 (and probably Mono) too.",
                                           "updatedAt":  "2023-11-14T19:08:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5r9eDg",
                                           "createdAt":  "2023-11-14T20:55:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "colejohnson66",
                                           "body":  "Didn\u0027t even look at codegen, or consider optimizations. It was just a proof-of-concept, but you\u0027re right. However, your usage of pointer magic to write the result (instead of `Unsafe.As` to read it) makes no difference to codegen. The only important part is using `sizeof`. It\u0027s all optimized down to:\r\n\r\n```assembly\r\n; bytes\r\nmovzx eax, byte ptr [rcx]\r\nret\r\n\r\n; words\r\nmovzx eax, word ptr [rcx]\r\ncwde\r\nret\r\n\r\n; double-words\r\nmov eax, [rcx]\r\nret\r\n\r\n; quad-words\r\nmov rax, [rcx]\r\nret\r\n```",
                                           "updatedAt":  "2023-11-14T20:58:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5r904O",
                                           "createdAt":  "2023-11-14T21:42:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODMnkZw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2023-11-14T22:03:28Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "DaZombieKiller",
                                           "body":  "Related https://github.com/dotnet/runtime/issues/65184\r\n\r\n\u003e However, your usage of pointer magic to write the result (instead of `Unsafe.As` to read it) makes no difference to codegen.\r\n\r\nYeah, that was just an attempt to make the implementation smaller (should have a little less IL too).",
                                           "updatedAt":  "2023-11-14T21:42:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5sFZuQ",
                                           "createdAt":  "2023-11-15T22:22:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\r\n\r\nNormally, one would use `Volatile.Read` and `Volatile.Write` to handle interlocking of numeric values between tasks. Sometimes it\u0027s beneficial to use enums in these cases, but we are prevented from doing so due to limitations in the API. Currently, one must cast their enum values back and forth when reading and writing:\r\n\r\n```csharp\r\nMyEnum nextState = default;\r\nTask task = Task.Run(() =\u003e\r\n{\r\n    ...\r\n    Volatile.Write(ref nextState, success ? (int)MyEnum.SuccessState : (int)MyEnum.FailureState);\r\n});\r\n\r\n...\r\n\r\ntask.Wait();\r\nMyEnum newState = (MyEnum)Volatile.Read(ref nextState);\r\n```\r\n\r\nHaving overloads that take enums would be beneficial in these cases to avoid issues that occur when casting enum values (such as using incorrect numeric or enum types). For example, a `ulong` backed enum _must_ be cast to either `long` or `ulong` lest you lose 32 bits of data. Casting to `int` above would throw away such data.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Threading;\r\n\r\npublic static class Volatile\r\n{\r\n    public static TEnum ReadEnum\u003cTEnum\u003e(ref TEnum location)\r\n        where TEnum : struct, Enum;\r\n    public static void WriteEnum\u003cTEnum\u003e(ref TEnum location, TEnum value)\r\n        where TEnum : struct, Enum;\r\n}\r\n```\r\n\r\nIn each function, `typeof(TEnum).GetEnumUnderlyingType()` would be used to determine the size of the enum. Then `Unsafe.As` and normal `Volatile` methods would be used to massage out the value. For example, an implementation of `ReadEnum` that only handled single-byte-backed enums would look like\r\n\r\n```csharp\r\npublic static TEnum ReadEnum\u003cTEnum\u003e(ref TEnum location)\r\n    where TEnum : struct, Enum\r\n{\r\n    Type memberType = typeof(TEnum).GetEnumUnderlyingType();\r\n\r\n    if (memberType == typeof(byte) || memberType == typeof(sbyte))\r\n    {\r\n        byte value = Volatile.Read(ref Unsafe.As\u003cTEnum, byte\u003e(ref location));\r\n        return Unsafe.As\u003cbyte, TEnum\u003e(ref value);\r\n    }\r\n\r\n    throw new NotSupportedException(\"Unsupported enum underlying type.\");\r\n}\r\n```\r\n\r\n### API Usage\r\n\r\n```csharp\r\nMyEnum nextState = default;\r\nTask task = Task.Run(() =\u003e\r\n{\r\n    ...\r\n    Volatile.WriteEnum(ref nextState, success ? MyEnum.SuccessState : MyEnum.FailureState);\r\n});\r\n\r\n...\r\n\r\ntask.Wait();\r\nMyEnum newState = Volatile.ReadEnum(ref nextState);\r\n```\r\n\r\n### Alternative Designs\r\n\r\nLeave as is: use memory barriers or cast enums back and forth between numeric types.\r\n\r\n### Risks\r\n\r\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ecolejohnson66\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading`, `untriaged`, `needs-area-label`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-11-15T22:22:03Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "[API Proposal]: `Volatile.(Read|Write)Enum`",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/95794",
        "createdAt":  "2023-12-08T17:06:34Z",
        "number":  95794,
        "author":  "piju3",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-05-02T21:34:39Z",
        "body":  "### Description\n\nWhen debugging inside WSL, a single thread running an infinite loop appears to completely block the main thread from execution.\n\n### Reproduction Steps\n\nIn Visual Studio, create a new console project with this code:\r\n```c#\r\nConsole.WriteLine(\"Started\");\r\nnew Thread(() =\u003e\r\n{\r\n    while (true){}\r\n}).Start();\r\n\r\nwhile (true)\r\n{\r\n    Console.WriteLine(\"Main thread\");\r\n    Thread.Sleep(1000);\r\n}\r\n\r\n```\r\nThen run on the WSL2 debugging target (if you don\u0027t see it, [follow the steps](https://learn.microsoft.com/en-us/visualstudio/debugger/debug-dotnet-core-in-wsl-2?view=vs-2022)).\n\n### Expected behavior\n\n\"Main thread\" appears approximately once per second, indefinitely.\n\n### Actual behavior\n\n\"Main thread\" appears 5 times (it appears to be exactly 5 every time) then stops indefinitely.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nModifying the loop to include `Thread.Sleep(0)` appears to work around the issue. Running the project on the Windows target or directly inside WSL2 does not show the issue either.\n\n### Configuration\n\nTested on Windows 11 (latest build) on x64, Visual Studio 17.8, happens on both .NET 8 and .NET 7, using both Ubuntu and OpenSUSE as the WSL distros.\n\n### Other information\n\nA similar case appears to have been reported here: [c# - Threads with low priority prevents other threads with normal priority from execution - Stack Overflow](https://stackoverflow.com/questions/62809155/threads-with-low-priority-prevents-other-threads-with-normal-priority-from-execu)",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHObh9nvQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5uH2e9",
                                           "createdAt":  "2023-12-08T17:18:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nWhen debugging inside WSL, a single thread running an infinite loop appears to completely block the main thread from execution.\n\n### Reproduction Steps\n\nIn Visual Studio, create a new console project with this code:\r\n```c#\r\nConsole.WriteLine(\"Started\");\r\nnew Thread(() =\u003e\r\n{\r\n    while (true){}\r\n}).Start();\r\n\r\nwhile (true)\r\n{\r\n    Console.WriteLine(\"Main thread\");\r\n    Thread.Sleep(1000);\r\n}\r\n\r\n```\r\nThen run on the WSL2 debugging target (if you don\u0027t see it, [follow the steps](https://learn.microsoft.com/en-us/visualstudio/debugger/debug-dotnet-core-in-wsl-2?view=vs-2022)).\n\n### Expected behavior\n\n\"Main thread\" appears approximately once per second, indefinitely.\n\n### Actual behavior\n\n\"Main thread\" appears 5 times (it appears to be exactly 5 every time) then stops indefinitely.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nModifying the loop to include `Thread.Sleep(0)` appears to work around the issue. Running the project on the Windows target or directly inside WSL2 does not show the issue either.\n\n### Configuration\n\nTested on Windows 11 (latest build) on x64, Visual Studio 17.8, happens on both .NET 8 and .NET 7, using both Ubuntu and OpenSUSE as the WSL distros.\n\n### Other information\n\nA similar case appears to have been reported here: [c# - Threads with low priority prevents other threads with normal priority from execution - Stack Overflow](https://stackoverflow.com/questions/62809155/threads-with-low-priority-prevents-other-threads-with-normal-priority-from-execu)\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003epiju3\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-12-08T17:18:24Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "WSL debugger: busy thread stops execution of other threads",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/95800",
        "createdAt":  "2023-12-08T18:59:26Z",
        "number":  95800,
        "author":  "piju3",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC0kb1g==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "neon-sunset",
                                            "createdAt":  "2023-12-08T21:54:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Xor-el",
                                            "createdAt":  "2023-12-09T18:06:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "manandre",
                                            "createdAt":  "2023-12-09T19:48:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "saul",
                                            "createdAt":  "2023-12-11T10:08:25Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "karakasa",
                                            "createdAt":  "2023-12-11T11:03:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "omariom",
                                            "createdAt":  "2023-12-11T22:45:35Z"
                                        }
                                    ],
                          "totalCount":  6
                      },
        "updatedAt":  "2024-07-08T17:57:26Z",
        "body":  "### Background and motivation\n\nOn many platforms (including at least Windows, Linux and FreeBSD), a system thread can define a \"name\" for itself, which can be read by other processes. These names are useful for external tools such as debuggers or system activity monitors (like *htop*), and can help identify what internal tasks are using most processor time.\r\n\t\r\nIn Linux and FreeBSD this corresponds to *pthread_setname_np* and *pthread_getname_np* (or, in Linux, the */proc/[tid]/comm* file). In Windows this corresponds to *SetThreadDescription* and *GetThreadDescription*.\r\n\r\n.NET already has the Thread.Name property for internal threads, which sets those properties for the corresponding operating system thread. It also has Process.ProcessName which can get the equivalent name for any system process. But there is no corresponding ProcessThread.ThreadName.\r\n\t\r\nIt\u0027s true that threads are a low level tool, and most programmers should generally not deal with them directly, but there are still many situations where they might be important to deal with. \r\nAs an example, I recently had to write a custom \"CPU monitor\" for a legacy application that manually spawns multiple threads, and ended up implementing this method myself.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Diagnostics\r\n{\r\n    public class ProcessThread {\r\n       public string ThreadName {get;}\r\n    }\r\n}\r\n```\r\nIf a platform does not have this concept, the method would just throw PlatformNotSupportedException.\n\n### API Usage\n\n```csharp\r\nusing System.Diagnostics;\r\nvar currentThreads = Process.GetCurrentProcess().Threads.Cast\u003cProcessThread\u003e();\r\nforeach (var thread in currentThreads)\r\n{\r\n    Console.WriteLine(thread.ThreadName);\r\n}\r\n```\n\n### Alternative Designs\n\n- Platforms that don\u0027t have a thread name property could return null instead of throwing an exception.\r\n- I named the property ThreadName for consistency with the existing Process.ProcessName, alternatively just \"Name\" would be fine.\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOccY-jQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5uIUbT",
                                           "createdAt":  "2023-12-08T18:59:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nOn many platforms (including at least Windows, Linux and FreeBSD), a system thread can define a \"name\" for itself, which can be read by other processes. These names are useful for external tools such as debuggers or system activity monitors (like *htop*), and can help identify what internal tasks are using most processor time.\r\n\t\r\nIn Linux and FreeBSD this corresponds to *pthread_setname_np* and *pthread_getname_np* (or, in Linux, the */proc/[tid]/comm* file). In Windows this corresponds to *SetThreadDescription* and *GetThreadDescription*.\r\n\r\n.NET already has the Thread.Name property for internal threads, which sets those properties for the corresponding operating system thread. It also has Process.ProcessName which can get the equivalent name for any system process. But there is no corresponding ProcessThread.ThreadName.\r\n\t\r\nIt\u0027s true that threads are a low level tool, and most programmers should generally not deal with them directly, but there are still many situations where they might be important to deal with. \r\nAs an example, I recently had to write a custom \"CPU monitor\" for a legacy application that manually spawns multiple threads, and ended up implementing this method myself.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Diagnostics\r\n{\r\n    public class ProcessThread {\r\n       public string ThreadName {get;}\r\n    }\r\n}\r\n```\r\nIf a platform does not have this concept, the method would just throw PlatformNotSupportedException.\n\n### API Usage\n\n```csharp\r\nusing System.Diagnostics;\r\nvar currentThreads = Process.GetCurrentProcess().Threads.Cast\u003cProcessThread\u003e();\r\nforeach (var thread in currentThreads)\r\n{\r\n    Console.WriteLine(thread.ThreadName);\r\n}\r\n```\n\n### Alternative Designs\n\n- Platforms that don\u0027t have a thread name property could return null instead of throwing an exception.\r\n- I named the property ThreadName for consistency with the existing Process.ProcessName, alternatively just \"Name\" would be fine.\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003epiju3\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-12-08T18:59:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5xxj6N",
                                           "createdAt":  "2024-01-24T19:53:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "emaste",
                                           "body":  "\u003e Platforms that don\u0027t have a thread name property could return null instead of throwing an exception.\r\n\r\nIn my experience thread names are primarily a diagnostic/debugging aid, and so would just silently ignore the inability to set a thread name.",
                                           "updatedAt":  "2024-01-24T19:53:36Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[API Proposal]: ProcessThread.ThreadName",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/95849",
        "createdAt":  "2023-12-11T09:30:48Z",
        "number":  95849,
        "author":  "AloisKraus",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-03T21:01:19Z",
        "body":  "\r\n### Description\r\n\r\nNormalized Spinwait has evolved a lot. The current state that it measured the pause latency on the finalizer thread at most every 4s\r\n\r\n- Update spin-wait pause/yield normalization #55295\r\n\r\nThat should work reasonably well on machines even with different C-States. \r\n\r\n### Regression?\r\nNo\r\n\r\n### Data\r\nThe pause instruction latency is defined in cycles. This means it is dependant on the current CPU Frequency which on todays CPUs has a lot of variability. It is in the range of 700 Mhz - 5 GHz which is a factor 7 apart. With the introduction of Efficiency Cores variability has increased again because the latency of the pause instruction is NOT a single number for a CPU generation anymore. Instead it is a different number for P and E Cores. \r\n\r\nIf you pin the CPU Frequency with a custom power profile to 2 GHz and execute pause affinitized on a single core you get these numbers on an Intel I7 13700 (Raptor Lake).\r\n\r\n![image](https://github.com/dotnet/runtime/assets/101576413/036a3def-b6f4-460a-8318-aed43be5f7a0)\r\n\r\nTest Application is from  https://github.com/Alois-xx/OpenMPTest\r\n\r\n```\r\nC:\\source\\vc22\\OpenMPTest_1.0.0.2\u003eOpenMPTest.exe -pause \r\nPause Latency CPU[0]: 92.0 ns\r\nPause Latency CPU[1]: 91.9 ns\r\nPause Latency CPU[2]: 92.0 ns\r\nPause Latency CPU[3]: 91.8 ns\r\nPause Latency CPU[4]: 91.9 ns\r\nPause Latency CPU[5]: 91.9 ns\r\nPause Latency CPU[6]: 91.7 ns\r\nPause Latency CPU[7]: 91.8 ns\r\nPause Latency CPU[8]: 92.3 ns\r\nPause Latency CPU[9]: 91.7 ns\r\nPause Latency CPU[10]: 92.1 ns\r\nPause Latency CPU[11]: 91.6 ns\r\nPause Latency CPU[12]: 92.0 ns\r\nPause Latency CPU[13]: 91.8 ns\r\nPause Latency CPU[14]: 91.8 ns\r\nPause Latency CPU[15]: 92.1 ns\r\nPause Latency CPU[16]: 31.3 ns\r\nPause Latency CPU[17]: 31.2 ns\r\nPause Latency CPU[18]: 31.6 ns\r\nPause Latency CPU[19]: 31.2 ns\r\nPause Latency CPU[20]: 31.3 ns\r\nPause Latency CPU[21]: 31.3 ns\r\nPause Latency CPU[22]: 31.2 ns\r\nPause Latency CPU[23]: 31.2 ns\r\n```\r\nAs you can see the latency of the E Cores 16-23 with 31ns or 15 cycles at 2 GHz is 3 times lower compared to the P Cores 0-15 with 91ns or 46 cycles at 2 GHz Cores. \r\n\r\nThe latency for the P-Cores matches Cascade Lake with 40ns: \r\n![image](https://github.com/dotnet/runtime/assets/101576413/c0e87082-55cc-404e-946a-e9f754a2fc00)\r\n\r\n\r\n### Analysis\r\n\r\nMy question is is it sufficient to define a single pause spin latency on such CPUs or should it be two numbers which are used depending on which core the load is currently running on? \r\n\r\nEfficiency Cores are ca. 2.5-3 times slower so I am not sure why Intel did decrease the pause latency for the E-Cores by a factor 3. If a comparable workload is running on all cores the different timing might lead to interesting yet to be discovered effects. With the latest Xeon CPUs a similar concept of High Priority Cores where some cores are running at a higher frequency than the others might cause also issues. \r\nWith SpeedShift/Step the CPU frequency can change up to a factor 7 within 1ms/30ms so I am not sure if we ever can arrive at a \"right\" value and we should give up trying to generate better spin counts. ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOg5CF7Q==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5uSadz",
                                           "createdAt":  "2023-12-11T15:34:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n\r\n### Description\r\n\r\nNormalized Spinwait has evolved a lot. The current state that it measured the pause latency on the finalizer thread at most every 4s\r\n\r\n- Update spin-wait pause/yield normalization #55295\r\n\r\nThat should work reasonably well on machines even with different C-States. \r\n\r\n### Regression?\r\nNo\r\n\r\n### Data\r\nThe pause instruction latency is defined in cycles. This means it is dependant on the current CPU Frequency which on todays CPUs has a lot of variability. It is in the range of 700 Mhz - 5 GHz which is a factor 7 apart. With the introduction of Efficiency Cores variability has increased again because the latency of the pause instruction is NOT a single number for a CPU generation anymore. Instead it is a different number for P and E Cores. \r\n\r\nIf you pin the CPU Frequency with a custom power profile to 2 GHz and execute pause affinitized on a single core you get these numbers on an Intel I7 13700 (Raptor Lake).\r\n\r\n![image](https://github.com/dotnet/runtime/assets/101576413/036a3def-b6f4-460a-8318-aed43be5f7a0)\r\n\r\nTest Application is from  https://github.com/Alois-xx/OpenMPTest\r\n\r\n```\r\nC:\\source\\vc22\\OpenMPTest_1.0.0.2\u003eOpenMPTest.exe -pause \r\nPause Latency CPU[0]: 92.0 ns\r\nPause Latency CPU[1]: 91.9 ns\r\nPause Latency CPU[2]: 92.0 ns\r\nPause Latency CPU[3]: 91.8 ns\r\nPause Latency CPU[4]: 91.9 ns\r\nPause Latency CPU[5]: 91.9 ns\r\nPause Latency CPU[6]: 91.7 ns\r\nPause Latency CPU[7]: 91.8 ns\r\nPause Latency CPU[8]: 92.3 ns\r\nPause Latency CPU[9]: 91.7 ns\r\nPause Latency CPU[10]: 92.1 ns\r\nPause Latency CPU[11]: 91.6 ns\r\nPause Latency CPU[12]: 92.0 ns\r\nPause Latency CPU[13]: 91.8 ns\r\nPause Latency CPU[14]: 91.8 ns\r\nPause Latency CPU[15]: 92.1 ns\r\nPause Latency CPU[16]: 31.3 ns\r\nPause Latency CPU[17]: 31.2 ns\r\nPause Latency CPU[18]: 31.6 ns\r\nPause Latency CPU[19]: 31.2 ns\r\nPause Latency CPU[20]: 31.3 ns\r\nPause Latency CPU[21]: 31.3 ns\r\nPause Latency CPU[22]: 31.2 ns\r\nPause Latency CPU[23]: 31.2 ns\r\n```\r\nAs you can see the latency of the E Cores 16-23 with 31ns or 15 cycles at 2 GHz is 3 times lower compared to the P Cores 0-15 with 91ns or 46 cycles at 2 GHz Cores. \r\n\r\nThe latency for the P-Cores matches Cascade Lake with 40ns: \r\n![image](https://github.com/dotnet/runtime/assets/101576413/c0e87082-55cc-404e-946a-e9f754a2fc00)\r\n\r\n\r\n### Analysis\r\n\r\nMy question is is it sufficient to define a single pause spin latency on such CPUs or should it be two numbers which are used depending on which core the load is currently running on? \r\n\r\nEfficiency Cores are ca. 2.5-3 times slower so I am not sure why Intel did decrease the pause latency for the E-Cores by a factor 3. If a comparable workload is running on all cores the different timing might lead to interesting yet to be discovered effects. With the latest Xeon CPUs a similar concept of High Priority Cores where some cores are running at a higher frequency than the others might cause also issues. \r\nWith SpeedShift/Step the CPU frequency can change up to a factor 7 within 1ms/30ms so I am not sure if we ever can arrive at a \"right\" value and we should give up trying to generate better spin counts. \n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eAloisKraus\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `tenet-performance`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-12-11T15:34:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5vAqoW",
                                           "createdAt":  "2023-12-19T09:53:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "cc: @kouvel ",
                                           "updatedAt":  "2023-12-19T09:53:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc58PkkX",
                                           "createdAt":  "2024-04-30T06:13:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AloisKraus",
                                           "body":  "Any update on this, or do no expect this to be an issue? ",
                                           "updatedAt":  "2024-04-30T06:13:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6DkIXt",
                                           "createdAt":  "2024-07-03T21:01:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "we havent focused on optimizing for P/E cores yet. We plan to look into these in a future release. ",
                                           "updatedAt":  "2024-07-03T21:01:18Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Normalized Spinwait on CPUs with P/E Cores",
        "labels":  [
                       "area-System.Threading",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/96351",
        "createdAt":  "2023-12-29T04:09:15Z",
        "number":  96351,
        "author":  "drawxy",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-03T20:30:22Z",
        "body":  "I have upgraded my web api service from .net framework 4.7.2 to asp .net core 6.0. And I choose Kestrel as my web server, but there is a performance regression. There are many async opertion in my controller action. The CPU is not fully used in the new version, and the CPU time almost below 20% even if I increase the thread count with ThreadPool.SetMinThreads. However, it can reach to 70% in original version. My code looks like this:\r\n\r\n    \r\n        [HttpPost(\"/action\")]\r\n        public async Task\u003cActionResult\u003e ActionAsync()\r\n        {\r\n                byte[] bodyBytes = null;\r\n                using (var ms = new MemoryStream())\r\n                {\r\n                    await Request.Body.CopyToAsync(ms).ConfigureAwait(false);\r\n                    bodyBytes = ms.ToArray();\r\n                }\r\n\r\n                // parse the data to requests\r\n                var tasks = new List\u003cTask\u003cResult\u003e\u003e();\r\n                for(var request in requests)\r\n                {\r\n                    tasks.Add(service.OperateAsync(request))\r\n                }\r\n                await Task.WhenAll(tasks).ConfigurateAwait(false);\r\n                // handle the results of the tasks\r\n        }\r\n\r\n\r\nIf I put the `service.OperateAsync` operation to my custom thread pool, the performance would be leverage a lot.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOb6zYmg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5vmRBh",
                                           "createdAt":  "2023-12-29T19:40:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Suchiman",
                                           "body":  "Is the rate of requests / throughput also reduced? ASP.NET Core has gotten a lot of optimizations to be more CPU efficient over Framework which would permit for the CPU usage to be significantly lower at same throughput.\r\n\r\nAlthough I guess your complaint is more about insufficient parallelism with OperateAsync which does something CPU expensive?\r\nOne thing to keep in mind is that if OperateAsync calls methods that used to go async but no longer go async and complete synchronously, the method might be performing more work on the calling thread than you anticipated. The work only moves to a thread pool thread once the method yielded once and then continues.\r\nOne easy way to ensure you\u0027re being multithreaded would be doing:\r\n```csharp\r\n            var tasks = requests.AsParallel().Select(x =\u003e service.OperateAsync(x)).ToList();\r\n            await Task.WhenAll(tasks).ConfigurateAwait(false);\r\n``` \r\n\r\nbtw. doing `CopyToAsync` followed by `ToArray()` means you copy the input data twice. You can either use `Request.ContentLength` to create a pre sized `byte[]` and then `ReadAsync` into that array or you can use `MemoryStream.GetBuffer` to get the underlying array which might be oversized which you can then convert to a sliced `Memory\u003cT\u003e` / `Span\u003cT\u003e` or `ArraySegment\u003cT\u003e`.",
                                           "updatedAt":  "2023-12-29T19:52:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5vo2Yf",
                                           "createdAt":  "2023-12-31T15:47:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "This issue has been marked `needs-author-action` and may be missing some important information.",
                                           "updatedAt":  "2023-12-31T15:47:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5vo2Yz",
                                           "createdAt":  "2023-12-31T15:47:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nI have upgraded my web api service from .net framework 4.7.2 to asp .net core 6.0. And I choose Kestrel as my web server, but there is a performance regression. There are many async opertion in my controller action. The CPU is not fully used in the new version, and the CPU time almost below 20% even if I increase the thread count with ThreadPool.SetMinThreads. However, it can reach to 70% in original version. My code looks like this:\r\n\r\n    \r\n        [HttpPost(\"/action\")]\r\n        public async Task\u003cActionResult\u003e ActionAsync()\r\n        {\r\n                byte[] bodyBytes = null;\r\n                using (var ms = new MemoryStream())\r\n                {\r\n                    await Request.Body.CopyToAsync(ms).ConfigureAwait(false);\r\n                    bodyBytes = ms.ToArray();\r\n                }\r\n\r\n                // parse the data to requests\r\n                var tasks = new List\u003cTask\u003cResult\u003e\u003e();\r\n                for(var request in requests)\r\n                {\r\n                    tasks.Add(service.OperateAsync(request))\r\n                }\r\n                await Task.WhenAll(tasks).ConfigurateAwait(false);\r\n                // handle the results of the tasks\r\n        }\r\n\r\n\r\nIf I put the `service.OperateAsync` operation to my custom thread pool, the performance would be leverage a lot.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003edrawxy\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `tenet-performance`, `untriaged`, `needs-author-action`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-12-31T15:47:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5vrNia",
                                           "createdAt":  "2024-01-02T03:47:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "drawxy",
                                           "body":  "\u003e Is the rate of requests / throughput also reduced? \r\n\r\nYes, I did the performance test on the upgraded code. The rate of requests was reduced.\r\n\r\n\r\n\u003e Although I guess your complaint is more about insufficient parallelism with OperateAsync which does something CPU expensive? \r\n\r\nNo, there is nothing CPU expensive. However, it\u0027s network IO expensive.\r\n\r\n\r\n\u003e One easy way to ensure you\u0027re being multithreaded would be doing:\r\n\u003e \r\n\u003e ```cs\r\n\u003e             var tasks = requests.AsParallel().Select(x =\u003e service.OperateAsync(x)).ToList();\r\n\u003e             await Task.WhenAll(tasks).ConfigurateAwait(false);\r\n\u003e ```\r\n\r\nI have tried before I raise this issue ticket. And the performance was regressed more in this way. So I guessed that there was thread starvation and introduced the custom thread pool. Is there any way to increase the worker thread num of Kestrel?\r\n\r\n\r\n\u003e btw. doing `CopyToAsync` followed by `ToArray()` means you copy the input data twice. You can either use `Request.ContentLength` to create a pre sized `byte[]` and then `ReadAsync` into that array or you can use `MemoryStream.GetBuffer` to get the underlying array which might be oversized which you can then convert to a sliced `Memory\u003cT\u003e` / `Span\u003cT\u003e` or `ArraySegment\u003cT\u003e`.\r\n\r\nThanks a lot, @Suchiman ! This is very helpful to me!\r\n\r\n",
                                           "updatedAt":  "2024-01-02T03:47:38Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Web API performance regression after upgrading from .net framework 4.7.2 to asp .net core 6.0",
        "labels":  [
                       "area-System.Threading",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/96519",
        "createdAt":  "2024-01-05T02:00:43Z",
        "number":  96519,
        "author":  "munichmule",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-05-02T21:33:55Z",
        "body":  "### Description\r\n\r\nHi Guys,\r\n\r\nFirst of all, I know that netcore comes with a cooperative task cancellation by design.\r\nSecond, I checked these similar issues: [1](https://github.com/dotnet/runtime/issues/69622), [2](https://github.com/dotnet/runtime/discussions/66480), [3](https://github.com/dotnet/runtime/pull/71661), [4](https://github.com/dotnet/runtime/issues/65556), [5](https://github.com/dotnet/runtime/issues/41291), [6](https://github.com/dotnet/runtime/issues/39145), [7](https://github.com/dotnet/runtime/issues/2315)\r\nThird, I tried to use [ControlledExecution](https://github.com/dotnet/runtime/blob/main/src/coreclr/System.Private.CoreLib/src/System/Runtime/ControlledExecution.CoreCLR.cs#L43)\r\n\r\nStill the problem persists, eg even `ControlledExecution` isn\u0027t a remedy for certain scenarios (examples below).\r\n\r\nI totally understand why you don\u0027t want to support un-cooperative abortion, but what are the options? There could easily be 3rd party code which goes into an infinite loop or simply eats too much resources. Code REPL is an obvious example, but there could be so many more. The problem is bigger for web apps, because one request can easily eat all the resources and take down the whole process/pod. How am I supposed to implement a safety valve and recover from such situation? \r\n\r\nThat\u0027s not a matter of taste, that\u0027s a matter of resiliency: there **must** be a way to stop bad tasks, one way or another. If you don\u0027t want to support old-fashioned thread abortion - fine, just give us a workaround which works for the 3rd party code (REPL script, or a 3rd party library etc). I can\u0027t believe it remains unsolved after so many requests over years...\r\n\r\n### Reproduction Steps\r\n\r\nThis seems to work for win and linux:\r\n```\r\n        ControlledExecution.Run(() =\u003e\r\n        {\r\n            while (true)\r\n            {\r\n                 \r\n            }\r\n        }, new CancellationTokenSource(500).Token);\r\n```\r\n\r\nThis doesn\u0027t work for linux (Ubuntu):\r\n```\r\n        ControlledExecution.Run(() =\u003e\r\n        {\r\n            var task = Task.Run(() =\u003e\r\n            {\r\n                while (true)\r\n                {\r\n\r\n                }\r\n            });\r\n            Task.WaitAll(task);\r\n        }, new CancellationTokenSource(500).Token);\r\n```\r\n\r\nThere are more examples. The key thing is that there should be a way to stop hanging tasks (sync, async, thread-pooled etc).\r\n\r\n### Expected behavior\r\n\r\nShould be able to kill hanging tasks/threads without killing the process\r\n\r\n### Actual behavior\r\n\r\nOne hanging thread can easily take down the whole process/container\r\n\r\n### Regression?\r\n\r\nYes, since netfx\r\n\r\n### Known Workarounds\r\n\r\nControlledExecution class (obsolete, doesn\u0027t cover all cases)\r\n\r\n### Configuration\r\n\r\nTested on Linux Ubuntu 22.04\r\n\r\n### Other information\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOcJ7GhQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5v8Iqz",
                                           "createdAt":  "2024-01-05T02:24:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODRZCxA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "munichmule",
                                                                               "createdAt":  "2024-01-05T16:42:27Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e there must be a way to stop bad tasks\r\n\r\nThe only 100% reliable way to stop bad tasks is to kill the process.",
                                           "updatedAt":  "2024-01-05T02:24:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5v8IzW",
                                           "createdAt":  "2024-01-05T02:24:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\nHi Guys,\r\n\r\nFirst of all, I know that netcore comes with a cooperative task cancellation by design.\r\nSecond, I checked these similar issues: [1](https://github.com/dotnet/runtime/issues/69622), [2](https://github.com/dotnet/runtime/discussions/66480), [3](https://github.com/dotnet/runtime/pull/71661), [4](https://github.com/dotnet/runtime/issues/65556), [5](https://github.com/dotnet/runtime/issues/41291), [6](https://github.com/dotnet/runtime/issues/39145), [7](https://github.com/dotnet/runtime/issues/2315)\r\nThird, I tried to use [ControlledExecution](https://github.com/dotnet/runtime/blob/main/src/coreclr/System.Private.CoreLib/src/System/Runtime/ControlledExecution.CoreCLR.cs#L43)\r\n\r\nStill the problem persists, eg even `ControlledExecution` isn\u0027t a remedy for certain scenarios (examples below).\r\n\r\nI totally understand why you don\u0027t want to support un-cooperative abortion, but what are the options? There could easily be 3rd party code which goes into an infinite loop or simply eats too much resources. Code REPL is an obvious example, but there could be so many more. The problem is bigger for web apps, because one request can easily eat all the resources and take down the whole process/pod. How am I supposed to implement a safety valve and recover from such situation? \r\n\r\nThat\u0027s not a matter of taste, that\u0027s a matter of resiliency: there **must** be a way to stop bad tasks, one way or another. If you don\u0027t want to support old-fashioned thread abortion - fine, just give us a workaround which works for the 3rd party code (REPL script, or a 3rd party library etc). I can\u0027t believe it remains unsolved after so many requests over years...\r\n\r\n### Reproduction Steps\r\n\r\nThis seems to work for win and linux:\r\n```\r\n        ControlledExecution.Run(() =\u003e\r\n        {\r\n            while (true)\r\n            {\r\n                 \r\n            }\r\n        }, new CancellationTokenSource(500).Token);\r\n```\r\n\r\nThis doesn\u0027t work for linux (Ubuntu):\r\n```\r\n        ControlledExecution.Run(() =\u003e\r\n        {\r\n            var task = Task.Run(() =\u003e\r\n            {\r\n                while (true)\r\n                {\r\n\r\n                }\r\n            });\r\n            Task.WaitAll(task);\r\n        }, new CancellationTokenSource(500).Token);\r\n```\r\n\r\nThere are more examples. The key thing is that there should be a way to stop hanging tasks (sync, async, thread-pooled etc).\r\n\r\n### Expected behavior\r\n\r\nShould be able to kill hanging tasks/threads without killing the process\r\n\r\n### Actual behavior\r\n\r\nOne hanging thread can easily take down the whole process/container\r\n\r\n### Regression?\r\n\r\nYes, since netfx\r\n\r\n### Known Workarounds\r\n\r\nControlledExecution class (obsolete, doesn\u0027t cover all cases)\r\n\r\n### Configuration\r\n\r\nTested on Linux Ubuntu 22.04\r\n\r\n### Other information\r\n\r\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003emunichmule\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`, `needs-area-label`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-01-05T02:24:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5v_wj5",
                                           "createdAt":  "2024-01-05T17:00:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "munichmule",
                                           "body":  "@jkotas Yeah, but in case of web app there is no guarantee that all your processes/pods don\u0027t get constantly bombarded with malicious requests etc. Code/math REPL is a good example, but there could be much more (like a general 3rd party dependency which doesn\u0027t support cooperative cancellation etc). I mean killing the process / restarting a pod isn\u0027t a remedy for for hanging threads in a web app. This sounds like a super-standard problem: to measure cpu/memory per-request and throttle/drop bad requests to keep the app resilient. I\u0027m surprised I can\u0027t find a standard solution, maybe I\u0027m looking in a wrong place, dunno...\r\n\r\nIf there is no idiomatic solution, I would appreciate an idiomatic workaround. :)\r\n\r\nCC @AntonLapounov @stephentoub ",
                                           "updatedAt":  "2024-01-05T17:03:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5v_3L5",
                                           "createdAt":  "2024-01-05T17:19:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "If you have a hanging thread or run-away task in your web app, your web app has a bug. The remedy is to fix the bug.\r\n\r\nControlledExecution is a best-effort solution for REPLs. It was not designed to be used as remedy for run-away threads or tasks in production. It is understood that it does not handle all situations. We do not plan to fix that. We do not know how to fix that even if we wanted to.",
                                           "updatedAt":  "2024-01-05T17:19:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5v_7cn",
                                           "createdAt":  "2024-01-05T17:33:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "\u003e If there is no idiomatic solution, I would appreciate an idiomatic workaround.\r\n\r\nI\u0027d guess the idiomatic workaround would be to have a pool of worker processes you\u0027d be delegating work to.\r\nAFAIR no mainstream operating systems have been designed to be fully resilient against sudden thread abortion so using it can break more than just your app.",
                                           "updatedAt":  "2024-01-05T17:33:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5v_8X_",
                                           "createdAt":  "2024-01-05T17:37:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODRZZhw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2024-01-05T17:40:04Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "\u003e This sounds like a super-standard problem: to measure cpu/memory per-request and throttle/drop bad requests to keep the app resilient. I\u0027m surprised I can\u0027t find a standard solution, maybe I\u0027m looking in a wrong place, dunno...\r\n\r\nThat\u0027s because its solved in the operating system and language runtimes don\u0027t really want to re-implement it.\r\n\r\nYou can consider using WASM in the future for this sort of stuff, it\u0027s being designed with this in mind.",
                                           "updatedAt":  "2024-01-05T17:37:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wE88Y",
                                           "createdAt":  "2024-01-08T03:44:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hez2010",
                                           "body":  "A workaround would be obtaining the Thread ID and killing it using the system API. But still, it cannot handle those run-away threads. ",
                                           "updatedAt":  "2024-01-08T03:45:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wTuKT",
                                           "createdAt":  "2024-01-10T05:32:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "munichmule",
                                           "body":  "\u003e A workaround would be obtaining the Thread ID and killing it using the system API.\r\n\r\nYeah, I would be happy to do that, but here comes the challenge: I need to somehow track managed thread enter/exit, maintain managed threads to os tasks mapping (which is not 1\u003c\u003e1 and unreliable), and then force-kill tasks without root access. \r\n\r\nI implemented it in some silly way, but I\u0027m not satisfied. So it would be nice to get some guidance from dotnet team. 😺 \r\n\r\nPS: Not sure how wasm can help with asp.net thread starvation though...",
                                           "updatedAt":  "2024-01-10T05:32:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wT3LN",
                                           "createdAt":  "2024-01-10T06:17:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODR2ZKQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "davidfowl",
                                                                               "createdAt":  "2024-01-10T07:10:07Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e  it would be nice to get some guidance from dotnet team.\r\n\r\nThere is no good reliable way to do what you are trying to do in .NET.\r\n\r\n\u003e  Not sure how wasm can help with asp.net thread starvation though...\r\n\r\nWasm helps only if you can isolate the untrusted code (and its state) from the trusted code (and its state). You can then run the untrusted code in wasm vm and kill it if it starts misbehaving. The trusted code state and its state stays intact.\r\n\r\nIf you are not able to isolate the untrusted code/state, wasm does not help much. You can kill the wasm vm, but it is not that much different from killing a regular process - all your state is gone.",
                                           "updatedAt":  "2024-01-10T06:17:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wT340",
                                           "createdAt":  "2024-01-10T06:20:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hez2010",
                                           "body":  "By using the wasm approach we will have to face severe performance issues (blazor is ridiculously slow even when compared with JavaScript, no matter whether AOT-ed or not). \nWondering if is it feasible to provide an API to host a coreclr on top of coreclr so that the hosted coreclr becomes the isolated execution environment. ",
                                           "updatedAt":  "2024-01-10T06:24:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wT6vR",
                                           "createdAt":  "2024-01-10T06:34:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e the wasm approach we will have to face severe performance issues\r\n\r\nYes, the execution isolation is relatively expensive.\r\n\r\n\u003e Wondering if is it feasible to provide an API to host a coreclr on top of coreclr so that the hosted coreclr becomes the isolated execution environment.\r\n\r\ncoreclr does not provide execution isolation. I do not see how stacking two coreclr on top of each other creates execution isolation.",
                                           "updatedAt":  "2024-01-10T06:34:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wT_dX",
                                           "createdAt":  "2024-01-10T06:55:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hez2010",
                                           "body":  "\u003e coreclr does not provide execution isolation\n\nThe \"isolation\" here means we can take the entire host down and reload it when needed, such as killing an out-of-control operation in the REPL scenario. ",
                                           "updatedAt":  "2024-01-10T06:55:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wXIPC",
                                           "createdAt":  "2024-01-10T15:46:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e The \"isolation\" here means we can take the entire host down\r\n\r\nThere is no way to unload codeclr and the runtime libraries from a process cleanly. The only way to unload coreclr is by killing the process.",
                                           "updatedAt":  "2024-01-10T15:46:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wgbBR",
                                           "createdAt":  "2024-01-11T16:39:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "munichmule",
                                           "body":  "Let\u0027s say I want to measure resources consumption per asp.net request (for logging/troubleshooting purposes etc), and - optionally - kill runaway threads (if possible). \r\nSo there are 3 problems here:\r\n1) from async operation entry point, observe how control flows across managed threads (async operation -\u003e thread1 enter -\u003e thread2 enter -\u003e thread2 exit -\u003e thread1 exit -\u003e ...)\r\n2) for threads visited in #⁠1, read thread stats (cpu time, memory etc) and be able to map it to underlying os task in a reliable way\r\n3) detect runaway threads (and kill them if possible)\r\n\r\nSo far I understand that you can\u0027t help me with #⁠3, but how about #⁠1-2? \r\nFor #⁠1 I tried a hack using AsyncLocal with callback to track context switching, but I\u0027m not sure if it\u0027s reliable, and it doesn\u0027t look like a production-grade approach.\r\n\r\nFor #⁠2 I tried Process.Threads, but it adds a significant slowdown (because it reads all threads data at once). I also tried pure pinvoke approach (eg `gettid`/`getrusage` or `GetCurrentThreadId`/`GetThreadTimes` etc), but I noticed tid can change for the same managed thread, so I can\u0027t map them 1\u003c\u003e1, and thus I can\u0027t track tid change from the managed code. And it\u0027s even worse for OSX. \r\n\r\nIt would be nice to have these things solved with default sdk, eg by having a more reach managed thread interface and async state machine events. But I totally understand if you don\u0027t want to support that. Could you please advise then on how to achieve what I want?",
                                           "updatedAt":  "2024-01-11T16:47:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wghrK",
                                           "createdAt":  "2024-01-11T16:55:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODSGlBw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2024-01-11T16:58:44Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "Maybe it\u0027s still unclear from the previous comments but this isn\u0027t something that the .NET runtime solves or wants to solve. You cannot reliably measure resource usage of a unit of work, nor can you control the effect arbitrary user code can have on the process. If you want isolation, you need to use a process.",
                                           "updatedAt":  "2024-01-11T16:55:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5whMQw",
                                           "createdAt":  "2024-01-11T18:39:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "munichmule",
                                           "body":  "\u003e Maybe it\u0027s still unclear from the previous comments\r\n\r\n@davidfowl I understand that non-cooperative abortion and true isolation is not possible. But it is still unclear from the previous comments what runtime can offer to detect problematic async code paths. How am I supposed to detect/log requests that cause cpu/thread starvation in my web app? Why do you say runtime doesn\u0027t want to solve that? I don\u0027t ask for the Moon. \r\n\r\n\u003e If you have a hanging thread or run-away task in your web app, your web app has a bug. The remedy is to fix the bug.\r\n\r\n@jkotas Awesome point! It would be nice to find the code/conditions that cause the bug first. I guess I need to measure and logs something... but how? 😄 \r\n\r\nPS: Process per request is way too expensive for a web app with a decent load, clearly not an option.",
                                           "updatedAt":  "2024-01-11T18:41:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5whULd",
                                           "createdAt":  "2024-01-11T19:01:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e I guess I need to measure and logs something... but how?\r\n\r\nThe runtime, libraries and ASP.NET provide number of perf counters and telemetry events. It is possible to detect hung requests or unusual high CPU consumption using these perf counters and telemetry events. It is typically done by APM software that monitors your service.",
                                           "updatedAt":  "2024-01-11T19:02:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wldkq",
                                           "createdAt":  "2024-01-12T10:49:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "munichmule",
                                           "body":  "Yes, per process. I would like to do some measurements per request. Problems are marginal, only 1/10000 requests maybe cause high cpu or leave run-away threads. Those requests are not necessarily long-lasting, they may end in a timely fashion but eat resources. \r\n\r\nI can\u0027t just restart the process every N seconds, that\u0027s not an acceptable solution. I need to be able to deal with those requests, to identify them for analysis as least (to \"fix the bug\", as you suggested). \r\n\r\nIt\u0027s not about non-cooperative abortion anymore - this part is clear from comments above. But even for cooperative cancellation, I need to measure something in code, to log the problem, cancel the token, fail gracefully etc.",
                                           "updatedAt":  "2024-01-12T10:50:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wnsaF",
                                           "createdAt":  "2024-01-12T15:04:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODSaflg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "munichmule",
                                                                               "createdAt":  "2024-01-13T14:08:06Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "\u003e @davidfowl I understand that non-cooperative abortion and true isolation is not possible.\r\n\r\nExcellent.\r\n\r\n\u003e I can\u0027t just restart the process every N seconds, that\u0027s not an acceptable solution. I need to be able to deal with those requests, to identify them for analysis as least (to \"fix the bug\", as you suggested).\r\n\r\nWe have great docs on the options for diagnosing problems with .NET https://learn.microsoft.com/en-us/dotnet/core/diagnostics/. \r\n\r\nAs you can imagine, people build high scale services daily with our stack and run into these sorts of problems with code (within their control) that often doesn\u0027t scale on the backend. \r\n\r\n\u003e But even for cooperative cancellation, I need to measure something in code, to log the problem, cancel the token, fail gracefully etc.\r\n\r\nThey aren\u0027t measuring the resource usage of individual requests, that\u0027s not a thing, they are looking at process health and [metrics exported by the runtime](https://learn.microsoft.com/en-us/dotnet/core/diagnostics/available-counters).\r\n\r\nYou can also use tools like https://github.com/benaadams/Ben.BlockingDetector to find blocking code in the application that might be problematic.\r\n\r\nThere\u0027s no bulletproof solution here.",
                                           "updatedAt":  "2024-01-12T15:04:40Z"
                                       }
                                   ],
                         "totalCount":  19
                     },
        "title":  "Resiliency problem: unable to abort hanging threads",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/96629",
        "createdAt":  "2024-01-08T16:51:46Z",
        "number":  96629,
        "author":  "lambdageek",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC1WCYQ==",
                          "nodes":  [
                                        {
                                            "content":  "EYES",
                                            "user":  "charlesroddie",
                                            "createdAt":  "2024-01-22T23:50:35Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-01-08T17:04:20Z",
        "body":  "This issue tracks support for the WebAssembly post-MVP \"shared everything threads\" (aka thread spawn) proposal in .NET\r\n\r\nSee #94351 for a summary of other WebAssembly proposals and their status.\r\n\r\n## Proposal\r\n\r\nRepo: https://github.com/WebAssembly/shared-everything-threads\r\n\r\nExplainer or overview: https://github.com/WebAssembly/shared-everything-threads/blob/main/proposals/shared-everything-threads/Overview.md\r\n\r\n### .NET Scenarios and User Stories\r\n\r\n#### Support multi-threaded .NET programs in web browsers\r\n\r\nSee https://github.com/dotnet/runtime/issues/85592\r\n\r\n#### Support multi-threaded .NET programs on WASI hosts\r\n\r\nAs a C# developer targeting a WASI host, I would like to compile and run multi-threaded .NET programs.\r\n\r\n### Upstream dependencies: engines and toolchains\r\n\r\n#### Required WebAssembly engine support\r\n\r\nExpected .NET targets or supported configurations: Desktop browsers + Mobile browsers + Node + WASI\r\n\r\n\r\n| Engine  | Status | \r\n|---------|--------|\r\n| Chrome  |   ?    |\r\n| Firefox |   ?    |\r\n| Safari  |   ?    |\r\n| Node    |   ?    |\r\n| wasmtime|   ?    |\r\n\r\n\r\n#### Required WebAssembly toolchain support\r\n\r\nWe need LLVM to support this for AOT.\r\n\r\n--- \r\n\r\n### Opportunities and challenges\r\n\r\n#### Shared-non-shared validation\r\n\r\nPreviously WebAssembly had a `shared` flag on linear memories, the proposal adds a `shared` flag on globals, functions, tables, etc.  It also introduces a new restriction: shared functions (globals, tables) cannot access non-shared function (globals, tables, memories).  As noted in the Overview, one approach that C toolchains may take is to mark everything as shared: https://github.com/WebAssembly/shared-everything-threads/blob/main/proposals/shared-everything-threads/Overview.md#how-will-toolchains-need-to-change\r\n\r\nThe jiterpreter will have to emit shared functions, too.  It should be possible to take advantage of the new atomic table grow/get/set opcodes to populate the tables with jiterpreter-generated code.\r\n\r\n#### Realm local shared globals and functions in JS\r\n\r\nThe proposal adds thread local shared globals (that can also be exported to JS as \"realm local\" shared globals.\r\nAdditionally JS hosts will have a way to construct a shared function object that can be initialized differently in each realm.\r\n\r\nWe will likely need to take advantage of this for JS interop.\r\n\r\n#### non-shared globals/functions/tables\r\n\r\nNeed to further investigate whether non-`shared` wasm constructs make sense for .NET (perhaps as an optimization for JS interop avoiding realm-local shared functions)\r\n\r\n#### acquire-release memory model operations\r\n\r\nThe proposal adds relaxed memory model annotations to some atomic memory access operations. We should be able to take advantage of these in .NET intrinsics\r\n\r\n#### thread spawn opcode\r\n\r\nThe proposal adds a thread spawn opcode. We will likely not use it directly (the spawned threads do not intrinsically have POSIX thread semantics), but together with the rest of the proposal there should be enough here for a WASI libc to implement something like POSIX thread semantics that .NET could use to bootstrap our own threads with the expected semantics.\r\n\r\n#### Compatibility with WASI preview1+threads\r\n\r\nWASI hosts implement WASI preview1 and the wasi-threads proposal as another mechanism for spawning threads.  Depending on engine uptake (and user scenarios) we might have to support both options.  That probably means compiling against a different libc and with different toolchain compiler flags.  Likewise our own tools would need to take flags to specify if we want \"shared everything\" or \"preview1+threads\"\r\n\r\n#### WasmGC\r\n\r\nIn some sense the point of this proposal is to add threading for WasmGC.  Heap types also get a `shared` annotation.  If we end up working on #94420 we would need to mark our heap types as shared.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOcCTb6w==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5wJNT8",
                                           "createdAt":  "2024-01-08T16:52:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to \u0027arch-wasm\u0027: @lewing\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThis issue tracks support for the WebAssembly post-MVP \"shared everything threads\" (aka thread spawn) proposal in .NET\r\n\r\nSee #94351 for a summary of other WebAssembly proposals and their status.\r\n\r\n## Proposal\r\n\r\nRepo: https://github.com/WebAssembly/shared-everything-threads\r\n\r\nExplainer or overview: https://github.com/WebAssembly/shared-everything-threads/blob/main/proposals/shared-everything-threads/Overview.md\r\n\r\n### .NET Scenarios and User Stories\r\n\r\n#### Support multi-threaded .NET programs in web browsers\r\n\r\nSee https://github.com/dotnet/runtime/issues/85592\r\n\r\n#### Support multi-threaded .NET programs on WASI hosts\r\n\r\nAs a C# developer targeting a WASI host, I would like to compile and run multi-threaded .NET programs.\r\n\r\n### Upstream dependencies: engines and toolchains\r\n\r\n#### Required WebAssembly engine support\r\n\r\nExpected .NET targets or supported configurations: Desktop browsers + Mobile browsers + Node + WASI\r\n\r\n\r\n| Engine  | Status | \r\n|---------|--------|\r\n| Chrome  |   ?    |\r\n| Firefox |   ?    |\r\n| Safari  |   ?    |\r\n| Node    |   ?    |\r\n| wasmtime|   ?    |\r\n\r\n\r\n#### Required WebAssembly toolchain support\r\n\r\nWe need LLVM to support this for AOT.\r\n\r\n--- \r\n\r\n### Opportunities and challenges\r\n\r\n#### Shared-non-shared validation\r\n\r\nPreviously WebAssembly had a `shared` flag on linear memories, the proposal adds a `shared` flag on globals, functions, tables, etc.  It also introduces a new restriction: shared functions (globals, tables) cannot access non-shared function (globals, tables, memories).  As noted in the Overview, one approach that C toolchains may take is to mark everything as shared: https://github.com/WebAssembly/shared-everything-threads/blob/main/proposals/shared-everything-threads/Overview.md#how-will-toolchains-need-to-change\r\n\r\nThe jiterpreter will have to emit shared functions, too.  It should be possible to take advantage of the new atomic table grow/get/set opcodes to populate the tables with jiterpreter-generated code.\r\n\r\n#### Realm local shared globals and functions in JS\r\n\r\nThe proposal adds thread local shared globals (that can also be exported to JS as \"realm local\" shared globals.\r\nAdditionally JS hosts will have a way to construct a shared function object that can be initialized differently in each realm.\r\n\r\nWe will likely need to take advantage of this for JS interop.\r\n\r\n#### non-shared globals/functions/tables\r\n\r\nNeed to further investigate whether non-`shared` wasm constructs make sense for .NET (perhaps as an optimization for JS interop avoiding realm-local shared functions)\r\n\r\n#### acquire-release memory model operations\r\n\r\nThe proposal adds relaxed memory model annotations to some atomic memory access operations. We should be able to take advantage of these in .NET intrinsics\r\n\r\n#### thread spawn opcode\r\n\r\nThe proposal adds a thread spawn opcode. We will likely not use it directly (the spawned threads do not intrinsically have POSIX thread semantics), but together with the rest of the proposal there should be enough here for a WASI libc to implement something like POSIX thread semantics that .NET could use to bootstrap our own threads with the expected semantics.\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003elambdageek\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`arch-wasm`, `needs-area-label`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-01-08T16:52:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wJNvr",
                                           "createdAt":  "2024-01-08T16:53:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lambdageek",
                                           "body":  "/cc @pavelsavara @kg ",
                                           "updatedAt":  "2024-01-08T16:53:01Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[wasm][post-MVP] shared everything threads",
        "labels":  [
                       "arch-wasm",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/96975",
        "createdAt":  "2024-01-15T09:17:33Z",
        "number":  96975,
        "author":  "YT-GameMaker",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-05-02T21:35:48Z",
        "body":  "### Background and motivation\n\nWhen using `SpinLock`, it\u0027s always necessary to use a `try-finally` block, and the usage is similar. Now, with `ref struct`, it\u0027s possible to use `using` to simplify this process.\n\n### API Proposal\n\n```csharp\r\npublic ref struct SpinLockTakenScope\r\n{\r\n    ref SpinLock _spinlock;\r\n    readonly bool _lockTaken;\r\n    readonly bool _exitUseMemoryBarrier;\r\n\r\n    public SpinLockTakenScope(ref SpinLock spinLock, bool exitUseMemoryBarrier = true)\r\n    {\r\n        if (Unsafe.IsNullRef(ref spinLock))\r\n            throw new NullReferenceException();\r\n\r\n        _spinlock = ref spinLock;\r\n        _lockTaken = false;\r\n        _exitUseMemoryBarrier = exitUseMemoryBarrier;\r\n\r\n        spinLock.Enter(ref _lockTaken);\r\n    }\r\n\r\n    public void Dispose()\r\n    {\r\n        if (!Unsafe.IsNullRef(ref _spinlock))\r\n        {\r\n            if (_lockTaken)\r\n                _spinlock.Exit(_exitUseMemoryBarrier);\r\n\r\n            _spinlock = ref Unsafe.NullRef\u003cSpinLock\u003e();\r\n        }\r\n    }\r\n}\r\n\r\n// Because a reference to \u0027this\u0027 cannot be obtained inside a struct,\r\n// implementing it without using unsafe code is only possible through extensions.\r\npublic static class SpinLockExtensions\r\n{\r\n    public static SpinLockTakenScope Take(this ref SpinLock spinLock, bool exitUseMemoryBarrier = true)\r\n        =\u003e new(ref spinLock, exitUseMemoryBarrier);\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nSpinLock _spinlock = new(true);\r\n\r\nvoid Func()\r\n{\r\n    using (_spinlock.Take())\r\n    {\r\n        // ...\r\n    }\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOcMI36A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5wwDgZ",
                                           "createdAt":  "2024-01-15T09:17:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nWhen using `SpinLock`, it\u0027s always necessary to use a `try-finally` block, and the usage is similar. Now, with `ref struct`, it\u0027s possible to use `using` to simplify this process.\n\n### API Proposal\n\n```csharp\r\npublic ref struct SpinLockTakenScope\r\n{\r\n    ref SpinLock _spinlock;\r\n    readonly bool _lockTaken;\r\n    readonly bool _exitUseMemoryBarrier;\r\n\r\n    public SpinLockTakenScope(ref SpinLock spinLock, bool exitUseMemoryBarrier = true)\r\n    {\r\n        if (Unsafe.IsNullRef(ref spinLock))\r\n            throw new NullReferenceException();\r\n\r\n        _spinlock = ref spinLock;\r\n        _lockTaken = false;\r\n        _exitUseMemoryBarrier = exitUseMemoryBarrier;\r\n\r\n        spinLock.Enter(ref _lockTaken);\r\n    }\r\n\r\n    public void Dispose()\r\n    {\r\n        if (!Unsafe.IsNullRef(ref _spinlock))\r\n        {\r\n            if (_lockTaken)\r\n                _spinlock.Exit(_exitUseMemoryBarrier);\r\n\r\n            _spinlock = ref Unsafe.NullRef\u003cSpinLock\u003e();\r\n        }\r\n    }\r\n}\r\n\r\n// Because a reference to \u0027this\u0027 cannot be obtained inside a struct,\r\n// implementing it without using unsafe code is only possible through extensions.\r\npublic static class SpinLockExtensions\r\n{\r\n    public static SpinLockTakenScope Take(this ref SpinLock spinLock, bool exitUseMemoryBarrier = true)\r\n        =\u003e new(ref spinLock, exitUseMemoryBarrier);\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nSpinLock _spinlock = new(true);\r\n\r\nvoid Func()\r\n{\r\n    using (_spinlock.Take())\r\n    {\r\n        // ...\r\n    }\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eyuyang9119\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-01-15T09:17:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wwK8C",
                                           "createdAt":  "2024-01-15T09:30:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "See #34812 and https://github.com/dotnet/csharplang/issues/7104 . `SpinLock` is in the interest of these proposals.",
                                           "updatedAt":  "2024-01-15T09:30:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wwNMC",
                                           "createdAt":  "2024-01-15T09:33:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "Kindly remind:\r\n\r\n- The implementations don\u0027t need to be included in `API Proposal` section. We are focusing on the public stuff exposed.\r\n- Explanations are better than names in title. The API review often changes the final name decided.",
                                           "updatedAt":  "2024-01-15T09:33:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wwjfo",
                                           "createdAt":  "2024-01-15T10:01:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "YT-GameMaker",
                                           "body":  "\u003e Kindly remind:\r\n\u003e \r\n\u003e * The implementations don\u0027t need to be included in `API Proposal` section. We are focusing on the public stuff exposed.\r\n\u003e * Explanations are better than names in title. The API review often changes the final name decided.\r\n\r\nThank you. Since I\u0027ve already written it in my own code, I just copied and pasted it. Indeed, it shouldn\u0027t include implementation details to keep the discussion focused. As for the title, I guess expressing it this way is more concise for programmers :-)",
                                           "updatedAt":  "2024-01-15T10:01:04Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "[API Proposal]: `SpinLockTakenScope` and `SpinLock.Take`",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/97034",
        "createdAt":  "2024-01-16T15:29:09Z",
        "number":  97034,
        "author":  "SkadOrdos",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-02-11T21:18:08Z",
        "body":  "### Description\r\n\r\nOur Application crashed with a internal NetCore Runtime error\r\nIt began after migrate from Net Framework 4.8 to NET 7.\r\nCrash reproduce on NET 7.0.14 / 7.0.15 / 8.0.1\r\n\r\n\r\nFaulting application name: server.exe, version: 1.0.10.1, time stamp: 0x65410000\r\nFaulting module name: coreclr.dll, version: 8.0.123.58001, time stamp: 0x65684720\r\nException code: 0xc0000005\r\nFault offset: 0x00000000000e87a6\r\nFaulting process id: 0x48f8\r\nFaulting application start time: 0x01da488073edf4b2\r\nFaulting application path: D:\\1.1.Server\\server.exe\r\nFaulting module path: C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\8.0.1\\coreclr.dll\r\nReport Id: be1a8f26-efe5-4a91-9f2f-242672b1661e\r\nFaulting package full name: \r\nFaulting package-relative application ID: \r\n\r\n\r\nDescription: The process was terminated due to an internal error in the .NET Runtime at IP 0x00007FFA27E587A6 (0x00007FFA27D70000) with exit code 0x80131506.\r\n\r\n### Reproduction Steps\r\n\r\nIt crashes spontaneously: could be once a hour or few days without errors. By stack trace it seem depends on Task.Start\r\n\r\n### Expected behavior\r\n\r\nWork without spontaneously crashes\r\n\r\n### Actual behavior\r\n\r\nDump analyze via WinDbg\r\n\r\n\r\n************* Preparing the environment for Debugger Extensions Gallery repositories **************\r\n   ExtensionRepository : Implicit\r\n   UseExperimentalFeatureForNugetShare : true\r\n   AllowNugetExeUpdate : true\r\n   AllowNugetMSCredentialProviderInstall : true\r\n   AllowParallelInitializationOfLocalRepositories : true\r\n\r\n   -- Configuring repositories\r\n      ----\u003e Repository : LocalInstalled, Enabled: true\r\n      ----\u003e Repository : UserExtensions, Enabled: true\r\n\r\n\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e Preparing the environment for Debugger Extensions Gallery repositories completed, duration 0.000 seconds\r\n\r\n************* Waiting for Debugger Extensions Gallery to Initialize **************\r\n\r\n\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e Waiting for Debugger Extensions Gallery to Initialize completed, duration 0.016 seconds\r\n   ----\u003e Repository : UserExtensions, Enabled: true, Packages count: 0\r\n   ----\u003e Repository : LocalInstalled, Enabled: true, Packages count: 36\r\n\r\nMicrosoft (R) Windows Debugger Version 10.0.25921.1001 AMD64\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\n\r\n\r\nLoading Dump File [H:\\server.exe.18680.dmp]\r\nUser Mini Dump File with Full Memory: Only application data is available\r\n\r\n\r\n************* Path validation summary **************\r\nResponse                         Time (ms)     Location\r\nDeferred                                       srv*\r\nSymbol search path is: srv*\r\nExecutable search path is: \r\nWindows 10 Version 20348 MP (16 procs) Free x64\r\nProduct: Server, suite: TerminalServer SingleUserTS\r\nEdition build lab: 20348.1.amd64fre.fe_release.210507-1500\r\nDebug session time: Tue Jan 16 15:58:19.000 2024 (UTC + 2:00)\r\nSystem Uptime: 10 days 8:20:29.450\r\nProcess Uptime: 0 days 0:25:50.000\r\n................................................................\r\n................................................................\r\n.....................\r\nLoading unloaded module list\r\n.\r\nThis dump file has an exception of interest stored in it.\r\nThe stored exception information can be accessed via .ecxr.\r\n(48f8.4508): Access violation - code c0000005 (first/second chance not available)\r\nFor analysis of this file, run !analyze -v\r\ncoreclr!CLREventBase::Set [inlined in coreclr!ObjectNative::PulseAll+0x126]:\r\n00007ffa`27e587a6 488b09          mov     rcx,qword ptr [rcx] ds:000096ac`68d2d80a=????????????????\r\n0:904\u003e !analyze -v\r\n*******************************************************************************\r\n*                                                                             *\r\n*                        Exception Analysis                                   *\r\n*                                                                             *\r\n*******************************************************************************\r\n\r\nFailed to request MethodData, not in JIT code range\r\n\r\nKEY_VALUES_STRING: 1\r\n\r\n    Key  : AV.Fault\r\n    Value: Read\r\n\r\n    Key  : Analysis.CPU.mSec\r\n    Value: 2983\r\n\r\n    Key  : Analysis.Elapsed.mSec\r\n    Value: 17261\r\n\r\n    Key  : Analysis.IO.Other.Mb\r\n    Value: 15\r\n\r\n    Key  : Analysis.IO.Read.Mb\r\n    Value: 1\r\n\r\n    Key  : Analysis.IO.Write.Mb\r\n    Value: 20\r\n\r\n    Key  : Analysis.Init.CPU.mSec\r\n    Value: 13218\r\n\r\n    Key  : Analysis.Init.Elapsed.mSec\r\n    Value: 1129306\r\n\r\n    Key  : Analysis.Memory.CommitPeak.Mb\r\n    Value: 243\r\n\r\n    Key  : CLR.Engine\r\n    Value: CORECLR\r\n\r\n    Key  : CLR.Version\r\n    Value: 8.0.123.58001\r\n\r\n    Key  : Failure.Bucket\r\n    Value: INVALID_POINTER_READ_c0000005_coreclr.dll!ObjectNative::PulseAll\r\n\r\n    Key  : Failure.Hash\r\n    Value: {be7e1d5f-f864-f771-a72a-7be333bc8c49}\r\n\r\n    Key  : Failure.Source.FileLine\r\n    Value: 340\r\n\r\n    Key  : Failure.Source.FilePath\r\n    Value: D:\\a\\_work\\1\\s\\src\\coreclr\\classlibnative\\bcltype\\objectnative.cpp\r\n\r\n    Key  : Failure.Source.SourceServerCommand\r\n    Value: raw.githubusercontent.com/dotnet/runtime/bf5e279d9239bfef5bb1b8d6212f1b971c434606/src/coreclr/classlibnative/bcltype/objectnative.cpp\r\n\r\n    Key  : Timeline.OS.Boot.DeltaSec\r\n    Value: 894029\r\n\r\n    Key  : Timeline.Process.Start.DeltaSec\r\n    Value: 1550\r\n\r\n    Key  : WER.OS.Branch\r\n    Value: fe_release\r\n\r\n    Key  : WER.OS.Version\r\n    Value: 10.0.20348.1\r\n\r\n    Key  : WER.Process.Version\r\n    Value: 1.0.10.1\r\n\r\n\r\nFILE_IN_CAB:  server.exe.18680.dmp\r\n\r\nNTGLOBALFLAG:  0\r\n\r\nPROCESS_BAM_CURRENT_THROTTLED: 0\r\n\r\nPROCESS_BAM_PREVIOUS_THROTTLED: 0\r\n\r\nAPPLICATION_VERIFIER_FLAGS:  0\r\n\r\nCONTEXT:  (.ecxr)\r\nrax=000000ab838fef10 rbx=000000ab829ff200 rcx=000096ac68d2d80a\r\nrdx=000000ab838fef30 rsi=000000ab829fea70 rdi=000000ab829fed10\r\nrip=00007ffa27e587a6 rsp=000000ab829ff2d0 rbp=000000ab829ff4a0\r\n r8=0000000000000054  r9=0000000000000056 r10=0000000000000007\r\nr11=0000000000000246 r12=0000000000000000 r13=0000000000000000\r\nr14=0000027c7107f878 r15=0000000000000000\r\niopl=0         nv up ei pl nz na pe nc\r\ncs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010200\r\ncoreclr!CLREventBase::Set [inlined in coreclr!ObjectNative::PulseAll+0x126]:\r\n00007ffa`27e587a6 488b09          mov     rcx,qword ptr [rcx] ds:000096ac`68d2d80a=????????????????\r\nResetting default scope\r\n\r\nEXCEPTION_RECORD:  (.exr -1)\r\nExceptionAddress: 00007ffa27e587a6 (coreclr!CLREventBase::Set)\r\n   ExceptionCode: c0000005 (Access violation)\r\n  ExceptionFlags: 00000001\r\nNumberParameters: 2\r\n   Parameter[0]: 0000000000000000\r\n   Parameter[1]: ffffffffffffffff\r\nAttempt to read from address ffffffffffffffff\r\n\r\nPROCESS_NAME:  server.exe\r\n\r\nREAD_ADDRESS:  ffffffffffffffff \r\n\r\nERROR_CODE: (NTSTATUS) 0xc0000005 -                      0x%p                               0x%p.                      %s.\r\n\r\nEXCEPTION_CODE_STR:  c0000005\r\n\r\nEXCEPTION_PARAMETER1:  0000000000000000\r\n\r\nEXCEPTION_PARAMETER2:  ffffffffffffffff\r\n\r\nIP_ON_HEAP:  00007ff9c9423f8a\r\nThe fault address in not in any loaded module, please check your build\u0027s rebase\r\nlog at \u003creleasedir\u003e\\bin\\build_logs\\timebuild\\ntrebase.log for module which may\r\ncontain the address if it were loaded.\r\n\r\nFRAME_ONE_INVALID: 1\r\n\r\nSTACK_TEXT:  \r\n000000ab`829ff2d0 00007ff9`c9423f8a     : 0000023c`675483a0 0000023c`675483a0 0000023c`608a3118 0000023c`67548388 : coreclr!ObjectNative::PulseAll+0x126\r\n000000ab`829ff430 00007ff9`ca5b0048     : 0000023c`67548388 00007ff9`00000000 000000ab`829ff4a0 0000027c`6f03e3d0 : System_Private_CoreLib!System.Threading.ManualResetEventSlim.Set+0x8a\r\n000000ab`829ff4b0 00007ff9`ca224447     : 0000023c`67548210 00000000`00000000 000000ab`829ff540 00000000`00000000 : System_Private_CoreLib!System.Threading.Tasks.Task.RunContinuations+0x128\r\n000000ab`829ff550 00007ff9`ca177076     : 0000027c`72496170 00000000`00000000 0000027c`72496170 00007ffa`56a87563 : System_Private_CoreLib!System.Threading.Tasks.Task.FinishSlow+0x37\r\n000000ab`829ff5b0 00007ffa`27eca333     : 0000023c`67548210 0000023c`675495d8 0000023c`5c822590 00000000`00000000 : System_Private_CoreLib!System.Threading.Tasks.Task.ExecuteWithThreadLocal+0x116\r\n000000ab`829ff660 00007ffa`27d84cb4     : 00000000`00000008 00000000`00000130 000000ab`829ff770 00007ffa`00000000 : coreclr!CallDescrWorkerInternal+0x83\r\n000000ab`829ff6a0 00007ffa`27eb74f3     : 0000023c`5c81a250 00000000`00000000 0000027c`6f03df7c 00000000`00000000 : coreclr!DispatchCallSimple+0x60\r\n000000ab`829ff730 00007ffa`27e589dd     : 0000027c`6f03df70 00007ffa`27e59308 0000027c`00004508 0000023c`5c820008 : coreclr!ThreadNative::KickOffThread_Worker+0x63\r\n000000ab`829ff790 00007ffa`27e588f3     : 000000ab`829ff808 0000023c`5c853fe0 00000000`00000000 00000000`00000000 : coreclr!ManagedThreadBase_DispatchMiddle+0x85\r\n000000ab`829ff870 00007ffa`27e58a8e     : 0000027c`00000001 ffffffff`ffffffff 0000023c`5c822590 0000023c`5c822590 : coreclr!ManagedThreadBase_DispatchOuter+0xab\r\n000000ab`829ff910 00007ffa`56ee4de0     : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : coreclr!ThreadNative::KickOffThread+0x7e\r\n000000ab`829ff970 00007ffa`5741ed9b     : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : kernel32!BaseThreadInitThunk+0x10\r\n000000ab`829ff9a0 00000000`00000000     : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : ntdll!RtlUserThreadStart+0x2b\r\n\r\n\r\nFAULTING_SOURCE_LINE:  D:\\a\\_work\\1\\s\\src\\coreclr\\classlibnative\\bcltype\\objectnative.cpp\r\n\r\nFAULTING_SOURCE_FILE:  D:\\a\\_work\\1\\s\\src\\coreclr\\classlibnative\\bcltype\\objectnative.cpp\r\n\r\nFAULTING_SOURCE_LINE_NUMBER:  340\r\n\r\nFAULTING_SOURCE_SRV_COMMAND:  https://raw.githubusercontent.com/dotnet/runtime/bf5e279d9239bfef5bb1b8d6212f1b971c434606/src/coreclr/classlibnative/bcltype/objectnative.cpp\r\n\r\nFAULTING_SOURCE_CODE:  \r\nNo source found for \u0027D:\\a\\_work\\1\\s\\src\\coreclr\\vm\\synch.cpp\u0027\r\n\r\n\r\nSYMBOL_NAME:  coreclr!ObjectNative::PulseAll+126\r\n\r\nMODULE_NAME: coreclr\r\n\r\nIMAGE_NAME:  coreclr.dll\r\n\r\nSTACK_COMMAND:  ~904s; .ecxr ; kb\r\n\r\nFAILURE_BUCKET_ID:  INVALID_POINTER_READ_c0000005_coreclr.dll!ObjectNative::PulseAll\r\n\r\nOS_VERSION:  10.0.20348.1\r\n\r\nBUILDLAB_STR:  fe_release\r\n\r\nOSPLATFORM_TYPE:  x64\r\n\r\nOSNAME:  Windows 10\r\n\r\nIMAGE_VERSION:  8.0.123.58001\r\n\r\nFAILURE_ID_HASH:  {be7e1d5f-f864-f771-a72a-7be333bc8c49}\r\n\r\nFollowup:     MachineOwner\r\n---------\r\n\r\n\r\n\r\n### Regression?\r\n\r\nWe dont have crash on Framework 4.5 / 4.8, but it reproduced on NET 7 / 8\r\n\r\n### Known Workarounds\r\n\r\nService MySQL56\r\n\r\n### Configuration\r\n\r\nNET 8.0.1, VM with Windows Server 2022 x64, 48 GB RAM\r\n\r\n### Other information\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOnhOssA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5w7GMz",
                                           "createdAt":  "2024-01-16T21:28:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e coreclr!CLREventBase::Set [inlined in coreclr!ObjectNative::PulseAll+0x126]:\r\n\u003e 00007ffa27e587a6 488b09          mov     rcx,qword ptr [rcx] ds:000096ac68d2d80a=????????????????\r\n\r\nDuplicate of https://github.com/dotnet/runtime/issues/44071 ?",
                                           "updatedAt":  "2024-01-16T21:28:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5w7GRl",
                                           "createdAt":  "2024-01-16T21:28:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\nOur Application crashed with a internal NetCore Runtime error\r\nIt began after migrate from Net Framework 4.8 to NET 7.\r\nCrash reproduce on NET 7.0.14 / 7.0.15 / 8.0.1\r\n\r\n\r\nFaulting application name: server.exe, version: 1.0.10.1, time stamp: 0x65410000\r\nFaulting module name: coreclr.dll, version: 8.0.123.58001, time stamp: 0x65684720\r\nException code: 0xc0000005\r\nFault offset: 0x00000000000e87a6\r\nFaulting process id: 0x48f8\r\nFaulting application start time: 0x01da488073edf4b2\r\nFaulting application path: D:\\1.1.Server\\server.exe\r\nFaulting module path: C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\8.0.1\\coreclr.dll\r\nReport Id: be1a8f26-efe5-4a91-9f2f-242672b1661e\r\nFaulting package full name: \r\nFaulting package-relative application ID: \r\n\r\n\r\nDescription: The process was terminated due to an internal error in the .NET Runtime at IP 0x00007FFA27E587A6 (0x00007FFA27D70000) with exit code 0x80131506.\r\n\r\n### Reproduction Steps\r\n\r\nIt crashes spontaneously: could be once a hour or few days without errors. By stack trace it seem depends on Task.Start\r\n\r\n### Expected behavior\r\n\r\nWork without spontaneously crashes\r\n\r\n### Actual behavior\r\n\r\nDump analyze via WinDbg\r\n\r\n\r\n************* Preparing the environment for Debugger Extensions Gallery repositories **************\r\n   ExtensionRepository : Implicit\r\n   UseExperimentalFeatureForNugetShare : true\r\n   AllowNugetExeUpdate : true\r\n   AllowNugetMSCredentialProviderInstall : true\r\n   AllowParallelInitializationOfLocalRepositories : true\r\n\r\n   -- Configuring repositories\r\n      ----\u003e Repository : LocalInstalled, Enabled: true\r\n      ----\u003e Repository : UserExtensions, Enabled: true\r\n\r\n\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e Preparing the environment for Debugger Extensions Gallery repositories completed, duration 0.000 seconds\r\n\r\n************* Waiting for Debugger Extensions Gallery to Initialize **************\r\n\r\n\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e Waiting for Debugger Extensions Gallery to Initialize completed, duration 0.016 seconds\r\n   ----\u003e Repository : UserExtensions, Enabled: true, Packages count: 0\r\n   ----\u003e Repository : LocalInstalled, Enabled: true, Packages count: 36\r\n\r\nMicrosoft (R) Windows Debugger Version 10.0.25921.1001 AMD64\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\n\r\n\r\nLoading Dump File [H:\\server.exe.18680.dmp]\r\nUser Mini Dump File with Full Memory: Only application data is available\r\n\r\n\r\n************* Path validation summary **************\r\nResponse                         Time (ms)     Location\r\nDeferred                                       srv*\r\nSymbol search path is: srv*\r\nExecutable search path is: \r\nWindows 10 Version 20348 MP (16 procs) Free x64\r\nProduct: Server, suite: TerminalServer SingleUserTS\r\nEdition build lab: 20348.1.amd64fre.fe_release.210507-1500\r\nDebug session time: Tue Jan 16 15:58:19.000 2024 (UTC + 2:00)\r\nSystem Uptime: 10 days 8:20:29.450\r\nProcess Uptime: 0 days 0:25:50.000\r\n................................................................\r\n................................................................\r\n.....................\r\nLoading unloaded module list\r\n.\r\nThis dump file has an exception of interest stored in it.\r\nThe stored exception information can be accessed via .ecxr.\r\n(48f8.4508): Access violation - code c0000005 (first/second chance not available)\r\nFor analysis of this file, run !analyze -v\r\ncoreclr!CLREventBase::Set [inlined in coreclr!ObjectNative::PulseAll+0x126]:\r\n00007ffa`27e587a6 488b09          mov     rcx,qword ptr [rcx] ds:000096ac`68d2d80a=????????????????\r\n0:904\u003e !analyze -v\r\n*******************************************************************************\r\n*                                                                             *\r\n*                        Exception Analysis                                   *\r\n*                                                                             *\r\n*******************************************************************************\r\n\r\nFailed to request MethodData, not in JIT code range\r\n\r\nKEY_VALUES_STRING: 1\r\n\r\n    Key  : AV.Fault\r\n    Value: Read\r\n\r\n    Key  : Analysis.CPU.mSec\r\n    Value: 2983\r\n\r\n    Key  : Analysis.Elapsed.mSec\r\n    Value: 17261\r\n\r\n    Key  : Analysis.IO.Other.Mb\r\n    Value: 15\r\n\r\n    Key  : Analysis.IO.Read.Mb\r\n    Value: 1\r\n\r\n    Key  : Analysis.IO.Write.Mb\r\n    Value: 20\r\n\r\n    Key  : Analysis.Init.CPU.mSec\r\n    Value: 13218\r\n\r\n    Key  : Analysis.Init.Elapsed.mSec\r\n    Value: 1129306\r\n\r\n    Key  : Analysis.Memory.CommitPeak.Mb\r\n    Value: 243\r\n\r\n    Key  : CLR.Engine\r\n    Value: CORECLR\r\n\r\n    Key  : CLR.Version\r\n    Value: 8.0.123.58001\r\n\r\n    Key  : Failure.Bucket\r\n    Value: INVALID_POINTER_READ_c0000005_coreclr.dll!ObjectNative::PulseAll\r\n\r\n    Key  : Failure.Hash\r\n    Value: {be7e1d5f-f864-f771-a72a-7be333bc8c49}\r\n\r\n    Key  : Failure.Source.FileLine\r\n    Value: 340\r\n\r\n    Key  : Failure.Source.FilePath\r\n    Value: D:\\a\\_work\\1\\s\\src\\coreclr\\classlibnative\\bcltype\\objectnative.cpp\r\n\r\n    Key  : Failure.Source.SourceServerCommand\r\n    Value: raw.githubusercontent.com/dotnet/runtime/bf5e279d9239bfef5bb1b8d6212f1b971c434606/src/coreclr/classlibnative/bcltype/objectnative.cpp\r\n\r\n    Key  : Timeline.OS.Boot.DeltaSec\r\n    Value: 894029\r\n\r\n    Key  : Timeline.Process.Start.DeltaSec\r\n    Value: 1550\r\n\r\n    Key  : WER.OS.Branch\r\n    Value: fe_release\r\n\r\n    Key  : WER.OS.Version\r\n    Value: 10.0.20348.1\r\n\r\n    Key  : WER.Process.Version\r\n    Value: 1.0.10.1\r\n\r\n\r\nFILE_IN_CAB:  server.exe.18680.dmp\r\n\r\nNTGLOBALFLAG:  0\r\n\r\nPROCESS_BAM_CURRENT_THROTTLED: 0\r\n\r\nPROCESS_BAM_PREVIOUS_THROTTLED: 0\r\n\r\nAPPLICATION_VERIFIER_FLAGS:  0\r\n\r\nCONTEXT:  (.ecxr)\r\nrax=000000ab838fef10 rbx=000000ab829ff200 rcx=000096ac68d2d80a\r\nrdx=000000ab838fef30 rsi=000000ab829fea70 rdi=000000ab829fed10\r\nrip=00007ffa27e587a6 rsp=000000ab829ff2d0 rbp=000000ab829ff4a0\r\n r8=0000000000000054  r9=0000000000000056 r10=0000000000000007\r\nr11=0000000000000246 r12=0000000000000000 r13=0000000000000000\r\nr14=0000027c7107f878 r15=0000000000000000\r\niopl=0         nv up ei pl nz na pe nc\r\ncs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010200\r\ncoreclr!CLREventBase::Set [inlined in coreclr!ObjectNative::PulseAll+0x126]:\r\n00007ffa`27e587a6 488b09          mov     rcx,qword ptr [rcx] ds:000096ac`68d2d80a=????????????????\r\nResetting default scope\r\n\r\nEXCEPTION_RECORD:  (.exr -1)\r\nExceptionAddress: 00007ffa27e587a6 (coreclr!CLREventBase::Set)\r\n   ExceptionCode: c0000005 (Access violation)\r\n  ExceptionFlags: 00000001\r\nNumberParameters: 2\r\n   Parameter[0]: 0000000000000000\r\n   Parameter[1]: ffffffffffffffff\r\nAttempt to read from address ffffffffffffffff\r\n\r\nPROCESS_NAME:  server.exe\r\n\r\nREAD_ADDRESS:  ffffffffffffffff \r\n\r\nERROR_CODE: (NTSTATUS) 0xc0000005 -                      0x%p                               0x%p.                      %s.\r\n\r\nEXCEPTION_CODE_STR:  c0000005\r\n\r\nEXCEPTION_PARAMETER1:  0000000000000000\r\n\r\nEXCEPTION_PARAMETER2:  ffffffffffffffff\r\n\r\nIP_ON_HEAP:  00007ff9c9423f8a\r\nThe fault address in not in any loaded module, please check your build\u0027s rebase\r\nlog at \u003creleasedir\u003e\\bin\\build_logs\\timebuild\\ntrebase.log for module which may\r\ncontain the address if it were loaded.\r\n\r\nFRAME_ONE_INVALID: 1\r\n\r\nSTACK_TEXT:  \r\n000000ab`829ff2d0 00007ff9`c9423f8a     : 0000023c`675483a0 0000023c`675483a0 0000023c`608a3118 0000023c`67548388 : coreclr!ObjectNative::PulseAll+0x126\r\n000000ab`829ff430 00007ff9`ca5b0048     : 0000023c`67548388 00007ff9`00000000 000000ab`829ff4a0 0000027c`6f03e3d0 : System_Private_CoreLib!System.Threading.ManualResetEventSlim.Set+0x8a\r\n000000ab`829ff4b0 00007ff9`ca224447     : 0000023c`67548210 00000000`00000000 000000ab`829ff540 00000000`00000000 : System_Private_CoreLib!System.Threading.Tasks.Task.RunContinuations+0x128\r\n000000ab`829ff550 00007ff9`ca177076     : 0000027c`72496170 00000000`00000000 0000027c`72496170 00007ffa`56a87563 : System_Private_CoreLib!System.Threading.Tasks.Task.FinishSlow+0x37\r\n000000ab`829ff5b0 00007ffa`27eca333     : 0000023c`67548210 0000023c`675495d8 0000023c`5c822590 00000000`00000000 : System_Private_CoreLib!System.Threading.Tasks.Task.ExecuteWithThreadLocal+0x116\r\n000000ab`829ff660 00007ffa`27d84cb4     : 00000000`00000008 00000000`00000130 000000ab`829ff770 00007ffa`00000000 : coreclr!CallDescrWorkerInternal+0x83\r\n000000ab`829ff6a0 00007ffa`27eb74f3     : 0000023c`5c81a250 00000000`00000000 0000027c`6f03df7c 00000000`00000000 : coreclr!DispatchCallSimple+0x60\r\n000000ab`829ff730 00007ffa`27e589dd     : 0000027c`6f03df70 00007ffa`27e59308 0000027c`00004508 0000023c`5c820008 : coreclr!ThreadNative::KickOffThread_Worker+0x63\r\n000000ab`829ff790 00007ffa`27e588f3     : 000000ab`829ff808 0000023c`5c853fe0 00000000`00000000 00000000`00000000 : coreclr!ManagedThreadBase_DispatchMiddle+0x85\r\n000000ab`829ff870 00007ffa`27e58a8e     : 0000027c`00000001 ffffffff`ffffffff 0000023c`5c822590 0000023c`5c822590 : coreclr!ManagedThreadBase_DispatchOuter+0xab\r\n000000ab`829ff910 00007ffa`56ee4de0     : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : coreclr!ThreadNative::KickOffThread+0x7e\r\n000000ab`829ff970 00007ffa`5741ed9b     : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : kernel32!BaseThreadInitThunk+0x10\r\n000000ab`829ff9a0 00000000`00000000     : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : ntdll!RtlUserThreadStart+0x2b\r\n\r\n\r\nFAULTING_SOURCE_LINE:  D:\\a\\_work\\1\\s\\src\\coreclr\\classlibnative\\bcltype\\objectnative.cpp\r\n\r\nFAULTING_SOURCE_FILE:  D:\\a\\_work\\1\\s\\src\\coreclr\\classlibnative\\bcltype\\objectnative.cpp\r\n\r\nFAULTING_SOURCE_LINE_NUMBER:  340\r\n\r\nFAULTING_SOURCE_SRV_COMMAND:  https://raw.githubusercontent.com/dotnet/runtime/bf5e279d9239bfef5bb1b8d6212f1b971c434606/src/coreclr/classlibnative/bcltype/objectnative.cpp\r\n\r\nFAULTING_SOURCE_CODE:  \r\nNo source found for \u0027D:\\a\\_work\\1\\s\\src\\coreclr\\vm\\synch.cpp\u0027\r\n\r\n\r\nSYMBOL_NAME:  coreclr!ObjectNative::PulseAll+126\r\n\r\nMODULE_NAME: coreclr\r\n\r\nIMAGE_NAME:  coreclr.dll\r\n\r\nSTACK_COMMAND:  ~904s; .ecxr ; kb\r\n\r\nFAILURE_BUCKET_ID:  INVALID_POINTER_READ_c0000005_coreclr.dll!ObjectNative::PulseAll\r\n\r\nOS_VERSION:  10.0.20348.1\r\n\r\nBUILDLAB_STR:  fe_release\r\n\r\nOSPLATFORM_TYPE:  x64\r\n\r\nOSNAME:  Windows 10\r\n\r\nIMAGE_VERSION:  8.0.123.58001\r\n\r\nFAILURE_ID_HASH:  {be7e1d5f-f864-f771-a72a-7be333bc8c49}\r\n\r\nFollowup:     MachineOwner\r\n---------\r\n\r\n\r\n\r\n### Regression?\r\n\r\nWe dont have crash on Framework 4.5 / 4.8, but it reproduced on NET 7 / 8\r\n\r\n### Known Workarounds\r\n\r\nService MySQL56\r\n\r\n### Configuration\r\n\r\nNET 8.0.1, VM with Windows Server 2022 x64, 48 GB RAM\r\n\r\n### Other information\r\n\r\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eSkadOrdos\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`, `needs-area-label`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-01-16T21:28:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5w_Py_",
                                           "createdAt":  "2024-01-17T11:35:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "SkadOrdos",
                                           "body":  "\u003e \u003e coreclr!CLREventBase::Set [inlined in coreclr!ObjectNative::PulseAll+0x126]:\r\n\u003e \u003e 00007ffa27e587a6 488b09          mov     rcx,qword ptr [rcx] ds:000096ac68d2d80a=????????????????\r\n\u003e \r\n\u003e Duplicate of #44071 ?\r\n\r\nIm not sure that is the same crashes, but in our app we had error after migrate to NET. Besides we also sometimes got a crash in ntdll.dll:\r\n\r\nFILE_IN_CAB:  server.exe.19416.dmp\r\n\r\nNTGLOBALFLAG:  0\r\n\r\nPROCESS_BAM_CURRENT_THROTTLED: 0\r\n\r\nPROCESS_BAM_PREVIOUS_THROTTLED: 0\r\n\r\nAPPLICATION_VERIFIER_FLAGS:  0\r\n\r\nCONTEXT:  (.ecxr)\r\nrax=00000000000002e0 rbx=00000310c6722000 rcx=0000000000000008\r\nrdx=00000000000002f0 rsi=0000000000001948 rdi=0000000000000000\r\nrip=00007ffa574bce4b rsp=000000ff0547f4b0 rbp=000000ff0547f529\r\n r8=00007ffa573bbf5a  r9=000002d0b2c50000 r10=0000000000000000\r\nr11=00000000000002e0 r12=0000000000000000 r13=0000000000000000\r\nr14=0000000000000000 r15=00000310c67220f0\r\niopl=0         nv up ei pl nz na pe nc\r\ncs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202\r\nntdll!TppRaiseHandleStatus+0x8b:\r\n00007ffa`574bce4b 488b4d47        mov     rcx,qword ptr [rbp+47h] ss:000000ff`0547f570=0000f4069729cfe0\r\nResetting default scope\r\n\r\nEXCEPTION_RECORD:  (.exr -1)\r\nExceptionAddress: 00007ffa574bce4b (ntdll!TppRaiseHandleStatus+0x000000000000008b)\r\n   ExceptionCode: c000070a\r\n  ExceptionFlags: 00000081\r\nNumberParameters: 5\r\n   Parameter[0]: ffffffffc0000008\r\n   Parameter[1]: 0000000000001948\r\n   Parameter[2]: 00000310c6722000\r\n   Parameter[3]: 0000000000000000\r\n   Parameter[4]: 00007ffa54ba5590\r\n\r\nPROCESS_NAME:  server.exe\r\n\r\nHANDLE: 0000000000001948 (!handle 0000000000001948)\r\n\r\nTHREADPOOL_WAITER: !tp wait 310c6722000\r\nUnrecognized command or argument \u0027wait\u0027\r\nUnrecognized command or argument \u0027310c6722000\u0027\r\n\r\nthreadpool:\r\n  Displays info about the runtime thread pool.\r\n\r\nUsage:\r\n  \u003e!ext threadpool [options]\r\n\r\nOptions:\r\n  -hc, -ti    Print the hill climbing log.\r\n  -wi         Print all work items that are queued.\r\n\r\n\r\nERROR_CODE: (NTSTATUS) 0xc000070a -                      0x\r\n\r\nEXCEPTION_CODE_STR:  c000070a\r\n\r\nEXCEPTION_PARAMETER1:  ffffffffc0000008\r\n\r\nEXCEPTION_PARAMETER2:  0000000000001948\r\n\r\nEXCEPTION_PARAMETER3:  00000310c6722000\r\n\r\nEXCEPTION_PARAMETER4: 0\r\n\r\nSTACK_TEXT:  \r\n000000ff`0547f4b0 00007ffa`5744d41f     : 00000310`00000000 00007ffa`54bc0501 00000000`00000000 00007ffa`573a6953 : ntdll!TppRaiseHandleStatus+0x8b\r\n000000ff`0547f590 00007ffa`573a67e6     : 00000310`c67223c0 00000000`00000000 00000000`00000000 00000000`00001948 : ntdll!TppSetupNextWait+0xa6a8b\r\n000000ff`0547f5e0 00007ffa`573a8729     : 000002d0`b12ad8f0 00000000`00000000 00000310`c6722188 00000000`00000000 : ntdll!TpSetWaitEx+0xa6\r\n000000ff`0547f620 00007ffa`573a47ce     : 000002d0`b12ad8f0 000002d0`b12ad8f0 00000000`00000000 00000310`c6722188 : ntdll!RtlpTpWaitCheckReset+0x41\r\n000000ff`0547f650 00007ffa`573a6e52     : 00000310`c6722000 000002d0`b12ad8f0 00000000`00000000 00007ffa`00000000 : ntdll!RtlpTpWaitCallback+0x2e\r\n000000ff`0547f6b0 00007ffa`573ab8e8     : 00000310`c6722188 00000310`c66cc030 00000000`00000000 00000000`00000000 : ntdll!TppExecuteWaitCallback+0xae\r\n000000ff`0547f700 00007ffa`56ee4de0     : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : ntdll!TppWorkerThread+0x448\r\n000000ff`0547f9f0 00007ffa`5741ed9b     : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : kernel32!BaseThreadInitThunk+0x10\r\n000000ff`0547fa20 00000000`00000000     : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : ntdll!RtlUserThreadStart+0x2b\r\n\r\n\r\nSYMBOL_NAME:  ntdll!TppRaiseHandleStatus+8b\r\n\r\nMODULE_NAME: ntdll\r\n\r\nIMAGE_NAME:  ntdll.dll\r\n\r\nSTACK_COMMAND:  ~297s; .ecxr ; kb\r\n\r\nFAILURE_BUCKET_ID:  THREADPOOL_HANDLE_EXCEPTION_c000070a_ntdll.dll!TppRaiseHandleStatus\r\n\r\nBoth errors registered as code 0x80131506",
                                           "updatedAt":  "2024-01-17T11:36:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc58rbBa",
                                           "createdAt":  "2024-05-02T21:36:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "are you able to share a dump and/or a repro? ",
                                           "updatedAt":  "2024-05-02T21:36:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5_UJ8T",
                                           "createdAt":  "2024-05-28T19:46:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "SkadOrdos",
                                           "body":  "\u003e are you able to share a dump and/or a repro?\r\n\r\nUnfortunately not, I couldn\u0027t share the dump by security policy of company. And we couldn\u0027t find fixed way to reproduce the crash - the only thing that clearly defined its depend on NET and no ocurus with Net Framework",
                                           "updatedAt":  "2024-05-28T19:46:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6eEAYc",
                                           "createdAt":  "2025-02-11T19:20:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "This should be fixed #107168. The fix is going to be included in .NET 10.",
                                           "updatedAt":  "2025-02-11T19:20:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6eE6yw",
                                           "createdAt":  "2025-02-11T21:18:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "After offline discussion with @eduardo-vp and @kouvel , this is unlikely to be fixed by https://github.com/dotnet/runtime/pull/107168",
                                           "updatedAt":  "2025-02-11T21:18:07Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "Intermittent crash in ObjectNative::PulseAll",
        "labels":  [
                       "area-System.Threading",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/97240",
        "createdAt":  "2024-01-20T01:25:40Z",
        "number":  97240,
        "author":  "VSadov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-16T21:05:47Z",
        "body":  "Noticed while reviewing https://github.com/dotnet/runtime/pull/97227\r\n\r\nThe acquisition path tries to acquire the lock under `try`\r\nhttps://github.com/dotnet/runtime/blob/ca1b161e3c987bc2c14f695bffce3bb391b8aaa0/src/libraries/System.Private.CoreLib/src/System/Threading/Lock.cs#L459\r\n\r\nI assume the purpose of that is to catch exceptions that may come from the event source, which is external code.  \r\nSince we may see exception after the lock is already in acquired state, the `catch` should release the lock, but instead it unregisters a waiter.\r\n\r\nhttps://github.com/dotnet/runtime/blob/ca1b161e3c987bc2c14f695bffce3bb391b8aaa0/src/libraries/System.Private.CoreLib/src/System/Threading/Lock.cs#L544-L548\r\n\r\nI think it would be unexpected for the caller that a failed attempt to acquire could leave the lock in a locked state. Worst case the calling thread will terminate while leaving behind an acquired lock, which is UB.\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOt6CB7A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5xV4Sy",
                                           "createdAt":  "2024-01-20T01:25:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nNoticed while reviewing https://github.com/dotnet/runtime/pull/97227\r\n\r\nThe acquisition path tries to acquire the lock under `try`\r\nhttps://github.com/dotnet/runtime/blob/ca1b161e3c987bc2c14f695bffce3bb391b8aaa0/src/libraries/System.Private.CoreLib/src/System/Threading/Lock.cs#L459\r\n\r\nI assume the purpose of that is to catch exceptions that may come from the event source, which is external code.  \r\nSince we may see exception after the lock is already in acquired state, the `catch` should release the lock, but instead it unregisters a waiter.\r\n\r\nhttps://github.com/dotnet/runtime/blob/ca1b161e3c987bc2c14f695bffce3bb391b8aaa0/src/libraries/System.Private.CoreLib/src/System/Threading/Lock.cs#L546-L547\r\n\r\nI think it would be unexpected for the caller that a failed attempt to acquire could leave the lock in a locked state. Worst case the calling thread will terminate while leaving behind an acquired lock, which is UB.\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eVSadov\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-01-20T01:25:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5xV4ao",
                                           "createdAt":  "2024-01-20T01:26:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "VSadov",
                                           "body":  "CC: @kouvel ",
                                           "updatedAt":  "2024-01-20T01:26:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5xXxZo",
                                           "createdAt":  "2024-01-20T10:16:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "I\u0027m thinking once the lock is acquired any exceptions (there shouldn\u0027t be any important ones) can be ignored. Could consider undoing the state changes and propagating the exception but it seems a rare need and unnecessarily more complicated.",
                                           "updatedAt":  "2024-01-20T10:16:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc63oIHs",
                                           "createdAt":  "2025-07-16T21:05:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "VSadov",
                                           "body":  "The bug is indirectly a result of the complexity in the lock (various nested loops, etc..). \nFixing this issue would require refactoring and would be safer to do in 11. \n\nConsidering that this issue has been around for two releases and has not been observed to cause actual failures, I think at this point in release cycle pushing this to 11 is a better option.",
                                           "updatedAt":  "2025-07-16T21:05:36Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "If an attempt to acquire a System.Threading.Lock ends up throwing, we should leave the lock unlocked.",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/99851",
        "createdAt":  "2024-03-16T02:58:38Z",
        "number":  99851,
        "author":  "dongfengxin",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-05-02T21:32:33Z",
        "body":  "\r\n\r\n### Description\r\n\r\nWhen uopdated to Visual Studio 17.9.2/3， Program runs slowly in some reason，and a computer with 17.9.1 runs normaly.\r\n\r\nand test in Visual Studio Preview 2 build project is also run slowly than Visual Studio Preview 1 build project.\r\n\r\n![Screenshot 2024-03-16 104049](https://github.com/dotnet/runtime/assets/17286415/4b5e7f5d-2aad-437e-99d3-7adb501636bc)\r\n\r\n\r\n![image](https://github.com/dotnet/runtime/assets/17286415/e3c15929-2cfc-4c60-8057-b33709bdc267)\r\n\r\n\r\nAs the picture shows above , the program runs more slowly as the times going on!",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOfK1o9A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc53Sa5r",
                                           "createdAt":  "2024-03-16T02:59:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-infrastructure-libraries\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-03-16T02:59:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc58rWj0",
                                           "createdAt":  "2024-05-02T21:32:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "Hi @dongfengxin, are you able to provide a repro? ",
                                           "updatedAt":  "2024-05-02T21:32:21Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Net8 Program runs slowly for some reason when updated to Visual Studio 17.9.2/3",
        "labels":  [
                       "area-System.Threading",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/99865",
        "createdAt":  "2024-03-16T17:12:20Z",
        "number":  99865,
        "author":  "nitinag",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-09-04T20:35:14Z",
        "body":  "### Description\n\nWe occasionally see an ObjectDisposedException thrown in our logs on ConcurrencyLimiter AttemptAcquire.\n\n### Reproduction Steps\n\n```\r\nprivate readonly PartitionedRateLimiter\u003cstring\u003e _concurrentConnectionLimiter =\r\n    PartitionedRateLimiter.Create\u003cstring, string\u003e(clientIp =\u003e\r\n    {\r\n        return RateLimitPartition.GetConcurrencyLimiter(clientIp, _ =\u003e\r\n            new ConcurrencyLimiterOptions\r\n            {\r\n                PermitLimit = 15,\r\n                QueueLimit = 0\r\n            });\r\n    }, StringComparer.OrdinalIgnoreCase);\r\n\r\n//Usage\r\nusing (var concurrentRateLimitLease = _concurrentConnectionLimiter.AttemptAcquire(clientIp, permitCount: 1))\r\n{\r\n    //Drop Connection\r\n    if (!concurrentRateLimitLease.IsAcquired)\r\n    {\r\n\t\treturn;\r\n    }\r\n\r\n    //...\r\n}\r\n\r\n```\n\n### Expected behavior\n\nNo exception thrown.\n\n### Actual behavior\n\n```\r\nSystem.ObjectDisposedException: Cannot access a disposed object.\r\n Object name: \u0027ConcurrencyLimiter\u0027.\r\n    at System.Threading.RateLimiting.ConcurrencyLimiter.AttemptAcquireCore(Int32 permitCount)\r\n```\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n.NET 8, Linux\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  null,
                         "nodes":  [

                                   ],
                         "totalCount":  0
                     },
        "title":  "Occasional ObjectDisposedException on ConcurrencyLimiter AttemptAcquire ",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/99896",
        "createdAt":  "2024-03-18T11:26:28Z",
        "number":  99896,
        "author":  "dongfengxin",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-03T21:03:56Z",
        "body":  "### Description\n\nSystem Threading Portable Thread Pool + IOCCompletionPoller, System.ThreadinWaitHande.WaitOneNocheck and LevelLifoSemaphore.WaitForSignal in net8 Description.\r\n\r\n![image](https://github.com/dotnet/runtime/assets/17286415/3a8588f0-0256-415d-9c69-f65805ab35c3)\r\n\r\nas the profile shows ,the thread is almost waiting.\n\n### Reproduction Steps\n\nThere is a program runs well before, and recently the program runs with the thread pool almost stop:\r\n\r\nMaybe the reason have some relationship with the worker in the thread pool below,\r\n\r\n.NET TP Worker\r\n.NET Timer\r\n.NET TP Gate.NET \r\nThreadPool lO\n\n### Expected behavior\n\nSystem Threading Portable Thread Pool + IOCCompletionPoller, WaitOneNocheck and LevelLifoSemaphore runs well.\n\n### Actual behavior\n\n![image](https://github.com/dotnet/runtime/assets/17286415/ec568d99-2d05-43af-83f2-a483ace082f1)\r\n\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOd22AAw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc53bYAD",
                                           "createdAt":  "2024-03-18T11:28:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-03-18T11:28:58Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "[Net] System Threading Portable Thread Pool + IOCCompletionPoller, WaitOneNocheck and LevelLifoSemaphore almost stop to run.",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/100135",
        "createdAt":  "2024-03-22T10:57:37Z",
        "number":  100135,
        "author":  "svick",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODBGTEQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "addabis",
                                            "createdAt":  "2025-04-11T07:04:49Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-06-19T09:23:20Z",
        "body":  "### Description\r\n\r\nWe have a customer that reported getting the following exception when our code is creating a global named `Mutex` on macOS (see https://github.com/postsharp/Metalama/issues/272):\r\n\r\n```\r\nUnhandled exception. System.IO.IOException: The system cannot open the device or file specified. : \u0027Global\\Metalama.Configuration\u0027\r\n   at System.Threading.Mutex.CreateMutexCore(Boolean initiallyOwned, String name, Boolean\u0026 createdNew)\r\n   at System.Threading.Mutex..ctor(Boolean initiallyOwned, String name)\r\n```\r\n\r\nThe exception happened consistently, but did not reoccur after restarting the machine, so it seems it\u0027s caused by some corrupted temporary state.\r\n\r\nWhat could have caused this situation? Could it be a bug in our code, or a bug in the macOS implementation of `Mutex`? What should we do to avoid this problem in the future?\r\n\r\n### Reproduction Steps\r\n\r\nI do not have a reproduction. The relevant code on our side is [here](https://github.com/postsharp/Metalama.Backstage/blob/5743a3f/Metalama.Backstage/Utilities/MutexHelper.cs#L83), but it boils down to:\r\n\r\n```c#\r\ninternal static Mutex OpenOrCreateMutex( string mutexName )\r\n{\r\n    // The number of iterations is intentionally very low.\r\n    // We will restart if the following occurs:\r\n    //   1) TryOpenExisting fails, i.e. there is no existing mutex.\r\n    //   2) Creating a new mutex fails, i.e. the mutex was created in the meantime by a process with higher set of rights.\r\n    // The probability of mutex being destroyed when we call TryOpenExisting again is fairly low.\r\n\r\n    for ( var i = 0; ; i++ )\r\n    {\r\n        // First try opening the mutex.\r\n        if ( Mutex.TryOpenExisting( mutexName, out var existingMutex ) )\r\n        {\r\n            return existingMutex;\r\n        }\r\n        else\r\n        {\r\n            // Otherwise we will try to create the mutex.\r\n            try\r\n            {\r\n                return new Mutex( false, mutexName );\r\n            }\r\n            catch ( UnauthorizedAccessException )\r\n            {\r\n                if ( i \u003c 3 )\r\n                {\r\n                    // Mutex was probably created in the meantime and is not accessible - we will restart.\r\n                    continue;\r\n                }\r\n                else\r\n                {\r\n                    // There were too many restarts - just rethrow.\r\n                    throw;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### Expected behavior\r\n\r\nEither the exception is not thrown at all, or there is more information on the actual cause of the exception.\r\n\r\n### Actual behavior\r\n\r\nThe exception described above is thrown.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOsg8kew==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc54GZBk",
                                           "createdAt":  "2024-03-22T12:06:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "filipnavara",
                                           "body":  "I\u0027m not sure whether this is actionable without more information. What version of framework was used to run the app? I went all the way back to .NET 6 and the `CreateMutexCore` would not throw `IOException` there AFAICT.",
                                           "updatedAt":  "2024-03-22T12:06:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc54HCco",
                                           "createdAt":  "2024-03-22T13:34:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "svick",
                                           "body":  "@filipnavara Unfortunately, I don\u0027t have more information, apart from it being .Net 6+.\r\n\r\nThough [that exception message is associated with `ERROR_OPEN_FAILED` in the PAL](https://github.com/dotnet/runtime/blob/a2ce8db/src/coreclr/pal/src/misc/errorstrings.cpp#L71), so I\u0027m assuming that the exception is coming from native code.",
                                           "updatedAt":  "2024-03-22T13:34:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc54JjvC",
                                           "createdAt":  "2024-03-22T19:27:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOENzSzA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "filipnavara",
                                                                               "createdAt":  "2024-03-22T19:31:53Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "addabis",
                                                                               "createdAt":  "2025-04-11T07:01:54Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "craigbehnke",
                                           "body":  "Hi @filipnavara, I\u0027m the guy who opened the original issue. My app\u0027s target framework is net7.0 (installed SDKs are 7.0.311 and 7.0.313).\r\n\r\nPlease let me know what other info you would like.",
                                           "updatedAt":  "2024-03-22T19:27:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6WKBPd",
                                           "createdAt":  "2024-12-05T05:24:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "albahari",
                                           "body":  "I have experience this, too, on .NET 8.0.6 on macOS. Same stack trace.",
                                           "updatedAt":  "2024-12-05T05:24:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6yDyR7",
                                           "createdAt":  "2025-06-19T09:08:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "filipnavara",
                                           "body":  "\u003e The exception shows the file \u0027Global\\Metalama.Configuration\u0027. Shouldn\u0027t that be Global/Metalama.Configuration on macOS?\n\nNo. The `Global\\` prefix is a mutex thing, not a file-system thing.",
                                           "updatedAt":  "2025-06-19T09:08:52Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "IOException when creating a global mutex on macOS",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/100459",
        "createdAt":  "2024-03-30T06:40:57Z",
        "number":  100459,
        "author":  "kouvel",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-08-01T20:46:54Z",
        "body":  "- In addition to the job object CPU limits. CPU limits may need to apply after taking affinitization into account, including on single-CPU-group machines where affinitization may be done using different APIs.\r\n- Thread-spreading currently only considers the total proc count in each CPU group and does not consider affinitization\r\n  - An alternative may be to disable thread-spreading by default, but there were scheduler issues when using server GC",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOeN_0hw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc543_SH",
                                           "createdAt":  "2024-03-30T06:41:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-03-30T06:41:22Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "[Windows] Take job object affinitization into account for processor count and thread-spreading",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/100639",
        "createdAt":  "2024-04-04T14:12:16Z",
        "number":  100639,
        "author":  "kekekeks",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-03T20:25:01Z",
        "body":  "Existing (3rd party) library code is using `Thread.SetApartmentState` to make its worker threads compatible with various Win32 APIs. \r\n\r\nOn non-windows platforms, this method throws a `PlatformNotSupportedException`, which makes an otherwise compatible library code (that by itself doesn\u0027t even use Win32 APIs) impossible to consume on such platforms.\r\n\r\nAt the same time `STAThreadAttribute` applied on Main does nothing and doesn\u0027t prevent the app from running on those platforms, so there is already a case when .NET completely ignores desired apartment and it\u0027s considered a completely safe thing to do.\r\n\r\nThe proposal is to have a .runtimeconfig.json flag, that would prevent Thread.SetApartmentState from throwing exceptions on non-Windows platforms.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOejGLeA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc55cXoS",
                                           "createdAt":  "2024-04-04T15:11:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODd3Dxw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Zintom",
                                                                               "createdAt":  "2024-04-04T16:16:29Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2024-04-06T15:29:52Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "danmoseley",
                                                                               "createdAt":  "2024-04-11T16:29:58Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Can the library be fixed to call `Thread.SetApartmentState` only on Windows?\r\n\r\n\u003e The proposal is to have a .runtimeconfig.json flag, that would prevent Thread.SetApartmentState from throwing exceptions on non-Windows platforms.\r\n\r\nWe add compatibility quirks like this as the very last resort for issues with broad impact. I do not think this compatibility quirk meets the bar.",
                                           "updatedAt":  "2024-04-04T15:11:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc55c_8c",
                                           "createdAt":  "2024-04-04T16:17:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Zintom",
                                           "body":  "\u003e Can the library be fixed to call `Thread.SetApartmentState` only on Windows?\n\u003e \n\nYeah a #IF would suffice in the lib code",
                                           "updatedAt":  "2024-04-04T16:17:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc55dBhw",
                                           "createdAt":  "2024-04-04T16:20:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kekekeks",
                                           "body":  "The library code is a 3rd party one and we can\u0027t IL-patch it due to licensing restrictions, unfortunately.",
                                           "updatedAt":  "2024-04-04T16:20:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc55dCO4",
                                           "createdAt":  "2024-04-04T16:21:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kekekeks",
                                           "body":  "Why does the method throw in the first place, BTW? Since [STAThread] is silently ignored instead of throwing, the runtime already considers some apartment-related APIs to be a no-op on non-windows.",
                                           "updatedAt":  "2024-04-04T16:21:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc55dQYk",
                                           "createdAt":  "2024-04-04T16:52:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "In general, the API behaviors on unsupported platforms are:\r\n- Platform-specific attributes are silently ignored. For example, `ObjectiveCTrackedTypeAttribute` is ignored on platforms without Objective C support.\r\n- Getters or Try... setter return a sensible value on unsupported platforms where possible. For example,  `Console.WindowLeft` getter returns 0 on Unix.\r\n- Setters and methods throw `PlatformNotSupportedException`. For example,  `Console.WindowLeft` setter throws `PlatformNotSupportedException` on Unix.\r\n\r\n(I am sure you would be able to find some counter-examples.)",
                                           "updatedAt":  "2024-04-04T16:52:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc55qQ2h",
                                           "createdAt":  "2024-04-06T15:45:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODd3D7w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2024-04-08T17:52:10Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "danmoseley",
                                                                               "createdAt":  "2024-04-11T16:30:26Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e The library code is a 3rd party one and we can\u0027t IL-patch it due to licensing restrictions, unfortunately.\r\n\r\nSomething to consider is it seems the 3rd party doesn\u0027t support running on non-Windows platforms. It is quite possible additional issues are present and this is simply the first of many. It also means it isn\u0027t tested on those platforms so relying on it is exposing applications to added risk.\r\n\r\nIt would seem most appropriate to reach out to the library author and work with them on a support non-Windows option.",
                                           "updatedAt":  "2024-04-06T15:45:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc55yXXV",
                                           "createdAt":  "2024-04-08T17:00:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kekekeks",
                                           "body":  "We are using NativeLibrary.SetDllImportResolver and a native lib implementing win32 apis to fix the rest of \"incompatibilities\". The rest of the code _is_ compatible.",
                                           "updatedAt":  "2024-04-08T17:00:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56BYYT",
                                           "createdAt":  "2024-04-10T10:40:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "What are you going to do if an updated version of the library introduces more Windows-specific code that is not possible to \"fix\" using `NativeLibrary.SetDllImportResolver`?\r\n\r\nThe support plan you are on does not look dependable. ",
                                           "updatedAt":  "2024-04-10T10:40:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56MYt4",
                                           "createdAt":  "2024-04-11T16:24:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kekekeks",
                                           "body":  "\u003eWhat are you going to do if an updated version of the library introduces more Windows-specific code that is not possible to \"fix\" using NativeLibrary.SetDllImportResolver?\r\n\r\nWe\u0027ve managed to get lots of 3rd party WPF components to work flawlessly using that API.\r\n\r\nSo far we\u0027ve only had 2 roadblocks that can\u0027t be fixed on our side and both are COM-related and are explicitly blocked by runtime and not by 3rd party code doing something windows-specific.\r\n\r\n1) [HostVisual](https://learn.microsoft.com/en-us/dotnet/api/system.windows.media.hostvisual?view=windowsdesktop-8.0)/[VisualTarget](https://learn.microsoft.com/ru-ru/dotnet/api/system.windows.media.visualtarget?view=windowsdesktop-8.0) require an STA thread with windows-only version of WPF and don\u0027t require it with xplat-one, but pre-existing 3rd party libs (some of those haven\u0027t seen updates for half a decade) are setting the STA thread flag just to get those _100% managed_ APIs to work.\r\n\r\n2) Another COM-related major blocker is people trying to use [TF_CreateThreadMgr](https://learn.microsoft.com/en-us/windows/win32/api/msctf/nf-msctf-tf_createthreadmgr) which the runtime simply refuses to call even though our implementation returns E_FAIL and don\u0027t provide anything in ppv, but that\u0027s a separate story. For that one, I believe, we\u0027ll have to build and ship a custom runtime\r\n",
                                           "updatedAt":  "2024-04-11T16:24:22Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "(Optionally) make Thread.SetApartmentState behavior to match [STAThread] on Main() on non-Windows platforms.",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/101506",
        "createdAt":  "2024-04-24T17:30:00Z",
        "number":  101506,
        "author":  "kouvel",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-04T19:11:03Z",
        "body":  "- Before yield normalization occurs, the current defaults lead to very little spin-waiting on ARM processors\r\n- On one hand, spin-waiting less until the yield normalization occurs seems like it could be a sensible option, on the other hand it can lead to more context switching during startup in some cases. It\u0027s unclear which would be less expensive.\r\n- Determine if improving the defaults that are used before yield normalization improves or degrades any startup perf metrics",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOe7U7yg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc57tTvK",
                                           "createdAt":  "2024-04-24T17:30:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-04-24T17:30:17Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Verify spin-waiting defaults before yield normalization occurs for ARM processors",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/101612",
        "createdAt":  "2024-04-26T16:28:57Z",
        "number":  101612,
        "author":  "alexwang1109",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-14T21:00:41Z",
        "body":  "### Description\n\nWe are using FixedWindowRateLimiter to limit the number of API requests per second to our vendor API endpoint. Sometimes, the FixedWindowRateLimiter has unexpected behavior, e.g., it doubles the rate from the configuration at the very beginning. \n\n### Reproduction Steps\n\nYou can run the attached program, and reproduce the described issue. The program is NOT \r\ngoing to call the API. Instead, it is writing timestamp to console.\r\n\r\n[Program.txt](https://github.com/dotnet/runtime/files/15133072/Program.txt)\r\n\r\n \n\n### Expected behavior\n\nThe FixedWindowRateLimiter should only allow 6 requests based on the configuration to hit API endpoint within each second.\n\n### Actual behavior\n\nAt the beginning, the FixedWindowRateLimiter actually allows 12 requests to hit API endpoint within the first second.\r\n[FixedWindowRateLimiter_API_log.txt](https://github.com/dotnet/runtime/files/15132761/FixedWindowRateLimiter_API_log.txt)\r\n[FixedWindowRateLimiter_console_log.txt](https://github.com/dotnet/runtime/files/15132955/FixedWindowRateLimiter_console_log.txt)\r\n\n\n### Regression?\n\nThis issue persists in all .NET Frameworks. The example program is using .NET Framework 4.8.\n\n### Known Workarounds\n\nWe will have to implement retry mechanism when \"429 too many requests\" error occurs.  \n\n### Configuration\n\n.NET Framework 4.8\r\nMicrosoft Windows 10 Pro\r\nx64\r\n\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOfAAA2A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc57_1u6",
                                           "createdAt":  "2024-04-27T02:51:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODfvBQA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alexwang1109",
                                                                               "createdAt":  "2024-04-27T04:00:14Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "BrennanConroy",
                                           "body":  "You are hitting the time window that resets the number of allowed requests. I\u0027m guessing you\u0027re running on a slow machine, or under the debugger, so it\u0027s taking close to 1 second before you start acquiring permits.\r\n\r\nSo what is happening is that you acquire 6 permits, but then almost immediately reset the amount of allowed permits due to the 1 second timer being hit.\r\n\r\nA better example of this (on a fast machine not under the debugger):\r\n```csharp\r\npublic static async Task Main(string[] args)\r\n{\r\n    Console.WriteLine($\"Start {DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss.fff\")}\");\r\n    RateLimiter limiter = new FixedWindowRateLimiter(\r\n                   new FixedWindowRateLimiterOptions\r\n                   {\r\n                       AutoReplenishment = true,\r\n                       PermitLimit = 6,\r\n                       QueueLimit = int.MaxValue,\r\n                       QueueProcessingOrder = QueueProcessingOrder.OldestFirst,\r\n                       Window = TimeSpan.FromSeconds(1),\r\n                   });\r\n\r\n    await Task.Delay(900); // get close to the 1 second reset window\r\n    for (var i = 0; i \u003c 13; i++)\r\n    {\r\n        using (RateLimitLease lease = await limiter.AcquireAsync(permitCount: 1))\r\n        {\r\n            Console.WriteLine(DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss.fff\"));\r\n        } // lease\r\n    }\r\n\r\n    Console.ReadKey();\r\n}\r\n```\r\nResults in:\r\n```\r\nStart 2024-04-26 19:48:58.923\r\n2024-04-26 19:48:59.874\r\n2024-04-26 19:48:59.883\r\n2024-04-26 19:48:59.883\r\n2024-04-26 19:48:59.883\r\n2024-04-26 19:48:59.883\r\n2024-04-26 19:48:59.883\r\n2024-04-26 19:48:59.930 \u003c-- 1 second window reset occurred\r\n2024-04-26 19:48:59.930\r\n2024-04-26 19:48:59.930\r\n2024-04-26 19:48:59.930\r\n2024-04-26 19:48:59.930\r\n2024-04-26 19:48:59.930\r\n2024-04-26 19:49:00.935\r\n```\r\nWhich can look like it took twice the limit.\r\n\r\nIt might be nice to only start counting once the limiter becomes active so this wouldn\u0027t be possible at all.",
                                           "updatedAt":  "2024-04-27T02:52:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57_58e",
                                           "createdAt":  "2024-04-27T04:02:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "alexwang1109",
                                           "body":  "This is definitely explaining what was going on. Now I understand this behavior. Thanks!",
                                           "updatedAt":  "2024-04-27T04:02:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc58AADY",
                                           "createdAt":  "2024-04-27T05:43:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-04-27T05:43:50Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "System.Threading.RateLimiting.FixedWindowRateLimiter sometimes doubles the configured rate ",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/101793",
        "createdAt":  "2024-05-02T10:40:15Z",
        "number":  101793,
        "author":  "TonyValenti",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-24T18:33:45Z",
        "body":  "### Background and motivation\n\nAcquiring one permit from a rate limiter and using a cancelation token is a common scenario.  This should be built in to the core\n\n### API Proposal\n\n```csharp\r\nnamespace System.Threading.RateLimiting;\r\n\r\npublic class RateLimiter\r\n{\r\n    public ValueTask\u003cRateLimitLease\u003e AcquireAsync(CancellationToken cancellationToken);\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nusing var Lease = await RateLimiter.AcquireAsync(Token);\r\n```\r\n\n\n### Alternative Designs\n\nThis could be implemented as an extension method.\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOfJVZbg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc58lVlu",
                                           "createdAt":  "2024-05-02T10:40:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-05-02T10:40:41Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "[API Proposal]: System.Threading.RateLimiting.RateLimiter.AcquireAsync(CancellationToken cancellationToken);",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/102326",
        "createdAt":  "2024-05-16T17:01:57Z",
        "number":  102326,
        "author":  "verdie-g",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-12T22:16:52Z",
        "body":  "When debugging a thread pool starvation issue, I can collect the WaitHandleWait event introduced in .NET 9 with https://github.com/dotnet/runtime/pull/94737. Though, if my sum-up the time spent waiting using this event, I\u0027ll often get such result:\r\n\r\n![image](https://github.com/dotnet/runtime/assets/9092290/e554f402-bd8c-4bab-92bb-25d6659f77ea)\r\nIn the screenshot from ([.NET Events Viewer](https://verdie-g.github.io/dotnet-events-viewer) :)), we can see that most of the time is spent on non-thread-pool threads which is fine and not relevant to my issue. I would like to be able to filter them out as they can be misleading, especially to someone unexperienced with this kind of investigation.\r\n\r\nWhat do you think about, whenever a trace is started, events are sent about the current managed threads. Something like that\r\n```\r\nManagedThreadId: 2337\r\nIsThreadPoolThread: false\r\n```\r\nand also, I can\u0027t find it anymore, but I think there is a `ThreadCreated` event that could be amended to also include the `IsThreadPoolThread` field.\r\n\r\ncc @kouvel @noahfalk ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOhLSUaQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5-HEDV",
                                           "createdAt":  "2024-05-16T17:02:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-05-16T17:02:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-RXcU",
                                           "createdAt":  "2024-05-17T23:19:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "Having rundown events that enumerate which threads are in the threadpool seems reasonable to me. We already have a thread enumeration there, but not a threadpool enumeration.\r\nCurious to hear what @brianrob and @kouvel think on it.\r\n\r\n\u003e I think there is a ThreadCreated event that could be amended to also include the IsThreadPoolThread field.\r\n\r\nDo you mean the ThreadCreatedRundown event on the rundown provider or the ThreadCreated event on the normal CLR provider? For the normal provider ThreadCreated event you won\u0027t be guaranteed to see it if your trace starts after the thread started. If you only care about traces that do start early enough to see that event there is also a [ThreadpoolWorkerThreadStart](https://learn.microsoft.com/en-us/dotnet/fundamentals/diagnostics/runtime-thread-events#threadpoolworkerthreadstart-event) event that identifies worker threads.",
                                           "updatedAt":  "2024-05-17T23:19:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-Rb7d",
                                           "createdAt":  "2024-05-17T23:51:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "verdie-g",
                                           "body":  "\u003e there is also a [ThreadpoolWorkerThreadStart](https://learn.microsoft.com/en-us/dotnet/fundamentals/diagnostics/runtime-thread-events#threadpoolworkerthreadstart-event) event that identifies worker threads.\r\n\r\nGreat! So yes in that case I would only be interested in an enumeration of the thread pool threads.",
                                           "updatedAt":  "2024-05-17T23:51:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-jIdK",
                                           "createdAt":  "2024-05-21T17:49:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODip-fA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "verdie-g",
                                                                               "createdAt":  "2024-05-21T20:58:21Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "brianrob",
                                           "body":  "This seems do-able, but I wonder if a more generic way to do this would be to use the thread name.  Thread pool worker threads get a unique name that gets set on thread start-up.  This gets emitted in rundown for ETW by the kernel, but I don\u0027t see it exposed in the nettrace.  We have some precedent for using the thread name in other places such as GC tooling where we detect GC threads by their name.",
                                           "updatedAt":  "2024-05-21T17:49:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5_S3s8",
                                           "createdAt":  "2024-05-28T16:19:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "verdie-g",
                                           "body":  "So when a nettrace starts, a new event would be sent for each running thread with their name. Then, we can use ThreadpoolWorkerThreadStart to monitor the change of threads?",
                                           "updatedAt":  "2024-05-28T16:19:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5_U19b",
                                           "createdAt":  "2024-05-28T21:54:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "brianrob",
                                           "body":  "I think that would be the idea.  Though, I am thinking that you might also need thread lifetime events to make sure that you know when a thread is created/destroyed more generically to ensure that if/when a thread ID gets re-used, that you don\u0027t assume an old value for the name.",
                                           "updatedAt":  "2024-05-28T21:54:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5_VM-b",
                                           "createdAt":  "2024-05-28T23:31:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODjnpiA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "verdie-g",
                                                                               "createdAt":  "2024-05-29T00:16:51Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "\u003e This gets emitted in rundown for ETW by the kernel, but I don\u0027t see it exposed in the nettrace\r\n\r\nYou can use the SequenceNumber on events to infer when a thread ID has been recycled almost always (https://github.com/microsoft/perfview/blob/main/src/TraceEvent/EventPipe/EventCache.cs#L150). It wasn\u0027t designed for that purpose originally and I\u0027d be happy to get a better mechanism but if you need something now it works.",
                                           "updatedAt":  "2024-05-28T23:31:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5_VW_j",
                                           "createdAt":  "2024-05-29T00:21:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "verdie-g",
                                           "body":  "\u003e We already have a thread enumeration there\r\n\r\nWhat event is that? Should I add ThreadName to that event?",
                                           "updatedAt":  "2024-05-29T00:21:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5_adus",
                                           "createdAt":  "2024-05-29T15:05:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "I like the idea of using the thread name. I\u0027m not sure about using the ThreadPoolWorkerThreadStart event though. There are several threads that are not TP worker threads and spend most of their time waiting, some of which don\u0027t run any user code, like the TP gate and wait threads, the timer thread, and IO poller threads. There could also be other app-specific threads that spend most of their time waiting and not doing much else.\r\n\r\nMaybe a new event would work better? The `Thread.Name` property can be set lazily but it can only be set once so when the name is set the event can be raised. Also when a `Thread` object is created for a thread the name can be checked and sent in the event if it has one (or when an external thread enters the runtime for the first time). Then on trace start the event can be sent for each thread in the thread store that has a name.\r\n\r\nThere is a [`ThreadCreated` event](https://github.com/dotnet/runtime/blob/23e15a51b8c45df8c5efbd5b80d577eaef981edb/src/coreclr/vm/eventtrace.cpp#L578) that could also be used to identify new threads. There is also a [`ThreadTerminated` event](https://github.com/dotnet/runtime/blob/23e15a51b8c45df8c5efbd5b80d577eaef981edb/src/coreclr/vm/ClrEtwAll.man#L3757-L3760) that is currently not sent for most threads, not sure if it\u0027s necessary for this case though.",
                                           "updatedAt":  "2024-05-29T15:06:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5_nYHE",
                                           "createdAt":  "2024-05-31T00:10:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "\u003e Then on trace start the event can be sent for each thread in the thread store that has a name.\r\n\r\nAnd maybe also a rundown event at the end of a tracing session, for cases where long-duration circular buffer tracing is done, where the initial events may be discarded.",
                                           "updatedAt":  "2024-05-31T00:12:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5_u1C_",
                                           "createdAt":  "2024-05-31T21:10:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "brianrob",
                                           "body":  "Agreed with @kouvel\u0027s comments here.  I suspect that this is data that we\u0027d like to have specifically for non-ETW cases, so I would probably put it under a new keyword so that we don\u0027t enable it when the kernel already provides such data (via ETW).",
                                           "updatedAt":  "2024-05-31T21:10:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5_vKCX",
                                           "createdAt":  "2024-05-31T22:45:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "I\u0027m thinking it could just be under the Threading keyword. Are there kernel events that provide the thread name? I\u0027m not familiar with it, and since the thread name can be set after the thread has started I\u0027m not sure if that would provide similar info.",
                                           "updatedAt":  "2024-05-31T22:45:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EtJRp",
                                           "createdAt":  "2024-07-12T22:16:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "brianrob",
                                           "body":  "Yes, there are Thread/SetName events that get fired if you set it after the thread gets created.",
                                           "updatedAt":  "2024-07-12T22:16:51Z"
                                       }
                                   ],
                         "totalCount":  13
                     },
        "title":  "Ability to filter thread pool thread events in a nettrace",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/102621",
        "createdAt":  "2024-05-23T18:04:25Z",
        "number":  102621,
        "author":  "vsfeedback",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC5Eymw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mahara",
                                            "createdAt":  "2024-05-27T13:44:37Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-07-02T16:35:50Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2024-07-10T16:26:40Z",
        "body":  "_This issue has been moved from [a ticket on Developer Community](https://developercommunity.visualstudio.com/t/Provide-a-way-to-verify-which-thread-own/10657187)._\n\n---\nOn the new Lock Class introduced on .NET 9.0 preview, we have a property (IsHeldByCurrentThread) that allows us to check whether the lock is being held by the current thread or not: https://learn.microsoft.com/en-us/dotnet/api/system.threading.lock?view=net-9.0\n\nHowever, if a lock is being hold by a different thread, it becomes difficult to determine which thread holds the lock. I understand that this isn\u0027t impossible to achieve, since Win32\u0027s critical section has an internal member that tells the user that information.\n\nHaving this supposed new property that tells us the current Id of the thread that\u0027s holding the lock could make software engineer\u0027s lives easier, as it would improve traceability when debugging code.\n\n---\n### Original Comments\n\n#### Feedback Bot on 5/10/2024, 10:36 PM: \n\n(private comment, text removed)",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOgvj9cQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5-0yyy",
                                           "createdAt":  "2024-05-23T18:13:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-05-23T18:13:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6C-P1x",
                                           "createdAt":  "2024-06-28T17:17:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "For heap dump diagnostics, https://github.com/dotnet/runtime/pull/101192 tracks info about threads waiting on a lock and provides info about which thread holds the lock.\r\n\r\n`Lock` tracks some thread ID in a field (managed thread ID in NativeAOT, and OS thread ID elsewhere). For on-the-fly traceability or temporary purposes that could be used.\r\n\r\nIf there were to be an API to expose it, since managed thread IDs are opaque, there probably would need to also be a way to translate one to a Thread object and a way to obtain the corresponding OS thread ID. Could be considered if there\u0027s a need, please open an API suggestion with more details in that case.",
                                           "updatedAt":  "2024-06-28T17:17:07Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Provide a way to verify which thread owns a lock",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/102666",
        "createdAt":  "2024-05-24T16:43:10Z",
        "number":  102666,
        "author":  "kouvel",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-12-09T18:34:21Z",
        "body":  "Below is an example of a deadlock that was seen.\r\n\r\nThread 1:\r\n- Enters a concurrent queue\u0027s cross-segment lock [here](https://github.com/dotnet/runtime/blob/919e5b2b4995c0769f49d272042de50533b47c75/src/libraries/System.Private.CoreLib/src/System/Collections/Concurrent/ConcurrentQueue.cs#L629)\r\n- OOM exception occurs [here](https://github.com/dotnet/runtime/blob/919e5b2b4995c0769f49d272042de50533b47c75/src/libraries/System.Private.CoreLib/src/System/Collections/Concurrent/ConcurrentQueue.cs#L646) in array allocation\r\n- `MemoryCache`\u0027s unhandled exception handler [runs](https://github.com/dotnet/runtime/blob/919e5b2b4995c0769f49d272042de50533b47c75/src/libraries/System.Runtime.Caching/src/System/Runtime/Caching/MemoryCache.cs#L247), [disposes stats](https://github.com/dotnet/runtime/blob/919e5b2b4995c0769f49d272042de50533b47c75/src/libraries/System.Runtime.Caching/src/System/Runtime/Caching/MemoryCache.cs#L477), [disposes timer](https://github.com/dotnet/runtime/blob/919e5b2b4995c0769f49d272042de50533b47c75/src/libraries/System.Runtime.Caching/src/System/Runtime/Caching/MemoryCacheStatistics.cs#L343), which tries to enter a `TimerQueue` lock [here](https://github.com/dotnet/runtime/blob/919e5b2b4995c0769f49d272042de50533b47c75/src/libraries/System.Private.CoreLib/src/System/Threading/Timer.cs#L570) and blocks because Thread 2 holds the lock\r\n\r\nThread 2:\r\n- Enters the `TimerQueue` lock [here](https://github.com/dotnet/runtime/blob/919e5b2b4995c0769f49d272042de50533b47c75/src/libraries/System.Private.CoreLib/src/System/Threading/Timer.cs#L184)\r\n- Tries to [queue a timer callback](https://github.com/dotnet/runtime/blob/919e5b2b4995c0769f49d272042de50533b47c75/src/libraries/System.Private.CoreLib/src/System/Threading/Timer.cs#L265), which tries to enter the concurrent queue\u0027s cross-segment lock [here](https://github.com/dotnet/runtime/blob/919e5b2b4995c0769f49d272042de50533b47c75/src/libraries/System.Private.CoreLib/src/System/Collections/Concurrent/ConcurrentQueue.cs#L629) and blocks because Thread 1 holds the lock\r\n\r\nThe two threads are deadlocked. Unhandled exceptions can occur in arbitrary places and there may also be other cases. A solution could be to not dispose the timer on the unhandled exception path.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOlr4xlg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6CBMa9",
                                           "createdAt":  "2024-06-20T19:05:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "Related: https://github.com/dotnet/runtime/issues/64115",
                                           "updatedAt":  "2024-06-20T19:05:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6DDyTV",
                                           "createdAt":  "2024-06-30T23:46:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "StephenMolloy",
                                           "body":  "The System.Runtime.Caching team is working on a [PR](#105853) for 9.0 that we will try to get approved for backporting to 6/8. But I\u0027ve associated that PR to the previously-reported related bug, since it only addresses this System.Runtime.Caching manifestation of what I really think is a larger issue. I could be mistaken, but I\u0027ve always been under the impression that IDisposable things should be disposed, and I\u0027m not seeing any guidance where we recommend people to not dispose things inside an unhandled exception handler. To be honest, MemoryCache is kind of stuck in a difficult place here, because we can only know if we\u0027re in our own UnhandledException handler, and we do have to clean up a handle either way. If somebody else has the bright idea to Dispose things that are IDisposable and calls our Dispose method directly, MemoryCache can\u0027t know if it\u0027s in an UnhandledException handler or not - whether it should Dispose it\u0027s Timer or not. And certainly, while MemoryCache might be more likely to hit this issue with it\u0027s propensity to push the OOM line and it\u0027s use of an UnhandledException handler - there isn\u0027t anything specific to MemoryCache that causes this in a way that any other responsible resource-disposing code couldn\u0027t also hit.\n\nHopefully this PR unblocks the majority of instances of this issue for folks. But I think the Timer team should take a look as well.",
                                           "updatedAt":  "2024-12-09T18:18:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6DDydz",
                                           "createdAt":  "2024-06-30T23:48:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-06-30T23:48:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Jqgwp",
                                           "createdAt":  "2024-08-26T08:17:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ahofman",
                                           "body":  "@kouvel @StephenMolloy is it clear when this issue was introduced? Is this a regression in an 8.0.x release or has it been there forever? ",
                                           "updatedAt":  "2024-08-26T08:17:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Wvirt",
                                           "createdAt":  "2024-12-09T18:33:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "StephenMolloy",
                                           "body":  "Sorry for the confusion on this thread here. The issue was \"introduced\" when TimerQueue was update in .Net 5.0 to reduce lock contention. \n\nThe background here is that System.Runtime.Caching is a bridge port of a general purpose cache from .Net Framework, so it has always done cleanup in a .Net Framework-informed way, where AppDomains are an actual useful thing. .Net Core has evolved to take a different approach. Anyway, when TimerQueue was updated in .Net 5.0 to use a multi-lock strategy for efficiency, it left a window for potential deadlock for anybody who uses TimerQueue and cleans up their AppDomain like MemoryCache did.\n\nMemoryCache was updated in 9.0 ([PR #103937](#103937) and later [PR #105853](#105853), then backported to 8.0 [PR #106221](#106221)) to take a more .Net Core approach to clean up that will avoid hitting this deadlock. Subsequently, the [duplicate issue](#64115) tracking this for MemoryCache was closed. I left this one open and added the area-System.Threading label so the TimerQueue team could have an opportunity to evaluate and decide if they want to do anything with this pattern. If not, I leave it to them to resolve/close. MemoryCache is already done.",
                                           "updatedAt":  "2024-12-09T18:33:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6WvjGW",
                                           "createdAt":  "2024-12-09T18:34:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-12-09T18:34:19Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "`MemoryCache`\u0027s unhandled exception handler disposes a timer that takes a lock and can lead to deadlock",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/103509",
        "createdAt":  "2024-06-15T08:17:44Z",
        "number":  103509,
        "author":  "EgorBo",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODFiCSw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MihaZupan",
                                            "createdAt":  "2024-06-15T08:35:51Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Rob-Hague",
                                            "createdAt":  "2024-06-15T08:39:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "neon-sunset",
                                            "createdAt":  "2024-06-15T08:41:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "y0ung3r",
                                            "createdAt":  "2024-06-15T08:43:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ImoutoChan",
                                            "createdAt":  "2024-06-15T08:47:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aloraman",
                                            "createdAt":  "2024-06-15T08:51:29Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "aloraman",
                                            "createdAt":  "2024-06-15T08:51:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "campersau",
                                            "createdAt":  "2024-06-15T08:55:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "breadnone",
                                            "createdAt":  "2024-06-15T09:06:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "karb0f0s",
                                            "createdAt":  "2024-06-15T09:06:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "1MrEnot",
                                            "createdAt":  "2024-06-15T09:09:31Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "huoyaoyuan",
                                            "createdAt":  "2024-06-15T09:10:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hrrrrustic",
                                            "createdAt":  "2024-06-15T09:16:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "h3xds1nz",
                                            "createdAt":  "2024-06-15T09:41:50Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "JakeYallop",
                                            "createdAt":  "2024-06-15T11:06:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2024-06-15T12:24:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Xor-el",
                                            "createdAt":  "2024-06-15T12:36:16Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "cometoeternity",
                                            "createdAt":  "2024-06-15T12:45:42Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "NightlyRevenger",
                                            "createdAt":  "2024-06-15T12:51:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "CooperMidnight",
                                            "createdAt":  "2024-06-15T16:03:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-06-15T17:04:05Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "saul",
                                            "createdAt":  "2024-06-16T19:08:36Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "max-best",
                                            "createdAt":  "2024-06-16T20:48:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "D3-LucaPiombino",
                                            "createdAt":  "2024-06-16T22:31:52Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Sergio0694",
                                            "createdAt":  "2024-06-17T05:02:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Wraith2",
                                            "createdAt":  "2024-06-17T07:26:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "saucecontrol",
                                            "createdAt":  "2024-06-18T02:22:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "extense1337",
                                            "createdAt":  "2024-06-18T05:45:37Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ufcpp",
                                            "createdAt":  "2024-06-19T01:38:05Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kronic",
                                            "createdAt":  "2024-06-19T19:13:37Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "avsorokin",
                                            "createdAt":  "2024-06-20T20:27:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SlavkaOnline",
                                            "createdAt":  "2024-06-21T14:15:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Hawxy",
                                            "createdAt":  "2024-07-10T06:39:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "cremor",
                                            "createdAt":  "2024-07-17T14:51:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MineCake147E",
                                            "createdAt":  "2024-11-07T10:41:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mthesing88",
                                            "createdAt":  "2025-02-13T07:41:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mus65",
                                            "createdAt":  "2025-02-19T20:33:04Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aromaa",
                                            "createdAt":  "2025-06-15T14:49:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "BoundedChenn31",
                                            "createdAt":  "2025-07-03T03:51:38Z"
                                        }
                                    ],
                          "totalCount":  39
                      },
        "updatedAt":  "2025-06-15T07:17:03Z",
        "body":  "### Background and motivation\r\n\r\nA classic pattern for locks in async code looks like this:\r\n```cs\r\nreadonly SemaphoreSlim _semaphoreSlim = new (1);\r\n\r\nasync Task DoWork()\r\n{\r\n    await _semaphoreSlim.WaitAsync();\r\n    try\r\n    {\r\n        // some work\r\n    }\r\n    finally\r\n    {\r\n        _semaphoreSlim.Release();\r\n    }\r\n}\r\n```\r\nThis pattern feels a bit too verbose compared to non-async `lock` and it\u0027s important to keep in mind that `Release` has to be called in `finally` block to avoid dead-locks. I propose we add a new API for `SemaphoreSlim` so the same program can be simplified down to\r\n```cs\r\nasync Task DoWork1()\r\n{\r\n    using (var scope = await _semaphoreSlim.EnterScope())\r\n    {\r\n        // do some work\r\n    }\r\n}\r\n\r\n// or\r\n\r\nasync Task DoWork2()\r\n{\r\n    using var _ = await _semaphoreSlim.EnterScope();\r\n    // do some work\r\n}\r\n```\r\nSimilarily to [Lock.EnterScope](https://apisof.net/catalog/19a7f990a1c749e8f0b942b76fd2f7b2) API.\r\n\r\n\r\n\r\n### API Proposal\r\n\r\n```diff\r\nnamespace System.Threading;\r\n\r\npublic class SemaphoreSlim\r\n{\r\n+   public ValueTask\u003cSemaphoreSlim.Scope\u003e EnterScope();\r\n+   public ValueTask\u003cSemaphoreSlim.Scope\u003e EnterScope(CancellationToken cancellationToken);\r\n+   public ValueTask\u003cSemaphoreSlim.Scope\u003e EnterScope(int millisecondsTimeout);\r\n+   public ValueTask\u003cSemaphoreSlim.Scope\u003e EnterScope(TimeSpan timeout, CancellationToken cancellationToken);\r\n+   public ValueTask\u003cSemaphoreSlim.Scope\u003e EnterScope(int millisecondsTimeout, CancellationToken cancellationToken);\r\n\r\n+   public readonly struct Scope : IDisposable\r\n+   {\r\n+       public void Dispose();\r\n+   }\r\n}\r\n```\r\nI am not sure about the overloads, I just copied the exising ones from `WaitAsync` for consistency, I\u0027d pesonally add only these:\r\n```diff\r\n+   public ValueTask\u003cSemaphoreSlim.Scope\u003e EnterScope(CancellationToken cancellationToken = default);\r\n+   public ValueTask\u003cSemaphoreSlim.Scope\u003e EnterScope(TimeSpan timeout, CancellationToken cancellationToken = default);\r\n```\r\nAlso, should it be `EnterScopeAsync` ?\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\nusing var _ = await _semaphoreSlim.EnterScope();\r\n```\r\nSadly, C# doesn\u0027t allow to omit the variable so we could have something like:\r\n```cs\r\nusing await _semaphoreSlim.EnterScope();\r\n// or at least:\r\nusing _ = await _semaphoreSlim.EnterScope();\r\n```\r\n\r\n### Alternative Designs\r\n\r\nWe can extend the `lock` keyword in C# to support `async/await` like we recently extended it to support the new `Lock` type. I think it\u0027s a popular pain point when developers (especially newcomers) try to use `lock (obj)` for async code and then have to google how to workaround the compilation failure.\r\n\r\n```cs\r\nreadonly SemaphoreSlim _semaphoreSlim = new (1);\r\n\r\nasync Task DoWork()\r\n{\r\n    lock (_semaphoreSlim)\r\n    // await lock (_semaphoreSlim) ?\r\n    {\r\n    }\r\n}\r\n```\r\nOr at very least, Roslyn could suggest to use `SemaphoreSlim` in the error text when user tries to use normal `lock` for async blocks.\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOsTzQvw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6BS2Xq",
                                           "createdAt":  "2024-06-15T08:18:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-06-15T08:18:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6BS3cj",
                                           "createdAt":  "2024-06-15T08:28:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEWpW8w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "EgorBo",
                                                                               "createdAt":  "2024-06-15T08:30:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CaCTuCaTu4ECKuu",
                                                                               "createdAt":  "2025-06-15T06:48:47Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "jcotton42",
                                           "body":  "In the case of\r\n```diff\r\n+public sealed class SemaphoreSlimReleaser(SemaphoreSlim semaphore) : IDisposable\r\n+{\r\n+   public void Dispose() =\u003e semaphore.Release();\r\n+}\r\n```\r\nWould we maybe want an `idDisposed` bool field or similar, to prevent double release by disposing the same releaser twice?",
                                           "updatedAt":  "2024-06-15T08:28:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6BS4Ab",
                                           "createdAt":  "2024-06-15T08:32:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODlynjw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "EgorBo",
                                                                               "createdAt":  "2024-06-15T08:35:17Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "neon-sunset",
                                                                               "createdAt":  "2024-06-15T08:41:31Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "breadnone",
                                                                               "createdAt":  "2024-06-15T09:07:07Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-06-15T17:04:15Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "I\u0027d make `EnterScope` a `ValueTask` and change `SemaphoreSlimReleaser` to a `public struct Scope` nested type (similar to `Lock`\u0027s scope in #34812).",
                                           "updatedAt":  "2024-06-15T08:32:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6BS5a4",
                                           "createdAt":  "2024-06-15T08:41:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEWpXAw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "neon-sunset",
                                                                               "createdAt":  "2024-06-15T13:08:41Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CooperMidnight",
                                                                               "createdAt":  "2024-06-15T16:04:07Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-06-15T17:04:22Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "saul",
                                                                               "createdAt":  "2024-06-16T19:08:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "sauronazm",
                                                                               "createdAt":  "2024-06-17T08:47:35Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ilmax",
                                                                               "createdAt":  "2024-06-19T08:57:53Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kronic",
                                                                               "createdAt":  "2024-06-19T19:10:50Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "OlsonDev",
                                                                               "createdAt":  "2024-07-13T01:50:01Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CaCTuCaTu4ECKuu",
                                                                               "createdAt":  "2025-06-15T06:49:04Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  9
                                                         },
                                           "author":  "y0ung3r",
                                           "body":  "\u003e Also, should it be `EnterScopeAsync`?\r\n\r\nMy personal opinion - yes",
                                           "updatedAt":  "2024-06-15T08:41:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6BS_rn",
                                           "createdAt":  "2024-06-15T09:23:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODl0kwg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "CONFUSED",
                                                                               "user":  "En3Tho",
                                                                               "createdAt":  "2024-06-16T09:00:32Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "aloraman",
                                           "body":  "This pattern of issuing a small *cookie*-object, while changing the state of the owner, and reverting the owner\u0027s state on cookie disposal - it\u0027s quite familiar and somewhat well-known. I\u0027m so accustomed to it, that I would\u0027ve chosen the name `SemaphoreReleaseCookie` without a hint of hesitation. That said, MSFT uses the term \u0027cookie\u0027 mostly for stack canary scenarios, so it doesn\u0027t fit here.\r\nNevertheless, I would suggest the following:\r\n - Do make this cookie object not a class, but a readonly struct.\r\n - Don\u0027t bother with double-release prevention, IMHO, additional security for advanced usage scenarios just isn\u0027t worth the overhead.",
                                           "updatedAt":  "2024-06-15T09:23:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6BTYMI",
                                           "createdAt":  "2024-06-15T11:10:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEWpXNA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "y0ung3r",
                                                                               "createdAt":  "2024-06-16T09:13:06Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "shuowpro",
                                                                               "createdAt":  "2024-06-16T15:36:03Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CooperMidnight",
                                                                               "createdAt":  "2024-06-17T00:48:12Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Wisdou",
                                                                               "createdAt":  "2024-06-17T13:23:22Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kronic",
                                                                               "createdAt":  "2024-06-19T19:11:20Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CaCTuCaTu4ECKuu",
                                                                               "createdAt":  "2025-06-15T06:50:05Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  6
                                                         },
                                           "author":  "JakeYallop",
                                           "body":  "I\u0027ve used this pattern so many times, I\u0027m surprised something similar hasn\u0027t been proposed before. I think the name should be `EnterScopeAsync`, to fit with basically every other API that returns a `Task` or `ValueTask`.",
                                           "updatedAt":  "2024-06-15T11:10:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6BT_Pn",
                                           "createdAt":  "2024-06-15T12:42:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Rob-Hague",
                                           "body":  "I have also used this pattern a lot and would welcome something more idiomatic. One thing though, is that in practically all cases I am also using the equivalent sync pattern. It would be nice if both async and sync variants of the pattern were available.\r\n\r\nBy the way, this exists already in Stephen Cleary\u0027s package (https://github.com/StephenCleary/AsyncEx/blob/master/src/Nito.AsyncEx.Tasks/SemaphoreSlimExtensions.cs). If we were going there, it would be even nicer if there were a dedicated type which can participate in synchronous and asynchronous mutual exclusion, including with Monitor.Wait\u0026Pulse-like semantics. Basically, something similar to Cleary\u0027s AsyncMonitor/AsyncLock (https://github.com/StephenCleary/AsyncEx/blob/master/src/Nito.AsyncEx.Coordination/AsyncMonitor.cs) but perhaps that\u0027s a separate discussion.",
                                           "updatedAt":  "2024-06-15T12:42:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6BrJdv",
                                           "createdAt":  "2024-06-18T08:57:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lilinus",
                                           "body":  "\u003e I\u0027d make `EnterScope` a `ValueTask` and change `SemaphoreSlimReleaser` to a `public struct Scope` nested type (similar to `Lock`\u0027s scope in #34812).\r\n\r\nJust to point  out a potential caveat:\r\nIf the scope has a field that prevents double-releasing and is a struct, would it not still be possible to release twice if the struct is copied?",
                                           "updatedAt":  "2024-06-18T08:57:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6BucQd",
                                           "createdAt":  "2024-06-18T15:51:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jaredpar",
                                           "body":  "\u003e Similarily to [Lock.EnterScope](https://apisof.net/catalog/19a7f990a1c749e8f0b942b76fd2f7b2) API.\r\n\r\nGiven the similarity should we consider expanding the new C# `lock` support to include this type? When we started the work on `Lock.EnterScope` in was specific to that type because there were no other examples. \r\n",
                                           "updatedAt":  "2024-06-18T15:51:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6BuoKE",
                                           "createdAt":  "2024-06-18T16:12:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "\u003e \u003e Similarily to [Lock.EnterScope](https://apisof.net/catalog/19a7f990a1c749e8f0b942b76fd2f7b2) API.\r\n\u003e \r\n\u003e Given the similarity should we consider expanding the new C# `lock` support to include this type? When we started the work on `Lock.EnterScope` in was specific to that type because there were no other examples.\r\n\r\nI guess the main problem that it\u0027s not obvious what it should do, the wait in this case is async, so should it look like this:\r\n```cs\r\nlock (obj) // await is implicit, requires method to be async. obj must be SemaphoreSlim (or some duck-typing check)\r\n{\r\n}\r\n```\r\nor it needs to be a new construct:\r\n```cs\r\nawait lock (obj)\r\n{\r\n}\r\n```",
                                           "updatedAt":  "2024-06-18T16:12:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6B-wFP",
                                           "createdAt":  "2024-06-20T13:33:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "quinmars",
                                           "body":  "I think it should be `await lock (...)` analog to `using` and `foreach`. More problematic is how you can pass the cancellation token and the timeout and how you can `.ConfigureAwait`?",
                                           "updatedAt":  "2024-06-20T13:33:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6fqWJ_",
                                           "createdAt":  "2025-02-24T14:48:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tjwald",
                                           "body":  "I like the enter scope as it allows configuring how to enter the scope in a very simple manner.\nAnd I also think that we should also have support for: \n```csharp\nawait using (var scope = _semaphore.EnterScope(...))\n{\n    ...\n}\n```\n\nAnd this is simply up to the user whether to use the await or the sync version. \nThis doesn\u0027t require any language changes as this is all supported given that SemaphoreSlim\u0027s Scope will implement both `IDisposable` and `IAsyncDisposable`.\n\nIf you do choose to support both, there should be an analyzer that tells you to use the await version when in an async functions.\n\n\u003e @quinmars how you can `.ConfigureAwait`? \n\nHow do you configure await on any `IAsyncDisposable`?\n",
                                           "updatedAt":  "2025-02-24T14:48:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6xPNC_",
                                           "createdAt":  "2025-06-15T07:11:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEWpdtQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tjwald",
                                                                               "createdAt":  "2025-06-15T08:13:33Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "CaCTuCaTu4ECKuu",
                                           "body":  "The thing is **Release** is actually _sync_, but entering scope awaits _async_, so it has to be\n```csharp\nusing var scope = await _semaphore.EnterScopeAsync(cancellationToken);\n```\nAnd you should have check for double releasing because you may want to have few locks and manually dispose them in random places\n\nOther thing is that it\u0027s not so obvious how to better implement entering lock scope with timeout. It may look like it doesn\u0027t matter but when you using time limit you actually want to handle it like this\n```csharp\nif (!await _semaphore.WaitAsync(timeout))\n{\n    // Handle fail\n    return;\n}\n```\nAnd with scope it have more variants of implementations that you would like to, from just throwing an exception (which is best for use of scoped locks imo) to making IsLocked property or adding boolean equality comparer to token to check if it has entered lock state (still success lock enter state)\n\nBut all of it aside, if you think about it, you actually 80% of time want to just simplify code and write locking of code within method with 1 line and for other cases you actually will be okay with current SemaphoreSlim. But still even covering this single use case I believe justify adding little class/struct and extension method - it\u0027s so good where there\u0027s a lot of basic locking needed\n\n#### To summarize:\n1. `SemaphoreSlimScopeToken` struct\n2. Extension method `Task\u003cSemaphoreSlimScopeToken\u003e EnterScopeAsync(this SemaphoreSlim semaphore, CancellationToken ct = default)`",
                                           "updatedAt":  "2025-06-15T07:17:03Z"
                                       }
                                   ],
                         "totalCount":  13
                     },
        "title":  "[API Proposal]: SemaphoreSlim.EnterScope",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/103516",
        "createdAt":  "2024-06-15T12:11:30Z",
        "number":  103516,
        "author":  "teo-tsirpanis",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC7_ASg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MitchRazga",
                                            "createdAt":  "2024-10-20T14:32:37Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-07-03T20:48:44Z",
        "body":  "### Background and motivation\n\nWith the new `Lock` type\u0027s introduction, we can add new overloads of `LazyInitializer.EnsureInitialized`  that accept a `ref Lock?` instead of a `ref object?` as the synchronization object, allowing users to easily migrate their code.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Threading;\r\n\r\npublic static partial class LazyInitializer\r\n{\r\n    public static T EnsureInitialized\u003c[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)] T\u003e([AllowNull] ref T target, ref bool initialized, [NotNullIfNotNull(\"syncLock\")] ref Lock? syncLock);\r\n\r\n    public static T EnsureInitialized\u003cT\u003e([AllowNull] ref T target, ref bool initialized, [NotNullIfNotNull(\"syncLock\")] ref Lock? syncLock, Func\u003cT\u003e valueFactory);\r\n\r\n    public static T EnsureInitialized\u003cT\u003e([NotNull] ref T? target, [NotNullIfNotNull(\"syncLock\")] ref Lock? syncLock, Func\u003cT\u003e valueFactory) where T : class;\r\n}\r\n```\r\n\n\n### API Usage\n\n_same as the existing `LazyInitializer.EnsureInitialized` overloads_\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOgU6s8A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6BTqzw",
                                           "createdAt":  "2024-06-15T12:11:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-06-15T12:11:53Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "[API Proposal]: `LazyInitializer.EnsureInitialized` overloads that accept `ref Lock?`.",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/103684",
        "createdAt":  "2024-06-19T06:52:20Z",
        "number":  103684,
        "author":  "benaadams",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC41fiA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2024-06-19T09:04:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AlgorithmsAreCool",
                                            "createdAt":  "2024-06-23T14:33:54Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2024-06-28T16:54:33Z",
        "body":  "### Background and motivation\n\n`ThreadLocal\u003cT\u003e` is a good approach to gather uncontended metrics; however then collating those metrics via `ThreadLocal.Values` is very allocatey.\r\n\r\nIt would be better to provide a struct enumerator that can be iterated over for no allocations.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Threading;\r\n\r\npublic class ThreadLocal\u003cT\u003e : IEnumerable\u003cT\u003e\r\n{\r\n    public StructEnumerator GetEnumerator();\r\n    // etc.\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\n[CounterMetric]\r\npublic static long Calls\r\n{\r\n    get\r\n    {\r\n        long total = 0;\r\n        foreach (var value in _calls)\r\n        {\r\n            total += value;\r\n        }\r\n        return total;\r\n    }\r\n}\r\nprivate static ThreadLocal\u003clong\u003e _calls = new(trackAllValues: true);\r\npublic static void IncrementCalls(int delta) =\u003e _calls.Value+= delta;\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOgeKXQg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6Bz__4",
                                           "createdAt":  "2024-06-19T06:56:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-06-19T06:56:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6B30xb",
                                           "createdAt":  "2024-06-19T14:47:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "Should the enumerator return values or references to the underlying storage? I assume the latter would be problematic due to making mutations from multiple threads possible?",
                                           "updatedAt":  "2024-06-19T14:47:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6B4pdC",
                                           "createdAt":  "2024-06-19T16:42:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "\u003e Should the enumerator return values or references to the underlying storage? I assume the latter would be problematic due to making mutations from multiple threads possible?\r\n\r\nValues; can always wrap with an object if want reference of values",
                                           "updatedAt":  "2024-06-19T16:42:51Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "[API Proposal]: ThreadLocal\u003cT\u003e.GetEnumerator()",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/103812",
        "createdAt":  "2024-06-21T12:14:33Z",
        "number":  103812,
        "author":  "AdamFrisby",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODCLdNA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SupinePandora43",
                                            "createdAt":  "2024-10-19T18:50:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AlphaBs",
                                            "createdAt":  "2025-01-29T16:16:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rjmurillo",
                                            "createdAt":  "2025-02-12T01:50:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rgroenewoudt",
                                            "createdAt":  "2025-05-08T19:10:08Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2024-07-03T20:47:46Z",
        "body":  "### Description\r\n\r\nWhen running a load that is highly burstable - i.e. creates lots of threadpool workers that aren\u0027t used persistently, the threadpool itself uses a lot of CPU time waiting for jobs, that could interfere with background processes (outside the application).\r\n\r\nThe codebase extensively uses async/await for primarily low-level networking related operations.\r\n\r\n### Configuration\r\n\r\n.NET Core LTS 6.0\r\nLinux (Ubuntu 22.04)\r\nAWS EC2 t2.medium host\r\n\r\n### Data\r\n\r\nMeasured using a combination of htop and JetBrain\u0027s dotTrace - when 17 threadpool workers are created, the system CPU usage is around 75% +/- 15% (averaging both cores).\r\n\r\ndotTrace (sampling mode) reports that 35.4% of the CPU usage is spent in the following stack trace:\r\n\r\n```\r\nSystem.Threading.LowLevelLifoSemaphore.WaitNative(SafeWaitHandle, Int32)\r\nSystem.Threading.LowLevelLifoSemaphore.WaitForSignal(Int32)\r\nSystem.Threading.LowLevelLifoSemaphore.Wait(Int32, Boolean)\r\nSystem.Threading.PortableThreadPool+WorkerThread.WorkerThreadStart()\r\nSystem.Threading.Thread.StartCallback()\r\n```\r\n\r\nAnother 45% or so is spread among\r\n\r\n10.5%\r\n`System.Threading.Monitor.Wait(Object, Int32)`\r\n\r\n9.8%\r\n`System.IO.FileSystemWatcher+RunningInstance.TryReadEvent(out NotifyEvent)`\r\n\r\n8.7%\r\n```\r\nSystem.Threading.WaitHandle.WaitOneNoCheck(Int32)\r\nSystem.Threading.PortableThreadPool+GateThread.GateThreadStart()\r\nSystem.Threading.Thread.StartCallback()\r\n```\r\n\r\n5.3%\r\n`System.Threading.Thread.Sleep(Int32)`\r\n\r\n4.9%\r\n`Interop+Sys.WaitForSocketEvents(IntPtr, SocketEvent*, Int32*)`\r\n\r\nWhich all appear to be roughly symptomatic of the same thing - even if different in specifics.\r\n\r\n### Analysis\r\n\r\nAcross a range of areas (see stack traces above) the runtime appears to be spinlocking while waiting for jobs, rather than using interrupts which _may_ be better in this scenario when some latency in picking up the job is acceptable (i.e. I\u0027m fine waiting 5ms for the job to start).\r\n\r\nThis would allow the CPU to idle more lowering both environmental impact (both real world, and within the OS instance), as well as better manage things such as AWS\u0027s CPU Credits; and provide more accurate reporting in system level analytics on the real system load.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOgh9iBA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6CGGm0",
                                           "createdAt":  "2024-06-21T12:14:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-06-21T12:14:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6CGs4z",
                                           "createdAt":  "2024-06-21T13:49:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD3Ln3Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "SupinePandora43",
                                                                               "createdAt":  "2024-10-19T18:51:50Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "You can control this behaviour via `DOTNET_ThreadPool_UnfairSemaphoreSpinLimit`, e.g. set it to just `0` to prefer `sched_yield` over spin locks. It\u0027s a known issue that our heuristics need some tunning as they\u0027re focused mainly on quick short-living tasks and lead to unnecessary cpu usage for other scenarios due to long spin waits.",
                                           "updatedAt":  "2024-06-21T13:49:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6CGt5_",
                                           "createdAt":  "2024-06-21T13:52:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AdamFrisby",
                                           "body":  "Brilliant, thankyou @EgorBo - we\u0027ll give that a try.\r\n\r\nCan that be changed via code, or environmental only?",
                                           "updatedAt":  "2024-06-21T13:52:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6CGvgp",
                                           "createdAt":  "2024-06-21T13:56:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEGGg6g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "bogoslovskiy",
                                                                               "createdAt":  "2025-02-12T11:56:04Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "\u003e Brilliant, thankyou @EgorBo - we\u0027ll give that a try.\r\n\u003e \r\n\u003e Can that be changed via code, or environmental only?\r\n\r\nEither environment variable `DOTNET_ThreadPool_UnfairSemaphoreSpinLimit=0` or runtime config json `System.Threading.ThreadPool.UnfairSemaphoreSpinLimit`, can\u0027t be set via code.",
                                           "updatedAt":  "2024-06-21T13:56:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6CGyFg",
                                           "createdAt":  "2024-06-21T14:01:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "filipnavara",
                                           "body":  "Note that calls like `LowLevelLifoSemaphore.WaitNative`, `WaitHandle.WaitOneNoCheck` and in most cases `Monitor.Wait` are not really consuming CPU time. If you run a sampling profiler, which is common configuration of dotTrace, you will inevitably see time spent in those methods but it doesn\u0027t mean that it\u0027s consuming CPU resources.",
                                           "updatedAt":  "2024-06-21T14:01:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6CGy3N",
                                           "createdAt":  "2024-06-21T14:03:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "\u003e Note that calls like `LowLevelLifoSemaphore.WaitNative`, `WaitHandle.WaitOneNoCheck` and in most cases `Monitor.Wait` are not really consuming CPU time. If you run a sampling profiler, which is common configuration of dotTrace, you will inevitably see time spent in those methods but it doesn\u0027t mean that it\u0027s consuming CPU resources.\r\n\r\nIt\u0027s usually much worse on arm64 due to lack of `pause` alternative",
                                           "updatedAt":  "2024-06-21T14:03:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6CGzlD",
                                           "createdAt":  "2024-06-21T14:05:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "filipnavara",
                                           "body":  "\u003e It\u0027s usually much worse on arm64 due to lack of `pause` alternative\r\n\r\nThese are not spin wait though, at least predominantly so. They are OS event waits that should completely block the thread from being scheduled.",
                                           "updatedAt":  "2024-06-21T14:05:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6CG1ea",
                                           "createdAt":  "2024-06-21T14:09:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "Oops, right, I didn\u0027t notice that it\u0027s `WaitForSignal` that is hot here, so it\u0027s not related to spin waits.",
                                           "updatedAt":  "2024-06-21T14:12:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6CG2Jn",
                                           "createdAt":  "2024-06-21T14:10:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AdamFrisby",
                                           "body":  "\u003e Note that calls like `LowLevelLifoSemaphore.WaitNative`, `WaitHandle.WaitOneNoCheck` and in most cases `Monitor.Wait` are not really consuming CPU time. If you run a sampling profiler, which is common configuration of dotTrace, you will inevitably see time spent in those methods but it doesn\u0027t mean that it\u0027s consuming CPU resources.\r\n\r\nThis is what I\u0027d expect, but monitoring via `top`/`htop` does seem to show the process actually using CPU time too.",
                                           "updatedAt":  "2024-06-21T14:10:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6CG4ZV",
                                           "createdAt":  "2024-06-21T14:16:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "filipnavara",
                                           "body":  "\u003e This is what I\u0027d expect, but monitoring via `top`/`htop` does seem to show the process actually using CPU time too.\r\n\r\nI\u0027d expect most of these wait calls to be [red herrings](https://en.wikipedia.org/wiki/Red_herring). Not sure if dotTrace is the best profiler for this but perhaps there\u0027s something else in the Hot Spots view?\r\n\r\nThe file system watcher may be relevant.\r\n\r\n`WaitForSocketEvents` CPU usage is also not odd for server-side apps but there could be some issues around the network request processing that may stress it more.",
                                           "updatedAt":  "2024-06-21T14:16:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6CG5Um",
                                           "createdAt":  "2024-06-21T14:18:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "`WaitForSocketEvents` is effectively an infinite loop over `epoll_wait` where `epoll_wait` syscall may also either use spin-wait or sched_yeild internally.",
                                           "updatedAt":  "2024-06-21T14:18:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6CG7JJ",
                                           "createdAt":  "2024-06-21T14:22:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AdamFrisby",
                                           "body":  "\u003e I\u0027d expect most of these wait calls to be [red herrings](https://en.wikipedia.org/wiki/Red_herring). Not sure if dotTrace is the best profiler for this but perhaps there\u0027s something else in the Hot Spots view?\r\n\r\nI have considered this - I tried running it in tracing mode as well, but unfortunately it\u0027s spitting out broken trace files that cannot be opened. Is there another you\u0027d recommend trying with?",
                                           "updatedAt":  "2024-06-21T14:22:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6CH2IE",
                                           "createdAt":  "2024-06-21T16:46:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEAVHkw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "EgorBo",
                                                                               "createdAt":  "2024-06-21T16:47:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "filipnavara",
                                                                               "createdAt":  "2024-06-21T16:59:28Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-06-21T17:58:54Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "SupinePandora43",
                                                                               "createdAt":  "2024-10-19T18:58:28Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "neon-sunset",
                                                                               "createdAt":  "2024-12-27T11:36:10Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  5
                                                         },
                                           "author":  "AdamFrisby",
                                           "body":  "Just as some quick unscientific results - `DOTNET_ThreadPool_UnfairSemaphoreSpinLimit=0` did help. \r\n\r\nThe overall CPU usage went down by about 25% (from ~75% into the 55-60% range) - not enough to completely fix the issue, but it certainly helped. I\u0027m going to spend a bit more time with various profilers to see if I can improve things from the code side.\r\n\r\nThankyou both for your detailed comments!",
                                           "updatedAt":  "2024-06-21T16:46:56Z"
                                       }
                                   ],
                         "totalCount":  13
                     },
        "title":  "ThreadPool unfriendly to background processes",
        "labels":  [
                       "area-System.Threading",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/104179",
        "createdAt":  "2024-06-28T21:47:11Z",
        "number":  104179,
        "author":  "timcassell",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-03T20:59:09Z",
        "body":  "### Background and motivation\r\n\r\n`System.Threading.Lock` type was added to replace `Monitor.Enter/Exit` (#34812). No replacements were added for `Monitor.Wait/Pulse`. `ConditionVariable` is the replacement for those, as well as it can be used locally (`Monitor.Wait/Pulse` can only be used globally).\r\n\r\nIt\u0027s also .Net\u0027s version of C++\u0027s `std::condition_variable`.\r\n\r\n### API Proposal\r\n\r\n```cs\r\nnamespace System.Threading;\r\n\r\npublic sealed class ConditionVariable\r\n{\r\n    public ConditionVariable(Lock @lock);\r\n    public void Wait();\r\n    public bool TryWait(TimeSpan timeout);\r\n    public bool TryWait(int millisecondsTimeout);\r\n    public void Notify();\r\n    public void NotifyAll();\r\n}\r\n```\r\n\r\n`Notify` naming matches C++, but it could also be `Pulse` to match `Monitor` instead, or even `Signal` to match `WaitHandle`.\r\n\r\n### API Usage\r\n\r\nThe pattern using `Monitor`:\r\n\r\n```cs\r\nprivate readonly Queue\u003cT\u003e _queue = new();\r\nprivate readonly object _mutex = new();\r\n\r\npublic void PushItem(T item)\r\n{\r\n    lock (_mutex)\r\n    {\r\n        _queue.Enqueue(item);\r\n        Monitor.Pulse(_mutex);\r\n    }\r\n}\r\n\r\npublic T GetItem()\r\n{\r\n    lock (_mutex)\r\n    {\r\n        while (!_queue.TryDequeue(out T item))\r\n        {\r\n            Monitor.Wait(_mutex);\r\n        }\r\n        return item;\r\n    }\r\n}\r\n```\r\n\r\nConverted to using the new types (with C# updated `lock` keyword):\r\n\r\n```cs\r\nprivate readonly Queue\u003cT\u003e _queue = new();\r\nprivate readonly Lock _lock = new();\r\nprivate readonly ConditionVariable _condVar = new(_lock);\r\n\r\npublic void PushItem(T item)\r\n{\r\n    lock (_lock)\r\n    {\r\n        _queue.Enqueue(item);\r\n        _condVar.Notify();\r\n    }\r\n}\r\n\r\npublic T GetItem()\r\n{\r\n    lock (_lock)\r\n    {\r\n        while (!_queue.TryDequeue(out T item))\r\n        {\r\n            _condVar.Wait();\r\n        }\r\n        return item;\r\n    }\r\n}\r\n```\r\n\r\nMore advanced usage that is more cumbersome to implement with `Monitor`:\r\n\r\n```cs\r\nprivate readonly Lock _lock = new();\r\nprivate readonly ConditionVariable _condVar1 = new(_lock);\r\nprivate readonly ConditionVariable _condVar2 = new(_lock);\r\n\r\npublic void WaitForEvent1()\r\n{\r\n    lock (_lock)\r\n    {\r\n        _condVar1.Wait();\r\n    }\r\n}\r\n\r\npublic void WaitForEvent2()\r\n{\r\n    lock (_lock)\r\n    {\r\n        _condVar2.Wait();\r\n    }\r\n}\r\n\r\npublic void SignalEvent1()\r\n{\r\n    lock (_lock)\r\n    {\r\n        _condVar1.Notify();\r\n    }\r\n}\r\n\r\npublic void SignalEvent2()\r\n{\r\n    lock (_lock)\r\n    {\r\n        _condVar2.Notify();\r\n    }\r\n}\r\n```\r\n\r\n### Alternative Designs\r\n\r\nAlternative 1 - A `ConditionVariable` may be associated with more than 1 `Lock` object, but not more than 1 at the same time. The `Lock` is passed as an argument to each function, and it\u0027s validated internally to be only used by 1 `Lock` at a time. In C++, using the same condition variable with more than 1 mutex at the same time has undefined behavior. .Net should throw.\r\n\r\n```cs\r\nnamespace System.Threading;\r\n\r\npublic sealed class ConditionVariable\r\n{\r\n    public void Wait(Lock @lock);\r\n    public bool TryWait(Lock @lock, TimeSpan timeout);\r\n    public bool TryWait(Lock @lock, int millisecondsTimeout);\r\n    public void Notify(Lock @lock);\r\n    public void NotifyAll(Lock @lock);\r\n}\r\n```\r\n\r\nAlternative 2 - Match `std::condition_variable` more closely.\r\n\r\n```cs\r\nnamespace System.Threading;\r\n\r\npublic sealed class ConditionVariable\r\n{\r\n    public void Wait(Lock @lock);\r\n    public bool TryWait(Lock @lock, TimeSpan timeout);\r\n    public bool TryWait(Lock @lock, int millisecondsTimeout);\r\n    public void Notify();\r\n    public void NotifyAll();\r\n}\r\n```\r\n\r\nThis version does not take the `Lock` object as an argument for `Notify(All)`. Even though C++ does it this way, I think it\u0027s less safe than passing in the `Lock` object (we can verify that the notification occurs for the correct `Lock` object).\r\n\r\n### Open Question\r\n\r\n`Monitor.Pulse(All)` requires the lock to be held while calling it. `std::condition_variable::notify_one` has this in its notes:\r\n\r\n\u003e The notifying thread does not need to hold the lock on the same mutex as the one held by the waiting thread(s); in fact doing so is a pessimization, since the notified thread would immediately block again, waiting for the notifying thread to release the lock.\r\n\r\nShould `ConditionVariable.Notify(All)` require the lock to be entered? (It might need it as an implementation detail, I\u0027m not sure.)\r\n\r\n### Risks\r\n\r\nNone",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOg5BtPA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6C_kHP",
                                           "createdAt":  "2024-06-28T21:47:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-06-28T21:47:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6DACTe",
                                           "createdAt":  "2024-06-29T01:33:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "https://github.com/dotnet/runtime/blob/main/src/coreclr/nativeaot/System.Private.CoreLib/src/System/Threading/Condition.cs is an internal implementation of this used by native AOT.\r\n\r\nShould `lock` be a constructor parameter instead of being passed into every instance method?",
                                           "updatedAt":  "2024-06-29T01:33:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6DAIdh",
                                           "createdAt":  "2024-06-29T01:55:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "\u003e Should `lock` be a constructor parameter instead of being passed into every instance method?\r\n\r\nThat\u0027s the alternative 1 design. I prefer passing it in to each method to be less restrictive so that multiple `Lock` instances can use a single `ConditionVariable` instance (not at the same time). This makes it possible to pool the objects and use them later without worrying about mapping the exact `Lock` object to it. I implemented an `AsyncConditionVariable` in my [promise library](https://github.com/timcassell/ProtoPromise) that works this way.",
                                           "updatedAt":  "2024-06-29T01:55:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6DG_hA",
                                           "createdAt":  "2024-07-01T09:18:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "Upon further thought, I can\u0027t think of a reason to need to pool individual `ConditionVariable` objects. They would typically be used inside a data structure, and if object pooling is needed, the data structure itself can be pooled. So I guess it makes sense to only pass in the `Lock` as a constructor argument to reduce overhead and simplify the API.\r\n\r\nPerhaps a hypothetical `ValueConditionVariable` struct could take a hypothetical `ref ValueLock` struct as an argument to each method (to reduce object overhead), and that would more closely match C++\u0027s semantics, but it makes less sense for the `ConditionVariable` class. But I\u0027m getting ahead of myself.\r\n\r\nI updated the proposal.",
                                           "updatedAt":  "2024-07-01T09:24:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6DkG08",
                                           "createdAt":  "2024-07-03T20:59:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "@kouvel ",
                                           "updatedAt":  "2024-07-03T20:59:08Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "[API Proposal]: Add `System.Threading.ConditionVariable` type",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/104858",
        "createdAt":  "2024-07-13T14:57:45Z",
        "number":  104858,
        "author":  "h3xds1nz",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-08-13T00:18:10Z",
        "body":  "### Background and motivation\r\n\r\nCurrently, `SynchronizationContext` has a `public virtual int Wait(...)` method that takes array an of `IntPtr` and a protected `WaitHelper` method which also takes an array of `IntPtr`, which is by default called by the public member.\r\n\r\nOne of the frequent call chains originate from `WaitOne`-\u003e`WaitOneNoCheck` from `WaitHandle` class and its derivations, which is currently always [forced to allocate a heap-based array](https://github.com/dotnet/runtime/blob/5336e1815c36927f13b2a8f6365be81ddd0d3a31/src/libraries/System.Private.CoreLib/src/System/Threading/WaitHandle.cs#L140) of a single `IntPtr`, causing unnecessary GC overhead.\r\n\r\nSince the protected `WaitHelper` helper from `SynchronizationContext` calls into `WaitHandle.WaitMultipleIgnoringSyncContext(...)` which already takes a `ReadOnlySpan\u003cIntPtr\u003e`, by adding public `ReadOnlySpan\u003cIntPtr\u003e` overloads onto `SynchronizationContext` we could get rid of this unnecessary allocation when awaiting a single handle in the runtime code, and also in user-code.\r\n\r\n### API Proposal\r\n\r\n```diff\r\nnamespace System.Threading;\r\n\r\npublic partial class SynchronizationContext\r\n{\r\n+    public virtual int Wait(bool waitAll, int millisecondsTimeout, params ReadOnlySpan\u003cIntPtr\u003e waitHandles);\r\n+    protected static int WaitHelper(bool waitAll, int millisecondsTimeout, params ReadOnlySpan\u003cIntPtr\u003e waitHandles);\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\nnamespace System.Threading;\r\n\r\npublic partial class WaitHandle\r\n{\r\n    private bool WaitOneNoCheck(int millisecondsTimeout)\r\n    {\r\n        // some code\r\n        int num = current.Wait(false, millisecondsTimeout, waitHandle.DangerousGetHandle());\r\n        // some code\r\n    }\r\n}\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOiDQTIg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6EvHA7",
                                           "createdAt":  "2024-07-13T14:58:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-07-13T14:58:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EvV5m",
                                           "createdAt":  "2024-07-13T17:28:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODppOBA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "h3xds1nz",
                                                                               "createdAt":  "2024-07-13T18:36:43Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "gfoidl",
                                           "body":  "Taking latest language features into account the proposal could be\r\n```diff\r\nnamespace System.Threading;\r\n\r\npublic partial class SynchronizationContext\r\n{\r\n+    public virtual int Wait(params ReadOnlySpan\u003cIntPtr\u003e waitHandles, bool waitAll, int millisecondsTimeout);\r\n+    protected static int WaitHelper(params ReadOnlySpan\u003cIntPtr\u003e waitHandles, bool waitAll, int millisecondsTimeout);\r\n}\r\n```\r\n* `ReadOnlySpan` as the waitHandles aren\u0027t updated\r\n* `params ReadOnlySpan` so that 1 or more waithandles can be given more easily\r\n\r\nBut as given above this wouldn\u0027t compile, as the `params` parameter must be last, so actually it could be\r\n```diff\r\nnamespace System.Threading;\r\n\r\npublic partial class SynchronizationContext\r\n{\r\n+    public virtual int Wait(bool waitAll, int millisecondsTimeout, params ReadOnlySpan\u003cIntPtr\u003e waitHandles);\r\n+    protected static int WaitHelper(bool waitAll, int millisecondsTimeout, params ReadOnlySpan\u003cIntPtr\u003e waitHandles);\r\n}\r\n```",
                                           "updatedAt":  "2024-07-13T17:28:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EvZp3",
                                           "createdAt":  "2024-07-13T17:54:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Can you elaborate on why this particular allocation is impactful to you? What SC are you using where you\u0027ve asked for wait notification and what\u0027s the calling pattern where you\u0027re frequently doing blocking waits on threads with this context current? ",
                                           "updatedAt":  "2024-07-13T17:54:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Evfbi",
                                           "createdAt":  "2024-07-13T18:36:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "h3xds1nz",
                                           "body":  "@gfoidl The second proposal could do, this would also aid to the fact with `Span\u003cT\u003e` overloads being preferred over `T[]` and since those methods are virtual which I didn\u0027t consider before.\r\n\r\nHowever, since the underlying `WaitHandle` methods use `Span\u003cIntPtr\u003e`, you would be unable to call those when we use `ReadOnlySpan\u003cIntPtr\u003e` unless the chain is adjusted, unsure whether it is modified anywhere. That is why I didn\u0027t initially go with ROS.\r\n\r\n@stephentoub Thank you for your interest on this. I originally came onto this alloc when looking at total GC time.\r\nThe most usual chain here for me were `Dispatcher` Invokes in WPF and the underlying operations, queue posts from long-running background threads to update UI, which uses `ManualResetEvent` for `DispatcherOperationEvent`.",
                                           "updatedAt":  "2024-07-13T18:36:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EwJa8",
                                           "createdAt":  "2024-07-14T06:36:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gfoidl",
                                           "body":  "\u003e However, since the underlying `WaitHandle` methods use `Span\u003cIntPtr\u003e`, you would be unable to call those when we use `ReadOnlySpan\u003cIntPtr\u003e` unless the chain is adjusted, unsure whether it is modified anywhere.\r\n\r\nThis gets addressed in https://github.com/dotnet/runtime/pull/104864.",
                                           "updatedAt":  "2024-07-14T06:36:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EwaKE",
                                           "createdAt":  "2024-07-14T09:39:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "h3xds1nz",
                                           "body":  "\u003e This gets addressed in #104864.\r\n\r\nAmazing, thanks for that, I have updated the proposal based on your suggestion. ",
                                           "updatedAt":  "2024-07-14T09:39:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6IM975",
                                           "createdAt":  "2024-08-13T00:05:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODurEbw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "stephentoub",
                                                                               "createdAt":  "2024-08-16T22:34:42Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "h3xds1nz",
                                                                               "createdAt":  "2024-08-18T21:09:30Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "rickbrew",
                                           "body":  "\u003e Can you elaborate on why this particular allocation is impactful to you? What SC are you using where you\u0027ve asked for wait notification and what\u0027s the calling pattern where you\u0027re frequently doing blocking waits on threads with this context current?\r\n\r\nHere\u0027s an example of how I\u0027m using this (not publicly accessible link) : https://github.com/dotnet/paint.net/blob/bc539c00f25e9f5bcafb4146cfc449532cfb29b9/Windows.Framework/Threading/TimerThread.cs#L250\r\n\r\nThe use here is clumsy, but not performance impacting. I\u0027d love to see this become less clumsy, but it\u0027s not a high priority for my uses.\r\n\r\nBecause there\u0027s no span-based versions of these APIs, I have to use `new WaitHandle[]`. I cannot use `ArrayPool\u003cWaitHandle\u003e.Shared.Rent()` and then slice the span to the appropriate length. In my case I only need to allocate once at app startup, so it\u0027s no big deal, but any kind of high-traffic situation becomes more clumsy as you need to implement your own local array pooling.",
                                           "updatedAt":  "2024-08-13T00:07:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6INBMi",
                                           "createdAt":  "2024-08-13T00:17:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEYS_UQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nietras",
                                                                               "createdAt":  "2025-06-28T08:13:06Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "rickbrew",
                                           "body":  "The code is essentially this. So I can\u0027t use the array pool, and it\u0027s necessary to allocate two arrays for the two waits that use 3 and 2 handles respectively.\r\n\r\nThis is for `WaitHandle.Wait[Any|All]()` but it\u0027s the same idea as `SynchronizationContext.Wait()`.\r\n\r\n```cs\r\nprivate void TimerThreadProc()\r\n{\r\n    WaitHandle[] waitHandles3 = new WaitHandle[3];\r\n    waitHandles3[0] = this.isCancelledEvent;\r\n    waitHandles3[1] = this.isEnabledEvent;\r\n    waitHandles3[2] = this.pulseEvent;\r\n\r\n    WaitHandle[] waitHandles2 = new WaitHandle[2];\r\n    waitHandles2[0] = this.isCancelledEvent;\r\n    waitHandles2[2] = this.waitableTimer; // Win32 waitable timer\r\n\r\n    while (true)\r\n    {\r\n         // wait on the 3 handles array\r\n         int waitIndex = WaitHandle.WaitAny(waitHandles3);\r\n         ...\r\n         // wait on the 2 handles array\r\n         waitIndex = WaitHandle.WaitAny(waitHandles2);\r\n         ...\r\n    }\r\n}\r\n```",
                                           "updatedAt":  "2024-08-13T00:18:10Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "[API Proposal]: Span overload for SynchronizationContext.Wait(...)",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/105054",
        "createdAt":  "2024-07-18T00:04:51Z",
        "number":  105054,
        "author":  "timcassell",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-26T00:32:41Z",
        "body":  "### Background and motivation\r\n\r\nTo make it possible to use atomic `(Compare)Exchange` on any type, including custom structs of varying size. It also makes it possible to use 128-bit atomics which the runtime currently doesn\u0027t support (like x64\u0027s `cmpxchg16b`), and atomic exchanges of 2 references at once (which can\u0027t even be done in 32-bit runtimes currently).\r\n\r\nIf the type\u0027s size is \u003c= the target architecture\u0027s largest atomic `(Compare)Exchange` instruction (16 bytes for 64-bit, 8 bytes for 32-bit), it will use native atomic instructions. If a type\u0027s size is larger than that, the runtime will fallback to a spinlock.\r\n\r\nIn the case of a padded type, the runtime must ensure that all padded bits are zeroed before performing the atomic operation.\r\n\r\nFor optimal performance, the runtime should also align the field of the atomic properly according to its size (if possible). I.E. a `BitwiseAtomic\u003cObjectPair\u003e` should be aligned on a 16-byte boundary, as opposed to the normal 8-byte boundary in 64-bit processes.\r\n\r\nThis proposal is different than #17975, which uses `IEquatable\u003cT\u003e` for equality comparisons, while this proposal uses bitwise equality. Float -0.0 != 0.0. This can result in single instruction operations compared to that proposal which requires CompareExchange loops. And without requiring the `IEquatable\u003cT\u003e` interface, it will work with any type.\r\n\r\nThis could also supersede #31911 since we only need 1 new type instead of several.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Threading;\r\n\r\npublic struct BitwiseAtomic\u003cT\u003e\r\n{\r\n    private T _value;\r\n    // SpinLock is only added to this struct by the runtime if sizeof(T) is too large for native atomics.\r\n    // private SpinLock _lock;\r\n    \r\n    // True if sizeof(T) is \u003c= the target architecture\u0027s largest atomic operation.\r\n    [Intrinsic]\r\n    public static bool IsNative { get; }\r\n    \r\n    // Any padded bits are zeroed.\r\n    [Intrinsic]\r\n    public BitwiseAtomic(T value);\r\n    [Intrinsic]\r\n    public T Exchange(T value);\r\n    [Intrinsic]\r\n    public T CompareExchange(T value, T comparand);\r\n    \r\n    // We expose separate non-atomic read/write functions so that users can use\r\n    // volatile (with new Volatile.Read/WriteBarrier() APIs) or normal reads/writes\r\n    // if they don\u0027t need the cost of the exchange.\r\n    public T ReadNonAtomic();\r\n    // Any padded bits are zeroed.\r\n    [Intrinsic]\r\n    public void WriteNonAtomic(T value);\r\n}\r\n```\r\n\r\n### API Usage\r\n\r\n```csharp\r\nprivate struct ObjectPair\u003cT1, T2\u003e where T1 : class where T2 : class\r\n{\r\n    public T1 obj1;\r\n    public T2 obj2;\r\n}\r\n\r\nprivate BitwiseAtomic\u003cObjectPair\u003cMyType, AnotherType\u003e\u003e _atom;\r\n\r\n...\r\n\r\nprivate struct Bytes\r\n{\r\n    public byte b1;\r\n    public byte b2;\r\n    public byte b3;\r\n}\r\n\r\n// Padded byte 4 will be zeroed on 32-bit, padded bytes 4-8 will be zeroed on 64-bit.\r\nprivate BitwiseAtomic\u003cBytes\u003e _atom;\r\n\r\n...\r\n\r\nprivate struct Numbers\r\n{\r\n    public long num1;\r\n    public int num2;\r\n}\r\n\r\n// No padding on 32-bit, padded bytes 5-8 will be zeroed on 64-bit.\r\nprivate BitwiseAtomic\u003cNumbers\u003e _atom;\r\n\r\n...\r\n\r\nprivate struct LargeStruct\r\n{\r\n    public long num1;\r\n    public long num2;\r\n    public long num3;\r\n    public long num4;\r\n}\r\n\r\n// The BitwiseAtomic\u003cLargeStruct\u003e struct adds a SpinLock.\r\nprivate BitwiseAtomic\u003cLargeStruct\u003e _atom;\r\n```\r\n\r\n```cs\r\n// Emits cmpxchg16b instruction on x64, uses SpinLock on x86.\r\nif (_atom.CompareExchange(new Numbers() { num1= 1, num2= 2 }, default) == default)\r\n{\r\n    ...\r\n}\r\n```\r\n\r\n```cs\r\n// Uses SpinLock.\r\nif (_atom.CompareExchange(new LargeStruct() { num1= 1, num2= 2 }, default) == default)\r\n{\r\n    ...\r\n}\r\n```\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\nIt\u0027s a struct, and exposes non-atomic methods, so it could be torn if used improperly. It also has the same risks as the `SpinLock` struct.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOhjXcSQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6FNoEb",
                                           "createdAt":  "2024-07-18T00:47:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-07-18T00:47:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6FRF78",
                                           "createdAt":  "2024-07-18T07:48:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "\u003e Any padded bits are zeroed.\r\n\r\nWhat does that do to types like the following -- perhaps zero them entirely?\r\n\r\n```csharp\r\n[StructLayout(LayoutKind.Explicit, Size = 8)]\r\nstruct Mystery\r\n{\r\n    // Fields are accessed using unsafe code and are not declared to the CLR.\r\n}\r\n```\r\n\r\nIIRC, the C++/CLI compiler can generate types like that.",
                                           "updatedAt":  "2024-07-18T07:48:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6FSsKb",
                                           "createdAt":  "2024-07-18T11:28:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "colejohnson66",
                                           "body":  "#17975?",
                                           "updatedAt":  "2024-07-18T11:28:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6FXXpc",
                                           "createdAt":  "2024-07-18T20:23:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "\u003e \u003e Any padded bits are zeroed.\r\n\u003e \r\n\u003e What does that do to types like the following -- perhaps zero them entirely?\r\n\u003e \r\n\u003e ```cs\r\n\u003e [StructLayout(LayoutKind.Explicit, Size = 8)]\r\n\u003e struct Mystery\r\n\u003e {\r\n\u003e     // Fields are accessed using unsafe code and are not declared to the CLR.\r\n\u003e }\r\n\u003e ```\r\n\u003e \r\n\u003e IIRC, the C++/CLI compiler can generate types like that.\r\n\r\nYeah, I don\u0027t think that will work with this API. This API is meant to be \"safe\", such that any padded bytes that could be random won\u0027t affect the equality of the declared fields. You would need to declare a field (or fields) of that size to make it work, or union the type in another struct.",
                                           "updatedAt":  "2024-07-18T20:29:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6FXYU1",
                                           "createdAt":  "2024-07-18T20:24:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "\u003e It\u0027s a struct\r\n\r\nThis type could possibly need to be a ref type with special GC support since 16B cmpxchg requires 16B alignment on all platforms.",
                                           "updatedAt":  "2024-07-18T20:24:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6FXitc",
                                           "createdAt":  "2024-07-18T20:42:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "\u003e \u003e It\u0027s a struct\r\n\u003e \r\n\u003e This type could possibly need to be a ref type with special GC support since 16B cmpxchg requires 16B alignment on all platforms.\r\n\r\nIs that not enforceable for this struct type? It would be unfortunate to add extra object overhead if it can be avoided.\r\n\r\nOr do you mean this type would be specially treated the same as object references, such that it must always be aligned? If so, I can definitely get behind that.",
                                           "updatedAt":  "2024-07-18T21:06:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Fkg45",
                                           "createdAt":  "2024-07-20T05:58:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODroSTg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-07-26T00:50:05Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "timcassell",
                                           "body":  "\u003e #17975?\r\n\r\nI explained in the proposal how this is different than that. Actually, that one could probably be built on top of this.",
                                           "updatedAt":  "2024-07-20T05:58:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GNdxJ",
                                           "createdAt":  "2024-07-26T00:32:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODroSQg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-07-26T00:49:59Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "timcassell",
                                           "body":  "Another boon to this type is, for architectures that don\u0027t support small atomics (like `byte` and `short`), this could widen itself to the smallest atomic instruction size. Unlike `Interlocked.CompareExchange(byte, byte, byte)` that has to fall back to software emulation.",
                                           "updatedAt":  "2024-07-26T00:32:41Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "[API Proposal]: BitwiseAtomic\u003cT\u003e",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/105165",
        "createdAt":  "2024-07-19T20:50:13Z",
        "number":  105165,
        "author":  "danmoseley",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-08-26T19:48:42Z",
        "body":  "Work scheduled with `TaskCreationOptions.LongRunning` currently always creates a new thread. If the threadpool is sufficiently idle then it might be worthwhile to grab an idle threadpool thread to use instead - and kick off creating a replacement one to put in the threadpool.\r\n\r\nThis assumes that there are enough of these work items to make it worthwhile, and that thread startup is large enough to be relevant to them. That may well not be the case. Also, this could potentially be a deoptimization if it delays short-running threadpool work which would otherwise grab that idle thread.\r\n\r\ndetails https://github.com/dotnet/runtime/pull/104972#discussion_r1681759430",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOib498A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6FhQAs",
                                           "createdAt":  "2024-07-19T20:50:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-07-19T20:50:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Jvj3w",
                                           "createdAt":  "2024-08-26T19:41:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "The frequency of completing tasks flagged as long-running would have to be large for this to be worthwhile. Also relevant may be separating the concept of \"long-running\" between \"long-running-blocking\" and \"long-running-cpu-bound\", as the latter types of work items might complete more frequently than the former, and the former types of work items may not complete at all. The blocking work items probably shouldn\u0027t go into the thread pool. The cpu-bound work items could probably be better handled by the thread pool.",
                                           "updatedAt":  "2024-08-26T19:48:42Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "consider pulling long running threatpool threads from the pool",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/105607",
        "createdAt":  "2024-07-29T01:25:51Z",
        "number":  105607,
        "author":  "rickbrew",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-05-07T15:24:50Z",
        "body":  "### Background and motivation\n\nIn my app I occasionally have to get into the weeds to do some serious cycle-trimming optimizations. Sometimes that means making use of methods like `CollectionsMarshal.GetValueOrAddDefault\u003cTKey, TValue\u003e(...)`. That is, you need to do two things with a storage slot somewhere, but you only want to pay the lookup cost once. On hot code paths this can make a difference!\n\nI\u0027m currently writing some code that uses `ThreadLocal\u003cT\u003e` on a hot path where I need to retrieve the `Value` and then immediately clear it. This means I have to pay the slot lookup cost twice, once for `get_Value` and then again for `set_Value`. I don\u0027t get the impression that `ThreadLocal\u003cT\u003e` is a bottleneck, but this app is intended to be fast even on low-spec PCs and every cycle helps.\n\nIn a similar vein, a `bool TryGetValue(out TValue value)` method could be useful, eliminating the need to call both `IsValueCreated` and then `Value` in order to differentiate between a `null` `Value` versus a never-set `Value`.\n\n### API Proposal\n\n```csharp\nnamespace System.Threading;\n\npublic class ThreadLocal\u003cT\u003e\n{\n    // Gets the old per-thread Value, then sets it to newValue, then returns the old per-thread Value\n    TValue ExchangeValue(TValue newValue);\n}\n```\n\n### API Usage\n\n```csharp\nprivate readonly ThreadLocal\u003cBitmap?\u003e perThreadBitmap = new();\n\npublic void BeginRenderingTask(SizeInt32 bitmapSize)\n{\n    Debug.Assert(this.perThreadBitmap.Value is null);\n    this.perThreadBitmap.Value = new Bitmap(bitmapSize);\n}\n\npublic void PerformRenderingTask()\n{    \n    ...\n}\n\n// Without this API:\npublic void EndRenderingTask()\n{\n    using Bitmap? bitmap = this.perThreadBitmap.Value;\n    Debug.Assert(buffer is not null);\n    this.perThreadBitmap.Value = null;\n}\n\n// With this API:\npublic void EndRenderingTask()\n{\n    using Bitmap? bitmap = this.perThreadBitmap.ExchangeValue(null);\n    Debug.Assert(buffer is not null);\n}\n```\n\n### Alternative Designs\n\nI\u0027m sure there are several different ways to articulate this API. Whether or not it should be in `ThreadLocal\u003cT\u003e` or `ThreadingMarshal`, or wherever, is not something I have a strong opinion on.\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOhnQYgw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6GZRHs",
                                           "createdAt":  "2024-07-29T01:26:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-07-29T01:26:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GZepx",
                                           "createdAt":  "2024-07-29T02:33:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rickbrew",
                                           "body":  "Worth pointing out that it is possible to work around this by using something like `ThreadLocal\u003cStrongBox\u003cT\u003e\u003e`. This does cost an extra allocation per thread.",
                                           "updatedAt":  "2024-07-29T02:33:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GdBiD",
                                           "createdAt":  "2024-07-29T12:06:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "colejohnson66",
                                           "body":  "Would a ref property be better? `ref T ValueRef { get; }`",
                                           "updatedAt":  "2024-07-29T12:06:52Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "[API Proposal]: Ability to get and set `ThreadLocal\u003cT\u003e.Value` in one method call",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/110025",
        "createdAt":  "2024-07-31T17:18:03Z",
        "number":  110025,
        "author":  "IeuanWalker",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC81RPA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "torfluor",
                                            "createdAt":  "2024-08-09T08:20:07Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-07-01T06:36:32Z",
        "body":  "### Description\n\nTryng to prevent a method from being ran multiple times by using SemphoreSlim. But when i call `.Release` the app hangs and never gets passed the release line.\r\n\r\nSimilar code works fine on android.\r\n\r\nCode is pretty straightforward - \r\n```csharp\r\npublic partial class OsAppSettingsFeature\r\n{\r\n\treadonly SemaphoreSlim _semaphore = new(1, 1);\r\n\tpublic async partial Task OpenSettings()\r\n\t{\r\n\t\tawait _semaphore.WaitAsync();\r\n\r\n\t\tTaskCompletionSource tcs = new();\r\n\r\n\t\tNSObject observer = UIApplication.Notifications.ObserveDidBecomeActive((_, __) =\u003e tcs.SetResult());\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\tawait UIApplication.SharedApplication.OpenUrlAsync(new NSUrl(\"app-settings:\"), new UIApplicationOpenUrlOptions());\r\n\r\n\t\t\tawait tcs.Task;\r\n\t\t}\r\n\t\tfinally\r\n\t\t{\r\n\t\t\tobserver.Dispose();\r\n\t\t\t_semaphore.Release();\r\n\t\t}\r\n\t}\r\n}\r\n```\n\n### Steps to Reproduce\n\n_No response_\n\n### Link to public reproduction project repository\n\n_No response_\n\n### Version with bug\n\n8.0.70 SR7\n\n### Is this a regression from previous behavior?\n\nNot sure, did not test other versions\n\n### Last version that worked well\n\nUnknown/Other\n\n### Affected platforms\n\niOS\n\n### Affected platform versions\n\n_No response_\n\n### Did you find any workaround?\n\n_No response_\n\n### Relevant log output\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOlGRhRA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6UZF5z",
                                           "createdAt":  "2024-08-09T08:19:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD70Iuw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "IeuanWalker",
                                                                               "createdAt":  "2024-08-09T11:14:34Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "torfluor",
                                           "body":  "I have also experienced that semaphores don\u0027t work correctly on iOS. Both in my own code and in the CommunityToolkit MediaElement.\r\nUnsure if this is related to MAUI or if it\u0027s a more general .Net on iOS issue.",
                                           "updatedAt":  "2024-08-09T08:19:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6UZF58",
                                           "createdAt":  "2024-11-15T08:03:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jaosnz-rep",
                                           "body":  "@IeuanWalker Could you provide us with a sample project so we can investigate it further? Looking forward to your reply!",
                                           "updatedAt":  "2024-11-15T08:03:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6UZGFE",
                                           "createdAt":  "2024-11-20T21:47:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-11-20T21:47:45Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "SemaphoreSlim Release hangs on iOS",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/105811",
        "createdAt":  "2024-08-01T14:22:46Z",
        "number":  105811,
        "author":  "JamesNK",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODEJKrw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "martincostello",
                                            "createdAt":  "2024-08-01T14:42:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_DOWN",
                                            "user":  "vcsjones",
                                            "createdAt":  "2024-08-01T16:10:18Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rameel",
                                            "createdAt":  "2024-08-01T17:40:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-08-01T21:04:04Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "strangeman375",
                                            "createdAt":  "2024-08-02T04:50:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "vyacheslav-volkov",
                                            "createdAt":  "2024-08-02T10:54:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "davidroth",
                                            "createdAt":  "2024-08-02T17:35:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "omariom",
                                            "createdAt":  "2024-08-02T19:27:25Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "saul",
                                            "createdAt":  "2024-09-10T09:01:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "cat-prices",
                                            "createdAt":  "2024-09-17T07:05:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hexawyz",
                                            "createdAt":  "2025-03-19T22:01:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "omghb",
                                            "createdAt":  "2025-04-09T13:38:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "giovani-luigi",
                                            "createdAt":  "2025-05-29T16:13:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rmotta01",
                                            "createdAt":  "2025-06-18T02:10:33Z"
                                        }
                                    ],
                          "totalCount":  14
                      },
        "updatedAt":  "2025-04-09T14:05:31Z",
        "body":  "`CancellationTokenSource` guidance recommends disposing of the CTS once it is no longer used. However, after disposal the `Token` property throws `ObjectDisposedException` when accessed:\r\n\r\nhttps://github.com/dotnet/runtime/blob/74c608d67d64675ff840c5888368669777c8aa2c/src/libraries/System.Private.CoreLib/src/System/Threading/CancellationTokenSource.cs#L77-L87\r\n\r\nI\u0027ve seen this be a problem a number of times. For example, in ASP.NET Core a request can be aborted with a signal from the client. This would cancel the CTS that drives the `HttpContext.RequestAborted` cancellation token and it was then disposed. But server code could still be executing and access `HttpContext.RequestAborted`. Instead of returning the cancelled token, the code would get an ODE: https://github.com/dotnet/aspnetcore/issues/4422\r\n\r\nThe fix in ASP.NET Core was to not dispose a canceled CTS (which is against guidance in the docs that say a CTS should be disposed once you\u0027re no longer using it). We solved the problem after a couple of attempts, but it felt like a pit of failure that is easy to fall into.\r\n\r\nBecause of this situation, people who use CTS either need to:\r\n\r\n* Be careful about not accessing the Token property after dispose (not an easy feat if dispose and API usage happen on different threads)\r\n* Assign the token value to a field or property on the class (see below)\r\n* Not dispose the CTS\r\n\r\nExample of making a type safe by setting the cancellation token to a field:\r\n\r\n```cs\r\npublic class Worker : IAsyncDisposable\r\n{\r\n    private readonly CancellationTokenSource _cts = new();\r\n    private readonly CancellationToken _cancellationToken = _cts.Token; // field can be safely accessed\r\n    private Task? _workerTask;\r\n\r\n    public Worker()\r\n    {\r\n        _workerTask = Task.Run(() =\u003e\r\n        {\r\n            // If _cts.Token was used here then there would be the chance of throwing ODE.\r\n            while (_cancellationToken.IsCancellationRequested)\r\n            {\r\n                // do a thing\r\n                await Task.Delay(1000, _cancellationToken);\r\n            }\r\n        });\r\n    }\r\n\r\n    public async ValueTask DisposeAsync()\r\n    {\r\n        _cts.Cancel();\r\n        _cts.Dispose();\r\n        try { await _workerTask; } catch (OperationCanceledException) { }\r\n    }\r\n}\r\n```\r\n\r\nCTS feels like it would be simpler to use and less of a pit of failure if `CancellationTokenSource.Token` could still be accessed after dispose.\r\n\r\nProposed change: https://github.com/dotnet/runtime/commit/31d8d32096228931749484c4a36a559bba8a4cb7",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOpkjwaA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6G5oWh",
                                           "createdAt":  "2024-08-01T14:42:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-08-01T14:42:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6G6cXJ",
                                           "createdAt":  "2024-08-01T16:22:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vladd",
                                           "body":  "@JamesNK For your example, I would argue that we should not dispose the CTS after cancellation (because the clients may still be using it). The point where we can be sure that the CTS is not used is after `await workerTask`, not before.\r\n\r\nBeside that, maybe workerTask should not use the CTS, only CT, so the CT should be passed down to Worker (so presumably we don\u0027t need to store the CT in a field at all).\r\n\r\nOf course, there might be a more elaborate example where this simple approach doesn\u0027t help.",
                                           "updatedAt":  "2024-08-01T16:22:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6HJULD",
                                           "createdAt":  "2024-08-04T06:32:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "JamesNK",
                                           "body":  "@vladd Yes, that would fix this case. Every example I give there will always be a way to change the code to make it work. CTS isn\u0027t broken. But it could be made easier to use with one simple change.\r\n\r\nHow about this Blazor dialog component that has a CancellationTokenSource:\r\n\r\nhttps://github.com/dotnet/aspire/blob/a41bd1baf4367f6b9394575d75dd995340b4795b/src/Aspire.Dashboard/Components/Dialogs/ExemplarsDialog.razor.cs\r\n\r\n`OnViewDetailsAsync` is triggered by someone clicking on a button in the UI. It passes a cancellation token to a method that does some async work.\r\n\r\n`Dispose` is triggered when the dialog is clicked. It cancels the CTS.\r\n\r\nNow, I don\u0027t _think_ these two events can race because Blazor has the concept of the UI thread, but perhaps there is an exceptional situation where UI events come in out of order and they could, and it just hasn\u0027t happened yet. If `Dispose` is called and it\u0027s then followed by `OnViewDetailsAsync` then an `ObjectDisposedException` is thrown when accessing the `CancellationTokenSource.Token`.",
                                           "updatedAt":  "2024-08-04T06:32:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6HJ-xt",
                                           "createdAt":  "2024-08-04T13:18:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vladd",
                                           "body":  "@JamesNK I usually avoid patterns [like](https://github.com/dotnet/aspire/blob/a41bd1baf4367f6b9394575d75dd995340b4795b/src/Aspire.Dashboard/Components/Dialogs/ExemplarsDialog.razor.cs#L82)\r\n\r\n```csharp\r\ncts.Cancel();\r\ncts.Dispose();\r\n```\r\n\r\nby the very same reason: `Cancel` is a signal to whoever is using the token, so I tend to maintain an inner list of those and await all of them to finish before disposing. (But I understand that this way is tedious and maybe an overkill.)\r\n\r\nBy the way, CancellationToken after disposal of CTS allows using [everything except WaitHandle](https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwAICYCMBYAUKgBgAJVMA6AFQAswBTAQzgEsoBzAbjzwGF6oBjWgBsh9YEwD2UChIDWtKAGUJEMIKL9gAZyIBeIlFoB3ABQBKTrl4Dho8VJnyoG4HpdbKchZbyaP1wSFzSz8yABEmLQAHCS1aYK5cTTIAJVpWSOBaMBNzPQA+EkwAThMAIn4+QKFaODKzCyIAeiaiIwkwWS08ADd6MCIqPjgat2SAdXomYAAJYZr2ZtbgGgkjHQB5MIBRIA) (which is a bit inconsistent, too).",
                                           "updatedAt":  "2024-08-04T13:18:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ja4Ph",
                                           "createdAt":  "2025-03-20T21:40:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hexawyz",
                                           "body":  "I too would like to see the `ObjectDisposedException` on `CancellationTokeSource.Token` removed.\nIt seems to make little sense to not be able to get the `Token` after cancellation, given that pre-existing tokens will for the most part work perfectly fine. (And they have to, otherwise many random bits of code that kept a token for \"too long\" would throw)\nHaving that restriction removed would avoid writing extra code just to handle the fact that `Token` could throw sometimes.\n\nIf it really is necessary to preserve the behavior for compatibility reason, it should at least be possible to give us something like an official extension method `UnsafeGetToken(CancellationTokenSource)`.\nBut I honestly doubt anybody is seriously *depending* on that throwing behavior.\n",
                                           "updatedAt":  "2025-03-20T21:40:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mSPBo",
                                           "createdAt":  "2025-04-09T13:46:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "omghb",
                                           "body":  "I\u0027m also having issues because of this behavior - in my case with calling `cts.Cancel()`. We are using `CreateLinkedTokenSource` so dispose is important. We cannot control that a `CancellationTokenSource` might be cancelled right after dispose (race-conditions of callbacks) and so we get sometimes `System.ObjectDisposedException: CancellationTokenSource_Disposed`.\n\nOn StackOverflow a lot people are discussing this issue as well. An interesting post is here suggesting to not use `Dispose` and use `Cancel` instead. But for linked token source this might not work.\n- https://stackoverflow.com/a/51220106/28603541\n\n**Proposed solution:**\n- `Cancel()` should not throw an ObjectDisposedException. If the CTS is disposed than the call just does nothing.\n\n**Workaround for some scenarios**\n```C#\ninternal static class CancellationTokenSourceHelper\n{\n    public static void TryCancel(this CancellationTokenSource source)\n    {\n        try { source.Cancel(); }\n        catch (ObjectDisposedException) { }\n    }\n}\n```",
                                           "updatedAt":  "2025-04-09T14:05:30Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "Make `CancellationTokenSource.Token` accessible after dispose",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/106447",
        "createdAt":  "2024-08-15T08:38:24Z",
        "number":  106447,
        "author":  "aetos382",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODGn2EA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "julealgon",
                                            "createdAt":  "2024-08-15T13:31:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "martincostello",
                                            "createdAt":  "2024-08-15T15:25:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2024-08-16T07:28:17Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pedoc",
                                            "createdAt":  "2024-08-17T05:55:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "omariom",
                                            "createdAt":  "2024-08-18T12:13:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "edwardneal",
                                            "createdAt":  "2024-08-19T04:41:58Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "KennethHoff",
                                            "createdAt":  "2024-08-19T06:23:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "huoyaoyuan",
                                            "createdAt":  "2024-08-27T09:18:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "WeihanLi",
                                            "createdAt":  "2024-11-04T02:03:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "john-bartu",
                                            "createdAt":  "2025-01-27T16:10:31Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "akade",
                                            "createdAt":  "2025-07-11T09:09:40Z"
                                        }
                                    ],
                          "totalCount":  11
                      },
        "updatedAt":  "2024-08-20T18:30:32Z",
        "body":  "### Background and motivation\n\nRate limiters in the `System.Threading.RateLimiting` namespace is not designed to accept `TimeProvider`.\r\n\r\nTherefore, we need to wait for the actual time to elapse when testing functions that use them.\r\n\r\nFor faster testing, please make sure that rate limiters accepts `TimeProvider` and does not have to wait for the actual time to elapse.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Threading.RateLimiting;\r\n\r\npublic sealed class FixedWindowRateLimiterOptions\r\n{\r\n    public TimeProvider TimeProvider { get; set; } = TimeProvider.System;\r\n}\r\n\r\npublic sealed class SlidingWindowRateLimiterOptions\r\n{\r\n    public TimeProvider TimeProvider { get; set; } = TimeProvider.System;\r\n}\r\n\r\npublic sealed class TokenBucketRateLimiterOptions\r\n{\r\n    public TimeProvider TimeProvider { get; set; } = TimeProvider.System;\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nvar timeProvider = new FakeTimeProvider();\r\n\r\nvar options = new TokenBucketRateLimiterOptions\r\n{\r\n    TokenLimit = 1,\r\n    TokensPerPeriod = 1,\r\n    AutoReplenishment = true,\r\n    ReplenishmentPeriod = TimeSpan.FromSeconds(10),\r\n    TimeProvider = timeProvider\r\n};\r\n\r\nusing var limiter = new TokenBucketRateLimiter(options);\r\n\r\nusing (var lease = limiter.AttemptAcquire())\r\n{\r\n    Assert.True(lease.IsAcquired);\r\n}\r\n\r\ntimeProvider.Advance(TimeSpan.FromSeconds(10));\r\n\r\n// If TimeProvider is not supported, we need to actually stop the thread here.\r\n// Thread.Sleep(TimeSpan.FromSeconds(10));\r\n\r\nusing (var lease = limiter.AttemptAcquire())\r\n{\r\n    Assert.True(lease.IsAcquired);\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOiIxSHg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6IjFIe",
                                           "createdAt":  "2024-08-15T08:38:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-08-15T08:38:46Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "[API Proposal]: RateLimiter uses TimeProvider",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/107013",
        "createdAt":  "2024-08-27T02:27:11Z",
        "number":  107013,
        "author":  "zhenlei520",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-11-11T07:17:21Z",
        "body":  "\u003c!--This is just a template - feel free to delete any and all of it and replace as appropriate.--\u003e\r\n\r\n### Description\r\n\r\n\u003c!--\r\n* Please share a clear and concise description of the performance problem.\r\n* Include minimal steps to reproduce the problem if possible. E.g.: the smallest possible code snippet; or a small repo to clone, with steps to run it.\r\n  --\u003e\r\n1. Simulate 100 connections, accessing at an average of 50 qps per second\r\n2. Simulate response delays to cause thread pool threads to accumulate\r\n3. Response time becomes longer, thread creation takes time, a large number of requests accumulate, and CPU usage increases sharply\r\n\r\n### Configuration\r\n\r\n\u003c!--\r\n(If you are posting Benchmark.NET results, this info will be included.)\r\n* Which version of .NET is the code running on?\r\n* What OS version, and what distro if applicable?\r\n* What is the architecture (x64, x86, ARM, ARM64)?\r\n* If relevant, what are the specs of the machine?\r\n  --\u003e\r\n\r\nSystem: Ubuntu 22.04 X64\r\n.NET Version: 8.0\r\n\r\n### Data\r\n\r\n\u003c!--\r\n* Please include any benchmark results, images of graphs, timings or measurements, or callstacks that are relevant.\r\n* If possible please include text as text rather than images (so it shows up in searches).\r\n* If applicable please include before and after measurements.\r\n* There is helpful information about measuring code in this repo [here](https://github.com/dotnet/performance/blob/master/docs/benchmarking-workflow-dotnet-runtime.md).\r\n  --\u003e\r\n![image](https://github.com/user-attachments/assets/3862d38d-a4ca-4594-bcdf-5251f0afb108)\r\n\r\n\r\n### Analysis\r\n\r\n\u003c!--\r\n* If you have an idea where the problem might lie, let us know that here.\r\n* Please include any pointers to code, relevant changes, or related issues you know of.\r\n* If you don\u0027t know, you can delete this section.\r\n  --\u003e\r\n[Downstream.zip](https://github.com/user-attachments/files/16755617/Downstream.zip)\r\n\r\nThe response time is longer, and the number of requests remains the same, which means more requests need to be processed, and more threads are needed to process these requests, so the CPU increases. However, my setting of MinThreads has no effect at all. The thread increase still takes 1 minute. What I hope is that a certain amount of threads can be prepared in advance so that when burst traffic comes in, these threads can be used directly without temporarily enabling new threads. Temporarily enabling a large number of requests will cause a lot of CPU pressure and easily cause the server to go down.\r\n\r\n```csharp\r\nThreadPool.SetMinThreads(200, 200);\r\n\r\nThreadPool.SetMaxThreads(1000, 1000);\r\n```\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOkxGcfg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6JxeG7",
                                           "createdAt":  "2024-08-27T02:27:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-08-27T02:27:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6KgaV9",
                                           "createdAt":  "2024-09-02T03:40:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "zhenlei520",
                                           "body":  "https://github.com/microsoft/reverse-proxy/issues/2427#issuecomment-1977911480\r\n\r\nWe use it in yarp and find that a lot of CPU resources are occupied in SetThreadPoolWorkerThreadName, but this is a runtime problem. Is there any room for optimization?",
                                           "updatedAt":  "2024-09-02T03:40:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6TDdNn",
                                           "createdAt":  "2024-11-11T03:24:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "WeihanLi",
                                           "body":  "\u003e a lot of CPU resources are occupied in SetThreadPoolWorkerThreadName\n\nmaybe relate to https://github.com/dotnet/runtime/issues/108057",
                                           "updatedAt":  "2024-11-11T03:24:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6TEZx-",
                                           "createdAt":  "2024-11-11T07:17:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "zhenlei520",
                                           "body":  "\u003e \u003e a lot of CPU resources are occupied in SetThreadPoolWorkerThreadName\n\u003e \n\u003e maybe relate to [#108057](https://github.com/dotnet/runtime/issues/108057)\n\nYes. In which version will this problem be fixed?",
                                           "updatedAt":  "2024-11-11T07:17:20Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "How to deal with traffic bursts",
        "labels":  [
                       "area-System.Threading",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/107034",
        "createdAt":  "2024-08-27T13:40:04Z",
        "number":  107034,
        "author":  "brantburnett",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC8gIxg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-08-27T13:57:52Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2024-08-30T00:19:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aetos382",
                                            "createdAt":  "2024-11-08T10:49:21Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2024-09-02T18:17:01Z",
        "body":  "### Background and motivation\r\n\r\nCurrently, the only way to use a `TimeProvider` with a `CancellationTokenSource` is by passing the `TimeProvider` to the constructor. However, the concept of `CancellationTokenSource` pooling is allowed via the `TryReset()` method. After renting from a pool `CancelAfter(...)` might be used to schedule cancellation on a timer, but this method doesn\u0027t currently accept a `TimeProvider`.\r\n\r\nAdditionally, I don\u0027t believe there is a 100% thread-safe way to implement this externally as an extension. This is because the implementation of `TryReset` needs to know about the `ITimer` and validate its state, which it can\u0027t do with an external timer created by an extension method. (Note: This is also why this proposal doesn\u0027t include an extension to `System.Threading.Tasks.Task.TimeProviderTaskExtensions` in `Microsoft.Bcl.Async`).\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Threading;\r\n\r\npublic partial class CancellationTokenSource\r\n{\r\n    // Existing API\r\n    public CancellationTokenSource(TimeSpan delay, TimeProvider timeProvider);\r\n    public void CancelAfter(TimeSpan delay);\r\n    public void CancelAfter(int millisecondsDelay);\r\n    \r\n    // New API\r\n    public void CancelAfter(TimeSpan delay, TimeProvider timeProvider);\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\npublic class MyClass(TimeProvider timeProvider)\r\n{\r\n    public async DoWork(TimeSpan timeout)\r\n    {\r\n        var cts = SomeCancellationTokenSourcePool.Rent();\r\n        try\r\n        {\r\n            cts.CancelAfter(timeout, timeProvider);\r\n\r\n            // Do work...\r\n        }\r\n        finally\r\n        {\r\n            SomeCancellationTokenSourcePool.Return(cts); // Pool implementation calls cts.TryReset and discards if false is returned\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nThis pattern may often be used where `WaitAsync` may be a better pattern, so we could leave off the API to encourage the use of `WaitAsync`. However, `WaitAsync` isn\u0027t fully equivalent if you need cancellation to propagate into called methods after the timeout.\r\n\r\nIt appears that it\u0027s also possible to create a CTS using a time provider and `Timeout.Infinite`, then later use `CancelAfter` to change the timeout. This could be used if it is known that all sources in the pool will use the same time provider.\r\n\r\n### Risks\r\n\r\nThe current implementation of `CancelAfter` has a performance optimization that uses `ITimer.Change` to change the current timer if one already exists. This approach would be invalid if the provided `TimeProvider` is not the same provider originally used when the timer was created. For `TimeProvider.System` we can optimize by type checking for `TimerQueueTimer`, but for any other `TimeProvider` I think it would be required to create a new timer.\r\n\r\nAlternatively, a DIMed method to get the `TimeProvider` could be added to `ITimer`. But this may be overkill, especially since the DIM would need to return `null` so the above logic would still be required in the null case.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOipdXJw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6J1250",
                                           "createdAt":  "2024-08-27T13:40:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-08-27T13:40:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6J2bZ9",
                                           "createdAt":  "2024-08-27T14:34:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "brantburnett",
                                           "body":  "Upon closer inspection, while I do think this API is worthwhile I\u0027m not sure it\u0027s sufficient by itself. `TryReset` only resets and allows pooling when the timer is a `TimerQueueTimer`, which only applies in the case of `TimeProvider.System`. This appears to be because `TimerQueueTimer` has additional internal support for `_everQueued` so that `TryReset` can test to see if the timer has queued work after firing. Other timer implementations can\u0027t expose this without extending `ITimer`.",
                                           "updatedAt":  "2024-08-27T14:34:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6KfqR3",
                                           "createdAt":  "2024-09-02T00:10:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "This has been discussed and rejected multiple times in the past, e.g.\nhttps://github.com/dotnet/runtime/issues/85080#issuecomment-1524020384",
                                           "updatedAt":  "2024-09-02T00:10:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Kl1cn",
                                           "createdAt":  "2024-09-02T18:16:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "brantburnett",
                                           "body":  "\u003e This has been discussed and rejected multiple times in the past, e.g. [#85080 (comment)](https://github.com/dotnet/runtime/issues/85080#issuecomment-1524020384)\r\n\r\nSorry, I tried to find a previous issue and apparently I didn\u0027t look hard enough. Upon more careful review, I agree that this is probably not worthwhile, especially considering that (to my understanding) using a `TimeProvider` other than `System` is primarily intended for unit tests. This means that pooling non-System providers isn\u0027t terribly important from a performance perspective, unless there are other use cases out there for custom time providers.\r\n\r\nThe only downside to not having a built-in solution is the need for code like this when using a pool. But given the complexity of any possible solution versus the relative simplicity of this code, on balance I think that using code like this makes more sense.\r\n\r\n```c#\r\npublic CancellationTokenSource Rent(TimeProvider timeProvider, TimeSpan delay)\r\n{\r\n    if (timeProvider == TimeProvider.System)\r\n    {\r\n        // Using system time provider so we can use the pool and the built-in CancelAfter\r\n        var cts = _pool.Get();\r\n        cts.CancelAfter(delay);\r\n        return cts;\r\n    }\r\n\r\n    // Can\u0027t use the pool when unit testing because custom TimeProviders aren\u0027t supported except on construction.\r\n    // Note that a CTS returned to the pool using a custom TimeProvider will always return false from TryReset and\r\n    // therefore won\u0027t be reused.\r\n    return timeProvider.CreateCancellationTokenSource(delay);\r\n}\r\n```",
                                           "updatedAt":  "2024-09-02T18:16:59Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "[API Proposal]: Add CancellationTokenSource.CancelAfter overload that accepts TimeProvider",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/107094",
        "createdAt":  "2024-08-28T16:30:13Z",
        "number":  107094,
        "author":  "timcassell",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-08-28T21:55:55Z",
        "body":  "### Background and motivation\r\n\r\nI need to register a listener to the token while holding a non-reentrant lock (like SpinLock). If the callback is synchronously invoked due to the token having been canceled, it will cause a deadlock. It\u0027s impossible to simply check the `IsCancellationRequested` property before registering, because it could still be canceled on another thread, causing a race condition.\r\n\r\n### API Proposal\r\n\r\n```cs\r\nnamespace System.Threading;\r\n\r\npublic struct CancellationToken\r\n{\r\n    public CancellationTokenRegistration UnsafeRegisterWithoutImmediateInvoke(Action\u003cobject?\u003e callback, object? state, out bool alreadyCanceled);\r\n    public CancellationTokenRegistration UnsafeRegisterWithoutImmediateInvoke(Action\u003cobject?, CancellationToken\u003e callback, object? state, out bool alreadyCanceled);\r\n}\r\n```\r\n\r\n`alreadyCanceled` is set to true if the callback would have been invoked using the existing register APIs.\r\n\r\n### API Usage\r\n\r\n```cs\r\n_spinLock.Enter();\r\nvar obj = new MyAsyncObject(this);\r\nobj._registration = cancellationToken.UnsafeRegisterWithoutImmediateInvoke(o =\u003e ((MyAsyncObject) o).Cancel(), obj, out bool alreadyCanceled);\r\nif (!alreadyCanceled)\r\n{\r\n    _queue.Enqueue(obj);\r\n}\r\n_spinLock.Exit();\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nAlternative 1 - use a more expensive reentrant lock.\r\n\r\nAlternative 2 - use a `[ThreadStatic]` field to determine if the callback is invoked synchronously.\r\n\r\n```cs\r\n[ThreadStatic] private static bool ts_hookingUpCancelation;\r\n\r\n// ...\r\n\r\n_spinLock.Enter();\r\nvar obj = new MyAsyncObject(this);\r\nts_hookingUpCancelation = true;\r\nobj._registration = cancellationToken.UnsafeRegister(o =\u003e\r\n{\r\n    if (ts_hookingUpCancelation)\r\n    {\r\n        ts_hookingUpCancelation = false;\r\n        return;\r\n    }\r\n    ((MyAsyncObject) o).Cancel();\r\n}, obj);\r\nif (!ts_hookingUpCancelation)\r\n{\r\n    _queue.Enqueue(obj);\r\n}\r\nelse\r\n{\r\n    ts_hookingUpCancelation = false;\r\n}\r\n_spinLock.Exit();\r\n```\r\n\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOighLOw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6KCEs7",
                                           "createdAt":  "2024-08-28T16:30:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-08-28T16:30:36Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "[API Proposal]: CancellationToken.UnsafeRegisterWithoutImmediateInvoke",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/107183",
        "createdAt":  "2024-08-30T13:18:36Z",
        "number":  107183,
        "author":  "YoshiRulz",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-13T15:39:13Z",
        "body":  "Per discussions at #96347 (there is no official documentation\u0026dagger;), the size of the *default/global* stack is fixed and differs between OSes.\r\nASP.NET devs can use [the `stackSize` setting](https://learn.microsoft.com/en-us/aspnet/core/host-and-deploy/iis/advanced?view=aspnetcore-8.0#modify-the-stack-size) (only with IIS?) to configure it. I would like to do the same with a CLI or desktop app. A new API or an environment variable would also be acceptable for me.\r\nI would use this to *decrease* the size in order to root out stealthy bugs, but I can also see it being used to increase the size for some non-ASP.NET server or other high-perf use case.\r\n\r\nSee also:\r\n- Previous requests [#11634](https://github.com/dotnet/runtime/issues/11634) and [#12042](https://github.com/dotnet/runtime/issues/12042), which were closed as resolved, but OP in [#96347](https://github.com/dotnet/runtime/issues/96347) says the new flag was never exposed for public use.\r\n- [#30034](https://github.com/dotnet/runtime/issues/30034) was requesting a new API to get the currently applicable stack size at runtime. Closed as stale.\r\n- [#8861](https://github.com/dotnet/runtime/issues/8861) and [#33622](https://github.com/dotnet/runtime/issues/33622) inquiring as to why the stack is a different size on different OSes.\r\n\r\n\u0026dagger; There seemed to be no official documentation for the stack in modern .NET, and info for .NET Framework and Mono was all over the place, so I\u0027ve [collected everything I\u0027ve found here](https://github.com/TASEmulators/BizHawk/wiki/C%23-and-.NET-docs-supplement#allocation-limits).",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOitgETQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6KX3BB",
                                           "createdAt":  "2024-08-30T14:52:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEVR-ag==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "YoshiRulz",
                                                                               "createdAt":  "2024-08-30T15:03:59Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "0xfeeddeadbeef",
                                                                               "createdAt":  "2025-06-04T09:52:50Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "janvorli",
                                           "body":  "On Unix, you can set the default stack size this way:\r\n* Using the `ulimit -s` shell command. That sets it for the main thread and on glibc based distros for secondary threads too. On MUSL based distros like Alpine, the `DOTNET_DefaultStackSize` needs to be used for the secondary threads.\r\n\r\nOn all OSes, but only for secondary threads, since the main thread stack size is set by the OS when launching the application and the runtime cannot influence it.\r\n* Using the `DOTNET_DefaultStackSize` env variable\r\n* Using `DEFAULT_STACK_SIZE` property passed to `coreclr_initialize` in case you have your own custom .NET host\r\n\r\nOn Windows, you can also modify the stack size set in the host executable (if you build your app, you end up having YourApp.exe and YourApp.dll, the .exe is the host)\r\n* To set the stack size to e.g. 4MB: `editbin.exe YourApp.exe /STACK:0x400000`\r\n\r\nYou can also specify the thread stack size when creating new threads in your code in the constructor of the thread (`public Thread (System.Threading.ThreadStart start, int maxStackSize)`). However, that doesn\u0027t work for threadpool threads.\r\n\r\n",
                                           "updatedAt":  "2024-08-30T14:52:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6KsW4a",
                                           "createdAt":  "2024-09-03T15:57:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-09-03T15:57:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Ksz-K",
                                           "createdAt":  "2024-09-03T16:52:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "@YoshiRulz is this sufficient for you or would you like something additional?",
                                           "updatedAt":  "2024-09-03T16:52:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6KzF_F",
                                           "createdAt":  "2024-09-04T11:21:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "YoshiRulz",
                                           "body":  "My team develops on and builds for Windows and Linux, so I think we could use a combination of those 2 workarounds, but it still seems odd that there\u0027s no way to change the stack size for the main thread.\r\n\r\nedit: I maintain that a compile-time `EDITBIN` invocation and a runtime `ulimit` invocation are both *workarounds*. For one, I imagine they can\u0027t be used on Android. BASH on macOS might have `ulimit`, not sure.",
                                           "updatedAt":  "2024-09-04T12:19:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Kzfw8",
                                           "createdAt":  "2024-09-04T11:52:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODw8jZg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "YoshiRulz",
                                                                               "createdAt":  "2024-09-04T12:14:47Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "janvorli",
                                           "body":  "\u003e it still seems odd that there\u0027s no way to change the stack size for the main thread.\r\n\r\n@YoshiRulz there are ways to change it for the main thread both on Windows and Linux that I\u0027ve mentioned in my previous comment:\r\n* Using the `ulimit -s` shell command on Linux\r\n* Modify the stack size set in the host executable on Windows using the `editbin.exe`.\r\n\r\n\r\n",
                                           "updatedAt":  "2024-09-04T11:52:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6K0Hwa",
                                           "createdAt":  "2024-09-04T12:47:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEVR-1A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "0xfeeddeadbeef",
                                                                               "createdAt":  "2025-06-04T09:53:33Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "janvorli",
                                           "body":  "@YoshiRulz what\u0027s wrong with these ways? The default stack size for the main thread is something only the operating system can set, because it needs to be set before the process is launched and the application itself doesn\u0027t have any way to control it.",
                                           "updatedAt":  "2024-09-04T12:47:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6K2ARN",
                                           "createdAt":  "2024-09-04T15:43:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "YoshiRulz",
                                           "body":  "As per my edit above, they\u0027re not cross-platform, and one is compile-time and one is runtime.\r\n\r\nIf the runtime can\u0027t change its own stack size, perhaps it could spawn a new thread with the stack size specified in the assembly metadata (for example) and begin execution of the main method on that thread?",
                                           "updatedAt":  "2024-09-04T15:43:51Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "[F.Rq.] Some way to configure the size of the stack",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/107441",
        "createdAt":  "2024-09-06T04:14:51Z",
        "number":  107441,
        "author":  "WeihanLi",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-09-18T18:40:34Z",
        "body":  "### Background and motivation\n\nIn additional to #64658 \u0026 #65184 should we consider introduce an API for `Interlocked.Read\u003cT\u003e(ref T field)`\n\n### API Proposal\n\n```diff\r\nnamespace System.Threading;\r\n\r\npublic static class Interlocked\r\n{\r\n+    public static T Read\u003cT\u003e(ref T location);\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nvar progress = 1;\r\n\r\nTask.Run(() =\u003e \r\n{\r\n    while(true)\r\n    {\r\n      var value = Interlocked.Read(ref progress);\r\n      Console.WriteLine(value);\r\n        \r\n      if (value \u003e= 100)\r\n          break;\r\n        \r\n      Thread.Sleep(1000);\r\n    }\r\n});\r\n\r\nParallel.For(1, 100, (i, _) =\u003e \r\n{\r\n\r\n  // ...\r\n  Thread.Sleep(i * 30);\r\n  Interlocked.Increment(ref progress);\r\n});\r\n\r\nConsole.WriteLine(\"done\");\r\nConsole.ReadLine();\r\n\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOi1wCxA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6LEdIY",
                                           "createdAt":  "2024-09-06T04:15:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-09-06T04:15:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6LJk9U",
                                           "createdAt":  "2024-09-06T17:44:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "colejohnson66",
                                           "body":  "To read variables, `Volatile.Read` already exists.",
                                           "updatedAt":  "2024-09-06T17:44:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6LL4NP",
                                           "createdAt":  "2024-09-07T10:35:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "\u003e To read variables, `Volatile.Read` already exists.\r\n\r\n`Interlocked.Read` provides stronger memory ordering (Seq-Cst) than `Volatile.Read`, but looks like it\u0027s indeed rarely used judging by [grep.app](https://grep.app/search?q=Interlocked.Read) so do we really want to add this API for consistency or wait for a real-world demand?\r\n\r\nPS: The official doc for [Interlocked.Read](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked.read?view=net-8.0) could be updated, its Remarks section is not entirely correct (while Read is atomic, it doesn\u0027t mean a full fence we emit here and which is promised by Interlocked in general, is useless on 64bit systems)",
                                           "updatedAt":  "2024-09-07T10:37:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6LL5KZ",
                                           "createdAt":  "2024-09-07T10:53:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Interlocked.Read provides stronger memory ordering (Seq-Cst) than Volatile.Read\r\n\r\nThe implementation of `Interlocked.Read` happens to provide strong memory ordering guarantee. The contract of the API was not meant to provide such stronger memory ordering guarantee. It was only meant to provide atomicity guarantees. \r\n\r\n`Interlocked.Read` is confusing API since the implementation actually does a dummy write, so the performance characteristics and the corner case behaviors are absolutely not what one excepts.",
                                           "updatedAt":  "2024-09-07T10:53:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6LL5lb",
                                           "createdAt":  "2024-09-07T11:01:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODxYDrw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "AlgorithmsAreCool",
                                                                               "createdAt":  "2024-09-07T15:10:43Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "\u003e The contract of the API was not meant to provide such stronger memory ordering guarantee.\r\n\r\n![image](https://github.com/user-attachments/assets/c5e3eaab-c88d-4c78-a2ec-17e004e86a93)\r\n\r\n^ from our Memory Model doc: https://github.com/dotnet/runtime/blob/main/docs/design/specs/Memory-model.md#order-of-memory-operations",
                                           "updatedAt":  "2024-09-07T11:04:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6LTJlV",
                                           "createdAt":  "2024-09-09T03:45:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "WeihanLi",
                                           "body":  "From the grep search, there are some usage like `Interlocked.CompareExchange(ref status, 1, 1)`\r\n\r\nIs this necessary? If yes, maybe we could have an API like this to simplify the usage. If not, is `Volatile.Read` enough for the same purpose?\r\n\r\nhttps://grep.app/search?q=Interlocked.CompareExchange%5C%28ref%20%28%5Cw%2B%29%2C%201%2C%201%5C%29\u0026regexp=true\r\n\r\n![image](https://github.com/user-attachments/assets/6bd7becc-4881-4334-a84d-b1b00a00aede)\r\n\r\n![image](https://github.com/user-attachments/assets/7fecf913-f57b-4ff3-bbcb-28393d93e9fb)\r\n\r\n![image](https://github.com/user-attachments/assets/75c92249-5979-416a-a710-a7c3f768209a)\r\n",
                                           "updatedAt":  "2024-09-09T10:51:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6LXALE",
                                           "createdAt":  "2024-09-09T13:00:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODxhOkw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "WeihanLi",
                                                                               "createdAt":  "2024-09-09T13:01:24Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "colejohnson66",
                                           "body":  "An analyzer flagging \"incorrect\" usages of `Interlocked.CompareExchange` would be useful, but that\u0027s a different discussion",
                                           "updatedAt":  "2024-09-09T13:00:11Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "[API Proposal]: `Interlocked.Read` generic API",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/107449",
        "createdAt":  "2024-09-06T08:56:36Z",
        "number":  107449,
        "author":  "ShadedBlink",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODFAjuA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "timcassell",
                                            "createdAt":  "2024-11-06T19:14:09Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "NinoFloris",
                                            "createdAt":  "2025-06-27T17:19:15Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2025-07-02T13:08:00Z",
        "body":  "### Background and motivation\n\n.Net 9 now allows us to exchange more types like byte, short and enums. It would be nice to expand `Volatile.Write()` and `Volatile.Read()` with such overloads as well.\n\n### API Proposal\n\n```diff\npublic static class Volatile\n{\n    // Remove constraints from existing methods, making them work for primitives and throw for unsupported types,\n    // as was done with Interlocked.{Compare}Exchange\n    public static T Read\u003cT\u003e([NotNullIfNotNull(nameof(location))] ref readonly T location)\n-        where T : class?\n    public static void Write\u003cT\u003e([NotNullIfNotNull(nameof(value))] ref T location, T value) \n-        where T : class?\n}\n```\n\n\n### API Usage\n\n```csharp\nvar x = SomeEnumType.DefaultValue;\nVolatile.Write(ref x, SomeEnumType.NonDefaultValue);\n```\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\nNo risks, everything already implemented in `net9.0`.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOtHiyoQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6LF8Qj",
                                           "createdAt":  "2024-09-06T09:02:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-09-06T09:02:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6LInpQ",
                                           "createdAt":  "2024-09-06T15:21:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "[These already exist](https://learn.microsoft.com/en-us/dotnet/api/system.threading.volatile.write?view=net-8.0).  Are you thinking of something else?",
                                           "updatedAt":  "2024-09-06T15:21:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6LJgKp",
                                           "createdAt":  "2024-09-06T17:35:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ShadedBlink",
                                           "body":  "@Clockwork-Muse , sorry, I missed the byte part. However, generic case supports only object types, like it was before with `Interlocked.Exchange\u003cT\u003e()`. In `net9.0` `Interlocked.Exchange\u003cT\u003e()` was updated to support both primitives and objects so enums are supported as well. Same changes should be applied to generic case of `Volatile.Write()` and `Volatile.Read()`. I updated proposal.",
                                           "updatedAt":  "2024-09-06T17:35:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Nn8e4",
                                           "createdAt":  "2024-09-26T06:38:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ShadedBlink",
                                           "body":  "@Clockwork-Muse @mangod9 \r\nSo what is to expect? `net9.0` is near, `Interlocked.Exchange()` changes are already implemented and announced, will we have corresponding changes to `Volatile`? This seems as a small enough change to add it before release.",
                                           "updatedAt":  "2024-09-26T06:38:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Nslfg",
                                           "createdAt":  "2024-09-26T15:20:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODz0DWw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ShadedBlink",
                                                                               "createdAt":  "2024-09-27T08:25:04Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "mangod9",
                                           "body":  "at this point we are already locked down for 9, so we will have to consider these for next release. ",
                                           "updatedAt":  "2024-09-26T15:20:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6SiYIy",
                                           "createdAt":  "2024-11-06T00:49:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "Unlike the new `Interlocked` functionality, this should be able to support all types. Any type \u003c= `IntrPtr.Size` can be special-cased, and any larger type can use the new `Volatile.(Read/Write)Barrier` APIs.",
                                           "updatedAt":  "2024-11-06T00:49:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Siiyt",
                                           "createdAt":  "2024-11-06T01:38:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Yes, it can support all type. I think the question is whether it should support all types. `Volatile` has been historically limited to atomically read/written values. Relaxing it is going to lead to more subtle thread-safety bugs that will get unnoticed. Is the extra convenience worth it? Also, if we relax `Volatile.Read/Write`, are we also going to remove C# restriction that allows `volatile` to be used for atomically read/written values only?",
                                           "updatedAt":  "2024-11-06T01:38:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Sij7l",
                                           "createdAt":  "2024-11-06T01:43:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "I certainly wouldn\u0027t mind lifting the C# restriction. It seems to me that volatile is an ordering guarantee, not an atomic guarantee. It would be nice to pair such a change with the addition of `Atomic\u003cT\u003e`, though, to reduce any potential confusion.",
                                           "updatedAt":  "2024-11-06T01:43:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6zpCVF",
                                           "createdAt":  "2025-06-27T17:30:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "NinoFloris",
                                           "body":  "Can we still get this up for review for 10.0 @mangod9? This is something I\u0027m running into consistently with the new Interlocked.{Compare}Exchange support when used directly with enums. Once the inevitable need to do a volatile read of such an enum field arises you need to do unsafe reinterpretation casts again.",
                                           "updatedAt":  "2025-06-27T17:30:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6zpMt_",
                                           "createdAt":  "2025-06-27T17:49:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "This hadn\u0027t come up as a priority for 10, but we will consider if time permits. ",
                                           "updatedAt":  "2025-06-27T17:49:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6zpQ3p",
                                           "createdAt":  "2025-06-27T17:54:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "NinoFloris",
                                           "body":  "This would help with reducing the need for unsafe code and complements the work done in 9.0 on Interlocked by doing the same for Volatile.\n\nIt so happens that the [api review queue](https://apireview.net/) is running dry, so as long as there are no concerns would you mind tagging it as api-ready-for-review?\n\ncc @stephentoub ",
                                           "updatedAt":  "2025-06-27T17:54:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6zpbU1",
                                           "createdAt":  "2025-06-27T18:11:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEb8nnA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "NinoFloris",
                                                                               "createdAt":  "2025-07-25T16:17:26Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "I\u0027d personally have no problem with removing the constraint, but even if we approve doing so in API review, that doesn\u0027t say anything about when the work would actually be done to fix up the implementation accordingly.",
                                           "updatedAt":  "2025-06-27T18:11:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc60Tavf",
                                           "createdAt":  "2025-07-01T17:49:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bartonjs",
                                           "body":  "[Video](https://www.youtube.com/watch?v=52f8Bz8db04\u0026t=0h36m12s)\n\nLooks good as proposed, consistent with the change on Interlocked.\n\n```diff\npublic static class Volatile\n{\n    // Remove constraints from existing methods, making them work for primitives and throw for unsupported types,\n    // as was done with Interlocked.{Compare}Exchange\n    public static T Read\u003cT\u003e([NotNullIfNotNull(nameof(location))] ref readonly T location)\n-        where T : class?\n    public static void Write\u003cT\u003e([NotNullIfNotNull(nameof(value))] ref T location, T value) \n-        where T : class?\n}\n```",
                                           "updatedAt":  "2025-07-01T19:05:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc60VMWx",
                                           "createdAt":  "2025-07-01T20:47:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "API review really glossed over support for any T just amounts to emitting a memory barrier. It doesn\u0027t _have_ to be as restrictive as Interlocked. Seems like it could be a missed opportunity to me (#109572).",
                                           "updatedAt":  "2025-07-01T20:47:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc60VR3m",
                                           "createdAt":  "2025-07-01T20:53:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e API review really glossed over support for any T just amounts to emitting a memory barrier. It doesn\u0027t _have_ to be as restrictive as Interlocked. Seems like it could be a missed opportunity to me ([#109572](https://github.com/dotnet/runtime/issues/109572)).\n\nIt needs to be atomic. It can\u0027t support any T.",
                                           "updatedAt":  "2025-07-01T20:53:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc60VeSr",
                                           "createdAt":  "2025-07-01T21:07:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEY4SGA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hamarb123",
                                                                               "createdAt":  "2025-07-02T12:54:02Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e It needs to be atomic. It can\u0027t support any T.\n\nThe implementation can support any T. We have introduced `Volatile.ReadBarrier` and `Volatile.WriteBarrier` for that exact (non-atomic) scenario. The implementation of the proposed APIs can look like this:\n\n```\npublic static T Read\u003cT\u003e([NotNullIfNotNull(nameof(location))] ref readonly T location)\n{\n    T value = location;\n    Volatile.ReadBarrier();\n    return value;\n}\n\npublic static void Write\u003cT\u003e([NotNullIfNotNull(nameof(value))] ref T location, T value)\n{\n    Volatile.WriteBarrier();\n    location = value;\n}\n```\n\nThe question is whether allowing any T in these convenience wrappers is more helpful or more confusing.",
                                           "updatedAt":  "2025-07-01T21:07:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc60Vf7x",
                                           "createdAt":  "2025-07-01T21:09:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "As per the [Memory Model](https://github.com/dotnet/runtime/blob/main/docs/design/specs/Memory-model.md):\n```\nThe following methods perform atomic memory accesses regardless of the platform when the location of the variable is managed by the runtime.\n\nSystem.Threading.Interlocked methods\nSystem.Threading.Volatile methods\n```",
                                           "updatedAt":  "2025-07-01T21:09:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc60VgUU",
                                           "createdAt":  "2025-07-01T21:09:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003eThe implementation can support any T.\n\nHow? We document that these methods perform a single atomic memory access.",
                                           "updatedAt":  "2025-07-01T21:09:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc60VgZe",
                                           "createdAt":  "2025-07-01T21:10:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "I think it’s more confusing, particularly since we cannot guarantee atomicity here.\n\nIf people are using arbitrary T, I think they should have it very explicit (by default) that tears are still possible and something that may need to be considered. Making that explicit by forcing use of the barrier seems like goodness",
                                           "updatedAt":  "2025-07-01T21:10:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc60Vird",
                                           "createdAt":  "2025-07-01T21:12:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEY4v8w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "timcassell",
                                                                               "createdAt":  "2025-07-01T21:30:46Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hamarb123",
                                                                               "createdAt":  "2025-07-02T12:54:07Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2025-07-02T13:36:37Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e We document that these methods perform a single atomic memory access.\n\nWe have to update the documentation for the API update, so the notes on atomic guarantees can be updated at the same time.",
                                           "updatedAt":  "2025-07-01T21:12:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc60Vj6Q",
                                           "createdAt":  "2025-07-01T21:14:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e I think it’s more confusing\n\nI agree. It would be confusing for anybody with a historic context on volatile in C# and .NET.\n\n",
                                           "updatedAt":  "2025-07-01T21:14:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc60VxVj",
                                           "createdAt":  "2025-07-01T21:33:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEYxSyg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tannergooding",
                                                                               "createdAt":  "2025-07-01T21:35:05Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "333fred",
                                           "body":  "\u003e \u003e I think it’s more confusing\n\u003e \n\u003e I agree. It would be confusing for anybody with a historic context on volatile in C# and .NET.\n\nSpeaking as someone who probably has enough knowledge here to be dangerous to myself and others, I would be _very_ surprised if it actually worked with something that is 3 `long`s (or similarly larger than atomic cpu instructions exist for). I absolutely expect that calling `Volatile.Read/Write` will produce an atomic operation with everything Read/Written being done all at once, no chance of shearing; allowing that to be violated will likely lead to difficult-to-troubleshoot race conditions where the user accidentally takes advantage of this without realizing that they are being exposed to shearing.",
                                           "updatedAt":  "2025-07-01T21:33:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc60V0e7",
                                           "createdAt":  "2025-07-01T21:39:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEYxZAg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "333fred",
                                                                               "createdAt":  "2025-07-01T21:51:00Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Right, it depends on where you are coming from. If you came from C++ or Rust, you would be surprised that volatile tries to guarantee atomicity. Volatile does not guarantee atomicity in most (or all?) other languages.",
                                           "updatedAt":  "2025-07-01T21:39:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc60V35w",
                                           "createdAt":  "2025-07-01T21:46:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "\u003e Volatile does not guarantee atomicity in most (or all?) other languages.\n\nmy 5 cents that , `volatile` also promises atomic access on 32-bit targets for 64-bit fields if they have `volatile` keyword in Java just like in .NET, but overall I agree with the point",
                                           "updatedAt":  "2025-07-01T21:46:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc60eLKh",
                                           "createdAt":  "2025-07-02T13:02:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "\u003e my 5 cents that , `volatile` also promises atomic access on 32-bit targets for 64-bit fields if they have `volatile` keyword in Java just like in .NET, but overall I agree with the point\n\n`volatile` in C# doesn\u0027t allow fields of type `long`, only `Volatile` does. `volatile.` (in IL) doesn\u0027t guarantee atomicity either for \"large\" types. So imo you could easily argue that, while we have a consistent rule for `Volatile`, we don\u0027t have a consistent rule for volatile in general in .NET.\n\nI personally would like to see a non-atomic Volatile Read/Write, but the Read/Write-barriers get me most of the way there for most cases anyway, and in conjunction with some (slightly sketcky) unsafe trickery, I have basically optimised every case I care about w/o too much trouble (which just involves reading/writing as byte/short/int/nint/object instead of doing a barrier when `T` has suitable size \u0026 alignment (which there is no proper way to detect sadly, but I have something which is close enough for my uses thus far)).\n\nIf we added non-atomic Volatile Read/Write APIs, it should be under a seperate API imo (e.g., `Volatile.{Read/Write}NonAtomic`), rather than the pre-existing one, as the handling for `long`/`double` on 32-bit would either have to be slower than necessary (to match the explicitly typed one being atomic) or inconsistent.",
                                           "updatedAt":  "2025-07-02T13:08:00Z"
                                       }
                                   ],
                         "totalCount":  25
                     },
        "title":  "[API Proposal]: Volatile read/write for new supported types of Interlocked exchange",
        "labels":  [
                       "api-approved",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/108286",
        "createdAt":  "2024-09-26T14:57:27Z",
        "number":  108286,
        "author":  "fvaillancourt",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODIfPUg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dagophil",
                                            "createdAt":  "2024-09-26T18:14:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "martincostello",
                                            "createdAt":  "2024-09-26T22:33:16Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pat-sc-philips",
                                            "createdAt":  "2024-09-27T12:21:33Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dannyhorodniczy",
                                            "createdAt":  "2024-09-30T13:05:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "NN---",
                                            "createdAt":  "2024-10-02T06:05:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kmcclellan",
                                            "createdAt":  "2024-11-12T15:39:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sindrekroknes",
                                            "createdAt":  "2025-07-25T09:13:13Z"
                                        }
                                    ],
                          "totalCount":  7
                      },
        "updatedAt":  "2025-07-07T20:10:48Z",
        "body":  "### Background and motivation\n\nWhen calling `CancellationTokenSource.CreateLinkedTokenSource` there is no way to specify a `TimeProvider`. This makes it impossible to use fake time provider to unit test code using linked token source, as the linked token would be using `TimeProvider.System`.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Threading;\r\n\r\npublic class CancellationTokenSource : IDisposable\r\n{\r\n    // ...\r\n    public static CancellationTokenSource CreateLinkedTokenSource(TimeSpan delay, TimeProvider timeProvider, CancellationToken token);\r\n    public static CancellationTokenSource CreateLinkedTokenSource(TimeSpan delay, TimeProvider timeProvider, CancellationToken token1, CancellationToken token2);\r\n    public static CancellationTokenSource CreateLinkedTokenSource(TimeSpan delay, TimeProvider timeProvider, params CancellationToken[] tokens);\r\n}\r\n```\n\n### API Usage\n\n```csharp\r\npublic Task\u003cint\u003e ReadAsync(ArraySegment\u003cbyte\u003e data, CancellationToken cancellationToken)\r\n{\r\n    using var linkedToken = CancellationTokenSource.CreateLinkedTokenSource(TimeSpan.FromSeconds(10), _timeProvider, cancellationToken);\r\n    // Read for at most 10 seconds\r\n    return await _socket.ReadAsync(data, linkedToken);\r\n}\r\n```\r\n`_timeProvider` would come from the constructor, and could be System in normal code and Fake in unit tests.\n\n### Alternative Designs\n\n### New classes\r\nSome places in the framework just expose a whole new class that add functionalities rather than trying to tie it to existing one.\r\n```csharp\r\npublic sealed class TimeoutCancellationTokenSource : CancellationTokenSource\r\n{\r\n    public TimeoutCancellationTokenSource(CancellationToken parent, TimeSpan delay, TimeProvider timeProvider)\r\n        : base(delay, timeProvider) {}\r\n}\r\n```\r\nHowever it can only support one cancellation token. There would have to be two other classes to support two and N tokens. All of that is currently neatly hidden under `CreateLinkedTokenSource`.\r\n\r\n### No params\r\nAnother option, if we support only one or two cancellation token. That would allow moving new parameters to the end where they feel more natural.\r\n```csharp\r\nnamespace System.Threading;\r\n\r\npublic class CancellationTokenSource : IDisposable\r\n{\r\n    // ...\r\n    public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken token, TimeSpan delay, TimeProvider timeProvider);\r\n    public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken token1, CancellationToken token2, TimeSpan delay, TimeProvider timeProvider);\r\n}\r\n```\r\nHowever I do not think we can drop the N tokens override.\n\n### Risks\n\nI do not see any.\r\nAdded parameters cannot be confused with existing one and thus would not cause breaking changes. Required changes to implement this is all internal implementation and passing in delay and `TimeProvider` is already supported in `CancellationTokenSource` constructor so there is no big changes required. Implementation would probably follow the existing `CancellationTokenSource` pattern and use three new classes derived from `CancellationTokenSource` and pass in delay and `TimeProvider` to base constructor.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOtZREWg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6Nt_LV",
                                           "createdAt":  "2024-09-26T18:22:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD5_06Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "aetos382",
                                                                               "createdAt":  "2024-11-08T10:46:34Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "dagophil",
                                           "body":  "I ran across the same issue just a few days ago. It would be great to have this functionality.\r\n\r\nAs an alternative, one could add an overload of `CancelAfter` that takes a `TimeProvider` as input. This would solve your use case, since you can then call the new `CancelAfter` overload right after one of the existing `CreateLinkedTokenSource`. Additionally, it would solve even more use cases, because you can use it not only on linked CTS\u0027s, but also on \"normal\" CTS\u0027s.",
                                           "updatedAt":  "2024-09-26T18:22:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6NulE4",
                                           "createdAt":  "2024-09-26T19:45:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "\u003e As an alternative, one could add an overload of `CancelAfter` that takes a `TimeProvider` as input. This would solve your use case, since you can then call the new `CancelAfter` overload right after one of the existing `CreateLinkedTokenSource`. Additionally, it would solve even more use cases, because you can use it not only on linked CTS\u0027s, but also on \"normal\" CTS\u0027s.\r\n\r\nThis was previously rejected in #85131",
                                           "updatedAt":  "2024-09-26T19:45:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6NvL76",
                                           "createdAt":  "2024-09-26T21:18:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dagophil",
                                           "body":  "\u003e This was previously rejected in #85131\r\n\r\nI did not know that. Well, in that case I\u0027m even more in support of the proposed API :)\r\n",
                                           "updatedAt":  "2024-09-26T21:18:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6NwCFJ",
                                           "createdAt":  "2024-09-27T00:31:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-09-27T00:31:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc61lERa",
                                           "createdAt":  "2025-07-07T20:10:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEZuyRw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "fvaillancourt",
                                                                               "createdAt":  "2025-07-08T08:55:17Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "aDisplayName",
                                           "body":  "Ran across to the same problem, and upvote the proposal",
                                           "updatedAt":  "2025-07-07T20:10:48Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "[API Proposal]: Add TimeProvider to CreateLinkedTokenSource",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/109027",
        "createdAt":  "2024-10-18T20:05:41Z",
        "number":  109027,
        "author":  "rorozcov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-02T02:28:05Z",
        "body":  "### Description\n\nWe were using TokenBucketRateLimiter with a ReplenishmentPeriod in the microseconds (so less than 1ms). \n\n[This value is just passed into the Timer constructor by the limiter.](https://github.com/dotnet/runtime/blob/5535e31a712343a63f5d7d796cd874e563e5ac14/src/libraries/System.Threading.RateLimiting/src/System/Threading/RateLimiting/TokenBucketRateLimiter.cs#L28C9-L92C10) \n\n[The timer constructor however, has a line of code where it gets the period in total milliseconds from the timestamp, and then casts it to a long.](https://github.com/dotnet/runtime/blob/5535e31a712343a63f5d7d796cd874e563e5ac14/src/libraries/System.Private.CoreLib/src/System/Threading/Timer.cs#L848C9-L862C10)\n\nThis meant that any value \u003c 1ms was being casted to 0. We ran into an issue where the rate limiter was never replenishing, because the timer would not run, so our application would just pause and no errors were present.\n\nIn other applications our replenishment periods were \u003e 1ms, so this wasn\u0027t caught in those instances.\n\nI don\u0027t know if this qualifies as a bug, but at least the documentation should warn you about this.\n[TokenBucketRateLimiterOptions only warns about \u003e TimeSpan.Zero.](https://learn.microsoft.com/en-us/dotnet/api/system.threading.ratelimiting.tokenbucketratelimiteroptions?view=aspnetcore-8.0#:~:text=Specifies%20the%20minimum%20period%20between%20replenishments.%20Must%20be%20set%20to%20a%20value%20greater%20than%20Zero%20by%20the%20time%20these%20options%20are%20passed%20to%20the%20constructor%20of%20TokenBucketRateLimiter). \n\n[Timer\u0027s reference docs implicitly mention it here, which is the constructor used by the rate limiter.](https://learn.microsoft.com/en-us/dotnet/api/system.threading.timer.-ctor?view=net-8.0#system-threading-timer-ctor(system-threading-timercallback-system-object-system-timespan-system-timespan)).\n\n[These other docs do explicitly mention time being in milliseconds, but it is not the same constructor.](https://learn.microsoft.com/en-us/dotnet/api/system.timers.timer.-ctor?view=net-8.0#:~:text=The%20time%20between%20events.%20The%20value%20in%20milliseconds%20must%20be%20greater%20than%20zero%20and%20less%20than%20or%20equal%20to%20MaxValue)\n\nThe TokenBucketRateLimiter could maybe do something to prevent the timer from being initialized with a low enough TimeSpan, but then that would couple the limiter implementation much closer to the Timer implementation.\n\nI am not sure how or if this is something the .NET team would look to fix, but for us at least a documentation update or summary comment update would go a long way to make others aware of the limitation.\n\n### Reproduction Steps\n\nCreate a TokenBucketRateLimiter with a ReplenishmentPeriod of less than 1ms.\n```\n        var options = new TokenBucketRateLimiterOptions\n        {\n            TokenLimit = 1000,\n            QueueLimit = int.MaxValue,\n            TokensPerPeriod = 1,\n            ReplenishmentPeriod = TimeSpan.FromMicroseconds(500),\n            AutoReplenishment = true\n        };\n\n        var rateLimiter = new TokenBucketRateLimiter(options);\n```\n\nThen in the VS debugger:\n![Image](https://github.com/user-attachments/assets/8fccd4a3-b19e-4b20-a224-8ffb656c566a)\n\n\n\n\n\n\n\n\n\n\n\n\n### Expected behavior\n\nTo allow for lower than 1ms timespans or make it explicit that we cannot do a replenishment period (or timer period, depending on where the \"fix\") should be applied, lower than 1ms unless it\u0027s the infinite time span which is allowed.\n\n### Actual behavior\n\nAdded it in repro steps\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nWe have our own logic in our applications to ensure\n\n### Configuration\n\n.NET 8.0.403\nWindows (issue is found in our Linux containers too, running the aspnet image from the Microsoft MCR).\nWe run in x64 but target AnyCPU.\n\n### Other information\n\nI am happy to help in any way with fixing this issue, including creating pull requests since I know the team is quite busy. I wanted to consult with you all first before applying a \"fix\" I would like but that might not be aligned with your goals/thinking.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOwVVJtw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6Qbmwx",
                                           "createdAt":  "2024-10-18T20:06:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-10-18T20:06:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6QcRhE",
                                           "createdAt":  "2024-10-18T22:37:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "BrennanConroy",
                                           "body":  "Similar issue https://github.com/dotnet/runtime/issues/105446\n\nWe\u0027ll need to decide what behavior to have here. Throw for \"invalid\" values or set a minimum timer value.",
                                           "updatedAt":  "2024-10-18T22:37:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6QcSul",
                                           "createdAt":  "2024-10-18T22:44:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rorozcov",
                                           "body":  "I\u0027m happy to issue a PR to address this. The question is, how do we decide what the \"correct\" implementation is.\n\nI\u0027d argue that the rate limiter should just have a check for ms \u003e 1 and throw, with updates to docs and comments.\n\nI don\u0027t know if you want to \"fix\" the timer to allow smaller timescales than 1ms. That might be a more disruptive change given it\u0027s probably used in many more places",
                                           "updatedAt":  "2024-10-18T22:44:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6SDT7l",
                                           "createdAt":  "2024-10-31T16:42:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rorozcov",
                                           "body":  "@BrennanConroy \n\nSo I\u0027d say we have two choices in the timer:\n\n1. We throw if you pass in a value \u003c 1ms but greater than 0ms. This would be backwards compatible with anyone using insanely large Timespans (like int64.max for total ms or ns), and throwing could break users, their timers are already not working if they\u0027re passing in \u003c 1ms Timespans.\n\n2. We change the math to use total nanoseconds instead, considering the idea of anyone using int64.max as their Timespan is extremely unlikely. This could break someone passing in int64.max for the total milliseconds, but I\u0027d argue that is an unlikely edge case (int64.max in nanoseconds is around 292 years, with int64.max ms being 292.5 million years) exceeding human and hardware lifespans that we are unlikely to break anyone. This is my preferred option and it would enable much smaller periods for Timers.\n\nEither fix will require documentation changes to both the Timer docs and the TokenBucketRateLimiter docs.\n\nI am happy to write a PR if you and the .NET team agree in concept so we can iterate and solve it.\n\nLet me know!",
                                           "updatedAt":  "2024-10-31T16:42:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6T54Sv",
                                           "createdAt":  "2024-11-17T18:44:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rorozcov",
                                           "body":  "I\u0027ve checked the underlying APIs and it appears we do need to keep using milliseconds. I dug deeper and found that the other timers in .NET use different approaches.\n\nSystem.Threading.Timer (this timer) and [System.Threading.PeriodicTimer](https://github.com/dotnet/runtime/blob/1d1bf92fcf43aa6981804dc53c5174445069c9e4/src/libraries/System.Private.CoreLib/src/System/Threading/PeriodicTimer.cs#L110C1-L121C10) both just cast the milliseconds to a long.\n\nHowever, [System.Timers.Timer uses Math.Ceiling](https://github.com/dotnet/runtime/blob/1d1bf92fcf43aa6981804dc53c5174445069c9e4/src/libraries/System.ComponentModel.TypeConverter/src/System/Timers/Timer.cs#L49C1-L63C10) to avoid the problems I\u0027ve mentioned in this thread.\n\nNow, while any number \u003c 1ms is going to be way less than the minimum timer resolution, the intent of a user passing in \u003c 1ms should still be that the timer will run. Assuming less than 1ms is 0 is confusing from a user\u0027s point of view, because only by explicitly setting it to zero would one assume it\u0027ll only run once.\n\nI\u0027ve consulted with others and have reached the following two options:\n\n1. Updated System.Threading.Timer to use Match.Ceiling. This brings backcompat risks since other users could\u0027ve written code around this problem already.\n\n2. Updating the docs to make it extremely clear that any value below 1ms will be treated as 0 and that users should mitigate this themselves.\n\n",
                                           "updatedAt":  "2024-11-17T18:44:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6UNDta",
                                           "createdAt":  "2024-11-19T18:29:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "BrennanConroy",
                                           "body":  "It\u0027s very unlikely that we would make a change in the timer implementation for this.\n\nReally we have 3 options IMO:\n\n1. Do nothing except update docs\n2. Set a lower bound of 1ms in the rate limiter implementations\n3. Throw if we get an interval of less than 1ms\n\nI think I\u0027m leaning towards option 2 (with some doc updates). Limiters will keep working, and if someone uses settings that would have made the interval less than 1ms the limiter will worst case be more restrictive than the user expects, which seems better than less restrictive.",
                                           "updatedAt":  "2024-11-19T18:29:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6_eGrw",
                                           "createdAt":  "2025-08-21T23:19:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEgbnDw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "BrennanConroy",
                                                                               "createdAt":  "2025-08-21T23:32:46Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "rorozcov",
                                                                               "createdAt":  "2025-09-02T02:24:56Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "TonyValenti",
                                           "body":  "I believe that option 2 is the right option as it captures user intent. ",
                                           "updatedAt":  "2025-08-21T23:19:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7BVUm3",
                                           "createdAt":  "2025-09-02T02:28:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rorozcov",
                                           "body":  "@BrennanConroy is someone actively looking into fixing this?\n\nI might have some time in the next month or so to address the issue. It should only be a couple of lines of code to set the limit to 1ms. \n\nThoughts?",
                                           "updatedAt":  "2025-09-02T02:28:05Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  ".NET 8 Timer Implementation Has Silent Period Minimum and TokenBucketRateLimiter Is Not Aware of This",
        "labels":  [
                       "area-System.Threading",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/109246",
        "createdAt":  "2024-10-25T21:58:35Z",
        "number":  109246,
        "author":  "thomhurst",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC8PazQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "julealgon",
                                            "createdAt":  "2024-10-25T22:23:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-10-29T12:16:44Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2025-07-01T16:40:36Z",
        "body":  "### Background and motivation\n\nI\u0027ve found that in complex systems where you have a process that goes through many stages or moving parts, that if one area of that cancels your token, it can be confusing or hard to work out what and where.\n\nYou\u0027d have to generally add separate logging statements around any functionality that cancels tokens if you want to know why and when that happened.\n\nThen, if you have consumers, it\u0027s even more complicated. Especially if you\u0027re throwing TaskCanceledExceptions, as you can\u0027t even return data that explains why then.\n\nCurrently, CancellationToken is sealed, so we are unable to build on top of it.\n\nBut I think it could be really useful if we could:\n- Cancel with a specific reason\n- Allow the cancellation token to throw custom types\n\nThe latter isn\u0027t really available to do nicely without use of reflection, due to language constraints, and this idea has led me to propose this on the csharp lang ideas discussion board: https://github.com/dotnet/csharplang/discussions/8542 \n\n\n## Reason\n\nSo specifying a reason at the time of cancellation easily lets us know why (and where in the code if we make our messages informative) we cancelled a token.\nThis would then naturally:\n- Flow through to logs automatically if global exception handling is set up\n- Be shown to consumers of code when thrown\n\n## Custom Throw-Type\nBy being able to throw custom types, this allows us to better define and control our exception handling logic. We could use logic based on string messages, but this can be incredibly flakey and be easily knocked out if any message formatting changes. \n\nBeing able to catch a specific type is a much more robust solution.\n\n### API Proposal\n\n## Reason\n\n```csharp\npublic class CancellationTokenSource\n{\n    public void Cancel(string reason);\n    public void Cancel(bool throwOnFirstException, string reason);\n    public void CancelAfter(int millisecondsDelay, string reason);\n    public void CancelAfter(TimeSpan delay, string reason);\n}\n```\n\n## Custom Throw-Type\n\n### Proposal 1 (Lacking language features)\n\n```csharp\npublic class CancellationTokenSource\n{\n    public void Cancel\u003cTException\u003e()\n        where TException : Exception;\n        where TException : new(string);\n\n    public void Cancel\u003cTException\u003e(bool throwOnFirstException)\n        where TException : Exception;\n        where TException : new(string);\n\n    public void CancelAfter\u003cTException\u003e(int millisecondsDelay);\n        where TException : Exception;\n        where TException : new(string);\n\n    public void CancelAfter\u003cTException\u003e(TimeSpan delay);\n        where TException : Exception;\n        where TException : new(string);\n}\n```\n\n### Proposal 2\n\n```csharp\npublic class CancellationTokenSource\n{\n    public void Cancel(Exception exception)\n    {\n        ...\n        throw exception;\n    }\n\n    public void Cancel(bool throwOnFirstException, Exception exception)\n    {\n        ...\n        throw exception;\n    }\n\n    public void CancelAfter(int millisecondsDelay, Exception exception);\n    {\n        ...\n        throw exception;\n    }\n\n    public void CancelAfter(TimeSpan delay, Exception exception);\n    {\n        ...\n        throw exception;\n    }\n}\n```\n\n### API Usage\n\n## Reason\n\n```csharp\nprivate readonly CancellationTokenSource _cancellationTokenSource;\n\npublic void SomeMethod()\n{\n    cancellationTokenSource.CancelAfter(TimeSpan.FromSeconds(30), \"The 30 second timeout for doing x was exceeded\");\n    cancellationTokenSource.Cancel(\"The 30 second timeout for doing x was exceeded\");\n}\n```\n\n## Custom Throw-Type\n\n### Proposal 1\n\n```csharp\npublic void SomeMethod(CancellationToken cancellationToken)\n{\n    cancellationToken.Cancel\u003cProcessXyzTimedOut\u003e();\n}\n\npublic void MethodWithCancellationToken(CancellationToken token)\n{\n    try\n    {\n        token.ThrowIfCancellationRequested(); // Could throw ExceptionX / ExceptionY / ExceptionZ\n    }\n    catch (ExceptionX exception)\n    {\n        // ExceptionX could represent we didn\u0027t really proceed anywhere with our request so we can just log and re-throw to fail the request\n        _logger.Log(exception);\n        throw;\n    }\n    catch (ExceptionY exception)\n    {\n        // ExceptionY could mean we got part way through a process, and so we might want to do some clean up or schedule something else to retry\n        await ScheduleRetryOnMessageBus(exception.Param1, exception.Param2);\n    }\n    catch (ExceptionX exception)\n    {\n        // ExceptionX could represent a non-mandatory process timed out, but doesn\u0027t really impact anything as it\u0027s just a \"nice-to-have\", so we can just log but not fail\n        _logger.Log(exception);\n    }\n}\n\n```\n\n### Proposal 2\n\n```csharp\npublic void SomeMethod(CancellationToken cancellationToken)\n{\n    cancellationToken.Cancel(new ProcessXyzTimedOut(\"Something timed out after 30 seconds\"))\n}\n```\n\n### Alternative Designs\n\n## Custom Throw-Type\n\n```csharp\n    public void Cancel(Func\u003cException\u003e exceptionFactory)\n    {\n        ...\n        throw exception();\n    }\n```\n\n\n### Risks\n\nCustom throw-types might mean existing code catch clauses wouldn\u0027t catch the exception types.\nYou could constraint them to have to inherit from `OperationCanceledException` or `TaskCanceledException` ?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOkjaPyg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6RX7Mo",
                                           "createdAt":  "2024-10-25T22:30:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "julealgon",
                                           "body":  "As someone who is _at this very moment_ focused on adding proper cancellation support to multiple APIs and background processes in our solution, I fully agree that being able to provide a reason for cancellation would really help.\n\nThe only way today to tell what happened is by catching the `OperationCancelledException` and then checking which of the various cancellation tokens has had cancellation requested on them, and then make a decision based on that.\n\nWe have something in place for that purpose today to differentiate cancellations due to client disconnects, vs cancellations due to server-side timeouts, in some legacy APIs where we then set different HTTP status codes: 499 for client-side disconnects, and 504 for server timeouts.\n\nI wouldn\u0027t necessarily inspect the `Reason` property on the exception to make the decision above (as making decisions based on `string` values is kinda bad), but it would make a ton of sense for when we also do a `logger.Information` call for each of the scenarios.",
                                           "updatedAt":  "2024-10-25T22:30:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6RYgxB",
                                           "createdAt":  "2024-10-26T01:00:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD95fiQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-12-06T15:57:04Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "\u003e CancellationToken is sealed\n\n`CancellationToken` cannot be inherited because it is a struct, but `CancellationTokenSource` is a class and not sealed. This might help you with implementing this on your own code.",
                                           "updatedAt":  "2024-10-26T01:00:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6RYhB0",
                                           "createdAt":  "2024-10-26T01:00:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-10-26T01:00:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6RYnR7",
                                           "createdAt":  "2024-10-26T01:12:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD4XsAg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-10-28T15:16:11Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "thomhurst",
                                           "body":  "\u003e \u003e CancellationToken is sealed\n\u003e \n\u003e `CancellationToken` cannot be inherited because it is a struct, but `CancellationTokenSource` is a class and not sealed. This might help you with implementing this on your own code.\n\nI don\u0027t think there\u0027s a way because we can\u0027t extend CancellationToken.\n\nWe can extend CTS - But what can we do with it? We can\u0027t pass reasons to the underlying cancellation token still.\n\nThere\u0027s no way for cancellation token to know about a reason when it calls `.ThrowIfCancellationRequested()`",
                                           "updatedAt":  "2024-10-26T01:12:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6RcCDj",
                                           "createdAt":  "2024-10-27T14:24:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "DrkWzrd",
                                           "body":  "@thomhurst Thinking about your last comment, you don\u0027t need to pass a reason to the token, The token itself is the reason (identifier). The simplest thing I can think is create something like a singleton `Dictionary\u003cCancellationToken, string\u003e` and handling the `Add` and `Remove` by yourself when you create a token and when you catch an operation cancellation. But if not handled correctly there be dragons in that thing.\n\nIf you work around it, you maybe could achieve to create a small system that check if the token has been cancelled and auto remove it from the dictionary.",
                                           "updatedAt":  "2024-10-27T14:24:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6RcCs7",
                                           "createdAt":  "2024-10-27T14:31:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "thomhurst",
                                           "body":  "Ideally I just want that when `ThrowIfCancellationRequested()` is called and throws, then the exception has a reason, or is a custom exception type.\n\nHaving to have dedicated catch logic everywhere to try and pull reasons out of some other stateful objects seems very messy. The caller shouldn\u0027t have to know about reasons imo ",
                                           "updatedAt":  "2024-10-27T14:31:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6RcK_g",
                                           "createdAt":  "2024-10-27T16:08:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  ".... If you\u0027re in control of all throws, can\u0027t you just check `IsCancellationRequested` and then throw whatever you want?\n\nNote that throwing an arbitrary exception from a token is probably a non-starter, since too much stuff would be expecting the existing base exception.  A subclass might work, though.",
                                           "updatedAt":  "2024-10-27T16:08:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6RcLc9",
                                           "createdAt":  "2024-10-27T16:14:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "thomhurst",
                                           "body":  "\u003e .... If you\u0027re in control of all throws, can\u0027t you just check `IsCancellationRequested` and then throw whatever you want?\n\u003e \n\u003e Note that throwing an arbitrary exception from a token is probably a non-starter, since too much stuff would be expecting the existing base exception. A subclass might work, though.\n\nBut if cancellation is requested, you don\u0027t know why. Because something else has cancelled it.",
                                           "updatedAt":  "2024-10-27T16:14:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Rcbi8",
                                           "createdAt":  "2024-10-27T19:36:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "... silly me, I was approaching it from the wrong direction.\n\nI guess the other workaround would be a single-element queue or lazy or something.",
                                           "updatedAt":  "2024-10-27T19:36:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6RjKaS",
                                           "createdAt":  "2024-10-28T15:29:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "colejohnson66",
                                           "body":  "\u003e \u003e .... If you\u0027re in control of all throws, can\u0027t you just check `IsCancellationRequested` and then throw whatever you want?\n\u003e \u003e Note that throwing an arbitrary exception from a token is probably a non-starter, since too much stuff would be expecting the existing base exception. A subclass might work, though.\n\u003e \n\u003e But if cancellation is requested, you don\u0027t know why. Because something else has cancelled it.\n\nYou could use reflection or `UnsafeAccessor` to extract the `_source` field (the owning `CancellationTokenSource`), but that\u0027s prone to breakage.\n\nhttps://github.com/dotnet/runtime/blob/efbb417ee1436a4e13c7dae106a095ca26bd531a/src/libraries/System.Private.CoreLib/src/System/Threading/CancellationToken.cs#L32-L35",
                                           "updatedAt":  "2024-10-28T15:29:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Rm9rT",
                                           "createdAt":  "2024-10-29T00:15:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD4lbjQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-10-29T11:57:20Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "julealgon",
                                                                               "createdAt":  "2024-10-29T14:32:52Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "omariom",
                                                                               "createdAt":  "2024-10-29T17:31:02Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "thomhurst",
                                           "body":  "\u003e \u003e \u003e .... If you\u0027re in control of all throws, can\u0027t you just check `IsCancellationRequested` and then throw whatever you want?\n\u003e \u003e \u003e Note that throwing an arbitrary exception from a token is probably a non-starter, since too much stuff would be expecting the existing base exception. A subclass might work, though.\n\u003e \u003e \n\u003e \u003e \n\u003e \u003e But if cancellation is requested, you don\u0027t know why. Because something else has cancelled it.\n\u003e \n\u003e You could use reflection or `UnsafeAccessor` to extract the `_source` field (the owning `CancellationTokenSource`), but that\u0027s prone to breakage.\n\u003e \n\u003e [runtime/src/libraries/System.Private.CoreLib/src/System/Threading/CancellationToken.cs](https://github.com/dotnet/runtime/blob/efbb417ee1436a4e13c7dae106a095ca26bd531a/src/libraries/System.Private.CoreLib/src/System/Threading/CancellationToken.cs#L32-L35)\n\u003e \n\u003e Lines 32 to 35 in [efbb417](/dotnet/runtime/commit/efbb417ee1436a4e13c7dae106a095ca26bd531a)\n\u003e \n\u003e  // The backing TokenSource. \n\u003e  // if null, it implicitly represents the same thing as new CancellationToken(false). \n\u003e  // When required, it will be instantiated to reflect this. \n\u003e  private readonly CancellationTokenSource? _source;\n\nYeah there isn\u0027t a way to do this without doing something hacky. This is why it\u0027d be a nice extension of cancellation token ",
                                           "updatedAt":  "2024-10-29T00:15:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6SNowY",
                                           "createdAt":  "2024-11-02T17:00:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "colejohnson66",
                                           "body":  "I, personally, don\u0027t like the idea of overriding the thrown exception - all cancellations should be `OperationCancelledException` for consistency. Perhaps some opaque \"state/reason\" object?\n\n```csharp\npublic class CancellationTokenSource\n{\n    public void Cancel(object? state);\n    public void Cancel(object? state, bool throwOnFirstException);\n    public void CancelAfter(int millisecondsDelay, object? state);\n    public void CancelAfter(TimeSpan delay, object? state);\n}\n\npublic class OperationCancelledException\n{\n    public object? State { get; init; }\n}\n```\n\nUsage would be either:\n\n```csharp\ntry\n{\n    await SomeOperation(token);\n}\ncatch (OperationCancelledException ex)\n    when (ex.State is CancelReasons.SomeReason)\n{\n    // process\n}\n// ...\n```\n\nHowever, this does not help `if (token.IsCancellationRequested) throw new OperationCancelledException();` code that surely exists. Alternatively, we could put the cancel \"state\" on the token itself, exposed as a property against the source:\n\n```csharp\npublic readonly struct CancellationToken\n{\n    public object? CancelState =\u003e _source._state;\n}\n```\n\n```csharp\ntry\n{\n    await SomeOperation(token);\n}\ncatch (OperationCancelledException ex)\n    when (token.CancelState is CancelReasons.SomeReason)\n{\n    // process\n}\n// ...\n```",
                                           "updatedAt":  "2024-11-02T17:09:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6SNo_K",
                                           "createdAt":  "2024-11-02T17:03:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "thomhurst",
                                           "body":  "\u003e I, personally, don\u0027t like the idea of overriding the thrown exception - all cancellations should be `OperationCancelledException` for consistency. Perhaps some opaque \"state/reason\" object?\n\u003e \n\u003e public class CancellationTokenSource\n\u003e {\n\u003e     public void Cancel(object? state);\n\u003e     public void Cancel(object? state, bool throwOnFirstException);\n\u003e     public void CancelAfter(int millisecondsDelay, object? state);\n\u003e     public void CancelAfter(TimeSpan delay, object? state);\n\u003e }\n\u003e \n\u003e public class OperationCancelledException\n\u003e {\n\u003e     public object? State { get; init; }\n\u003e }\n\u003e Usage would be:\n\u003e \n\u003e try\n\u003e {\n\u003e     await SomeOperation(token);\n\u003e }\n\u003e catch (OperationCancelledException ex)\n\u003e     when (ex.State is CancelReasons.SomeReason)\n\u003e {\n\u003e     // process\n\u003e }\n\u003e // ...\n\nTo be honest, I\u0027d be fine with that, just as long as there\u0027s some `Type` that can control catch logic rather than relying on the string message.",
                                           "updatedAt":  "2024-11-02T17:03:37Z"
                                       }
                                   ],
                         "totalCount":  13
                     },
        "title":  "[API Proposal]: CancellationTokens/CancellationTokenSources with reasons and/or custom exceptions",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/109343",
        "createdAt":  "2024-10-29T15:40:03Z",
        "number":  109343,
        "author":  "KrzysztofBranicki",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-01T06:32:43Z",
        "body":  "### Background and motivation\n\nI\u0027m implementing partitioned buffer for messages (retrieved from Kafka). Processing ordering needs to be guaranteed within partition so internally buffer holds dictionary of concurrent queues (one for each partition). I have one thread which is reading messages from Kafka and adding them to the buffer. Second thread is enqueuing message processing on the thread pool. I use `Channel\u003cT\u003e` for signaling available work on partition and `SemaphorSlim` for enforcing max buffer size. Method which enqueues message to a buffer uses `WaitAsync(ct)` and tasks which are processing messages use `Release()` when they finish processing, dequeue message and commit message offset. This works great, however max buffer size is expressed in terms of number of messages and it would be better if we are able to express it in bytes. I would be able to use same design if `WaitAsync` method accepted parameter `waitCount` so I\u0027m able to express how many bytes I\u0027m waiting for. The `Release` method already supports `releaseCount` parameter so no issues there.\n\n### API Proposal\n\n```csharp\npublic class SemaphoreSlim\n{\n    public Task WaitAsync(int waitCount)\n    public Task WaitAsync(int waitCount, CancellationToken cancellationToken)\n}\n```\nThose are just example signatures, other overloads (non async and accepting timeout should also get `waitCount` parameter for completenes.\n\n\n### API Usage\n\n```csharp\nprivate readonly SemaphoreSlim bufferSizeSemaphore = new (initialCount: maxBufferSizeBytes, maxCount: maxBufferSizeBytes);\n\nprivate readonly Channel\u003cConcurrentQueue\u003cMessageWrapper\u003e\u003e workSignallingChannel;\nprivate readonly Dictionary\u003cint, ConcurrentQueue\u003cMessageWrapper\u003e\u003e partitions;\n\npublic async Task EnqueueMessageForProcessingAsync(Message message, CancellationToken cancellationToken)\n{\n    await bufferSizeSemaphore.WaitAsync(message.SizeBytes, cancellationToken);\n   \n   var partition = partitions[message.Partition]\n   partition.Enqueue(new MessageWrapper(message));\n\n   if (!workSignallingChannel.Writer.TryWrite(partition))\n      throw new Exception(\"Failed to write to work signaling channel.\");\n   \n    ...\n}\n\n```\n\nAfter partition is signaled we use `TryPeek`, mark message as being processed and enqueue processing task on thread pool. After message is processed it will be dequeued and `bufferSizeSemaphore.Release(message.SizeBytes)` will be called.\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOkudLXA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6Rtm7h",
                                           "createdAt":  "2024-10-29T15:40:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-10-29T15:40:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6RvzTN",
                                           "createdAt":  "2024-10-29T20:07:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lilinus",
                                           "body":  "I think the suggested methods can be useful.\n\nAlthough they need to be named differently because there already exists overloads with exactly the same parameters (the int parameter is timeout in milliseconds).",
                                           "updatedAt":  "2024-10-29T20:07:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Ryv3R",
                                           "createdAt":  "2024-10-30T06:48:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KrzysztofBranicki",
                                           "body":  "@lilinus good point, alternative name could be `WaitMany` and `WaitManyAsync`.",
                                           "updatedAt":  "2024-10-30T06:48:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6SFhrt",
                                           "createdAt":  "2024-10-31T22:19:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jilles-sg",
                                           "body":  "`SemaphoreSlim` must work also for the case where multiple threads are calling `WaitAsync`. Consider a situation where the buffer is almost full (semaphore count very low) and lots of small messages are coming in and occasionally a big one. If messages are let through whenever there is space, the small messages will constantly take the last bit of space and it will take a long time before there will be enough space for a big message. To prevent this problem (known as starvation), the semaphore will need to store that a big message (wait with a large count) is pending and hold small messages (wait for 1 count) until the big message has gone through. This makes the semaphore more complex and slower for the existing use cases.\n\nMaking this worse is a behaviour of `SemaphoreSlim` to avoid lock convoying and improve throughput in general: if a thread is waiting synchronously when `Release` is called, `Release` will wake the thread but not hand over the count to it. So if another thread calls `Wait` or `WaitAsync` before the awakened thread continues running, that other thread will return immediately and the awakened thread might find a count of zero again. In the happy flow, the other thread will have released the semaphore again when the awakened thread gets its turn at the CPU and the context switch is complete, and the other thread has saved a lot of time without hurting the awakened thread. It is assumed that threads do not \"hold\" the semaphore for a long time.\n\nOn the other hand, if a task is waiting asynchronously, `Release` will hand over the count to it. Newly arriving `Wait` and `WaitAsync` callers must wait until the task completes.\n\nIn this specific case with only one flow calling `WaitAsync`, starvation is not an issue and I suggest hand-rolling something using `lock`, an integer storing the free buffer space and a `TaskCompletionSource` reference. Maybe add another integer to avoid waking the Kafka reader when there is no sufficient space yet.",
                                           "updatedAt":  "2024-10-31T22:19:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6S50tc",
                                           "createdAt":  "2024-11-08T12:24:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KrzysztofBranicki",
                                           "body":  "@jilles-sg thanks for your remarks. Regarding starvation issue I assumed that `Wait` would be satisfied in the FIFO order,  and not in the order of \"whichever waiter can be satisfied first based on the `waitCount` and `CurrentCount`\", this approach does not have the starvation issue but if that complicates the implementation to a point where base case (`waitCount == 1`) would take performance hit then there is no point in doing that as part of this component.",
                                           "updatedAt":  "2024-11-08T12:24:20Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "[API Proposal]: SemaphoreSlim.WaitAsync(int waitCount)",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/111102",
        "createdAt":  "2025-01-06T01:22:09Z",
        "number":  111102,
        "author":  "mriehm",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-25T21:25:57Z",
        "body":  "### Background and motivation\n\nThe ThreadPool can be inappropriately starved of threads if many ThreadPool threads block. The ideal solution to that problem is for applications to write async code to avoid blocking threads. However, sometimes it is impossible for applications to write async code because of a requirement to call a sync API that has no async equivalent.\n\nThe particular scenario that I am dealing with is that my ASP.NET app frequently opens handles to files on network storage. Sometimes, the network storage appliance does not open file handles in a timely manner, and so my thread pool threads become blocked for non-trivial amounts of time, which causes the ThreadPool to starve, which causes other requests to not be served in a timely manner. There is no way to open a file handle asynchronously, so I cannot solve this problem by switching to async code.\n\nIn .NET 6, PR https://github.com/dotnet/runtime/pull/53471 modified Task.Wait() to notify the ThreadPool that it is blocking a thread, which informs the ThreadPool to inject new threads more aggressively, My goal with this proposal is to enable application developers to similarly notify the ThreadPool of a thread blocking for reasons other than waiting on a Task.\n\n### API Proposal\n\n```csharp\nnamespace System.Threading;\n\npublic static partial class ThreadPool\n{\n    public static ThreadBlockedScope NotifyThreadBlocked();\n}\n\npublic ref struct ThreadBlockedScope : IDisposable\n{\n    public void Dispose();\n}\n```\n\nThe NotifyThreadBlocked() method is modeled after the existing internal method of the same name, but it returns a new ThreadBlockedScope ref struct that notifies the runtime of thread unblock when it is disposed, whereas the pre-existing internal method returns a bool that indicates whether a separate NotifyThreadUnblocked() method should be called upon unblock.\nThis aspect of the proposal exists to protect against potential misuse that could occur if the existing internal methods were exposed directly, such as erroneous additional or missing calls to NotifyThreadUnblocked().\n\nCalling NotifyThreadBlocked() will be taken to indicate that the current thread is about to block, as opposed to incrementing a process-wide counter of the number of threads blocked. This means that nested calls on the same thread will be ignored, which is a valuable behavior to allow future .NET versions to decide to add calls to NotifyThreadBlocked() within an existing APIs (e.g., Thread.Sleep()) without concern that the blocked thread will be double counted due to application code already calling NotifyThreadBlocked() before calling that existing API. Since ThreadBlockedScope is a ref struct, disposal is guaranteed to occur on the same thread that called NotifyThreadBlocked(), similar to the recently introduced Lock.Scope type.\n\n### API Usage\n\n```csharp\npublic SafeFileHandle OpenNetworkFile(string networkFilePath)\n{\n    using (ThreadBlockedScope blockScope = ThreadPool.NotifyThreadBlocked())\n    {\n        return NativeMethods.CreateFileW(networkFilePath, ...);\n    }\n}\n```\n\nThis example uses a call to the Win32 API [CreateFileW()](https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew) to open a file handle instead of using File.OpenHandle() to open a file handle. I wrote the example this way to sidestep any discussion about whether the problem is better solved by having File.OpenHandle() internally call the existing internal ThreadPool APIs. For the record, I think that File.OpenHandle() probably shouldn\u0027t call them, since most files opened by .NET applications in general are not in network storage, so making every caller pay the overhead of notifying the thread pool may not be worth it. Regardless, my ASP.NET app uses native code to open the handle to the network file, so modifying File.OpenHandle() to call the existing internal ThreadPool APIs would not solve my problem.\n\n### Alternative Designs\n\n1. As discussed above, relevant .NET runtime APIs such as File.OpenHandle() or Thread.Sleep() could be modified to call the existing internal ThreadPool APIs instead of exposing the ThreadPool APIs publicly for applications to call. However, this does not solve my case of opening a file handle via native code unless LibraryImportAttribute is enhanced to support calling these APIs, which I\u0027m guessing would an undesirable entanglement of layers. Also, it\u0027s not clear that the .NET runtime can always determine when its APIs, such as File.OpenHandle(), are sufficiently likely to block to justify notifying the ThreadPool that the thread is potentially blocking.\n\n2. Instead of depending on apps to manually indicate with these new ThreadPool APIs that a thread is about to block, perhaps there is some way to solve thread exhaustion with changes internal to the ThreadPool thread injection algorithm, such as with automated detection of blocked threads. I don\u0027t have any practical suggestion about how this could be accomplished, though.\n\n3. For my particular concern about opening files always being synchronous, perhaps it is possible to open files asynchronously on Linux with io_uring. My ASP.NET app runs on Windows, though, where I believe asynchronous file opens to be impossible. Maybe the Windows team could be contacted to request this feature though :).\n\n### Risks\n\n1. For some ThreadPool implementations, there may be no useful implementation for these APIs, such as when the native Windows thread pool is used. Therefore, use of these APIs may increase behavioral differences between the same application running under different deployment scenarios, or different versions of .NET as ThreadPool implementations are modified. This does not seem a significant concern because the APIs are only performance hints, not guaranteeing specific behavior. Also, the behavioral differences have already been introduced via Task.Wait() in .NET 6+.\n\n2. It may be unclear to application developers when it is or isn\u0027t beneficial for them to call ThreadPool.NotifyThreadBlocked(). For example, Task.Wait() already calls it internally, so applications do not need to call it in that case, but the only way to know that is to read the .NET runtime source code. This could be mitigated with docs for ThreadPool.NotifyThreadBlocked() that list all the runtime APIs that already call it internally, if that list remains sufficiently small. In any case, the impact of an application adding erroneous additional calls to these APIs is probably not significant.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOp9IykQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6ZS0Si",
                                           "createdAt":  "2025-01-06T01:22:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-01-06T01:22:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ZWG_E",
                                           "createdAt":  "2025-01-06T09:30:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEBKhAw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2025-01-06T11:43:18Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "filipnavara",
                                           "body":  "(I\u0027ll refrain from addressing the big questions.)\n\nFor the API shape I think it would be preferrable to go with something more robust like the alternative design 2 with disposable `ref struct`. The original API is too easy to misuse.",
                                           "updatedAt":  "2025-01-06T09:30:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6bJ7aZ",
                                           "createdAt":  "2025-01-20T18:51:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mriehm",
                                           "body":  "Thanks for the feedback @filipnavara. I agree that the design with the ThreadBlockedScope ref struct is better overall, so I have edited the proposal now to describe that as the primary design.\n\n@kouvel Do you have an opinion on this proposal?",
                                           "updatedAt":  "2025-01-20T18:51:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6bcgCx",
                                           "createdAt":  "2025-01-22T18:14:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "An option may be to dedicate one thread to handle network file open requests in sequence. Regular threads could queue up a file open request in an async way and await it, and the dedicated thread can do the opening synchronously in sequence, indicating completion for each by queuing up the continuation to the thread pool. There may be some downsides to this, but it may work reasonably enough.\n\nWhat about copies:\n```c#\nusing (ThreadBlockedScope blockScope = ThreadPool.NotifyThreadBlocked())\n{\n    using (ThreadBlockedScope blockScope2 = blockScope) { }\n}\n```\n\nShould the outer Dispose throw? It would be awkward for the thread to be marked unblocked while still inside the outer scope, so maybe an exception would be good.\n\nWhat about nesting:\n```c#\nusing (ThreadPool.NotifyThreadBlocked())\n{\n    using (ThreadPool.NotifyThreadBlocked()) { }\n}\n```\n\nThe implementation could keep track of this and make it work, or the inner call could throw, but would be good to clarify.",
                                           "updatedAt":  "2025-01-22T18:15:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6bmbnc",
                                           "createdAt":  "2025-01-23T17:40:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mriehm",
                                           "body":  "\u003e An option may be to dedicate one thread to handle network file open requests in sequence.\n\nI wouldn\u0027t be comfortable with serializing all network file open requests to a single thread, since that means the delay of opening any single file causes delay opening all files behind it. We\u0027ve experienced scenarios where network storage appliances have drive failures such that trying to open files that happen to be located on the failed drives will just hang for some timeout period before returning an error, but other files not located on those failed drives can be opened quickly/successfully.\n\nTo give more context to my scenario, my ASP.NET app is part of a product that my company sells. So, the network storage I refer to are the various storage appliances owned and managed by our customers, not something my company can control or monitor directly. We sometimes get support requests that my ASP.NET app is unresponsive, and we find that some network file opens are being slow or sometimes even hung completely until timing out, which can starve the thread pool even from processing unrelated requests. In such cases, we currently tell the customer that we can\u0027t do anything and they should contact the support of their network storage vendor to solve the issue. Overall, this is not a highly common or impactful issue for my company, but it is a recurring pattern seen in support requests over time, and it would be ideal if we could make changes to our code that would mitigate the impact.\n\nI have considered that we could push file opens to a _pool_ of threads that we can expand as we need it to, but that seems like basically reinventing the whole .NET ThreadPool just so that we can implement our own equivalent of NotifyThreadBlocked(). From my perspective, ThreadPool.NotifyThreadBlocked() already exists internally in the .NET runtime, so it seemed worthwhile to request if it could be exposed publicly before considering pursuing a custom thread pool implementation.\n\n\u003e What about copies\n\u003e What about nesting\n\nFor nesting, I think it should be supported, but the inner nested call to NotifyThreadBlocked() should only increment a thread-local nesting count, not actually notify the thread pool again. If nesting were to throw, then any .NET runtime APIs that didn\u0027t call NotifyThreadBlocked() in .NET 10 would never be able to call NotifyThreadBlocked() in a future .NET version because the API could potentially already be inside a NotifyThreadBlocked() scope activated by the caller.\n\nFor copies, I agree that the outer Dispose() should throw. To be clear, ThreadBlockedScope.Dispose() would throw if the thread-local nesting count was already at zero, and due to potential nesting of NotifyThreadBlocked() and because NotifyThreadBlocked() presumably will not assign a unique identity to each ThreadBlockedScope, that throw might occur on Dispose() of an outer ThreadBlockScope that was not copied instead of Dispose() of an inner ThreadBlockScope that was copied.\n\nNote that both of those behaviors are consistent with the behavior of Lock.Scope.\n\n\n",
                                           "updatedAt":  "2025-01-23T17:40:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dQhi6",
                                           "createdAt":  "2025-02-06T00:45:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "\u003e I wouldn\u0027t be comfortable with serializing all network file open requests to a single thread\n\u003e I have considered that we could push file opens to a _pool_ of threads that we can expand as we need it to, but that seems like basically reinventing the whole .NET ThreadPool just so that we can implement our own equivalent of NotifyThreadBlocked(). From my perspective, ThreadPool.NotifyThreadBlocked() already exists internally in the .NET runtime, so it seemed worthwhile to request if it could be exposed publicly before considering pursuing a custom thread pool implementation.\n\nThe .NET thread pool\u0027s cooperative blocking mechanism is intended mainly as a workaround for something that shouldn\u0027t be happening on thread pool threads and is difficult to fix. For instance, the rate of thread injection in response to cooperative blocking is not unbounded and is ramped down with increasing number of active threads. Using this API would be at best a workaround to the problem. Configuring cooperative blocking to inject threads more aggressively may enable working around the problem for longer, but at some point it would likely start hitting various tradeoffs. If several components in a process use the API, configuring cooperative blocking to overcome issues would become complicated, because each component should have its own limits on what level of concurrency of its blocking operations it expects to support. The API would have to be clearly documented as such to help avoid misuse/overuse.\n\nIn your scenario, in my opinion, offloading that work from the .NET thread pool would be a better and more complete solution. I don\u0027t think it would be too difficult to create a purpose-oriented thread pool that tackles a maximum of `N` concurrent file-opens, where N may be configurable.\n\nRegarding a more generic solution, maybe it would be interesting to introduce a type that can be instantiated with the `N`, and which can create/reuse/share thread pool threads specifically for blocking work but without affecting the thread pool\u0027s worker threads, for async-over-sync use cases like this.",
                                           "updatedAt":  "2025-02-06T00:45:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6n0jKR",
                                           "createdAt":  "2025-04-18T14:38:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "RobinsonWM",
                                           "body":  "I just wanted to note that I ran into an issue that may share a similar fix. It was a high-throughput application running on a 2-core machine. All the I/O was async, and the ThreadPool would often go down to 3 threads with no problems. But I was experiencing sporadic freezes that lasted 5-10 seconds.  When the application would unfreeze, the thread count would be higher, suggesting the ThreadPool resolved the freeze by adding threads. I got a memory dump during one of the freezes and found multiple ThreadPool threads with this stack trace:\n```no-highlight\n[InlinedCallFrame]\n[InlinedCallFrame]\nInterop+Sys.GetHostEntryForName(System.String, System.Net.Sockets.AddressFamily, HostEntry*)\nSystem.Net.NameResolutionPal.TryGetAddrInfo(System.String, Boolean, System.Net.Sockets.AddressFamily, System.String ByRef, System.String[] ByRef, System.Net.IPAddress[] ByRef, Int32 ByRef)\nSystem.Net.Dns.GetHostEntryOrAddressesCore(System.String, Boolean, System.Net.Sockets.AddressFamily, System.Nullable`1)\nSystem.Net.Dns+\u003c\u003ec.b__33_0(System.Object, System.Net.NameResolutionActivity)\nSystem.Net.Dns+\u003c\u003ec__DisplayClass39_0`1[[System.__Canon, System.Private.CoreLib]].b__0(System.Threading.Tasks.Task, System.Object)\nSystem.Threading.Tasks.ContinuationResultTaskFromTask`1[[System.__Canon, System.Private.CoreLib]].InnerInvoke()\nSystem.Threading.ExecutionContext.RunFromThreadPoolDispatchLoop(System.Threading.Thread, System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)\nSystem.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef, System.Threading.Thread)\nSystem.Threading.ThreadPoolWorkQueue.Dispatch()\nSystem.Threading.PortableThreadPool+WorkerThread.WorkerThreadStart()\n[DebuggerU2MCatchHandlerFrame]\n```\nDNS lookups on Linux are synchronous; even if you call `Dns.GetHostAddressesAsync()`, it will block a thread (just not the thread that called it.) It seems this issue would have been mitigated if the Linux implementation of `GetHostEntryForName()` were able to notify the ThreadPool that it\u0027s going to block a thread.",
                                           "updatedAt":  "2025-04-18T14:38:47Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "[API Proposal]: Expose ThreadPool.NotifyThreadBlocked()",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/111173",
        "createdAt":  "2025-01-07T19:16:41Z",
        "number":  111173,
        "author":  "vsfeedback",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC-QHPw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "HighPerfDotNet",
                                            "createdAt":  "2025-01-08T07:16:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2025-01-08T16:25:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MineCake147E",
                                            "createdAt":  "2025-01-13T03:51:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dellamonica",
                                            "createdAt":  "2025-01-18T00:37:13Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2025-07-01T17:02:01Z",
        "body":  "_This issue has been moved from [a ticket on Developer Community](https://developercommunity.visualstudio.com/t/C-EnvironmentPhysicalCoreCount/10804000)._\n\n---\nCurrently, Environment.ProcessorCount provides the total number of logical threads, which has been useful in processors leveraging technologies like SMT (Simultaneous Multithreading). However, this approach has limitations because, in SMT configurations, only one thread per core is truly executed simultaneously, while the second thread is only used when the first thread is idle. This can lead to worse performance in intensive parallel loops (such as those using native memory and pointers) when attempting to use all logical threads without effectively leveraging hardware resources.\n\nUntil now, dividing Environment.ProcessorCount by 2 was a common practice to estimate the number of physical cores. However, this solution is no longer valid with newer processors that do not implement SMT, such as some recent Intel and Apple models. In these cases, continuing to divide by 2 would result in a significant waste of resources by ignoring half of the available physical cores.\n\nFor this reason, it is crucial for C# to offer a native API to directly retrieve the number of physical cores, something like Environment.PhysicalCoreCount. This would avoid the current limitations and ensure a reliable, cross-platform, and native way to access this information without relying on operating system calls.\n\nAdditionally, it is important to revisit how C# parallel loops handle scenarios on heterogeneous processors, i.e., those combining high-performance cores (P-cores) and high-efficiency cores (E-cores), as seen in modern hybrid architectures. In such cases, the performance of parallel loops can degrade significantly if the unequal performance of the cores is not accounted for. A potential solution could involve dynamically adjusting the workload based on the relative performance of each core.\n\nThese improvements would not only benefit high-performance scenarios but also simplify the development of applications that need to optimally utilize underlying hardware in modern and heterogeneous configurations.\n\n---\n### Original Comments\n\n#### Feedback Bot on 12/2/2024, 09:22 PM: \n\n\u003cp\u003eThank you for taking the time to provide your suggestion. We will do some preliminary checks to make sure we can proceed further. You will hear from us in about a week on our next steps.\u003c/p\u003e\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOmYvs0Q==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6Zi-zR",
                                           "createdAt":  "2025-01-07T19:37:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-01-07T19:37:45Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "C#, Environment.PhysicalCoreCount",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/111266",
        "createdAt":  "2025-01-10T08:33:51Z",
        "number":  111266,
        "author":  "idg10",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC_8PZg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "filipnavara",
                                            "createdAt":  "2025-01-10T21:50:03Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Genmutant",
                                            "createdAt":  "2025-01-11T19:49:18Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rickbrew",
                                            "createdAt":  "2025-01-18T18:29:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "geniuszxy",
                                            "createdAt":  "2025-03-11T12:35:21Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2025-07-01T19:29:16Z",
        "body":  "### Background and motivation\n\nThe `Lock.Scope` type is (according to the API design review session for `Lock`) intended to \"play nicely with language constructs\". But it doesn\u0027t work in F# because the `use` keyword in F# requires types to implement `IDisposable`. (It works fine in C# because when it comes to a `ref struct`, C#\u0027s `using` will accept any method called `Dispose` whether or not it\u0027s part of an `IDisposable` implementation. But since C# offers intrinsic support for `Lock`, the fact that you can also use it via `using` isn\u0027t particularly useful.)\n\nNote this is **not** a request to make `Lock` itself disposable. This is about `Lock.Scope`.\n\nEarly design proposals for `Lock.Scope` had it implement `IDiposable`. As far as I can tell, this interface was dropped when `Lock.Scope` was turned into a `ref struct` back in 2023. At the time, `ref struct` types were not allowed to implement interfaces, so it would have been necessary to remove the `IDisposable` interface at that time.\n\nHowever, `Lock` didn\u0027t ship until .NET 9.0, by which time the CLR and C# 13 _did_ allow `ref struct` types to implement interfaces.\n\nMaking `Lock.Scope` implement `IDisposable` wouldn\u0027t affect any existing users: code already calling `Dispose` directly today would continue to work. But it would enable F# code to use `Lock.Scope` through its `use` statement. (It _wouldn\u0027t_ work for F#\u0027s `using` because that doesn\u0027t work with `ref struct` types. `use` is happy to use a `ref struct` though.)\n\n### API Proposal\n\nThe nested `Lock.Scope` type exists today, and it is a `ref struct` that does not implement any interfaces:\n\n```csharp\nnamespace System.Threading;\n\npublic sealed partial class Lock\n{\n    ...\n    public ref struct Scope\n    {\n        ...\n    }\n}\n```\n\nThe change would be to declare that it implements `IDisposable`:\n\n```csharp\nnamespace System.Threading;\n\npublic sealed partial class Lock\n{\n    ...\n    public ref struct Scope : IDisposable\n    {\n        ...\n    }\n}\n```\n\nScope already defines a suitable `Dispose` method, so there is no need to add any new code other than this one line change.\n\n### API Usage\n\nThis code, which does not work today in F#:\n\n```fsharp\nlet myLock = new System.Threading.Lock()\n\nlet f =\n    use _ = Lock.EnterScope(myLock)\n    printfn \"Hello from use\"\n```\n\nwould work after this change.\n\nThis is according to the discussion in the [original design review of the `Lock` API](https://youtu.be/sPkVcPeFeis?t=2837), precisely what `Lock.Scope` is meant for. As Immo said in that meeting:\n\n\u003e the only reason Scope exists it to play nicely with language constructs\n\nToday, it fails to achieve this for F#. It succeeds in C# but since C# added intrinsic support for `Lock` in the same release that `Lock` first became available, that\u0027s not much use. (In the original design review, the .NET team thought there was a high chance that C# would not provide this intrinsic support, at which point the design they came up with would have been more useful because it would have provided C# support that would otherwise have been missing.)\n\n### Alternative Designs\n\nThe alternative is to leave the API unchanged. The F# team could provide intrinsic support themselves.\n\n### Risks\n\nIt would be possible to write code today that checked via reflection whether `Lock.Scope` implements `IDisposable`, and which deliberately breaks if it does, so technically this could be considered a breaking change, but this is a far fetched scenario.\n\nThis does rely on the JIT not changing its behaviour just because the `Dispose` method is now part of an interface.\n\n(Note that this does _not_ create a risk of the `Lock.Scope` being boxed, because it continues to be a `ref struct`, and you can\u0027t box those.)",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOtFG_pw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6Z5xxm",
                                           "createdAt":  "2025-01-10T08:36:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-01-10T08:36:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6apmSd",
                                           "createdAt":  "2025-01-16T05:55:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEJXxug==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "geniuszxy",
                                                                               "createdAt":  "2025-03-11T12:35:37Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e It works fine in C# because C#\u0027s using will accept any method called Dispose whether or not it\u0027s part of an IDisposable implementation.\n\nThis isn\u0027t true. It must be a `ref struct`. Types of `class` and `struct` must implement `IDisposable`. \n\n[SharpLab](https://sharplab.io/#v2:EYLgtghglgdgNAFxFANgHwAICYCMBYAKEIwAYACAChgFMB3MgQQoEpnCBvQgX0OPKrpkAQizYFOBHkQKlKNegGFRHbrxkBmMtkZkJZfVs0YALGQAiUAM4AHAPaXqLXYQNkpU4pssIATgFcAYwRhZwJXDCNTCxt7R2ZQ13c1CLIfagAzMm9/ILIFBIMUk3MrOwcnPQN3IA===)\n\nDoesn\u0027t really change the request, but it seems like `ref struct` has been special cased. I wish it would do what you\u0027re saying, but I recall there being some reason related to `IEnumerable`.\n\n/cc @jaredpar  ",
                                           "updatedAt":  "2025-01-16T05:55:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6k6E2Q",
                                           "createdAt":  "2025-03-31T16:02:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "idg10",
                                           "body":  "Sorry, I should have qualified that the \"will accept any method called Dispose\" only applies when the type is a `ref struct`.\n\n\u003e it seems like `ref struct` has been special cased.\n\nI assume this is because when `ref struct` first appeared, types of this kind weren\u0027t allowed to implement `IDisposable`, so the only way `using` could possibly work for a `ref struct` would be if it accepted any no-args method called `Dispose`.",
                                           "updatedAt":  "2025-03-31T16:02:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc60Ub-n",
                                           "createdAt":  "2025-07-01T19:29:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEZcz4A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tannergooding",
                                                                               "createdAt":  "2025-07-01T23:24:06Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2025-07-05T15:38:17Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e The alternative is to leave the API unchanged. The F# team could provide intrinsic support themselves.\n\nDoes it mean that F# would behave same way as C# wrt ref structs and Dispose? It seems preferable solution to me. ",
                                           "updatedAt":  "2025-07-01T19:29:16Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "[API Proposal]: Consider implementing IDisposable on Lock.Scope",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/112131",
        "createdAt":  "2025-02-04T16:32:36Z",
        "number":  112131,
        "author":  "jkotas",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-14T20:39:43Z",
        "body":  "\u003e Can we detect an attempt to re-initialize the runtime thread object and abort immediately to make this issue easier to diagnose next time?\n\u003e \n\u003e I can look into that. Need to check, but we may need to store the already-destructed info in pthread thread-specific data, as there were some reports that there may be issues with using `thread_local` vars on macOS after they have been destroyed. \n\n _Originally posted by @kouvel in [#110442](https://github.com/dotnet/runtime/issues/110442#issuecomment-2620656175)_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOoN_NOw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6dByHR",
                                           "createdAt":  "2025-02-04T16:33:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-02-04T16:33:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6g3807",
                                           "createdAt":  "2025-03-04T21:51:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "On macOS, it looks like accessing a `thread_local` var from a pthread thread-specific data destructor leads to the `thread_local` var being reinitialized (data is zerored / constructor is called again, and the destructor is not called again), so storing info there about the Thread already being cleaned up would not detect the issue.\n\nOn Linux, in the same case accessing the `thread_local` var seemingly treats it as a new construction, but without running the constructor or zeroing the data, and the destructor is called a second time some time after the pthread thread-specific data destructor.\n\nBased on the glibc docs it seems unsafe to use `thread_local` vars in pthread thread-specific data destructors. So, probably we would need to use pthread thread-specific data to store the info that the Thread has already been cleaned up.",
                                           "updatedAt":  "2025-03-04T21:53:47Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Detect an attempt to re-initialize the runtime thread object and abort immediately",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/112299",
        "createdAt":  "2025-02-08T07:32:17Z",
        "number":  112299,
        "author":  "vityaman",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-02-10T16:23:59Z",
        "body":  "### Description\n\nSeems to be a concurrency bug.\n\n### Reproduction Steps\n\n1. Build a DotNET SDK for a RISC-V\n2. Create an executable program for C# with the following code in Main body\n\n```cs\nfor (int i = 0; i \u003c 900_000; i++) {\n   using var task = new Task(() =\u003e { });\n   task.Start();\n   task.Wait();\n}\n```\n\n3. Run the program on the Banana Pie K1 8 cores hardware\n\n### Expected behavior\n\nSuccessful completion of the program.\n\n### Actual behavior\n\nAn exception\n\n```cs\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\n   at System.Threading.LowLevelSpinWaiter.Wait(Int32 spinIndex, Int32 sleep0Threshold, Boolean isSingleProcessor)\n   at System.Threading.LowLevelLifoSemaphore.Wait(Int32 timeoutMs, Boolean spinWait)\n   at System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart()\n```\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n- Run the program on the hardware LicheePi4A\n\n### Configuration\n\n- .NET v9.0.1\n- Debian 11\n- RISC-V\n- Hardware: Banana Pie K1 8 cores\n\n### Other information\n\nOther reproducer:\n\n```cs\nfor (long i = 0; i \u003c 7000; ++i) \n  Parallel.For(0, 10, j =\u003e {});\n```\n\nAn exception:\n\n```cs\nUnhandled exception. System.AggregateException: One or more errors occurred. (Object reference not set to an instance of an object.)\n ---\u003e System.NullReferenceException: Object reference not set to an instance of an object.\n   at System.Threading.Tasks.Task.InnerInvoke()\n   at System.Threading.ExecutionContext.RunFromThreadPoolDispatchLoop(Thread threadPoolThread, ExecutionContext executionContext, ContextCallback callback, Object state)\n--- End of stack trace from previous location ---\n   at System.Threading.ExecutionContext.RunFromThreadPoolDispatchLoop(Thread threadPoolThread, ExecutionContext executionContext, ContextCallback callback, Object state)\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\n   --- End of inner exception stack trace ---\n   at System.Threading.Tasks.Task.ThrowIfExceptional(Boolean includeTaskCanceledExceptions)\n   at System.Threading.Tasks.Task.Wait(Int32 millisecondsTimeout, CancellationToken cancellationToken)\n   at System.Threading.Tasks.Task.Wait()\n   at System.Threading.Tasks.TaskReplicator.Run[TState](ReplicatableUserAction`1 action, ParallelOptions options, Boolean stopOnFirstFailure)\n   at System.Threading.Tasks.Parallel.ForWorker[TLocal,TInt](TInt fromInclusive, TInt toExclusive, ParallelOptions parallelOptions, Action`1 body, Action`2 bodyWithState, Func`4 bodyWithLocal, Func`1 localInit, Action`1 localFinally)\n--- End of stack trace from previous location ---\n   at System.Threading.Tasks.Parallel.ForWorker[TLocal,TInt](TInt fromInclusive, TInt toExclusive, ParallelOptions parallelOptions, Action`1 body, Action`2 bodyWithState, Func`4 bodyWithLocal, Func`1 localInit, Action`1 localFinally)\n   at System.Threading.Tasks.Parallel.For(Int32 fromInclusive, Int32 toExclusive, Action`1 body)\n   at Program.TestParallelForLoop() in /home/student3/sandbox/Program.cs:line 57\n   at Program.RunRepeating(String name, Action action) in /home/student3/sandbox/Program.cs:line 50\n   at Program.Main(String[] args) in /home/student3/sandbox/Program.cs:line 34\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOnaZibQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6doNgv",
                                           "createdAt":  "2025-02-08T07:32:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-02-08T07:32:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6doXxt",
                                           "createdAt":  "2025-02-08T07:48:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "cc @dotnet/samsung ",
                                           "updatedAt":  "2025-02-08T07:48:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dpmJt",
                                           "createdAt":  "2025-02-08T10:58:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tomeksowi",
                                           "body":  "I\u0027ll try to repeat when my Banana Pi arrives.\n\n\u003e .NET v9.0.1\n\nI fixed a number of GC bugs since then, \"NullReferenceException: Object reference not set\" was one of the symptoms of #109512.\n\nDoes it reproduce on the main branch?",
                                           "updatedAt":  "2025-02-08T10:58:00Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Bug in Task Parallel Library on RISC-V Banana Pie K1 8 cores",
        "labels":  [
                       "area-System.Threading",
                       "arch-riscv"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/112608",
        "createdAt":  "2025-02-16T00:45:06Z",
        "number":  112608,
        "author":  "HighPerfDotNet",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODO3V8w==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Greg-Smulko",
                                            "createdAt":  "2025-06-18T12:42:57Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hendriklhf",
                                            "createdAt":  "2025-09-07T01:17:39Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2025-09-17T18:09:44Z",
        "body":  "I\u0027ve been doing some profiling and run into what appears to be the issue described here - \nhttps://github.com/dotnet/runtime/issues/108057 - that thread is closed to comments, so I felt compelled to open a new one because it seems that the fix is in but it appears to be for .NET 10 only?\n\nThis takes a lot more CPU cycles than it should be in a mild scenario of just 30 active threads -\n\n![Image](https://github.com/user-attachments/assets/25f72aa5-3246-4da0-8d0b-2cabdcbb7e49)\n\nCan the fix get backported to .NET 8 since it is current LTS and .NET 10 isn\u0027t due for a fairly long time? \n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOxPAJJg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6enjXW",
                                           "createdAt":  "2025-02-16T00:45:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-02-16T00:45:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6enuG1",
                                           "createdAt":  "2025-02-16T03:08:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEGfiIA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2025-02-16T07:08:22Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "Could you share what the level of impact is for your deployments?",
                                           "updatedAt":  "2025-02-16T03:08:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6epDGU",
                                           "createdAt":  "2025-02-16T18:33:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "HighPerfDotNet",
                                           "body":  "First off, thank you for your attention spent on this, especially over the weekend, I\u0027ll try to be brief:\n\nImpact on our software is high - it\u0027s designed to be deployed in large quantities so we use NativeAOT to minimize memory usage and have rewritten a lot of old code to use modern stuff like Spans. CPU usage is also one of the limits and this is where this problem affects us: in screenshots at the bottom you can see that profiling shows when we use 30 workers (those are not separate threads on their own - they are basically state machines managed by the main thread) that use library functions that in turn rely on ThreadPool it takes **34%** in that alone, and when workers increased to 300 the ratio goes even higher - over **40%**! \n\nAs much as it is important to us I would not want to make an argument just about that, because nobody can expect you to fix things on that basis, however there are in my view very strong arguments why the fix should be backported to .NET 8 -\n\n1) ThreadPool is very much fundamental piece as it is used by lots of library functions: _\"Task Parallel Library (TPL) operations, asynchronous I/O completion, timer callbacks, registered wait operations, asynchronous method calls using delegates, and System.Net socket connections\"_ (quoting from Google) - this covers possibly all deployments out there: there is good potential to save a LOT of CPU out there: this directly translates into monetary savings.\n\n2) The problem gets worse with more threads, which is unsurprising as it appears to be due to lock contention which will get even worse with more threads, this isn\u0027t just big but predictable linear CPU overhead - it can result in spiky behavior under load that is highly undesirable and hard to debug in the field, I\u0027d expect this problem to become even worse on a heavily loaded machine which it should be expected to run on.\n\n3) The fix appears to be ready and approved for .NET 10, however it won\u0027t be officially released for a long time and current LTS is .NET 8 - a lot of companies would prefer to skip odd versions, so even backporting this to .NET 9 isn\u0027t ideal solution. In my view end user benefits overweight risks and time of doing backport.\n\n4) (removed lots of rambling after checking PR for the fix - it moves setting of the thread name once when thread is created, rather than every time it was started - CPU overheads become immaterial after that)\n\nScreenshots obtained by using VS 2022 Perf Profiler using \"CPU Usage\" option.\n\nUsing 30 our workers (they are not directly using ThreadPool threads - our workers are state machines that use async library functions that in turn rely on ThreadPool for callbacks) - \n![Image](https://github.com/user-attachments/assets/1e664a6a-3c71-4ac5-b1db-3a2d3e7ed3f3)\n\nWith 300 workers - you can see here that top functions more or less the same, our main code is even doing more work processing data, but even in that case the ratio of ThreadPool gone up to 40% overall - \n\n![Image](https://github.com/user-attachments/assets/03544e31-93fa-412e-9a26-16f9c3daba71)\n\nThe culprit is Thread.SetThreadPoolWorkerThreadName \n\n![Image](https://github.com/user-attachments/assets/d4ddb912-7ea9-4855-9421-8b7a230a38b7)",
                                           "updatedAt":  "2025-02-16T19:01:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6e2se3",
                                           "createdAt":  "2025-02-18T09:58:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "\u003e it moves setting of the thread name once when thread is created, rather than every time it was started\n\nIn .NET 8.0.0, CreateWorkerThread() calls `workerThread.UnsafeStart()`, which indirectly calls Thread.StartCore, which locks the new thread and calls Thread.StartInternal.  The new thread then starts running PortableThreadPool.WorkerThread.WorkerThreadStart(), which calls `Thread.CurrentThread.SetThreadPoolWorkerThreadName()`, which locks the new thread again.  If Thread.StartCore has not yet released its lock, this causes lock contention.\n\n\u003chttps://github.com/dotnet/runtime/pull/108135\u003e fixed the lock contention by making CreateWorkerThread() call `workerThread.SetThreadPoolWorkerThreadName()`.  At that point, Thread.StartCore has not yet been entered and has not locked the new thread, so there is no contention.\n\nThe PR did not change how many times SetThreadPoolWorkerThreadName is called.  The thread is started only once, immediately after it is created.\n\nCan you try profiling your application with a [daily build](https://github.com/dotnet/runtime/blob/main/docs/project/dogfooding.md) of .NET 10?  The links on that page point to NET 9 but it seems one can replace `9.0` with `10.0` in the URL.  If SetThreadPoolWorkerThreadName still takes too much CPU time there, then backporting this change will not suffice.",
                                           "updatedAt":  "2025-02-18T09:59:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7E8Akm",
                                           "createdAt":  "2025-09-17T18:09:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "alasdaircs",
                                           "body":  "My numbers in dotnet 9.0.9 are even worse, probable because of the way we schedule a lot of small tasks.\n\n\u003cimg width=\"1679\" height=\"583\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/6cc85357-b806-4b9f-80c7-60450b1ca41a\" /\u003e\n\nGiven the timing, we\u0027ll wait for dotnet 10 now.",
                                           "updatedAt":  "2025-09-17T18:09:44Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "Thread.SetThreadPoolWorkerThreadName takes way too many CPU cycles",
        "labels":  [
                       "area-System.Threading",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/112869",
        "createdAt":  "2025-02-24T16:33:23Z",
        "number":  112869,
        "author":  "kouvel",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-13T17:34:04Z",
        "body":  "- In environments where the CPU quota is limited, spin-waiting will eat some of the CPU quota\n- It\u0027s unpredictable whether eating up CPU quota from spin-waiting would leave less CPU time for more useful work later. Even an adaptive spin-waiting scheme that is aware of the scenario would have difficulty making a useful compromise due to the unpredictability in these scenarios.\n- Environments where CPU quota is limited often tend to be more efficiency-oriented than throughput-oriented, in the sense useful work done per CPU time used is more valued than the throughput\n- A better default for those environments would be to disable spin-waiting in at least cases that typically contribute noticeably to spin-waiting CPU time, such as the thread pool and locks\n- The change should be configurable. In environments where the CPU quota is typically not reached (even with spin-waiting), and where throughput is more valued than efficiency, spin-waiting may still be beneficial.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOn66XhQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6frpeF",
                                           "createdAt":  "2025-02-24T16:33:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-02-24T16:33:56Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Disable spin-waiting in some cases when CPU quota is limited by default",
        "labels":  [
                       "area-System.Threading",
                       "in-pr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/112870",
        "createdAt":  "2025-02-24T16:34:18Z",
        "number":  112870,
        "author":  "kouvel",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-13T15:44:39Z",
        "body":  "- There are some scaling issues on Windows with 1 IOCP on larger machines, and some fixes were made to scale better with 2+ IOCPs. So far, the data doesn\u0027t show better scaling with more than 2 IOCPs even on very large machines.\n- Determine when to switch to 2 IOCPs by default",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOn66jEQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6frqMR",
                                           "createdAt":  "2025-02-24T16:34:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-02-24T16:34:58Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Change the number of IOCPs used on Windows to 2 on larger machines",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/113322",
        "createdAt":  "2025-03-10T15:03:21Z",
        "number":  113322,
        "author":  "georgschausberger",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-03-13T14:49:42Z",
        "body":  "### Description\n\nhttps://github.com/dotnet/runtime/pull/64834\n\nchanged the behavior of\n`public static void GetAvailableThreads(out int workerThreads, out int completionPortThreads);`\n\npreviously this lead to a native call returning the available IO Completion Threads. Now it always returns the configured maximum. This breaks metrics about the thread pool usage.\n\n### Reproduction Steps\n\ncalling ThreadPool.GetAvailableThreads\nstart some async threads\ncall ThreadPool.GetAvailableThreads again to see no difference in the returned metric.\n\n### Expected behavior\n\n`PortableThreadPool.GetAvailableThreads(out int workerThreads, out int completionPortThreads);`\nshould return the correct ammount of available IO Completion Threads.\n\n### Actual behavior\n\nthe api always return max.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOojdFjQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6hlSeE",
                                           "createdAt":  "2025-03-10T15:03:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-03-10T15:03:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6hlaCv",
                                           "createdAt":  "2025-03-10T15:13:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "georgschausberger",
                                           "body":  "@kouvel tagging you, since this has been part of your PR from 2022.",
                                           "updatedAt":  "2025-03-10T15:13:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6iN0WN",
                                           "createdAt":  "2025-03-13T14:48:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "After https://github.com/dotnet/runtime/pull/64834 (in .NET 7), the IO completion thread pool was not used by default, in favor of using worker threads to process IO completions in batches. In .NET 8, the IO completion thread pool was removed, and the `completionPortThreads` value is not applicable anymore, so it just returns the max.",
                                           "updatedAt":  "2025-03-13T14:49:41Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "System.ThreadPool.GetAvailableThreads always returns maxIoCompletionThreads instead of available IO Completion Threads",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/113411",
        "createdAt":  "2025-03-12T06:21:03Z",
        "number":  113411,
        "author":  "eduardo-vp",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-15T16:50:54Z",
        "body":  "\u003c!--This is just a template - feel free to delete any and all of it and replace as appropriate.--\u003e\n\n### Description\n\n\u003c!--\n* Please share a clear and concise description of the performance problem.\n* Include minimal steps to reproduce the problem if possible. E.g.: the smallest possible code snippet; or a small repo to clone, with steps to run it.\n  --\u003e\n\nThere\u0027s a performance issue regarding Semaphore in scenarios where threads request and release the semaphore with no work in between as shown in the snippet below. The rate of transactions is up to 3-4 times lower compared to other runtimes.\n\n```C#\nusing System;\nusing System.Diagnostics;\nusing System.Threading;\n\nnamespace MultiThreadedScaling\n{\n  internal class ScalingIssue\n  {\n    static ReaderWriterLockSlim slimRWlock = null;\n    static Semaphore normalSemaphore = null;\n\n    static int numThreads = 8;\n    static int run_time = 30; // seconds\n\n    static void Main(string[] args)\n    {\n      Console.WriteLine(\"Running test with \" + numThreads + \" threads for \" + run_time + \" seconds\");\n\n      slimRWlock = new ReaderWriterLockSlim();\n      normalSemaphore = new Semaphore(numThreads, Int32.MaxValue);\n      for (int i = 0; i \u003c numThreads; i++)\n      {\n        Thread t1 = new Thread(new ParameterizedThreadStart(OpenCloseSimulation));\n        t1.Name = i.ToString();\n        t1.Start(i);\n      }\n    }\n\n    static void OpenCloseSimulation(object state)\n    {\n      int index = (int)state;\n      int numTxns = 0;\n      var start_time = DateTime.UtcNow;\n      while (DateTime.UtcNow - start_time \u003c TimeSpan.FromSeconds(run_time))\n      {\n        OpenConnSimulation(index);\n        CloseConnSimulation(index);\n        numTxns += 1;\n      }\n      var end_time = DateTime.UtcNow;\n      long totRunTime = (long)(end_time - start_time).TotalSeconds;\n      Console.WriteLine(\"Thread \" + Thread.CurrentThread.Name + \" Transaction rate: commits= \" + (numTxns / totRunTime));\n    }\n\n    static void OpenConnSimulation(int index)\n    {\n      normalSemaphore.WaitOne();\n      DoWork();\n      slimRWlock.EnterReadLock();\n      DoWork();\n      slimRWlock.ExitReadLock();\n    }\n\n    static void CloseConnSimulation(int index)\n    {\n      DoWork();\n      normalSemaphore.Release();\n    }\n\n    internal static void DoWork()\n    {\n      return;\n    }\n  }\n}\n```\n\n\u003c!--\n(If you are posting Benchmark.NET results, this info will be included.)\n* Which version of .NET is the code running on?\n* What OS version, and what distro if applicable?\n* What is the architecture (x64, x86, ARM, ARM64)?\n* If relevant, what are the specs of the machine?\n  --\u003e\n\nThis scenario was tested with .NET 9, arch x64 for both Windows and Linux. Machines had 16 vcpus and the test was ran using 8 threads during 30 seconds. \n\nThe transactions per second rate on Windows is ~320K whereas on Linux the rate is ~130K. Other runtimes can achieve around ~500K+ on both platforms.\n\nNative AOT achieved similar results to the non Native AOT versions.\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOrJtc6Q==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6h7SiA",
                                           "createdAt":  "2025-03-12T06:21:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-03-12T06:21:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6h7Vuy",
                                           "createdAt":  "2025-03-12T06:30:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEJwxoQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "KalleOlaviNiemitalo",
                                                                               "createdAt":  "2025-03-12T07:37:42Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "neon-sunset",
                                                                               "createdAt":  "2025-03-12T12:13:13Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2025-03-12T14:59:19Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "sanamhub",
                                                                               "createdAt":  "2025-03-13T09:59:40Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "hez2010",
                                           "body":  "You can try `SemaphoreSlim` instead of `Semaphore`. `Semaphore` is a type that wraps the system semaphore directly and has performance implications from the OS.",
                                           "updatedAt":  "2025-03-12T06:34:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6h7ar6",
                                           "createdAt":  "2025-03-12T06:44:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "Other runtimes are able to get better performance so certainly something we can investigate. ",
                                           "updatedAt":  "2025-03-12T06:44:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6h7hiI",
                                           "createdAt":  "2025-03-12T06:55:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "En3Tho",
                                           "body":  "Is using ReaderWriter lock necessary here? Is issue scoped to Semaphore only or a combination of Semaphore and ReaderWriter lock?\n\nWhen you say other runtimes, which ones? Can they optimize out an empty acquire-release seeing that DoWork actually does nothing?",
                                           "updatedAt":  "2025-03-12T06:56:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6h7zol",
                                           "createdAt":  "2025-03-12T07:09:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "\u003e Is using ReaderWriter lock necessary here? Is issue scoped to Semaphore only or a combination of Semaphore and ReaderWriter lock?\n\nDont believe RWLock makes a difference. \n\n\u003e When you say other runtimes, which ones? Can they optimize out an empty acquire-release seeing that DoWork actually does nothing?\n\nFair point, it\u0027s a possibility, but unlikely that a compiler would be able to make the determination and completely remove the acquire/release? But worth looking into. ",
                                           "updatedAt":  "2025-03-12T07:09:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6h-msq",
                                           "createdAt":  "2025-03-12T11:22:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEJlhKA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2025-03-12T14:57:58Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Other runtimes are able to get better performance so certainly something we can investigate.\n\nUsing a semaphore that wraps the OS primitive? Or using their built-in semaphore type? Or using a hand-rolled semaphore? ",
                                           "updatedAt":  "2025-03-12T11:22:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6h_Mzd",
                                           "createdAt":  "2025-03-12T12:19:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "neon-sunset",
                                           "body":  "\u003e Dont believe RWLock makes a difference.\n\n`ReaderWriterLockSlim` is plenty fast, only slightly slower than a plain lock (which in itself is fast too, contended or not). Without looking at a profile I can bet the most time is spent on waiting for OS-level semaphore. `SemaphoreSlim` should be used instead. Although the naming is a bit unfortunate but you can always wrap it in a struct which will also provide better enter/exit semantics through IDisposable if needed.",
                                           "updatedAt":  "2025-03-12T17:01:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6iFp4Z",
                                           "createdAt":  "2025-03-13T00:07:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEJ61QQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "mahara",
                                                                               "createdAt":  "2025-03-14T07:34:35Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "eduardo-vp",
                                           "body":  "Agree that using `SemaphoreSlim` might be a fair comparison since it doesn\u0027t use the underlying OS semaphore and the wait time between request/release is almost non-existent but it still shows lower performance than the ~500K mentioned above.\n\nIn fact, on Linux the transaction rate notably increased but actually decreased on Windows.\n\n| Platform | Semaphore class | Transaction rate |\n|----------|----------|----------|\n| Linux    | Semaphore         | ~130K   |\n| Linux    | SemaphoreSlim  | ~220K   |\n| Windows | Semaphore         | ~320K   |\n| Windows | SemaphoreSlim  | ~280K   |",
                                           "updatedAt":  "2025-03-13T00:07:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6iwB_M",
                                           "createdAt":  "2025-03-17T18:38:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kakiyama1018",
                                           "body":  "SemaphoreSlim has a major limitation:  One cannot \"wait\" on multiple SemaphoreSlim objects.  .NET Semaphore allow this.  Thus, even if SemaphoreSlim is more efficient than the regular Semaphores, SemaphoreSlim is not a solution to obtain better performance \u0026 scalability due to this limitation.  Can SemaphoreSlim be enhanced so that one can \"wait\" on multiple SemaphoreSlim objects?",
                                           "updatedAt":  "2025-03-17T18:38:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6iw3MN",
                                           "createdAt":  "2025-03-17T20:08:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "You can do it with Task.WhenAll/WaitAll.",
                                           "updatedAt":  "2025-03-17T20:08:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ixQqS",
                                           "createdAt":  "2025-03-17T20:35:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kakiyama1018",
                                           "body":  "Won\u0027t Task.WhenAll/WaitAll require ALL the semaphores to be acquired from the collection of SemaphoreSlim objects?   Is there a .NET API that can come out from a wait after acquiring just ONE semaphore out of the collection of SemaphoreSlim objects?",
                                           "updatedAt":  "2025-03-17T20:35:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ixsFg",
                                           "createdAt":  "2025-03-17T21:09:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "You could use Task.WhenAny/WaitAny and pass in a cancelation token. It\u0027s a bit more boilerplate, but you could make it a helper method. ",
                                           "updatedAt":  "2025-03-17T21:10:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ixt4t",
                                           "createdAt":  "2025-03-17T21:12:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "Or you could use the `SemaphoreSlim.AvailableWaitHandle` property, and use the `WaitHandle` APIs. ",
                                           "updatedAt":  "2025-03-17T21:12:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6i034u",
                                           "createdAt":  "2025-03-18T06:02:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Aks2025-orcl",
                                           "body":  "The problem with using AvailableWaitHandle is that it is implemented as ManualResetEvent and when the semaphore is released, all threads waiting on the WaitHandle would end their block and then try to Wait on SemaphoreSlim. From here only one thread would be able to acquire the semaphore and other threads will get stuck.\n\nOne can possibly cook up something with Wait{0) and loop but not sure if this is the best we can do or if there are some other better solutions.",
                                           "updatedAt":  "2025-03-18T06:02:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6jApML",
                                           "createdAt":  "2025-03-18T22:12:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "In regards to the OP\u0027s issue, I think `SemaphoreSlim` suffers from the duality of supporting both synchronous and asynchronous waits, while `Semaphore` only supports synchronous waits. I assume the difference in performance between Linux and Windows is due to the implementation of the OS semaphore (`SemaphoreSlim` performance looks much closer on both OSes).\n\nThe performance delta only shows this way because there is actually zero contention on the semaphore in the OP\u0027s benchmark. Adding contention shows a very different story. My results on Windows with Ryzen 9800X3D:\n\n| initialCount | Type | Throughput |\n|--------|--------|--------|\n| 8 | Semaphore | 746923 |\n| 8 | SemaphoreSlim | 526376 |\n| 4 | Semaphore | 116927 | \n| 4 | SemaphoreSlim | 513910 | \n\n---\n\n\u003e or if there are some other better solutions.\n\nIf you care for a library solution, I created an `AsyncSemaphore` in my [ProtoPromise library](https://github.com/timcassell/ProtoPromise). And I posted a [discussion](https://github.com/timcassell/ProtoPromise/discussions/531) demonstrating how to wait for multiple.\n\nRunning the same benchmark, it\u0027s actually faster without contention, but a bit slower with contention:\n\n| initialCount | Type | Throughput |\n|--------|--------|--------|\n| 8 | AsyncSemaphore | 1112091|\n| 4 | AsyncSemaphore | 456698 |\n\nBut `SemaphoreSlim` performance will also change if you `WaitAsync`, which is not measured here.\n\nhttps://github.com/dotnet/runtime/blob/a1a3fb7188f322fbfdbf8c3fdac84b4d68c2964c/src/libraries/System.Private.CoreLib/src/System/Threading/SemaphoreSlim.cs#L365-L374",
                                           "updatedAt":  "2025-03-18T22:12:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6j6WO_",
                                           "createdAt":  "2025-03-25T03:37:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "eduardo-vp",
                                           "body":  "@kakiyama1018 is there any limitation you find when trying to use Task.WhenAny/WaitAny to wait on multiple SemaphoreSlim objects?",
                                           "updatedAt":  "2025-03-25T03:37:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6sm1zp",
                                           "createdAt":  "2025-05-20T21:20:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "eduardo-vp",
                                           "body":  "Decided to get some profiles on a test case using Semaphore only (excluded ReaderWriterLockSlim) and most time is just used on waiting and releasing (especially on the syscall to wait). \n \n\n![Image](https://github.com/user-attachments/assets/dbb1deff-612f-40aa-b8b5-a07df5dcd7e8)\n\nSince Semaphore implementations use locks/monitors for state manipulation and .NET’s Semaphore objects also support multi-waits on top of the fact that in this test case the only thing the Semaphore does is just waiting/releasing, contention is expected.\n\nAlthough there is the possibility to optimize this scenario with no work between waiting and releasing, so far it doesn’t really seem like a compelling scenario to improve since a Semaphore is meant to be used with at least some work in the middle. \n\nIncluding some wait time as short as 0.05 ms in between didn’t show any performance issues with Semaphore. I believe it should be fine to close this issue unless some performance issues show up in a more realistic scenario, in such case that could be used to perform some extra investigation.\n",
                                           "updatedAt":  "2025-05-20T21:20:58Z"
                                       }
                                   ],
                         "totalCount":  17
                     },
        "title":  "Semaphore performance issue",
        "labels":  [
                       "area-System.Threading",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/115226",
        "createdAt":  "2025-03-25T13:38:33Z",
        "number":  115226,
        "author":  "peto268",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODB7vuw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_DOWN",
                                            "user":  "punchready",
                                            "createdAt":  "2025-03-26T01:39:28Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-05-02T09:34:02Z",
        "body":  "Reading [https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-9/#threading](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-9/#threading) i\u0027m wondering if instead of replacing `lock(_lock)` with `_lock.EnterScope() ... Dispose` the compiler shouldn\u0027t actually use something like:\n```\n_lock.Enter();\ntry\n{\n    ...\n}\nfinally\n{\n    _lock.Exit();\n}\n```\nThis prevents the allocation of the scope struct and in my benchmarks:\n```\n[Benchmark]\npublic void WithLock()\n{\n    lock (_lock)\n    {\n        _value++;\n    }\n}\n\n[Benchmark]\npublic void WithLock2()\n{\n    _lock2.Enter();\n    try\n    {\n        _value++;\n    }\n    finally\n    {\n        _lock2.Exit();\n    }\n}\n```\nthis performs ~5% better.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOqZYv8A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6plixE",
                                           "createdAt":  "2025-03-25T13:38:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one area label.",
                                           "updatedAt":  "2025-03-25T13:38:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6plixL",
                                           "createdAt":  "2025-03-25T13:38:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one area label.",
                                           "updatedAt":  "2025-03-25T13:38:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6plixR",
                                           "createdAt":  "2025-03-26T09:24:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jjonescz",
                                           "body":  "The [speclet of the feature](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/lock-object.md) addresses this:\n\n![Image](https://github.com/user-attachments/assets/ca6e7d19-147d-4edf-a305-a492947d2321)\n\n\u003e This prevents the allocation of the scope struct and in my benchmarks:\n\nStructs are not allocated, so I don\u0027t understand this.\n\n\u003e this performs ~5% better.\n\ncc @kouvel ",
                                           "updatedAt":  "2025-03-26T09:24:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6plixV",
                                           "createdAt":  "2025-03-26T12:05:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "peto268",
                                           "body":  "From [ref structure types (C# reference)](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/ref-struct):\n\n\u003e Instances of a ref struct type are allocated on the stack and can\u0027t escape to the managed heap.\n\nThnx for the speclet link, i didn\u0027t know about the extra thread lookup in Exit. This makes it even weirder. The perf improvement i observe is ~the same as switching from lock(object) to lock(Lock). Have you tried benchmarking it yourself?",
                                           "updatedAt":  "2025-03-26T12:05:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6plixY",
                                           "createdAt":  "2025-03-26T17:29:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "\u003e This makes it even weirder. The perf improvement i observe is ~the same as switching from lock(object) to lock(Lock). Have you tried benchmarking it yourself?\n\nSome processors may be able to prefetch through the thread-local lookup more easily, so the cost of the extra lookup may not show up in some cases. Depending on what is done inside and outside the lock, the perf may vary and can be slightly better with `Lock` when the overhead of the thread-local lookups show up.",
                                           "updatedAt":  "2025-03-26T17:29:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6plixe",
                                           "createdAt":  "2025-04-03T21:52:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jilles-sg",
                                           "body":  "\u003e \u003e This prevents the allocation of the scope struct and in my benchmarks:\n\n\u003e Structs are not allocated, so I don\u0027t understand this.\n\nWhat is meant with \"allocation\" here is extra unnecessary memory reads and writes and missed optimizations that can result from using structs (for example, `foreach` on spans has a special expansion rather than using the `Span\u003cT\u003e.Enumerator` struct). However, `Lock.Scope` appears to be carefully crafted such that the JIT turns the struct into its two fields (verified using godbolt.org).\n\nEven then, keeping the thread ID between enter and exit is not entirely free and if thread-local storage is very fast on the system it may not be a win.\n\nThe `Benchmark2` code assumes that `_lock2` does not change. The JIT normally does not assume that `readonly` class instance fields do not change, but perhaps Roslyn can do this. If not, the benchmark is not entirely realistic.",
                                           "updatedAt":  "2025-04-03T21:52:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6plixi",
                                           "createdAt":  "2025-04-04T06:18:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "peto268",
                                           "body":  "Is the thread check necessary in this case though? Is there a scenario when a thread can change inside a lock block like this?",
                                           "updatedAt":  "2025-04-04T06:18:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6plixm",
                                           "createdAt":  "2025-04-04T07:51:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEQdzUw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "peto268",
                                                                               "createdAt":  "2025-04-04T14:14:54Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jjonescz",
                                           "body":  "\u003e Is the thread check necessary in this case though? Is there a scenario when a thread can change inside a lock block like this?\n\n`Lock.Exit` can be used in other cases than `lock` block though, so the check is necessary there. The runtime could expose another API which doesn\u0027t check the thread, e.g., `ExitUnsafe` or something like that, then compiler could use that API:\n\n```cs\n_lock.Enter();\ntry\n{\n    _value++;\n}\nfinally\n{\n    _lock.ExitUnsafe();\n}\n``` ",
                                           "updatedAt":  "2025-05-02T09:34:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6plixt",
                                           "createdAt":  "2025-04-04T14:16:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "peto268",
                                           "body":  "Yes, that is what i meant, the compiler can use some kind of unsafe exit.",
                                           "updatedAt":  "2025-04-04T14:16:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6plixz",
                                           "createdAt":  "2025-05-01T16:27:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jaredpar",
                                           "body":  "Moving to runtime. This is about the performance of the overall locking system. It\u0027s hard for compiler to make a judgement on whether this is or is not a good path forward. Runtime can make that call and if they believe it\u0027s worth the change we can sync up on compiler implementation. ",
                                           "updatedAt":  "2025-05-01T16:27:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6pli_w",
                                           "createdAt":  "2025-05-01T16:28:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-05-01T16:28:35Z"
                                       }
                                   ],
                         "totalCount":  11
                     },
        "title":  "Possible lock(System.Threading.Lock) perf improvement",
        "labels":  [
                       "question",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/114151",
        "createdAt":  "2025-04-02T13:15:23Z",
        "number":  114151,
        "author":  "amoerie",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODAw7og==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "tarsdejaeger",
                                            "createdAt":  "2025-04-02T13:17:31Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-06-12T20:36:23Z",
        "body":  "### Background and motivation\n\nSystem.Threading.RateLimiting has an option called AutoReplenish. When enabled, every rate limiter has a Timer that \"replenishes\" its availability based on various parameters.\nIt is possible to disable AutoReplenish, at which point applications are expected to periodically manually call ReplenishingRateLimiter.TryReplenish.\nSo far so good.\nHowever, if we wrap a ReplenishingRateLimiter in a PartitionedRateLimiter, this is no longer possible. PartitionedRateLimiter will automatically create its own (single) Timer, that automatically replenishes any materialized ReplenishingRateLimiters. (materialization happens per partition key on demand)\n\nThis leaves us unable to manually call TryReplenish. \n\nMy current workaround is to call DefaultPartitionedRateLimiter.Heartbeat manually (this is called from the Timer)\n\n```csharp\nvar heartBeatTask =\n  (Task)myRateLimiter\n      .GetType()\n      .GetMethod(\"Heartbeat\", BindingFlags.NonPublic | BindingFlags.Instance)!\n      .Invoke(innerRateLimiter, null)!;\nawait heartBeatTask;\n```\n\n\n\n### API Proposal\n\n```csharp\nnamespace System.Threading.RateLimiting;\n\npublic abstract class PartitionedRateLimiter\u003cTResource\u003e : IAsyncDisposable, IDisposable\n{\n    /// \u003csummary\u003eAttempts to replenish tokens for all materialized replenishing rate limiters.\u003c/summary\u003e\n    /// \u003creturns\u003e\n    /// Generally returns \u003csee langword=\"false\" /\u003e if \u003csee cref=\"P:System.Threading.RateLimiting.ReplenishingRateLimiter.IsAutoReplenishing\" /\u003e is enabled\n    /// or if no tokens were replenished. Otherwise \u003csee langword=\"true\" /\u003e.\n    /// \u003c/returns\u003e\n    public abstract bool TryReplenish();\n}\n```\n\n\n### API Usage\n\n```csharp\nvar ipAddressLimiter = PartitionedRateLimiter.Create\u003cHttpContext, IPAddress\u003e(\n    context =\u003e\n    {\n        var remoteIpAddress = context.HttpContext.Connection.RemoteIpAddress;\n        return RateLimitPartition.GetSlidingWindowLimiter(\n            remoteIpAddress,\n            _ =\u003e new SlidingWindowRateLimiterOptions\n            {\n                Window = TimeSpan.FromMilliseconds(100),\n                PermitLimit = 1,\n                SegmentsPerWindow = 2,\n                AutoReplenishment = false\n            }\n        );\n    }\n)\n\nipAddressLimiter.TryReplenish();\n```\n\n\n### Alternative Designs\n\nNo idea\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOsOl-_w==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6lQYZX",
                                           "createdAt":  "2025-04-02T13:15:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-04-02T13:15:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6w6X7_",
                                           "createdAt":  "2025-06-12T20:36:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "@BrennanConroy fyi. Is there a better label to put RateLimiter issues into? ",
                                           "updatedAt":  "2025-06-12T20:36:23Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[API Proposal]: Add PartitionedRateLimiter.TryReplenish",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/114262",
        "createdAt":  "2025-04-04T13:27:02Z",
        "number":  114262,
        "author":  "sleushunou",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODC9SXA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mlancione",
                                            "createdAt":  "2025-04-25T19:52:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aalsamoht",
                                            "createdAt":  "2025-04-29T12:00:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AndreWaageSorensen",
                                            "createdAt":  "2025-04-29T12:02:05Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "HoffZ",
                                            "createdAt":  "2025-04-29T12:02:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Ctrl-Alt-Lars",
                                            "createdAt":  "2025-04-29T13:05:03Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "LarsHolen",
                                            "createdAt":  "2025-04-29T13:27:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "KillswitchPrime",
                                            "createdAt":  "2025-04-30T08:16:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "huzaifacontour",
                                            "createdAt":  "2025-04-30T10:06:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "EmilienDup",
                                            "createdAt":  "2025-05-05T10:00:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "janusw",
                                            "createdAt":  "2025-05-05T12:20:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "linnkrb",
                                            "createdAt":  "2025-05-05T20:33:02Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "kotlarmilos",
                                            "createdAt":  "2025-05-07T12:06:37Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "VictoriaxNeacsu",
                                            "createdAt":  "2025-05-29T13:20:18Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "VictoriaxNeacsu",
                                            "createdAt":  "2025-05-29T13:20:19Z"
                                        }
                                    ],
                          "totalCount":  14
                      },
        "updatedAt":  "2025-09-15T09:26:01Z",
        "body":  "### Description\n\nreproduces absolutely randomly both in debug and in release mode, appeared after switching from net8-ios to net9-ios (It doesn\u0027t seem like it applies to iOS)\n\nstacktrace of InvalidCastException:\n\n\nSystem.InvalidCastException: Specified cast is not valid.\n   at System.Threading.Tasks.Task.RunContinuations(Object continuationObject)\n   at System.Threading.Tasks.Task.FinishContinuations()\n   at System.Threading.Tasks.Task.FinishStageThree()\n   at System.Threading.Tasks.Task.FinishStageTwo()\n   at System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)\n   at System.Threading.Tasks.Task.Finish(Boolean userDelegateExecute)\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\n   at System.Threading.Tasks.Task.ExecuteEntryUnsafe(Thread threadPoolThread)\n   at System.Threading.Tasks.Task.ExecuteFromThreadPool(Thread threadPoolThread)\n   at System.Threading.ThreadPoolWorkQueue.DispatchItemWithAutoreleasePool(Object workItem, Thread currentThread)\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\n   at System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart()\n   at System.Threading.Thread.StartCallback()\n\nstacktrace of InvalidOperationException (from Sentry):\n\nSystem.InvalidOperationException: Arg_InvalidOperationException\n  ?, in void ManualResetValueTaskSourceCore\u003clong\u003e.SignalCompletion()\n  ?, in void ManualResetValueTaskSourceCore\u003clong\u003e.SetResult(long)\n  ?, in void ThreadPoolValueTaskSource.ExecuteInternal()\n  ?, in void ThreadPoolValueTaskSource.System.Threading.IThreadPoolWorkItem.Execute()\n  ?, in void ThreadPoolWorkQueue.DispatchItemWithAutoreleasePool(object, Thread)\n  ?, in bool ThreadPoolWorkQueue.Dispatch()\n  ?, in void WorkerThread.WorkerThreadStart()\n\nalso screenshot from debug session (from AppDomain.CurrentDomain.UnhandledException):\n\n![Image](https://github.com/user-attachments/assets/22e553f0-1a6b-4fb8-af50-b428ea33bab9)\n\n\n### Reproduction Steps\n\nhave not steps\n\n### Expected behavior\n\nno crashes\n\n### Actual behavior\n\ncrash occurs\n\n### Regression?\n\nworks in net8-ios\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\nnet9, ios 18\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOqlzMFA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6loB9N",
                                           "createdAt":  "2025-04-04T13:27:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-04-04T13:27:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6lvhrq",
                                           "createdAt":  "2025-04-05T12:34:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "TDiblik",
                                           "body":  "hey, i would love to look into this, could you please provide a minimal reproducible example?",
                                           "updatedAt":  "2025-04-05T12:34:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6lx5Os",
                                           "createdAt":  "2025-04-06T09:05:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sleushunou",
                                           "body":  "so far it\u0027s very difficult for me to understand where this is being reproduced: the project is very large, the stack trace is absolutely uninformative for me",
                                           "updatedAt":  "2025-04-06T09:05:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6lx539",
                                           "createdAt":  "2025-04-06T09:12:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sleushunou",
                                           "body":  "perhaps you can find breaking changes that occurred during the transition from net8 to net9 based on the stack trace",
                                           "updatedAt":  "2025-04-06T09:12:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6lyOUo",
                                           "createdAt":  "2025-04-06T12:46:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sleushunou",
                                           "body":  "https://github.com/dotnet/maui/issues/28197\n\ni found similar issue",
                                           "updatedAt":  "2025-04-06T12:46:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mN3X1",
                                           "createdAt":  "2025-04-09T07:38:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOENg4vg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "uwe-neuronation",
                                                                               "createdAt":  "2025-04-09T09:55:22Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "a1exv",
                                           "body":  "Happens for us in random places in the iOS in release mode. This is a blocker to go for net9",
                                           "updatedAt":  "2025-04-09T07:38:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mOWXG",
                                           "createdAt":  "2025-04-09T08:29:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEQ3q4g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "ROCKET",
                                                                               "user":  "Pablo-Sierra",
                                                                               "createdAt":  "2025-05-05T19:49:29Z"
                                                                           },
                                                                           {
                                                                               "content":  "ROCKET",
                                                                               "user":  "linnkrb",
                                                                               "createdAt":  "2025-05-05T21:21:46Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "afk013",
                                           "body":  "**TLDR: Just to add a me too to this issue though our situation we can only repeat in a release mode and we only get InvalidCastException**\n\nThis crash has only been recreated by us using a release-built iOS app with the default template AOT and trimming settings enabled. Attempting to create repro steps has been difficult as the crash is intermittent in that it seemingly can occur anywhere in the app however will occur multiple times within the span of a couple of hours for any given device (sometimes within 5 minutes of app start to around 1.5 hours of use).\n\nIt seems to happen during periods of heavy activity such as background syncing and the UI reacting to data changes or during page navigation.\u2028\u2028\n\nException details:\n\n```\n*** Terminating app due to uncaught exception \u0027SIGABRT\u0027, reason: \u0027Arg_InvalidCastException\u0027\u2028\u2028\n\nXamarin Exception Stack:\u2028\nSystem.InvalidCastException: Arg_InvalidCastException\u2028\nat System.Threading.Tasks.Task.RunContinuations(Object )\u2028\nat System.Threading.Tasks.Task.FinishStageThree()\u2028\nat System.Threading.Tasks.Task.FinishStageTwo()\u2028\nat System.Threading.Tasks.Task.Finish(Boolean )\u2028\nat System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 , Thread )\u2028\nat System.Threading.Tasks.Task.ExecuteEntryUnsafe(Thread )\u2028\nat System.Threading.Tasks.Task.ExecuteFromThreadPool(Thread )\u2028\nat System.Threading.ThreadPoolWorkQueue.DispatchItemWithAutoreleasePool(Object , Thread )\u2028\nat System.Threading.ThreadPoolWorkQueue.Dispatch()\u2028\nat System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart()\n```\n\nThis issue does look very similar to the issue raised here: https://github.com/dotnet/runtime/issues/81211 however this was resolved in .Net MAUI 8 RC2 and we are using .Net MAUI 9.0.50 SR5.\u2028\n\nWe did have a theory that possibly the exception was being raised within an event handler that was using async void. To rule this out we have used the package: https://github.com/roubachof/Sharpnado.TaskMonitor to revert all event handlers back to returning void and if any tasks within these methods throw an exception this is now handled within a global error handler. Sadly, while this approach is definitely better moving forward it was not the cause of the unhandled exception we are experiencing on iOS.",
                                           "updatedAt":  "2025-04-09T08:29:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mRnJO",
                                           "createdAt":  "2025-04-09T13:03:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOESPLCQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "EmilienDup",
                                                                               "createdAt":  "2025-04-16T12:47:37Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "asherrna",
                                                                               "createdAt":  "2025-04-29T12:43:31Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "linnkrb",
                                                                               "createdAt":  "2025-05-05T21:21:54Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Pablo-Sierra",
                                                                               "createdAt":  "2025-05-15T12:25:22Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "pme442",
                                           "body":  "Well, add me to this, too.  Happening in release mode .Net MAUI 9.0.10.  It\u0027s very random (could happen while refreshing a ListView, closing a modal page, opening a modal page, toggling a Switch control, displaying an activity indicator etc.).   \nVery, very similar to what @afk013 describes.\n\nThat being said, what is the game plan here?\nUp until now, I\u0027ve been able to support our users and provide emergency bug fixes via the Xamarin Forms app.  \nHowever, in 2 weeks, I will no longer be able to do this due to the April 2025 App Store Xcode requirement.\nSince I\u0027ve converted to Maui, performance has taken a hit.  It runs poorly on any device with less than 3GB of RAM.  I\u0027ve done everything that the Maui documents encourage me to do to help performance (compiled bindings, simplified layouts etc.).  Our app is complex with heavy processing due to business requirements that I can\u0027t change.  Xamarin Forms handled it like a dream.  So I was quite disappointed after all the work I\u0027ve put into converting it to Maui.  \nAside from that, I\u0027m not at all comfortable releasing the Maui app since this issue, in particular, makes it unstable.",
                                           "updatedAt":  "2025-04-09T13:03:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mUCjt",
                                           "createdAt":  "2025-04-09T16:21:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveisok",
                                           "body":  "\u003e That being said, what is the game plan here?\n\nWe\u0027re in the process of triaging to determine what the problem is. If we\u0027re able to pin it down, I\u0027m hopeful we\u0027ll be able to suggest workarounds better than falling back to the interpreter. \n\nIf anyone can provide a simple repro, that would help speed everything up.",
                                           "updatedAt":  "2025-04-09T16:21:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mXMGc",
                                           "createdAt":  "2025-04-09T22:10:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "HarlanHugh",
                                           "body":  "Just commenting to say we are seeing the same issue. Only happens when using net9 on iOS. Also appears randomly and without any obvious pattern.",
                                           "updatedAt":  "2025-04-09T22:10:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mlRYE",
                                           "createdAt":  "2025-04-10T18:32:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEQ3rlg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "linnkrb",
                                                                               "createdAt":  "2025-05-05T21:23:33Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "wgriep",
                                           "body":  "We have the same issue when we run our Maui app on iOS without the VS debugger attached.  When the debugger is attached, we never get the exception.  Our project is quite complex and haven\u0027t tried to isolate this with a repro, but can provide some background in hopes it helps:\nVisual Studio Version 17.13.5\ndotnet workload list:\n\nInstalled Workload Id      Manifest Version       Installation Source\n--------------------------------------------------------------------------------\nandroid                    35.0.50/9.0.100        SDK 9.0.200, VS 17.13.35919.96\naspire                     8.2.2/8.0.100          SDK 9.0.200, VS 17.13.35919.96\nios                        18.2.9180/9.0.100      SDK 9.0.200, VS 17.13.35919.96\nmaccatalyst                18.2.9180/9.0.100      SDK 9.0.200, VS 17.13.35919.96\nmaui                       9.0.14/9.0.100         SDK 9.0.200\nmaui-windows               9.0.14/9.0.100         SDK 9.0.200, VS 17.13.35919.96\nwasm-tools                 9.0.3/9.0.100          SDK 9.0.200, VS 17.13.35919.96\n\nProject has `\u003cUseInterpreter\u003eTrue\u003c/UseInterpreter\u003e`\n\nPackages:\n\n- Camera.MAUI\" Version=\"1.5.1\" \n- Camera.MAUI.ZXing\" Version=\"1.0.0\" \n- CommunityToolkit.Maui\" Version=\"11.2.0\" \n- MetroLog.Maui\" Version=\"2.1.0\" \n- Microsoft.Maui.Controls\" Version=\"9.0.50\" \n- Microsoft.Maui.Controls.Compatibility\" Version=\"9.0.50\" \n- Microsoft.Extensions.Logging.Debug\" Version=\"9.0.3\" \n- Esri.ArcGISRuntime.Maui\" Version=\"200.6.0\" \n- Esri.ArcGISRuntime.Toolkit.Maui\" Version=\"200.6.0\" \n- MetroLog.Net6\" Version=\"2.1.0\" \n- Newtonsoft.Json\" Version=\"13.0.3\" \n- Plugin.Maui.Audio\" Version=\"3.1.0\" \n- Sentry.Maui\" Version=\"5.5.0\" \n- SkiaSharp\" Version=\"3.116.1\" \n- SkiaSharp.Views.Maui.Controls\" Version=\"3.116.1\" \n- Svg.Skia\" Version=\"2.0.0.4\" \n- System.Private.Uri\" Version=\"4.3.2\" \n- Telerik.UI.for.Maui\" Version=\"10.1.0\" \n- Microsoft.Graph\" Version=\"5.75.0\" \n- Microsoft.Identity.Client\" Version=\"4.70.0\" \n- Microsoft.Identity.Client.Broker\" Version=\"4.70.0\" \n- Microsoft.Identity.Client.Extensions.Msal\" Version=\"4.70.0\" \n- Websocket.Client\" Version=\"5.1.2\" \n- ZXing.Net.Maui.Controls\" Version=\"0.4.0\" \n\nProcess that causes the crashes:\nWe have 280 files downloading (total of 20+ GB).  These downloads are processed using Parallel.ForEachAsync (MaxDegreeOfParallelism = 5 yet setting to 1 or not setting doesn\u0027t matter) and use HttpClient within the loop to download the file.\n\nWe have added try catch around everything, but the exception bubbles up to AppDomain.CurrentDomain.UnhandledException.\n\nNote that the same code works with dotnet 8.",
                                           "updatedAt":  "2025-04-10T18:42:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mnTBE",
                                           "createdAt":  "2025-04-10T22:36:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveisok",
                                           "body":  "\u003e Process that causes the crashes: We have 280 files downloading (total of 20+ GB). These downloads are processed using Parallel.ForEachAsync (MaxDegreeOfParallelism = 5 yet setting to 1 or not setting doesn\u0027t matter) and use HttpClient within the loop to download the file.\n\u003e \n\u003e We have added try catch around everything, but the exception bubbles up to AppDomain.CurrentDomain.UnhandledException.\n\u003e \n\u003e Note that the same code works with dotnet 8.\n\nNot sure if this has been suggested, but can you set `\u003cUseNativeHttpHandler\u003efalse\u003c/UseNativeHttpHandler\u003e` in your csproj? That will use `SocketsHttpHandler` instead interoping with the native iOS one. Might be a clue if it does work for you.",
                                           "updatedAt":  "2025-04-10T22:36:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6msQOw",
                                           "createdAt":  "2025-04-11T11:20:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wgriep",
                                           "body":  "\u003e \u003e Process that causes the crashes: We have 280 files downloading (total of 20+ GB). These downloads are processed using Parallel.ForEachAsync (MaxDegreeOfParallelism = 5 yet setting to 1 or not setting doesn\u0027t matter) and use HttpClient within the loop to download the file.\n\u003e \u003e We have added try catch around everything, but the exception bubbles up to AppDomain.CurrentDomain.UnhandledException.\n\u003e \u003e Note that the same code works with dotnet 8.\n\u003e \n\u003e Not sure if this has been suggested, but can you set `\u003cUseNativeHttpHandler\u003efalse\u003c/UseNativeHttpHandler\u003e` in your csproj? That will use `SocketsHttpHandler` instead interoping with the native iOS one. Might be a clue if it does work for you.\n\nThanks for the suggestion. We tried `\u003cUseNativeHttpHandler\u003efalse\u003c/UseNativeHttpHandler\u003e` but unfortunately it doesn\u0027t solve the problem.  \n\nWe also experience the same exceptions in a long running Parallel.ForEachAsync that unzips these files after downloading.\n\nIt seems the more items we are putting thru the ForEachAsync, the higher probability we have for the exception to occur.",
                                           "updatedAt":  "2025-04-11T11:20:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6msjoq",
                                           "createdAt":  "2025-04-11T11:53:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveisok",
                                           "body":  "\u003e Thanks for the suggestion. We tried `\u003cUseNativeHttpHandler\u003efalse\u003c/UseNativeHttpHandler\u003e` but unfortunately it doesn\u0027t solve the problem.\n\u003e \n\u003e We also experience the same exceptions in a long running Parallel.ForEachAsync that unzips these files after downloading.\n\u003e \n\u003e It seems the more items we are putting thru the ForEachAsync, the higher probability we have for the exception to occur.\n\nAppreciate you trying it out and letting me know. I\u0027ll add `ForEachAsync` to the list of things we\u0027ll try. ",
                                           "updatedAt":  "2025-04-11T11:53:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6nJbfa",
                                           "createdAt":  "2025-04-15T08:35:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEQ3sOw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "linnkrb",
                                                                               "createdAt":  "2025-05-05T21:24:51Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Illyaaa",
                                           "body":  "We facing with the same problem. The app crashes randomly with Arg_InvalidCastException exception with the same stack as provided above. We just moved the app from Xamarin forms to MAUI9 and facing with this issue on release builds only. I was not able to reproduce it locally.\nThe app periodically syncing data with the backend by making 14 http requests at the same time and updating data in the local sqlite database. To work with database we use sqlite-net-pcl 1.9.172. According to Sentry breadcrumbs and the app logs, the crash always happening somewhere in the end of the sync iteration, but this happening not that often, usually it\u0027s finishing without any issues. I assume that this is somehow related to running multiple tasks in parallel or waiting them using Task.WhenAll.\nWe were facing the issue when using MAUI 9.0.50(workload version is 9.0.14/9.0.100). Today we updated MAUI to 9.0.60 and testing. I will update if it helps. ",
                                           "updatedAt":  "2025-04-15T08:35:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6nJtZr",
                                           "createdAt":  "2025-04-15T08:59:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Illyaaa",
                                           "body":  "Updating MAUI to 9.0.60 didn\u0027t help",
                                           "updatedAt":  "2025-04-15T08:59:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ndacV",
                                           "createdAt":  "2025-04-16T12:55:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EmilienDup",
                                           "body":  "We are also facing the same problem on iOS, while using MAUI version `9.0.70-ci.main.25216.1` in `Release` configuration.\n\nSame situation as others, it occurs \"at random\", and on various pages.\nWe couldn\u0027t find an exact pattern to reproduce the problem.\n\nDefinitely a blocker for us.\n\nIf it can help, here is the IOS project `Release` build configuration.\n```xaml\n\n  \u003cPropertyGroup Condition=\" \u0027$(Configuration)\u0027 == \u0027Release\u0027 \"\u003e\n    \u003cCodesignKey\u003eiPhone Distribution\u003c/CodesignKey\u003e\n    \u003cMtouchLink\u003eSdkOnly\u003c/MtouchLink\u003e\n    \u003cUseInterpreter\u003etrue\u003c/UseInterpreter\u003e\n  \u003c/PropertyGroup\u003e\n```",
                                           "updatedAt":  "2025-04-16T13:02:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6oDhim",
                                           "createdAt":  "2025-04-21T21:00:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEPMQVw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "afk013",
                                                                               "createdAt":  "2025-04-22T09:03:50Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "wgriep",
                                           "body":  "@jeffhandley since you have moved this to a future milestone, does that mean it won\u0027t be fixed for dotnet 9?  Has the issue been identified?  Are there any workarounds?  This is a major setback for our software if there is no resolution or workaround for dotnet 9.",
                                           "updatedAt":  "2025-04-21T21:00:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6oD60e",
                                           "createdAt":  "2025-04-21T22:10:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEQHfvQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "afk013",
                                                                               "createdAt":  "2025-04-22T09:03:48Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "wgriep",
                                                                               "createdAt":  "2025-04-22T12:02:34Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "HoffZ",
                                                                               "createdAt":  "2025-04-29T08:48:54Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "asherrna",
                                                                               "createdAt":  "2025-04-29T13:12:20Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "steveisok",
                                           "body":  "\u003e [@jeffhandley](https://github.com/jeffhandley) since you have moved this to a future milestone, does that mean it won\u0027t be fixed for dotnet 9? Has the issue been identified? Are there any workarounds? This is a major setback for our software if there is no resolution or workaround for dotnet 9.\n\nWe are still investigating and will relay any kind of workarounds / fixes when we determine what the problem is. Rest assured, it has our full attention. ",
                                           "updatedAt":  "2025-04-21T22:10:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6oL9IB",
                                           "createdAt":  "2025-04-22T15:29:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEQRXcg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "steveisok",
                                                                               "createdAt":  "2025-04-22T16:27:09Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kotlarmilos",
                                                                               "createdAt":  "2025-04-23T09:14:08Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "marcodelfrari",
                                                                               "createdAt":  "2025-04-29T21:09:58Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "janusw",
                                                                               "createdAt":  "2025-04-30T10:02:14Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "pme442",
                                           "body":  "OK, I have a repo app here: https://github.com/pme442/CVIssueApp\n\nI deployed this to my iPad mini 6th Gen (4GB of RAM) and ran in release mode.\nThis is an _extremely_ watered down version of what my app is doing.  It took me about 5 to 6 days (starting over 3 times) to get the exception to happen.  I\u0027ll be honest, it is frustrating to get this to happen.  It\u0027s almost like it has to hit the perfect storm.  Maybe something like a background task running, while the GC is running, while the UI is updating?  I don\u0027t know.\n\nIn this app, there are 3 tabs at the bottom:\n1 - Collection Views:   You can ignore this one.\n2 - List Views:  This is where you will answer the questions.\n3 - Error Log:  Every time you navigate here, it will append a message displaying the current memory used and total available memory.  It will also log a record for each time the app is started, any apple memory warnings and any unhandled exceptions.\n\nGeneral Notes on how it works:\n1. Every time you answer a question it will do some dummy async task processing.  \n2. If your answer contains a lowercase \"o\", it will do some extra processing.\n3. For the text questions, you can either press the purple \"Done\" button in the popup window, OR you can press the \"done\" key on the soft keyboard -- both will \"save\" the response and close the popup.  So, if you are right-handed, you can pretty easily press the o and then the \"done\" key quickly.\n4. There is a green Reset button in the bottom left corner of the screen.  If you press that, it will clear and reload all of the questions.\n\nHere is what I did:\nGo to the List View tab and start answering questions.  Sometimes I would start at the bottom and go up.  Sometimes I would start at the top or middle.  \nFor the most part, I was answering every text question with a lowercase \"o\".  Also, I was doing it rather quickly.  \nSometimes, as soon as the popup closed, I would quickly select the other category and reload all of those questions and then quickly scroll to the bottom and start answering them. \nSometimes, I would tap on one category then the other and repeat 5 or 6 times in a row just to hammer on the performance.\nSometimes, I would answer the first and last 20 questions in the 1st category, then answer the first and last 20 questions in the 2nd category, then hit the Reset button really fast and start over.   The more rendering it has to do, the faster the used memory will grow.\n\nAfter you do these things for about 15 to 20 minutes, go to the Error Log tab and see where you are with memory.  \nOnce I got the used memory to be between 500,000,000 and 700,000,000, I would put the app in the background, or just turn off the screen and let it sit for a few hours.  Then, I would pick it up and just answer and/or un-answer questions for 15 minutes or so, then let it sit overnight.\nBy the next morning, the memory is probably over 800,000,000 or even 900,000,000.  If the GC runs and knocks that number down, I\u0027d just scroll through the questions more and get it back up a little.  But try not to do it too fast, because you could risk apple aborting it due to resource issues.  If it crashes with nothing logged to the Error Log, look at the device\u0027s Privacy and Security -\u003e Analytics and Improvements -\u003e Analytics Data.  If you just get a \"cpu_resource.ips\" report instead of a regular .ips report, then apple caused it.  (This was the reason I had to start over my testing last week.)\nSo when I would get into the 800,000,000 - 900,000,000 range I would just go back to answering the first 10 or 11 questions of each category with o\u0027s and No\u0027s, hit the reset button, repeat.  So very little scrolling.  Could take a half hour or so of doing this but eventually it crashed.  \n\nHere is a screen shot of my Error Log:\n\n![Image](https://github.com/user-attachments/assets/d33b10af-767f-4611-974c-1aa9978f3322)\n\nHope this helps!",
                                           "updatedAt":  "2025-04-22T15:54:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6pXXz5",
                                           "createdAt":  "2025-04-30T10:07:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janusw",
                                           "body":  "We\u0027re seeing the same here with a .NET MAUI app on iOS. Total blocker for moving to .NET9.\nObserved with MAUI versions 9.0.50 and 9.0.60 and SDKs 9.0.201 and 9.0.203 (runtime versions 9.0.3 and 9.0.4).",
                                           "updatedAt":  "2025-04-30T10:07:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6pbZss",
                                           "createdAt":  "2025-04-30T16:17:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveisok",
                                           "body":  "\u003e We\u0027re seeing the same here with a .NET MAUI app on iOS. Total blocker for moving to .NET9. Observed with MAUI versions 9.0.50 and 9.0.60 and SDKs 9.0.201 and 9.0.203 (runtime versions 9.0.3 and 9.0.4).\n\nThanks - any repro or description of what you are doing in the lead up would be helpful. Are you seeing this on certain device types more often than others?  ",
                                           "updatedAt":  "2025-04-30T16:17:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6pyPXE",
                                           "createdAt":  "2025-05-03T08:29:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janusw",
                                           "body":  "\u003e \u003e We\u0027re seeing the same here with a .NET MAUI app on iOS. Total blocker for moving to .NET9. Observed with MAUI versions 9.0.50 and 9.0.60 and SDKs 9.0.201 and 9.0.203 (runtime versions 9.0.3 and 9.0.4).\n\u003e \n\u003e Thanks - any repro or description of what you are doing in the lead up would be helpful.\n\nAs others have reported here, we are also seeing crashes at random basically. The crashes have been observed in very different situations, including ones where the app is almost doing nothing at all (no user interactive for a while).\n\n\u003e Are you seeing this on certain device types more often than others?\n\nNot really. We\u0027ve seen it on various devices (including, for example, iPhone 14, iPhone 8, iPad Air 4th gen), and with various iOS versions (16 -18). Since the crash is occurring rarely and at random, it\u0027s hard to say if it occurs \"more often\" on a specific device.",
                                           "updatedAt":  "2025-05-03T08:29:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6pySOS",
                                           "createdAt":  "2025-05-03T09:04:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janusw",
                                           "body":  "Trying to approach this issue from the source-code side, I\u0027ve looked at the blame of [Task.RunContinuations](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Task.cs#L3455).\n\nThere is only one commit that is recent enough (added between net8.0 and net9.0) and has potential for causing this issue:\n7e5e2e7c9a585d5ff02776f9f489db69f9411211 by @pentp and @stephentoub.\n\nIt adds the following line in `RunContinuations`:\n\n```\nSpan\u003cobject?\u003e continuations = CollectionsMarshal.AsSpan(list);\n```\n\nLooking at the source of [CollectionsMarshal.AsSpan](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Runtime/InteropServices/CollectionsMarshal.cs#L22), it makes the following assertions:\n\n```\nDebug.Assert(items is not null, \"Implementation depends on List\u003cT\u003e always having an array.\");\n[..]\nDebug.Assert(typeof(T[]) == list._items.GetType(), \"Implementation depends on List\u003cT\u003e always using a T[] and not U[] where U : T.\");\n```\n\nCould it be that the crash is caused by one of these assertions not being fulfilled for some reason?\n\nThe documentation of `AsSpan` says:\n\n```\nItems should not be added or removed from the List{T} while the Span{T} is in use.\n```\n\nSo maybe the issue is caused by some sort of race condition, where the `continuationObject` parameter of `RunContinuations` is used/modified concurrently?",
                                           "updatedAt":  "2025-05-03T09:04:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6pygEv",
                                           "createdAt":  "2025-05-03T11:49:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janusw",
                                           "body":  "\n\u003e There is only one commit that is recent enough (added between net8.0 and net9.0) and has potential for causing this issue: [7e5e2e7](https://github.com/dotnet/runtime/commit/7e5e2e7c9a585d5ff02776f9f489db69f9411211) by [@pentp](https://github.com/pentp) and [@stephentoub](https://github.com/stephentoub).\n\u003e \n\u003e It adds the following line in `RunContinuations`:\n\u003e \n\u003e ```\n\u003e Span\u003cobject?\u003e continuations = CollectionsMarshal.AsSpan(list);\n\u003e ```\n\u003e \n\u003e [..]\n\u003e \n\u003e So maybe the issue is caused by some sort of race condition, where the `continuationObject` parameter of `RunContinuations` is used/modified concurrently?\n\nI see that there is some locking code in front of the `AsSpan` (which is supposed to avoid any such race conditions, I assume):\n\nhttps://github.com/dotnet/runtime/blob/6a3747bf868f5a7774c336103c0b48e7275958e5/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Task.cs#L3505-L3508\n\nHowever, the locking has also been modified in the commit above (from an acutal `lock` statement to using the `Monitor` class). And I find it somewhat unusual that the locking does not encompass the `AsSpan` line, but precedes it (which means that it technically does not guarantee to avoid all race conditions, right?).\n\nWhile I cannot prove that the commit mentioned above is the culprit that introduced this regression, I still think it\u0027s the most probable cause.\n\n[Note that I also blame-checked all the `Task.Finish...` and `Task.Execute...` methods that appear in the backterace, and apparently none of them have been modified recently.]",
                                           "updatedAt":  "2025-05-03T11:49:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6pyigy",
                                           "createdAt":  "2025-05-03T12:14:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janusw",
                                           "body":  "\n\u003e Project has `\u003cUseInterpreter\u003eTrue\u003c/UseInterpreter\u003e`\n\nI\u0027ll note that, like @wgriep and @EmilienDup, we\u0027re setting `UseInterpreter` to `True`. However, since @pme442\u0027s repro project does not seem to do that, it might not actually matter (?).\n\nAlso, we use:\n\n```\n\u003cTrimMode\u003epartial\u003c/TrimMode\u003e\n```",
                                           "updatedAt":  "2025-05-03T12:14:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6p15I_",
                                           "createdAt":  "2025-05-04T22:39:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pentp",
                                           "body":  "\u003e There is only one commit that is recent enough (added between net8.0 and net9.0) and has potential for causing this issue: [7e5e2e7](https://github.com/dotnet/runtime/commit/7e5e2e7c9a585d5ff02776f9f489db69f9411211) by [@pentp](https://github.com/pentp) and [@stephentoub](https://github.com/stephentoub).\n\u003e \n\u003e It adds the following line in `RunContinuations`:\n\u003e \n\u003e ```\n\u003e Span\u003cobject?\u003e continuations = CollectionsMarshal.AsSpan(list);\n\u003e ```\n\nThis commit did not weaken any lock guarantees, all accesses to the continuations list are still done under lock (or after the last locking operation in case of `RunContinuations`).",
                                           "updatedAt":  "2025-05-04T22:39:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6p45Rj",
                                           "createdAt":  "2025-05-05T08:27:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janusw",
                                           "body":  "\u003e \u003e There is only one commit that is recent enough (added between net8.0 and net9.0) and has potential for causing this issue: [7e5e2e7](https://github.com/dotnet/runtime/commit/7e5e2e7c9a585d5ff02776f9f489db69f9411211) by [@pentp](https://github.com/pentp) and [@stephentoub](https://github.com/stephentoub).\n\u003e \n\u003e This commit did not weaken any lock guarantees, all accesses to the continuations list are still done under lock (or after the last locking operation in case of `RunContinuations`).\n\nTrue, but shouldn\u0027t the access to the list in `RunContinuations` also be done \"under lock\" (not just \"after the last locking operation\")?\n\nI.e. instead of ...\n\n```\n            Monitor.Enter(list);\n            Monitor.Exit(list);\n            Span\u003cobject?\u003e continuations = CollectionsMarshal.AsSpan(list);\n```\n\nshouldn\u0027t it better be the following?\n```\n            Monitor.Enter(list);\n            Span\u003cobject?\u003e continuations = CollectionsMarshal.AsSpan(list);\n            Monitor.Exit(list);\n```\n\nOtherwise another locked access might be done simulteneously, while `AsSpan` is already executing, right? (unlikely as it may be)",
                                           "updatedAt":  "2025-05-05T08:27:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6p491Q",
                                           "createdAt":  "2025-05-05T08:34:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janusw",
                                           "body":  "\n\u003e \u003e This commit did not weaken any lock guarantees, all accesses to the continuations list are still done under lock (or after the last locking operation in case of `RunContinuations`).\n\u003e \n\u003e True, but shouldn\u0027t the access to the list in `RunContinuations` also be done \"under lock\" (not just \"after the last locking operation\")?\n\u003e \n\u003e ```\n\u003e             Monitor.Enter(list);\n\u003e             Monitor.Exit(list);\n\u003e             Span\u003cobject?\u003e continuations = CollectionsMarshal.AsSpan(list);\n\u003e ```\n\u003e \n\u003e Otherwise another locked access might be done simulteneously, while `AsSpan` is already executing, right? (unlikely as it may be)\n\nPlus, this would not only be a problem while to conversion to `Span` is being executed, but also while that `Span` is being used, according to the `AsSpan` documentation:\n\n```\nItems should not be added or removed from the List{T} while the Span{T} is in use.\n```",
                                           "updatedAt":  "2025-05-05T08:34:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6p5KvJ",
                                           "createdAt":  "2025-05-05T08:54:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janusw",
                                           "body":  "\n\u003e \u003e Otherwise another locked access might be done simulteneously, while `AsSpan` is already executing, right? (unlikely as it may be)\n\u003e \n\u003e Plus, this would not only be a problem while to conversion to `Span` is being executed, but also while that `Span` is being used, according to the `AsSpan` documentation:\n\u003e \n\u003e ```\n\u003e Items should not be added or removed from the List{T} while the Span{T} is in use.\n\u003e ```\n\n... and that is indeed a difference to the old .NET 8 implementation, where only the continuation count was determined up front, and could then be used safely in the subsequent loops.\n\nConverting to `Span` up front and then using `Span.Length` in subsequent loops does not seem to be thread-safe without proper locking. And it probably does not even improve performance, if all you need from the `Span` is its length.\n\n@stephentoub Could you possibly comment on this (as the reviewer of PR #93953)?",
                                           "updatedAt":  "2025-05-05T08:54:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6p66jv",
                                           "createdAt":  "2025-05-05T12:10:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pentp",
                                           "body":  "The operations in `RunContinuations` run after the task is marked completed and the lock is taken there just to guarantee all locking operations have completed. The locking there is still the same as before.",
                                           "updatedAt":  "2025-05-05T12:10:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6p7AtT",
                                           "createdAt":  "2025-05-05T12:20:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janusw",
                                           "body":  "\u003e The operations in `RunContinuations` run after the task is marked completed and the lock is taken there just to guarantee all locking operations have completed. The locking there is still the same as before.\n\nThanks for the comments, @pentp!\n\nSo, if you are sure that PR #93953 is not what caused this issue, do you possibly have an idea what else could cause InvalidCastExceptions in `Task.RunContinuations` with .NET 9 on iOS (which did not occur with .NET 8)?",
                                           "updatedAt":  "2025-05-05T12:20:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6p7wuZ",
                                           "createdAt":  "2025-05-05T13:28:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEQ28_Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "CONFUSED",
                                                                               "user":  "Pablo-Sierra",
                                                                               "createdAt":  "2025-05-05T19:50:33Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "steveisok",
                                           "body":  "\u003e So, if you are sure that PR [#93953](https://github.com/dotnet/runtime/pull/93953) is not what caused this issue, do you possibly have an idea what else could cause InvalidCastExceptions in `Task.RunContinuations` with .NET 9 on iOS (which did not occur with .NET 8)?\n\nThat\u0027s what we\u0027re trying to figure out by surfacing the first exception, but we have been unsuccessful reproducing anything to this point. I do think it\u0027s something unique to the iOS runtime in .NET 9. ",
                                           "updatedAt":  "2025-05-05T13:28:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6p9RwQ",
                                           "createdAt":  "2025-05-05T15:43:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEQ3CMg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "Pablo-Sierra",
                                                                               "createdAt":  "2025-05-05T19:44:50Z"
                                                                           },
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "pme442",
                                                                               "createdAt":  "2025-05-05T20:00:55Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "janusw",
                                           "body":  "\u003e \u003e So, if you are sure that PR [#93953](https://github.com/dotnet/runtime/pull/93953) is not what caused this issue, do you possibly have an idea what else could cause InvalidCastExceptions in `Task.RunContinuations` with .NET 9 on iOS (which did not occur with .NET 8)?\n\u003e \n\u003e That\u0027s what we\u0027re trying to figure out by surfacing the first exception, but we have been unsuccessful reproducing anything to this point.\n\nIs there anything one can do to help debug this? Due to the ghostly nature of this issue, I think it will be hard to create a reliable reproducer (plus, my app is closed-source). Even worse: It only seems to occur in Release builds.\n\nSo, if I manage to hit the exception by chance, what can I do to debug and pinpoint it?\n\n",
                                           "updatedAt":  "2025-05-05T15:43:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6qAUa2",
                                           "createdAt":  "2025-05-05T20:07:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "linnkrb",
                                           "body":  "We also have this exact same problem and it´s driving us mad.  All worked well before upgrading to .net9. We have a few background task that updates data every 15 min, some ui related updates every 15 seconds, and after a random number of times it just crashes. Some times it can take a pretty long time, but it feels pretty ransom. The app can be idle except for the background updates.\n\nI´ll just drop here all  our findings and hope someone can get good use of it and figure out how to solve it.\n\n`System.InvalidCastException:\n   at System.Threading.Tasks.Task.RunContinuations (System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\n   at System.Threading.Tasks.Task.FinishContinuations (System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\n   at System.Threading.Tasks.Task.FinishStageThree (System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\n   at System.Threading.Tasks.Task.FinishStageTwo (System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\n   at System.Threading.Tasks.Task.Finish (System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal (System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\n   at System.Threading.Tasks.Task.ExecuteEntryUnsafe (System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\n   at System.Threading.Tasks.Task.ExecuteFromThreadPool (System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\n   at System.Threading.ThreadPoolWorkQueue.DispatchWorkItem (System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\n   at System.Threading.ThreadPoolWorkQueue.DispatchItemWithAutoreleasePool (System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\n   at System.Threading.ThreadPoolWorkQueue.Dispatch (System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\n   at System.Threading.PortableThreadPool+WorkerThread.WorkerDoWork (System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\n   at System.Threading.PortableThreadPool+WorkerThread.WorkerThreadStart (System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\n\n`\n\n\u003cimg width=\"510\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/b70a68c4-1d94-459b-addb-58f9a34c988f\" /\u003e\n\n`Incident Identifier: 28AD7BBA-770F-46EB-ABC8-8CEF07A29AC5\nDistributor ID:      com.apple.TestFlight\nHardware Model:      iPad16,1\nProcess:             FrontSystems [817]\nPath:                /private/var/containers/Bundle/Application/935093F6-569C-4A31-96A9-343E5D6A669D/FrontSystems.app/FrontSystems\nIdentifier:          no.frontsystems.cornerstone\nVersion:             2.0.1 (208)\nAppStoreTools:       16E137\nAppVariant:          1:iPad16,1:18\nBeta:                YES\nCode Type:           ARM-64 (Native)\nRole:                Foreground\nParent Process:      launchd [1]\nCoalition:           no.frontsystems.cornerstone [672]\n\nDate/Time:           2025-05-05 19:50:55.9033 +0200\nLaunch Time:         2025-05-05 19:50:43.5463 +0200\nOS Version:          iPhone OS 18.4.1 (22E252)\nRelease Type:        User\nReport Version:      104\n\nException Type:  EXC_CRASH (SIGABRT)\nException Codes: 0x0000000000000000, 0x0000000000000000\nTermination Reason: SIGNAL 6 Abort trap: 6\nTerminating Process: FrontSystems [817]\n\nTriggered by Thread:  20\n\n\nThread 0 name:\nThread 0 name:\nThread 0:\n0   libsystem_kernel.dylib        \t0x00000001d91ffce4 mach_msg2_trap + 8 (:-1)\n1   libsystem_kernel.dylib        \t0x00000001d920339c mach_msg2_internal + 76 (mach_msg.c:201)\n2   libsystem_kernel.dylib        \t0x00000001d92032b8 mach_msg_overwrite + 428 (mach_msg.c:0)\n3   libsystem_kernel.dylib        \t0x00000001d9203100 mach_msg + 24 (mach_msg.c:323)\n4   CoreFoundation                \t0x00000001886746cc __CFRunLoopServiceMachPort + 160 (CFRunLoop.c:2637)\n5   CoreFoundation                \t0x0000000188673dac __CFRunLoopRun + 1208 (CFRunLoop.c:3021)\n6   CoreFoundation                \t0x0000000188698700 CFRunLoopRunSpecific + 572 (CFRunLoop.c:3434)\n7   GraphicsServices              \t0x00000001d51d9190 GSEventRunModal + 168 (GSEvent.c:2196)\n8   UIKitCore                     \t0x000000018b2b6240 -[UIApplication _run] + 816 (UIApplication.m:3845)\n9   UIKitCore                     \t0x000000018b2b4470 UIApplicationMain + 336 (UIApplication.m:5540)\n10  FrontSystems                  \t0x00000001035e84b0 xamarin_UIApplicationMain (in FrontSystems) (bindings.m:131) + 8897712\n11  FrontSystems                  \t0x00000001037f918c do_icall (in FrontSystems) (interp.c:2426) + 11063692\n12  FrontSystems                  \t0x00000001037f7760 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 11056992\n13  FrontSystems                  \t0x00000001037ec7bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n14  FrontSystems                  \t0x00000001037ea388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n15  FrontSystems                  \t0x00000001037ae0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n16  FrontSystems                  \t0x000000010374a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n17  FrontSystems                  \t0x00000001037515d8 mono_runtime_exec_main_checked (in FrontSystems) (object.c:4808) + 10376664\n18  FrontSystems                  \t0x00000001037b5b14 mono_jit_exec (in FrontSystems) (driver.c:1311) + 10787604\n19  FrontSystems                  \t0x00000001035fcaec xamarin_main (in FrontSystems) (monotouch-main.m:0) + 8981228\n20  FrontSystems                  \t0x00000001039b711c main (in FrontSystems) (main.arm64.mm:81) + 12890396\n21  dyld                          \t0x00000001af09bad8 start + 5964 (dyldMain.cpp:1443)\n\nThread 1 name:\nThread 1:\n0   libsystem_kernel.dylib        \t0x00000001d9205438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x0000000212ae92fc _pthread_cond_wait + 984 (pthread_cond.c:862)\n2   FrontSystems                  \t0x00000001036d59b4 thread_func (in FrontSystems) (sgen-thread-pool.c:195) + 9869748\n3   libsystem_pthread.dylib       \t0x0000000212ae7afc _pthread_start + 136 (pthread.c:931)\n4   libsystem_pthread.dylib       \t0x0000000212ae7a04 thread_start + 8 (:-1)\n\nThread 2 name:\nThread 2:\n0   libsystem_kernel.dylib        \t0x00000001d91ffc60 semaphore_wait_trap + 8 (:-1)\n1   FrontSystems                  \t0x000000010378b178 finalizer_thread (in FrontSystems) (gc.c:868) + 10613112\n2   FrontSystems                  \t0x000000010376417c start_wrapper (in FrontSystems) (threads.c:1276) + 10453372\n3   libsystem_pthread.dylib       \t0x0000000212ae7afc _pthread_start + 136 (pthread.c:931)\n4   libsystem_pthread.dylib       \t0x0000000212ae7a04 thread_start + 8 (:-1)\n\nThread 3:\n0   libsystem_pthread.dylib       \t0x0000000212ae79f0 start_wqthread + 0 (:-1)\n\nThread 4:\n0   libsystem_pthread.dylib       \t0x0000000212ae79f0 start_wqthread + 0 (:-1)\n\nThread 5 name:\nThread 5:\n0   libsystem_kernel.dylib        \t0x00000001d91ffce4 mach_msg2_trap + 8 (:-1)\n1   libsystem_kernel.dylib        \t0x00000001d920339c mach_msg2_internal + 76 (mach_msg.c:201)\n2   libsystem_kernel.dylib        \t0x00000001d92032b8 mach_msg_overwrite + 428 (mach_msg.c:0)\n3   libsystem_kernel.dylib        \t0x00000001d9203100 mach_msg + 24 (mach_msg.c:323)\n4   CoreFoundation                \t0x00000001886746cc __CFRunLoopServiceMachPort + 160 (CFRunLoop.c:2637)\n5   CoreFoundation                \t0x0000000188673dac __CFRunLoopRun + 1208 (CFRunLoop.c:3021)\n6   CoreFoundation                \t0x0000000188698700 CFRunLoopRunSpecific + 572 (CFRunLoop.c:3434)\n7   Foundation                    \t0x00000001872da8a8 -[NSRunLoop(NSRunLoop) runMode:beforeDate:] + 212 (NSRunLoop.m:375)\n8   Foundation                    \t0x00000001872d96d8 -[NSRunLoop(NSRunLoop) runUntilDate:] + 64 (NSRunLoop.m:422)\n9   UIKitCore                     \t0x000000018b3a95ec -[UIEventFetcher threadMain] + 424 (UIEventFetcher.m:1351)\n10  Foundation                    \t0x000000018737bcf8 __NSThread__start__ + 732 (NSThread.m:991)\n11  libsystem_pthread.dylib       \t0x0000000212ae7afc _pthread_start + 136 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x0000000212ae7a04 thread_start + 8 (:-1)\n\nThread 6:\n0   libsystem_pthread.dylib       \t0x0000000212ae79f0 start_wqthread + 0 (:-1)\n\nThread 7 name:\nThread 7:\n0   libsystem_kernel.dylib        \t0x00000001d9205438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x0000000212ae92fc _pthread_cond_wait + 984 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000103685724 mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9541412\n3   FrontSystems                  \t0x0000000103689ae0 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9558752\n4   FrontSystems                  \t0x00000001037f9100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n5   FrontSystems                  \t0x00000001037f7798 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 11057048\n6   FrontSystems                  \t0x00000001037ec7bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n7   FrontSystems                  \t0x00000001037ea388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n8   FrontSystems                  \t0x00000001037ae0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n9   FrontSystems                  \t0x000000010374a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n10  FrontSystems                  \t0x0000000103764270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n11  libsystem_pthread.dylib       \t0x0000000212ae7afc _pthread_start + 136 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x0000000212ae7a04 thread_start + 8 (:-1)\n\nThread 8 name:\nThread 8:\n0   libsystem_kernel.dylib        \t0x00000001d9205438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x0000000212ae9328 _pthread_cond_wait + 1028 (pthread_cond.c:862)\n2   FrontSystems                  \t0x000000010365e818 SystemNative_LowLevelMonitor_TimedWait (in FrontSystems) (pal_threading.c:198) + 9381912\n3   FrontSystems                  \t0x00000001037f9100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n4   FrontSystems                  \t0x00000001037f7760 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 11056992\n5   FrontSystems                  \t0x00000001037ec7bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n6   FrontSystems                  \t0x00000001037ea388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n7   FrontSystems                  \t0x00000001037ae0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n8   FrontSystems                  \t0x000000010374a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n9   FrontSystems                  \t0x0000000103764270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n10  libsystem_pthread.dylib       \t0x0000000212ae7afc _pthread_start + 136 (pthread.c:931)\n11  libsystem_pthread.dylib       \t0x0000000212ae7a04 thread_start + 8 (:-1)\n\nThread 9 name:\nThread 9:\n0   libsystem_kernel.dylib        \t0x00000001d9205438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x0000000212ae9328 _pthread_cond_wait + 1028 (pthread_cond.c:862)\n2   FrontSystems                  \t0x000000010365e818 SystemNative_LowLevelMonitor_TimedWait (in FrontSystems) (pal_threading.c:198) + 9381912\n3   FrontSystems                  \t0x00000001037f9100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n4   FrontSystems                  \t0x00000001037f7760 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 11056992\n5   FrontSystems                  \t0x00000001037ec7bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n6   FrontSystems                  \t0x00000001037ea388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n7   FrontSystems                  \t0x00000001037ae0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n8   FrontSystems                  \t0x000000010374a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n9   FrontSystems                  \t0x0000000103764270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n10  libsystem_pthread.dylib       \t0x0000000212ae7afc _pthread_start + 136 (pthread.c:931)\n11  libsystem_pthread.dylib       \t0x0000000212ae7a04 thread_start + 8 (:-1)\n\nThread 10 name:\nThread 10:\n0   libsystem_kernel.dylib        \t0x00000001d9205438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x0000000212ae9328 _pthread_cond_wait + 1028 (pthread_cond.c:862)\n2   FrontSystems                  \t0x000000010365e818 SystemNative_LowLevelMonitor_TimedWait (in FrontSystems) (pal_threading.c:198) + 9381912\n3   FrontSystems                  \t0x00000001037f9100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n4   FrontSystems                  \t0x00000001037f7760 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 11056992\n5   FrontSystems                  \t0x00000001037ec7bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n6   FrontSystems                  \t0x00000001037ea388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n7   FrontSystems                  \t0x00000001037ae0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n8   FrontSystems                  \t0x000000010374a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n9   FrontSystems                  \t0x0000000103764270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n10  libsystem_pthread.dylib       \t0x0000000212ae7afc _pthread_start + 136 (pthread.c:931)\n11  libsystem_pthread.dylib       \t0x0000000212ae7a04 thread_start + 8 (:-1)\n\nThread 11 name:\nThread 11:\n0   libsystem_kernel.dylib        \t0x00000001d9205438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x0000000212ae9328 _pthread_cond_wait + 1028 (pthread_cond.c:862)\n2   FrontSystems                  \t0x000000010365e818 SystemNative_LowLevelMonitor_TimedWait (in FrontSystems) (pal_threading.c:198) + 9381912\n3   FrontSystems                  \t0x00000001037f9100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n4   FrontSystems                  \t0x00000001037f7760 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 11056992\n5   FrontSystems                  \t0x00000001037ec7bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n6   FrontSystems                  \t0x00000001037ea388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n7   FrontSystems                  \t0x00000001037ae0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n8   FrontSystems                  \t0x000000010374a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n9   FrontSystems                  \t0x0000000103764270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n10  libsystem_pthread.dylib       \t0x0000000212ae7afc _pthread_start + 136 (pthread.c:931)\n11  libsystem_pthread.dylib       \t0x0000000212ae7a04 thread_start + 8 (:-1)\n\nThread 12 name:\nThread 12:\n0   libsystem_kernel.dylib        \t0x00000001d9206768 kevent + 8 (:-1)\n1   FrontSystems                  \t0x000000010365c9b4 SystemNative_WaitForSocketEvents (in FrontSystems) (pal_networking.c:3256) + 9374132\n2   FrontSystems                  \t0x00000001037f912c do_icall (in FrontSystems) (interp.c:2402) + 11063596\n3   FrontSystems                  \t0x00000001037f7760 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 11056992\n4   FrontSystems                  \t0x00000001037ec7bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n5   FrontSystems                  \t0x00000001037ea388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n6   FrontSystems                  \t0x00000001037ae0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n7   FrontSystems                  \t0x000000010374a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n8   FrontSystems                  \t0x0000000103764270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n9   libsystem_pthread.dylib       \t0x0000000212ae7afc _pthread_start + 136 (pthread.c:931)\n10  libsystem_pthread.dylib       \t0x0000000212ae7a04 thread_start + 8 (:-1)\n\nThread 13 name:\nThread 13:\n0   libsystem_kernel.dylib        \t0x00000001d9205438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x0000000212ae92fc _pthread_cond_wait + 984 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000103685724 mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9541412\n3   FrontSystems                  \t0x0000000103689ae0 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9558752\n4   FrontSystems                  \t0x00000001037f9100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n5   FrontSystems                  \t0x00000001037f7798 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 11057048\n6   FrontSystems                  \t0x00000001037ec7bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n7   FrontSystems                  \t0x00000001037ea388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n8   FrontSystems                  \t0x00000001037ae0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n9   FrontSystems                  \t0x000000010374a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n10  FrontSystems                  \t0x0000000103764270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n11  libsystem_pthread.dylib       \t0x0000000212ae7afc _pthread_start + 136 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x0000000212ae7a04 thread_start + 8 (:-1)\n\nThread 14 name:\nThread 14:\n0   libsystem_kernel.dylib        \t0x00000001d9205438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x0000000212ae92fc _pthread_cond_wait + 984 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000103685724 mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9541412\n3   FrontSystems                  \t0x0000000103689ae0 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9558752\n4   FrontSystems                  \t0x00000001037f9100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n5   FrontSystems                  \t0x00000001037f7798 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 11057048\n6   FrontSystems                  \t0x00000001037ec7bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n7   FrontSystems                  \t0x00000001037ea388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n8   FrontSystems                  \t0x00000001037ae0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n9   FrontSystems                  \t0x000000010374a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n10  FrontSystems                  \t0x0000000103764270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n11  libsystem_pthread.dylib       \t0x0000000212ae7afc _pthread_start + 136 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x0000000212ae7a04 thread_start + 8 (:-1)\n\nThread 15 name:\nThread 15:\n0   libsystem_kernel.dylib        \t0x00000001d9205438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x0000000212ae92fc _pthread_cond_wait + 984 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000103685724 mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9541412\n3   FrontSystems                  \t0x0000000103689ae0 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9558752\n4   FrontSystems                  \t0x00000001037f9100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n5   FrontSystems                  \t0x00000001037f7798 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 11057048\n6   FrontSystems                  \t0x00000001037ec7bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n7   FrontSystems                  \t0x00000001037ea388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n8   FrontSystems                  \t0x00000001037ae0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n9   FrontSystems                  \t0x000000010374a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n10  FrontSystems                  \t0x0000000103764270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n11  libsystem_pthread.dylib       \t0x0000000212ae7afc _pthread_start + 136 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x0000000212ae7a04 thread_start + 8 (:-1)\n\nThread 16:\n0   libsystem_pthread.dylib       \t0x0000000212ae79f0 start_wqthread + 0 (:-1)\n\nThread 17:\n0   libsystem_pthread.dylib       \t0x0000000212ae79f0 start_wqthread + 0 (:-1)\n\nThread 18:\n0   libsystem_pthread.dylib       \t0x0000000212ae79f0 start_wqthread + 0 (:-1)\n\nThread 19 name:\nThread 19:\n0   libsystem_kernel.dylib        \t0x00000001d9205438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x0000000212ae92fc _pthread_cond_wait + 984 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000103685724 mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9541412\n3   FrontSystems                  \t0x0000000103689ae0 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9558752\n4   FrontSystems                  \t0x00000001037f9100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n5   FrontSystems                  \t0x00000001037f7798 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 11057048\n6   FrontSystems                  \t0x00000001037ec7bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n7   FrontSystems                  \t0x00000001037ea388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n8   FrontSystems                  \t0x00000001037ae0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n9   FrontSystems                  \t0x000000010374a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n10  FrontSystems                  \t0x0000000103764270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n11  libsystem_pthread.dylib       \t0x0000000212ae7afc _pthread_start + 136 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x0000000212ae7a04 thread_start + 8 (:-1)\n\nThread 20 name:\nThread 20 Crashed:\n0   libsystem_kernel.dylib        \t0x00000001d920a1dc __pthread_kill + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x0000000212aedb40 pthread_kill + 268 (pthread.c:1721)\n2   libsystem_c.dylib             \t0x000000019063d2d0 abort + 124 (abort.c:122)\n3   FrontSystems                  \t0x0000000103a10c24 0x0000000100ca4c24 (in FrontSystems) + 13257764\n4   FrontSystems                  \t0x00000001037e86cc mono_runtime_setup_stat_profiler (in FrontSystems) (mini-posix.c:692) + 10995404\n5   libsystem_platform.dylib      \t0x0000000212a3eeec _sigtramp + 56 (sigtramp.c:116)\n6   libsystem_pthread.dylib       \t0x0000000212aedb40 pthread_kill + 268 (pthread.c:1721)\n7   libsystem_c.dylib             \t0x000000019063d2d0 abort + 124 (abort.c:122)\n8   FrontSystems                  \t0x00000001035f3148 xamarin_find_protocol_wrapper_type (in FrontSystems) (runtime.m:1218) + 8941896\n9   FrontSystems                  \t0x00000001037001c4 mono_invoke_unhandled_exception_hook (in FrontSystems) (exception.c:1263) + 10043844\n10  FrontSystems                  \t0x00000001037644bc start_wrapper (in FrontSystems) (threads.c:1276) + 10454204\n11  libsystem_pthread.dylib       \t0x0000000212ae7afc _pthread_start + 136 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x0000000212ae7a04 thread_start + 8 (:-1)\n\nThread 21 name:\nThread 21:\n0   libsystem_kernel.dylib        \t0x00000001d9205438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x0000000212ae92fc _pthread_cond_wait + 984 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000103685724 mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9541412\n3   FrontSystems                  \t0x0000000103689ae0 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9558752\n4   FrontSystems                  \t0x00000001037f9100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n5   FrontSystems                  \t0x00000001037f7798 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 11057048\n6   FrontSystems                  \t0x00000001037ec7bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n7   FrontSystems                  \t0x00000001037ea388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n8   FrontSystems                  \t0x00000001037ae0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n9   FrontSystems                  \t0x000000010374a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n10  FrontSystems                  \t0x0000000103764270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n11  libsystem_pthread.dylib       \t0x0000000212ae7afc _pthread_start + 136 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x0000000212ae7a04 thread_start + 8 (:-1)\n\nThread 22 name:\nThread 22:\n0   libsystem_kernel.dylib        \t0x00000001d9205438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x0000000212ae92fc _pthread_cond_wait + 984 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000103685724 mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9541412\n3   FrontSystems                  \t0x0000000103689ae0 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9558752\n4   FrontSystems                  \t0x00000001037f9100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n5   FrontSystems                  \t0x00000001037f7798 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 11057048\n6   FrontSystems                  \t0x00000001037ec7bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n7   FrontSystems                  \t0x00000001037ea388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n8   FrontSystems                  \t0x00000001037ae0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n9   FrontSystems                  \t0x000000010374a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n10  FrontSystems                  \t0x0000000103764270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n11  libsystem_pthread.dylib       \t0x0000000212ae7afc _pthread_start + 136 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x0000000212ae7a04 thread_start + 8 (:-1)\n\nThread 23 name:\nThread 23:\n0   libsystem_kernel.dylib        \t0x00000001d9205438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x0000000212ae92fc _pthread_cond_wait + 984 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000103685724 mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9541412\n3   FrontSystems                  \t0x0000000103689ae0 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9558752\n4   FrontSystems                  \t0x00000001037f9100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n5   FrontSystems                  \t0x00000001037f7798 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 11057048\n6   FrontSystems                  \t0x00000001037ec7bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n7   FrontSystems                  \t0x00000001037ea388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n8   FrontSystems                  \t0x00000001037ae0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n9   FrontSystems                  \t0x000000010374a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n10  FrontSystems                  \t0x0000000103764270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n11  libsystem_pthread.dylib       \t0x0000000212ae7afc _pthread_start + 136 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x0000000212ae7a04 thread_start + 8 (:-1)\n\nThread 24 name:\nThread 24:\n0   libsystem_kernel.dylib        \t0x00000001d9205438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x0000000212ae92fc _pthread_cond_wait + 984 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000103685724 mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9541412\n3   FrontSystems                  \t0x0000000103689ae0 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9558752\n4   FrontSystems                  \t0x00000001037f9100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n5   FrontSystems                  \t0x00000001037f7798 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 11057048\n6   FrontSystems                  \t0x00000001037ec7bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n7   FrontSystems                  \t0x00000001037ea388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n8   FrontSystems                  \t0x00000001037ae0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n9   FrontSystems                  \t0x000000010374a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n10  FrontSystems                  \t0x0000000103764270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n11  libsystem_pthread.dylib       \t0x0000000212ae7afc _pthread_start + 136 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x0000000212ae7a04 thread_start + 8 (:-1)\n\nThread 25 name:\nThread 25:\n0   libsystem_kernel.dylib        \t0x00000001d9205438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x0000000212ae92fc _pthread_cond_wait + 984 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000103685724 mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9541412\n3   FrontSystems                  \t0x0000000103689ae0 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9558752\n4   FrontSystems                  \t0x00000001037f9100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n5   FrontSystems                  \t0x00000001037f7798 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 11057048\n6   FrontSystems                  \t0x00000001037ec7bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n7   FrontSystems                  \t0x00000001037ea388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n8   FrontSystems                  \t0x00000001037ae0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n9   FrontSystems                  \t0x000000010374a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n10  FrontSystems                  \t0x0000000103764270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n11  libsystem_pthread.dylib       \t0x0000000212ae7afc _pthread_start + 136 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x0000000212ae7a04 thread_start + 8 (:-1)\n\nThread 26 name:\nThread 26:\n0   libsystem_kernel.dylib        \t0x00000001d9205438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x0000000212ae92fc _pthread_cond_wait + 984 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000103685724 mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9541412\n3   FrontSystems                  \t0x0000000103689ae0 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9558752\n4   FrontSystems                  \t0x00000001037f9100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n5   FrontSystems                  \t0x00000001037f7798 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 11057048\n6   FrontSystems                  \t0x00000001037ec7bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n7   FrontSystems                  \t0x00000001037ea388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n8   FrontSystems                  \t0x00000001037ae0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n9   FrontSystems                  \t0x000000010374a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n10  FrontSystems                  \t0x0000000103764270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n11  libsystem_pthread.dylib       \t0x0000000212ae7afc _pthread_start + 136 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x0000000212ae7a04 thread_start + 8 (:-1)\n\n\nThread 20 crashed with ARM Thread State (64-bit):\n    x0: 0x0000000000000000   x1: 0x0000000000000000   x2: 0x0000000000000000   x3: 0x0000000000000000\n    x4: 0xffffffff94e56dff   x5: 0x0000000000000018   x6: 0x000000016ecfa570   x7: 0x000000016ecf9c60\n    x8: 0x69477f8af3917d1e   x9: 0x69477f8b9d5ecd1e  x10: 0x00000000000003ff  x11: 0x000000016ecf9cd8\n   x12: 0x0000000000000000  x13: 0x00000001035cb4b8  x14: 0x0000000000000001  x15: 0x0000000000000001\n   x16: 0x0000000000000148  x17: 0x000000016ecfb000  x18: 0x0000000000000000  x19: 0x0000000000000006\n   x20: 0x000000000000be13  x21: 0x000000016ecfb0e0  x22: 0x00000001260d4000  x23: 0x000000016ecfb000\n   x24: 0x0000000000000000  x25: 0x0000000000000000  x26: 0x0000000103fa5668  x27: 0x0000000000000000\n   x28: 0x0000000000000000   fp: 0x000000016ecfa580   lr: 0x0000000212aedb40\n    sp: 0x000000016ecfa560   pc: 0x00000001d920a1dc cpsr: 0x40001000\n   esr: 0x56000080  Address size fault\n\n\nBinary Images:\n        0x102d6c000 -         0x103bdbfff FrontSystems arm64  \u003ce70c0e522bff3e98993c53b6f31b0818\u003e /var/containers/Bundle/Application/935093F6-569C-4A31-96A9-343E5D6A669D/FrontSystems.app/FrontSystems\n        0x104064000 -         0x1041abfff libHarfBuzzSharp arm64  \u003c8ca693a9d0533072850919c5df43d67e\u003e /private/var/containers/Bundle/Application/935093F6-569C-4A31-96A9-343E5D6A669D/FrontSystems.app/Frameworks/libHarfBuzzSharp.framework/libHarfBuzzSharp\n        0x1043bc000 -         0x10491bfff libSkiaSharp arm64  \u003c6b45b7dee11f31139b1f1aff7553de02\u003e /private/var/containers/Bundle/Application/935093F6-569C-4A31-96A9-343E5D6A669D/FrontSystems.app/Frameworks/libSkiaSharp.framework/libSkiaSharp\n        0x10ae08000 -         0x10ae13fff libobjc-trampolines.dylib arm64e  \u003c7b2292ed23143e4f929b2831fc172b43\u003e /private/preboot/Cryptexes/OS/usr/lib/libobjc-trampolines.dylib\n        0x187266000 -         0x187eef5ff Foundation arm64e  \u003c2bd7eb532f573300b8de478229e49115\u003e /System/Library/Frameworks/Foundation.framework/Foundation\n        0x188603000 -         0x188b7ffff CoreFoundation arm64e  \u003c0551baa3c6e93423b0e2be69719c1d7f\u003e /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation\n        0x18aeec000 -         0x18ce2ca1f UIKitCore arm64e  \u003c05197341f99832e5a847da98bb8c68bf\u003e /System/Library/PrivateFrameworks/UIKitCore.framework/UIKitCore\n        0x1905c6000 -         0x1906458b7 libsystem_c.dylib arm64e  \u003c027de04c2929357bb6a3701405aab6be\u003e /usr/lib/system/libsystem_c.dylib\n        0x1af08b000 -         0x1af125013 dyld arm64e  \u003c189fe4805d5b3b89928958bc88624420\u003e /usr/lib/dyld\n        0x1d51d8000 -         0x1d51e0c5f GraphicsServices arm64e  \u003cc620bafa568e3bcbb31776c829cbdd46\u003e /System/Library/PrivateFrameworks/GraphicsServices.framework/GraphicsServices\n        0x1d91ff000 -         0x1d9238b77 libsystem_kernel.dylib arm64e  \u003c9d196db4701331768c025b4c68701c92\u003e /usr/lib/system/libsystem_kernel.dylib\n        0x212a3b000 -         0x212a42627 libsystem_platform.dylib arm64e  \u003c9b52c74387943d229564b6bcf3303389\u003e /usr/lib/system/libsystem_platform.dylib\n        0x212ae6000 -         0x212af23fb libsystem_pthread.dylib arm64e  \u003c00306a1f11183f8690bdd18b5ed5409f\u003e /usr/lib/system/libsystem_pthread.dylib\n\nEOF\n`\n`GitHub Copilot suggestion:\n\nThe crash report indicates that Thread 20 crashed due to an EXC_CRASH (SIGABRT), which is caused by an explicit call to abort(). Below is an analysis of the crash and what can be inferred from the report.\n\nKey Findings from the Crash Report\nCrash Cause:\n\nException Type: EXC_CRASH (SIGABRT)\nTermination Reason: SIGNAL 6 Abort trap: 6\nThe crash was triggered by an explicit call to abort() in the code.\nTriggered by Thread: Thread 20\n\nThe crash occurred in mono_runtime_setup_stat_profiler (mini-posix.c:692).\nThis suggests an issue related to the Mono runtime, possibly involving profiling or exception handling.\nCrash Context:\n\nThe stack trace shows that the crash occurred in the Mono runtime, specifically in mono_runtime_setup_stat_profiler.\nThe crash propagated through xamarin_find_protocol_wrapper_type and mono_invoke_unhandled_exception_hook, indicating that an unhandled exception might have occurred.\nStack Trace Highlights:\n\nThe crash occurred in the Mono runtime\u0027s thread management (start_wrapper in threads.c).\nThe call to pthread_kill and abort indicates that the process was terminated intentionally due to a critical error.\nThread 20\u0027s Role:\n\nThread 20 appears to be executing application code via the Mono runtime. The crash occurred while handling an unhandled exception or setting up a profiler.\nObservations\nUnhandled Exception:\n\nThe stack trace shows a call to mono_invoke_unhandled_exception_hook, indicating that an unhandled exception occurred in the application.\nSIGABRT:\n\nThe crash was caused by an explicit call to abort(), likely due to a critical error in the app\u0027s logic or runtime environment.\nMono Runtime Involvement:\n\nThe involvement of mini-posix.c and runtime.m suggests the issue might be related to the Mono runtime or its interaction with the app.\nNext Steps\nSymbolicate the Crash Log:\n\nUse the symbolication script to identify the exact function and line number where the crash occurred.\nInvestigate the Root Cause:\n\nCheck for unhandled exceptions or invalid states in the identified function.\nReview the logic around mono_runtime_setup_stat_profiler and mono_invoke_unhandled_exception_hook.\nReview Mono Runtime Configuration:\n\nEnsure the Mono runtime is properly configured and up to date.\nCheck for any custom configurations or modifications that might affect its behavior.\nTest in Debug Mode:\n\nRun the app in debug mode with additional logging enabled to capture more details about the crash.\nEnable Debug Symbols for Production:\n\nIf necessary, enable \u003cDebugSymbols\u003etrue\u003c/DebugSymbols\u003e for production builds to get more detailed stack traces.\nSummary\nThe crash was caused by an unhandled exception or critical error in the Mono runtime, leading to an explicit call to abort(). The issue likely involves the Mono runtime\u0027s thread management or exception handling. Further investigation is needed to pinpoint the root cause.\n\nLet me know if you need help interpreting the symbolicated output or further investigating the crash!",
                                           "updatedAt":  "2025-05-05T20:31:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6qA8py",
                                           "createdAt":  "2025-05-05T21:25:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "linnkrb",
                                           "body":  "\u003e We facing with the same problem. The app crashes randomly with Arg_InvalidCastException exception with the same stack as provided above. We just moved the app from Xamarin forms to MAUI9 and facing with this issue on release builds only. I was not able to reproduce it locally. The app periodically syncing data with the backend by making 14 http requests at the same time and updating data in the local sqlite database. To work with database we use sqlite-net-pcl 1.9.172. According to Sentry breadcrumbs and the app logs, the crash always happening somewhere in the end of the sync iteration, but this happening not that often, usually it\u0027s finishing without any issues. I assume that this is somehow related to running multiple tasks in parallel or waiting them using Task.WhenAll. We were facing the issue when using MAUI 9.0.50(workload version is 9.0.14/9.0.100). Today we updated MAUI to 9.0.60 and testing. I will update if it helps.\n\nThis looks very much like our setup",
                                           "updatedAt":  "2025-05-05T21:25:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6qDm82",
                                           "createdAt":  "2025-05-06T02:11:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEQ86gA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "am11",
                                                                               "createdAt":  "2025-05-06T02:21:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "Pablo-Sierra",
                                                                               "createdAt":  "2025-05-06T06:36:05Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "linnkrb",
                                                                               "createdAt":  "2025-05-06T06:51:24Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "afk013",
                                                                               "createdAt":  "2025-05-06T09:46:16Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "steveisok",
                                           "body":  "\u003e Is there anything one can do to help debug this? Due to the ghostly nature of this issue, I think it will be hard to create a reliable reproducer (plus, my app is closed-source). Even worse: It only seems to occur in Release builds.\n\u003e \n\u003e So, if I manage to hit the exception by chance, what can I do to debug and pinpoint it?\n\nIf you are up for it, can you use this runtime pack built from a [fork](https://github.com/dotnet/runtime/compare/release/9.0...kotlarmilos:runtime:release9.0/bugfix/task-finish-continuations-sentinel?expand=1) of our public 9.0 runtime branch?\n\nAll you have to do within your project is add a nuget.config if you don\u0027t have one and add a local feed. We think this will surface an exception unique to iOS and may help us pinpoint the issue.\n\n```\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\n\u003cconfiguration\u003e\n  \u003cpackageSources\u003e\n    \u003cclear /\u003e\n    \u003cadd key=\"LocalRuntime\" value=\"\u003cpath-to-package-dir-goes-here\u003e\" /\u003e\n    \u003cadd key=\"nuget.org\"      value=\"https://api.nuget.org/v3/index.json\" /\u003e\n  \u003c/packageSources\u003e\n\n  \u003cpackageSourceMapping\u003e\n    \u003cpackageSource key=\"LocalRuntime\"\u003e\n      \u003cpackage pattern=\"Microsoft.NETCore.App.Runtime.Mono.ios-arm64\" /\u003e\n      \u003cpackage pattern=\"Microsoft.NETCore.App.Ref\" /\u003e\n    \u003c/packageSource\u003e\n    \u003cpackageSource key=\"nuget.org\"\u003e\n      \u003cpackage pattern=\"*\" /\u003e\n    \u003c/packageSource\u003e\n  \u003c/packageSourceMapping\u003e\n\u003c/configuration\u003e\n```\n\n[Microsoft.NETCore.App.Runtime.Mono.ios-arm64.9.0.5.nupkg.zip](https://github.com/user-attachments/files/20051993/Microsoft.NETCore.App.Runtime.Mono.ios-arm64.9.0.5.nupkg.zip)",
                                           "updatedAt":  "2025-05-06T02:11:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6qFHfd",
                                           "createdAt":  "2025-05-06T06:55:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janusw",
                                           "body":  "\u003e \u003e Is there anything one can do to help debug this? Due to the ghostly nature of this issue, I think it will be hard to create a reliable reproducer (plus, my app is closed-source). Even worse: It only seems to occur in Release builds.\n\u003e \u003e So, if I manage to hit the exception by chance, what can I do to debug and pinpoint it?\n\u003e \n\u003e If you are up for it, can you use this runtime pack built from a [fork](https://github.com/dotnet/runtime/compare/release/9.0...kotlarmilos:runtime:release9.0/bugfix/task-finish-continuations-sentinel?expand=1) of our public 9.0 runtime branch?\n\u003e \n\u003e All you have to do within your project is add a nuget.config if you don\u0027t have one and add a local feed. We think this will surface an exception unique to iOS and may help us pinpoint the issue.\n\u003e\n\u003e [Microsoft.NETCore.App.Runtime.Mono.ios-arm64.9.0.5.nupkg.zip](https://github.com/user-attachments/files/20051993/Microsoft.NETCore.App.Runtime.Mono.ios-arm64.9.0.5.nupkg.zip)\n\nAwesome, thanks for that nupkg! I hope that I\u0027ll be able to try it in the next days. 👍\n(My project has a nuget.config already, and I have been working with local package sources in the past.)",
                                           "updatedAt":  "2025-05-06T06:55:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6qIiM2",
                                           "createdAt":  "2025-05-06T12:18:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janusw",
                                           "body":  "\n\u003e If you are up for it, can you use this runtime pack built from a [fork](https://github.com/dotnet/runtime/compare/release/9.0...kotlarmilos:runtime:release9.0/bugfix/task-finish-continuations-sentinel?expand=1) of our public 9.0 runtime branch?\n\u003e \n\u003e All you have to do within your project is add a nuget.config if you don\u0027t have one and add a local feed. We think this will surface an exception unique to iOS and may help us pinpoint the issue.\n\u003e \n\u003e [Microsoft.NETCore.App.Runtime.Mono.ios-arm64.9.0.5.nupkg.zip](https://github.com/user-attachments/files/20051993/Microsoft.NETCore.App.Runtime.Mono.ios-arm64.9.0.5.nupkg.zip)\n\n@steveisok I just tried to include this nupkg into my app. In addition to your `nuget.config` snippet, I had to add an explicit package reference in my csproj, in order to have it picked up:\n\n```\n    \u003cPackageReference Include=\"Microsoft.NETCore.App.Runtime.Mono.ios-arm64\" Version=\"9.0.5\" /\u003e\n```\n\nBut then `dotnet restore` gives me errors like this:\n\n```\nerror NU1213: The package Microsoft.NETCore.App.Runtime.Mono.ios-arm64 9.0.5 has a package type DotnetPlatform that is incompatible with this project. \n```\n\n@steveisok Could you tell me what this error means and how to get rid of it?\n\nMy project is a MAUI app with TFMs like `net9.0-android` and `net9.0-ios` and I\u0027m using .NET SDK 9.0.203 on MacOS.",
                                           "updatedAt":  "2025-05-06T12:18:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6qIpbs",
                                           "createdAt":  "2025-05-06T12:28:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "linnkrb",
                                           "body":  "I´m not 100% sure if we got it included correct, but delete all in my  previously downloded nugets in the nuget folders to start fresh, so I do belive it worked. \nAnd i think the error have now changed, but do not get  any exception. We do have other crashes, but this is the one we got the most times and i think the other exceptions we now have is not related to this\n\n\n0   FrontSystems                  \t0x0000000105741af4 mono_interp_exec_method (in FrontSystems) (interp.c:6193) + 11033332\n1   FrontSystems                  \t0x000000010573a388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n2   FrontSystems                  \t0x00000001056fe0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n3   FrontSystems                  \t0x000000010569a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n4   FrontSystems                  \t0x00000001056b4270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n5   libsystem_pthread.dylib       \t0x00000001eddaa924 _pthread_start + 104 (pthread.c:931)\n6   libsystem_pthread.dylib       \t0x00000001eddaa84c thread_start + 8 (:-1)\n\n\n\nFull crash report\n\n`Incident Identifier: BB647D5A-72AD-461C-9DB7-16E91D4E882A\nDistributor ID:      com.apple.TestFlight\nHardware Model:      iPad7,11\nProcess:             FrontSystems [25079]\nPath:                /private/var/containers/Bundle/Application/32F28AF7-CA3A-458C-B230-057620B8282B/FrontSystems.app/FrontSystems\nIdentifier:          no.frontsystems.cornerstone\nVersion:             2.0.1 (211)\nAppStoreTools:       16E137\nAppVariant:          1:iPad7,11:18\nBeta:                YES\nCode Type:           ARM-64 (Native)\nRole:                Foreground\nParent Process:      launchd [1]\nCoalition:           no.frontsystems.cornerstone [665]\n\nDate/Time:           2025-05-06 13:25:22.6009 +0200\nLaunch Time:         2025-05-06 12:12:53.5000 +0200\nOS Version:          iPhone OS 18.4.1 (22E252)\nRelease Type:        User\nReport Version:      104\n\nException Type:  EXC_BAD_ACCESS (SIGSEGV)\nException Subtype: KERN_INVALID_ADDRESS at 0x0000000100000019\nException Codes: 0x0000000000000001, 0x0000000100000019\nVM Region Info: 0x100000019 is not in any region.  Bytes before following region: 80461799\n      REGION TYPE                 START - END      [ VSIZE] PRT/MAX SHRMOD  REGION DETAIL\n      UNUSED SPACE AT START\n---\u003e  \n      __TEXT                   104cbc000-105904000 [ 12.3M] r-x/r-x SM=COW  /var/containers/Bundle/Application/32F28AF7-CA3A-458C-B230-057620B8282B/FrontSystems.app/FrontSystems\nTriggered by Thread:  11\n\n\nThread 0 name:\nThread 0 name:\nThread 0:\n0   libsystem_kernel.dylib        \t0x00000001dad29bf4 mach_msg2_trap + 8 (:-1)\n1   libsystem_kernel.dylib        \t0x00000001dad2d17c mach_msg2_internal + 72 (mach_msg.c:201)\n2   libsystem_kernel.dylib        \t0x00000001dad2d0d0 mach_msg_overwrite + 424 (mach_msg.c:0)\n3   libsystem_kernel.dylib        \t0x00000001dad2cf1c mach_msg + 20 (mach_msg.c:323)\n4   CoreFoundation                \t0x0000000190079b30 __CFRunLoopServiceMachPort + 156 (CFRunLoop.c:2637)\n5   CoreFoundation                \t0x00000001900791fc __CFRunLoopRun + 1192 (CFRunLoop.c:3021)\n6   CoreFoundation                \t0x000000019009c57c CFRunLoopRunSpecific + 536 (CFRunLoop.c:3434)\n7   GraphicsServices              \t0x00000001d706000c GSEventRunModal + 164 (GSEvent.c:2196)\n8   UIKitCore                     \t0x0000000192a9331c -[UIApplication _run] + 796 (UIApplication.m:3845)\n9   UIKitCore                     \t0x0000000192a91654 UIApplicationMain + 308 (UIApplication.m:5540)\n10  FrontSystems                  \t0x00000001055384b0 xamarin_UIApplicationMain (in FrontSystems) (bindings.m:131) + 8897712\n11  FrontSystems                  \t0x000000010574918c do_icall (in FrontSystems) (interp.c:2426) + 11063692\n12  FrontSystems                  \t0x0000000105747760 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 11056992\n13  FrontSystems                  \t0x000000010573c7bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n14  FrontSystems                  \t0x000000010573a388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n15  FrontSystems                  \t0x00000001056fe0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n16  FrontSystems                  \t0x000000010569a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n17  FrontSystems                  \t0x00000001056a15d8 mono_runtime_exec_main_checked (in FrontSystems) (object.c:4808) + 10376664\n18  FrontSystems                  \t0x0000000105705b14 mono_jit_exec (in FrontSystems) (driver.c:1311) + 10787604\n19  FrontSystems                  \t0x000000010554caec xamarin_main (in FrontSystems) (monotouch-main.m:0) + 8981228\n20  FrontSystems                  \t0x000000010590711c main (in FrontSystems) (main.arm64.mm:81) + 12890396\n21  dyld                          \t0x00000001b43e0318 start + 2492 (dyldMain.cpp:1443)\n\nThread 1 name:\nThread 1:\n0   libsystem_kernel.dylib        \t0x00000001dad2efd8 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x00000001eddb0a14 _pthread_cond_wait$VARIANT$mp + 1004 (pthread_cond.c:862)\n2   FrontSystems                  \t0x00000001056259b4 thread_func (in FrontSystems) (sgen-thread-pool.c:195) + 9869748\n3   libsystem_pthread.dylib       \t0x00000001eddaa924 _pthread_start + 104 (pthread.c:931)\n4   libsystem_pthread.dylib       \t0x00000001eddaa84c thread_start + 8 (:-1)\n\nThread 2 name:\nThread 2:\n0   libsystem_kernel.dylib        \t0x00000001dad29b70 semaphore_wait_trap + 8 (:-1)\n1   FrontSystems                  \t0x00000001056db178 finalizer_thread (in FrontSystems) (gc.c:868) + 10613112\n2   FrontSystems                  \t0x00000001056b417c start_wrapper (in FrontSystems) (threads.c:1276) + 10453372\n3   libsystem_pthread.dylib       \t0x00000001eddaa924 _pthread_start + 104 (pthread.c:931)\n4   libsystem_pthread.dylib       \t0x00000001eddaa84c thread_start + 8 (:-1)\n\nThread 3 name:\nThread 3:\n0   libsystem_kernel.dylib        \t0x00000001dad29bf4 mach_msg2_trap + 8 (:-1)\n1   libsystem_kernel.dylib        \t0x00000001dad2d17c mach_msg2_internal + 72 (mach_msg.c:201)\n2   libsystem_kernel.dylib        \t0x00000001dad2d0d0 mach_msg_overwrite + 424 (mach_msg.c:0)\n3   libsystem_kernel.dylib        \t0x00000001dad2cf1c mach_msg + 20 (mach_msg.c:323)\n4   CoreFoundation                \t0x0000000190079b30 __CFRunLoopServiceMachPort + 156 (CFRunLoop.c:2637)\n5   CoreFoundation                \t0x00000001900791fc __CFRunLoopRun + 1192 (CFRunLoop.c:3021)\n6   CoreFoundation                \t0x000000019009c57c CFRunLoopRunSpecific + 536 (CFRunLoop.c:3434)\n7   Foundation                    \t0x000000018ede0fe4 -[NSRunLoop(NSRunLoop) runMode:beforeDate:] + 208 (NSRunLoop.m:375)\n8   Foundation                    \t0x000000018eddff4c -[NSRunLoop(NSRunLoop) runUntilDate:] + 60 (NSRunLoop.m:422)\n9   UIKitCore                     \t0x0000000192b7a300 -[UIEventFetcher threadMain] + 412 (UIEventFetcher.m:1351)\n10  Foundation                    \t0x000000018ee7783c __NSThread__start__ + 716 (NSThread.m:991)\n11  libsystem_pthread.dylib       \t0x00000001eddaa924 _pthread_start + 104 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x00000001eddaa84c thread_start + 8 (:-1)\n\nThread 4 name:\nThread 4:\n0   libsystem_kernel.dylib        \t0x00000001dad2efd8 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x00000001eddb0a40 _pthread_cond_wait$VARIANT$mp + 1048 (pthread_cond.c:862)\n2   FrontSystems                  \t0x00000001055ae818 SystemNative_LowLevelMonitor_TimedWait (in FrontSystems) (pal_threading.c:198) + 9381912\n3   FrontSystems                  \t0x0000000105749100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n4   FrontSystems                  \t0x0000000105747760 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 11056992\n5   FrontSystems                  \t0x000000010573c7bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n6   FrontSystems                  \t0x000000010573a388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n7   FrontSystems                  \t0x00000001056fe0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n8   FrontSystems                  \t0x000000010569a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n9   FrontSystems                  \t0x00000001056b4270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n10  libsystem_pthread.dylib       \t0x00000001eddaa924 _pthread_start + 104 (pthread.c:931)\n11  libsystem_pthread.dylib       \t0x00000001eddaa84c thread_start + 8 (:-1)\n\nThread 5 name:\nThread 5:\n0   libsystem_kernel.dylib        \t0x00000001dad2efd8 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x00000001eddb0a40 _pthread_cond_wait$VARIANT$mp + 1048 (pthread_cond.c:862)\n2   FrontSystems                  \t0x00000001055ae818 SystemNative_LowLevelMonitor_TimedWait (in FrontSystems) (pal_threading.c:198) + 9381912\n3   FrontSystems                  \t0x0000000105749100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n4   FrontSystems                  \t0x0000000105747760 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 11056992\n5   FrontSystems                  \t0x000000010573c7bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n6   FrontSystems                  \t0x000000010573a388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n7   FrontSystems                  \t0x00000001056fe0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n8   FrontSystems                  \t0x000000010569a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n9   FrontSystems                  \t0x00000001056b4270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n10  libsystem_pthread.dylib       \t0x00000001eddaa924 _pthread_start + 104 (pthread.c:931)\n11  libsystem_pthread.dylib       \t0x00000001eddaa84c thread_start + 8 (:-1)\n\nThread 6 name:\nThread 6:\n0   libsystem_kernel.dylib        \t0x00000001dad2efd8 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x00000001eddb0a40 _pthread_cond_wait$VARIANT$mp + 1048 (pthread_cond.c:862)\n2   FrontSystems                  \t0x00000001055ae818 SystemNative_LowLevelMonitor_TimedWait (in FrontSystems) (pal_threading.c:198) + 9381912\n3   FrontSystems                  \t0x0000000105749100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n4   FrontSystems                  \t0x0000000105747760 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 11056992\n5   FrontSystems                  \t0x000000010573c7bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n6   FrontSystems                  \t0x000000010573a388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n7   FrontSystems                  \t0x00000001056fe0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n8   FrontSystems                  \t0x000000010569a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n9   FrontSystems                  \t0x00000001056b4270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n10  libsystem_pthread.dylib       \t0x00000001eddaa924 _pthread_start + 104 (pthread.c:931)\n11  libsystem_pthread.dylib       \t0x00000001eddaa84c thread_start + 8 (:-1)\n\nThread 7 name:\nThread 7:\n0   libsystem_kernel.dylib        \t0x00000001dad2efd8 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x00000001eddb0a40 _pthread_cond_wait$VARIANT$mp + 1048 (pthread_cond.c:862)\n2   FrontSystems                  \t0x00000001055ae818 SystemNative_LowLevelMonitor_TimedWait (in FrontSystems) (pal_threading.c:198) + 9381912\n3   FrontSystems                  \t0x0000000105749100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n4   FrontSystems                  \t0x0000000105747760 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 11056992\n5   FrontSystems                  \t0x000000010573c7bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n6   FrontSystems                  \t0x000000010573a388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n7   FrontSystems                  \t0x00000001056fe0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n8   FrontSystems                  \t0x000000010569a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n9   FrontSystems                  \t0x00000001056b4270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n10  libsystem_pthread.dylib       \t0x00000001eddaa924 _pthread_start + 104 (pthread.c:931)\n11  libsystem_pthread.dylib       \t0x00000001eddaa84c thread_start + 8 (:-1)\n\nThread 8 name:\nThread 8:\n0   libsystem_kernel.dylib        \t0x00000001dad3010c kevent + 8\n1   FrontSystems                  \t0x00000001055ac9b4 SystemNative_WaitForSocketEvents (in FrontSystems) (pal_networking.c:3256) + 9374132\n2   FrontSystems                  \t0x000000010574912c do_icall (in FrontSystems) (interp.c:2402) + 11063596\n3   FrontSystems                  \t0x0000000105747760 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 11056992\n4   FrontSystems                  \t0x000000010573c7bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n5   FrontSystems                  \t0x000000010573a388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n6   FrontSystems                  \t0x00000001056fe0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n7   FrontSystems                  \t0x000000010569a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n8   FrontSystems                  \t0x00000001056b4270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n9   libsystem_pthread.dylib       \t0x00000001eddaa924 _pthread_start + 104 (pthread.c:931)\n10  libsystem_pthread.dylib       \t0x00000001eddaa84c thread_start + 8 (:-1)\n\nThread 9:\n0   libsystem_pthread.dylib       \t0x00000001eddaa838 start_wqthread + 0 (:-1)\n\nThread 10 name:\nThread 10:\n0   FrontSystems                  \t0x000000010573cb24 mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012900\n1   FrontSystems                  \t0x000000010573a388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n2   FrontSystems                  \t0x00000001056fe0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n3   FrontSystems                  \t0x000000010569a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n4   FrontSystems                  \t0x00000001056b4270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n5   libsystem_pthread.dylib       \t0x00000001eddaa924 _pthread_start + 104 (pthread.c:931)\n6   libsystem_pthread.dylib       \t0x00000001eddaa84c thread_start + 8 (:-1)\n\nThread 11 name:\nThread 11 Crashed:\n0   FrontSystems                  \t0x0000000105741af4 mono_interp_exec_method (in FrontSystems) (interp.c:6193) + 11033332\n1   FrontSystems                  \t0x000000010573a388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n2   FrontSystems                  \t0x00000001056fe0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n3   FrontSystems                  \t0x000000010569a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n4   FrontSystems                  \t0x00000001056b4270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n5   libsystem_pthread.dylib       \t0x00000001eddaa924 _pthread_start + 104 (pthread.c:931)\n6   libsystem_pthread.dylib       \t0x00000001eddaa84c thread_start + 8 (:-1)\n\nThread 12 name:\nThread 12:\n0   libsystem_kernel.dylib        \t0x00000001dad2efd8 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x00000001eddb0a14 _pthread_cond_wait$VARIANT$mp + 1004 (pthread_cond.c:862)\n2   FrontSystems                  \t0x00000001055d5724 mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9541412\n3   FrontSystems                  \t0x00000001055d9ae0 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9558752\n4   FrontSystems                  \t0x0000000105749100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n5   FrontSystems                  \t0x0000000105747798 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 11057048\n6   FrontSystems                  \t0x000000010573c7bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n7   FrontSystems                  \t0x000000010573a388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n8   FrontSystems                  \t0x00000001056fe0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n9   FrontSystems                  \t0x000000010569a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n10  FrontSystems                  \t0x00000001056b4270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n11  libsystem_pthread.dylib       \t0x00000001eddaa924 _pthread_start + 104 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x00000001eddaa84c thread_start + 8 (:-1)\n\nThread 13:\n0   libsystem_pthread.dylib       \t0x00000001eddaa838 start_wqthread + 0 (:-1)\n\nThread 14 name:\nThread 14:\n0   libsystem_kernel.dylib        \t0x00000001dad2efd8 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x00000001eddb0a14 _pthread_cond_wait$VARIANT$mp + 1004 (pthread_cond.c:862)\n2   FrontSystems                  \t0x00000001055d5724 mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9541412\n3   FrontSystems                  \t0x00000001055d9ae0 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9558752\n4   FrontSystems                  \t0x0000000105749100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n5   FrontSystems                  \t0x0000000105747798 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 11057048\n6   FrontSystems                  \t0x000000010573c7bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n7   FrontSystems                  \t0x000000010573a388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n8   FrontSystems                  \t0x00000001056fe0f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n9   FrontSystems                  \t0x000000010569a3f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n10  FrontSystems                  \t0x00000001056b4270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n11  libsystem_pthread.dylib       \t0x00000001eddaa924 _pthread_start + 104 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x00000001eddaa84c thread_start + 8 (:-1)\n\n\nThread 11 crashed with ARM Thread State (64-bit):\n    x0: 0x0000000303fdc1c8   x1: 0x000000016c6d5fd0   x2: 0x0000000100000001   x3: 0x00000001055e7834\n    x4: 0x0000000105653f50   x5: 0x0000000000000000   x6: 0x0000000000000000   x7: 0x000000016c6d68c4\n    x8: 0x0000000100000001   x9: 0x0000000000000018  x10: 0x000000016c6d5fa0  x11: 0x0000000105b54ec0\n   x12: 0x0000000000000000  x13: 0x0000000000000000  x14: 0x00000000ffffffff  x15: 0x000000000000009e\n   x16: 0x00000001edd00cc0  x17: 0x0000000000000001  x18: 0x0000000000000000  x19: 0x0000000129b81250\n   x20: 0x0000000303fdc1c8  x21: 0x000000016c6d5fa0  x22: 0x0000000000000000  x23: 0x000000011e26c8d0\n   x24: 0x0000000303fdc1c8  x25: 0x000000000000001b  x26: 0x0000000105b54ec0  x27: 0x0000000303fdc180\n   x28: 0x0000000000000000   fp: 0x000000016c6d69d0   lr: 0x0000000105741f0c\n    sp: 0x000000016c6d4650   pc: 0x0000000105741af4 cpsr: 0x80000000\n   esr: 0x56000080  Address size fault\n\n\nBinary Images:\n        0x104cbc000 -         0x105b2bfff FrontSystems arm64  \u003c0e5ad6da9648315c901a2fa3253e7f19\u003e /var/containers/Bundle/Application/32F28AF7-CA3A-458C-B230-057620B8282B/FrontSystems.app/FrontSystems\n        0x10625c000 -         0x1063a3fff libHarfBuzzSharp arm64  \u003c8ca693a9d0533072850919c5df43d67e\u003e /private/var/containers/Bundle/Application/32F28AF7-CA3A-458C-B230-057620B8282B/FrontSystems.app/Frameworks/libHarfBuzzSharp.framework/libHarfBuzzSharp\n        0x106990000 -         0x106eeffff libSkiaSharp arm64  \u003c6b45b7dee11f31139b1f1aff7553de02\u003e /private/var/containers/Bundle/Application/32F28AF7-CA3A-458C-B230-057620B8282B/FrontSystems.app/Frameworks/libSkiaSharp.framework/libSkiaSharp\n        0x10b420000 -         0x10b42bfff libobjc-trampolines.dylib arm64  \u003cd44d2db8a3033b3eafe03aafa2566ab4\u003e /private/preboot/Cryptexes/OS/usr/lib/libobjc-trampolines.dylib\n        0x18ed73000 -         0x18f93581f Foundation arm64  \u003cbdb9993b36ae37b7bd86858ff578b211\u003e /System/Library/Frameworks/Foundation.framework/Foundation\n        0x190009000 -         0x190576fff CoreFoundation arm64  \u003c23ef691cc62f32d4a78d05ac9c7beaba\u003e /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation\n        0x1926fe000 -         0x1944abf3f UIKitCore arm64  \u003c115ab21b23ad3c5292fc921d6789a43d\u003e /System/Library/PrivateFrameworks/UIKitCore.framework/UIKitCore\n        0x1b43d3000 -         0x1b4455a47 dyld arm64  \u003cb6b8762a7f643a9ea1929b9925f78e05\u003e /usr/lib/dyld\n        0x1d705f000 -         0x1d70674df GraphicsServices arm64  \u003c08dbb058dbdf3c748eac0e015d869a30\u003e /System/Library/PrivateFrameworks/GraphicsServices.framework/GraphicsServices\n        0x1dad29000 -         0x1dad6054f libsystem_kernel.dylib arm64  \u003ca69389fa663339cf9f4ecab5f9faa66d\u003e /usr/lib/system/libsystem_kernel.dylib\n        0x1edcff000 -         0x1edd0abcf libsystem_platform.dylib arm64  \u003ceaffd9b342be31e297867d571d6ee638\u003e /usr/lib/system/libsystem_platform.dylib\n        0x1edda9000 -         0x1eddb93ef libsystem_pthread.dylib arm64  \u003c7d06e933a40131cdacf97e7055c4f4f1\u003e /usr/lib/system/libsystem_pthread.dylib\n\nEOF\n`",
                                           "updatedAt":  "2025-05-06T12:29:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6qIuVF",
                                           "createdAt":  "2025-05-06T12:35:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "linnkrb",
                                           "body":  "Or maybe not, this is the other crash report we get, maybe this is the one related...\n`Incident Identifier: 99F56DCA-301C-49B9-9758-E61E8FA4E55E\nDistributor ID:      com.apple.TestFlight\nHardware Model:      iPhone15,4\nProcess:             FrontSystems [1212]\nPath:                /private/var/containers/Bundle/Application/D3850A45-2902-483A-82EB-CA0569E57DBB/FrontSystems.app/FrontSystems\nIdentifier:          no.frontsystems.cornerstone\nVersion:             2.0.1 (211)\nAppStoreTools:       16E137\nAppVariant:          1:iPhone15,4:18\nBeta:                YES\nCode Type:           ARM-64 (Native)\nRole:                Foreground\nParent Process:      launchd [1]\nCoalition:           no.frontsystems.cornerstone [752]\n\nDate/Time:           2025-05-06 13:26:37.5899 +0200\nLaunch Time:         2025-05-06 13:26:14.0689 +0200\nOS Version:          iPhone OS 18.4.1 (22E252)\nRelease Type:        User\nBaseband Version:    2.52.03\nReport Version:      104\n\nException Type:  EXC_CRASH (SIGABRT)\nException Codes: 0x0000000000000000, 0x0000000000000000\nTermination Reason: SIGNAL 6 Abort trap: 6\nTerminating Process: FrontSystems [1212]\n\nTriggered by Thread:  23\n\n\nThread 0 name:\nThread 0 name:\nThread 0:\n0   FrontSystems                  \t0x0000000104d3dc8c mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11050124\n1   FrontSystems                  \t0x0000000104d31b84 interp_entry_from_trampoline (in FrontSystems) (interp.c:3229) + 11000708\n2   FrontSystems                  \t0x0000000104b19970 native_to_interp_trampoline (in FrontSystems) + 112 + 8804720\n3   UIKitCore                     \t0x0000000193ac72c8 -[UIAlertController _invokeHandlersForAction:] + 88 (UIAlertController.m:1218)\n4   UIKitCore                     \t0x0000000193ac7af8 __103-[UIAlertController _dismissAnimated:triggeringAction:triggeredByPopoverDimmingView:dismissCompletion:]_block_invoke_2 + 36 (UIAlertController.m:1383)\n5   UIKitCore                     \t0x00000001933925fc -[UIPresentationController transitionDidFinish:] + 840 (UIPresentationController.m:677)\n6   UIKitCore                     \t0x00000001936e60d8 __77-[UIPresentationController runTransitionForCurrentStateAnimated:handoffData:]_block_invoke.112 + 344 (UIPresentationController.m:1423)\n7   UIKitCore                     \t0x0000000193420774 -[_UIViewControllerTransitionContext completeTransition:] + 192 (UIViewControllerTransitioning.m:353)\n8   UIKitCore                     \t0x0000000193303c54 __UIVIEW_IS_EXECUTING_ANIMATION_COMPLETION_BLOCK__ + 36 (UIView.m:16568)\n9   UIKitCore                     \t0x0000000193303ae4 -[UIViewAnimationBlockDelegate _didEndBlockAnimation:finished:context:] + 628 (UIView.m:16601)\n10  UIKitCore                     \t0x00000001933027a4 -[UIViewAnimationState sendDelegateAnimationDidStop:finished:] + 436 (UIView.m:0)\n11  UIKitCore                     \t0x0000000193303d1c -[UIViewAnimationState animationDidStop:finished:] + 192 (UIView.m:2417)\n12  UIKitCore                     \t0x0000000193303d8c -[UIViewAnimationState animationDidStop:finished:] + 304 (UIView.m:2439)\n13  QuartzCore                    \t0x000000019254dbac run_animation_callbacks(void*) + 132 (CALayer.mm:7843)\n14  libdispatch.dylib             \t0x00000001988d3584 _dispatch_client_callout + 16 (client_callout.mm:85)\n15  libdispatch.dylib             \t0x00000001988f0574 _dispatch_main_queue_drain.cold.5 + 812 (queue.c:8104)\n16  libdispatch.dylib             \t0x00000001988c8d30 _dispatch_main_queue_drain + 180 (queue.c:8085)\n17  libdispatch.dylib             \t0x00000001988c8c6c _dispatch_main_queue_callback_4CF + 44 (queue.c:8264)\n18  CoreFoundation                \t0x00000001909ae2b4 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 16 (CFRunLoop.c:1793)\n19  CoreFoundation                \t0x00000001909ac0b0 __CFRunLoopRun + 1980 (CFRunLoop.c:3163)\n20  CoreFoundation                \t0x00000001909d0700 CFRunLoopRunSpecific + 572 (CFRunLoop.c:3434)\n21  GraphicsServices              \t0x00000001dd511190 GSEventRunModal + 168 (GSEvent.c:2196)\n22  UIKitCore                     \t0x00000001935ee240 -[UIApplication _run] + 816 (UIApplication.m:3845)\n23  UIKitCore                     \t0x00000001935ec470 UIApplicationMain + 336 (UIApplication.m:5540)\n24  FrontSystems                  \t0x0000000104b304b0 xamarin_UIApplicationMain (in FrontSystems) (bindings.m:131) + 8897712\n25  FrontSystems                  \t0x0000000104d4118c do_icall (in FrontSystems) (interp.c:2426) + 11063692\n26  FrontSystems                  \t0x0000000104d3f760 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 11056992\n27  FrontSystems                  \t0x0000000104d347bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n28  FrontSystems                  \t0x0000000104d32388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n29  FrontSystems                  \t0x0000000104cf60f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n30  FrontSystems                  \t0x0000000104c923f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n31  FrontSystems                  \t0x0000000104c995d8 mono_runtime_exec_main_checked (in FrontSystems) (object.c:4808) + 10376664\n32  FrontSystems                  \t0x0000000104cfdb14 mono_jit_exec (in FrontSystems) (driver.c:1311) + 10787604\n33  FrontSystems                  \t0x0000000104b44aec xamarin_main (in FrontSystems) (monotouch-main.m:0) + 8981228\n34  FrontSystems                  \t0x0000000104eff11c main (in FrontSystems) (main.arm64.mm:81) + 12890396\n35  dyld                          \t0x00000001b73d3ad8 start + 5964 (dyldMain.cpp:1443)\n\nThread 1 name:\nThread 1:\n0   libsystem_kernel.dylib        \t0x00000001e153d438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x000000021aebc2fc _pthread_cond_wait + 984 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000104c1d9b4 thread_func (in FrontSystems) (sgen-thread-pool.c:195) + 9869748\n3   libsystem_pthread.dylib       \t0x000000021aebaafc _pthread_start + 136 (pthread.c:931)\n4   libsystem_pthread.dylib       \t0x000000021aebaa04 thread_start + 8 (:-1)\n\nThread 2 name:\nThread 2:\n0   libsystem_kernel.dylib        \t0x00000001e1537c60 semaphore_wait_trap + 8 (:-1)\n1   FrontSystems                  \t0x0000000104cd3178 finalizer_thread (in FrontSystems) (gc.c:868) + 10613112\n2   FrontSystems                  \t0x0000000104cac17c start_wrapper (in FrontSystems) (threads.c:1276) + 10453372\n3   libsystem_pthread.dylib       \t0x000000021aebaafc _pthread_start + 136 (pthread.c:931)\n4   libsystem_pthread.dylib       \t0x000000021aebaa04 thread_start + 8 (:-1)\n\nThread 3:\n0   libsystem_pthread.dylib       \t0x000000021aeba9f0 start_wqthread + 0 (:-1)\n\nThread 4 name:\nThread 4:\n0   libsystem_kernel.dylib        \t0x00000001e1537ce4 mach_msg2_trap + 8 (:-1)\n1   libsystem_kernel.dylib        \t0x00000001e153b39c mach_msg2_internal + 76 (mach_msg.c:201)\n2   libsystem_kernel.dylib        \t0x00000001e153b2b8 mach_msg_overwrite + 428 (mach_msg.c:0)\n3   libsystem_kernel.dylib        \t0x00000001e153b100 mach_msg + 24 (mach_msg.c:323)\n4   CoreFoundation                \t0x00000001909ac6cc __CFRunLoopServiceMachPort + 160 (CFRunLoop.c:2637)\n5   CoreFoundation                \t0x00000001909abdac __CFRunLoopRun + 1208 (CFRunLoop.c:3021)\n6   CoreFoundation                \t0x00000001909d0700 CFRunLoopRunSpecific + 572 (CFRunLoop.c:3434)\n7   Foundation                    \t0x000000018f6128a8 -[NSRunLoop(NSRunLoop) runMode:beforeDate:] + 212 (NSRunLoop.m:375)\n8   Foundation                    \t0x000000018f6116d8 -[NSRunLoop(NSRunLoop) runUntilDate:] + 64 (NSRunLoop.m:422)\n9   UIKitCore                     \t0x00000001936e15ec -[UIEventFetcher threadMain] + 424 (UIEventFetcher.m:1351)\n10  Foundation                    \t0x000000018f6b3cf8 __NSThread__start__ + 732 (NSThread.m:991)\n11  libsystem_pthread.dylib       \t0x000000021aebaafc _pthread_start + 136 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x000000021aebaa04 thread_start + 8 (:-1)\n\nThread 5 name:\nThread 5:\n0   libsystem_kernel.dylib        \t0x00000001e153d438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x000000021aebc2fc _pthread_cond_wait + 984 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000104bcd724 mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9541412\n3   FrontSystems                  \t0x0000000104bd1ae0 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9558752\n4   FrontSystems                  \t0x0000000104d41100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n5   FrontSystems                  \t0x0000000104d3f798 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 11057048\n6   FrontSystems                  \t0x0000000104d347bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n7   FrontSystems                  \t0x0000000104d32388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n8   FrontSystems                  \t0x0000000104cf60f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n9   FrontSystems                  \t0x0000000104c923f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n10  FrontSystems                  \t0x0000000104cac270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n11  libsystem_pthread.dylib       \t0x000000021aebaafc _pthread_start + 136 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x000000021aebaa04 thread_start + 8 (:-1)\n\nThread 6 name:\nThread 6:\n0   libsystem_kernel.dylib        \t0x00000001e153d438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x000000021aebc328 _pthread_cond_wait + 1028 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000104ba6818 SystemNative_LowLevelMonitor_TimedWait (in FrontSystems) (pal_threading.c:198) + 9381912\n3   FrontSystems                  \t0x0000000104d41100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n4   FrontSystems                  \t0x0000000104d3f760 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 11056992\n5   FrontSystems                  \t0x0000000104d347bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n6   FrontSystems                  \t0x0000000104d32388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n7   FrontSystems                  \t0x0000000104cf60f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n8   FrontSystems                  \t0x0000000104c923f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n9   FrontSystems                  \t0x0000000104cac270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n10  libsystem_pthread.dylib       \t0x000000021aebaafc _pthread_start + 136 (pthread.c:931)\n11  libsystem_pthread.dylib       \t0x000000021aebaa04 thread_start + 8 (:-1)\n\nThread 7 name:\nThread 7:\n0   libsystem_kernel.dylib        \t0x00000001e153d438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x000000021aebc328 _pthread_cond_wait + 1028 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000104ba6818 SystemNative_LowLevelMonitor_TimedWait (in FrontSystems) (pal_threading.c:198) + 9381912\n3   FrontSystems                  \t0x0000000104d41100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n4   FrontSystems                  \t0x0000000104d3f760 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 11056992\n5   FrontSystems                  \t0x0000000104d347bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n6   FrontSystems                  \t0x0000000104d32388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n7   FrontSystems                  \t0x0000000104cf60f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n8   FrontSystems                  \t0x0000000104c923f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n9   FrontSystems                  \t0x0000000104cac270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n10  libsystem_pthread.dylib       \t0x000000021aebaafc _pthread_start + 136 (pthread.c:931)\n11  libsystem_pthread.dylib       \t0x000000021aebaa04 thread_start + 8 (:-1)\n\nThread 8 name:\nThread 8:\n0   libsystem_kernel.dylib        \t0x00000001e153d438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x000000021aebc328 _pthread_cond_wait + 1028 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000104ba6818 SystemNative_LowLevelMonitor_TimedWait (in FrontSystems) (pal_threading.c:198) + 9381912\n3   FrontSystems                  \t0x0000000104d41100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n4   FrontSystems                  \t0x0000000104d3f760 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 11056992\n5   FrontSystems                  \t0x0000000104d347bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n6   FrontSystems                  \t0x0000000104d32388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n7   FrontSystems                  \t0x0000000104cf60f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n8   FrontSystems                  \t0x0000000104c923f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n9   FrontSystems                  \t0x0000000104cac270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n10  libsystem_pthread.dylib       \t0x000000021aebaafc _pthread_start + 136 (pthread.c:931)\n11  libsystem_pthread.dylib       \t0x000000021aebaa04 thread_start + 8 (:-1)\n\nThread 9 name:\nThread 9:\n0   libsystem_kernel.dylib        \t0x00000001e153d438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x000000021aebc328 _pthread_cond_wait + 1028 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000104ba6818 SystemNative_LowLevelMonitor_TimedWait (in FrontSystems) (pal_threading.c:198) + 9381912\n3   FrontSystems                  \t0x0000000104d41100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n4   FrontSystems                  \t0x0000000104d3f760 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 11056992\n5   FrontSystems                  \t0x0000000104d347bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n6   FrontSystems                  \t0x0000000104d32388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n7   FrontSystems                  \t0x0000000104cf60f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n8   FrontSystems                  \t0x0000000104c923f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n9   FrontSystems                  \t0x0000000104cac270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n10  libsystem_pthread.dylib       \t0x000000021aebaafc _pthread_start + 136 (pthread.c:931)\n11  libsystem_pthread.dylib       \t0x000000021aebaa04 thread_start + 8 (:-1)\n\nThread 10 name:\nThread 10:\n0   libsystem_kernel.dylib        \t0x00000001e153e768 kevent + 8 (:-1)\n1   FrontSystems                  \t0x0000000104ba49b4 SystemNative_WaitForSocketEvents (in FrontSystems) (pal_networking.c:3256) + 9374132\n2   FrontSystems                  \t0x0000000104d4112c do_icall (in FrontSystems) (interp.c:2402) + 11063596\n3   FrontSystems                  \t0x0000000104d3f760 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 11056992\n4   FrontSystems                  \t0x0000000104d347bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n5   FrontSystems                  \t0x0000000104d32388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n6   FrontSystems                  \t0x0000000104cf60f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n7   FrontSystems                  \t0x0000000104c923f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n8   FrontSystems                  \t0x0000000104cac270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n9   libsystem_pthread.dylib       \t0x000000021aebaafc _pthread_start + 136 (pthread.c:931)\n10  libsystem_pthread.dylib       \t0x000000021aebaa04 thread_start + 8 (:-1)\n\nThread 11 name:\nThread 11:\n0   libsystem_kernel.dylib        \t0x00000001e153d438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x000000021aebc2fc _pthread_cond_wait + 984 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000104bcd724 mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9541412\n3   FrontSystems                  \t0x0000000104bd1ae0 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9558752\n4   FrontSystems                  \t0x0000000104d41100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n5   FrontSystems                  \t0x0000000104d3f798 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 11057048\n6   FrontSystems                  \t0x0000000104d347bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n7   FrontSystems                  \t0x0000000104d32388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n8   FrontSystems                  \t0x0000000104cf60f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n9   FrontSystems                  \t0x0000000104c923f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n10  FrontSystems                  \t0x0000000104cac270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n11  libsystem_pthread.dylib       \t0x000000021aebaafc _pthread_start + 136 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x000000021aebaa04 thread_start + 8 (:-1)\n\nThread 12 name:\nThread 12:\n0   libsystem_kernel.dylib        \t0x00000001e153d438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x000000021aebc2fc _pthread_cond_wait + 984 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000104bcd724 mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9541412\n3   FrontSystems                  \t0x0000000104bd1ae0 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9558752\n4   FrontSystems                  \t0x0000000104d41100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n5   FrontSystems                  \t0x0000000104d3f798 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 11057048\n6   FrontSystems                  \t0x0000000104d347bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n7   FrontSystems                  \t0x0000000104d32388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n8   FrontSystems                  \t0x0000000104cf60f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n9   FrontSystems                  \t0x0000000104c923f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n10  FrontSystems                  \t0x0000000104cac270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n11  libsystem_pthread.dylib       \t0x000000021aebaafc _pthread_start + 136 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x000000021aebaa04 thread_start + 8 (:-1)\n\nThread 13:\n0   libsystem_pthread.dylib       \t0x000000021aeba9f0 start_wqthread + 0 (:-1)\n\nThread 14 name:\nThread 14:\n0   libsystem_kernel.dylib        \t0x00000001e153d438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x000000021aebc2fc _pthread_cond_wait + 984 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000104bcd724 mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9541412\n3   FrontSystems                  \t0x0000000104bd1ae0 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9558752\n4   FrontSystems                  \t0x0000000104d41100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n5   FrontSystems                  \t0x0000000104d3f798 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 11057048\n6   FrontSystems                  \t0x0000000104d347bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n7   FrontSystems                  \t0x0000000104d32388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n8   FrontSystems                  \t0x0000000104cf60f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n9   FrontSystems                  \t0x0000000104c923f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n10  FrontSystems                  \t0x0000000104cac270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n11  libsystem_pthread.dylib       \t0x000000021aebaafc _pthread_start + 136 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x000000021aebaa04 thread_start + 8 (:-1)\n\nThread 15:\n0   libsystem_pthread.dylib       \t0x000000021aeba9f0 start_wqthread + 0 (:-1)\n\nThread 16:\n0   libsystem_pthread.dylib       \t0x000000021aeba9f0 start_wqthread + 0 (:-1)\n\nThread 17:\n0   libsystem_pthread.dylib       \t0x000000021aeba9f0 start_wqthread + 0 (:-1)\n\nThread 18 name:\nThread 18:\n0   libsystem_kernel.dylib        \t0x00000001e153d438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x000000021aebc2fc _pthread_cond_wait + 984 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000104bcd724 mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9541412\n3   FrontSystems                  \t0x0000000104bd1ae0 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9558752\n4   FrontSystems                  \t0x0000000104d41100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n5   FrontSystems                  \t0x0000000104d3f798 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 11057048\n6   FrontSystems                  \t0x0000000104d347bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n7   FrontSystems                  \t0x0000000104d32388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n8   FrontSystems                  \t0x0000000104cf60f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n9   FrontSystems                  \t0x0000000104c923f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n10  FrontSystems                  \t0x0000000104cac270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n11  libsystem_pthread.dylib       \t0x000000021aebaafc _pthread_start + 136 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x000000021aebaa04 thread_start + 8 (:-1)\n\nThread 19 name:\nThread 19:\n0   libsystem_kernel.dylib        \t0x00000001e153d438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x000000021aebc2fc _pthread_cond_wait + 984 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000104bcd724 mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9541412\n3   FrontSystems                  \t0x0000000104bd1ae0 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9558752\n4   FrontSystems                  \t0x0000000104d41100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n5   FrontSystems                  \t0x0000000104d3f798 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 11057048\n6   FrontSystems                  \t0x0000000104d347bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n7   FrontSystems                  \t0x0000000104d32388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n8   FrontSystems                  \t0x0000000104cf60f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n9   FrontSystems                  \t0x0000000104c923f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n10  FrontSystems                  \t0x0000000104cac270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n11  libsystem_pthread.dylib       \t0x000000021aebaafc _pthread_start + 136 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x000000021aebaa04 thread_start + 8 (:-1)\n\nThread 20 name:\nThread 20:\n0   libsystem_kernel.dylib        \t0x00000001e153d438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x000000021aebc2fc _pthread_cond_wait + 984 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000104bcd724 mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9541412\n3   FrontSystems                  \t0x0000000104bd1ae0 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9558752\n4   FrontSystems                  \t0x0000000104d41100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n5   FrontSystems                  \t0x0000000104d3f798 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 11057048\n6   FrontSystems                  \t0x0000000104d347bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n7   FrontSystems                  \t0x0000000104d32388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n8   FrontSystems                  \t0x0000000104cf60f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n9   FrontSystems                  \t0x0000000104c923f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n10  FrontSystems                  \t0x0000000104cac270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n11  libsystem_pthread.dylib       \t0x000000021aebaafc _pthread_start + 136 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x000000021aebaa04 thread_start + 8 (:-1)\n\nThread 21 name:\nThread 21:\n0   libsystem_kernel.dylib        \t0x00000001e153d438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x000000021aebc2fc _pthread_cond_wait + 984 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000104bcd724 mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9541412\n3   FrontSystems                  \t0x0000000104bd1ae0 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9558752\n4   FrontSystems                  \t0x0000000104d41100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n5   FrontSystems                  \t0x0000000104d3f798 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 11057048\n6   FrontSystems                  \t0x0000000104d347bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n7   FrontSystems                  \t0x0000000104d32388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n8   FrontSystems                  \t0x0000000104cf60f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n9   FrontSystems                  \t0x0000000104c923f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n10  FrontSystems                  \t0x0000000104cac270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n11  libsystem_pthread.dylib       \t0x000000021aebaafc _pthread_start + 136 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x000000021aebaa04 thread_start + 8 (:-1)\n\nThread 22 name:\nThread 22:\n0   libsystem_kernel.dylib        \t0x00000001e153d438 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x000000021aebc2fc _pthread_cond_wait + 984 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000104bcd724 mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9541412\n3   FrontSystems                  \t0x0000000104bd1ae0 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9558752\n4   FrontSystems                  \t0x0000000104d41100 do_icall (in FrontSystems) (interp.c:2390) + 11063552\n5   FrontSystems                  \t0x0000000104d3f798 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 11057048\n6   FrontSystems                  \t0x0000000104d347bc mono_interp_exec_method (in FrontSystems) (interp.c:0) + 11012028\n7   FrontSystems                  \t0x0000000104d32388 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 11002760\n8   FrontSystems                  \t0x0000000104cf60f8 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3686) + 10756344\n9   FrontSystems                  \t0x0000000104c923f8 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10347512\n10  FrontSystems                  \t0x0000000104cac270 start_wrapper (in FrontSystems) (threads.c:1276) + 10453616\n11  libsystem_pthread.dylib       \t0x000000021aebaafc _pthread_start + 136 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x000000021aebaa04 thread_start + 8 (:-1)\n\nThread 23 name:\nThread 23 Crashed:\n0   libsystem_kernel.dylib        \t0x00000001e15421dc __pthread_kill + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x000000021aec0b40 pthread_kill + 268 (pthread.c:1721)\n2   libsystem_c.dylib             \t0x00000001989752d0 abort + 124 (abort.c:122)\n3   FrontSystems                  \t0x0000000104f58c24 0x0000000100ca4c24 (in FrontSystems) + 13257764\n4   FrontSystems                  \t0x0000000104d306cc mono_runtime_setup_stat_profiler (in FrontSystems) (mini-posix.c:692) + 10995404\n5   libsystem_platform.dylib      \t0x000000021ae11eec _sigtramp + 56 (sigtramp.c:116)\n6   libsystem_pthread.dylib       \t0x000000021aec0b40 pthread_kill + 268 (pthread.c:1721)\n7   libsystem_c.dylib             \t0x00000001989752d0 abort + 124 (abort.c:122)\n8   FrontSystems                  \t0x0000000104b3b148 xamarin_find_protocol_wrapper_type (in FrontSystems) (runtime.m:1218) + 8941896\n9   FrontSystems                  \t0x0000000104c481c4 mono_invoke_unhandled_exception_hook (in FrontSystems) (exception.c:1263) + 10043844\n10  FrontSystems                  \t0x0000000104cac4bc start_wrapper (in FrontSystems) (threads.c:1276) + 10454204\n11  libsystem_pthread.dylib       \t0x000000021aebaafc _pthread_start + 136 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x000000021aebaa04 thread_start + 8 (:-1)\n\n\nThread 23 crashed with ARM Thread State (64-bit):\n    x0: 0x0000000000000000   x1: 0x0000000000000000   x2: 0x0000000000000000   x3: 0x0000000000000000\n    x4: 0xffffffff9704edff   x5: 0x0000000000000018   x6: 0x000000016e04a570   x7: 0x000000016e049c60\n    x8: 0xf254d7953f683b94   x9: 0xf254d794516c8b94  x10: 0x00000000000003ff  x11: 0x000000016e049cd8\n   x12: 0x0000000000000000  x13: 0x0000000104b134b8  x14: 0x0000000000000001  x15: 0x0000000000000001\n   x16: 0x0000000000000148  x17: 0x000000016e04b000  x18: 0x0000000000000000  x19: 0x0000000000000006\n   x20: 0x0000000000011607  x21: 0x000000016e04b0e0  x22: 0x00000001270c4000  x23: 0x000000016e04b000\n   x24: 0x0000000000000000  x25: 0x0000000000000000  x26: 0x00000001054ed668  x27: 0x0000000000000000\n   x28: 0x0000000000000000   fp: 0x000000016e04a580   lr: 0x000000021aec0b40\n    sp: 0x000000016e04a560   pc: 0x00000001e15421dc cpsr: 0x40001000\n   esr: 0x56000080  Address size fault\n\n\nBinary Images:\n        0x1042b4000 -         0x105123fff FrontSystems arm64  \u003c0e5ad6da9648315c901a2fa3253e7f19\u003e /var/containers/Bundle/Application/D3850A45-2902-483A-82EB-CA0569E57DBB/FrontSystems.app/FrontSystems\n        0x105838000 -         0x10597ffff libHarfBuzzSharp arm64  \u003c8ca693a9d0533072850919c5df43d67e\u003e /private/var/containers/Bundle/Application/D3850A45-2902-483A-82EB-CA0569E57DBB/FrontSystems.app/Frameworks/libHarfBuzzSharp.framework/libHarfBuzzSharp\n        0x105f6c000 -         0x1064cbfff libSkiaSharp arm64  \u003c6b45b7dee11f31139b1f1aff7553de02\u003e /private/var/containers/Bundle/Application/D3850A45-2902-483A-82EB-CA0569E57DBB/FrontSystems.app/Frameworks/libSkiaSharp.framework/libSkiaSharp\n        0x10c330000 -         0x10c33bfff libobjc-trampolines.dylib arm64e  \u003c7b2292ed23143e4f929b2831fc172b43\u003e /private/preboot/Cryptexes/OS/usr/lib/libobjc-trampolines.dylib\n        0x18f59e000 -         0x1902275ff Foundation arm64e  \u003c2bd7eb532f573300b8de478229e49115\u003e /System/Library/Frameworks/Foundation.framework/Foundation\n        0x19093b000 -         0x190eb7fff CoreFoundation arm64e  \u003c0551baa3c6e93423b0e2be69719c1d7f\u003e /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation\n        0x1924b1000 -         0x19286b45f QuartzCore arm64e  \u003caa60096595aa3af4853aa2c99d41e348\u003e /System/Library/Frameworks/QuartzCore.framework/QuartzCore\n        0x193224000 -         0x195164a1f UIKitCore arm64e  \u003c05197341f99832e5a847da98bb8c68bf\u003e /System/Library/PrivateFrameworks/UIKitCore.framework/UIKitCore\n        0x1988b8000 -         0x1988fdaff libdispatch.dylib arm64e  \u003c2c7db97b46f03a67af9fe26859f0008d\u003e /usr/lib/system/libdispatch.dylib\n        0x1988fe000 -         0x19897d8b7 libsystem_c.dylib arm64e  \u003c027de04c2929357bb6a3701405aab6be\u003e /usr/lib/system/libsystem_c.dylib\n        0x1b73c3000 -         0x1b745d013 dyld arm64e  \u003c189fe4805d5b3b89928958bc88624420\u003e /usr/lib/dyld\n        0x1dd510000 -         0x1dd518c5f GraphicsServices arm64e  \u003cc620bafa568e3bcbb31776c829cbdd46\u003e /System/Library/PrivateFrameworks/GraphicsServices.framework/GraphicsServices\n        0x1e1537000 -         0x1e1570b77 libsystem_kernel.dylib arm64e  \u003c9d196db4701331768c025b4c68701c92\u003e /usr/lib/system/libsystem_kernel.dylib\n        0x21ae0e000 -         0x21ae15627 libsystem_platform.dylib arm64e  \u003c9b52c74387943d229564b6bcf3303389\u003e /usr/lib/system/libsystem_platform.dylib\n        0x21aeb9000 -         0x21aec53fb libsystem_pthread.dylib arm64e  \u003c00306a1f11183f8690bdd18b5ed5409f\u003e /usr/lib/system/libsystem_pthread.dylib\n\nEOF\n`",
                                           "updatedAt":  "2025-05-06T12:35:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6qIxlb",
                                           "createdAt":  "2025-05-06T12:40:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOERA2Tg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "am11",
                                                                               "createdAt":  "2025-05-06T12:47:48Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "afk013",
                                                                               "createdAt":  "2025-05-06T13:34:40Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Pablo-Sierra",
                                                                               "createdAt":  "2025-05-06T17:20:00Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "kotlarmilos",
                                           "body":  "\u003e \u003e If you are up for it, can you use this runtime pack built from a [fork](https://github.com/dotnet/runtime/compare/release/9.0...kotlarmilos:runtime:release9.0/bugfix/task-finish-continuations-sentinel?expand=1) of our public 9.0 runtime branch?\n\u003e \u003e All you have to do within your project is add a nuget.config if you don\u0027t have one and add a local feed. We think this will surface an exception unique to iOS and may help us pinpoint the issue.\n\u003e \u003e [Microsoft.NETCore.App.Runtime.Mono.ios-arm64.9.0.5.nupkg.zip](https://github.com/user-attachments/files/20051993/Microsoft.NETCore.App.Runtime.Mono.ios-arm64.9.0.5.nupkg.zip)\n\u003e \n\u003e [@steveisok](https://github.com/steveisok) I just tried to include this nupkg into my app. In addition to your `nuget.config` snippet, I had to add an explicit package reference in my csproj, in order to have it picked up:\n\u003e \n\u003e ```\n\u003e     \u003cPackageReference Include=\"Microsoft.NETCore.App.Runtime.Mono.ios-arm64\" Version=\"9.0.5\" /\u003e\n\u003e ```\n\u003e \n\u003e But then `dotnet restore` gives me errors like this:\n\u003e \n\u003e ```\n\u003e error NU1213: The package Microsoft.NETCore.App.Runtime.Mono.ios-arm64 9.0.5 has a package type DotnetPlatform that is incompatible with this project. \n\u003e ```\n\u003e \n\u003e [@steveisok](https://github.com/steveisok) Could you tell me what this error means and how to get rid of it?\n\u003e \n\u003e My project is a MAUI app with TFMs like `net9.0-android` and `net9.0-ios` and I\u0027m using .NET SDK 9.0.203 on MacOS.\n\n@janusw Try to add the following instead of the `PackageReference` version:\n```\n\u003cItemGroup\u003e\n\t\u003cFrameworkReference Update=\"Microsoft.NETCore.App\"\u003e\n\t\t\u003cRuntimeFrameworkVersion\u003e9.0.5\u003c/RuntimeFrameworkVersion\u003e\n\t\u003c/FrameworkReference\u003e\n\u003c/ItemGroup\u003e\n```\n\nEnsure you have the provided `nuget.config`, and clear cache by running `dotnet nuget locals --clear all`.\n\n[Microsoft.NETCore.App.Ref.9.0.5.nupkg.zip](https://github.com/user-attachments/files/20062130/Microsoft.NETCore.App.Ref.9.0.5.nupkg.zip)\n[Microsoft.NETCore.App.Runtime.Mono.ios-arm64.9.0.5.nupkg.zip](https://github.com/user-attachments/files/20062131/Microsoft.NETCore.App.Runtime.Mono.ios-arm64.9.0.5.nupkg.zip)",
                                           "updatedAt":  "2025-05-06T12:41:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6qI1aK",
                                           "createdAt":  "2025-05-06T12:45:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEQ-V8w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "linnkrb",
                                                                               "createdAt":  "2025-05-06T12:55:11Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "kotlarmilos",
                                           "body":  "\u003e I´m not 100% sure if we got it included correct, but delete all in my previously downloded nugets in the nuget folders to start fresh, so I do belive it worked.\n\u003e And i think the error have now changed, but do not get any exception. We do have other crashes, but this is the one we got the most times and i think the other exceptions we now have is not related to this\n\n@linnkrb With the patch applied, we expect it to throw a different managed exception, which will help us determine the root cause of the failure. Did you get any managed exception trace related to threading (but not the invalid cast, which should be already addressed in the provided NuGet packages)?",
                                           "updatedAt":  "2025-05-06T12:46:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6qKUjl",
                                           "createdAt":  "2025-05-06T14:41:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janusw",
                                           "body":  "\n\u003e [@janusw](https://github.com/janusw) Try to add the following instead of the `PackageReference` version:\n\u003e \n\u003e ```\n\u003e \u003cItemGroup\u003e\n\u003e \t\u003cFrameworkReference Update=\"Microsoft.NETCore.App\"\u003e\n\u003e \t\t\u003cRuntimeFrameworkVersion\u003e9.0.5\u003c/RuntimeFrameworkVersion\u003e\n\u003e \t\u003c/FrameworkReference\u003e\n\u003e \u003c/ItemGroup\u003e\n\u003e ```\n\u003e \n\u003e Ensure you have the provided `nuget.config`, and clear cache by running `dotnet nuget locals --clear all`.\n\u003e \n\u003e [Microsoft.NETCore.App.Ref.9.0.5.nupkg.zip](https://github.com/user-attachments/files/20062130/Microsoft.NETCore.App.Ref.9.0.5.nupkg.zip) [Microsoft.NETCore.App.Runtime.Mono.ios-arm64.9.0.5.nupkg.zip](https://github.com/user-attachments/files/20062131/Microsoft.NETCore.App.Runtime.Mono.ios-arm64.9.0.5.nupkg.zip)\n\nThanks for the hints, @kotlarmilos. With this I can build, but the results are the same as before. I still see `SIGABRT: Specified cast is not valid` with the stack trace shown in the original report.\n\nSo either your modifications have no influence on the observed behavior, or the nupkgs are still not picked up properly. I actually expected my `packages.lock.json` file to reflect the modified version of `Microsoft.NETCore.App.Runtime.Mono`, but it doesn\u0027t. (Should it?)\n\n@kotlarmilos Can you recommend a simple way to verify that my build uses the nupkgs you provided?",
                                           "updatedAt":  "2025-05-06T14:41:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6qKgb1",
                                           "createdAt":  "2025-05-06T14:56:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOERA2kw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kotlarmilos",
                                                                               "createdAt":  "2025-05-06T15:10:13Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "afk013",
                                                                               "createdAt":  "2025-05-06T15:33:55Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Pablo-Sierra",
                                                                               "createdAt":  "2025-05-06T17:20:40Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "janusw",
                                           "body":  "Ok, sorry, I think I made a mistake, which caused the nupkgs not to be used. I fixed it, then saw errors like:\n\n```\nerror NU1102: Unable to find package Microsoft.NETCore.App.Runtime.Mono.android-arm with version (= 9.0.5)\n```\n\nI fixed that by removing the Android TFM, and only keeping iOS. I\u0027m about to rebuild and retry ...",
                                           "updatedAt":  "2025-05-06T14:56:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6qK04P",
                                           "createdAt":  "2025-05-06T15:16:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "linnkrb",
                                           "body":  "\n\u003e I fixed that by removing the Android TFM, and only keeping iOS. I\u0027m about to rebuild and retry ...\n\nWe got the same, but re-build with just adding those pacgages to iOs,  and still no luck getting anything that brings more light to the issue.  All our crashlogs are now of this, just varies what thread that crashes depending on how long the app has been running\n\n`Incident Identifier: 67DBFC0B-B6EC-4EA9-8894-127D2BD91F80\nDistributor ID:      com.apple.TestFlight\nHardware Model:      iPad7,5\nProcess:             FrontSystems [1790]\nPath:                /private/var/containers/Bundle/Application/72E38665-57F4-48E3-AE77-D0D5178E71BA/FrontSystems.app/FrontSystems\nIdentifier:          no.frontsystems.cornerstone\nVersion:             2.0.1 (212)\nAppStoreTools:       16E137\nAppVariant:          1:iPad7,5:17.4\nBeta:                YES\nCode Type:           ARM-64 (Native)\nRole:                Foreground\nParent Process:      launchd [1]\nCoalition:           no.frontsystems.cornerstone [447]\n\nDate/Time:           2025-05-06 16:42:54.7979 +0200\nLaunch Time:         2025-05-06 16:20:04.4101 +0200\nOS Version:          iPhone OS 17.7.6 (21H423)\nRelease Type:        User\nReport Version:      104\n\nException Type:  EXC_BAD_ACCESS (SIGSEGV)\nException Subtype: KERN_INVALID_ADDRESS at 0x0000000100000019\nException Codes: 0x0000000000000001, 0x0000000100000019\nVM Region Info: 0x100000019 is not in any region.  Bytes before following region: 49135591\n      REGION TYPE                 START - END      [ VSIZE] PRT/MAX SHRMOD  REGION DETAIL\n      UNUSED SPACE AT START\n---\u003e  \n      __TEXT                   102edc000-103b00000 [ 12.1M] r-x/r-x SM=COW  /var/containers/Bundle/Application/72E38665-57F4-48E3-AE77-D0D5178E71BA/FrontSystems.app/FrontSystems\nTriggered by Thread:  9\n\n\nKernel Triage:\nVM - (arg = 0x3) mach_vm_allocate_kernel failed within call to vm_map_enter\n\n\nThread 0 name:\nThread 0 name:\nThread 0:\n0   libsystem_kernel.dylib        \t0x00000001eb38bb58 mach_msg2_trap + 8 (:-1)\n1   libsystem_kernel.dylib        \t0x00000001eb38f224 mach_msg2_internal + 76 (mach_msg.c:201)\n2   libsystem_kernel.dylib        \t0x00000001eb38f1b0 mach_msg_overwrite + 492 (mach_msg.c:0)\n3   libsystem_kernel.dylib        \t0x00000001eb38efb8 mach_msg + 20 (mach_msg.c:323)\n4   CoreFoundation                \t0x00000001a7a65a6c __CFRunLoopServiceMachPort + 156 (CFRunLoop.c:2624)\n5   CoreFoundation                \t0x00000001a7a650dc __CFRunLoopRun + 1208 (CFRunLoop.c:3007)\n6   CoreFoundation                \t0x00000001a7a647d0 CFRunLoopRunSpecific + 572 (CFRunLoop.c:3420)\n7   GraphicsServices              \t0x00000001e74d8814 GSEventRunModal + 160 (GSEvent.c:2196)\n8   UIKitCore                     \t0x00000001a9f61268 -[UIApplication _run] + 868 (UIApplication.m:3713)\n9   UIKitCore                     \t0x00000001aa00b90c UIApplicationMain + 312 (UIApplication.m:5303)\n10  FrontSystems                  \t0x00000001037584b0 xamarin_UIApplicationMain (in FrontSystems) (bindings.m:131) + 8897712\n11  FrontSystems                  \t0x000000010394ba68 do_icall (in FrontSystems) (interp.c:2426) + 10943080\n12  FrontSystems                  \t0x000000010394a110 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 10936592\n13  FrontSystems                  \t0x0000000103945250 mono_interp_exec_method (in FrontSystems) (interp.c:4259) + 10916432\n14  FrontSystems                  \t0x0000000103940ac8 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10898120\n15  FrontSystems                  \t0x0000000103908508 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10667272\n16  FrontSystems                  \t0x00000001038abf00 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10288896\n17  FrontSystems                  \t0x00000001038b258c mono_runtime_exec_main_checked (in FrontSystems) (object.c:4808) + 10315148\n18  FrontSystems                  \t0x000000010390f6dc mono_jit_exec (in FrontSystems) (driver.c:1311) + 10696412\n19  FrontSystems                  \t0x000000010376caec xamarin_main (in FrontSystems) (monotouch-main.m:0) + 8981228\n20  FrontSystems                  \t0x0000000103b03768 main (in FrontSystems) (main.arm64.mm:81) + 12744552\n21  dyld                          \t0x00000001c8fe7228 start + 1520 (dyldMain.cpp:1298)\n\nThread 1 name:\nThread 1:\n0   libsystem_kernel.dylib        \t0x00000001eb3911a4 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x00000001fd26afd8 _pthread_cond_wait$VARIANT$mp + 1232 (pthread_cond.c:862)\n2   FrontSystems                  \t0x000000010383f5bc thread_func (in FrontSystems) (sgen-thread-pool.c:195) + 9844156\n3   libsystem_pthread.dylib       \t0x00000001fd26782c _pthread_start + 104 (pthread.c:931)\n4   libsystem_pthread.dylib       \t0x00000001fd263cd8 thread_start + 8 (:-1)\n\nThread 2 name:\nThread 2:\n0   libsystem_kernel.dylib        \t0x00000001eb38bad4 semaphore_wait_trap + 8 (:-1)\n1   FrontSystems                  \t0x00000001038e6e78 finalizer_thread (in FrontSystems) (gc.c:868) + 10530424\n2   FrontSystems                  \t0x00000001038c2b94 start_wrapper (in FrontSystems) (threads.c:1276) + 10382228\n3   libsystem_pthread.dylib       \t0x00000001fd26782c _pthread_start + 104 (pthread.c:931)\n4   libsystem_pthread.dylib       \t0x00000001fd263cd8 thread_start + 8 (:-1)\n\nThread 3 name:\nThread 3:\n0   libsystem_kernel.dylib        \t0x00000001eb38bb58 mach_msg2_trap + 8 (:-1)\n1   libsystem_kernel.dylib        \t0x00000001eb38f224 mach_msg2_internal + 76 (mach_msg.c:201)\n2   libsystem_kernel.dylib        \t0x00000001eb38f1b0 mach_msg_overwrite + 492 (mach_msg.c:0)\n3   libsystem_kernel.dylib        \t0x00000001eb38efb8 mach_msg + 20 (mach_msg.c:323)\n4   CoreFoundation                \t0x00000001a7a65a6c __CFRunLoopServiceMachPort + 156 (CFRunLoop.c:2624)\n5   CoreFoundation                \t0x00000001a7a650dc __CFRunLoopRun + 1208 (CFRunLoop.c:3007)\n6   CoreFoundation                \t0x00000001a7a647d0 CFRunLoopRunSpecific + 572 (CFRunLoop.c:3420)\n7   Foundation                    \t0x00000001a6a7f368 -[NSRunLoop(NSRunLoop) runMode:beforeDate:] + 208 (NSRunLoop.m:373)\n8   Foundation                    \t0x00000001a6a7f1e4 -[NSRunLoop(NSRunLoop) runUntilDate:] + 60 (NSRunLoop.m:420)\n9   UIKitCore                     \t0x00000001a9f73e28 -[UIEventFetcher threadMain] + 408 (UIEventFetcher.m:1207)\n10  Foundation                    \t0x00000001a6a93d04 __NSThread__start__ + 720 (NSThread.m:991)\n11  libsystem_pthread.dylib       \t0x00000001fd26782c _pthread_start + 104 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x00000001fd263cd8 thread_start + 8 (:-1)\n\nThread 4 name:\nThread 4:\n0   libsystem_kernel.dylib        \t0x00000001eb3911a4 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x00000001fd26b004 _pthread_cond_wait$VARIANT$mp + 1276 (pthread_cond.c:862)\n2   FrontSystems                  \t0x00000001037d0484 SystemNative_LowLevelMonitor_TimedWait (in FrontSystems) (pal_threading.c:198) + 9389188\n3   FrontSystems                  \t0x000000010394bb08 do_icall (in FrontSystems) (interp.c:2390) + 10943240\n4   FrontSystems                  \t0x000000010394a110 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 10936592\n5   FrontSystems                  \t0x0000000103945250 mono_interp_exec_method (in FrontSystems) (interp.c:4259) + 10916432\n6   FrontSystems                  \t0x0000000103940ac8 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10898120\n7   FrontSystems                  \t0x0000000103908508 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10667272\n8   FrontSystems                  \t0x00000001038abf00 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10288896\n9   FrontSystems                  \t0x00000001038c2b78 start_wrapper (in FrontSystems) (threads.c:1276) + 10382200\n10  libsystem_pthread.dylib       \t0x00000001fd26782c _pthread_start + 104 (pthread.c:931)\n11  libsystem_pthread.dylib       \t0x00000001fd263cd8 thread_start + 8 (:-1)\n\nThread 5 name:\nThread 5:\n0   libsystem_kernel.dylib        \t0x00000001eb3911a4 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x00000001fd26b004 _pthread_cond_wait$VARIANT$mp + 1276 (pthread_cond.c:862)\n2   FrontSystems                  \t0x00000001037d0484 SystemNative_LowLevelMonitor_TimedWait (in FrontSystems) (pal_threading.c:198) + 9389188\n3   FrontSystems                  \t0x000000010394bb08 do_icall (in FrontSystems) (interp.c:2390) + 10943240\n4   FrontSystems                  \t0x000000010394a110 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 10936592\n5   FrontSystems                  \t0x0000000103945250 mono_interp_exec_method (in FrontSystems) (interp.c:4259) + 10916432\n6   FrontSystems                  \t0x0000000103940ac8 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10898120\n7   FrontSystems                  \t0x0000000103908508 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10667272\n8   FrontSystems                  \t0x00000001038abf00 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10288896\n9   FrontSystems                  \t0x00000001038c2b78 start_wrapper (in FrontSystems) (threads.c:1276) + 10382200\n10  libsystem_pthread.dylib       \t0x00000001fd26782c _pthread_start + 104 (pthread.c:931)\n11  libsystem_pthread.dylib       \t0x00000001fd263cd8 thread_start + 8 (:-1)\n\nThread 6 name:\nThread 6:\n0   libsystem_kernel.dylib        \t0x00000001eb3911a4 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x00000001fd26b004 _pthread_cond_wait$VARIANT$mp + 1276 (pthread_cond.c:862)\n2   FrontSystems                  \t0x00000001037d0484 SystemNative_LowLevelMonitor_TimedWait (in FrontSystems) (pal_threading.c:198) + 9389188\n3   FrontSystems                  \t0x000000010394bb08 do_icall (in FrontSystems) (interp.c:2390) + 10943240\n4   FrontSystems                  \t0x000000010394a110 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 10936592\n5   FrontSystems                  \t0x0000000103945250 mono_interp_exec_method (in FrontSystems) (interp.c:4259) + 10916432\n6   FrontSystems                  \t0x0000000103940ac8 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10898120\n7   FrontSystems                  \t0x0000000103908508 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10667272\n8   FrontSystems                  \t0x00000001038abf00 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10288896\n9   FrontSystems                  \t0x00000001038c2b78 start_wrapper (in FrontSystems) (threads.c:1276) + 10382200\n10  libsystem_pthread.dylib       \t0x00000001fd26782c _pthread_start + 104 (pthread.c:931)\n11  libsystem_pthread.dylib       \t0x00000001fd263cd8 thread_start + 8 (:-1)\n\nThread 7 name:\nThread 7:\n0   libsystem_kernel.dylib        \t0x00000001eb3911a4 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x00000001fd26b004 _pthread_cond_wait$VARIANT$mp + 1276 (pthread_cond.c:862)\n2   FrontSystems                  \t0x00000001037d0484 SystemNative_LowLevelMonitor_TimedWait (in FrontSystems) (pal_threading.c:198) + 9389188\n3   FrontSystems                  \t0x000000010394bb08 do_icall (in FrontSystems) (interp.c:2390) + 10943240\n4   FrontSystems                  \t0x000000010394a110 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 10936592\n5   FrontSystems                  \t0x0000000103945250 mono_interp_exec_method (in FrontSystems) (interp.c:4259) + 10916432\n6   FrontSystems                  \t0x0000000103940ac8 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10898120\n7   FrontSystems                  \t0x0000000103908508 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10667272\n8   FrontSystems                  \t0x00000001038abf00 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10288896\n9   FrontSystems                  \t0x00000001038c2b78 start_wrapper (in FrontSystems) (threads.c:1276) + 10382200\n10  libsystem_pthread.dylib       \t0x00000001fd26782c _pthread_start + 104 (pthread.c:931)\n11  libsystem_pthread.dylib       \t0x00000001fd263cd8 thread_start + 8 (:-1)\n\nThread 8 name:\nThread 8:\n0   libsystem_kernel.dylib        \t0x00000001eb3923ec kevent + 8 (:-1)\n1   FrontSystems                  \t0x00000001037ce5c0 SystemNative_WaitForSocketEvents (in FrontSystems) (pal_networking.c:3256) + 9381312\n2   FrontSystems                  \t0x000000010394bae4 do_icall (in FrontSystems) (interp.c:2402) + 10943204\n3   FrontSystems                  \t0x000000010394a110 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 10936592\n4   FrontSystems                  \t0x0000000103945250 mono_interp_exec_method (in FrontSystems) (interp.c:4259) + 10916432\n5   FrontSystems                  \t0x0000000103940ac8 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10898120\n6   FrontSystems                  \t0x0000000103908508 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10667272\n7   FrontSystems                  \t0x00000001038abf00 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10288896\n8   FrontSystems                  \t0x00000001038c2b78 start_wrapper (in FrontSystems) (threads.c:1276) + 10382200\n9   libsystem_pthread.dylib       \t0x00000001fd26782c _pthread_start + 104 (pthread.c:931)\n10  libsystem_pthread.dylib       \t0x00000001fd263cd8 thread_start + 8 (:-1)\n\nThread 9 name:\nThread 9 Crashed:\n0   FrontSystems                  \t0x0000000103943268 mono_interp_exec_method (in FrontSystems) (interp.c:6221) + 10908264\n1   FrontSystems                  \t0x0000000103940ac8 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10898120\n2   FrontSystems                  \t0x0000000103908508 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10667272\n3   FrontSystems                  \t0x00000001038abf00 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10288896\n4   FrontSystems                  \t0x00000001038c2b78 start_wrapper (in FrontSystems) (threads.c:1276) + 10382200\n5   libsystem_pthread.dylib       \t0x00000001fd26782c _pthread_start + 104 (pthread.c:931)\n6   libsystem_pthread.dylib       \t0x00000001fd263cd8 thread_start + 8 (:-1)\n\nThread 10:\n0   libsystem_pthread.dylib       \t0x00000001fd263cc4 start_wqthread + 0 (:-1)\n\nThread 11 name:\nThread 11:\n0   libsystem_kernel.dylib        \t0x00000001eb3911a4 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x00000001fd26afd8 _pthread_cond_wait$VARIANT$mp + 1232 (pthread_cond.c:862)\n2   FrontSystems                  \t0x00000001037f538c mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9540492\n3   FrontSystems                  \t0x00000001037f9158 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9556312\n4   FrontSystems                  \t0x000000010394bb08 do_icall (in FrontSystems) (interp.c:2390) + 10943240\n5   FrontSystems                  \t0x000000010394a148 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 10936648\n6   FrontSystems                  \t0x0000000103945250 mono_interp_exec_method (in FrontSystems) (interp.c:4259) + 10916432\n7   FrontSystems                  \t0x0000000103940ac8 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10898120\n8   FrontSystems                  \t0x0000000103908508 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10667272\n9   FrontSystems                  \t0x00000001038abf00 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10288896\n10  FrontSystems                  \t0x00000001038c2b78 start_wrapper (in FrontSystems) (threads.c:1276) + 10382200\n11  libsystem_pthread.dylib       \t0x00000001fd26782c _pthread_start + 104 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x00000001fd263cd8 thread_start + 8 (:-1)\n\nThread 12:\n0   libsystem_pthread.dylib       \t0x00000001fd263cc4 start_wqthread + 0 (:-1)\n\nThread 13 name:\nThread 13:\n0   libsystem_kernel.dylib        \t0x00000001eb3911a4 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x00000001fd26afd8 _pthread_cond_wait$VARIANT$mp + 1232 (pthread_cond.c:862)\n2   FrontSystems                  \t0x00000001037f538c mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9540492\n3   FrontSystems                  \t0x00000001037f9158 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9556312\n4   FrontSystems                  \t0x000000010394bb08 do_icall (in FrontSystems) (interp.c:2390) + 10943240\n5   FrontSystems                  \t0x000000010394a148 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 10936648\n6   FrontSystems                  \t0x0000000103945250 mono_interp_exec_method (in FrontSystems) (interp.c:4259) + 10916432\n7   FrontSystems                  \t0x0000000103940ac8 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10898120\n8   FrontSystems                  \t0x0000000103908508 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10667272\n9   FrontSystems                  \t0x00000001038abf00 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10288896\n10  FrontSystems                  \t0x00000001038c2b78 start_wrapper (in FrontSystems) (threads.c:1276) + 10382200\n11  libsystem_pthread.dylib       \t0x00000001fd26782c _pthread_start + 104 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x00000001fd263cd8 thread_start + 8 (:-1)\n\nThread 14:\n0   libsystem_pthread.dylib       \t0x00000001fd263cc4 start_wqthread + 0 (:-1)\n\nThread 15:\n0   libsystem_pthread.dylib       \t0x00000001fd263cc4 start_wqthread + 0 (:-1)\n\n\nThread 9 crashed with ARM Thread State (64-bit):\n    x0: 0x000000011c0f5230   x1: 0x000000011c0f5238   x2: 0x0000000100000001   x3: 0x000000010380594c\n    x4: 0x000000010386acb4   x5: 0x0000000000000000   x6: 0x0000000000000000   x7: 0x000000016d67e88c\n    x8: 0x0000000100000001   x9: 0x0000000000000018  x10: 0x00000000000000c0  x11: 0x0000000000000008\n   x12: 0x0000000000000000  x13: 0x000000012b441aa8  x14: 0x00000000ffffffff  x15: 0x00000001260bd820\n   x16: 0x00000001fd1adb80  x17: 0x0000000000000001  x18: 0x0000000000000000  x19: 0x000000016d67e860\n   x20: 0x0000000000000010  x21: 0x000000016d67df30  x22: 0x000000000000001b  x23: 0x0000000126551178\n   x24: 0x0000000126551098  x25: 0x000000016d67df30  x26: 0x0000000103d7cf08  x27: 0x0000000301246880\n   x28: 0x000000011c0f5270   fp: 0x000000016d67e9f0   lr: 0x00000001039474f8\n    sp: 0x000000016d67bda0   pc: 0x0000000103943268 cpsr: 0x80000000\n   esr: 0x56000080  Address size fault\n\n\nBinary Images:\n        0x102edc000 -         0x103d53fff FrontSystems arm64  \u003cef9ccd57f91e323da9be5ad5b08ac5fc\u003e /private/var/containers/Bundle/Application/72E38665-57F4-48E3-AE77-D0D5178E71BA/FrontSystems.app/FrontSystems\n        0x104624000 -         0x10476bfff libHarfBuzzSharp arm64  \u003c8ca693a9d0533072850919c5df43d67e\u003e /private/var/containers/Bundle/Application/72E38665-57F4-48E3-AE77-D0D5178E71BA/FrontSystems.app/Frameworks/libHarfBuzzSharp.framework/libHarfBuzzSharp\n        0x104788000 -         0x104ce7fff libSkiaSharp arm64  \u003c6b45b7dee11f31139b1f1aff7553de02\u003e /private/var/containers/Bundle/Application/72E38665-57F4-48E3-AE77-D0D5178E71BA/FrontSystems.app/Frameworks/libSkiaSharp.framework/libSkiaSharp\n        0x109658000 -         0x109663fff libobjc-trampolines.dylib arm64  \u003ceb3d5206bc9b353abbd95f0b8cb87223\u003e /private/preboot/Cryptexes/OS/usr/lib/libobjc-trampolines.dylib\n        0x1a69c4000 -         0x1a746dfff Foundation arm64  \u003c96733d340a373c34810a735d1720ae42\u003e /System/Library/Frameworks/Foundation.framework/Foundation\n        0x1a7a15000 -         0x1a7f2efff CoreFoundation arm64  \u003ca422c57854c430c686d85ea81d9694be\u003e /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation\n        0x1a9b8e000 -         0x1ab56cfff UIKitCore arm64  \u003c9c152472929f36f6ba1bb04b81a1a3d4\u003e /System/Library/PrivateFrameworks/UIKitCore.framework/UIKitCore\n        0x1c8fb0000 -         0x1c902f84b dyld arm64  \u003cac75b14264df3e3fb8b58cc2659746bd\u003e /usr/lib/dyld\n        0x1e74d7000 -         0x1e74dffff GraphicsServices arm64  \u003cbb7850853ff43338baf91e2cb995360f\u003e /System/Library/PrivateFrameworks/GraphicsServices.framework/GraphicsServices\n        0x1eb38a000 -         0x1eb3c1fef libsystem_kernel.dylib arm64  \u003c1abf4f5efe0834368be694b61970defd\u003e /usr/lib/system/libsystem_kernel.dylib\n        0x1fd1ac000 -         0x1fd1b7ff7 libsystem_platform.dylib arm64  \u003cdbe0cb03f16a3021b8d3512ac2580923\u003e /usr/lib/system/libsystem_platform.dylib\n        0x1fd263000 -         0x1fd273ffb libsystem_pthread.dylib arm64  \u003c05d0d8cf4b863a7fa70d7006d7925763\u003e /usr/lib/system/libsystem_pthread.dylib\n        0x1ffe98000 -         0x200661fff ANECompiler arm64  \u003c39ad5a9a2029337e8194b3464ae1c81d\u003e /System/Library/PrivateFrameworks/ANECompiler.framework/ANECompiler\n\nEOF\n`",
                                           "updatedAt":  "2025-05-06T15:16:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6qLEMJ",
                                           "createdAt":  "2025-05-06T15:28:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOERA7lA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "afk013",
                                                                               "createdAt":  "2025-05-06T15:34:19Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pme442",
                                                                               "createdAt":  "2025-05-06T15:35:50Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "steveisok",
                                                                               "createdAt":  "2025-05-06T15:36:00Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "am11",
                                                                               "createdAt":  "2025-05-06T16:09:23Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Pablo-Sierra",
                                                                               "createdAt":  "2025-05-06T17:21:28Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kotlarmilos",
                                                                               "createdAt":  "2025-05-06T17:24:18Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "linnkrb",
                                                                               "createdAt":  "2025-05-06T17:29:40Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  7
                                                         },
                                           "author":  "wgriep",
                                           "body":  "I have used the fork and was able to get the following running on the iPhone. Hopefully this will help. As a refresher, we are running in a Parallel.ForEachAsync()\n\nTaskScheduler.UnobservedTaskException --\u003e System.NullReferenceException: Object reference not set to an instance of an object.\n   at System.Threading.Tasks.ContinuationTaskFromTask.InnerInvoke()\n   at System.Threading.Tasks.Task.\u003c\u003ec.\u003c.cctor\u003eb__292_0(Object obj)\n   at System.Threading.ExecutionContext.RunFromThreadPoolDispatchLoop(Thread threadPoolThread, ExecutionContext executionContext, ContextCallback callback, Object state)\n--- End of stack trace from previous location ---\n   at System.Threading.ExecutionContext.RunFromThreadPoolDispatchLoop(Thread threadPoolThread, ExecutionContext executionContext, ContextCallback callback, Object state)\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)",
                                           "updatedAt":  "2025-05-06T15:28:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6qLhCR",
                                           "createdAt":  "2025-05-06T16:07:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOERBrIw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "Pablo-Sierra",
                                                                               "createdAt":  "2025-05-06T17:21:22Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "linnkrb",
                                                                               "createdAt":  "2025-05-06T17:29:31Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "wgriep",
                                                                               "createdAt":  "2025-05-06T18:55:51Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "steveisok",
                                           "body":  "\u003e I have used the fork and was able to get the following running on the iPhone. Hopefully this will help. As a refresher, we are running in a Parallel.ForEachAsync()\n\n@wgriep and others, I appreciate you all being willing to drink from the firehose ;-). Please keep the info coming if you have it and we\u0027ll keep trying to narrow this down. \n\n",
                                           "updatedAt":  "2025-05-06T16:07:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6qNNX3",
                                           "createdAt":  "2025-05-06T18:50:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOERCIPw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "kotlarmilos",
                                                                               "createdAt":  "2025-05-06T19:52:11Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "janusw",
                                           "body":  "\u003e Ok, sorry, I think I made a mistake, which caused the nupkgs not to be used. I fixed it, then saw errors like:\n\u003e \n\u003e ```\n\u003e error NU1102: Unable to find package Microsoft.NETCore.App.Runtime.Mono.android-arm with version (= 9.0.5)\n\u003e ```\n\u003e \n\u003e I fixed that by removing the Android TFM, and only keeping iOS. I\u0027m about to rebuild and retry ...\n\nDespite longer testing sessions on two different devices, I haven\u0027t been able to trigger any more crashes/exceptions with the modified runtime pkgs, which might indicate that these pkgs already fix the problem for our use case, or at least make it even more unlikely than before.\n\nI\u0027ll note that our use case is not as massively multi-threaded as the `ForEachAsync` mentioned by @wgriep. We only have the occasional `Task.Run` and similar stuff.",
                                           "updatedAt":  "2025-05-06T18:50:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6qXMwU",
                                           "createdAt":  "2025-05-07T11:25:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOERJ1fw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "wgriep",
                                                                               "createdAt":  "2025-05-07T12:00:30Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "kotlarmilos",
                                           "body":  "@wgriep If you have a reliable repro on your side, could you temporarily disable the GC and see if you still get the failure?\n```\nif (GC.TryStartNoGCRegion(10_000_000))  // 10MB ?\n{\n   try\n   {\n       Parallel.ForEachAsync(...);\n   }\n   finally\n   {\n       GC.EndNoGCRegion();\n   }\n}\n```\nAlso, if you can share the repro or describe exactly how you’re calling `Parallel.ForEachAsync(...)`, that would help us narrow down the issue.",
                                           "updatedAt":  "2025-05-07T11:25:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6qX35O",
                                           "createdAt":  "2025-05-07T12:24:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOERKILQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kotlarmilos",
                                                                               "createdAt":  "2025-05-07T12:36:21Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "wgriep",
                                           "body":  "@kotlarmilos unfortunately you can\u0027t make that call on iOS\n\nSystem.NotImplementedException: The method or operation is not implemented.\n   at System.GC.StartNoGCRegion(Int64 totalSize, Boolean hasLohSize, Int64 lohSize, Boolean disallowFullBlockingGC)\n   at System.GC.TryStartNoGCRegion(Int64 totalSize)\n\nI will put together high-level code that we are performing in the Parallel.ForEachAsync.\n",
                                           "updatedAt":  "2025-05-07T12:24:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6qYYpQ",
                                           "createdAt":  "2025-05-07T13:04:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOERKcDw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kotlarmilos",
                                                                               "createdAt":  "2025-05-07T13:05:34Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "linnkrb",
                                                                               "createdAt":  "2025-05-07T13:06:02Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "wgriep",
                                           "body":  "@kotlarmilos please see code below.  High-level, we are downloading 200+ files; sizes ranging from 1 MB - 3 GB. \n\n\u003cdetails\u003e\n\n\u003csummary\u003eParallel.ForEachAsync usage\u003c/summary\u003e\n`    \n    public class SiteData\n    {\n        public CancellationTokenSource CancellationTokenSource { get; set; }\n        public string Url { get; set; }\n        public string DestinationPathName { get; set; }\n    }\n\n    public class SiteDownloader\n    {\n        static HttpClient _httpClient = new HttpClient() { Timeout = new TimeSpan(1, 0, 0) };\n\n        public async void PerformDownloads(ObservableCollection\u003cSiteData\u003e sites)\n        {\n            decimal totalSize = 0;\n            var cancelSource = new CancellationTokenSource();\n\n            ParallelOptions options = new()\n            {\n                MaxDegreeOfParallelism = 5,\n                CancellationToken = cancelSource.Token,\n            };\n            await Parallel.ForEachAsync(sites, options, async (site, token) =\u003e\n            {\n                using (HttpResponseMessage response = await _httpClient.GetAsync(site.Url, HttpCompletionOption.ResponseHeadersRead, site.CancellationTokenSource.Token))\n                {\n                    response.EnsureSuccessStatusCode();\n                    var contentLength = response.Content.Headers.ContentLength;\n                    if (contentLength.HasValue)\n                    {\n                        totalSize = contentLength.Value;\n                    }\n\n                    int readChunkSize = 4096;\n\n                    //Let\u0027s calculate the buffer size based on the file size\n                    if (totalSize \u003c 50000)//500KB\n                    {\n                        readChunkSize = 4096;\n                    }\n                    else if (totalSize \u003c 1000000)//1MB\n                    {\n                        readChunkSize = 81920;\n                    }\n                    else if (totalSize \u003c 100000000)// 100MB\n                    {\n                        readChunkSize = 131072;\n                    }\n                    else if (totalSize \u003c 100000000000)//1GB\n                    {\n                        readChunkSize = 524288;\n                    }\n                    else //\u003e=1GB\n                    {\n                        readChunkSize = 1048576;\n                    }\n                    FileStreamOptions fileStreamOptions = new FileStreamOptions();\n                    fileStreamOptions.Mode = FileMode.Create;\n                    fileStreamOptions.Access = FileAccess.Write;\n                    fileStreamOptions.PreallocationSize = (long)totalSize;\n                    fileStreamOptions.BufferSize = readChunkSize;\n\n                    using (var fileStream = new FileStream(site.DestinationPathName, fileStreamOptions))\n                    {\n                        using (Stream contentStream = await response.Content.ReadAsStreamAsync(site.CancellationTokenSource.Token))\n                        {\n                            var buffer = new byte[readChunkSize];\n                            int read = 0;\n                            while ((read = await contentStream.ReadAsync(buffer.AsMemory(0, readChunkSize), site.CancellationTokenSource.Token)) \u003e 0)\n                            {\n\n                                await fileStream.WriteAsync(buffer.AsMemory(0, read), site.CancellationTokenSource.Token);\n                            }\n                        }\n\n                    }\n                }\n            });\n        }\n\n    }\n`\n\u003c/details\u003e",
                                           "updatedAt":  "2025-05-07T13:04:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6qpRJ0",
                                           "createdAt":  "2025-05-08T12:51:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOERVDPQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "wgriep",
                                                                               "createdAt":  "2025-05-08T13:17:13Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "steveisok",
                                           "body":  "@wgriep (and others who want to try), can you put `\u003cEnableSGenConc\u003efalse\u003c/EnableSGenConc\u003e` in your csproj and try your repro again?",
                                           "updatedAt":  "2025-05-08T12:51:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6qtYO8",
                                           "createdAt":  "2025-05-08T19:07:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wgriep",
                                           "body":  "@steveisok I didn\u0027t try the EnableSGenConc false (we have it set to true) but based on all the hinting around the GC, I did change some code that may help with the investigation.\n\nBackground: old practice due to memory leaks in previous versions of Maui, we have GC running on a background timer to help recover memory, particularly on iOS.\n\nAfter we start our app, the timer is kicked off and scheduled every minute to do GC.Collect().  I tried not kicking off that timer and we aren\u0027t getting the exception (I reverted and not using your fork).  I\u0027ve been able to test this on the iPhone and it worked 4 times, but the fifth try, crashed.\n\nI will try disabling concurrent memory collection next.\n\nIs the thought that GC.Collect may be impacting Parallel.ForEachAsync (or multiple threads for that matter) on iOS?",
                                           "updatedAt":  "2025-05-08T19:07:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6qva8T",
                                           "createdAt":  "2025-05-08T22:18:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kotlarmilos",
                                           "body":  "\u003e I have used the fork and was able to get the following running on the iPhone. Hopefully this will help. As a refresher, we are running in a Parallel.ForEachAsync()\n\n\u003e TaskScheduler.UnobservedTaskException --\u003e System.NullReferenceException: Object reference not set to an instance of an object.\nat System.Threading.Tasks.ContinuationTaskFromTask.InnerInvoke()\nat System.Threading.Tasks.Task.\u003c\u003ec.\u003c.cctor\u003eb__292_0(Object obj)\nat System.Threading.ExecutionContext.RunFromThreadPoolDispatchLoop(Thread threadPoolThread, ExecutionContext executionContext, ContextCallback callback, Object state)\n--- End of stack trace from previous location ---\nat System.Threading.ExecutionContext.RunFromThreadPoolDispatchLoop(Thread threadPoolThread, ExecutionContext executionContext, ContextCallback callback, Object state)\nat System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread) \n\n@wgriep Was the `NullReferenceException` thrown directly in `ContinuationTaskFromTask.InnerInvoke`, or were there additional frames between the exception and `InnerInvoke`?\n\nI’d like to double-check that we’re focusing our investigation in the right direction.\n\nThanks a lot for the help!",
                                           "updatedAt":  "2025-05-08T22:18:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6q2B_A",
                                           "createdAt":  "2025-05-09T12:05:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOERfJtg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kotlarmilos",
                                                                               "createdAt":  "2025-05-09T13:34:33Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "wgriep",
                                           "body":  "I\u0027m not sure, I was only able to catch at the app level.  I captured the \"e.Exception\" in the below code\n\n`//Add Unobserved Task Exception\n   TaskScheduler.UnobservedTaskException += (sender, e) =\u003e\n   {\n       // Log the exception\n       e.SetObserved();\n   };\n`",
                                           "updatedAt":  "2025-05-09T12:06:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6q7xDW",
                                           "createdAt":  "2025-05-09T20:19:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pme442",
                                           "body":  "FYI, I used the fork as well.  However, I am having a really difficult time reproducing the issue in my repo app.  I\u0027ve been at it for 3 days now and no luck.  The app eventually crashes, but no errors are logged in my error log and nothing from apple either.  I\u0027m not really sure if this behavior is the forked code, or if I\u0027m just not lucky enough to hit the right sequence of events that cause the error.\nI did apply the fork to my real app and I got the InvalidCastException error in about 20 minutes.\nI think I am going to remove the forked code from my repo app and see if I can get the error to happen again -- just so I know I\u0027m not losing my mind and that I really do know how to reproduce it there.  \nOh, I haven\u0027t tried the EnableSGenConc setting yet.  That\u0027s next on my list.",
                                           "updatedAt":  "2025-05-09T22:12:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6q8KyA",
                                           "createdAt":  "2025-05-09T21:20:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pme442",
                                           "body":  "Question:  How do I remove the forked code from my project?  Can I just remove the nuget.config file, delete the bin and obj folders, and clean and rebuild the solution?   Would that be enough  or is there something else I need to do?",
                                           "updatedAt":  "2025-05-09T21:20:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6q8Unj",
                                           "createdAt":  "2025-05-09T21:46:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOERvGQQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pme442",
                                                                               "createdAt":  "2025-05-09T22:04:02Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "linnkrb",
                                                                               "createdAt":  "2025-05-12T11:44:54Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "steveisok",
                                           "body":  "\u003e Question: How do I remove the forked code from my project? Can I just remove the nuget.config file, delete the bin and obj folders, and clean and rebuild the solution? Would that be enough or is there something else I need to do?\n\nYeah, that should do. It\u0027ll look in the reguarly scheduled spot for the runtime we ship with.",
                                           "updatedAt":  "2025-05-09T21:46:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6rJSXY",
                                           "createdAt":  "2025-05-12T08:08:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janusw",
                                           "body":  "\u003e [@wgriep](https://github.com/wgriep) (and others who want to try), can you put `\u003cEnableSGenConc\u003efalse\u003c/EnableSGenConc\u003e` in your csproj and try your repro again?\n\nI tried this, but in fact I still see the same crashes (with the original 9.0.4 runtime, not with the custom nupkgs). So, unfortunately it does not look like a viable workaround to me 🤷 ",
                                           "updatedAt":  "2025-05-12T08:08:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6rM835",
                                           "createdAt":  "2025-05-12T12:06:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "linnkrb",
                                           "body":  "We have used the fork and we do not get the original problem with the InvalidCastException, at elast it´s not reported anywhere anymore. BUT, we have still got random crashes that we did not get in .net8, so we do think it´s the same issue in many ways or should I create another thread for this ?  \n\nWe have are constantly improving with removing  allot of throws that should be catched lower down in the code, think that has helped a bit. Also instead of doing      await Task.WhenAll(.  we are calling our tasks one after each other awaited.\nWe removed socketmobile nuget, as that also gave us some random crashes as well.\n\nBut still after removing everything we can think of, we still keep having this radom crash in release. It works REALLY well in debug and that makes it even more frustration.  \n\nWe have quite allot of things going on, tried to remove most of them, but we still cannot pinpoint what creates the crash, so have a feeling it might be the sum of them all ?\n\nWe have tried \u003cMtouchLink\u003eNone\u003c/MtouchLink\u003e, but then it crashed right away with this crash report:\n\n`Incident Identifier: 343E6AF8-FA0D-4156-B474-09DE69D44987\nDistributor ID:      com.apple.TestFlight\nHardware Model:      iPad7,5\nProcess:             FrontSystems [1151]\nPath:                /private/var/containers/Bundle/Application/CA76E648-7F89-4B4C-AB55-13CD4202ECAA/FrontSystems.app/FrontSystems\nIdentifier:          no.frontsystems.cornerstone\nVersion:             2.0.1 (231)\nAppStoreTools:       16E137\nAppVariant:          1:iPad7,5:17.4\nBeta:                YES\nCode Type:           ARM-64 (Native)\nRole:                Foreground\nParent Process:      launchd [1]\nCoalition:           no.frontsystems.cornerstone [425]\n\nDate/Time:           2025-05-10 00:01:06.4123 +0200\nLaunch Time:         2025-05-10 00:01:06.3407 +0200\nOS Version:          iPhone OS 17.7.6 (21H423)\nRelease Type:        User\nReport Version:      104\n\nException Type:  EXC_CRASH (SIGABRT)\nException Codes: 0x0000000000000000, 0x0000000000000000\nTermination Reason: SIGNAL 6 Abort trap: 6\nTerminating Process: FrontSystems [1151]\n\nTriggered by Thread:  0\n\n\nThread 0 name:\nThread 0 name:\nThread 0 Crashed:\n0   libsystem_kernel.dylib        \t0x00000001d91b5f74 __pthread_kill + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x00000001eb088fa4 pthread_kill + 208 (pthread.c:1721)\n2   libsystem_c.dylib             \t0x000000019d00c708 abort + 104 (abort.c:0)\n3   FrontSystems                  \t0x00000001057a42bc mono_runtime_setup_stat_profiler.cold.1 (in FrontSystems) (mini-posix.c:0) + 21054140\n4   FrontSystems                  \t0x00000001054aeecc mono_runtime_setup_stat_profiler (in FrontSystems) (mini-posix.c:692) + 17952460\n5   libsystem_platform.dylib      \t0x00000001eafcd714 _sigtramp + 52 (sigtramp.c:116)\n6   libsystem_pthread.dylib       \t0x00000001eb088fa4 pthread_kill + 208 (pthread.c:1721)\n7   libsystem_c.dylib             \t0x000000019d00c708 abort + 104 (abort.c:0)\n8   FrontSystems                  \t0x000000010536310c mono_log_write_os_log (in FrontSystems) (mono-log-darwin.c:0) + 16593164\n9   FrontSystems                  \t0x0000000105356880 monoeg_g_logv (in FrontSystems) (goutput.c:173) + 16541824\n10  FrontSystems                  \t0x00000001053569c8 monoeg_g_log (in FrontSystems) (goutput.c:184) + 16542152\n11  FrontSystems                  \t0x0000000105486a80 load_aot_module (in FrontSystems) (aot-runtime.c:2406) + 17787520\n12  FrontSystems                  \t0x000000010548ab04 mono_aot_get_method (in FrontSystems) (aot-runtime.c:4968) + 17804036\n13  FrontSystems                  \t0x000000010547a2cc mono_jit_compile_method_with_opt (in FrontSystems) (mini-runtime.c:2763) + 17736396\n14  FrontSystems                  \t0x0000000105478258 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:3526) + 17728088\n15  FrontSystems                  \t0x000000010541bf00 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 17350400\n16  FrontSystems                  \t0x00000001053d4e70 create_exception_two_strings (in FrontSystems) (exception.c:177) + 17059440\n17  FrontSystems                  \t0x00000001053d4c14 mono_exception_from_name_two_strings_checked (in FrontSystems) (exception.c:236) + 17058836\n18  FrontSystems                  \t0x00000001053b1970 mono_runtime_init_checked (in FrontSystems) (appdomain.c:283) + 16914800\n19  FrontSystems                  \t0x0000000105477bc8 mini_init (in FrontSystems) (mini-runtime.c:4905) + 17726408\n20  FrontSystems                  \t0x00000001054827a4 mono_jit_init_version (in FrontSystems) (driver.c:2736) + 17770404\n21  FrontSystems                  \t0x00000001052db7d8 xamarin_bridge_initialize (in FrontSystems) (monovm-bridge.m:93) + 16037848\n22  FrontSystems                  \t0x00000001052dc9c8 xamarin_main (in FrontSystems) (monotouch-main.m:438) + 16042440\n23  FrontSystems                  \t0x0000000105673768 main (in FrontSystems) (main.arm64.mm:81) + 19806056\n24  dyld                          \t0x00000001b6e07228 start + 1520 (dyldMain.cpp:1298)\n\nThread 1:\n0   libsystem_pthread.dylib       \t0x00000001eb083cd0 thread_start + 0 (:-1)\n\nThread 2:\n0   libsystem_pthread.dylib       \t0x00000001eb083cd0 thread_start + 0 (:-1)\n\n\nThread 0 crashed with ARM Thread State (64-bit):\n    x0: 0x0000000000000000   x1: 0x0000000000000000   x2: 0x0000000000000000   x3: 0x0000000000000000\n    x4: 0xffffffff99eab599   x5: 0x0000000000000008   x6: 0x000000016ba6dbc0   x7: 0x000000016ba6d2b0\n    x8: 0x0000000202184d40   x9: 0x4176241ea02cceec  x10: 0x3d3d3d3d3d3d3d3d  x11: 0x3d3d3d3d3d3d3d3d\n   x12: 0x3d3d3d3d3d3d3d3d  x13: 0x3d3d3d3d3d3d3d3d  x14: 0x3d3d3d3d3d3d3d3d  x15: 0x0a3d3d3d3d3d3d3d\n   x16: 0x0000000000000148  x17: 0x0000000000000001  x18: 0x0000000000000000  x19: 0x0000000000000006\n   x20: 0x0000000000000103  x21: 0x0000000202184e20  x22: 0x0000000000000010  x23: 0x0000000000000004\n   x24: 0x0000000105e80f04  x25: 0x00000003027a8000  x26: 0x0000000105bd6f00  x27: 0x00000003017a4700\n   x28: 0x0000000109170590   fp: 0x000000016ba6dbd0   lr: 0x00000001eb088fa4\n    sp: 0x000000016ba6dbb0   pc: 0x00000001d91b5f74 cpsr: 0x40000000\n   esr: 0x56000080  Address size fault\n\n\nBinary Images:\n        0x104390000 -         0x105a17fff FrontSystems arm64  \u003cf9bf50fa48d836bea38a6580fe97115b\u003e /private/var/containers/Bundle/Application/CA76E648-7F89-4B4C-AB55-13CD4202ECAA/FrontSystems.app/FrontSystems\n        0x1063e4000 -         0x10652bfff libHarfBuzzSharp arm64  \u003c8ca693a9d0533072850919c5df43d67e\u003e /private/var/containers/Bundle/Application/CA76E648-7F89-4B4C-AB55-13CD4202ECAA/FrontSystems.app/Frameworks/libHarfBuzzSharp.framework/libHarfBuzzSharp\n        0x106548000 -         0x106aa7fff libSkiaSharp arm64  \u003c6b45b7dee11f31139b1f1aff7553de02\u003e /private/var/containers/Bundle/Application/CA76E648-7F89-4B4C-AB55-13CD4202ECAA/FrontSystems.app/Frameworks/libSkiaSharp.framework/libSkiaSharp\n        0x1947e4000 -         0x19528dfff Foundation arm64  \u003c96733d340a373c34810a735d1720ae42\u003e /System/Library/Frameworks/Foundation.framework/Foundation\n        0x19cf9b000 -         0x19d014fff libsystem_c.dylib arm64  \u003c40c30adb93f73ed4a9dd51d191289df5\u003e /usr/lib/system/libsystem_c.dylib\n        0x1b6dd0000 -         0x1b6e4f84b dyld arm64  \u003cac75b14264df3e3fb8b58cc2659746bd\u003e /usr/lib/dyld\n        0x1d91aa000 -         0x1d91e1fef libsystem_kernel.dylib arm64  \u003c1abf4f5efe0834368be694b61970defd\u003e /usr/lib/system/libsystem_kernel.dylib\n        0x1eafcc000 -         0x1eafd7ff7 libsystem_platform.dylib arm64  \u003cdbe0cb03f16a3021b8d3512ac2580923\u003e /usr/lib/system/libsystem_platform.dylib\n        0x1eb083000 -         0x1eb093ffb libsystem_pthread.dylib arm64  \u003c05d0d8cf4b863a7fa70d7006d7925763\u003e /usr/lib/system/libsystem_pthread.dylib\n\nEOF\n`\nHave tried \u003cMtouchEnableAOTCompilation\u003efalse\u003c/MtouchEnableAOTCompilation\u003e does not give us anything extra.\nalso added \u003cMtouchLink\u003e SdkOnly \u003c/MtouchLink\u003e and \u003cEnableSGenConc\u003efalse\u003c/EnableSGenConc\u003e, but we are still getting the same exception\n\nThe crash we are getting gives us this:\n\n``\nThread 12 name:\nThread 12 Crashed:\n0   FrontSystems                  \t0x0000000102e9f268 mono_interp_exec_method (in FrontSystems) (interp.c:6221) + 10908264\n1   FrontSystems                  \t0x0000000102e9cac8 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10898120\n2   FrontSystems                  \t0x0000000102e64508 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10667272\n3   FrontSystems                  \t0x0000000102e07f00 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10288896\n4   FrontSystems                  \t0x0000000102e1eb78 start_wrapper (in FrontSystems) (threads.c:1276) + 10382200\n5   libsystem_pthread.dylib       \t0x000000021beec7d0 _pthread_start + 136 (pthread.c:931)\n6   libsystem_pthread.dylib       \t0x000000021beec480 thread_start + 8 (:-1)\n\nHere is the full report\n`Incident Identifier: E0ABC6CF-B5FD-4A87-91A5-2CD1AE62288F\nDistributor ID:      com.apple.TestFlight\nHardware Model:      iPad15,7\nProcess:             FrontSystems [1158]\nPath:                /private/var/containers/Bundle/Application/12200522-5CF2-4D12-BC29-4CBA75F131D1/FrontSystems.app/FrontSystems\nIdentifier:          no.frontsystems.cornerstone\nVersion:             2.0.1 (233)\nAppStoreTools:       16E137\nAppVariant:          1:iPad15,7:18\nBeta:                YES\nCode Type:           ARM-64 (Native)\nRole:                Foreground\nParent Process:      launchd [1]\nCoalition:           no.frontsystems.cornerstone [561]\n\nDate/Time:           2025-05-12 10:34:46.9754 +0200\nLaunch Time:         2025-05-12 10:01:36.9254 +0200\nOS Version:          iPhone OS 18.3.2 (22D2082)\nRelease Type:        User\nReport Version:      104\n\nException Type:  EXC_BAD_ACCESS (SIGSEGV)\nException Subtype: KERN_INVALID_ADDRESS at 0x0000000100000019\nException Codes: 0x0000000000000001, 0x0000000100000019\nVM Region Info: 0x100000019 is not in any region.  Bytes before following region: 37978087\n      REGION TYPE                 START - END      [ VSIZE] PRT/MAX SHRMOD  REGION DETAIL\n      UNUSED SPACE AT START\n---\u003e  \n      __TEXT                   102438000-10305c000 [ 12.1M] r-x/r-x SM=COW  /var/containers/Bundle/Application/12200522-5CF2-4D12-BC29-4CBA75F131D1/FrontSystems.app/FrontSystems\nTriggered by Thread:  12\n\n\nThread 0 name:\nThread 0 name:\nThread 0:\n0   libsystem_kernel.dylib        \t0x00000001e29c0788 mach_msg2_trap + 8 (:-1)\n1   libsystem_kernel.dylib        \t0x00000001e29c3e98 mach_msg2_internal + 80 (mach_msg.c:201)\n2   libsystem_kernel.dylib        \t0x00000001e29c3db0 mach_msg_overwrite + 424 (mach_msg.c:0)\n3   libsystem_kernel.dylib        \t0x00000001e29c3bfc mach_msg + 24 (mach_msg.c:323)\n4   CoreFoundation                \t0x000000019183b804 __CFRunLoopServiceMachPort + 160 (CFRunLoop.c:2637)\n5   CoreFoundation                \t0x000000019183aeb0 __CFRunLoopRun + 1212 (CFRunLoop.c:3021)\n6   CoreFoundation                \t0x000000019188d284 CFRunLoopRunSpecific + 588 (CFRunLoop.c:3434)\n7   GraphicsServices              \t0x00000001de4dd4c0 GSEventRunModal + 164 (GSEvent.c:2196)\n8   UIKitCore                     \t0x00000001943d2674 -[UIApplication _run] + 816 (UIApplication.m:3846)\n9   UIKitCore                     \t0x0000000193ff8e88 UIApplicationMain + 340 (UIApplication.m:5503)\n10  FrontSystems                  \t0x0000000102cb44b0 xamarin_UIApplicationMain (in FrontSystems) (bindings.m:131) + 8897712\n11  FrontSystems                  \t0x0000000102ea7a68 do_icall (in FrontSystems) (interp.c:2426) + 10943080\n12  FrontSystems                  \t0x0000000102ea6110 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 10936592\n13  FrontSystems                  \t0x0000000102ea1250 mono_interp_exec_method (in FrontSystems) (interp.c:4259) + 10916432\n14  FrontSystems                  \t0x0000000102e9cac8 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10898120\n15  FrontSystems                  \t0x0000000102e64508 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10667272\n16  FrontSystems                  \t0x0000000102e07f00 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10288896\n17  FrontSystems                  \t0x0000000102e0e58c mono_runtime_exec_main_checked (in FrontSystems) (object.c:4808) + 10315148\n18  FrontSystems                  \t0x0000000102e6b6dc mono_jit_exec (in FrontSystems) (driver.c:1311) + 10696412\n19  FrontSystems                  \t0x0000000102cc8aec xamarin_main (in FrontSystems) (monotouch-main.m:0) + 8981228\n20  FrontSystems                  \t0x000000010305f768 main (in FrontSystems) (main.arm64.mm:81) + 12744552\n21  dyld                          \t0x00000001b7ae1de8 start + 2724 (dyldMain.cpp:1338)\n\nThread 1 name:\nThread 1:\n0   libsystem_kernel.dylib        \t0x00000001e29c6090 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x000000021beeef98 _pthread_cond_wait + 1204 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000102d9b5bc thread_func (in FrontSystems) (sgen-thread-pool.c:195) + 9844156\n3   libsystem_pthread.dylib       \t0x000000021beec7d0 _pthread_start + 136 (pthread.c:931)\n4   libsystem_pthread.dylib       \t0x000000021beec480 thread_start + 8 (:-1)\n\nThread 2 name:\nThread 2:\n0   libsystem_kernel.dylib        \t0x00000001e29c0704 semaphore_wait_trap + 8 (:-1)\n1   FrontSystems                  \t0x0000000102e42e78 finalizer_thread (in FrontSystems) (gc.c:868) + 10530424\n2   FrontSystems                  \t0x0000000102e1eb94 start_wrapper (in FrontSystems) (threads.c:1276) + 10382228\n3   libsystem_pthread.dylib       \t0x000000021beec7d0 _pthread_start + 136 (pthread.c:931)\n4   libsystem_pthread.dylib       \t0x000000021beec480 thread_start + 8 (:-1)\n\nThread 3 name:\nThread 3:\n0   libsystem_kernel.dylib        \t0x00000001e29c0788 mach_msg2_trap + 8 (:-1)\n1   libsystem_kernel.dylib        \t0x00000001e29c3e98 mach_msg2_internal + 80 (mach_msg.c:201)\n2   libsystem_kernel.dylib        \t0x00000001e29c3db0 mach_msg_overwrite + 424 (mach_msg.c:0)\n3   libsystem_kernel.dylib        \t0x00000001e29c3bfc mach_msg + 24 (mach_msg.c:323)\n4   CoreFoundation                \t0x000000019183b804 __CFRunLoopServiceMachPort + 160 (CFRunLoop.c:2637)\n5   CoreFoundation                \t0x000000019183aeb0 __CFRunLoopRun + 1212 (CFRunLoop.c:3021)\n6   CoreFoundation                \t0x000000019188d284 CFRunLoopRunSpecific + 588 (CFRunLoop.c:3434)\n7   Foundation                    \t0x000000019040e908 -[NSRunLoop(NSRunLoop) runMode:beforeDate:] + 212 (NSRunLoop.m:373)\n8   Foundation                    \t0x000000019056b310 -[NSRunLoop(NSRunLoop) runUntilDate:] + 64 (NSRunLoop.m:420)\n9   UIKitCore                     \t0x0000000194465a78 -[UIEventFetcher threadMain] + 420 (UIEventFetcher.m:1351)\n10  Foundation                    \t0x00000001904fa6a0 __NSThread__start__ + 724 (NSThread.m:991)\n11  libsystem_pthread.dylib       \t0x000000021beec7d0 _pthread_start + 136 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x000000021beec480 thread_start + 8 (:-1)\n\nThread 4 name:\nThread 4:\n0   libsystem_kernel.dylib        \t0x00000001e29c6090 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x000000021beeefc4 _pthread_cond_wait + 1248 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000102d2c484 SystemNative_LowLevelMonitor_TimedWait (in FrontSystems) (pal_threading.c:198) + 9389188\n3   FrontSystems                  \t0x0000000102ea7b08 do_icall (in FrontSystems) (interp.c:2390) + 10943240\n4   FrontSystems                  \t0x0000000102ea6110 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 10936592\n5   FrontSystems                  \t0x0000000102ea1250 mono_interp_exec_method (in FrontSystems) (interp.c:4259) + 10916432\n6   FrontSystems                  \t0x0000000102e9cac8 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10898120\n7   FrontSystems                  \t0x0000000102e64508 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10667272\n8   FrontSystems                  \t0x0000000102e07f00 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10288896\n9   FrontSystems                  \t0x0000000102e1eb78 start_wrapper (in FrontSystems) (threads.c:1276) + 10382200\n10  libsystem_pthread.dylib       \t0x000000021beec7d0 _pthread_start + 136 (pthread.c:931)\n11  libsystem_pthread.dylib       \t0x000000021beec480 thread_start + 8 (:-1)\n\nThread 5 name:\nThread 5:\n0   libsystem_kernel.dylib        \t0x00000001e29c6090 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x000000021beeefc4 _pthread_cond_wait + 1248 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000102d2c484 SystemNative_LowLevelMonitor_TimedWait (in FrontSystems) (pal_threading.c:198) + 9389188\n3   FrontSystems                  \t0x0000000102ea7b08 do_icall (in FrontSystems) (interp.c:2390) + 10943240\n4   FrontSystems                  \t0x0000000102ea6110 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 10936592\n5   FrontSystems                  \t0x0000000102ea1250 mono_interp_exec_method (in FrontSystems) (interp.c:4259) + 10916432\n6   FrontSystems                  \t0x0000000102e9cac8 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10898120\n7   FrontSystems                  \t0x0000000102e64508 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10667272\n8   FrontSystems                  \t0x0000000102e07f00 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10288896\n9   FrontSystems                  \t0x0000000102e1eb78 start_wrapper (in FrontSystems) (threads.c:1276) + 10382200\n10  libsystem_pthread.dylib       \t0x000000021beec7d0 _pthread_start + 136 (pthread.c:931)\n11  libsystem_pthread.dylib       \t0x000000021beec480 thread_start + 8 (:-1)\n\nThread 6 name:\nThread 6:\n0   libsystem_kernel.dylib        \t0x00000001e29c6090 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x000000021beeefc4 _pthread_cond_wait + 1248 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000102d2c484 SystemNative_LowLevelMonitor_TimedWait (in FrontSystems) (pal_threading.c:198) + 9389188\n3   FrontSystems                  \t0x0000000102ea7b08 do_icall (in FrontSystems) (interp.c:2390) + 10943240\n4   FrontSystems                  \t0x0000000102ea6110 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 10936592\n5   FrontSystems                  \t0x0000000102ea1250 mono_interp_exec_method (in FrontSystems) (interp.c:4259) + 10916432\n6   FrontSystems                  \t0x0000000102e9cac8 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10898120\n7   FrontSystems                  \t0x0000000102e64508 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10667272\n8   FrontSystems                  \t0x0000000102e07f00 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10288896\n9   FrontSystems                  \t0x0000000102e1eb78 start_wrapper (in FrontSystems) (threads.c:1276) + 10382200\n10  libsystem_pthread.dylib       \t0x000000021beec7d0 _pthread_start + 136 (pthread.c:931)\n11  libsystem_pthread.dylib       \t0x000000021beec480 thread_start + 8 (:-1)\n\nThread 7 name:\nThread 7:\n0   libsystem_kernel.dylib        \t0x00000001e29c6090 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x000000021beeefc4 _pthread_cond_wait + 1248 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000102d2c484 SystemNative_LowLevelMonitor_TimedWait (in FrontSystems) (pal_threading.c:198) + 9389188\n3   FrontSystems                  \t0x0000000102ea7b08 do_icall (in FrontSystems) (interp.c:2390) + 10943240\n4   FrontSystems                  \t0x0000000102ea6110 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 10936592\n5   FrontSystems                  \t0x0000000102ea1250 mono_interp_exec_method (in FrontSystems) (interp.c:4259) + 10916432\n6   FrontSystems                  \t0x0000000102e9cac8 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10898120\n7   FrontSystems                  \t0x0000000102e64508 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10667272\n8   FrontSystems                  \t0x0000000102e07f00 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10288896\n9   FrontSystems                  \t0x0000000102e1eb78 start_wrapper (in FrontSystems) (threads.c:1276) + 10382200\n10  libsystem_pthread.dylib       \t0x000000021beec7d0 _pthread_start + 136 (pthread.c:931)\n11  libsystem_pthread.dylib       \t0x000000021beec480 thread_start + 8 (:-1)\n\nThread 8 name:\nThread 8:\n0   libsystem_kernel.dylib        \t0x00000001e29c74cc kevent + 8 (:-1)\n1   FrontSystems                  \t0x0000000102d2a5c0 SystemNative_WaitForSocketEvents (in FrontSystems) (pal_networking.c:3256) + 9381312\n2   FrontSystems                  \t0x0000000102ea7ae4 do_icall (in FrontSystems) (interp.c:2402) + 10943204\n3   FrontSystems                  \t0x0000000102ea6110 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 10936592\n4   FrontSystems                  \t0x0000000102ea1250 mono_interp_exec_method (in FrontSystems) (interp.c:4259) + 10916432\n5   FrontSystems                  \t0x0000000102e9cac8 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10898120\n6   FrontSystems                  \t0x0000000102e64508 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10667272\n7   FrontSystems                  \t0x0000000102e07f00 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10288896\n8   FrontSystems                  \t0x0000000102e1eb78 start_wrapper (in FrontSystems) (threads.c:1276) + 10382200\n9   libsystem_pthread.dylib       \t0x000000021beec7d0 _pthread_start + 136 (pthread.c:931)\n10  libsystem_pthread.dylib       \t0x000000021beec480 thread_start + 8 (:-1)\n\nThread 9 name:\nThread 9:\n0   libsystem_kernel.dylib        \t0x00000001e29c6090 __psynch_cvwait + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x000000021beeef98 _pthread_cond_wait + 1204 (pthread_cond.c:862)\n2   FrontSystems                  \t0x0000000102d5138c mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9540492\n3   FrontSystems                  \t0x0000000102d55158 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9556312\n4   FrontSystems                  \t0x0000000102ea7b08 do_icall (in FrontSystems) (interp.c:2390) + 10943240\n5   FrontSystems                  \t0x0000000102ea6148 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 10936648\n6   FrontSystems                  \t0x0000000102ea1250 mono_interp_exec_method (in FrontSystems) (interp.c:4259) + 10916432\n7   FrontSystems                  \t0x0000000102e9cac8 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10898120\n8   FrontSystems                  \t0x0000000102e64508 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10667272\n9   FrontSystems                  \t0x0000000102e07f00 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10288896\n10  FrontSystems                  \t0x0000000102e1eb78 start_wrapper (in FrontSystems) (threads.c:1276) + 10382200\n11  libsystem_pthread.dylib       \t0x000000021beec7d0 _pthread_start + 136 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x000000021beec480 thread_start + 8 (:-1)\n\nThread 10:\n0   libsystem_pthread.dylib       \t0x000000021beec46c start_wqthread + 0 (:-1)\n\nThread 11 name:\nThread 11:\n0   libsystem_kernel.dylib        \t0x00000001e29c07dc swtch_pri + 8 (:-1)\n1   libsystem_pthread.dylib       \t0x000000021bef08fc cthread_yield + 32 (pthread.c:2314)\n2   FrontSystems                  \t0x0000000102d5b180 mono_threads_platform_yield (in FrontSystems) (mono-threads-posix.c:127) + 9580928\n3   FrontSystems                  \t0x0000000102dd0ce4 ves_icall_System_Threading_Thread_YieldInternal (in FrontSystems) (icall.c:7276) + 10063076\n4   FrontSystems                  \t0x0000000102ea7af4 do_icall (in FrontSystems) (interp.c:2366) + 10943220\n5   FrontSystems                  \t0x0000000102ea6148 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 10936648\n6   FrontSystems                  \t0x0000000102ea1250 mono_interp_exec_method (in FrontSystems) (interp.c:4259) + 10916432\n7   FrontSystems                  \t0x0000000102e9cac8 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10898120\n8   FrontSystems                  \t0x0000000102e64508 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10667272\n9   FrontSystems                  \t0x0000000102e07f00 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10288896\n10  FrontSystems                  \t0x0000000102e1eb78 start_wrapper (in FrontSystems) (threads.c:1276) + 10382200\n11  libsystem_pthread.dylib       \t0x000000021beec7d0 _pthread_start + 136 (pthread.c:931)\n12  libsystem_pthread.dylib       \t0x000000021beec480 thread_start + 8 (:-1)\n\nThread 12 name:\nThread 12 Crashed:\n0   FrontSystems                  \t0x0000000102e9f268 mono_interp_exec_method (in FrontSystems) (interp.c:6221) + 10908264\n1   FrontSystems                  \t0x0000000102e9cac8 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10898120\n2   FrontSystems                  \t0x0000000102e64508 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10667272\n3   FrontSystems                  \t0x0000000102e07f00 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10288896\n4   FrontSystems                  \t0x0000000102e1eb78 start_wrapper (in FrontSystems) (threads.c:1276) + 10382200\n5   libsystem_pthread.dylib       \t0x000000021beec7d0 _pthread_start + 136 (pthread.c:931)\n6   libsystem_pthread.dylib       \t0x000000021beec480 thread_start + 8 (:-1)\n\nThread 13:\n0   libsystem_pthread.dylib       \t0x000000021beec46c start_wqthread + 0 (:-1)\n\nThread 14:\n0   libsystem_pthread.dylib       \t0x000000021beec46c start_wqthread + 0 (:-1)\n\n\nThread 12 crashed with ARM Thread State (64-bit):\n    x0: 0x0000000126521230   x1: 0x0000000126521238   x2: 0x0000000100000001   x3: 0x0000000102d6194c\n    x4: 0x0000000102dc6cb4   x5: 0x0000000000000000   x6: 0x0000000000000000   x7: 0x000000016df7e88c\n    x8: 0x0000000100000001   x9: 0x0000000000000018  x10: 0x00000000000000c0  x11: 0x0000000000000008\n   x12: 0x0000000000000000  x13: 0x0000000140aa03d0  x14: 0x00000000ffffffff  x15: 0x0000000110a8cc48\n   x16: 0x000000021be41ee0  x17: 0x00005d0000005d02  x18: 0x0000000000000000  x19: 0x000000016df7e860\n   x20: 0x0000000000000010  x21: 0x000000016df7df30  x22: 0x000000000000001b  x23: 0x000000010f268fe0\n   x24: 0x000000010f268f00  x25: 0x000000016df7df30  x26: 0x00000001032d8f08  x27: 0x0000000301de2400\n   x28: 0x0000000126521270   fp: 0x000000016df7e9f0   lr: 0x0000000102ea34f8\n    sp: 0x000000016df7c400   pc: 0x0000000102e9f268 cpsr: 0x80001000\n   esr: 0x56000080  Address size fault\n\n\nBinary Images:\n        0x102438000 -         0x1032affff FrontSystems arm64  \u003c9cbfed4900de350a8056cb540e7febcc\u003e /private/var/containers/Bundle/Application/12200522-5CF2-4D12-BC29-4CBA75F131D1/FrontSystems.app/FrontSystems\n        0x1039d0000 -         0x103b17fff libHarfBuzzSharp arm64  \u003c8ca693a9d0533072850919c5df43d67e\u003e /private/var/containers/Bundle/Application/12200522-5CF2-4D12-BC29-4CBA75F131D1/FrontSystems.app/Frameworks/libHarfBuzzSharp.framework/libHarfBuzzSharp\n        0x104104000 -         0x104663fff libSkiaSharp arm64  \u003c6b45b7dee11f31139b1f1aff7553de02\u003e /private/var/containers/Bundle/Application/12200522-5CF2-4D12-BC29-4CBA75F131D1/FrontSystems.app/Frameworks/libSkiaSharp.framework/libSkiaSharp\n        0x10a0ac000 -         0x10a0b7fff libobjc-trampolines.dylib arm64e  \u003c4aba9420e4d03c989d62c653b259eab4\u003e /private/preboot/Cryptexes/OS/usr/lib/libobjc-trampolines.dylib\n        0x1903e5000 -         0x1910f9fff Foundation arm64e  \u003cb90df3ef9713387387820236d3ad960a\u003e /System/Library/Frameworks/Foundation.framework/Foundation\n        0x1917c5000 -         0x191d08fff CoreFoundation arm64e  \u003c0013a8b125243534b5ba681aaf18c798\u003e /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation\n        0x193fe4000 -         0x195efcfff UIKitCore arm64e  \u003cb739e6d6ac9c3138acb5d55569e25848\u003e /System/Library/PrivateFrameworks/UIKitCore.framework/UIKitCore\n        0x1995c5000 -         0x199644ffb libsystem_c.dylib arm64e  \u003c4065a8811de03b378e7699600361e0d8\u003e /usr/lib/system/libsystem_c.dylib\n        0x1b7ab2000 -         0x1b7b3513f dyld arm64e  \u003cd0b3b73c1a4f33b8bd55b2d921ae7879\u003e /usr/lib/dyld\n        0x1de4dc000 -         0x1de4e4fff GraphicsServices arm64e  \u003cf1434e4883173cf089a0df059fad9f0d\u003e /System/Library/PrivateFrameworks/GraphicsServices.framework/GraphicsServices\n        0x1e29bf000 -         0x1e29f8fe3 libsystem_kernel.dylib arm64e  \u003c881fe934759c3089b98660344cb843e3\u003e /usr/lib/system/libsystem_kernel.dylib\n        0x21be3f000 -         0x21be46ff3 libsystem_platform.dylib arm64e  \u003cdef0b18b9b0a3ed3a4876171c6d9b127\u003e /usr/lib/system/libsystem_platform.dylib\n        0x21beeb000 -         0x21bef7ff3 libsystem_pthread.dylib arm64e  \u003c6f6e49251fb43a0b99d26bd8b7b1a148\u003e /usr/lib/system/libsystem_pthread.dylib\n\nEOF\n`\n\nAny suggestions  ? Wild ideas that we can try out ? Anything ? \n\n\n\n\n\n",
                                           "updatedAt":  "2025-05-12T12:10:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6rRBET",
                                           "createdAt":  "2025-05-12T17:20:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOERy7XQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "Pablo-Sierra",
                                                                               "createdAt":  "2025-05-12T18:32:32Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "pme442",
                                           "body":  "Updates:  \n1. Repo app: I did remove the forked packaged from my repo app and I was able to recreate the crash yesterday exactly the same way I described in my repo post.  Here is the error log:\n\n![Image](https://github.com/user-attachments/assets/c40b41d8-240b-4f75-985c-59f1bdaa3682)\n\n2. My real app: I know I previously said that I tried the forked package in my real app and it crashed with the original error.  But I was wrong.  I double checked and realized that I forgot to specify the framework version in my .csproj so I wasn\u0027t using the package after all.  This morning, I fixed that and verified that I built it with the 9.0.5 runtime package.  I re-tested and I could not reproduce the error.  That makes sense because, like I said on Friday, I could not reproduce it on my repo app with the package either.  \n\nSo at least my test results prove to be consistent.  The error does not happen with the package, it does happen without the package.\n\nAlso, I want to point out that when I used the package (in both apps) they did eventually crash.  However, there were no errors logged.  Nothing in my error log and nothing on the iPad.  Not even a cpu_resource.ips file.  But I would have to think that the crash must have had something to do with running out memory.  They both logged apple memory warnings and before the crash, they were using almost 1/3 of the total available memory.\n",
                                           "updatedAt":  "2025-05-12T17:20:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6rTLMV",
                                           "createdAt":  "2025-05-12T20:35:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOESCbXA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "wgriep",
                                                                               "createdAt":  "2025-05-12T20:41:10Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jarlem",
                                                                               "createdAt":  "2025-05-12T20:45:48Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "marcodelfrari",
                                                                               "createdAt":  "2025-05-12T20:59:33Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "janusw",
                                                                               "createdAt":  "2025-05-13T06:17:57Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "kotlarmilos",
                                                                               "createdAt":  "2025-05-13T07:00:00Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "afk013",
                                                                               "createdAt":  "2025-05-13T07:49:28Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "linnkrb",
                                                                               "createdAt":  "2025-05-13T07:50:16Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "Pablo-Sierra",
                                                                               "createdAt":  "2025-05-13T07:51:39Z"
                                                                           },
                                                                           {
                                                                               "content":  "ROCKET",
                                                                               "user":  "Pablo-Sierra",
                                                                               "createdAt":  "2025-05-13T07:51:42Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "pme442",
                                                                               "createdAt":  "2025-05-13T12:27:15Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "EmilienDup",
                                                                               "createdAt":  "2025-05-13T12:58:39Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "daniele-calanchi",
                                                                               "createdAt":  "2025-05-14T06:55:43Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  12
                                                         },
                                           "author":  "steveisok",
                                           "body":  "Quick update everyone.... We managed to create a reliable repro and we think we may have found the .NET 9 commit that caused this issue to pop. We are currently working on next steps and when I have more info, I will share it with you all. \n\nMany thanks to the energy put into this issue both from your comments and your willingness to try out custom builds. It really did help us hone in as this was hard to pin down. I\u0027m hopeful we\u0027ll have a fix and guidance so please stay tuned.",
                                           "updatedAt":  "2025-05-12T20:35:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6rmNs-",
                                           "createdAt":  "2025-05-14T06:56:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOESHN3w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Pablo-Sierra",
                                                                               "createdAt":  "2025-05-14T07:59:08Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "linnkrb",
                                                                               "createdAt":  "2025-05-14T15:42:12Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "daniele-calanchi",
                                           "body":  "Thank you very much for your work, let us know as soon as you have something on an ETA for the fix. \nI don\u0027t know if it can help, but, from our internal testing and prod data, we are experiencing this issue orders of magnitude more frequently on iPads with M2 cpu compared to M1 (same iOS 18.4.1 version)",
                                           "updatedAt":  "2025-05-14T08:26:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6rq6qB",
                                           "createdAt":  "2025-05-14T12:57:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOESIRBw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "linnkrb",
                                                                               "createdAt":  "2025-05-14T15:42:07Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Pablo-Sierra",
                                                                               "createdAt":  "2025-05-14T16:05:16Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jarlem",
                                                                               "createdAt":  "2025-05-14T17:39:43Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "janusw",
                                           "body":  "\u003e Quick update everyone....\n\nThanks for the update and all the work that has already gone into investigating this isseue, @steveisok \u0026 @kotlarmilos !\n\nApparently [runtime version 9.0.5 has been released yesterday](https://github.com/dotnet/core/blob/main/release-notes/9.0/9.0.5/9.0.5.md) (together with SDK 9.0.300), and I guess that version does not improve the situation wrt this issue yet, right?\n\nSo I strongly hope that it will be fixed with 9.0.6 (in June?). This is really the last blocker that keeps us from updating our MAUI app from .NET 8 to 9. (In fact our port to .NET 9 was already done, and has been reverted and put on ice due to this.)\n\nI\u0027ll also point out that [MAUI 8 support officially ends **today**](https://dotnet.microsoft.com/en-us/platform/support/policy/maui), and it has in fact not seen any maintenance since [release 8.0.100](https://github.com/dotnet/maui/releases/tag/8.0.100) back in November 2024.\n\nSo, a fix for this issue is rather urgent IMHO ... 😱 ",
                                           "updatedAt":  "2025-05-14T12:57:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6rtIcg",
                                           "createdAt":  "2025-05-14T15:48:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOESKYgw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Pablo-Sierra",
                                                                               "createdAt":  "2025-05-14T16:10:30Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jarlem",
                                                                               "createdAt":  "2025-05-14T17:39:44Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pme442",
                                                                               "createdAt":  "2025-05-14T20:57:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "itsazoo",
                                                                               "createdAt":  "2025-05-14T22:20:01Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "linnkrb",
                                           "body":  "\u003e Thank you very much for your work, let us know as soon as you have something on an ETA for the fix. I don\u0027t know if it can help, but, from our internal testing and prod data, we are experiencing this issue orders of magnitude more frequently on iPads with M2 cpu compared to M1 (same iOS 18.4.1 version)\n\nWe would really appreciate getting available previews ASAP so we also can se if this actually solves our problem, if not we need to take even more actions to figure out what is going on, that we are on the right track here waiting for these updates or that there is other issues as well for all we know ?  Our old Xamarin can not be published anymore, .net8 has issues for us that is solved in .net9 and we cannot release .net9 version because of  the crashes. Getting a bit desperat.",
                                           "updatedAt":  "2025-05-14T15:48:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6r6ixr",
                                           "createdAt":  "2025-05-15T15:30:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jjacksoncapula",
                                           "body":  "We experienced the same issue today. Running on dotnet 9.0.1 on Windows. Stack trace as follows:\n\n```\n2025-05-15 14:44:07,672 [347] FATAL ServiceHost\u003cPosition\u003e - Fatal unhandled exception! Service will be terminated\nSystem.InvalidCastException: Unable to cast object of type \u0027System.Object\u0027 to type \u0027System.Collections.Generic.List`1[System.Object]\u0027.\n   at System.Threading.Tasks.Task.RunContinuations(Object continuationObject)\n   at System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\n   at System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart()\n```",
                                           "updatedAt":  "2025-05-15T15:30:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6r6w-k",
                                           "createdAt":  "2025-05-15T15:48:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOESW0XA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kotlarmilos",
                                                                               "createdAt":  "2025-05-16T08:55:20Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "lateralusX",
                                           "body":  " \u003e We experienced the same issue today. Running on dotnet 9.0.1 on Windows. Stack trace as follows:\n\u003e \n\u003e ```\n\u003e 2025-05-15 14:44:07,672 [347] FATAL ServiceHost\u003cPosition\u003e - Fatal unhandled exception! Service will be terminated\n\u003e System.InvalidCastException: Unable to cast object of type \u0027System.Object\u0027 to type \u0027System.Collections.Generic.List`1[System.Object]\u0027.\n\u003e    at System.Threading.Tasks.Task.RunContinuations(Object continuationObject)\n\u003e    at System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)\n\u003e    at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\n\u003e    at System.Threading.ThreadPoolWorkQueue.Dispatch()\n\u003e    at System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart()\n\u003e ```\n\n\nI guess this is CoreCLR + Windows + x64, this issue is around Mono + iOS + ARM64, I guess you hit something similar as described in https://github.com/dotnet/runtime/issues/83520.",
                                           "updatedAt":  "2025-05-15T15:49:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6r69Pj",
                                           "createdAt":  "2025-05-15T16:06:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jjacksoncapula",
                                           "body":  "\u003e \u003e We experienced the same issue today. Running on dotnet 9.0.1 on Windows. Stack trace as follows:\n\u003e \u003e ```\n\u003e \u003e 2025-05-15 14:44:07,672 [347] FATAL ServiceHost\u003cPosition\u003e - Fatal unhandled exception! Service will be terminated\n\u003e \u003e System.InvalidCastException: Unable to cast object of type \u0027System.Object\u0027 to type \u0027System.Collections.Generic.List`1[System.Object]\u0027.\n\u003e \u003e    at System.Threading.Tasks.Task.RunContinuations(Object continuationObject)\n\u003e \u003e    at System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)\n\u003e \u003e    at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\n\u003e \u003e    at System.Threading.ThreadPoolWorkQueue.Dispatch()\n\u003e \u003e    at System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart()\n\u003e \u003e ```\n\u003e \n\u003e I guess this is CoreCLR + Windows + x64, this issue is around Mono + iOS + ARM64, I guess you hit something similar as described in [#83520](https://github.com/dotnet/runtime/issues/83520).\n\nWe do not use Thread.Interrupt / Thread.Abort. Also our stack trace is very similar to that linked in this issue, i.e. InvalidCastException thrown by System.Threading.Tasks.Task.RunContinuations. Strongly suspected to be this line:\n\n[https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Task.cs#L3497C9-L3497C68](url)\n\nOur issue therefore feels more at home in this chain. ",
                                           "updatedAt":  "2025-05-15T16:43:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6r7pw7",
                                           "createdAt":  "2025-05-15T17:17:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lateralusX",
                                           "body":  "\u003e https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Task.cs#L3497C9-L3497C68\n\nThat is the line that gets hit if you end up in a scenario where continuations have already been executed on the task and replaced it with s_taskCompletionSentinel object (so it not a list anymore). Your callstack aligns more with https://github.com/dotnet/runtime/issues/83520 and this issue mainly focus on Mono + iOS + AMR64 and tracks a regression between net8-ios and net9-ios:\n\n```\nstacktrace of InvalidCastException:\n\nSystem.InvalidCastException: Specified cast is not valid.\nat System.Threading.Tasks.Task.RunContinuations(Object continuationObject)\nat System.Threading.Tasks.Task.FinishContinuations()\nat System.Threading.Tasks.Task.FinishStageThree()\nat System.Threading.Tasks.Task.FinishStageTwo()\nat System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)\nat System.Threading.Tasks.Task.Finish(Boolean userDelegateExecute)\nat System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\nat System.Threading.Tasks.Task.ExecuteEntryUnsafe(Thread threadPoolThread)\nat System.Threading.Tasks.Task.ExecuteFromThreadPool(Thread threadPoolThread)\nat System.Threading.ThreadPoolWorkQueue.DispatchItemWithAutoreleasePool(Object workItem, Thread currentThread)\nat System.Threading.ThreadPoolWorkQueue.Dispatch()\nat System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart()\nat System.Threading.Thread.StartCallback()\n\n```\n\nJust wanted to clarify that it might be related but a different issue.",
                                           "updatedAt":  "2025-05-15T17:18:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6sDbhb",
                                           "createdAt":  "2025-05-16T12:26:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOESYO-A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "lateralusX",
                                                                               "createdAt":  "2025-05-16T12:29:35Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jjacksoncapula",
                                           "body":  "\u003e \u003e https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Task.cs#L3497C9-L3497C68\n\u003e \n\u003e That is the line that gets hit if you end up in a scenario where continuations have already been executed on the task and replaced it with s_taskCompletionSentinel object (so it not a list anymore). Your callstack aligns more with [#83520](https://github.com/dotnet/runtime/issues/83520) and this issue mainly focus on Mono + iOS + AMR64 and tracks a regression between net8-ios and net9-ios:\n\u003e \n\u003e ```\n\u003e stacktrace of InvalidCastException:\n\u003e \n\u003e System.InvalidCastException: Specified cast is not valid.\n\u003e at System.Threading.Tasks.Task.RunContinuations(Object continuationObject)\n\u003e at System.Threading.Tasks.Task.FinishContinuations()\n\u003e at System.Threading.Tasks.Task.FinishStageThree()\n\u003e at System.Threading.Tasks.Task.FinishStageTwo()\n\u003e at System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)\n\u003e at System.Threading.Tasks.Task.Finish(Boolean userDelegateExecute)\n\u003e at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\n\u003e at System.Threading.Tasks.Task.ExecuteEntryUnsafe(Thread threadPoolThread)\n\u003e at System.Threading.Tasks.Task.ExecuteFromThreadPool(Thread threadPoolThread)\n\u003e at System.Threading.ThreadPoolWorkQueue.DispatchItemWithAutoreleasePool(Object workItem, Thread currentThread)\n\u003e at System.Threading.ThreadPoolWorkQueue.Dispatch()\n\u003e at System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart()\n\u003e at System.Threading.Thread.StartCallback()\n\u003e ```\n\u003e \n\u003e Just wanted to clarify that it might be related but a different issue.\n\nThanks lateralusX, I have moved our comment over to [https://github.com/dotnet/runtime/issues/83520](url)",
                                           "updatedAt":  "2025-05-16T12:26:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6sFzJV",
                                           "createdAt":  "2025-05-16T16:37:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOES1TTQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Pablo-Sierra",
                                                                               "createdAt":  "2025-05-17T00:25:32Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "linnkrb",
                                                                               "createdAt":  "2025-05-19T13:22:44Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "cgan76",
                                                                               "createdAt":  "2025-05-20T14:16:32Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "ConwayLS",
                                           "body":  "We are seeing crashes in .NET 9 iOS after migrating from .NET 8. Although we don\u0027t see InvalidOperationException or InvalidCastException, we do get crash logs similar to what @linnkrb has posted in this issue, so I\u0027m adding a comment here. Both seemingly involving the interpreter - https://learn.microsoft.com/en-us/dotnet/maui/macios/interpreter?view=net-maui-9.0. The crashed thread call-stacks are posted below. We can\u0027t make this happen on demand, but we just spend time in a couple of areas in our app and the crash will eventually happen. The crash only happens with Release builds for iOS; Debug builds and Windows/Android apps work fine. \n\nBecause of this issue, we are rolling back to .NET 8 until this is fixed. I see that @steveisok mentions that they have possibly tracked down the causing commit and are working on next steps. Hopefully a fix follows soon...the sooner the better! \n\nIf this is really a separate bug, I can log a new issue.\n\n----------------------------------------------------\nException Type:  EXC_BAD_ACCESS (SIGSEGV)\nException Subtype: KERN_INVALID_ADDRESS at 0x0000000100000019\nException Codes: 0x0000000000000001, 0x0000000100000019\nVM Region Info: 0x100000019 is not in any region.  Bytes before following region: 15433703\n      REGION TYPE                 START - END      [ VSIZE] PRT/MAX SHRMOD  REGION DETAIL\n      UNUSED SPACE AT START\n---\u003e  \n      __TEXT                   100eb8000-1010dc000 [ 2192K] r-x/r-x SM=COW  ...edClient.Maui\nTriggered by Thread:  16\n\nThread 16 Crashed:\n0   Librestream.UnifiedClient.Maui\t0x00000001010a81e8 mono_interp_exec_method (in Librestream.UnifiedClient.Maui) (interp.c:6221) + 2032104\n1   Librestream.UnifiedClient.Maui\t0x00000001010a0084 interp_runtime_invoke (in Librestream.UnifiedClient.Maui) (interp.c:2220) + 1998980\n2   Librestream.UnifiedClient.Maui\t0x000000010106f038 mono_jit_runtime_invoke (in Librestream.UnifiedClient.Maui) (mini-runtime.c:3686) + 1798200\n3   Librestream.UnifiedClient.Maui\t0x000000010101a990 mono_runtime_invoke_checked (in Librestream.UnifiedClient.Maui) (object.c:2788) + 1452432\n4   Librestream.UnifiedClient.Maui\t0x000000010102ca90 start_wrapper (in Librestream.UnifiedClient.Maui) (threads.c:1276) + 1526416\n5   libsystem_pthread.dylib       \t0x000000021d0900ec _pthread_start + 116 (pthread.c:893)\n6   libsystem_pthread.dylib       \t0x000000021d08e72c thread_start + 8 (:-1)\n\nand \n\n-------------------------------------------------------------\nException Type:  EXC_BAD_ACCESS (SIGSEGV)\nException Subtype: KERN_INVALID_ADDRESS at 0x0000000000000008\nException Codes: 0x0000000000000001, 0x0000000000000008\nVM Region Info: 0x8 is not in any region.  Bytes before following region: 4333764600\n      REGION TYPE                 START - END      [ VSIZE] PRT/MAX SHRMOD  REGION DETAIL\n      UNUSED SPACE AT START\n---\u003e  \n      __TEXT                   102500000-102724000 [ 2192K] r-x/r-x SM=COW  /var/containers/Bundle/Application/C30BE77A-E3A7-4BB6-B379-04375B978BF2/Librestream.UnifiedClient.Maui.app/Librestream.UnifiedClient.Maui\nTriggered by Thread:  0\n\nThread 0 Crashed:\n0   Librestream.UnifiedClient.Maui\t0x000000010271e490 interp_optimize_code (in Librestream.UnifiedClient.Maui) (transform-opt.c:3981) + 2221200\n1   Librestream.UnifiedClient.Maui\t0x0000000102704b74 generate (in Librestream.UnifiedClient.Maui) (transform.c:9532) + 2116468\n2   Librestream.UnifiedClient.Maui\t0x0000000102704550 mono_interp_transform_method (in Librestream.UnifiedClient.Maui) (transform.c:9844) + 2114896\n3   Librestream.UnifiedClient.Maui\t0x0000000102722270 tier_up_method (in Librestream.UnifiedClient.Maui) (tiering.c:86) + 2237040\n4   Librestream.UnifiedClient.Maui\t0x0000000102721fe4 mono_interp_tier_up_frame_enter (in Librestream.UnifiedClient.Maui) (tiering.c:174) + 2236388\n5   Librestream.UnifiedClient.Maui\t0x00000001026f4da0 mono_interp_exec_method (in Librestream.UnifiedClient.Maui) (interp.c:7672) + 2051488\n6   Librestream.UnifiedClient.Maui\t0x00000001026e7880 interp_entry_from_trampoline (in Librestream.UnifiedClient.Maui) (interp.c:3229) + 1996928\n7   Librestream.UnifiedClient.Maui\t0x0000000102514d00 native_to_interp_trampoline (in Librestream.UnifiedClient.Maui) + 112 + 85248\n8   libdispatch.dylib             \t0x0000000190a37584 _dispatch_client_callout + 16 (client_callout.mm:85)\n9   libdispatch.dylib             \t0x0000000190a54574 _dispatch_main_queue_drain.cold.5 + 812 (queue.c:8104)\n10  libdispatch.dylib             \t0x0000000190a2cd30 _dispatch_main_queue_drain + 180 (queue.c:8085)\n11  libdispatch.dylib             \t0x0000000190a2cc6c _dispatch_main_queue_callback_4CF + 44 (queue.c:8264)\n12  CoreFoundation                \t0x0000000188b122b4 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 16 (CFRunLoop.c:1793)\n13  CoreFoundation                \t0x0000000188b100b0 __CFRunLoopRun + 1980 (CFRunLoop.c:3163)\n14  CoreFoundation                \t0x0000000188b34700 CFRunLoopRunSpecific + 572 (CFRunLoop.c:3434)\n15  GraphicsServices              \t0x00000001d5675190 GSEventRunModal + 168 (GSEvent.c:2196)\n16  UIKitCore                     \t0x000000018b752240 -[UIApplication _run] + 816 (:-1)\n17  UIKitCore                     \t0x000000018b750470 UIApplicationMain + 336 (:-1)\n18  Librestream.UnifiedClient.Maui\t0x000000010252cf68 xamarin_UIApplicationMain (in Librestream.UnifiedClient.Maui) (bindings.m:131) + 184168\n19  Librestream.UnifiedClient.Maui\t0x00000001026f897c do_icall (in Librestream.UnifiedClient.Maui) (interp.c:2426) + 2066812\n20  Librestream.UnifiedClient.Maui\t0x00000001026f6f50 do_icall_wrapper (in Librestream.UnifiedClient.Maui) (interp.c:2467) + 2060112\n21  Librestream.UnifiedClient.Maui\t0x00000001026ea4c8 mono_interp_exec_method (in Librestream.UnifiedClient.Maui) (interp.c:0) + 2008264\n22  Librestream.UnifiedClient.Maui\t0x00000001026e8084 interp_runtime_invoke (in Librestream.UnifiedClient.Maui) (interp.c:2220) + 1998980\n23  Librestream.UnifiedClient.Maui\t0x00000001026b7038 mono_jit_runtime_invoke (in Librestream.UnifiedClient.Maui) (mini-runtime.c:3686) + 1798200\n24  Librestream.UnifiedClient.Maui\t0x0000000102662990 mono_runtime_invoke_checked (in Librestream.UnifiedClient.Maui) (object.c:2788) + 1452432\n25  Librestream.UnifiedClient.Maui\t0x00000001026686c4 mono_runtime_exec_main_checked (in Librestream.UnifiedClient.Maui) (object.c:4808) + 1476292\n26  Librestream.UnifiedClient.Maui\t0x00000001026bd8e4 mono_jit_exec (in Librestream.UnifiedClient.Maui) (driver.c:1311) + 1824996\n27  Librestream.UnifiedClient.Maui\t0x0000000102537b38 xamarin_main (in Librestream.UnifiedClient.Maui) (monotouch-main.m:0) + 228152\n28  Librestream.UnifiedClient.Maui\t0x0000000102727540 main (in Librestream.UnifiedClient.Maui) (main.arm64.mm:79) + 2258240\n29  dyld                          \t0x00000001af537ad8 start + 5964 (dyldMain.cpp:1443)\n\n",
                                           "updatedAt":  "2025-05-16T16:37:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6sG9lQ",
                                           "createdAt":  "2025-05-16T19:20:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOES1Tdw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jarlem",
                                                                               "createdAt":  "2025-05-16T19:25:53Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Pablo-Sierra",
                                                                               "createdAt":  "2025-05-17T00:25:56Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pentp",
                                                                               "createdAt":  "2025-05-17T09:59:58Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "afk013",
                                                                               "createdAt":  "2025-05-19T08:18:11Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "linnkrb",
                                                                               "createdAt":  "2025-05-19T13:21:14Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "cgan76",
                                                                               "createdAt":  "2025-05-20T14:16:46Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  6
                                                         },
                                           "author":  "steveisok",
                                           "body":  "\u003e Quick update everyone.... We managed to create a reliable repro and we think we may have found the .NET 9 commit that caused this issue to pop. We are currently working on next steps and when I have more info, I will share it with you all.\n\u003e \n\u003e Many thanks to the energy put into this issue both from your comments and your willingness to try out custom builds. It really did help us hone in as this was hard to pin down. I\u0027m hopeful we\u0027ll have a fix and guidance so please stay tuned.\n\nAs you may of noticed in the issue, we pushed a runtime [change](https://github.com/dotnet/runtime/pull/115573) through to our main and release/9.0 branches. We are confident we resolved the instability most of you are experiencing. The fix is slated to be included in our June .NET servicing release and unfortunately, there isn\u0027t a 9.0 based workaround to recommend other than to take the fix when it comes. \n\nThanks again everyone for your patience and support. I\u0027ll keep the issue open as a way to track when the servicing release hits and you can tell me if it indeed helped your situation. ",
                                           "updatedAt":  "2025-05-16T19:20:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6sRMw2",
                                           "createdAt":  "2025-05-19T08:53:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOETI75Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jarlem",
                                                                               "createdAt":  "2025-05-19T12:13:20Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "linnkrb",
                                                                               "createdAt":  "2025-05-19T13:21:29Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "cgan76",
                                                                               "createdAt":  "2025-05-20T14:17:02Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Pablo-Sierra",
                                                                               "createdAt":  "2025-05-22T07:41:55Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "afk013",
                                           "body":  "Hi @steveisok thank you very much for your hard work in investigating and producing a fix for this issue, we were pulling our hair out trying to track down the issue before it was confirmed to be a runtime issue; as it was always intermittent but too regular to release to production in our use case. \n\nIs there any chance of obtaining a preview/nightly .Net 9 build of the runtime (including Android, iOS simulator and iOS device platforms)  with this fix in please. This bug cropped up for our client\u0027s app on 26th February and has blocked the initial release of the Xamarin Forms to Maui conversion since. We appreciate that the same guarantees for an early release can not be given as a stable release but been able to get the initial Maui release out the door will be a massive weight lifted for our team and client and we can produce a much smaller follow up release when the stable runtime is available.",
                                           "updatedAt":  "2025-05-19T08:54:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6tVWmQ",
                                           "createdAt":  "2025-05-25T20:08:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "linnkrb",
                                           "body":  "\n\u003e As you may of noticed in the issue, we pushed a runtime [change](https://github.com/dotnet/runtime/pull/115573) through to our main and release/9.0 branches. We are confident we resolved the instability most of you are experiencing. The fix is slated to be included in our June .NET servicing release and unfortunately, there isn\u0027t a 9.0 based workaround to recommend other than to take the fix when it comes.\n\nI´ve tried this version, and our is at least still crashing. Could be of course something we are doing wrong, but still I feel it´s related to  the same issue.\n\nCrashes on 4 different iPads all with different OS, models et.c\n\n\n`Incident Identifier: 72BE7A87-9F74-43D4-92CD-CE839AA90026\nDistributor ID:      com.apple.TestFlight\nHardware Model:      iPad13,18\nProcess:             FrontSystems [3013]\nPath:                /private/var/containers/Bundle/Application/1AE46E45-C00B-4B11-853F-EEF891B720DA/FrontSystems.app/FrontSystems\nIdentifier:          no.frontsystems.cornerstone\nVersion:             2.0.1 (2807)\nAppStoreTools:       16F3\nAppVariant:          1:iPad13,18:18\nBeta:                YES\nCode Type:           ARM-64 (Native)\nRole:                Foreground\nParent Process:      launchd [1]\nCoalition:           no.frontsystems.cornerstone [733]\n\nDate/Time:           2025-05-24 02:57:41.9339 +0200\nLaunch Time:         2025-05-24 01:11:44.1955 +0200\nOS Version:          iPhone OS 18.5 (22F76)\nRelease Type:        User\nReport Version:      104\n\nException Type:  EXC_BAD_ACCESS (SIGSEGV)\nException Subtype: KERN_INVALID_ADDRESS at 0x0000000100000019\nException Codes: 0x0000000000000001, 0x0000000100000019\nVM Region Info: 0x100000019 is not in any region.  Bytes before following region: 1818599\n      REGION TYPE                 START - END      [ VSIZE] PRT/MAX SHRMOD  REGION DETAIL\n      UNUSED SPACE AT START\n---\u003e  \n      __TEXT                   1001bc000-100de4000 [ 12.2M] r-x/r-x SM=COW  /var/containers/Bundle/Application/1AE46E45-C00B-4B11-853F-EEF891B720DA/FrontSystems.app/FrontSystems\nTriggered by Thread:  19\n\n\nThread 0 name:\nThread 0 name:\nThread 0:\n0   libsystem_kernel.dylib        \t0x00000001ed03bce4 0x1ed03b000 + 3300\n1   libsystem_kernel.dylib        \t0x00000001ed03f39c 0x1ed03b000 + 17308\n2   libsystem_kernel.dylib        \t0x00000001ed03f2b8 0x1ed03b000 + 17080\n3   libsystem_kernel.dylib        \t0x00000001ed03f100 0x1ed03b000 + 16640\n4   CoreFoundation                \t0x000000019be2e900 0x19be1d000 + 71936\n5   CoreFoundation                \t0x000000019be2d1f0 0x19be1d000 + 66032\n6   CoreFoundation                \t0x000000019be2ec3c 0x19be1d000 + 72764\n7   GraphicsServices              \t0x00000001e900d454 0x1e900c000 + 5204\n8   UIKitCore                     \t0x000000019e841274 0x19e70c000 + 1266292\n9   UIKitCore                     \t0x000000019e80ca28 0x19e70c000 + 1051176\n10  FrontSystems                  \t0x0000000100a384b0 xamarin_UIApplicationMain (in FrontSystems) (bindings.m:131) + 8897712\n11  FrontSystems                  \t0x0000000100c2cb34 do_icall (in FrontSystems) (interp.c:2426) + 10947380\n12  FrontSystems                  \t0x0000000100c2b1d8 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 10940888\n13  FrontSystems                  \t0x0000000100c26300 mono_interp_exec_method (in FrontSystems) (interp.c:4259) + 10920704\n14  FrontSystems                  \t0x0000000100c21b80 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10902400\n15  FrontSystems                  \t0x0000000100be94b4 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10671284\n16  FrontSystems                  \t0x0000000100b8c738 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10291000\n17  FrontSystems                  \t0x0000000100b92dc4 mono_runtime_exec_main_checked (in FrontSystems) (object.c:4808) + 10317252\n18  FrontSystems                  \t0x0000000100bf06ac mono_jit_exec (in FrontSystems) (driver.c:1311) + 10700460\n19  FrontSystems                  \t0x0000000100a4caec xamarin_main (in FrontSystems) (monotouch-main.m:0) + 8981228\n20  FrontSystems                  \t0x0000000100de4848 main (in FrontSystems) (main.arm64.mm:81) + 12748872\n21  dyld                          \t0x00000001c2d03f08 0x1c2cc5000 + 257800\n\nThread 1 name:\nThread 1:\n0   libsystem_kernel.dylib        \t0x00000001ed041438 0x1ed03b000 + 25656\n1   libsystem_pthread.dylib       \t0x0000000226459e50 0x226458000 + 7760\n2   FrontSystems                  \t0x0000000100b1fd20 thread_func (in FrontSystems) (sgen-thread-pool.c:195) + 9846048\n3   libsystem_pthread.dylib       \t0x000000022645b344 0x226458000 + 13124\n4   libsystem_pthread.dylib       \t0x0000000226458ab8 0x226458000 + 2744\n\nThread 2 name:\nThread 2:\n0   libsystem_kernel.dylib        \t0x00000001ed03bc60 0x1ed03b000 + 3168\n1   FrontSystems                  \t0x0000000100bc7e40 finalizer_thread (in FrontSystems) (gc.c:868) + 10534464\n2   FrontSystems                  \t0x0000000100ba3aa8 start_wrapper (in FrontSystems) (threads.c:1276) + 10386088\n3   libsystem_pthread.dylib       \t0x000000022645b344 0x226458000 + 13124\n4   libsystem_pthread.dylib       \t0x0000000226458ab8 0x226458000 + 2744\n\nThread 3:\n0   libsystem_pthread.dylib       \t0x0000000226458aa4 0x226458000 + 2724\n\nThread 4 name:\nThread 4:\n0   libsystem_kernel.dylib        \t0x00000001ed03bce4 0x1ed03b000 + 3300\n1   libsystem_kernel.dylib        \t0x00000001ed03f39c 0x1ed03b000 + 17308\n2   libsystem_kernel.dylib        \t0x00000001ed03f2b8 0x1ed03b000 + 17080\n3   libsystem_kernel.dylib        \t0x00000001ed03f100 0x1ed03b000 + 16640\n4   CoreFoundation                \t0x000000019be2e900 0x19be1d000 + 71936\n5   CoreFoundation                \t0x000000019be2d1f0 0x19be1d000 + 66032\n6   CoreFoundation                \t0x000000019be2ec3c 0x19be1d000 + 72764\n7   Foundation                    \t0x000000019aaa679c 0x19aa97000 + 63388\n8   Foundation                    \t0x000000019aaac020 0x19aa97000 + 86048\n9   UIKitCore                     \t0x000000019e82b56c 0x19e70c000 + 1176940\n10  Foundation                    \t0x000000019ab0c804 0x19aa97000 + 481284\n11  libsystem_pthread.dylib       \t0x000000022645b344 0x226458000 + 13124\n12  libsystem_pthread.dylib       \t0x0000000226458ab8 0x226458000 + 2744\n\nThread 5 name:\nThread 5:\n0   libsystem_kernel.dylib        \t0x00000001ed041438 0x1ed03b000 + 25656\n1   libsystem_pthread.dylib       \t0x0000000226459e7c 0x226458000 + 7804\n2   FrontSystems                  \t0x0000000100ab0484 SystemNative_LowLevelMonitor_TimedWait (in FrontSystems) (pal_threading.c:198) + 9389188\n3   FrontSystems                  \t0x0000000100c2cbd4 do_icall (in FrontSystems) (interp.c:2390) + 10947540\n4   FrontSystems                  \t0x0000000100c2b1d8 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 10940888\n5   FrontSystems                  \t0x0000000100c26300 mono_interp_exec_method (in FrontSystems) (interp.c:4259) + 10920704\n6   FrontSystems                  \t0x0000000100c21b80 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10902400\n7   FrontSystems                  \t0x0000000100be94b4 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10671284\n8   FrontSystems                  \t0x0000000100b8c738 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10291000\n9   FrontSystems                  \t0x0000000100ba3a8c start_wrapper (in FrontSystems) (threads.c:1276) + 10386060\n10  libsystem_pthread.dylib       \t0x000000022645b344 0x226458000 + 13124\n11  libsystem_pthread.dylib       \t0x0000000226458ab8 0x226458000 + 2744\n\nThread 6 name:\nThread 6:\n0   libsystem_kernel.dylib        \t0x00000001ed041438 0x1ed03b000 + 25656\n1   libsystem_pthread.dylib       \t0x0000000226459e7c 0x226458000 + 7804\n2   FrontSystems                  \t0x0000000100ab0484 SystemNative_LowLevelMonitor_TimedWait (in FrontSystems) (pal_threading.c:198) + 9389188\n3   FrontSystems                  \t0x0000000100c2cbd4 do_icall (in FrontSystems) (interp.c:2390) + 10947540\n4   FrontSystems                  \t0x0000000100c2b1d8 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 10940888\n5   FrontSystems                  \t0x0000000100c26300 mono_interp_exec_method (in FrontSystems) (interp.c:4259) + 10920704\n6   FrontSystems                  \t0x0000000100c21b80 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10902400\n7   FrontSystems                  \t0x0000000100be94b4 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10671284\n8   FrontSystems                  \t0x0000000100b8c738 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10291000\n9   FrontSystems                  \t0x0000000100ba3a8c start_wrapper (in FrontSystems) (threads.c:1276) + 10386060\n10  libsystem_pthread.dylib       \t0x000000022645b344 0x226458000 + 13124\n11  libsystem_pthread.dylib       \t0x0000000226458ab8 0x226458000 + 2744\n\nThread 7 name:\nThread 7:\n0   libsystem_kernel.dylib        \t0x00000001ed041438 0x1ed03b000 + 25656\n1   libsystem_pthread.dylib       \t0x0000000226459e7c 0x226458000 + 7804\n2   FrontSystems                  \t0x0000000100ab0484 SystemNative_LowLevelMonitor_TimedWait (in FrontSystems) (pal_threading.c:198) + 9389188\n3   FrontSystems                  \t0x0000000100c2cbd4 do_icall (in FrontSystems) (interp.c:2390) + 10947540\n4   FrontSystems                  \t0x0000000100c2b1d8 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 10940888\n5   FrontSystems                  \t0x0000000100c26300 mono_interp_exec_method (in FrontSystems) (interp.c:4259) + 10920704\n6   FrontSystems                  \t0x0000000100c21b80 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10902400\n7   FrontSystems                  \t0x0000000100be94b4 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10671284\n8   FrontSystems                  \t0x0000000100b8c738 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10291000\n9   FrontSystems                  \t0x0000000100ba3a8c start_wrapper (in FrontSystems) (threads.c:1276) + 10386060\n10  libsystem_pthread.dylib       \t0x000000022645b344 0x226458000 + 13124\n11  libsystem_pthread.dylib       \t0x0000000226458ab8 0x226458000 + 2744\n\nThread 8 name:\nThread 8:\n0   libsystem_kernel.dylib        \t0x00000001ed041438 0x1ed03b000 + 25656\n1   libsystem_pthread.dylib       \t0x0000000226459e7c 0x226458000 + 7804\n2   FrontSystems                  \t0x0000000100ab0484 SystemNative_LowLevelMonitor_TimedWait (in FrontSystems) (pal_threading.c:198) + 9389188\n3   FrontSystems                  \t0x0000000100c2cbd4 do_icall (in FrontSystems) (interp.c:2390) + 10947540\n4   FrontSystems                  \t0x0000000100c2b1d8 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 10940888\n5   FrontSystems                  \t0x0000000100c26300 mono_interp_exec_method (in FrontSystems) (interp.c:4259) + 10920704\n6   FrontSystems                  \t0x0000000100c21b80 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10902400\n7   FrontSystems                  \t0x0000000100be94b4 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10671284\n8   FrontSystems                  \t0x0000000100b8c738 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10291000\n9   FrontSystems                  \t0x0000000100ba3a8c start_wrapper (in FrontSystems) (threads.c:1276) + 10386060\n10  libsystem_pthread.dylib       \t0x000000022645b344 0x226458000 + 13124\n11  libsystem_pthread.dylib       \t0x0000000226458ab8 0x226458000 + 2744\n\nThread 9 name:\nThread 9:\n0   libsystem_kernel.dylib        \t0x00000001ed042768 0x1ed03b000 + 30568\n1   FrontSystems                  \t0x0000000100aae5c0 SystemNative_WaitForSocketEvents (in FrontSystems) (pal_networking.c:3256) + 9381312\n2   FrontSystems                  \t0x0000000100c2cbb0 do_icall (in FrontSystems) (interp.c:2402) + 10947504\n3   FrontSystems                  \t0x0000000100c2b1d8 do_icall_wrapper (in FrontSystems) (interp.c:2467) + 10940888\n4   FrontSystems                  \t0x0000000100c26300 mono_interp_exec_method (in FrontSystems) (interp.c:4259) + 10920704\n5   FrontSystems                  \t0x0000000100c21b80 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10902400\n6   FrontSystems                  \t0x0000000100be94b4 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10671284\n7   FrontSystems                  \t0x0000000100b8c738 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10291000\n8   FrontSystems                  \t0x0000000100ba3a8c start_wrapper (in FrontSystems) (threads.c:1276) + 10386060\n9   libsystem_pthread.dylib       \t0x000000022645b344 0x226458000 + 13124\n10  libsystem_pthread.dylib       \t0x0000000226458ab8 0x226458000 + 2744\n\nThread 10:\n0   libsystem_pthread.dylib       \t0x0000000226458aa4 0x226458000 + 2724\n\nThread 11:\n0   libsystem_pthread.dylib       \t0x0000000226458aa4 0x226458000 + 2724\n\nThread 12:\n0   libsystem_pthread.dylib       \t0x0000000226458aa4 0x226458000 + 2724\n\nThread 13 name:\nThread 13:\n0   libsystem_kernel.dylib        \t0x00000001ed041438 0x1ed03b000 + 25656\n1   libsystem_pthread.dylib       \t0x0000000226459e50 0x226458000 + 7760\n2   FrontSystems                  \t0x0000000100ad53f4 mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9540596\n3   FrontSystems                  \t0x0000000100ad91d0 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9556432\n4   FrontSystems                  \t0x0000000100c2cbd4 do_icall (in FrontSystems) (interp.c:2390) + 10947540\n5   FrontSystems                  \t0x0000000100c2b210 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 10940944\n6   FrontSystems                  \t0x0000000100c26300 mono_interp_exec_method (in FrontSystems) (interp.c:4259) + 10920704\n7   FrontSystems                  \t0x0000000100c21b80 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10902400\n8   FrontSystems                  \t0x0000000100be94b4 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10671284\n9   FrontSystems                  \t0x0000000100b8c738 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10291000\n10  FrontSystems                  \t0x0000000100ba3a8c start_wrapper (in FrontSystems) (threads.c:1276) + 10386060\n11  libsystem_pthread.dylib       \t0x000000022645b344 0x226458000 + 13124\n12  libsystem_pthread.dylib       \t0x0000000226458ab8 0x226458000 + 2744\n\nThread 14 name:\nThread 14:\n0   libsystem_kernel.dylib        \t0x00000001ed041438 0x1ed03b000 + 25656\n1   libsystem_pthread.dylib       \t0x0000000226459e50 0x226458000 + 7760\n2   FrontSystems                  \t0x0000000100ad53f4 mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9540596\n3   FrontSystems                  \t0x0000000100ad91d0 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9556432\n4   FrontSystems                  \t0x0000000100c2cbd4 do_icall (in FrontSystems) (interp.c:2390) + 10947540\n5   FrontSystems                  \t0x0000000100c2b210 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 10940944\n6   FrontSystems                  \t0x0000000100c26300 mono_interp_exec_method (in FrontSystems) (interp.c:4259) + 10920704\n7   FrontSystems                  \t0x0000000100c21b80 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10902400\n8   FrontSystems                  \t0x0000000100be94b4 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10671284\n9   FrontSystems                  \t0x0000000100b8c738 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10291000\n10  FrontSystems                  \t0x0000000100ba3a8c start_wrapper (in FrontSystems) (threads.c:1276) + 10386060\n11  libsystem_pthread.dylib       \t0x000000022645b344 0x226458000 + 13124\n12  libsystem_pthread.dylib       \t0x0000000226458ab8 0x226458000 + 2744\n\nThread 15 name:\nThread 15:\n0   libsystem_kernel.dylib        \t0x00000001ed041438 0x1ed03b000 + 25656\n1   libsystem_pthread.dylib       \t0x0000000226459e50 0x226458000 + 7760\n2   FrontSystems                  \t0x0000000100ad53f4 mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9540596\n3   FrontSystems                  \t0x0000000100ad91d0 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9556432\n4   FrontSystems                  \t0x0000000100c2cbd4 do_icall (in FrontSystems) (interp.c:2390) + 10947540\n5   FrontSystems                  \t0x0000000100c2b210 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 10940944\n6   FrontSystems                  \t0x0000000100c26300 mono_interp_exec_method (in FrontSystems) (interp.c:4259) + 10920704\n7   FrontSystems                  \t0x0000000100c21b80 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10902400\n8   FrontSystems                  \t0x0000000100be94b4 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10671284\n9   FrontSystems                  \t0x0000000100b8c738 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10291000\n10  FrontSystems                  \t0x0000000100ba3a8c start_wrapper (in FrontSystems) (threads.c:1276) + 10386060\n11  libsystem_pthread.dylib       \t0x000000022645b344 0x226458000 + 13124\n12  libsystem_pthread.dylib       \t0x0000000226458ab8 0x226458000 + 2744\n\nThread 16 name:\nThread 16:\n0   libsystem_kernel.dylib        \t0x00000001ed03bc60 0x1ed03b000 + 3168\n1   FrontSystems                  \t0x0000000100adb140 mono_os_sem_timedwait (in FrontSystems) (mono-os-semaphore.h:104) + 9564480\n2   FrontSystems                  \t0x0000000100adafa0 mono_threads_wait_pending_operations (in FrontSystems) (mono-threads.c:329) + 9564064\n3   FrontSystems                  \t0x0000000100bd32b0 unified_suspend_stop_world (in FrontSystems) (sgen-stw.c:0) + 10580656\n4   FrontSystems                  \t0x0000000100bd3074 sgen_client_stop_world (in FrontSystems) (sgen-stw.c:163) + 10580084\n5   FrontSystems                  \t0x0000000100af1514 sgen_stop_world (in FrontSystems) (sgen-gc.c:0) + 9655572\n6   FrontSystems                  \t0x0000000100aee59c sgen_perform_collection (in FrontSystems) (sgen-gc.c:2762) + 9643420\n7   FrontSystems                  \t0x0000000100aee4d8 sgen_ensure_free_space (in FrontSystems) (sgen-gc.c:2617) + 9643224\n8   FrontSystems                  \t0x0000000100ae43a0 sgen_alloc_obj_nolock (in FrontSystems) (sgen-alloc.c:259) + 9601952\n9   FrontSystems                  \t0x0000000100bd55a8 mono_gc_alloc_vector (in FrontSystems) (sgen-mono.c:1120) + 10589608\n10  FrontSystems                  \t0x0000000100b963c8 mono_array_new_specific_internal (in FrontSystems) (object.c:6040) + 10331080\n11  FrontSystems                  \t0x0000000100c27084 mono_interp_exec_method (in FrontSystems) (interp.c:6499) + 10924164\n12  FrontSystems                  \t0x0000000100c21b80 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10902400\n13  FrontSystems                  \t0x0000000100be94b4 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10671284\n14  FrontSystems                  \t0x0000000100b8c738 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10291000\n15  FrontSystems                  \t0x0000000100ba3a8c start_wrapper (in FrontSystems) (threads.c:1276) + 10386060\n16  libsystem_pthread.dylib       \t0x000000022645b344 0x226458000 + 13124\n17  libsystem_pthread.dylib       \t0x0000000226458ab8 0x226458000 + 2744\n\nThread 17 name:\nThread 17:\n0   libsystem_kernel.dylib        \t0x00000001ed041438 0x1ed03b000 + 25656\n1   libsystem_pthread.dylib       \t0x0000000226459e50 0x226458000 + 7760\n2   FrontSystems                  \t0x0000000100ad53f4 mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9540596\n3   FrontSystems                  \t0x0000000100ad91d0 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9556432\n4   FrontSystems                  \t0x0000000100c2cbd4 do_icall (in FrontSystems) (interp.c:2390) + 10947540\n5   FrontSystems                  \t0x0000000100c2b210 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 10940944\n6   FrontSystems                  \t0x0000000100c26300 mono_interp_exec_method (in FrontSystems) (interp.c:4259) + 10920704\n7   FrontSystems                  \t0x0000000100c21b80 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10902400\n8   FrontSystems                  \t0x0000000100be94b4 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10671284\n9   FrontSystems                  \t0x0000000100b8c738 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10291000\n10  FrontSystems                  \t0x0000000100ba3a8c start_wrapper (in FrontSystems) (threads.c:1276) + 10386060\n11  libsystem_pthread.dylib       \t0x000000022645b344 0x226458000 + 13124\n12  libsystem_pthread.dylib       \t0x0000000226458ab8 0x226458000 + 2744\n\nThread 18 name:\nThread 18:\n0   libsystem_kernel.dylib        \t0x00000001ed041438 0x1ed03b000 + 25656\n1   libsystem_pthread.dylib       \t0x0000000226459e50 0x226458000 + 7760\n2   FrontSystems                  \t0x0000000100ad53f4 mono_os_cond_timedwait (in FrontSystems) (mono-os-mutex.c:75) + 9540596\n3   FrontSystems                  \t0x0000000100ad91d0 mono_lifo_semaphore_timed_wait (in FrontSystems) (lifo-semaphore.c:55) + 9556432\n4   FrontSystems                  \t0x0000000100c2cbd4 do_icall (in FrontSystems) (interp.c:2390) + 10947540\n5   FrontSystems                  \t0x0000000100c2b210 do_icall_wrapper (in FrontSystems) (interp.c:2473) + 10940944\n6   FrontSystems                  \t0x0000000100c26300 mono_interp_exec_method (in FrontSystems) (interp.c:4259) + 10920704\n7   FrontSystems                  \t0x0000000100c21b80 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10902400\n8   FrontSystems                  \t0x0000000100be94b4 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10671284\n9   FrontSystems                  \t0x0000000100b8c738 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10291000\n10  FrontSystems                  \t0x0000000100ba3a8c start_wrapper (in FrontSystems) (threads.c:1276) + 10386060\n11  libsystem_pthread.dylib       \t0x000000022645b344 0x226458000 + 13124\n12  libsystem_pthread.dylib       \t0x0000000226458ab8 0x226458000 + 2744\n\nThread 19 name:\nThread 19 Crashed:\n0   FrontSystems                  \t0x0000000100c24324 mono_interp_exec_method (in FrontSystems) (interp.c:6221) + 10912548\n1   FrontSystems                  \t0x0000000100c21b80 interp_runtime_invoke (in FrontSystems) (interp.c:2220) + 10902400\n2   FrontSystems                  \t0x0000000100be94b4 mono_jit_runtime_invoke (in FrontSystems) (mini-runtime.c:0) + 10671284\n3   FrontSystems                  \t0x0000000100b8c738 mono_runtime_invoke_checked (in FrontSystems) (object.c:2788) + 10291000\n4   FrontSystems                  \t0x0000000100ba3a8c start_wrapper (in FrontSystems) (threads.c:1276) + 10386060\n5   libsystem_pthread.dylib       \t0x000000022645b344 0x226458000 + 13124\n6   libsystem_pthread.dylib       \t0x0000000226458ab8 0x226458000 + 2744\n\n\nThread 19 crashed with ARM Thread State (64-bit):\n    x0: 0x000000012d481210   x1: 0x000000012d481218   x2: 0x0000000100000001   x3: 0x0000000100ae5c24\n    x4: 0x0000000100b4b46c   x5: 0x0000000000000000   x6: 0x0000000000000000   x7: 0x000000017197a88c\n    x8: 0x0000000100000001   x9: 0x0000000000000018  x10: 0x00000000000000c0  x11: 0x0000000000000008\n   x12: 0x0000000000000000  x13: 0x000000012c2a7238  x14: 0x00000000ffffffff  x15: 0x000000010e8fa220\n   x16: 0x00000002263ae080  x17: 0x00005a0000005a02  x18: 0x0000000000000000  x19: 0x000000017197a860\n   x20: 0x0000000000000010  x21: 0x0000000171979f60  x22: 0x000000000000001b  x23: 0x0000000118db6a40\n   x24: 0x0000000118db6960  x25: 0x0000000171979f60  x26: 0x000000010105cf08  x27: 0x0000000129867480\n   x28: 0x000000012d481250   fp: 0x000000017197a9f0   lr: 0x0000000100c285c8\n    sp: 0x0000000171979870   pc: 0x0000000100c24324 cpsr: 0x80001000\n   esr: 0x56000080  Address size fault\n\n\nBinary Images:\n        0x1001bc000 -         0x101033fff FrontSystems arm64  \u003cbf0a5492ca63381595c2b4b043d2fba1\u003e /var/containers/Bundle/Application/1AE46E45-C00B-4B11-853F-EEF891B720DA/FrontSystems.app/FrontSystems\n        0x101668000 -         0x1017affff libHarfBuzzSharp arm64  \u003c8ca693a9d0533072850919c5df43d67e\u003e /private/var/containers/Bundle/Application/1AE46E45-C00B-4B11-853F-EEF891B720DA/FrontSystems.app/Frameworks/libHarfBuzzSharp.framework/libHarfBuzzSharp\n        0x1017cc000 -         0x101d2bfff libSkiaSharp arm64  \u003c6b45b7dee11f31139b1f1aff7553de02\u003e /private/var/containers/Bundle/Application/1AE46E45-C00B-4B11-853F-EEF891B720DA/FrontSystems.app/Frameworks/libSkiaSharp.framework/libSkiaSharp\n        0x108260000 -         0x10826bfff libobjc-trampolines.dylib arm64e  \u003c9136d8ba22ff3f129caddfc4c6dc51de\u003e /private/preboot/Cryptexes/OS/usr/lib/libobjc-trampolines.dylib\n        0x19aa97000 -         0x19b70addf Foundation arm64e  \u003c34de055d8683380a9198c3347211d13d\u003e /System/Library/Frameworks/Foundation.framework/Foundation\n        0x19be1d000 -         0x19c399fff CoreFoundation arm64e  \u003c7821f73c378b3a10be90ef526b7dba93\u003e /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation\n        0x19e70c000 -         0x1a064db5f UIKitCore arm64e  \u003c96636f64106f30c8a78082dcebb0f443\u003e /System/Library/PrivateFrameworks/UIKitCore.framework/UIKitCore\n        0x1c2cc5000 -         0x1c2d5f857 dyld arm64e  \u003c86d5253d4fd136f3b4ab25982c90cbf4\u003e /usr/lib/dyld\n        0x1e900c000 -         0x1e9014c7f GraphicsServices arm64e  \u003c5ba62c226d3731999dfd0e0f7abebfa9\u003e /System/Library/PrivateFrameworks/GraphicsServices.framework/GraphicsServices\n        0x1ed03b000 -         0x1ed074ebf libsystem_kernel.dylib arm64e  \u003c9e195be11733345ea9bf50d0d7059647\u003e /usr/lib/system/libsystem_kernel.dylib\n        0x1ffcf7000 -         0x2001b7f3f SceneKit arm64e  \u003c2c60462ffd863bbd86852745b25ad5f3\u003e /System/Library/Frameworks/SceneKit.framework/SceneKit\n        0x2263ad000 -         0x2263b460f libsystem_platform.dylib arm64e  \u003c2fef24de67233799a5c59e3df1cd2600\u003e /usr/lib/system/libsystem_platform.dylib\n        0x226458000 -         0x2264643f3 libsystem_pthread.dylib arm64e  \u003cb37430d8e3af33e481e1faed9ee26e8a\u003e /usr/lib/system/libsystem_pthread.dylib\n\nEOF\n`\n",
                                           "updatedAt":  "2025-05-25T20:08:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6tZgED",
                                           "createdAt":  "2025-05-26T10:00:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOET5VPA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "afk013",
                                                                               "createdAt":  "2025-05-27T09:37:04Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "kotlarmilos",
                                           "body":  "\u003e Is there any chance of obtaining a preview/nightly .Net 9 build of the runtime (including Android, iOS simulator and iOS device platforms) with this fix in please\n\n@afk013 Please refer to https://github.com/dotnet/runtime/pull/115573#issuecomment-2904535548 and let us know if it resolves the bug.",
                                           "updatedAt":  "2025-05-26T10:16:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6tZs3q",
                                           "createdAt":  "2025-05-26T10:17:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOETzN_g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "linnkrb",
                                                                               "createdAt":  "2025-05-26T16:25:26Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "kotlarmilos",
                                           "body":  "/cc: @linnkrb, @ConwayLS I\u0027ve created a tracking issue: https://github.com/dotnet/runtime/issues/115991",
                                           "updatedAt":  "2025-05-26T10:17:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6tj4uf",
                                           "createdAt":  "2025-05-27T09:39:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "afk013",
                                           "body":  "\u003e \u003e Is there any chance of obtaining a preview/nightly .Net 9 build of the runtime (including Android, iOS simulator and iOS device platforms) with this fix in please\n\u003e \n\u003e [@afk013](https://github.com/afk013) Please refer to [#115573 (comment)](https://github.com/dotnet/runtime/pull/115573#issuecomment-2904535548) and let us know if it resolves the bug.\n\nBrill thank you @kotlarmilos we will give that a test",
                                           "updatedAt":  "2025-05-27T09:39:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6t22ju",
                                           "createdAt":  "2025-05-28T15:52:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEXw7jw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "kotlarmilos",
                                                                               "createdAt":  "2025-05-28T17:26:15Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "matouskozak",
                                                                               "createdAt":  "2025-05-28T17:32:56Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "afk013",
                                                                               "createdAt":  "2025-05-29T08:27:52Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "dartasen",
                                                                               "createdAt":  "2025-06-24T17:38:04Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "wgriep",
                                           "body":  "@kotlarmilos I\u0027ve tested the private build and this looks like it has resolved our issues with Parallel.ForEachAsync.  Running more tests but on two different iPads and an iPad, we are now able to download significant amounts of data and unzip that data in two different, long running, Parallel.ForEachAsync processes.  Thanks for giving us access to test out your fixes.  Will update if we find anything in our testing, but for now, very positive results!",
                                           "updatedAt":  "2025-05-28T15:52:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6t3wUv",
                                           "createdAt":  "2025-05-28T17:20:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEUPKeQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "kotlarmilos",
                                                                               "createdAt":  "2025-05-28T17:26:16Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "afk013",
                                                                               "createdAt":  "2025-05-29T08:27:58Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "linnkrb",
                                           "body":  "@kotlarmilos  I can also confirm that the InvalidCastException is solved with the private build . Any ETA on this ?\n (Still have working on the other crash in https://github.com/dotnet/runtime/issues/115991). ",
                                           "updatedAt":  "2025-05-28T17:21:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6t33Lp",
                                           "createdAt":  "2025-05-28T17:31:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEU4WfA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "linnkrb",
                                                                               "createdAt":  "2025-05-28T21:07:17Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Pablo-Sierra",
                                                                               "createdAt":  "2025-05-28T22:37:38Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "VictoriaxNeacsu",
                                                                               "createdAt":  "2025-05-29T09:47:01Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Rajagopal-hue",
                                                                               "createdAt":  "2025-06-02T12:20:52Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "kotlarmilos",
                                           "body":  "Happy to hear that! The fix should be available in the next servicing release.\n\n\u003e As you may of noticed in the issue, we pushed a runtime https://github.com/dotnet/runtime/pull/115573 through to our main and release/9.0 branches. We are confident we resolved the instability most of you are experiencing. The fix is slated to be included in our June .NET servicing release and unfortunately, there isn\u0027t a 9.0 based workaround to recommend other than to take the fix when it comes.",
                                           "updatedAt":  "2025-05-28T17:31:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6wefFn",
                                           "createdAt":  "2025-06-10T23:08:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEXw7sA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "linnkrb",
                                                                               "createdAt":  "2025-06-11T11:19:04Z"
                                                                           },
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "jarlem",
                                                                               "createdAt":  "2025-06-11T15:46:58Z"
                                                                           },
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "dartasen",
                                                                               "createdAt":  "2025-06-24T17:38:25Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "HarlanHugh",
                                           "body":  "@kotlarmilos Looks like the June service release is out. (SDK 9.0.301) Can you confirm if this fix is included? ",
                                           "updatedAt":  "2025-06-10T23:08:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6woyzF",
                                           "createdAt":  "2025-06-11T16:34:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEWOycg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "kotlarmilos",
                                                                               "createdAt":  "2025-06-11T16:55:57Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "afk013",
                                           "body":  "@HarlanHugh https://github.com/dotnet/runtime/releases/tag/v9.0.6 was released 20 minutes ago and has #115635 in the release notes so it should be available now 🎉",
                                           "updatedAt":  "2025-06-11T16:34:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6wpBSd",
                                           "createdAt":  "2025-06-11T16:56:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kotlarmilos",
                                           "body":  "@HarlanHugh I checked the source and confirmed the fix is included. Please try it out and let us know if it resolves your issue.",
                                           "updatedAt":  "2025-06-11T16:56:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6wpLAk",
                                           "createdAt":  "2025-06-11T17:10:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEWVeVA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "kotlarmilos",
                                                                               "createdAt":  "2025-06-11T18:01:04Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "afk013",
                                                                               "createdAt":  "2025-06-12T08:22:18Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "wgriep",
                                           "body":  "@kotlarmilos \n\nWe have updated and confirmed that it addresses our issues with the long running Parallel.ForEachAsync issues we were experiencing.  Thanks again everyone for the fix.",
                                           "updatedAt":  "2025-06-11T17:10:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6w1t70",
                                           "createdAt":  "2025-06-12T13:57:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pme442",
                                           "body":  "OK, this is a dumb question, but what exactly do I need to do to get to runtime 9.0.6?  \nBesides Xamarin or Maui versions, I\u0027ve only ever updated things by upgrading Visual Studio.\nI would like to test the fix but I also do not want to screw up my environment.   Right now I am able to build my app and deploy to a real device without errors and I\u0027d like to keep it that way. \n\nHere is what I\u0027ve got installed:\n- Visual Studio 2022 Professional Version 17.12.3.\n- In my .csproj file I am targeting `\u003cMauiVersion\u003e9.0.71\u003c/MauiVersion\u003e`.\n- Xcode 16.3.\n- Note: I also have Visual Studio Version 17.14.0 Preview 7.0, which I am not using.  I had to install it a few weeks ago to test something for a .net maui bug that I found.\n\nIf I upgrade VS with the VS Installer, it wants to take me directly to version 17.14.5.  But I am not sure I want to go that high.  According to https://github.com/dotnet/maui/wiki/Release-Versions it doesn\u0027t look like .net maui has been approved on anything above 17.12.  And I can\u0027t find any MS documentation on what version of Visual Studio is compatible with .net maui 9.0.71.\nAnother option is go to  https://learn.microsoft.com/en-us/visualstudio/releases/2022/release-history and download the bootstrapper for 17.12.9 which supposedly contains runtime version 9.0.6.  \nSo I am not sure if that is what I should do, or is there a better way?\n\nIt looks like I currently have runtime 9.0.5 installed because when I open Visual Studio and go to the Dev Command Prompt, and type \"dotnet --info\" I get the following:\n\n.NET SDK:\n Version:           9.0.300\n Commit:            15606fe0a8\n Workload version:  9.0.300-manifests.af4147de\n MSBuild version:   17.14.5+edd3bbf37\n\nRuntime Environment:\n OS Name:     Windows\n OS Version:  10.0.26100\n OS Platform: Windows\n RID:         win-arm64\n Base Path:   C:\\Program Files\\dotnet\\sdk\\9.0.300\\\n\n.NET workloads installed:\n [android]\n   Installation Source: SDK 9.0.300, VS 17.14.36109.1\n   Manifest Version:    35.0.61/9.0.100\n   Manifest Path:       C:\\Program Files\\dotnet\\sdk-manifests\\9.0.100\\microsoft.net.sdk.android\\35.0.61\\WorkloadManifest.json\n   Install Type:              Msi\n\n [aspire]\n   Installation Source: SDK 9.0.300\n   Manifest Version:    8.2.2/8.0.100\n   Manifest Path:       C:\\Program Files\\dotnet\\sdk-manifests\\8.0.100\\microsoft.net.sdk.aspire\\8.2.2\\WorkloadManifest.json\n   Install Type:              Msi\n\n [iOS]\n   Installation Source: SDK 9.0.300, VS 17.14.36109.1\n   Manifest Version:    18.4.9288/9.0.100\n   Manifest Path:       C:\\Program Files\\dotnet\\sdk-manifests\\9.0.100\\microsoft.net.sdk.ios\\18.4.9288\\WorkloadManifest.json\n   Install Type:              Msi\n\n [maccatalyst]\n   Installation Source: SDK 9.0.300, VS 17.14.36109.1\n   Manifest Version:    18.4.9288/9.0.100\n   Manifest Path:       C:\\Program Files\\dotnet\\sdk-manifests\\9.0.100\\microsoft.net.sdk.maccatalyst\\18.4.9288\\WorkloadManifest.json\n   Install Type:              Msi\n\n [maui-windows]\n   Installation Source: SDK 9.0.300, VS 17.14.36109.1\n   Manifest Version:    9.0.51/9.0.100\n   Manifest Path:       C:\\Program Files\\dotnet\\sdk-manifests\\9.0.100\\microsoft.net.sdk.maui\\9.0.51\\WorkloadManifest.json\n   Install Type:              Msi\n\nConfigured to use workload sets when installing new manifests.\nWorkloads are configured to install and update using workload versions, but none were found. Run \"dotnet workload restore\" to install a workload version.\n\nHost:\n  Version:      9.0.5\n  Architecture: arm64\n  Commit:       e36e4d1a8f\n\n.NET SDKs installed:\n  9.0.101 [C:\\Program Files\\dotnet\\sdk]\n  9.0.300 [C:\\Program Files\\dotnet\\sdk]\n\n.NET runtimes installed:\n  Microsoft.AspNetCore.App 6.0.36 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\n  Microsoft.AspNetCore.App 8.0.11 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\n  Microsoft.AspNetCore.App 8.0.16 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\n  Microsoft.AspNetCore.App 9.0.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\n  Microsoft.AspNetCore.App 9.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\n  Microsoft.NETCore.App 6.0.36 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\n  Microsoft.NETCore.App 8.0.11 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\n  Microsoft.NETCore.App 8.0.16 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\n  Microsoft.NETCore.App 9.0.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\n  Microsoft.NETCore.App 9.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\n  Microsoft.WindowsDesktop.App 6.0.36 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\n  Microsoft.WindowsDesktop.App 8.0.11 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\n  Microsoft.WindowsDesktop.App 8.0.16 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\n  Microsoft.WindowsDesktop.App 9.0.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\n  Microsoft.WindowsDesktop.App 9.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\n\nOther architectures found:\n  x64   [C:\\Program Files\\dotnet\\x64]\n    registered at [HKLM\\SOFTWARE\\dotnet\\Setup\\InstalledVersions\\x64\\InstallLocation]\n  x86   [C:\\Program Files (x86)\\dotnet]\n    registered at [HKLM\\SOFTWARE\\dotnet\\Setup\\InstalledVersions\\x86\\InstallLocation]\n\nEnvironment variables:\n  Not set\n\nglobal.json file:\n  Not found\n\nLearn more:\n  https://aka.ms/dotnet/info\n\nDownload .NET:\n  https://aka.ms/dotnet/download",
                                           "updatedAt":  "2025-06-12T18:47:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6xI0Rk",
                                           "createdAt":  "2025-06-13T22:34:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEWtRKw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "kotlarmilos",
                                                                               "createdAt":  "2025-06-16T07:59:39Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "HarlanHugh",
                                           "body":  "@pme442 - download 9.0.6 here: https://dotnet.microsoft.com/en-us/download/dotnet/9.0\n\n@kotlarmilos - thanks for confirming for us! we have not been able to reproduce the problem since building with the new version so hopefully that\u0027s done but since it\u0027s not predictable it\u0027s hard to be sure until we do a wider distribution.",
                                           "updatedAt":  "2025-06-13T22:34:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6xTiAc",
                                           "createdAt":  "2025-06-15T20:54:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEXAqZw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "am11",
                                                                               "createdAt":  "2025-06-15T21:10:21Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "kotlarmilos",
                                                                               "createdAt":  "2025-06-16T07:59:13Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "jarlem",
                                                                               "createdAt":  "2025-06-18T07:11:48Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "linnkrb",
                                           "body":  "We have now had our app running for 4 days without any of this crashes on 5 differnet iPads with different setups, so at least it´s solved for us! Thanks to everyone! Now I can sleep again! ",
                                           "updatedAt":  "2025-06-15T20:54:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6xojC9",
                                           "createdAt":  "2025-06-17T12:32:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEW5WAA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "kotlarmilos",
                                                                               "createdAt":  "2025-06-17T12:40:59Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "pme442",
                                           "body":  "Thanks, @HarlanHugh.  Actually, I figured out that in Visual Studio, I can got to Help-\u003e Check For Updates -\u003e change the channel to 17.12 and it will upgrade me to the latest version of 17.12 (which is 17.12.9 which has runtime 9.0.6).\nSo I have been testing for 4 days now and I have not been able to reproduce the crash.  I would have to say that 9.0.6 has solved it for me, too.\nThank you so much, guys.  I agree with @linnkrb -- I can sleep again!",
                                           "updatedAt":  "2025-06-17T12:32:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6yJv0H",
                                           "createdAt":  "2025-06-19T18:51:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EricLVertiGIS",
                                           "body":  "We updated our .NET Maui application to 9.0.70 with 9.0.6 Runtime and 9.0.301 SDK, unfortunately the issue still occurs. For us it happens most often around ListView / VerticalStackLayout.\n\n`\n\t0x1028f17c4 - /private/var/containers/Bundle/Application/93C8E14D-7BAC-41DA-8975-6C329C55347B/VertiGISMobileViewer.app/Xamarin.PreBuilt.iOS : mono_runtime_setup_stat_profiler\n\n\t0x102825ea4 - /private/var/containers/Bundle/Application/93C8E14D-7BAC-41DA-8975-6C329C55347B/VertiGISMobileViewer.app/Xamarin.PreBuilt.iOS : mono_invoke_unhandled_exception_hook\n\n0x1d9efa1fc  c0 03 5f d6 10 27 80 d2 01 10 00 d4 03 01 00 54  .._..\u0027.........T\n\n=================================================================\n\nThe app has been terminated.\n\t0x2133dfc60 - /usr/lib/system/libsystem_pthread.dylib : pthread_kill\n\n\t0x1028f1f44 - /private/var/containers/Bundle/Application/93C8E14D-7BAC-41DA-8975-6C329C55347B/VertiGISMobileViewer.app/Xamarin.PreBuilt.iOS : mono_dump_native_crash_info\n\t0x1028dc5c8 - /private/var/containers/Bundle/Application/93C8E14D-7BAC-41DA-8975-6C329C55347B/VertiGISMobileViewer.app/Xamarin.PreBuilt.iOS : mono_handle_native_crash\n\neadStart()\n   at System.Threading.Thread.StartCallback()\n\n\t0x1029357b0 - /private/var/containers/Bundle/Application/93C8E14D-7BAC-41DA-8975-6C329C55347B/VertiGISMobileViewer.app/Xamarin.PreBuilt.iOS : sigabrt_signal_handler.cold.1\n\n\n=================================================================\n\tNative Crash Reporting\n=================================================================\nGot a SIGABRT while executing native code. This usually indicates\na fatal error in the mono runtime or one of the native libraries \nused by your application.\n=================================================================\n\n=================================================================\n\tNative stacktrace:\n=================================================================\n\n2025-06-19 11:45:05.467 Xamarin.PreBuilt.iOS[4602:656038] Unhandled managed exception: Specified cast is not valid. (System.InvalidCastException)\n   at System.Threading.Tasks.Task.RunContinuations(Object continuationObject)\n   at System.Threading.Tasks.Task.FinishContinuations()\n   at System.Threading.Tasks.Task.FinishStageThree()\n   at System.Threading.Tasks.Task.FinishStageTwo()\n   at System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)\n   at System.Threading.Tasks.Task.Finish(Boolean userDelegateExecute)\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\n   at System.Threading.Tasks.Task.ExecuteEntryUnsafe(Thread threadPoolThread)\n   at System.Threading.Tasks.Task.ExecuteFromThreadPool(Thread threadPoolThread)\n   at System.Threading.ThreadPoolWorkQueue.DispatchItemWithAutoreleasePool(Object workItem, Thread currentThread)\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\n   at System.Threading.PortableThreadPool.WorkerThread.WorkerThr\n()\n   at System.Threading.Thread.StartCallback()\n\n\t0x21332fa08 - /usr/lib/system/libsystem_platform.dylib : \u003credacted\u003e\n\n2025-06-19 11:45:05.466 Xamarin.PreBuilt.iOS[4602:656038] \nUnhandled Exception:\nSystem.InvalidCastException: Specified cast is not valid.\n   at System.Threading.Tasks.Task.RunContinuations(Object continuationObject)\n   at System.Threading.Tasks.Task.FinishContinuations()\n   at System.Threading.Tasks.Task.FinishStageThree()\n   at System.Threading.Tasks.Task.FinishStageTwo()\n   at System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)\n   at System.Threading.Tasks.Task.Finish(Boolean userDelegateExecute)\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\n   at System.Threading.Tasks.Task.ExecuteEntryUnsafe(Thread threadPoolThread)\n   at System.Threading.Tasks.Task.ExecuteFromThreadPool(Thread threadPoolThread)\n   at System.Threading.ThreadPoolWorkQueue.DispatchItemWithAutoreleasePool(Object workItem, Thread currentThread)\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\n   at System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart\n\tManaged Stacktrace:\n=================================================================\n=================================================================\n\n0f 5f d6  Y........{...._.\n\n..)......\n0x1d9efa1dc  03 01 00 54 7f 23 03 d5 fd 7b bf a9 fd 03 00 91  ...T.#...{......\n0x1d9efa1ec  59 ed ff 97 bf 03 00 91 fd 7b c1 a8 ff \nff 0f 5f d6 c0 03 5f d6 10 29 80 d2 01 10 00 d4  .._..._\n\t0x2133db344 - /usr/lib/system/libsystem_pthread.dylib : _pthread_start\n\t0x2133d8ab8 - /usr/lib/system/libsystem_pthread.dylib : thread_start\n\n=================================================================\n\tBasic Fault Address Reporting\n=================================================================\nMemory around native instruction pointer (0x1d9efa1dc):0x1d9efa1cc  \n\t0x1026defb0 - /private/var/containers/Bundle/Application/93C8E14D-7BAC-41DA-8975-6C329C55347B/VertiGISMobileViewer.app/Xamarin.PreBuilt.iOS : xamarin_find_protocol_wrapper_type\n\n\t0x190d182d0 - /usr/lib/system/libsystem_c.dylib : abort\n\n\t0x10287e344 - /private/var/containers/Bundle/Application/93C8E14D-7BAC-41DA-8975-6C329C55347B/VertiGISMobileViewer.app/Xamarin.PreBuilt.iOS : start_wrapper\n\nThe app has been terminated.`",
                                           "updatedAt":  "2025-06-19T18:51:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6yJ7PC",
                                           "createdAt":  "2025-06-19T19:09:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "linnkrb",
                                           "body":  "You need to convert your listviews to collectionview. They are deprecated.  We also had to make sure we did not have usenativehandler to  false .\r\n\r\nSendt fra Outlook for iOS\u003chttps://aka.ms/o0ukef\u003e\r\n________________________________\r\nFrom: EricLVertiGIS ***@***.***\u003e\r\nSent: Thursday, June 19, 2025 8:51:28 PM\r\nTo: dotnet/runtime ***@***.***\u003e\r\nCc: Linn Kristin Bjørkli ***@***.***\u003e; Mention ***@***.***\u003e\r\nSubject: Re: [dotnet/runtime] [net9] System.Private.CoreLib occurs InvalidOperationException and InvalidCastException (Issue #114262)\r\n\r\n[EXTERNAL E-MAIL] Do not click any links or attachments unless you trust the sender and know the content is safe.\r\n[https://avatars.githubusercontent.com/u/153765088?s=20\u0026v=4]EricLVertiGIS left a comment (dotnet/runtime#114262)\u003chttps://github.com/dotnet/runtime/issues/114262#issuecomment-2988899591\u003e\r\n\r\nWe updated our .NET Maui application to 9.0.70 with 9.0.6 Runtime and 9.0.301 SDK, unfortunately the issue still occurs. For us it happens most often around ListView / VerticalStackLayout.\r\n\r\n`\r\n0x1028f17c4 - /private/var/containers/Bundle/Application/93C8E14D-7BAC-41DA-8975-6C329C55347B/VertiGISMobileViewer.app/Xamarin.PreBuilt.iOS : mono_runtime_setup_stat_profiler\r\n\r\n0x102825ea4 - /private/var/containers/Bundle/Application/93C8E14D-7BAC-41DA-8975-6C329C55347B/VertiGISMobileViewer.app/Xamarin.PreBuilt.iOS : mono_invoke_unhandled_exception_hook\r\n\r\n\r\n0x1d9efa1fc c0 03 5f d6 10 27 80 d2 01 10 00 d4 03 01 00 54 .._..\u0027.........T\r\n\r\n=================================================================\r\n\r\nThe app has been terminated.\r\n0x2133dfc60 - /usr/lib/system/libsystem_pthread.dylib : pthread_kill\r\n\r\n0x1028f1f44 - /private/var/containers/Bundle/Application/93C8E14D-7BAC-41DA-8975-6C329C55347B/VertiGISMobileViewer.app/Xamarin.PreBuilt.iOS : mono_dump_native_crash_info\r\n0x1028dc5c8 - /private/var/containers/Bundle/Application/93C8E14D-7BAC-41DA-8975-6C329C55347B/VertiGISMobileViewer.app/Xamarin.PreBuilt.iOS : mono_handle_native_crash\r\n\r\n\r\neadStart()\r\nat System.Threading.Thread.StartCallback()\r\n\r\n0x1029357b0 - /private/var/containers/Bundle/Application/93C8E14D-7BAC-41DA-8975-6C329C55347B/VertiGISMobileViewer.app/Xamarin.PreBuilt.iOS : sigabrt_signal_handler.cold.1\r\n\r\n\r\n=================================================================\r\nNative Crash Reporting\r\nGot a SIGABRT while executing native code. This usually indicates\r\na fatal error in the mono runtime or one of the native libraries\r\nused by your application.\r\n=================================================================\r\nNative stacktrace:\r\n\r\n2025-06-19 11:45:05.467 Xamarin.PreBuilt.iOS[4602:656038] Unhandled managed exception: Specified cast is not valid. (System.InvalidCastException)\r\nat System.Threading.Tasks.Task.RunContinuations(Object continuationObject)\r\nat System.Threading.Tasks.Task.FinishContinuations()\r\nat System.Threading.Tasks.Task.FinishStageThree()\r\nat System.Threading.Tasks.Task.FinishStageTwo()\r\nat System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)\r\nat System.Threading.Tasks.Task.Finish(Boolean userDelegateExecute)\r\nat System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\r\nat System.Threading.Tasks.Task.ExecuteEntryUnsafe(Thread threadPoolThread)\r\nat System.Threading.Tasks.Task.ExecuteFromThreadPool(Thread threadPoolThread)\r\nat System.Threading.ThreadPoolWorkQueue.DispatchItemWithAutoreleasePool(Object workItem, Thread currentThread)\r\nat System.Threading.ThreadPoolWorkQueue.Dispatch()\r\nat System.Threading.PortableThreadPool.WorkerThread.WorkerThr\r\n()\r\nat System.Threading.Thread.StartCallback()\r\n\r\n0x21332fa08 - /usr/lib/system/libsystem_platform.dylib : \u003credacted\u003e\r\n\r\n\r\n2025-06-19 11:45:05.466 Xamarin.PreBuilt.iOS[4602:656038]\r\nUnhandled Exception:\r\nSystem.InvalidCastException: Specified cast is not valid.\r\nat System.Threading.Tasks.Task.RunContinuations(Object continuationObject)\r\nat System.Threading.Tasks.Task.FinishContinuations()\r\nat System.Threading.Tasks.Task.FinishStageThree()\r\nat System.Threading.Tasks.Task.FinishStageTwo()\r\nat System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)\r\nat System.Threading.Tasks.Task.Finish(Boolean userDelegateExecute)\r\nat System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\r\nat System.Threading.Tasks.Task.ExecuteEntryUnsafe(Thread threadPoolThread)\r\nat System.Threading.Tasks.Task.ExecuteFromThreadPool(Thread threadPoolThread)\r\nat System.Threading.ThreadPoolWorkQueue.DispatchItemWithAutoreleasePool(Object workItem, Thread currentThread)\r\nat System.Threading.ThreadPoolWorkQueue.Dispatch()\r\nat System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart\r\nManaged Stacktrace:\r\n\r\n=================================================================\r\n\r\n0f 5f d6 Y........{...._.\r\n\r\n..)......\r\n0x1d9efa1dc 03 01 00 54 7f 23 03 d5 fd 7b bf a9 fd 03 00 91 ...T.#...{......\r\n0x1d9efa1ec 59 ed ff 97 bf 03 00 91 fd 7b c1 a8 ff\r\nff 0f 5f d6 c0 03 5f d6 10 29 80 d2 01 10 00 d4 .....\r\n0x2133db344 - /usr/lib/system/libsystem_pthread.dylib : _pthread_start\r\n0x2133d8ab8 - /usr/lib/system/libsystem_pthread.dylib : thread_start\r\n\r\n=================================================================\r\nBasic Fault Address Reporting\r\n\r\nMemory around native instruction pointer (0x1d9efa1dc):0x1d9efa1cc\r\n0x1026defb0 - /private/var/containers/Bundle/Application/93C8E14D-7BAC-41DA-8975-6C329C55347B/VertiGISMobileViewer.app/Xamarin.PreBuilt.iOS : xamarin_find_protocol_wrapper_type\r\n\r\n0x190d182d0 - /usr/lib/system/libsystem_c.dylib : abort\r\n\r\n0x10287e344 - /private/var/containers/Bundle/Application/93C8E14D-7BAC-41DA-8975-6C329C55347B/VertiGISMobileViewer.app/Xamarin.PreBuilt.iOS : start_wrapper\r\n\r\n\r\nThe app has been terminated.`\r\n\r\n—\r\nReply to this email directly, view it on GitHub\u003chttps://github.com/dotnet/runtime/issues/114262#issuecomment-2988899591\u003e, or unsubscribe\u003chttps://github.com/notifications/unsubscribe-auth/ACGFSSVGAX5E3C2LBGT6KMT3EMBDBAVCNFSM6AAAAAB2OX4JTOVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDSOBYHA4TSNJZGE\u003e.\r\nYou are receiving this because you were mentioned.Message ID: ***@***.***\u003e\r\n",
                                           "updatedAt":  "2025-06-19T19:09:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6yKvpZ",
                                           "createdAt":  "2025-06-19T21:18:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EricLVertiGIS",
                                           "body":  "@linnkrb I had thought ListView wasn\u0027t deprecated until .NET 10 ? Anyways thanks for the tips. We use ListView extensively, looks like we have to replace it all.",
                                           "updatedAt":  "2025-06-19T21:18:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6yP-Tj",
                                           "createdAt":  "2025-06-20T09:40:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "linnkrb",
                                           "body":  "It´s not obsolete, just deprecated, but at least allot of our issues disappeared when moving away from listview.\r\n________________________________\r\nFrom: EricLVertiGIS ***@***.***\u003e\r\nSent: 19 June 2025 23:19\r\nTo: dotnet/runtime ***@***.***\u003e\r\nCc: Linn Kristin Bjørkli ***@***.***\u003e; Mention ***@***.***\u003e\r\nSubject: Re: [dotnet/runtime] [net9] System.Private.CoreLib occurs InvalidOperationException and InvalidCastException (Issue #114262)\r\n\r\n[EXTERNAL E-MAIL] Do not click any links or attachments unless you trust the sender and know the content is safe.\r\n[https://avatars.githubusercontent.com/u/153765088?s=20\u0026v=4]EricLVertiGIS left a comment (dotnet/runtime#114262)\u003chttps://github.com/dotnet/runtime/issues/114262#issuecomment-2989161049\u003e\r\n\r\n@linnkrb\u003chttps://github.com/linnkrb\u003e I had thought ListView wasn\u0027t deprecated until .NET 10 ? Anyways thanks for the tips. We use ListView extensively, looks like we have to replace it all.\r\n\r\n—\r\nReply to this email directly, view it on GitHub\u003chttps://github.com/dotnet/runtime/issues/114262#issuecomment-2989161049\u003e, or unsubscribe\u003chttps://github.com/notifications/unsubscribe-auth/ACGFSSSEFYURAQRR2SGU7333EMSNHAVCNFSM6AAAAAB2OX4JTOVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDSOBZGE3DCMBUHE\u003e.\r\nYou are receiving this because you were mentioned.Message ID: ***@***.***\u003e\r\n",
                                           "updatedAt":  "2025-06-20T09:40:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ynM7B",
                                           "createdAt":  "2025-06-23T14:00:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pme442",
                                           "body":  "I use ListViews as well but I haven\u0027t been able to recreate the issue with runtime 9.0.6.  I cannot convert to CollectionView yet due to a bug that causes my app to crash: (https://github.com/dotnet/maui/issues/29556)",
                                           "updatedAt":  "2025-06-23T14:00:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6yv9lc",
                                           "createdAt":  "2025-06-24T05:54:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEX4H3Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kiranbasvaraj",
                                                                               "createdAt":  "2025-06-25T11:10:01Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "neldnelaps",
                                           "body":  "I confirm that crashes still occur after updates. We also use ListView in the project.",
                                           "updatedAt":  "2025-06-24T05:54:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6zEzY2",
                                           "createdAt":  "2025-06-25T11:09:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kiranbasvaraj",
                                           "body":  "I have updated to the latest release, 9.0.80 I still see the same issue. I can also confirm that the frequency still remains the same as that of old version",
                                           "updatedAt":  "2025-06-25T11:09:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6zI2Y4",
                                           "createdAt":  "2025-06-25T16:40:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "afk013",
                                           "body":  "@kiranbasvaraj with you quoting the MAUI version `9.0.80` rather than runtime version `9.0.6` you may not be running with the latest fix. The runtime is not automatically consumed using the latest version MAUI, you need to have the latest .NET SDK installed on your build machine. You can check which SDK versions you have installed using `dotnet --list-sdks` the version you are looking for is **9.0.301** (https://learn.microsoft.com/en-us/dotnet/core/install/how-to-detect-installed-versions?pivots=os-macos)",
                                           "updatedAt":  "2025-06-25T16:40:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6zT59K",
                                           "createdAt":  "2025-06-26T12:35:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "munkii",
                                           "body":  "@afk013 am I correct in saying\n\n1. Set the MauiVersion in CSPROJ to 9.0.80\n2. Update global.json to \"version\" of 9.0.301\n\nIs that it? Previously I had only done number 1. \n\nWhere does 9.0.6 come into it?\n\n**UPDATE**\n\n~ ~I have updated our build to be \"version\" 9.0.301 in global.json and MauiVersion in CSPROJs to be 9.0.80 and it is still happening~ ~\n\n**UPDATE 2**\nI had set the global.json and MauiVersion but our CI Pipeline was not installing the correct maui workload. \n\nTo be honest I thought I\u0027d get a build error if I had a MauiVersion that was looking at the wrong SDK or didn\u0027t have the right workload. \n\nResulting build now working. That crash no longer happens\n\n",
                                           "updatedAt":  "2025-06-26T14:47:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6zicAY",
                                           "createdAt":  "2025-06-27T08:18:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janusw",
                                           "body":  "\u003e [@afk013](https://github.com/afk013) am I correct in saying\n\u003e \n\u003e     1. Set the MauiVersion in CSPROJ to 9.0.80\n\u003e \n\u003e     2. Update global.json to \"version\" of 9.0.301\n\u003e \n\u003e \n\u003e Is that it? Previously I had only done number 1.\n\nIn order to have the fix for this issue, you only need number 2 AFAIK. The MauiVersion should not matter much (and is basically independent of the SDK/runtime version, as long as they all have major version 9).\n\n\n\u003e Where does 9.0.6 come into it?\n\nThe runtime patch level is usually determined by the SDK you are using. The fact that SDK 9.0.301 comes with runtime 9.0.6 can be seen [here](https://dotnet.microsoft.com/en-us/download/dotnet/9.0) and [here](https://github.com/dotnet/core/blob/main/release-notes/9.0/9.0.6/9.0.6.md), for example.\n\n\n\u003e Resulting build now working. That crash no longer happens\n\nAwesome (and consistent with other people\u0027s observations, including mine)! 🥳 ",
                                           "updatedAt":  "2025-06-27T08:18:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7ELBvC",
                                           "createdAt":  "2025-09-15T09:26:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEig4MQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "CONFUSED",
                                                                               "user":  "intiondevelopment",
                                                                               "createdAt":  "2025-09-16T18:34:54Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "intiondevelopment",
                                           "body":  "Hello,\n\nWe have been tracking this issue for months, and in our case the exception still occurs. We are using the latest version of Visual Studio and built the app this morning with the latest SDK version v9.0.305.\n\nThe app runs for a while, but eventually crashes with the following error: Unhandled managed exception: Specified cast is not valid. The same code runs without problems in production on .NET 8.\n\nDo you have any suggestions or guidance? Is a fix planned for .NET 10, and what should we expect?\n\nThank you.\n\nDetails:\n---------------------------------------------------------------------------------------------\n0x102d0f44c - /private/var/containers/Bundle/Application/6DAB3A73-F23D-4F27-BD67-25B2E6310257/XXX.Maui.app/Xamarin.PreBuilt.iOS : mono_dump_native_crash_info\n\n\t0x22504fa68 - /usr/lib/system/libsystem_platform.dylib : \u003credacted\u003e\n\t0x2250ffc60 - /usr/lib/system/libsystem_pthread.dylib : pthread_kill\n\n\t0x2250f8ab8 - /usr/lib/system/libsystem_pthread.dylib : thread_start\n\n=================================================================\n\tBasic Fault Address Reporting\n=================================================================\nMemory around native instruction pointer (0x1ebb801dc):0x1ebb801cc  ff 0f 5f d6 c0 03 5f d6 10 29 80 d2 01 10 00 d4  .._..._..)......\n0x1ebb801dc  03 01 00 54 7f 23 03 d5 \nfd 7b bf a9 fd 03 00 91  ...T.#...{......\n0x1ebb801ec  59 ed ff 97 bf 03 00 91 fd \nThe app has been terminated.\nt()\n   at System.Threading.Thread.StartCallback()\n2025-09-15 11:19:02.362 Xamarin.PreBuilt.iOS[2297:1008718] Unhandled managed exception: Specified cast is not valid. (System.InvalidCastException)\n   at System.Threading.Tasks.Task.RunContinuations(Object continuationObject)\n   at System.Threading.Tasks.Task.FinishContinuations()\n   at System.Threading.Tasks.Task.FinishStageThree()\n   at System.Threading.Tasks.Task.FinishStageTwo()\n   at System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)\n   at System.Threading.Tasks.Task.Finish(Boolean userDelegateExecute)\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\n   at System.Threading.Tasks.Task.ExecuteEntryUnsafe(Thread threadPoolThread)\n   at System.Threading.Tasks.Task.ExecuteFromThreadPool(Thread threadPoolThread)\n   at System.Threading.ThreadPoolWorkQueue.DispatchItemWithAutoreleasePool(Object workItem, Thread currentThread)\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\n   at System.\n7b c1 a8 ff 0f 5f d6  Y........{...._.\n0x1ebb801fc  c0 03 5f d6 10 27 80 d2 01 10 00 d4 03 01 00 54  .._..\u0027.........T\n\n=================================================================\n\tManaged Stacktrace:\n=================================================================\n=================================================================\n\nThreading.PortableThreadPool.WorkerThread.WorkerThreadStart()\n   at System.Threading.Thread.StartCallback()\n\n=================================================================\n\tNative Crash Reporting\n=================================================================\nGot a SIGABRT while executing native code. This usually indicates\na fatal error in the mono runtime or one of the native libraries \nused by your application.\n=================================================================\n\n=================================================================\n\tNative stacktrace:\n=================================================================\n\n\t0x102afbbf0 - /private/var/containers/Bundle/Application/6DAB3A73-F23D-4F27-BD67-25B2E6310257/XXX.Maui.app/Xamarin.PreBuilt.iOS : xamarin_find_protocol_wrapper_type\n\t0x102c43080 - /private/var/containers/Bundle/Application/6DAB3A73-F23D-4F27-BD67-25B2E6310257/XXX.Maui.app/Xamarin.PreBuilt.iOS : mono_invoke_unhandled_exception_hook\n\n\t0x1a2d620ac - /usr/lib/system/libsystem_c.dylib : abort\n\n\t0x102cf9ad0 - /private/var/containers/Bundle/Application/6DAB3A73-F23D-4F27-BD67-25B2E6310257/XXX.Maui.app/Xamarin.PreBuilt.iOS : mono_handle_native_crash\n\t0x102d54804 - /private/var/containers/Bundle/Application/6DAB3A73-F23D-4F27-BD67-25B2E6310257/XXX.Maui.app/Xamarin.PreBuilt.iOS : sigabrt_signal_handler.cold.1\n\t0x102d0eccc - /private/var/containers/Bundle/Application/6DAB3A73-F23D-4F27-BD67-25B2E6310257/XXX.Maui.app/Xamarin.PreBuilt.iOS : mono_runtime_setup_stat_profiler\n\n2025-09-15 11:19:02.362 Xamarin.PreBuilt.iOS[2297:1008718] \nUnhandled Exception:\nSystem.InvalidCastException: Specified cast is not valid.\n   at System.Threading.Tasks.Task.RunContinuations(Object continuationObject)\n   at System.Threading.Tasks.Task.FinishContinuations()\n   at System.Threading.Tasks.Task.FinishStageThree()\n   at System.Threading.Tasks.Task.FinishStageTwo()\n   at System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)\n   at System.Threading.Tasks.Task.Finish(Boolean userDelegateExecute)\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\n   at System.Threading.Tasks.Task.ExecuteEntryUnsafe(Thread threadPoolThread)\n   at System.Threading.Tasks.Task.ExecuteFromThreadPool(Thread threadPoolThread)\n   at System.Threading.ThreadPoolWorkQueue.DispatchItemWithAutoreleasePool(Object workItem, Thread currentThread)\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\n   at System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStar\n\t0x102c9b874 - /private/var/containers/Bundle/Application/6DAB3A73-F23D-4F27-BD67-25B2E6310257/XXX.Maui.app/Xamarin.PreBuilt.iOS : start_wrapper\n\t0x2250fb344 - /usr/lib/system/libsystem_pthread.dylib : _pthread_start\n\nThe app has been terminated.`",
                                           "updatedAt":  "2025-09-15T09:26:01Z"
                                       }
                                   ],
                         "totalCount":  100
                     },
        "title":  "[net9] System.Private.CoreLib occurs InvalidOperationException and InvalidCastException",
        "labels":  [
                       "area-System.Threading",
                       "runtime-mono",
                       "regression-from-last-release"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/114264",
        "createdAt":  "2025-04-04T14:07:06Z",
        "number":  114264,
        "author":  "AlexMinchanka",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-01T17:21:48Z",
        "body":  "**Description:**\nI faced with an issue with the **CancellationTokenSource.CreateLinkedTokenSource** . In some cases, when a parent CancellationTokenSource is canceled, the linked token does not always reflect that cancellation. This issue occurs intermittently, where the linked token remains uncanceled even after the parent token has been canceled. \n\n**Reproduction Steps:**\n1. Use either a Parallel.For or standard for loop to run multiple asynchronous tasks concurrently.\n\n2. Inside each task, create a CancellationTokenSource with a timeout (e.g., 100ms).\n\n3. Register a linked token using CancellationTokenSource.CreateLinkedTokenSource.\n\n4. Introduce a slight delay (Task.Delay) before checking the cancellation status of both the parent and linked tokens.\n\nObserve that, in some cases, the linked token does not reflect the cancellation state of the parent token, even though the parent token has been canceled.\n\n```\nnamespace MyApp\n{\n    internal class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var task = new Task[1000];\n\n            // Use Parallel.For or a standard for loop\n            // Option 1: Using Parallel.For\n            // Parallel.For(0, task.Length, (i) =\u003e\n            // {\n            //     task[i] = DoAsync();\n            // });\n\n            // Option 2: Using standard for loop\n            for (int i = 0; i \u003c task.Length; i++)\n            {\n                task[i] = DoAsync();\n            }\n\n            await Task.WhenAll(task);\n\n            Console.WriteLine(\"Finish\");\n        }\n\n        static async Task DoAsync()\n        {\n            var parentCts = new CancellationTokenSource(100);\n            var parentToken = parentCts.Token;\n            \n            await Task.Delay(98);\n            \n            var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(parentCts.Token);\n            var linkedToken = linkedCts.Token;\n\n            \n            var t1 = parentToken.IsCancellationRequested;\n            var t2 = linkedToken.IsCancellationRequested;\n\n            if (t1 != t2)\n            {\n                Console.WriteLine($\"parent: {t1}, linked: {t2}\");\n            }\n        }\n    }\n}\n```\n\nOutput:\n```\nparent: True, linked: False\nparent: True, linked: False\nparent: True, linked: False\nparent: True, linked: False\nparent: True, linked: False\nFinish\n```\n\n\n**Expected Behavior:**\n\n- After the parent token (parentToken) is canceled (after 100ms), the linked token (linkedToken) should also be canceled.\n\n- Both parentToken.IsCancellationRequested and linkedToken.IsCancellationRequested should return the same result, indicating both tokens were canceled at the same time.\n\n- The cancellation status should be consistent across all tasks, whether using Parallel.For or a standard for loop.\n\n**Actual Behavior:**\n- Inconsistent cancellation status between the parent and linked tokens, especially in asynchronous tasks.\n\n- Some tasks report that the linked token is not canceled, even though the parent token was canceled.\n\nVersion Info:\n- .NET 9\n\n- Console application\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOpeLqtA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6loaC3",
                                           "createdAt":  "2025-04-04T14:07:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-04-04T14:07:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6lomJz",
                                           "createdAt":  "2025-04-04T14:24:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOENGPpg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "elgonzo",
                                                                               "createdAt":  "2025-04-04T14:56:14Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "timcassell",
                                                                               "createdAt":  "2025-04-06T22:27:42Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "When a `CancellationTokenSource` is signaled, e.g. by the timeout firing, it will first transition to a cancelled state (start returning `IsCancellationRequested = true`), then notify all linked token registrations.\nIt\u0027s not possible to do all of this as an atomic operation, so it\u0027s possible and expected that the parent CTS may show as cancelled before all linked sources are updated. But if you add a short delay before querying `IsCancellationRequested` you should see that they match.",
                                           "updatedAt":  "2025-04-04T14:24:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6l2f_j",
                                           "createdAt":  "2025-04-07T08:59:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AlexMinchanka",
                                           "body":  "Maybe there are some alternatives that will help avoid this behavior?",
                                           "updatedAt":  "2025-04-07T08:59:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6l4uq0",
                                           "createdAt":  "2025-04-07T12:07:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "Don\u0027t check the parent token, only check children tokens.  This is a slight delay (although this is already `async`...), but avoids the issue entirely.",
                                           "updatedAt":  "2025-04-07T12:07:26Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Counterintuitive behaviour of linked CancellationTokenSource",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/114551",
        "createdAt":  "2025-04-11T17:34:56Z",
        "number":  114551,
        "author":  "TimLovellSmith",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-13T17:43:31Z",
        "body":  "This is a somewhat anecdotal description of a performance issue, which I want to post in case anyone can help us \u0027track it down\u0027 based on pattern recognition.\n\n### Description\n\nWhile migrating our app to .Net 8, AND doing other changes, we saw some increases in CPU performance costs, this is probably of magnitude 1-3% CPU overall, that we thought we could try to better track down.\n\nThese show where the Delta growths and reductions for us are mostly at:\n\n![Image](https://github.com/user-attachments/assets/06590fab-6300-4622-8bf2-c7ee2b482041)\n\n![Image](https://github.com/user-attachments/assets/cb4c8d92-2eef-4514-8e25-aea03a1a5ae6)\n\nFrom the new increase in usage, we can notice the semaphore is now being used in order to gate access to \u0027GetQueuedCompletionStatus\u0027, which seems like it was previously called more often from CompletionPortThreadStart.\n\nI notice other nearby things that are in the new \u0027growth areas\u0027 (in cost) is the \u0027PortableThreadPool\u0027 and \u0027IOCompletionPoller\u0027.\n\nAlso there seems to be an increase in SwapContext, which I guess is switching threads?\n\n### Configuration\n\nI think this is Windows Server 2022 OS both before/after. Build may have changed.\n\n### Analysis\n\nLooks to me, suspiciously like the main cause of increased CPU cost is something like \n- reconfiguring the managed thread pool? or\n- a new implementation of reading from IO completion ports?\n- updating LIFO semaphore implementation?\n\nWhen I zoom in on LowLevelLifoSemaphore usage before/after, I see\n\nbefore: we mostly use \u0027Wait\u0027 and \u0027WaitForSignal\u0027, and its something like 0.1% of total CPU.\nafter: we mostly use \u0027Wait\u0027 and \u0027WaitForSignal\u0027 but skewed even more towards using \u0027Wait\u0027. Also now we use \u0027Release\u0027 more than \u0027WaitForSignal\u0027 whereas before it was the other way around. And its something like 0.3% of total CPU.\nSo, this doesn\u0027t seem to explain the entire change in overall CPU cost, but it might be a meaningful part of it.\n\nI see we had a **4x** increase in the amount of time in \u0027SpinWait\u0027. And all of that is from being LowLevelLifoSemaphore.Wait\n\nThat sounds possibly a bit like the observations about fairness and unfriendliness to background tasks discussed here, but seen through a different lens?\nhttps://github.com/dotnet/runtime/issues/103812\n\nIn general, our app tends to do a lot of IO processing, and is not usually CPU bound, with many background processes on the machine that occasionally need resources.\n\nI wonder what actually changed to make this difference.\nAre there any obvious ways we could get back to spending less CPU?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOuQLcxQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6mw4xS",
                                           "createdAt":  "2025-04-11T19:16:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "TimLovellSmith",
                                           "body":  "I suppose using [Windows Thread Pool](https://learn.microsoft.com/en-us/dotnet/core/runtime-config/threading#windows-thread-pool) instead is an option, no idea if better or worse yet..",
                                           "updatedAt":  "2025-04-11T19:16:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mw5O2",
                                           "createdAt":  "2025-04-11T19:17:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "TimLovellSmith",
                                           "body":  "Possibly related to PR https://github.com/dotnet/runtime/pull/64834 ?",
                                           "updatedAt":  "2025-04-11T19:17:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mw6pb",
                                           "createdAt":  "2025-04-11T19:21:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "TimLovellSmith",
                                           "body":  "This setting also looks like an interesting one to experiment with.\n\nThe comment here seems to run very counter to the \"received wisdom\" I have, which says you, the author of the IO handling thread, should never hold the thread for long, but you should strive to release it back to the IO completion thread pool in a timely manner.\n\n[I mean, it seems to think that onus should be moved from shoulders of the callback author, at some performance cost.]\n\n```\n        // Continuations of IO completions are dispatched to the ThreadPool from IO completion poller threads. This avoids\n        // continuations blocking/stalling the IO completion poller threads. Setting UnsafeInlineIOCompletionCallbacks allows\n        // continuations to run directly on the IO completion poller thread, but is inherently unsafe due to the potential for\n        // those threads to become stalled due to blocking. Sometimes, setting this config value may yield better latency. The\n        // config value is named for consistency with SocketAsyncEngine.Unix.cs.\n        private static readonly bool UnsafeInlineIOCompletionCallbacks =\n            Environment.GetEnvironmentVariable(\"DOTNET_SYSTEM_NET_SOCKETS_INLINE_COMPLETIONS\") == \"1\";\n```",
                                           "updatedAt":  "2025-04-11T19:23:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mw9cA",
                                           "createdAt":  "2025-04-11T19:28:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "TimLovellSmith",
                                           "body":  "In fact, the more I think about it, the worse that seems. \n\nIf you stick to processing IO on the IO threads, that increases the chances, that by the time you _finish processing_ the IO, _more IO_ has already arrived. So you can keep processing IO without any yielding of the (IO) thread or context switching.\n\nThe converse - if you _always_ hand IO off to non-IO threads for processing, you _always_ incur thread switch cost to hand the work over, _and_ you also increase the chance that you block, or spin, an IO thread waiting for the next bit of IO, since the elapsed time before you get back to waiting for IO is smaller.",
                                           "updatedAt":  "2025-04-11T19:29:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mxDWi",
                                           "createdAt":  "2025-04-11T19:42:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "TimLovellSmith",
                                           "body":  "I also wonder why a bit why you should want four IO poller threads per CPU, or to raise their thread priority.\n\n```\n                    // Poller threads are typically expected to be few in number and have to compete for time slices with all\n                    // other threads that are scheduled to run. They do only a small amount of work and don\u0027t run any user code.\n                    // In situations where frequently, a large number of threads are scheduled to run, a scheduled poller thread\n                    // may be delayed artificially quite a bit. The poller threads are given higher priority than normal to\n                    // mitigate that issue. It\u0027s unlikely that these threads would starve a system because in such a situation\n                    // IO completions would stop occurring. Since the number of IO pollers is configurable, avoid having too\n                    // many poller threads at higher priority.\n                    if (IOCompletionPollerCount * 4 \u003c Environment.ProcessorCount)\n                    {\n                        _thread.Priority = ThreadPriority.AboveNormal;\n                    }\n```\n\nSeems like an attempt to optimize for the \u0027hosed case\u0027, where the server is maxed out on CPU and we imagine that we somehow make things better by prioritizing IO. \n\nBut that itself, sounds like something that only _sometimes_ does what you want... depending on the direction:\n\n* prioritizing receiving requests: grows your current work backlog. (Except you kind of can\u0027t if you\u0027re maxed on CPU.) So maybe _shouldn\u0027t_ be prioritized?\n\n* prioritizing sending responses: closes/shrinks your current work backlog by finish responding to requests (with better latency?). So maybe is good to prioritize.",
                                           "updatedAt":  "2025-04-11T19:42:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mxFjK",
                                           "createdAt":  "2025-04-11T19:46:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "TimLovellSmith",
                                           "body":  "Whoops, I\u0027m reading that wrong, aren\u0027t I.\n four IO poller threads per CPU? That\u0027d be \n`(IOCompletionPollerCount  \u003c Environment.ProcessorCount *4)`",
                                           "updatedAt":  "2025-04-11T19:46:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6myWeZ",
                                           "createdAt":  "2025-04-11T23:34:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "TimLovellSmith",
                                           "body":  "Well, the IOCompletionPollerCount code seems to be changed a bit since the original PR so maybe I shouldn\u0027t focus on the old code.\n\nI do still wonder if having a count \u003e 1 is likely going to lead to having lots of competing polling threads on small machines though, which sounds like inefficiency.",
                                           "updatedAt":  "2025-04-11T23:35:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6m5w51",
                                           "createdAt":  "2025-04-13T22:41:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-04-13T22:41:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6m5w58",
                                           "createdAt":  "2025-04-13T22:41:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "c.c. @kouvel",
                                           "updatedAt":  "2025-04-13T22:41:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6nDVe1",
                                           "createdAt":  "2025-04-14T18:55:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "TimLovellSmith",
                                           "body":  "My main thought on what might be an improvement at this point - would be trying to optimize for efficiency as well as \u0027safety\u0027.\n\nif runtime were not defaulted to the less efficient dedicated threads IO dispatch, but only switch to that behavior when the liveness of IO dispatch is clearly suffering because threads aren\u0027t getting returned to the pool in timely fashion (is that what got called safety? I think).\n\nHowever, perhaps people will see some drawbacks to this.\n\nBiggest drawback that occurs to me, is just the difficulty of people intuiting or managing the implementation behavior going up - that you can\u0027t predict what kind of thread your work runs on any more, or that context switching kicking in afterwards is confusing to understand, and frustrating to still have to override if its still not what you want.",
                                           "updatedAt":  "2025-04-14T18:55:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc65AtzF",
                                           "createdAt":  "2025-07-22T17:25:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "Hello @TimLovellSmith, would you be able to provide a repro for this so we can investigate? ",
                                           "updatedAt":  "2025-07-22T17:25:24Z"
                                       }
                                   ],
                         "totalCount":  11
                     },
        "title":  "Updating to .Net Framework / .Net Core 8 from .Net Framework .Net Core 6 seems to come with performance penalties for IO completions",
        "labels":  [
                       "area-System.Threading",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/114568",
        "createdAt":  "2025-04-11T20:27:06Z",
        "number":  114568,
        "author":  "MihaZupan",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODCYOjQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "timcassell",
                                            "createdAt":  "2025-04-12T00:23:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "filipnavara",
                                            "createdAt":  "2025-04-12T14:24:37Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dannyd89",
                                            "createdAt":  "2025-04-14T08:32:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2025-05-14T16:47:12Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2025-09-02T18:15:51Z",
        "body":  "### Background and motivation\n\n#65184 made it possible to simplify code around `Exchange`/`CompareExchange`, but when dealing with enums you\u0027re still forced to use unsafe casts back and forth.\n\nA few examples: https://grep.app/search?f.repo=dotnet%2Fruntime\u0026regexp=true\u0026q=Interlocked%5C.%28%3F%3AOr%7CAnd%29%5C%28ref+Unsafe%5C.As\n\n### API Proposal\n\n```csharp\nnamespace System.Threading;\n\npublic static class Interlocked\n{\n    // Existing naming:\n    // public static long Or(ref long location1, long value); // and int, uint, ulong\n    // public static T Exchange\u003cT\u003e(ref T location1, T value);\n\n    public static T Or\u003cT\u003e(ref T location1, T value) where T : struct;\n    public static T And\u003cT\u003e(ref T location1, T value) where T : struct;\n}\n```\n\n\n### API Usage\n\nhttps://github.com/dotnet/runtime/blob/8f4365ae47f6a89a382187d27a00218a2ef7163a/src/libraries/System.Private.Uri/src/System/Uri.cs#L207-L208\nbecomes\n```csharp\nInterlocked.Or(ref _flags, flags); \n```\n\n### Alternative Designs\n\n`Exchange`/`CompareExchange` also have overloads for byte/sbyte/ushort/short.\nWe could list all of them for `Or`/`And` as well, with a generic one for enums.\n\n```csharp\nnamespace System.Threading;\n\npublic static class Interlocked\n{\n    // int/uint/long/ulong overloads already exist\n    public static T Or\u003cT\u003e(ref T location1, T value) where T : struct, Enum;\n    public static sbyte Or(ref sbyte location1, sbyte value);\n    public static byte Or(ref byte location1, byte value);\n    public static short Or(ref short location1, short value);\n    public static ushort Or(ref ushort location1, ushort value);\n\n    public static T And\u003cT\u003e(ref T location1, T value) where T : struct, Enum;\n    public static sbyte And(ref sbyte location1, sbyte value);\n    public static byte And(ref byte location1, byte value);\n    public static short And(ref short location1, short value);\n    public static ushort And(ref ushort location1, ushort value);\n\n    // Q: Do we need bool? Half of the operations are expensive nops\n    // Q: What about nint/nuint? Add/Increment/Decrement don\u0027t have those\n}\n```\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOwX6pMg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6mxVWb",
                                           "createdAt":  "2025-04-11T20:27:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-04-11T20:27:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mxa-N",
                                           "createdAt":  "2025-04-11T20:41:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEN5SEQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MihaZupan",
                                                                               "createdAt":  "2025-04-11T20:52:23Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e where T : Enum;\n\n`where TEnum : struct, Enum` to block Enum parent type.",
                                           "updatedAt":  "2025-04-11T20:41:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mzgJ9",
                                           "createdAt":  "2025-04-12T06:15:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "So now we will have `Interlocked.And/Or` for generic enum, but no normal by-value generic one.",
                                           "updatedAt":  "2025-04-12T06:15:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6m00cH",
                                           "createdAt":  "2025-04-12T15:00:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "Yeah I mentioned that in the alternative designs section, we could either add all the overloads we care about for smaller numbers, or drop the generic constraint and throw at runtime for invalid types like we do for `{Compare}Exchange`.",
                                           "updatedAt":  "2025-04-12T15:00:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7Bfqky",
                                           "createdAt":  "2025-09-02T18:01:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bartonjs",
                                           "body":  "[Video](https://www.youtube.com/watch?v=4DeB1qSvdfA\u0026t=0h50m1s)\n\n* Looks good as proposed\n\n```csharp\nnamespace System.Threading;\n\npublic static class Interlocked\n{\n    // Existing naming:\n    // public static long Or(ref long location1, long value); // and int, uint, ulong\n    // public static T Exchange\u003cT\u003e(ref T location1, T value);\n\n    public static T Or\u003cT\u003e(ref T location1, T value) where T : struct;\n    public static T And\u003cT\u003e(ref T location1, T value) where T : struct;\n}\n```",
                                           "updatedAt":  "2025-09-02T18:15:51Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "[API Proposal]: Generic Interlocked.Or/And for enums and small numbers",
        "labels":  [
                       "api-approved",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/114789",
        "createdAt":  "2025-04-17T17:26:29Z",
        "number":  114789,
        "author":  "nbcks",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-01T17:03:23Z",
        "body":  "### Background and motivation\n\nCurrently there is a very useful method to get the allocated bytes for the current thread: `GC.GetAllocatedBytesForCurrentThread`. However, there is no way to get this for a given System.Threading.Thread object. This is useful for operations like iterating over threads and getting the allocations given what the thread is working on\n\nThe proposed method would be `long System.Threading.Thread.GetAllocatedBytesForThread()` as an instance method added to the System.Threading.Thread class.\n\nAll of this information already exists and can be accessed using csharp from the gc_alloc_context associated with the Thread_data. We have implemented this on windows using:\n            \n```csharp   \nvar plngBytesAllocated = pData.m_alloc_context.alloc_bytes + pData.m_alloc_context.alloc_bytes_uoh - (pData.m_alloc_context.alloc_limit - pData.m_alloc_context.alloc_ptr);\n```\n\n```csharp\nstatic unsafe ref Thread_data GetCurrentNativeThread()\n{\n    var currentNativeThread = GetNativeThread(Thread.CurrentThread);\n    return ref Unsafe.AsRef\u003cThread_data\u003e((void*)currentNativeThread);\n}\n\n[UnsafeAccessor(UnsafeAccessorKind.Field, Name = \"_DONT_USE_InternalThread\")]\nstatic extern ref IntPtr GetNativeThread(Thread thread);\n\n[StructLayout(LayoutKind.Sequential)]\nunsafe struct Thread_data\n{\n    public nint vtable;\n    public int m_state;\n    public int m_fPreemptiveGCDisabled;\n    public nint m_pFrame;\n    public nint m_pDomain;\n    public int m_ThreadId;\n    public nint m_pHead;\n    public LockEntry m_embeddedEntry;\n    public nint m_pBlockingLock;\n    public gc_alloc_context m_alloc_context;\n    public nint m_thAllocContextObj;\n    public nint m_pTEB;\n}\n\n[StructLayout(LayoutKind.Sequential)]\nunsafe struct gc_alloc_context\n{\n    public nint alloc_ptr;\n    public nint alloc_limit;\n    public long alloc_bytes;\n    public long alloc_bytes_uoh;\n    public nint gc_reserved_1;\n    public nint gc_reserved_2;\n    public int alloc_count;\n}\n```\n\n\n\n\n\n### API Proposal\n\n```csharp\nnamespace System.Threading;\n\npublic class Thread\n{\n//....\n\n  public long GetAllocatedBytesForThread()\n  {\n      // implementation\n  }\n\n}\n\nvar thread = System.Threading.Thread.CurrentThread;\n\nConsole.WriteLine($\"Currently allocated bytes for thread: {thread.GetAllocatedBytesForThread()}\");\n```\n\n\n\n### API Usage\n\n```csharp\nnamespace System.Collections.Generic;\n\nvar thread = System.Threading.Thread.CurrentThread;\n\nConsole.WriteLine($\"Currently allocated bytes for thread: {thread.GetAllocatedBytesForThread()}\");\n```\n\n\n\n### Alternative Designs\n\nPotentially could be in GC via a static method that passes in the managed thread id: `GC.GetAllocatedBytesForAThread(int threadID)`\n\n### Risks\n\nThis is purely additive, so no breaking changes",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOp9X6mA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6ntFUd",
                                           "createdAt":  "2025-04-17T17:26:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-04-17T17:26:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6n1fqY",
                                           "createdAt":  "2025-04-18T16:37:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e All of this information already exists and can be accessed using csharp from the gc_alloc_context associated with the Thread_data. \n\nThis accesses the data without any synchronization. Implementation like you have proposed would return bogus result intermittently. Introducing proper synchronization without regressing allocation performance would make this API very slow.",
                                           "updatedAt":  "2025-04-18T16:37:14Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[API Proposal]: GetTotalAllocatedBytes for Thread",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/114991",
        "createdAt":  "2025-04-24T11:35:27Z",
        "number":  114991,
        "author":  "Kolky",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-18T19:06:40Z",
        "body":  "### Description\n\nWe have an application running with multiple instances (~40 pods) in Azure Kubernetes Service (AKS) that connects in total 20.000 IoT devices. The application has a timer (using `System.Threading.Timer`) that should run once a minute to update some counters and metrics. This application was recently ported from .NET Framework 4.7.2 to .NET 8, the code where this timer lives in is in `.NET Standard 2.0`. We know the results of the timer by seeing the counters and metrics on our self created dashboard. \n\nWhile running in AKS we see that Azure sometimes decides to do maintenance, particularly a \"freeze\" of the virtual machine ([link](https://learn.microsoft.com/en-us/azure/virtual-machines/linux/scheduled-events)). The description for that is \"The Virtual Machine is scheduled to pause for a few seconds. CPU and network connectivity may be suspended, but there\u0027s no impact on memory or open files.\". \n\nOut of our ~40 pods, and in the span of 6 months we have seen 5 cases where the `System.Threading.Timer` seems to have stopped working. At the same time the timer stops working we see the number of threads and memory usage of the pod in our Prometheus metrics continuously increasing. As if there is leakage. All of these 5 cases can be traced back to when a freeze occurred. We suspect that the timer is planned to go off during the freeze (which takes usually 7 to 9 seconds).\n\nIs this a known bug in the NetStandard2.0 implementation of the `System.Threading.Timer`? Or is there something wrong in our code that can cause this?\n\n### Reproduction Steps\n\nI cannot easily reproduce due to the requirement of an Azure VM Freeze. But if I would be able to test that:\n\n1. Create an application in dotnet 8. Using a dotnet standard 2.0 class library that has a timer (see`TimerBasedActionTrigger` below).\n2. Run it multiple times on a VM inside AKS.\n3. Schedule the timer so that it fires inside a Freeze of the VM.\n4. Trigger a Freeze of the VM.\n5. Wait until after the Freeze.\n\n### Expected behavior\n\nThe timer keeps working independent of a CPU freeze.\n\n### Actual behavior\n\nThe timer seems to have stopped working, my counters and timers are no longer updated. My thread count keeps slowly going up.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\nApplication is running .NET 8. The timer is in a class library which uses .NET Standard 2.0. We\u0027re using Ubuntu 22.04 in x64.\n\n### Other information\n\nWrapper around our usage of the Timer\n```cs\nusing System;\nusing System.Diagnostics;\nusing System.Threading;\nnamespace XXX\n{\n    public class TimerBasedActionTrigger\n    {\n        private readonly object _timerLocker = new();\n        private Timer _triggerTimer;\n        private readonly Action _action;\n        private readonly TimeSpan _triggerInterval;\n        public TimerBasedActionTrigger(Action action, TimeSpan interval)\n        {\n            _action = action;\n            _triggerInterval = interval;\n        }\n        public void Start()\n        {\n            lock (_timerLocker)\n            {\n                _triggerTimer = new Timer(TriggerTimerCallback);\n                _triggerTimer.Change(0, Timeout.Infinite);\n            }\n        }\n        public void Stop()\n        {\n            lock (_timerLocker)\n            {\n                _triggerTimer?.Change(Timeout.Infinite, Timeout.Infinite);\n                _triggerTimer = null;\n            }\n        }\n        private void RestartTriggerTimer()\n        {\n            lock (_timerLocker)\n            {\n                _triggerTimer?.Change(_triggerInterval, Timeout.InfiniteTimeSpan);\n            }\n        }\n        private void TriggerTimerCallback(object state)\n        {\n            try\n            {\n                _action();\n            }\n            finally\n            {\n                RestartTriggerTimer();\n            }\n        }\n    }\n}\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOxT5e4Q==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6ohTzV",
                                           "createdAt":  "2025-04-24T11:36:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-04-24T11:36:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6r0gMt",
                                           "createdAt":  "2025-05-15T06:06:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Kolky",
                                           "body":  "Any updates?",
                                           "updatedAt":  "2025-05-15T06:06:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7FPl7h",
                                           "createdAt":  "2025-09-18T19:06:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Kolky",
                                           "body":  "Update;\n\n1. We fixed one of the reasons for the freezes, by switching to a different security update strategy for our AKS clusters. This greatly reduced the chances of this happening.\n\n2. We found another piece of code causing the thread leakage.\n\n**However we still cannot explain why the timer stopped working. We still suspect this was due to the freezes.**\n\nWe have shifted priority and are now rewriting the code using dotnet 8 and using a PeriodicTimer.",
                                           "updatedAt":  "2025-09-18T19:06:40Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "System.Threading.Timer in NetStandard2.0 leaks threads after Azure VM Freeze",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/116735",
        "createdAt":  "2025-06-17T11:12:42Z",
        "number":  116735,
        "author":  "petrroll",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-01T06:13:51Z",
        "body":  "While most of methods on sync primitives s.a. SemaphoreSlim are naturally thread safe not just with respect to themselves but also other methods on the type, Dispose / DisposeAsync is a notable exception.\n\n\u003e Unlike most of the members of [SemaphoreSlim](https://learn.microsoft.com/en-us/dotnet/api/system.threading.semaphoreslim?view=net-9.0), [Dispose](https://learn.microsoft.com/en-us/dotnet/api/system.threading.semaphoreslim.dispose?view=net-9.0) is not thread-safe and may not be used concurrently with other members of this instance.\nhttps://learn.microsoft.com/en-us/dotnet/api/system.threading.semaphoreslim.dispose?view=net-9.0\n\nWhile perfectly understandable from API design point of view, I\u0027m convinced this is a pit of failure into which people fall and then end up getting very cryptic null refence exceptions.\n\nNot only is it relatively unexpected, it\u0027s also hard to work around when one knows about the design. As if the dispose is e.g. triggered by cancellation token, one needs to have a synchronization primitive for a synchronization primitive and that makes the whole situation very messy, ouroboros, and again _easy_ to mess up (developers are really bad at thread safety fixes it turns out).\n\nI understand there are perf implications to solving this most likely. But I think it should at least be explored. \n\nFurthermore, it not being an API shape change, it should not be as hard to get through. ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOsa-IJQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6xn2uJ",
                                           "createdAt":  "2025-06-17T11:35:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "If you\u0027re not done using it (or not sure you\u0027re done using it), why are you freeing its resources?\n\nIf you can\u0027t be sure it\u0027s not still in use, just don\u0027t dispose it. Finalizers will clean up anything that needs to be cleaned up.",
                                           "updatedAt":  "2025-06-17T11:35:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6xowQH",
                                           "createdAt":  "2025-06-17T12:47:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-06-17T12:47:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6xpY5y",
                                           "createdAt":  "2025-06-17T13:35:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "Related: #59639",
                                           "updatedAt":  "2025-06-17T13:35:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6xr4gl",
                                           "createdAt":  "2025-06-17T16:42:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "petrroll",
                                           "body":  "@stephentoub That\u0027s a very good point. I blame (our) analyzers yelling about disposing everything disposable in a disposable class (which the class that contains is and must be) and someone following it a while ago. \n\nWill stop disposing it. That makes most sense.\n\n(that being said, that by itself doesn\u0027t solve it being pit of failure unless there\u0027s analyser warning against disposing it or unless everyone realizes this would be a mistake which won\u0027t happen automatically)",
                                           "updatedAt":  "2025-06-17T16:42:05Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "[API thread-safety change] Make Dispose methods of sync primitives (SemaphoreSlim) thread safe",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/117468",
        "createdAt":  "2025-07-09T17:23:02Z",
        "number":  117468,
        "author":  "carlreinke",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-23T21:42:54Z",
        "body":  "### Background and motivation\n\nThere are [multiple internal methods](https://github.com/search?q=repo%3Adotnet%2Fruntime%20%2Fint%20ToTimeoutMilliseconds%2F\u0026type=code) to convert a `TimeSpan` to a number of milliseconds between -1 and `int.MaxValue`.  A common implementation ensures consistent behavior and allows non-BCL API designers to match that behavior.\n\n### API Proposal\n\n```csharp\nnamespace System.Threading;\n\npublic static partial class Timeout\n{\n    // Implementation to be taken from `WaitHandle.ToTimeoutMilliseconds(TimeSpan)`.\n    public static int ToMilliseconds(TimeSpan timeout);\n}\n```\n\n\n### API Usage\n\n```csharp\npublic void DoSomething(TimeSpan timeout)\n{\n    DoSomething(Timeout.ToMilliseconds(timeout));\n}\n\npublic void DoSomething(int timeoutMilliseconds)\n{\n    // ...\n}\n```\n\n\n### Alternative Designs\n\nExpose `WaitHandle.ToTimeoutMilliseconds(TimeSpan)` as a public API.\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOtgaciw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc61_6sg",
                                           "createdAt":  "2025-07-09T17:23:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-datetime\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-07-09T17:23:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc62AC37",
                                           "createdAt":  "2025-07-09T17:34:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-07-09T17:34:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc62AHxR",
                                           "createdAt":  "2025-07-09T17:40:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tarekgh",
                                           "body":  "I don\u0027t think this API gives us anything. What is wrong in `TimeSpan.TotalMilliseconds`? The internal methods that convert TimeSpan timeout to milliseconds can be called directly as `DoSomething(TimeSpan.TotalMilliseconds);` instead of your proposal `DoSomething(Timeout.ToMilliseconds(timeout))`.\n\nCC @stephentoub ",
                                           "updatedAt":  "2025-07-09T17:40:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc62ALwz",
                                           "createdAt":  "2025-07-09T17:45:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlreinke",
                                           "body":  "\u003e The internal methods that convert TimeSpan timeout to milliseconds can be called directly as `DoSomething(TimeSpan.TotalMilliseconds);` instead of your proposal `DoSomething(Timeout.ToMilliseconds(timeout))`.\n\nThey most certainly cannot, which is why [all these helper methods](https://github.com/search?q=repo%3Adotnet%2Fruntime%20%2Fint%20ToTimeoutMilliseconds%2F\u0026type=code) exist.",
                                           "updatedAt":  "2025-07-09T17:45:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc62ARR6",
                                           "createdAt":  "2025-07-09T17:53:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tarekgh",
                                           "body":  "The helper methods are intended to validate the range of milliseconds. Introducing a new class solely for this purpose isn\u0027t justified. All of these internal methods can be consolidated into a single static internal method instead.",
                                           "updatedAt":  "2025-07-09T17:53:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc62ATRQ",
                                           "createdAt":  "2025-07-09T17:57:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlreinke",
                                           "body":  "\u003e Introducing a new class solely for this purpose isn\u0027t justified.\n\nThe `Timeout` class already exists.\n\n\u003e All of these internal methods can be consolidated into a single static internal method instead.\n\nBut then I can\u0027t use it, and I have to re-implement it myself (which I have done for multiple projects and did again today).",
                                           "updatedAt":  "2025-07-09T17:57:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc62AVyH",
                                           "createdAt":  "2025-07-09T18:01:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tarekgh",
                                           "body":  "ok, I reactivated. Sorry, I thought this is a new class proposal. ",
                                           "updatedAt":  "2025-07-09T18:01:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc62BpyL",
                                           "createdAt":  "2025-07-09T20:18:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "Related https://github.com/dotnet/runtime/issues/111847#issuecomment-2672137911",
                                           "updatedAt":  "2025-07-09T20:18:30Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "[API Proposal]: `Timeout.ToMilliseconds(TimeSpan)`",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/117877",
        "createdAt":  "2025-07-21T09:52:12Z",
        "number":  117877,
        "author":  "vrecluse",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODQKGjQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Greg-Smulko",
                                            "createdAt":  "2025-09-12T15:58:47Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-08-13T15:40:56Z",
        "body":  "\n\n\nProblem Description\nWe\u0027ve encountered a critical performance issue with the .NET 9.0 thread pool (using SDK 9.0.303, a stable release) in our production/high-load environment.\n\nUnder heavy load, the application becomes extremely slow or unresponsive. Upon diagnosis with dotnet-stack, we observed a pathological state:\n\nThe ThreadPool\u0027s global work item queue (QueueSize) was backlogged with thousands of items (in our log, the count was 6759).\n\nSimultaneously, dozens of ThreadPool worker threads (PortableThreadPool+WorkerThread) were completely idle, waiting on LowLevelLifoSemaphore.Wait.\n\nExpected Behavior:\nWhen there are pending work items in the global queue, idle worker threads should be woken up immediately to process them.\n\nActual Behavior:\nWork items are severely backlogged in the global queue while a large number of worker threads remain idle, leading to effective thread pool starvation.\n\nAnalysis\nThis issue appears to be related to the internal scheduling or signaling/wakeup mechanism of the new Portable Thread Pool introduced in .NET 9. The logs strongly suggest a failure in the mechanism responsible for waking up idle threads despite a massive number of pending tasks.\n\nOur application is an Orleans-based service that uses ASP.NET Core Kestrel, MongoDB, Nacos, OpenTelemetry, and other libraries, involving a high degree of asynchronous I/O.\n\n\nEvidence: dotnet-stack Trace\nBelow are the key parts of the dotnet-stack log we captured. The full log file can be provided if needed.\n\nLog Summary:\n\nQueueSize: 6759\n\nTypical stack trace for the numerous idle threads:\n\nThread (0x3D6B):\n  CPU_TIME\n  System.Private.CoreLib!System.Threading.LowLevelLifoSemaphore.WaitNative(...)\n  System.Private.CoreLib!System.Threading.LowLevelLifoSemaphore.WaitForSignal(int32)\n  System.Private.CoreLib!System.Threading.LowLevelLifoSemaphore.Wait(int32,bool)\n  System.Private.CoreLib!System.Threading.PortableThreadPool+WorkerThread.WorkerThreadStart()\nAt the same time, at least one worker thread was active, processing an HTTP/2 frame write in Kestrel.\n\nWe believe this is a critical bug within the .NET 9.0 runtime. We hope this information is helpful for the investigation.\n\n[Panda.Silo.Server.stack_log_20250721_161744.txt](https://github.com/user-attachments/files/21344324/Panda.Silo.Server.stack_log_20250721_161744.txt)\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOvc62XQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc64pf0W",
                                           "createdAt":  "2025-07-21T18:08:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "Would you be able to provide a dump of when your service hits the issue? ",
                                           "updatedAt":  "2025-07-21T18:08:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc64zTMJ",
                                           "createdAt":  "2025-07-22T02:08:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vrecluse",
                                           "body":  "\u003e Would you be able to provide a dump of when your service hits the issue?\n\nMy service is running in production environment, and this issue accurs in a short time, I\u0027m running a background task that detecting threadpool queue length and auto call dotnet-stack when the problem happens. After a while, the queue length dropped to 0, so it\u0027s hard to intervent, but this problem shows up again and again.\n\n\u003cimg width=\"1578\" height=\"513\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/a70fe3c2-47d1-45fe-be64-c0dfeb41b754\" /\u003e",
                                           "updatedAt":  "2025-07-22T02:08:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc69zrZd",
                                           "createdAt":  "2025-08-13T15:40:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "We will need some repro or dump to investigate why the threads might not be making progress. ",
                                           "updatedAt":  "2025-08-13T15:40:47Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  ".NET 9 ThreadPool Starvation - High QueueSize with Many Idle Worker Threads",
        "labels":  [
                       "area-System.Threading",
                       "tenet-performance",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/118112",
        "createdAt":  "2025-07-28T03:59:28Z",
        "number":  118112,
        "author":  "clement911",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-31T23:34:29Z",
        "body":  "Hi,\n\nWe are reviewing the Rate limit APIs for our web application.\n\nI noticed that the time-based rate limiters (FixedWindow, SilidingWindow and TokenBucket) all use a [timer](https://github.com/dotnet/runtime/blob/7a6890342caa6360b4e8cb23c598b63046320088/src/libraries/System.Threading.RateLimiting/src/System/Threading/RateLimiting/TokenBucketRateLimiter.cs#L86) to replenish periodically.\n\nThis is also [the case](https://github.com/dotnet/runtime/blob/7a6890342caa6360b4e8cb23c598b63046320088/src/libraries/System.Threading.RateLimiting/src/System/Threading/RateLimiting/DefaultPartitionedRateLimiter.cs#L49) when using a partitioning limiter.\n\nWhile this works, wouldn\u0027t it be more efficient to replenish lazily instead?\nThat is, upon calling `AcquireAsyncCore`, the token count could be refilled with [this logic](https://github.com/dotnet/runtime/blob/7a6890342caa6360b4e8cb23c598b63046320088/src/libraries/System.Threading.RateLimiting/src/System/Threading/RateLimiting/TokenBucketRateLimiter.cs#L311). No timer needed.\n\nIn addition, it seems to me that using a Timer would not be a design choice that would work well with a [store backed bucket](https://github.com/dotnet/aspnetcore/issues/41861). I think that\u0027s why the Stripe\u0027s implementation of their redis LUA rate limiter works exactly like that. It [computes the token count lazily](https://gist.github.com/ptarjan/e38f45f2dfe601419ca3af937fff574d#file-request_rate_limiter-lua-L23) upon request.\n\nI would love to hear your thoughts.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOu0GQlg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc66SEbU",
                                           "createdAt":  "2025-07-28T04:00:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-07-28T04:00:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc66zLyL",
                                           "createdAt":  "2025-07-29T20:34:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "BrennanConroy",
                                           "body":  "We could in theory not use a Timer if the options used a value of `0` for [QueueLimit](https://source.dot.net/System.Threading.RateLimiting/R/5126c707612988e3.html) and then fallback to Timer when `QueueLimit` is in use.\n\nI\u0027ve heard this feedback before, but I guess no one filed an issue for it?\n\nI\u0027ll put this in the `Future` milestone. If anyone wants to try to implement this, please ping me on the PR.",
                                           "updatedAt":  "2025-07-29T20:34:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc66zZnf",
                                           "createdAt":  "2025-07-29T20:50:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "clement911",
                                           "body":  "What is the issue if QueueLimit \u003e 0?\nIs that because a request might need to wait until the bucket replenishes? ",
                                           "updatedAt":  "2025-07-29T20:50:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc67O75B",
                                           "createdAt":  "2025-07-31T20:30:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "BrennanConroy",
                                           "body":  "Right, and if the bucket replenishment is based on other requests, then there might be an arbitrarily long delay for the queued request to be unblocked.",
                                           "updatedAt":  "2025-07-31T20:30:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc67QZCW",
                                           "createdAt":  "2025-07-31T23:34:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "clement911",
                                           "body":  "I guess  it could calculate how long it will be until the first request in the queue can be granted, and set up a one-off timer to wake up at that precise time. As opposed to checking every 100ms.\nIf the queue is empty, one don\u0027t need any timer at all.\n",
                                           "updatedAt":  "2025-07-31T23:34:29Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "RateLimiter AutoReplenishment is based on a Timer",
        "labels":  [
                       "area-System.Threading",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/118192",
        "createdAt":  "2025-07-30T01:54:42Z",
        "number":  118192,
        "author":  "AdamCLarsen",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-14T21:40:49Z",
        "body":  "# Description\n\n`_tokenCount` is stored as `double` and may hold fractional values after replenishment. `AttemptAcquire(0)` returns a successful lease whenever `_tokenCount \u003e 0`, yet `GetStatistics().CurrentAvailablePermits` truncates the same value to `long`, so it reports 0. \n\nThis means that `AttemptAcquire(0)` will always grants a lease, even when none should be given.\n\nhttps://github.com/dotnet/runtime/blob/b6e34b8c14fc531b6997795024374302447372d7/src/libraries/System.Threading.RateLimiting/src/System/Threading/RateLimiting/TokenBucketRateLimiter.cs#L115C13-L119C18\n\n# Reproduction\n\n```csharp\n[Test]\npublic async Task FractionalTokenBug()\n{\n    var limiter = new TokenBucketRateLimiter(new TokenBucketRateLimiterOptions\n    {\n        TokenLimit = 3,\n        TokensPerPeriod = 1,\n        ReplenishmentPeriod = TimeSpan.FromSeconds(0.5),\n        QueueProcessingOrder = QueueProcessingOrder.OldestFirst,\n        AutoReplenishment = false\n    });\n\n    // Drain bucket\n    limiter.AttemptAcquire(3).Dispose();\n\n    await Task.Delay(500);   // enough to add ~1.0 token\n    limiter.TryReplenish();  // _tokenCount ≈ 1.0\n\n    limiter.AttemptAcquire(1).Dispose();      // succeeds as expected\n    Assert.That(limiter.GetStatistics()?.CurrentAvailablePermits, Is.EqualTo(0), \"Tokens after acquiring 1 permit\");\n    var lease = limiter.AttemptAcquire(0);    // **unexpected success**\n    Assert.That(!lease.IsAcquired, \"Acquired a lease, when none should be available\");\n    lease.Dispose();\n}\n```\n\n## Resutls\n\n`Assert.That(!lease.IsAcquired, \"Acquired a lease, when none should be available\");` is failing.\n\nSetting a break point, showed the value of `_tokenCount` to be `0.025640600000000013` in one example test run.\n\n# Root cause\n\n* `GetStatistics()` truncates with `(long)_tokenCount`, so shows as `0`.\n* `AttemptAcquireCore` considers any `_tokenCount \u003e 0` a success, even when `_tokenCount` sits in `(0,1)`\n\nThe cast hides the available fraction from statistics but the acquisition path still sees it, there are multiple places in the class that should be updated to `_tokenCount \u003e= 1`, or where conditions are checking for `_tokenCount == 0`, that will never happen once the first `TryReplenish` triggers.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOutf5VA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc661_lU",
                                           "createdAt":  "2025-07-30T03:07:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-07-30T03:07:39Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "TokenBucketRateLimiter: AttemptAcquire(0) succeeds while CurrentAvailablePermits is 0 due to fractional _tokenCount",
        "labels":  [
                       "area-System.Threading",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/118385",
        "createdAt":  "2025-08-05T11:04:37Z",
        "number":  118385,
        "author":  "vsfeedback",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-07T16:05:44Z",
        "body":  "_This issue has been moved from [a ticket on Developer Community](https://developercommunity.visualstudio.com/t/SemaphoreSlim类-WaitAsync方法不能退出/10946580)._\n\n---\n[severity:Other]\nThe following issues were found in both .NET 8 and .NET 4.8 versions:\nUsing the Release() and WaitAsync() methods of the SemaphoreSlim class, its CurrentCount property keeps increasing when the Release() method is executed. However, the WaitAsync() method did not exit and no exceptions occurred.\nAn example used is the SerialPortTest project in the attachment.\nUse the serial port to send the command to receive, and send the command every 10-200ms, and find that the WaitAsync() method is not working properly after 4-6 days and the serial port triggers the receive event to work normally.\n![image.png](https://aka.ms/dc/image?name=B83e45d1a9af540a78ed61f46fa8d5b9b638898885364982145_20250804-151535-image.png\u0026tid=83e45d1a9af540a78ed61f46fa8d5b9b638898885364982145)\n[Communication-master.zip](https://aka.ms/dc/file?name=B9fcfc5631ce34c61b3e0ba5a97fdb648638898885719401858_Communication-master.zip\u0026tid=9fcfc5631ce34c61b3e0ba5a97fdb648638898885719401858)\n\n---\n### Original Comments\n\n#### 曹一梁 on 04/08/2025, 10:34 AM: \n\n\u003cp\u003eI also used this, it was fine at first, it took 4-5 days to send, cracked\u003c/p\u003e\n\n#### 亮亮 朱 on 04/08/2025, 10:39 AM: \n\n\u003cp\u003eI had the same situation\u003c/p\u003e\n\n#### mo xiao on 04/08/2025, 10:44 AM: \n\n\u003cp\u003eI also found the same problem and hope to solve it soon\u003c/p\u003e\n\n#### U_1498541 on 04/08/2025, 10:45 AM: \n\n\u003cp\u003eI found the same issue.\u003c/p\u003e\n\n#### 苏 顾 on 04/08/2025, 10:45 AM: \n\n\u003cp\u003ePlease help speed up the resolution!!\u003c/p\u003e\n\n#### xingyuan lin on 04/08/2025, 10:47 AM: \n\n\u003cp\u003eEncountering the same problem and urgently needing to be resolved\u003c/p\u003e\n\n#### Feedback Bot on 05/08/2025, 08:08 AM: \n\n\u003cp\u003eWe have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.\u003c/p\u003e\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOvA9ebQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc68D15t",
                                           "createdAt":  "2025-08-05T13:01:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-08-05T13:01:41Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "SemaphoreSlim类 WaitAsync()方法不能退出",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/119043",
        "createdAt":  "2025-08-24T20:39:19Z",
        "number":  119043,
        "author":  "jogibear9988",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODMd7_A==",
                          "nodes":  [
                                        {
                                            "content":  "EYES",
                                            "user":  "lindexi",
                                            "createdAt":  "2025-08-25T07:24:30Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-08-25T19:08:24Z",
        "body":  "### Description\n\nI\u0027ve a bigger dotnet application, wich is running in Net9. It has a Kestrel webserver, and backend code running.\nIt also has a timer wich for example writes to a logfile every minute.\n\nAfter some time, the process is still running, but the webserver does not accept any incomming connections, or does the timer write to the logfile.\n\nBut I could not find anything wrong in the Dump. Anybody any idea?\n\nHere is the Threads window:\n\n\u003cimg width=\"2874\" height=\"1750\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/30dc0c66-60ce-4e4e-8d81-f88b468dfa12\" /\u003e\n\nand the tasks:\n\n\u003cimg width=\"1434\" height=\"872\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/a9e7db7a-373e-4afe-9064-0f2e184e8300\" /\u003e\n\n\u003cimg width=\"1437\" height=\"872\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/6ebffcde-c53c-43a0-9858-820e48169e66\" /\u003e\n\n\u003cimg width=\"1439\" height=\"875\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/5715347d-f2c6-4cd5-bced-0834029dddf2\" /\u003e\n\n### Reproduction Steps\n\nNo Idea, but I can provide a Dump\n\n### Expected behavior\n\nThe process should still accept Connections, or still write to the log\n\n### Actual behavior\n\nNothing, as if the process has completely stopped.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOv_YzuQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6_1JR7",
                                           "createdAt":  "2025-08-24T21:11:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jogibear9988",
                                           "body":  "Shouldn\u0027t the ThreadPool use more then 11 Threads? Or start more if none is available?",
                                           "updatedAt":  "2025-08-24T21:11:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6_1KCO",
                                           "createdAt":  "2025-08-24T21:17:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jogibear9988",
                                           "body":  "What could that wait come from? (I\u0027ve 3 of them in the dump)\n\n\u003cimg width=\"1443\" height=\"189\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/c33d3cfd-f331-4058-8a1b-2510a84a6ab0\" /\u003e\n\nIs there a way how I can find out?",
                                           "updatedAt":  "2025-08-24T21:18:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6_4uVB",
                                           "createdAt":  "2025-08-25T08:29:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hez2010",
                                           "body":  "Are you trying to run any long-running tasks on the worker thread? Don\u0027t use the worker thread for any long-running task, otherwise you may exhaust the worker threads so that the next task will never be scheduled. ",
                                           "updatedAt":  "2025-08-25T08:29:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6_47iN",
                                           "createdAt":  "2025-08-25T08:45:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jogibear9988",
                                           "body":  "I found cases were Thread sleep was used in worker Threads.\nBut shouldn\u0027t .net run more worker threads when they are blocked? Is it normal that there are only 11?\n\nI\u0027ve also one Thread waiting on this mentioned here:\nhttps://github.com/quartznet/quartznet/issues/2354\n\nIs this an error?",
                                           "updatedAt":  "2025-08-25T08:45:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6_9jO5",
                                           "createdAt":  "2025-08-25T14:43:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-08-25T14:43:26Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "Dotnet process running, but no reaction is shown",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/119221",
        "createdAt":  "2025-08-30T11:15:13Z",
        "number":  119221,
        "author":  "dongfengxin",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-15T15:16:36Z",
        "body":  "### Description\n\n!t Loading extension C:\\Program Files\\WindowsApps\\Microsoft.WinDbg_1.2506.12002.0_x64__8wekyb3d8bbwe\\amd64\\winext\\sos\\extensions\\Microsoft.Diagnostics.DataContractReader.dll Loading extension C:\\Program Files\\WindowsApps\\Microsoft.WinDbg_1.2506.12002.0_x64__8wekyb3d8bbwe\\amd64\\winext\\sos\\extensions\\Microsoft.Diagnostics.DataContractReader.Extension.dll Loading extension C:\\Program Files\\WindowsApps\\Microsoft.WinDbg_1.2506.12002.0_x64__8wekyb3d8bbwe\\amd64\\winext\\sos\\extensions\\Microsoft.Diagnostics.DebuggerCommands.dll ThreadCount: 27 UnstartedThread: 0 BackgroundThread: 25 PendingThread: 0 DeadThread: 1 Hosted Runtime: noDBG ID OSID ThreadOBJ State GC Mode GC Alloc Context Domain Count Apt Exception 3 1 3524 0000008000530F30 21220 Preemptive 0000000000000000:0000000000000000 000000800053abd0 -00001 MTA (Finalizer) 0 2 206c 0000008000580F50 26020 Cooperative 0000008029049718:000000802904A4B0 000000800053abd0 -00001 STA 5 4 3a20 000000C096539770 302b220 Preemptive 0000000000000000:0000000000000000 000000800053abd0 -00001 MTA (Threadpool Worker) 6 5 197c 000000C096539DE0 102b220 Preemptive 0000000000000000:0000000000000000 000000800053abd0 -00001 MTA (Threadpool Worker) 7 6 3920 000000C0965AE900 202b220 Preemptive 0000000000000000:0000000000000000 000000800053abd0 -00001 MTA 8 22 20e4 000000C096768D10 202b220 Preemptive 0000000000000000:0000000000000000 000000800053abd0 -00001 MTA 10 23 3294 000000C096434AE0 102b220 Preemptive 0000000000000000:0000000000000000 000000800053abd0 -00001 MTA (Threadpool Worker) 16 21 a28 000000C09EDA7910 302b220 Preemptive 0000000000000000:0000000000000000 000000800053abd0 -00001 MTA (Threadpool Worker) 17 17 3590 000000C09EDAAE00 302b220 Preemptive 0000000000000000:0000000000000000 000000800053abd0 -00001 MTA (Threadpool Worker) 18 8 2e40 000000C09EDA8C50 302b220 Preemptive 0000000000000000:0000000000000000 000000800053abd0 -00001 MTA (Threadpool Worker) 19 10 4808 000000C09EDAA930 302b220 Preemptive 0000000000000000:0000000000000000 000000800053abd0 -00001 MTA (Threadpool Worker) 20 15 31d8 000000C09EDABC70 302b220 Preemptive 0000000000000000:0000000000000000 000000800053abd0 -00001 Ukn (Threadpool Worker) 21 16 27a0 000000C09EDA82B0 302b220 Preemptive 0000000000000000:0000000000000000 000000800053abd0 -00001 MTA (Threadpool Worker) 22 18 3b70 000000C09EDACFB0 302b220 Preemptive 0000000000000000:0000000000000000 000000800053abd0 -00001 MTA (Threadpool Worker) 23 19 483c 000000C09EDA8780 302b220 Preemptive 0000000000000000:0000000000000000 000000800053abd0 -00001 MTA (Threadpool Worker) 24 14 43f0 000000C09EDAC610 302b220 Preemptive 0000000000000000:0000000000000000 000000800053abd0 -00001 MTA (Threadpool Worker) 25 13 4df4 000000C09EDACAE0 302b220 Preemptive 0000000000000000:0000000000000000 000000800053abd0 -00001 MTA (Threadpool Worker) 26 12 2c68 000000C09EDA9120 302b220 Preemptive 0000000000000000:0000000000000000 000000800053abd0 -00001 MTA (Threadpool Worker) 27 11 4e18 000000C09EDA95F0 302b220 Preemptive 0000000000000000:0000000000000000 000000800053abd0 -00001 MTA (Threadpool Worker) 28 9 2028 000000C09EDAD480 302b220 Preemptive 0000000000000000:0000000000000000 000000800053abd0 -00001 MTA (Threadpool Worker) 29 7 33f8 000000C09EDAD950 302b220 Preemptive 0000000000000000:0000000000000000 000000800053abd0 -00001 MTA (Threadpool Worker) 30 24 3768 000000C09EDAE7C0 302b220 Preemptive 0000000000000000:0000000000000000 000000800053abd0 -00001 MTA (Threadpool Worker) 31 25 aac 000000C09EDADE20 302b220 Preemptive 0000000000000000:0000000000000000 000000800053abd0 -00001 MTA (Threadpool Worker) 32 26 4080 000000C09EDAEC90 302b220 Preemptive 0000000000000000:0000000000000000 000000800053abd0 -00001 MTA (Threadpool Worker) 33 27 1c94 000000C09EDAE2F0 302b220 Preemptive 0000000000000000:0000000000000000 000000800053abd0 -00001 MTA (Threadpool Worker) XXXX 31 0 000000C09F6D7F30 1039820 Preemptive 0000000000000000:0000000000000000 000000800053abd0 -00001 Ukn (Threadpool Worker) 36 32 4f34 000000C09F6D4F10 102b220 Cooperative 000000802903C9F8:000000802903E3F0 000000800053abd0 -00001 MTA (Threadpool Worker)\n\n### Reproduction Steps\n\nWith Windbg analysis there is a  thread dead , and  confirm there is no nulls waits .result use, and can not catch the exception with try catch and application exception\n\n### Expected behavior\n\nContinue to run ,or throwth the exception.\n\n### Actual behavior\n\nApplication Stop to run with out any error and excptions\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOxELgJQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc7BJDq5",
                                           "createdAt":  "2025-08-31T20:02:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffschwMSFT",
                                           "body":  "Please share a trace or a dump of the stalled process",
                                           "updatedAt":  "2025-08-31T20:02:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7BJDx3",
                                           "createdAt":  "2025-08-31T20:02:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-08-31T20:02:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7EQuAl",
                                           "createdAt":  "2025-09-15T15:16:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "This issue has been marked `needs-author-action` and may be missing some important information.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-09-15T15:16:36Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "[Dotnet] DotNet 9 Application Stop to Run with Thread Dead",
        "labels":  [
                       "area-System.Threading",
                       "needs-author-action"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/119361",
        "createdAt":  "2025-09-04T19:19:09Z",
        "number":  119361,
        "author":  "VSadov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-15T14:54:22Z",
        "body":  "A follow up for: https://github.com/dotnet/runtime/issues/112868\nRe: https://github.com/dotnet/runtime/issues/102682\n\nA new set of APIs that take `options` arguments has been introduced as a replacement of the old API that could lead to confusion.\n\nSince the new API is a superset of the old, it may make sense to deprecate the old APIs.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOwgc9Kg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc7CBz0q",
                                           "createdAt":  "2025-09-04T19:19:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-09-04T19:19:38Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Deprecate the old named sync objects APIs (ones that have a name argument and no options argument)",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/119389",
        "createdAt":  "2025-09-05T12:11:54Z",
        "number":  119389,
        "author":  "HTH-FiANTEC",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-09T11:38:49Z",
        "body":  "### Description\n\nWe\u0027ve an application server based on .NET8 which gets terminated by a DivideByZeroException from System.Threading.PortableThreadPool.HillClimbing.Update.\n\n### Reproduction Steps\n\nWe\u0027re not able to identifiy the specific function as the application is terminated.\n\n### Expected behavior\n\nThe exception can be handled by application code to minimize corrupted state of data and application. A possibility to identify the producer of the error.\n\n### Actual behavior\n\nFrom the windows event logs, we receive the following information:\n\nCoreCLR Version: 8.0.1725.26602 .NET Version: 8.0.17 Description: The process was terminated due to an unhandled exception. Exception Info: System.DivideByZeroException: Attempted to divide by zero. at System.Threading.PortableThreadPool.HillClimbing.Update(Int32 currentThreadCount, Double sampleDurationSeconds, Int32 numCompletions) at System.Threading.PortableThreadPool.AdjustMaxWorkersActive() at System.Threading.ThreadPoolWorkQueue.Dispatch() at System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart()  \n\nReference found: https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/Threading/PortableThreadPool.WorkerThread.cs\n\n### Regression?\n\nWe\u0027re using the framework since .NET-core 3.1 without facing this issue. The first occurence was in July this year.\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\nCoreCLR Version: 8.0.1725.26602\n .NET Version: 8.0.17 \nx64\nWindows Server 2022\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOwuyyrw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc7CMzKJ",
                                           "createdAt":  "2025-09-05T12:12:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-09-05T12:12:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7COrFZ",
                                           "createdAt":  "2025-09-05T14:49:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "Are you able to capture a dump when the issue occurs? ",
                                           "updatedAt":  "2025-09-05T14:49:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7C7LKv",
                                           "createdAt":  "2025-09-09T11:38:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "HTH-FiANTEC",
                                           "body":  "Unfortunately, it only occurs in the customer environment and cannot really be provoked.\n\nAre there any points that can be checked that could lead to the error described?\nCan it be narrowed down to specific framework components/structures?",
                                           "updatedAt":  "2025-09-09T11:38:49Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "process terminated due to unhandled exception \"DivideByZeroException\"",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/119437",
        "createdAt":  "2025-09-07T12:14:27Z",
        "number":  119437,
        "author":  "marzent",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-15T14:55:48Z",
        "body":  "### Description\n\nThe `Environment.TickCount` and `Environment.TickCount64` APIs on macOS and Linux do not include time spent in system suspend (e.g., sleep or standby), unlike their behavior on Windows.\n\nThis creates a cross-platform inconsistency, as Windows uses `GetTickCount`/`GetTickCount64`, which count wall-clock time, including suspend periods, and is also specified in the dotnet documentation as such:\n\n\u003e Gets the number of milliseconds elapsed since the system started.\n\nOn macOS, `Environment.TickCount64` uses `clock_gettime_nsec_np(CLOCK_UPTIME_RAW)` for both low/hi-res timers:\n\n```\nCLOCK_UPTIME_RAW\n\nclock that increments monotonically, in the same man-\nner as CLOCK_MONOTONIC_RAW, but that does not incre-\nment while the system is asleep.  The returned value\nis identical to the result of mach_absolute_time()\nafter the appropriate mach_timebase conversion is\napplied.\n```\n\nOn Linux, it uses `clock_gettime(CLOCK_MONOTONIC, \u0026ts)` and the `CLOCK_MONOTONIC_COARSE` variant for low/hi-res timers respectively:\n\n```\nCLOCK_MONOTONIC\n\nA nonsettable system-wide clock that represents monotonic time\nsince—as described by POSIX—\"some unspecified point in the\npast\".  On Linux, that point corresponds to the number of sec‐\nonds that the system has been running since it was booted.\n\nThe CLOCK_MONOTONIC clock is not affected by discontinuous\njumps in the system time (e.g., if the system administrator\nmanually changes the clock), but is affected by the incremen‐\ntal adjustments performed by [adjtime(3)](https://man7.org/linux/man-pages/man3/adjtime.3.html) and NTP.  This clock\ndoes not count time that the system is suspended.  All\nCLOCK_MONOTONIC variants guarantee that the time returned by\nconsecutive calls will not go backwards, but successive calls\nmay—depending on the architecture—return identical (not-\nincreased) time values.\n\nCLOCK_MONOTONIC_COARSE (since Linux 2.6.32; Linux-specific)\n\nA faster but less precise version of CLOCK_MONOTONIC.  Use\nwhen you need very fast, but not fine-grained timestamps.\nRequires per-architecture support, and probably also architec‐\nture support for this flag in the [vdso(7)](https://man7.org/linux/man-pages/man7/vdso.7.html).\n```\n\nNote how on both platforms the opposite clock is chosen that should be used to include suspend time (i.e `CLOCK_MONOTONIC_RAW` on macOS and `CLOCK_BOOTTIME` on Linux.\n\n### Reproduction Steps\n\nObserve `Environment.TickCount` and `Environment.TickCount64` not advancing during suspend on Unix-like systems.\n\n### Expected behavior\n\n`Environment.TickCount` and `Environment.TickCount64` counting time in suspend as well on Unix-like systems.\n\n### Actual behavior\n\n`Environment.TickCount` and `Environment.TickCount64` not advancing during suspend on Unix-like systems.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOwoyV0A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc7CiaJR",
                                           "createdAt":  "2025-09-07T14:04:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Related https://github.com/dotnet/runtime/issues/77945",
                                           "updatedAt":  "2025-09-07T14:04:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7CiaPz",
                                           "createdAt":  "2025-09-07T14:04:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-09-07T14:04:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7Ci9Qv",
                                           "createdAt":  "2025-09-07T18:03:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "marzent",
                                           "body":  "Indeed this looks very similar to https://github.com/dotnet/runtime/issues/77945, sorry for overlooking that!\n\nSince there hasn\u0027t been a PR made for that issue I created https://github.com/dotnet/runtime/pull/119443.",
                                           "updatedAt":  "2025-09-07T18:03:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7CjJXQ",
                                           "createdAt":  "2025-09-07T19:33:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-09-07T19:33:53Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "TickCount on macOS/Linux does not include suspend time",
        "labels":  [
                       "area-System.Threading"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/119795",
        "createdAt":  "2025-09-17T03:34:19Z",
        "number":  119795,
        "author":  "srxqds",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-18T03:33:07Z",
        "body":  "hi, We use 9.0.5 tags and cherry-pick this merge request https://github.com/dotnet/runtime/pull/116001 \n\nbut hit below exception:\n```\n[17:57:19.294]   Loader Exception:\nSystem.InvalidOperationException: Handle is not initialized.\n   at System.Runtime.InteropServices.GCHandle.get_Target() in F:\\netease-gitlab\\dotnet\\runtime\\src\\libraries\\System.Private.CoreLib\\src\\System\\Runtime\\InteropServices\\GCHandle.cs:line 86\n   at System.Threading.Overlapped.GetOverlappedFromNative(NativeOverlapped* pNativeOverlapped) in F:\\netease-gitlab\\dotnet\\runtime\\src\\libraries\\System.Private.CoreLib\\src\\System\\Threading\\Overlapped.cs:line 228\n   at System.Threading.IOCompletionCallbackHelper.PerformSingleIOCompletionCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pNativeOverlapped) in F:\\netease-gitlab\\dotnet\\runtime\\src\\libraries\\System.Private.CoreLib\\src\\System\\Threading\\IOCompletionCallbackHelper.cs:line 36\n   at System.Threading.PortableThreadPool.IOCompletionPoller.Callback.Invoke(Event e) in F:\\netease-gitlab\\dotnet\\runtime\\src\\libraries\\System.Private.CoreLib\\src\\System\\Threading\\PortableThreadPool.IO.Windows.cs:line 319\n   at System.Threading.ThreadPoolTypedWorkItemQueue`2[[System.Threading.PortableThreadPool.IOCompletionPoller.Event, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Threading.PortableThreadPool.IOCompletionPoller.Callback, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].System.Threading.IThreadPoolWorkItem.Execute() in F:\\netease-gitlab\\dotnet\\runtime\\src\\libraries\\System.Private.CoreLib\\src\\System\\Threading\\ThreadPoolWorkQueue.cs:line 1395\n   at System.Threading.ThreadPoolWorkQueue.Dispatch() in F:\\netease-gitlab\\dotnet\\runtime\\src\\libraries\\System.Private.CoreLib\\src\\System\\Threading\\ThreadPoolWorkQueue.cs:line 1120\n   at System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart() in F:\\netease-gitlab\\dotnet\\runtime\\src\\libraries\\System.Private.CoreLib\\src\\System\\Threading\\PortableThreadPool.WorkerThread.cs:line 128\n```\n\n@lateralusX  Could you help me check if this change has this effect or maybe a new problem?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOxP_yeg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc7Ew6xQ",
                                           "createdAt":  "2025-09-17T03:35:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-09-17T03:35:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7E0lKK",
                                           "createdAt":  "2025-09-17T09:26:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lateralusX",
                                           "body":  "Hard to say without a repro. What happens here is that NativeOverlapp struct points to something that seems to at least have invalid GC handle and that triggers this exception. The NativeOverlapp structs we expect includes more stuff after the NativeOverlapp struct, like an uint + an array of GC handles, but if some other code queues none managed IO completion requests to this IO completion port, that would lead to issues since that won\u0027t have the expected NativeOverlapp data we expect. The change done in https://github.com/dotnet/runtime/pull/116001 doesn\u0027t affect what\u0027s on the IO completion queues, it just makes sure that a thread that waits using an alterable wait restart the wait if it was alerted and it was not an internal runtime APC or IO completion request. Do you have a repro hitting this issue?",
                                           "updatedAt":  "2025-09-17T09:26:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7E__J6",
                                           "createdAt":  "2025-09-18T01:52:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "srxqds",
                                           "body":  "Can anyone help analyze this issue?",
                                           "updatedAt":  "2025-09-18T01:52:55Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "[Mono] IOCompletionCallbackHelper fails with \"Handle is not initialized.\" error",
        "labels":  [
                       "area-System.Threading",
                       "untriaged",
                       "runtime-mono"
                   ]
    }
]
