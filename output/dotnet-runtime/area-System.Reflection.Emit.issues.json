[
    {
        "url":  "https://github.com/dotnet/runtime/issues/28206",
        "createdAt":  "2018-12-14T00:31:10Z",
        "number":  28206,
        "author":  "KevinRansom",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCIYZIg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "tachyus-ryan",
                                            "createdAt":  "2021-03-10T16:32:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ulrichb",
                                            "createdAt":  "2022-01-03T16:15:42Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2023-09-11T03:56:31Z",
        "body":  "In FSI we use **ILGenerator.MarkSequencePoint** to enable debugging of generated code from the in-memory generated assembly.\r\n\r\nWill this be added back, and will debugging coreclr code enable it to work correctly once it has been?\r\n\r\n// @jkotas, @dsyme, @joshfree, @steveharter \r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOZhwolA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ0NzM5NDIxMg==",
                                           "createdAt":  "2018-12-14T17:26:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "The only active ref emit API port issue I know of is https://github.com/dotnet/corefx/issues/12055",
                                           "updatedAt":  "2018-12-14T17:26:54Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1MjM5Njc1OQ==",
                                           "createdAt":  "2019-01-08T18:10:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "@jkotas this looks like another case of just expose in contract and add tests - do you believe it\u0027s more work than that? Any reason I shouldn\u0027t do this?\r\n\r\nAs we noted elsewhere, there is a lot of Ref.Emit present in S.P.Corelib that is not exposed in contracts, and I believe we planned to make strategic changes only this release.",
                                           "updatedAt":  "2019-01-08T18:10:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1MjQwMzE5NA==",
                                           "createdAt":  "2019-01-08T18:30:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Adding symbol/debugging support for reflection emit is a large (likely months) workitem. This is not a simple expose and add tests. The tests added for this would need to be debugger tests.",
                                           "updatedAt":  "2019-01-08T18:36:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1OTA3MjUyMQ==",
                                           "createdAt":  "2019-01-30T19:17:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "OK. Deferred.",
                                           "updatedAt":  "2019-01-30T19:17:50Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYxMzA3MjU0NQ==",
                                           "createdAt":  "2020-04-13T20:06:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "Linking https://github.com/dotnet/runtime/issues/15704 since that has a discussion on saving IL potentially with debug information.",
                                           "updatedAt":  "2020-04-13T20:06:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY4NTA5MzI4OA==",
                                           "createdAt":  "2020-09-01T19:46:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCAkAZA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "auduchinok",
                                                                               "createdAt":  "2020-09-02T14:23:40Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tachyus-ryan",
                                                                               "createdAt":  "2021-03-10T16:33:02Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "SchlenkR",
                                                                               "createdAt":  "2021-10-31T07:45:04Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "dsyme",
                                           "body":  "Just to say we\u0027re really missing this in F# land, as `dotnet fsi` is not emitting debug symbols.  This affects both debugging of scripts and stack traces\r\n",
                                           "updatedAt":  "2020-09-01T20:05:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc1MzM2MDQ0Mg==",
                                           "createdAt":  "2021-01-01T18:20:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "snuup",
                                           "body":  "F# script debugging, as it is possible with .Net 4.8 is incredible helpful. Such scripts are not just simple bash like admin \"scripts\" but much more the birthplace of very difficult code, where data analysis grows into algorithms. Being able to debug at this stage is an incredible cool feature.\r\n\r\nSee also https://github.com/dotnet/fsharp/issues/5457#issuecomment-753359820 ",
                                           "updatedAt":  "2021-01-01T18:20:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc5NTY3MzI0OA==",
                                           "createdAt":  "2021-03-10T16:15:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jackfoxy",
                                           "body":  "First thing I did after installing VS 16.9.1 was enable Use .NET Core Scripting. It took me a while to discover this disables breakpoints in FSI.",
                                           "updatedAt":  "2021-03-10T16:15:05Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc5NTY4OTI5MQ==",
                                           "createdAt":  "2021-03-10T16:26:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "zyzhu",
                                           "body":  "I second @snuup\u0027s comments about importance of debugging in data analysis scripting. Without this feature, scripting F# in Visual Studio will be a far inferior experience compared to debugging R in RStudio, debugging Python in PyCharm or VSCode, or debugging MATLAB.\r\n\r\nIn addition, it will be a blocking issue for supporting debugging break points in Jupyter Lab through dotnet interactive kernel. https://github.com/dotnet/interactive/issues/320",
                                           "updatedAt":  "2021-03-10T18:10:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5MvPrv",
                                           "createdAt":  "2022-10-21T21:29:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "Keeping for future; once we have [AssemblyBuilder.Save](https://github.com/dotnet/runtime/issues/15704) then we should consider.",
                                           "updatedAt":  "2022-10-21T21:29:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5mHCiU",
                                           "createdAt":  "2023-09-11T03:56:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "smoothdeveloper",
                                           "body":  "Also suffering from no debug in FSI, for exactly same reasons as @snuup. (https://github.com/dotnet/fsharp/issues/15820)",
                                           "updatedAt":  "2023-09-11T03:56:31Z"
                                       }
                                   ],
                         "totalCount":  11
                     },
        "title":  "RefEmit does not have the desktop api MarkSequencePoint",
        "labels":  [
                       "area-System.Reflection.Emit",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/42131",
        "createdAt":  "2020-09-11T17:37:22Z",
        "number":  42131,
        "author":  "stephentoub",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCrT5sw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "eerhardt",
                                            "createdAt":  "2020-09-11T18:57:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "drewnoakes",
                                            "createdAt":  "2020-09-11T21:33:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "huoyaoyuan",
                                            "createdAt":  "2020-09-11T21:48:44Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "reflectronic",
                                            "createdAt":  "2020-09-12T12:58:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "KandariukAO",
                                            "createdAt":  "2020-09-12T13:30:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SeeminglyScience",
                                            "createdAt":  "2021-06-23T18:14:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "steveharter",
                                            "createdAt":  "2022-11-04T18:34:27Z"
                                        }
                                    ],
                          "totalCount":  7
                      },
        "updatedAt":  "2022-11-04T18:35:11Z",
        "body":  "It can be difficult when using dynamic methods to understand exactly what IL was generated, which is important when debugging them. We should consider adding a simple IL debug visualizer on DynamicMethod.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOTblC0g==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5MTI3OTI4Ng==",
                                           "createdAt":  "2020-09-11T19:41:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "eerhardt",
                                           "body":  "cc @drewnoakes - from https://github.com/drewnoakes/il-visualizer",
                                           "updatedAt":  "2020-09-11T19:41:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5MTMwMDQwNQ==",
                                           "createdAt":  "2020-09-11T20:36:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "We have visualizer like this for crossgen2:\r\n\r\nhttps://github.com/dotnet/runtime/blob/master/src/coreclr/src/tools/Common/TypeSystem/IL/MethodILDebugView.cs\r\nhttps://github.com/dotnet/runtime/blob/master/src/coreclr/src/tools/Common/TypeSystem/IL/ILDisassembler.cs",
                                           "updatedAt":  "2020-09-11T20:36:05Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5MTMwMTgyMA==",
                                           "createdAt":  "2020-09-11T20:39:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Great. We can always improve it further, but just using / minimally-adapting that would be a great min bar.",
                                           "updatedAt":  "2020-09-11T20:39:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2MzQzMjg3MQ==",
                                           "createdAt":  "2021-06-17T17:38:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "krwq",
                                           "body":  "cc: @steveharter ",
                                           "updatedAt":  "2021-06-17T17:38:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc439Afh",
                                           "createdAt":  "2021-10-08T15:39:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "Marking up for grabs, as this is a nice self contained project - albeit probably significant work - that we could use eg for debugging the regex engine.\r\n\r\n@jkotas would it need any runtime work? ",
                                           "updatedAt":  "2021-10-08T15:39:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc439Bk2",
                                           "createdAt":  "2021-10-08T15:46:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "This would presumably be a significant project -- @eiriktsarpalis maybe we need a label for that? I guess we have \u0027hard problem\u0027 but it\u0027s not quite right. ",
                                           "updatedAt":  "2021-10-08T15:57:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc439Ceu",
                                           "createdAt":  "2021-10-08T15:51:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOB9mrMQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "danmoseley",
                                                                               "createdAt":  "2021-10-08T15:57:17Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "eiriktsarpalis",
                                                                               "createdAt":  "2021-10-08T16:08:19Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2021-10-08T18:43:52Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "It\u0027s certainly some work, but I don\u0027t think it\u0027d be particularly major, at least not in MVP form.  It\u0027d basically be some form of:\r\n- Incorporating some form of https://github.com/dotnet/runtime/blame/04f70d6fc56a5261b0dcad0e6217fcbf92570aaf/src/coreclr/tools/Common/TypeSystem/IL/MethodILDebugView.cs (and supporting files) into corelib, ideally in a way that shares the code files rather than duplicates it\r\n- Hooking it up to DynamicMethod (which already has 99% of the support required to extract the byte[] for reading) via a DebuggerTypeProxy (I don\u0027t think we have a good way to use DebuggerVisualizers from within netcoreapp)\r\n- Ensuring it gets trimmed away outside of debug application builds",
                                           "updatedAt":  "2021-10-08T15:51:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NuULS",
                                           "createdAt":  "2022-11-04T18:35:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "Although not directly related, [AssemblyBuilder.Save() ](https://github.com/dotnet/runtime/issues/62956)has been used in the past for debugging. We plan on doing something here for 8.0.",
                                           "updatedAt":  "2022-11-04T18:35:11Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Add debug visualizer for dynamic methods",
        "labels":  [
                       "area-System.Reflection.Emit",
                       "help wanted",
                       "hard-problem"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/53922",
        "createdAt":  "2021-06-09T08:47:52Z",
        "number":  53922,
        "author":  "MaximLipnin",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-07-06T02:08:47Z",
        "body":  "| Test suite| Possible reason |\r\n| ------ | ------ |\r\n| Microsoft.Extensions.DependencyInjection.ExternalContainers.Tests| IL2103 |\r\n| System.Diagnostics.FileVersionInfo.Tests | Cannot open NativeLibrary |\r\n| System.Runtime.Loader.DefaultContext.Tests | Fails in AndroidAppBuilder w/ warnings |\r\n| System.ComponentModel.Composition.Tests | System.Reflection.Emit issues |\r\n| System.Runtime.Loader.RefEmitLoadContext.Tests | System.Reflection.Emit issues |\r\n| Microsoft.Extensions.Logging.Generators.Tests | Method not found: intptr SQLitePCL.sqlite3.get_ptr() |\r\n| System.Diagnostics.Debug.Tests | Can\u0027t link |\r\n| System.IO.Pipelines.Tests | Crash |\r\n| System.Linq.Parallel.Tests | Crash |\r\n| System.Memory.Data.Tests | Crash |\r\n| System.Net.Requests.Tests | Crash |\r\n| Microsoft.Extensions.DependencyModel.Tests | PlatformNotSupportedException : Platform doesn\u0027t support interface IProvidePlatformServices|\r\n| FunctionalTests\\Android |  |\r\n\r\n@steveisok ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOMzf3ww==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1ODc2MjgzNQ==",
                                           "createdAt":  "2021-06-10T16:21:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "joperezr",
                                           "body":  "@MaximLipnin can you share info about the platform you are running in so that we can add the right labels here? Seems that this is in Xamarin-Android, is that right?",
                                           "updatedAt":  "2021-06-10T16:21:50Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1OTMwNTkyMw==",
                                           "createdAt":  "2021-06-11T06:19:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBuZ00g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "joperezr",
                                                                               "createdAt":  "2021-06-11T17:16:19Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "MaximLipnin",
                                           "body":  "\u003e @MaximLipnin can you share info about the platform you are running in so that we can add the right labels here? Seems that this is in Xamarin-Android, is that right?\r\n\r\nyeah, it\u0027s about Android AOT, Steve added the right labels.\r\n",
                                           "updatedAt":  "2021-06-11T06:19:24Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[Android][AOT] Bunch of library test suites failures",
        "labels":  [
                       "area-System.Reflection.Emit",
                       "os-android",
                       "trimming-for-aot"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/62234",
        "createdAt":  "2021-12-01T13:50:55Z",
        "number":  62234,
        "author":  "vitek-karas",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-07-24T21:48:35Z",
        "body":  "If the same assembly is loaded twice - once in the Default ALC and second time in the custom ALC, and let\u0027s say that assembly defines a type `BaseType`. Creating two new types derived from the `BaseType` from default and then from custom ALC using `TypeBuilder` from the same dynamic module will return two types which both derive from the same type (the first `BaseType`).\r\n\r\nThis is wrong, since this should basically always return true:\r\n```C#\r\nmoduleBuilder.DefineType(\"TestType\", parentType).CreateType().IsAssignableTo(parentType);\r\n```\r\n\r\nBut in the above case it doesn\u0027t - the second type will return false from this.\r\n\r\nFull repro:\r\nCreate a new console app and paste this code:\r\n```C#\r\nusing System.Reflection;\r\nusing System.Reflection.Emit;\r\nusing System.Runtime.Loader;\r\n\r\nvar typeId = 0;\r\nvar moduleBuilder = AssemblyBuilder\r\n    .DefineDynamicAssembly(new AssemblyName(\"assembly\"), AssemblyBuilderAccess.Run)\r\n    .DefineDynamicModule(\"module\");\r\n\r\nType baseTypeInCustomALC = new AssemblyLoadContext(\"CustomALC\")\r\n    .LoadFromAssemblyPath(typeof(BaseType).Assembly.Location)\r\n    .GetType(typeof(BaseType).FullName!)!;\r\n\r\n// First -----\r\n// This always writes \"true\"\r\nif (args.Length \u003e 0)\r\n{\r\n    Type? firstT = CreateDerivedType(typeof(BaseType));\r\n    Console.WriteLine(\"First: \" + firstT?.IsAssignableTo(typeof(BaseType)));\r\n}\r\nelse\r\n{\r\n    Console.WriteLine(\"First: \u003cskipped\u003e\");\r\n}\r\n\r\n// Second ----\r\n// If the First is executed, this writes \"false\", otherwise it writes \"true\"\r\nType? secondT = CreateDerivedType(baseTypeInCustomALC);\r\nConsole.WriteLine(\"Second: \" + secondT?.IsAssignableTo(baseTypeInCustomALC));\r\n\r\nType? CreateDerivedType(Type parentType)\r\n{\r\n    return moduleBuilder\r\n        .DefineType($\"type{typeId++}\", TypeAttributes.Public, parentType)\r\n        .CreateType();\r\n}\r\n\r\npublic class BaseType\r\n{\r\n}\r\n```\r\n\r\n```console\r\n ❯  dotnet run\r\nFirst: \u003cskipped\u003e\r\nSecond: True\r\n\r\n ❯  dotnet run -- true\r\nFirst: True\r\nSecond: False\r\n```\r\n\r\nThe \"Second\" try returns true/false depending if the \"First\" try was executed or not.\r\n\r\nThis is a tricky problem - under the hood runtime creates basically a normal assembly for every assembly builder. Such assembly has only one way to refer to types from other assemblies - typeref+assemblyref. Both of these specify just simple names. And then these go through normal assembly resolution process - which will effectively cache the first result (this is simplified, the logic to get the type ref is pretty complex and there might be other tricks to it, but it does eventually create a simple assembly ref).\r\n\r\nI don\u0027t think `TypeBuilder` can truly fix this - given the current implementation (where it generates real metadata with tokens and everything), since the underlying IL metadata doesn\u0027t have a way to express two assembly references to two different assemblies of the same exact name.\r\n\r\nThat said `TypeBuilder` should guard against this - ideally it should basically create the type ref, resolve it and validate that it got back the original Type instance - if not, it should fail as otherwise it creates wrong output.\r\n\r\nNote: The \"Workaround\" for this is to use two different dynamic modules (`moduleBuilder`) as those can then have separate assembly refs to different assemblies.\r\n\r\nOriginally found in https://github.com/dotnet/runtime/issues/60468. See https://github.com/dotnet/runtime/issues/60468#issuecomment-975968918 for a more detailed discussion of the original problem.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYkTFGA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5PvcjF",
                                           "createdAt":  "2022-12-05T17:45:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "Marking this as \"help wanted\" for @vitek-karas or others.\r\n\r\nAssuming this is lower-priority as there is a workaround and only known reported issue is related to [DispatchProxy](https://github.com/dotnet/runtime/issues/60468#issuecomment-975968918). ",
                                           "updatedAt":  "2022-12-05T17:45:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iRMUY",
                                           "createdAt":  "2023-07-24T21:48:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "Moving to future; there are no community hits for this issue. If someone wants to pick this up, we can add to the current release.",
                                           "updatedAt":  "2023-07-24T21:48:28Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "TypeBuilder creates a type derived from the wrong base type in presence of multiple ALCs",
        "labels":  [
                       "bug",
                       "area-System.Reflection.Emit",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/63419",
        "createdAt":  "2022-01-05T23:40:58Z",
        "number":  63419,
        "author":  "teo-tsirpanis",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-26T10:39:12Z",
        "body":  "### Background and motivation\n\nThere are APIs in the `System.Reflection.Emit` namespace that accept binary data only as byte arrays, forcing callers to allocate an array of exact size for each time they call them. I propose to add overloads to these methods that accept `ReadOnlySpan\u003cbyte\u003e`, reducing needless allocations.\n\n### API Proposal\n\n```C#\r\nnamespace System.Reflection.Emit\r\n{\r\n    public partial class AssemblyBuilder\r\n    {\r\n        public void SetCustomAttribute(ConstructorInfo con, ReadOnlySpan\u003cbyte\u003e binaryAttribute);\r\n    }\r\n\r\n    public partial class ConstructorBuilder\r\n    {\r\n        public void SetCustomAttribute(ConstructorInfo con, ReadOnlySpan\u003cbyte\u003e binaryAttribute);\r\n    }\r\n\r\n    public partial class DynamicILInfo\r\n    {\r\n        public int GetTokenFor(ReadOnlySpan\u003cbyte\u003e signature);\r\n        public void SetCode(ReadOnlySpan\u003cbyte\u003e code, int maxStackSize);\r\n        public void SetExceptions(ReadOnlySpan\u003cbyte\u003e exceptions);\r\n        public void SetLocalSignature(ReadOnlySpan\u003cbyte\u003e localSignature);\r\n    }\r\n\r\n    public partial class EnumBuilder\r\n    {\r\n        public void SetCustomAttribute(ConstructorInfo con, ReadOnlySpan\u003cbyte\u003e binaryAttribute);\r\n    }\r\n\r\n    public partial class EventBuilder\r\n    {\r\n        public void SetCustomAttribute(ConstructorInfo con, ReadOnlySpan\u003cbyte\u003e binaryAttribute);\r\n    }\r\n\r\n    public partial class FieldBuilder\r\n    {\r\n        public void SetCustomAttribute(ConstructorInfo con, ReadOnlySpan\u003cbyte\u003e binaryAttribute);\r\n    }\r\n\r\n    public partial class GenericTypeParameterBuilder\r\n    {\r\n        public void SetCustomAttribute(ConstructorInfo con, ReadOnlySpan\u003cbyte\u003e binaryAttribute);\r\n    }\r\n\r\n    public partial class MethodBuilder\r\n    {\r\n        public void SetCustomAttribute(ConstructorInfo con, ReadOnlySpan\u003cbyte\u003e binaryAttribute);\r\n    }\r\n\r\n    public partial class ModuleBuilder\r\n    {\r\n        public FieldBuilder DefineInitializedData(string name, ReadOnlySpan\u003cbyte\u003e data, FieldAttributes attributes);\r\n        public void SetCustomAttribute(ConstructorInfo con, ReadOnlySpan\u003cbyte\u003e binaryAttribute);\r\n    }\r\n\r\n    public partial class ParameterBuilder\r\n    {\r\n        public void SetCustomAttribute(ConstructorInfo con, ReadOnlySpan\u003cbyte\u003e binaryAttribute);\r\n    }\r\n\r\n    public partial class PropertyBuilder\r\n    {\r\n        public void SetCustomAttribute(ConstructorInfo con, ReadOnlySpan\u003cbyte\u003e binaryAttribute);\r\n    }\r\n\r\n    public partial class TypeBuilder\r\n    {\r\n        public FieldBuilder DefineInitializedData(string name, ReadOnlySpan\u003cbyte\u003e data, FieldAttributes attributes);\r\n        public void SetCustomAttribute(ConstructorInfo con, ReadOnlySpan\u003cbyte\u003e binaryAttribute);\r\n    }\r\n}\r\n```\r\n\r\nGoing further and adding span overloads for all methods that accept arrays of any type is out of scope and would require changes to the broader Reflection APIs.\n\n### API Usage\n\n```C#\r\nModuleBuilder modBuilder = ...;\r\nvar typeBuilder = modBuilder.DefineType(\"Foo\");\r\n\r\nvar dataField = modBuilder.DefineInitializedData(\"data\", (ReadOnlySpan\u003cbyte\u003e) new byte[] {1, 2, 3, 4}, FieldAttributes.Private | FieldAttributes.InitOnly);\r\n```\r\n\r\n```C#\r\nAssemblyBuilder asmBuilder = ...;\r\nReadOnlySpan\u003cbyte\u003e attributeData = ...;\r\nasm.Builder.SetCustomAttribute(myAttributeConstructor, attributeData);\r\n```\n\n### Alternative Designs\n\nThere is the option not to add the `DynamicILInfo.Set***` span overloads without sacrificing performance; there are already overloads accepting pointers, but callers would have to resort to `unsafe` code for no reason, and pinning spans is not supported in F#.\n\n### Risks\n\nOne would argue how commonly used these APIs are. Maybe they are not worth the effort but their implementations would be simple. As for popularity, upcoming APIs like #60948 provide a compelling use case in dynamic code generators for the spanified `DefineInitializedData` overloads.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHORosPew==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc47-NRt",
                                           "createdAt":  "2022-01-05T23:41:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-01-05T23:41:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc47-P5B",
                                           "createdAt":  "2022-01-06T00:02:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-reflection-emit\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nThere are APIs in the `System.Reflection.Emit` namespace that accept binary data only as byte arrays, forcing callers to allocate an array of exact size for each time they call them. I propose to add overloads to these methods that accept `ReadOnlySpan\u003cbyte\u003e`, reducing needless allocations.\n\n### API Proposal\n\n```C#\r\nnamespace System.Reflection.Emit\r\n{\r\n    public partial class AssemblyBuilder\r\n    {\r\n        public void SetCustomAttribute(ConstructorInfo con, ReadOnlySpan\u003cbyte\u003e binaryAttribute);\r\n    }\r\n\r\n    public partial class ConstructorBuilder\r\n    {\r\n        public void SetCustomAttribute(ConstructorInfo con, ReadOnlySpan\u003cbyte\u003e binaryAttribute);\r\n    }\r\n\r\n    public partial class DynamicILInfo\r\n    {\r\n        public int GetTokenFor(ReadOnlySpan\u003cbyte\u003e signature);\r\n        public void SetCode(ReadOnlySpan\u003cbyte\u003e code, int maxStackSize);\r\n        public void SetExceptions(ReadOnlySpan\u003cbyte\u003e exceptions);\r\n        public void SetLocalSignature(ReadOnlySpan\u003cbyte\u003e localSignature);\r\n    }\r\n\r\n    public partial class EnumBuilder\r\n    {\r\n        public void SetCustomAttribute(ConstructorInfo con, ReadOnlySpan\u003cbyte\u003e binaryAttribute);\r\n    }\r\n\r\n    public partial class EventBuilder\r\n    {\r\n        public void SetCustomAttribute(ConstructorInfo con, ReadOnlySpan\u003cbyte\u003e binaryAttribute);\r\n    }\r\n\r\n    public partial class FieldBuilder\r\n    {\r\n        public void SetCustomAttribute(ConstructorInfo con, ReadOnlySpan\u003cbyte\u003e binaryAttribute);\r\n    }\r\n\r\n    public partial class GenericTypeParameterBuilder\r\n    {\r\n        public void SetCustomAttribute(ConstructorInfo con, ReadOnlySpan\u003cbyte\u003e binaryAttribute);\r\n    }\r\n\r\n    public partial class MethodBuilder\r\n    {\r\n        public void SetCustomAttribute(ConstructorInfo con, ReadOnlySpan\u003cbyte\u003e binaryAttribute);\r\n    }\r\n\r\n    public partial class ModuleBuilder\r\n    {\r\n        public FieldBuilder DefineInitializedData(string name, ReadOnlySpan\u003cbyte\u003e data, FieldAttributes attributes);\r\n        public void SetCustomAttribute(ConstructorInfo con, ReadOnlySpan\u003cbyte\u003e binaryAttribute);\r\n    }\r\n\r\n    public partial class ParameterBuilder\r\n    {\r\n        public void SetCustomAttribute(ConstructorInfo con, ReadOnlySpan\u003cbyte\u003e binaryAttribute);\r\n    }\r\n\r\n    public partial class PropertyBuilder\r\n    {\r\n        public void SetCustomAttribute(ConstructorInfo con, ReadOnlySpan\u003cbyte\u003e binaryAttribute);\r\n    }\r\n\r\n    public partial class TypeBuilder\r\n    {\r\n        public FieldBuilder DefineInitializedData(string name, ReadOnlySpan\u003cbyte\u003e data, FieldAttributes attributes);\r\n        public void SetCustomAttribute(ConstructorInfo con, ReadOnlySpan\u003cbyte\u003e binaryAttribute);\r\n    }\r\n}\r\n```\r\n\r\nGoing further and adding span overloads for all methods that accept arrays of any type is out of scope and would require changes to the broader Reflection APIs.\n\n### API Usage\n\n```C#\r\nModuleBuilder modBuilder = ...;\r\nvar typeBuilder = modBuilder.DefineType(\"Foo\");\r\n\r\nvar dataField = modBuilder.DefineInitializedData(\"data\", (ReadOnlySpan\u003cbyte\u003e) new byte[] {1, 2, 3, 4}, FieldAttributes.Private | FieldAttributes.InitOnly);\r\n```\r\n\r\n```C#\r\nAssemblyBuilder asmBuilder = ...;\r\nReadOnlySpan\u003cbyte\u003e attributeData = ...;\r\nasm.Builder.SetCustomAttribute(myAttributeConstructor, attributeData);\r\n```\n\n### Alternative Designs\n\nThere is the option not to add the `DynamicILInfo.Set***` span overloads without sacrificing performance; there are already overloads accepting pointers, but callers would have to resort to `unsafe` code for no reason, and pinning spans is not supported in F#.\n\n### Risks\n\nOne would argue how commonly used these APIs are. Maybe they are not worth the effort but their implementations would be simple. As for popularity, upcoming APIs like #60948 provide a compelling use case in dynamic code generators for the spanified `DefineInitializedData` overloads.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eteo-tsirpanis\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Reflection.Emit`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-01-06T00:02:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49pHGF",
                                           "createdAt":  "2022-02-09T21:00:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "Thanks for creating this issue; we are continuing to spanify items as necessary.\r\n\r\nTypically, the raw performance of the Emit APIs has not been a concern -- can you explain your priority for this and how its used?\r\n\r\nAlso the underlying implementation of these APIs needs to be changed of course; currently they perform a defensive copy of the passed-in arrays, creating another array. I think the new APIs should not do this, and document that the underlying array (or whatever backs the span) should not change (although that is somewhat obvious by the **ReadOnly**Span).\r\n",
                                           "updatedAt":  "2022-02-09T21:00:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49pLex",
                                           "createdAt":  "2022-02-09T21:23:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "My priority is not high, but I would make use of `DefineInitializedData` if approved.\r\n\r\n\u003e currently [the APIs] perform a defensive copy of the passed-in arrays, creating another array.\r\n\r\nI might be wrong, but my impression is that this happens only for the `DynamicILInfo.Set***` family of methods. The others seem to call a `QCall` that marshals the array into a pointer and passes it to the runtime, without any apparent defensive copies (in managed memory at least, the native part of the runtime would of course make a copy).",
                                           "updatedAt":  "2022-02-09T21:23:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49pb3_",
                                           "createdAt":  "2022-02-09T22:41:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCN7kWQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "teo-tsirpanis",
                                                                               "createdAt":  "2022-02-09T22:43:16Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "steveharter",
                                           "body":  "You\u0027re right, the defensive copy doesn\u0027t apply to all of the methods. My main point here is that we can further optimize these with the PR.\r\n\r\nI\u0027ll keep this feature open and assign to 7.0 for now. It may make sense to do this at the same time as [AssemblyBuilder.Save refactoring](https://github.com/dotnet/runtime/issues/62956). The idea is that these emit calls would instead forward to MetadataWriter instead of QCalls when it\u0027s time to update the metdata\\IL.",
                                           "updatedAt":  "2022-02-09T22:41:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Giw97",
                                           "createdAt":  "2022-07-13T17:58:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "Moving to 8.0.\r\n\r\nWe should embrace Spans more in Reflection including the Emit APIs as originally mentioned. However, another important area that could use Span is the many APIs that return arrays (e.g. `MethodInfo.GetParameters()`) where a defensive copy is made since arrays cannot be made read-only and because we need to prevent cached array elements from being replaced in the array. For these, it is possible to use `ReadOnlySpan` there instead which will improve performance by avoiding the defensive copy.",
                                           "updatedAt":  "2022-07-13T17:58:24Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "[API Proposal]: Embrace spans more in `System.Reflection.Emit`.",
        "labels":  [
                       "api-suggestion",
                       "area-System.Reflection.Emit",
                       "Priority:3"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/64094",
        "createdAt":  "2022-01-21T10:58:35Z",
        "number":  64094,
        "author":  "ryanovic",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC6oTRQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Maksim-Bartoshyk",
                                            "createdAt":  "2022-01-21T14:06:20Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "madelson",
                                            "createdAt":  "2023-01-10T12:01:44Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ForNeVeR",
                                            "createdAt":  "2023-01-10T17:46:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "synastry-nc",
                                            "createdAt":  "2024-08-30T02:56:42Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2025-07-26T10:39:13Z",
        "body":  "### Description\n\n`TypeBuilder` could throw a random exception when multiple instances, that are defined in the same `ModuleBuilder`, are generated in different threads. It seems like a dynamic module itself got corrupted. It happens on a fresh instance only, meaning in the code sample below, increasing a number of iteration doesn\u0027t increase probability of an error, if the root module is not re-initialized at the beginning.\n\n### Reproduction Steps\n\n``` c#\r\nusing System;\r\nusing System.IO;\r\nusing System.Reflection;\r\nusing System.Reflection.Emit;\r\nusing System.Threading.Tasks;\r\n\r\npublic class TestBase\r\n{\r\n    public readonly TextReader reader;\r\n\r\n    public TestBase(TextReader reader)\r\n    {\r\n        this.reader = reader;\r\n    }\r\n}\r\n\r\npublic interface ITest\r\n{\r\n    string Test(int num);\r\n}\r\n\r\npublic class Program\r\n{\r\n    private static object syncroot = new object();\r\n    private const int N = 10;\r\n\r\n    public static void Main()\r\n    {\r\n        try\r\n        {\r\n            for (int step = 0; ; step++)\r\n            {\r\n                var assembly = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName(\"test\" + step.ToString()), AssemblyBuilderAccess.Run);\r\n                var module = assembly.DefineDynamicModule(\"test\" + step++.ToString());\r\n                var types = new Type[N];\r\n\r\n                Console.Write(step.ToString() + \u0027\\r\u0027);\r\n\r\n                Parallel.For(0, N, (i) =\u003e\r\n                {\r\n                    TypeBuilder tb;\r\n\r\n                    lock (syncroot) \r\n                    {\r\n                        tb = module.DefineType(\"test_\" + i.ToString(), TypeAttributes.Public, typeof(TestBase), new[] { typeof(ITest) });\r\n                    }\r\n\r\n                    MethodBuilder mb;\r\n\r\n                    // The following lock sections commented are enough to workaroud the issue.\r\n                    // Basically an error occurs when a new assembly reference is internally added in the assembly builder.\r\n                    // Note, each thread is working with its own TypeBuilder, no shared  context, except the initial DefineType call.\r\n                    \r\n                    //lock (syncroot)\r\n                    {\r\n                        mb = tb.DefineMethod(\"Test\", MethodAttributes.Public | MethodAttributes.Virtual, typeof(string), new[] { typeof(int) });\r\n                    }\r\n\r\n                    var il = mb.GetILGenerator();\r\n                    var label = il.DefineLabel();\r\n\r\n                    for (int j = 0; j \u003c 50; j++)\r\n                    {\r\n                        il.Emit(OpCodes.Ldarg_0);\r\n                        il.Emit(OpCodes.Ldc_I4, j);\r\n                        il.Emit(OpCodes.Bne_Un, label);\r\n\r\n                        il.Emit(OpCodes.Ldstr, j.ToString());\r\n                        il.Emit(OpCodes.Ret);\r\n\r\n                        il.MarkLabel(label);\r\n                        label = il.DefineLabel();\r\n                    }\r\n\r\n                    il.MarkLabel(label);\r\n                    il.Emit(OpCodes.Ldnull);\r\n                    il.Emit(OpCodes.Ret);\r\n\r\n                    ConstructorBuilder cb;\r\n\r\n                    //lock (syncroot)\r\n                    {\r\n                        cb = tb.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, new[] { typeof(TextReader) });\r\n                    }\r\n\r\n                    il = cb.GetILGenerator();\r\n                    il.Emit(OpCodes.Ldarg_0);\r\n                    il.Emit(OpCodes.Ldarg_1);\r\n\r\n                    //lock (syncroot)\r\n                    {\r\n                        il.Emit(OpCodes.Call, typeof(TestBase).GetConstructor(new[] { typeof(TextReader) }));\r\n                    }\r\n\r\n                    il.Emit(OpCodes.Ret);\r\n\r\n                    types[i] = tb.CreateType();\r\n\r\n                });\r\n            }\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            Console.WriteLine(ex.ToString());\r\n        }\r\n    }\r\n}\r\n\r\n```\n\n### Expected behavior\n\nTypeBuilder instances manage their internal shared context in a thread-safe manner.\n\n### Actual behavior\n\nExamples of exception types could be thrown, though, seems, their just indicates a corrupted state : \r\n\r\n_System.BadImageFormatException_: An attempt was made to load a program with an incorrect format. (0x8007000B)\r\n   at System.Reflection.Emit.ModuleBuilder.GetMemberRefOfMethodInfo(QCallModule module, Int32 tr, RuntimeMethodHandleInternal method)\r\n   \r\n_Fatal error. Internal CLR error._ (0x80131506)\r\n   at System.Reflection.Emit.TypeBuilder.DefineType(System.Runtime.CompilerServices.QCallModule, System.String, Int32, System.Reflection.TypeAttributes, Int32, Int32[])\r\n   \r\n_System.TypeLoadException_: The signature is incorrect.\r\n   at System.Reflection.Emit.TypeBuilder.CreateTypeNoLock()\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\nReproduced with .Net Core 3.1, .Net 5, .Net 6\r\nWindows 10, x64 \n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOpaCiew==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc48s5HD",
                                           "createdAt":  "2022-01-21T10:58:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-01-21T10:58:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48tL_k",
                                           "createdAt":  "2022-01-21T12:52:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-reflection-emit\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\n`TypeBuilder` could throw a random exception when multiple instances, that are defined in the same `ModuleBuilder`, are generated in different threads. It seems like a dynamic module itself got corrupted. It happens on a fresh instance only, meaning in the code sample below, increasing a number of iteration doesn\u0027t increase probability of an error, if the root module is not re-initialized at the beginning.\n\n### Reproduction Steps\n\n``` c#\r\nusing System;\r\nusing System.IO;\r\nusing System.Reflection;\r\nusing System.Reflection.Emit;\r\nusing System.Threading.Tasks;\r\n\r\npublic class TestBase\r\n{\r\n    public readonly TextReader reader;\r\n\r\n    public TestBase(TextReader reader)\r\n    {\r\n        this.reader = reader;\r\n    }\r\n}\r\n\r\npublic interface ITest\r\n{\r\n    string Test(int num);\r\n}\r\n\r\npublic class Program\r\n{\r\n    private static object syncroot = new object();\r\n    private const int N = 10;\r\n\r\n    public static void Main()\r\n    {\r\n        try\r\n        {\r\n            for (int step = 0; ; step++)\r\n            {\r\n                var assembly = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName(\"test\" + step.ToString()), AssemblyBuilderAccess.Run);\r\n                var module = assembly.DefineDynamicModule(\"test\" + step++.ToString());\r\n                var types = new Type[N];\r\n\r\n                Console.Write(step.ToString() + \u0027\\r\u0027);\r\n\r\n                Parallel.For(0, N, (i) =\u003e\r\n                {\r\n                    TypeBuilder tb;\r\n\r\n                    lock (syncroot) \r\n                    {\r\n                        tb = module.DefineType(\"test_\" + i.ToString(), TypeAttributes.Public, typeof(TestBase), new[] { typeof(ITest) });\r\n                    }\r\n\r\n                    MethodBuilder mb;\r\n\r\n                    // The following lock sections commented are enough to workaroud the issue.\r\n                    // Basically an error occurs when a new assembly reference is internally added in the assembly builder.\r\n                    // Note, each thread is working with its own TypeBuilder, no shared  context, except the initial DefineType call.\r\n                    \r\n                    //lock (syncroot)\r\n                    {\r\n                        mb = tb.DefineMethod(\"Test\", MethodAttributes.Public | MethodAttributes.Virtual, typeof(string), new[] { typeof(int) });\r\n                    }\r\n\r\n                    var il = mb.GetILGenerator();\r\n                    var label = il.DefineLabel();\r\n\r\n                    for (int j = 0; j \u003c 50; j++)\r\n                    {\r\n                        il.Emit(OpCodes.Ldarg_0);\r\n                        il.Emit(OpCodes.Ldc_I4, j);\r\n                        il.Emit(OpCodes.Bne_Un, label);\r\n\r\n                        il.Emit(OpCodes.Ldstr, j.ToString());\r\n                        il.Emit(OpCodes.Ret);\r\n\r\n                        il.MarkLabel(label);\r\n                        label = il.DefineLabel();\r\n                    }\r\n\r\n                    il.MarkLabel(label);\r\n                    il.Emit(OpCodes.Ldnull);\r\n                    il.Emit(OpCodes.Ret);\r\n\r\n                    ConstructorBuilder cb;\r\n\r\n                    //lock (syncroot)\r\n                    {\r\n                        cb = tb.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, new[] { typeof(TextReader) });\r\n                    }\r\n\r\n                    il = cb.GetILGenerator();\r\n                    il.Emit(OpCodes.Ldarg_0);\r\n                    il.Emit(OpCodes.Ldarg_1);\r\n\r\n                    //lock (syncroot)\r\n                    {\r\n                        il.Emit(OpCodes.Call, typeof(TestBase).GetConstructor(new[] { typeof(TextReader) }));\r\n                    }\r\n\r\n                    il.Emit(OpCodes.Ret);\r\n\r\n                    types[i] = tb.CreateType();\r\n\r\n                });\r\n            }\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            Console.WriteLine(ex.ToString());\r\n        }\r\n    }\r\n}\r\n\r\n```\n\n### Expected behavior\n\nTypeBuilder instances manage their internal shared context in a thread-safe manner.\n\n### Actual behavior\n\nExamples of exception types could be thrown, though, seems, their just indicates a corrupted state : \r\n\r\n_System.BadImageFormatException_: An attempt was made to load a program with an incorrect format. (0x8007000B)\r\n   at System.Reflection.Emit.ModuleBuilder.GetMemberRefOfMethodInfo(QCallModule module, Int32 tr, RuntimeMethodHandleInternal method)\r\n   \r\n_Fatal error. Internal CLR error._ (0x80131506)\r\n   at System.Reflection.Emit.TypeBuilder.DefineType(System.Runtime.CompilerServices.QCallModule, System.String, Int32, System.Reflection.TypeAttributes, Int32, Int32[])\r\n   \r\n_System.TypeLoadException_: The signature is incorrect.\r\n   at System.Reflection.Emit.TypeBuilder.CreateTypeNoLock()\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\nReproduced with .Net Core 3.1, .Net 5, .Net 6\r\nWindows 10, x64 \n\n### Other information\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eryanovic\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Reflection.Emit`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-01-21T12:52:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49Scg-",
                                           "createdAt":  "2022-02-02T18:45:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "I wouldn\u0027t expect the Emit code to be thread-safe, and it is not documented to be. However, was not able to repro the threading issue on .NET Framework 4.7.2, so we do research to see why that is the case (why it doesn\u0027t work on .NET 6, but does on .NET Framework).",
                                           "updatedAt":  "2022-02-02T18:45:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49YdaF",
                                           "createdAt":  "2022-02-04T10:01:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ryanovic",
                                           "body":  "However, this is still confusing because the common module\u0027s metadata is used internally and no thread accesses shared data directly.   ",
                                           "updatedAt":  "2022-02-04T10:01:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4-BXJ-",
                                           "createdAt":  "2022-02-15T17:09:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "It makes sense to assign this to 7.0 for further research or a fix.",
                                           "updatedAt":  "2022-02-15T17:09:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5SFcTO",
                                           "createdAt":  "2023-01-10T12:03:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "madelson",
                                           "body":  "\u003e I wouldn\u0027t expect the Emit code to be thread-safe, and it is not documented to be\r\n\r\nI think it would be helpful if it were thread-safe, because otherwise you can\u0027t lazily instantiate new types into your dynamic assembly as you need them. Not sure if there is something fundamentally invalid about using dynamic types from an assembly at the same time as new ones are being built.",
                                           "updatedAt":  "2023-01-10T12:04:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iRLh3",
                                           "createdAt":  "2023-07-24T21:44:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "Moving to 9; seems important to investigate\\fix.",
                                           "updatedAt":  "2023-07-24T21:44:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6loKJ7",
                                           "createdAt":  "2025-04-04T13:41:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "YerneF",
                                           "body":  "Hey!\n\nI also encountered this issue and tried to reduce to the minimum the size of the program I was using to troubleshoot it (This code crashes around every 4-5 tries):\n\n```F#\nopen System\nopen System.Reflection\nopen System.Reflection.Emit\nopen Microsoft.FSharp.Reflection\nopen System.Xml.Linq\n\ntype TypeA = {\n    id: XElement\n}\n    \ntype IRecordConstructor =\n    abstract member Construct: obj[] -\u003e obj\n\nlet assemblyName = AssemblyName(\"DynamicAssembly\")\nlet assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run)\nlet moduleBuilder = assemblyBuilder.DefineDynamicModule(\"DynamicModule\")\n\nlet buildRecordConstructor (ty: Type) index =\n    async {\n        let ctorInfo = FSharpValue.PreComputeRecordConstructorInfo ty\n\n        let typeName = sprintf \"RecordConstructor_index%i\" index\n        let typeBuilder = moduleBuilder.DefineType(typeName, TypeAttributes.Public)\n        typeBuilder.AddInterfaceImplementation(typeof\u003cIRecordConstructor\u003e)\n\n        let methodBuilder = typeBuilder.DefineMethod(\"Construct\", MethodAttributes.Virtual, typeof\u003cobj\u003e, [|typeof\u003cobj[]\u003e|])\n        let a = (methodBuilder.Module :?\u003e ModuleBuilder).GetMethodMetadataToken(ctorInfo)\n        ()\n    }\n[\u003cEntryPoint\u003e]\nlet main _ =\n    let _ = [ buildRecordConstructor typeof\u003cTypeA\u003e 1; buildRecordConstructor typeof\u003cTypeA\u003e 2 ] |\u003e Async.Parallel |\u003e Async.RunSynchronously |\u003e ignore\n    0\n```\n\n### Additionnal notes\nAt first I was testing with more threads and each thread had a loop to go through the code to try to reproduce the issue. It seemed that if one of the threads didn\u0027t fail the first time it would call GetMethodMetadataToken, the issue seemed to not occur in the following iterations.\n\n\n",
                                           "updatedAt":  "2025-04-04T13:41:56Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Generation of dynamic types with multiple threads using System.Reflection.Emit components causes runtime corruption",
        "labels":  [
                       "enhancement",
                       "area-System.Reflection.Emit",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/75348",
        "createdAt":  "2022-09-09T15:44:38Z",
        "number":  75348,
        "author":  "steveharter",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC2hDMg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ghord",
                                            "createdAt":  "2023-11-12T12:07:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hamarb123",
                                            "createdAt":  "2024-03-14T03:56:04Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2025-07-26T10:39:16Z",
        "body":  "[primarily a placeholder for now for planning]\r\n\r\nThis adds invoke capability to function pointers, layering on See also https://github.com/dotnet/runtime/issues/69273 and https://github.com/dotnet/runtime/issues/75347.\r\n\r\nOverloads will be added to `ILGenerator.EmitCalli()` to support new calling conventions that are modifier-based instead of enum-based. The enum-based calling conventions through `System.Runtime.InteropServices.CallingConvention` have not scaled well thus specifying \"CallConv\" types from the `System.Runtime.InteropServices` is assumed. Currently these include:\r\n- [CallConvCdecl](https://docs.microsoft.com/dotnet/api/system.runtime.compilerservices.callconvcdecl)\r\n- [CallConvStdCall](https://docs.microsoft.com/dotnet/api/system.runtime.compilerservices.callconvstdcall)\r\n- [CallConvThiscall](https://docs.microsoft.com/dotnet/api/system.runtime.compilerservices.callconvthiscall)\r\n- [CallConvFastcall](https://docs.microsoft.com/dotnet/api/system.runtime.compilerservices.callconvfastcall)\r\n- [CallConvSuppressGCTransition](https://docs.microsoft.com/dotnet/api/system.runtime.compilerservices.callconvsuppressgctransition)\r\n- [CallConvMemberFunction](https://docs.microsoft.com/dotnet/api/system.runtime.compilerservices.callconvmemberfunction)\r\n\r\nThe new APIs may likely take a proposed `MethodSignature` class from https://github.com/dotnet/runtime/issues/75347.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOShA1zw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5KCZYT",
                                           "createdAt":  "2022-09-09T15:44:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-reflection\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n[primarily a placeholder for now for planning]\r\n\r\nThis adds invoke capability to function pointers, layering on See also https://github.com/dotnet/runtime/issues/69273 and https://github.com/dotnet/runtime/issues/75347.\r\n\r\nOverloads will be added to `ILGenerator.EmitCalli()` to support new calling conventions that are modifier-based instead of enum-based. The enum-based calling conventions through `System.Runtime.InteropServices.CallingConvention` have not scaled well thus specifying \"CallConv\" types from the `System.Runtime.InteropServices` is assumed. Currently these include:\r\n- [CallConvCdecl](https://docs.microsoft.com/dotnet/api/system.runtime.compilerservices.callconvcdecl)\r\n- [CallConvStdCall](https://docs.microsoft.com/dotnet/api/system.runtime.compilerservices.callconvstdcall)\r\n- [CallConvThiscall](https://docs.microsoft.com/dotnet/api/system.runtime.compilerservices.callconvthiscall)\r\n- [CallConvFastcall](https://docs.microsoft.com/dotnet/api/system.runtime.compilerservices.callconvfastcall)\r\n- [CallConvSuppressGCTransition](https://docs.microsoft.com/dotnet/api/system.runtime.compilerservices.callconvsuppressgctransition)\r\n- [CallConvMemberFunction](https://docs.microsoft.com/dotnet/api/system.runtime.compilerservices.callconvmemberfunction)\r\n\r\nThe new APIs may likely take a proposed `MethodSignature` class from https://github.com/dotnet/runtime/issues/75347.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003esteveharter\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003esteveharter\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-needs-work`, `area-System.Reflection`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e8.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-09-09T15:44:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KEDXP",
                                           "createdAt":  "2022-09-10T00:38:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-reflection-emit\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n[primarily a placeholder for now for planning]\r\n\r\nThis adds invoke capability to function pointers, layering on See also https://github.com/dotnet/runtime/issues/69273 and https://github.com/dotnet/runtime/issues/75347.\r\n\r\nOverloads will be added to `ILGenerator.EmitCalli()` to support new calling conventions that are modifier-based instead of enum-based. The enum-based calling conventions through `System.Runtime.InteropServices.CallingConvention` have not scaled well thus specifying \"CallConv\" types from the `System.Runtime.InteropServices` is assumed. Currently these include:\r\n- [CallConvCdecl](https://docs.microsoft.com/dotnet/api/system.runtime.compilerservices.callconvcdecl)\r\n- [CallConvStdCall](https://docs.microsoft.com/dotnet/api/system.runtime.compilerservices.callconvstdcall)\r\n- [CallConvThiscall](https://docs.microsoft.com/dotnet/api/system.runtime.compilerservices.callconvthiscall)\r\n- [CallConvFastcall](https://docs.microsoft.com/dotnet/api/system.runtime.compilerservices.callconvfastcall)\r\n- [CallConvSuppressGCTransition](https://docs.microsoft.com/dotnet/api/system.runtime.compilerservices.callconvsuppressgctransition)\r\n- [CallConvMemberFunction](https://docs.microsoft.com/dotnet/api/system.runtime.compilerservices.callconvmemberfunction)\r\n\r\nThe new APIs may likely take a proposed `MethodSignature` class from https://github.com/dotnet/runtime/issues/75347.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003esteveharter\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003esteveharter\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-needs-work`, `area-System.Reflection`, `area-System.Reflection.Emit`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e8.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-09-10T00:38:32Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[API Proposal]: IL Emit support for FunctionPointer",
        "labels":  [
                       "api-needs-work",
                       "area-System.Reflection.Emit",
                       "Cost:M"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/91532",
        "createdAt":  "2023-09-04T08:23:20Z",
        "number":  91532,
        "author":  "stakx",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-11-01T20:30:00Z",
        "body":  "### Description\r\n\r\nCertain System.Reflection.Emit (SRE) subclasses of `Type` appear to be missing an implementation for the `Type.IsByRefLike` property. When queried, a `NotSupportedException` (\"Derived classes must provide an implementation\") gets thrown when they should probably just return `false`.\r\n\r\nI\u0027ve so far found two such types that both seem to involve generics: `System.Reflection.Emit.TypeBuilderInstantiation` and `System.Reflection.Emit.SymbolType`.\r\n\r\nCould it be that these two types were overlooked back in https://github.com/dotnet/runtime/pull/34846?\r\n\r\n### Reproduction Steps\r\n\r\nHere is one code example that reproduces the problem for `System.Reflection.Emit.TypeBuilderInstantiation`:\r\n\r\n```csharp\r\nvar assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName(\"A\"), AssemblyBuilderAccess.Run);\r\nvar moduleBuilder = assemblyBuilder.DefineDynamicModule(\"A\");\r\nvar genericTypeBuilder = moduleBuilder.DefineType(\"C\", TypeAttributes.Class);\r\n_ = genericTypeBuilder.DefineGenericParameters(\"T\");\r\nvar closedGenericTypeBuilder = genericTypeBuilder.MakeGenericType(typeof(object));\r\nConsole.WriteLine(closedGenericTypeBuilder.GetType().FullName);\r\nConsole.WriteLine(closedGenericTypeBuilder.IsByRefLike);\r\n```\r\n\r\n(I haven\u0027t yet been able to create a short code repro for `System.Reflection.Emit.SymbolType`, but will add one if I can figure it out.)\r\n\r\n### Expected behavior\r\n\r\nPrints the following to the console:\r\n\r\n```\r\nSystem.Reflection.Emit.TypeBuilderInstantiation\r\nFalse\r\n```\r\n\r\n### Actual behavior\r\n\r\nPrints the following to the console:\r\n\r\n```\r\nSystem.Reflection.Emit.TypeBuilderInstantiation\r\nUnhandled exception. System.NotSupportedException: Derived classes must provide an implementation.\r\n   at System.Type.get_IsByRefLike()\r\n   at Program.Main ...\r\n```\r\n\r\nThe exception is caused by the `IsByRefLike` query in the last line of code.\r\n\r\n### Regression?\r\n\r\nI don\u0027t think this is a regression, since the same error also occurs on older .NET runtimes (e. g. .NET Core 3.1). It appears like this simply hasn\u0027t been implemented yet at all.\r\n\r\n### Known Workarounds\r\n\r\nI don\u0027t know of any workaround short of wrapping `IsByRefLike` queries in an extension method that catches the exception and converts it to `false`, then calling that extension method instead of using `IsByRefLike` directly:\r\n\r\n```csharp\r\nstatic bool IsByRefLikeSafe(this Type type)\r\n{\r\n    try\r\n    {\r\n        return type.IsByRefLike;\r\n    }\r\n    catch (NotSupportedException)\r\n    {\r\n        return false;\r\n    }\r\n}\r\n```\r\n\r\n### Configuration\r\n\r\n* I\u0027ve run the code repro on the following runtimes:\r\n   * .NET Core 3.1\r\n   * .NET 6\r\n   * .NET 7\r\n* OS: Windows 11 Pro (22H2), build 22621.2134\r\n* Architecture: x64\r\n\r\n### Other information\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOaqucHw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5lnZ5o",
                                           "createdAt":  "2023-09-04T08:23:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-reflection-emit\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nCertain System.Reflection.Emit (SRE) subclasses of `Type` appear to be missing an implementation for the `Type.IsByRef` property. When queried, a `NotSupportedException` (\"Derived classes must provide an implementation\") gets thrown when they should probably just return `false`.\r\n\r\nI\u0027ve so far found two such types that both seem to involve generics: `System.Reflection.Emit.TypeBuilderInstantiation` and `System.Reflection.Emit.SymbolType`.\r\n\r\nCould it be that these two types were overlooked back in https://github.com/dotnet/runtime/pull/34846?\n\n### Reproduction Steps\n\nHere is one code example that reproduces the problem for `System.Reflection.Emit.TypeBuilderInstantiation`:\r\n\r\n```csharp\r\nvar assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName(\"A\"), AssemblyBuilderAccess.Run);\r\nvar moduleBuilder = assemblyBuilder.DefineDynamicModule(\"A\");\r\nvar genericTypeBuilder = moduleBuilder.DefineType(\"C\", TypeAttributes.Class);\r\n_ = genericTypeBuilder.DefineGenericParameters(\"T\");\r\nvar closedGenericTypeBuilder = genericTypeBuilder.MakeGenericType(typeof(object));\r\nConsole.WriteLine(closedGenericTypeBuilder.GetType().FullName);\r\nConsole.WriteLine(closedGenericTypeBuilder.IsByRefLike);\r\n```\r\n\r\n(I haven\u0027t yet been able to create a short code repro for `System.Reflection.Emit.SymbolType`, but will add one if I can figure it out.)\n\n### Expected behavior\n\nPrints the following to the console:\r\n\r\n```\r\nSystem.Reflection.Emit.TypeBuilderInstantiation\r\nFalse\r\n```\n\n### Actual behavior\n\nPrints the following to the console:\r\n\r\n```\r\nSystem.Reflection.Emit.TypeBuilderInstantiation\r\nUnhandled exception. System.NotSupportedException: Derived classes must provide an implementation.\r\n   at System.Type.get_IsByRefLike()\r\n   at Program.Main ...\r\n```\r\n\r\nThe exception is caused by the `IsByRefLike` query in the last line of code.\n\n### Regression?\n\nI don\u0027t think this is a regression, since the same error also occurs on older .NET runtimes (e. g. .NET Core 3.1). It appears like this simply hasn\u0027t been implemented yet at all.\n\n### Known Workarounds\n\nI don\u0027t know of any workaround short of wrapping `IsByRefLike` queries in an extension method that catches the exception and converts it to `false`, then calling that extension method instead of using `IsByRefLike` directly:\r\n\r\n```csharp\r\nstatic bool IsByRefLikeSafe(this Type type)\r\n{\r\n    try\r\n    {\r\n        return type.IsByRefLike;\r\n    }\r\n    catch (NotSupportedException)\r\n    {\r\n        return false;\r\n    }\r\n}\r\n```\n\n### Configuration\n\n* I\u0027ve run the code repro on the following runtimes:\r\n   * .NET Core 3.1\r\n   * .NET 6\r\n   * .NET 7\r\n* OS: Windows 11 Pro (22H2), build 22621.2134\r\n* Architecture: x64\n\n### Other information\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003estakx\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Reflection.Emit`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-09-04T08:23:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5nK4H5",
                                           "createdAt":  "2023-09-22T07:00:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karakasa",
                                           "body":  "I went through the codebase and found 4 types not implementing `IsByRefLike`. Should they all return `false`?\r\n\r\n````\r\nSystem.Reflection.Emit.TypeBuilderInstantiation\r\nSystem.Reflection.Emit.SymbolType\r\nSystem.Reflection.Emit.TypeBuilderImpl\r\nSystem.Reflection.Emit.GenericTypeParameterBuilderImpl\r\n````",
                                           "updatedAt":  "2023-09-22T07:00:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5nPBi-",
                                           "createdAt":  "2023-09-22T20:21:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stakx",
                                           "body":  "I strongly suspect that the last one (`GenericTypeParameterBuilderImpl`) at the very least should return `false`, since by-ref-like types may not be used as generic type arguments... if that\u0027s what this class represents.",
                                           "updatedAt":  "2023-09-22T20:21:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5nQYSU",
                                           "createdAt":  "2023-09-23T15:50:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODHm9dQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "stakx",
                                                                               "createdAt":  "2023-09-23T17:12:17Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "\u003e since by-ref-like types may not be used as generic type arguments\r\n\r\nWorth noting that this might change, cc @jaredpar for progress on that",
                                           "updatedAt":  "2023-09-23T15:50:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5nWiQN",
                                           "createdAt":  "2023-09-25T15:31:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODHyvNg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "stakx",
                                                                               "createdAt":  "2023-09-26T06:49:57Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jaredpar",
                                           "body":  "In terms of updates on `ref struct` generic arguments ... for a long time I thought that effectively three features were tied together design wise: `ref struct` generic arguments, `ref struct` implementing interfaces and `ref struct` as `ref` fields. \r\n\r\nDuring the .NET 8 timeframe I was convinced that we can separate the design for `ref struct` as `ref fields`. That\u0027s fortunate because it\u0027s probably the one with the most open questions. Basically design issues where there are presently no good answers. The other two features have some challenges but they\u0027re more in realm of deciding which design is best. If we committed to the feature I\u0027m pretty confident we could ship it in a .NET release. \r\n\r\nSo at this point it\u0027s more a question of where it fits in the priority ranking. ",
                                           "updatedAt":  "2023-09-25T15:31:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5qq5wf",
                                           "createdAt":  "2023-11-01T20:30:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODN4gMw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "karakasa",
                                                                               "createdAt":  "2023-11-29T04:21:13Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "buyaa-n",
                                           "body":  "\u003e I went through the codebase and found 4 types not implementing `IsByRefLike`. Should they all return `false`?\r\n\u003e \r\n\u003e ```\r\n\u003e System.Reflection.Emit.TypeBuilderInstantiation\r\n\u003e System.Reflection.Emit.SymbolType\r\n\u003e System.Reflection.Emit.TypeBuilderImpl\r\n\u003e System.Reflection.Emit.GenericTypeParameterBuilderImpl\r\n\u003e ```\r\n\r\nLooks they should all return false, though I would leave `TypeBuilderImpl` and `GenericTypeParameterBuilderImpl` out of this because they are new types that are not complete (many other unimplemented APIs not only `IsByRefLike`) and not exposed publicly yet ",
                                           "updatedAt":  "2023-11-01T20:30:00Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "Some System.Reflection.Emit implementations of `Type.IsByRefLike` still throw `NotSupportedException`: \"Derived classes must provide an implementation\"",
        "labels":  [
                       "bug",
                       "area-System.Reflection.Emit",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/100020",
        "createdAt":  "2024-03-20T14:55:47Z",
        "number":  100020,
        "author":  "MrJul",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC2ur9g==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "amongonz",
                                            "createdAt":  "2024-03-23T00:25:50Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-08-01T18:09:43Z",
        "body":  "### Description\n\nIt isn\u0027t possible to emit a dynamic assembly using `System.Reflection.Emit` that emits a call to a generic method having a function pointer as an argument. The code fails with a `ArgumentNullException`\n\n### Reproduction Steps\n\n```csharp\r\nusing System;\r\nusing System.Reflection;\r\nusing System.Reflection.Emit;\r\n\r\npublic static class Program\r\n{\r\n    public static void Main()\r\n    {\r\n        var assembly = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName(\"test\"), AssemblyBuilderAccess.Run);\r\n        var module = assembly.DefineDynamicModule(\"test\");\r\n        var type = module.DefineType(\"TestType\", TypeAttributes.Class | TypeAttributes.Public);\r\n        var method = type.DefineMethod(\"TestMethod\", MethodAttributes.Public | MethodAttributes.Static, typeof(void), null);\r\n\r\n        var m1 = typeof(C).GetMethod(\"M1\")!;\r\n        var m2 = typeof(C).GetMethod(\"M2\")!;\r\n\r\n        // void TestMethod() =\u003e C.M1\u003cstring\u003e(\u0026C.M2);\r\n        var il = method.GetILGenerator();\r\n        il.Emit(OpCodes.Ldftn, m2);\r\n        il.EmitCall(OpCodes.Call, m1.MakeGenericMethod(typeof(string)), null);\r\n        il.Emit(OpCodes.Ret);\r\n\r\n        var runtimeType = type.CreateType();\r\n        var runtimeMethod = runtimeType.GetMethod(\"TestMethod\")!;\r\n        runtimeMethod.Invoke(null, null);\r\n    }\r\n}\r\n\r\npublic static class C\r\n{\r\n    public static unsafe void M1\u003cT\u003e(delegate*\u003cvoid\u003e action) =\u003e action();\r\n    public static void M2() =\u003e Console.WriteLine(\"Called\");\r\n}\r\n```\r\n\r\nThis program emits a method equivalent to the following C# code:\r\n```csharp\r\nvoid TestMethod() =\u003e C.M1\u003cstring\u003e(\u0026C.M2);\r\n```\r\n\n\n### Expected behavior\n\nThe method is correctly emitted and runs.\n\n### Actual behavior\n\nThe `EmitCall()` fails with a `ArgumentNullException`.\r\n\r\nStack trace:\r\n```\r\nSystem.ArgumentNullException: String reference not set to an instance of a String.\r\n   at System.Reflection.Emit.RuntimeModuleBuilder.GetTypeRefNested(Type type, Module refedModule)\r\n   at System.Reflection.Emit.RuntimeModuleBuilder.GetTypeTokenWorkerNoLock(Type type, Boolean getGenericDefinition)\r\n   at System.Reflection.Emit.RuntimeModuleBuilder.GetTypeTokenInternal(Type type, Boolean getGenericDefinition)\r\n   at System.Reflection.Emit.SignatureHelper.AddOneArgTypeHelperWorker(Type clsArgument, Boolean lastWasGenericInst)\r\n   at System.Reflection.Emit.SignatureHelper.AddArguments(Type[] arguments, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers)\r\n   at System.Reflection.Emit.SignatureHelper.GetMethodSigHelper(Module scope, CallingConventions callingConvention, Int32 cGenericParam, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers)\r\n   at System.Reflection.Emit.RuntimeModuleBuilder.GetMemberRefSignature(MethodBase method, Int32 cGenericParameters)\r\n   at System.Reflection.Emit.RuntimeModuleBuilder.GetMemberRefToken(MethodBase method, Type[] optionalParameterTypes)\r\n   at System.Reflection.Emit.RuntimeModuleBuilder.GetMethodTokenInternal(MethodBase method, Type[] optionalParameterTypes, Boolean useMethodDef)\r\n   at System.Reflection.Emit.RuntimeILGenerator.EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes)\r\n   at Program.Main() in C:\\Dev\\EmitCallGenericFuncPtrArgBug\\Program.cs:line 20\r\n```\n\n### Regression?\n\nTechnically in .NET 7 the emit phase works, which now fails in .NET 8.\r\n\r\nThat doesn\u0027t really matter since the emitted code can\u0027t run in .NET 7: it searches for a `C.M1(IntPtr)` overload, which doesn\u0027t exist.\n\n### Known Workarounds\n\nUsing `IntPtr` instead of a function pointer parameter works.\n\n### Configuration\n\n.NET 8.0.2\r\nWindows 11 22631.3296\r\nx64\n\n### Other information\n\nRemarks:\r\n - This works if the called method isn\u0027t generic.\r\n - This works with a `DynamicMethod` instead of a dynamic assembly.\r\n\r\nThe `GetTypeRefNested` method probably isn\u0027t meant to be called for function pointers, as it seems to be assuming that a proper type (not a function pointer) was passed, here:\r\n\r\nhttps://github.com/dotnet/runtime/blob/ffe7e26ccc29f5ca1737dd7d84fa98b1b7c10d5f/src/coreclr/System.Private.CoreLib/src/System/Reflection/Emit/RuntimeModuleBuilder.cs#L208\r\n\r\n`FullName` is `null` for a function pointer, causing the `GetTypeRef` to fail:\r\nhttps://github.com/dotnet/runtime/blob/ffe7e26ccc29f5ca1737dd7d84fa98b1b7c10d5f/src/coreclr/vm/commodule.cpp#L42",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOh2tIFw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc53yqs1",
                                           "createdAt":  "2024-03-20T14:56:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-reflection-emit\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-03-20T14:56:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6HDgcp",
                                           "createdAt":  "2024-08-02T17:29:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "The method\r\n```\r\npublic static unsafe void M1\u003cT\u003e(delegate*\u003cvoid\u003e action) =\u003e action();\r\n```\r\nuses an unnecessary generic.\r\n\r\nChanging that to\r\n```\r\npublic static unsafe void M1(delegate*\u003cvoid\u003e action) =\u003e action();\r\n```\r\nand\r\n```\r\nil.EmitCall(OpCodes.Call, m1.MakeGenericMethod(typeof(string)), null);\r\n```\r\nto\r\n```\r\nil.EmitCall(OpCodes.Call, m1, null);\r\n```\r\n\r\nworks for me.",
                                           "updatedAt":  "2024-08-02T17:29:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6HDmdm",
                                           "createdAt":  "2024-08-02T17:47:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODsnSpQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "DaZombieKiller",
                                                                               "createdAt":  "2024-08-02T17:49:18Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "@steveharter, I think the principle here is that the code should work regardless of the generic being unnecessary.\r\n\r\nA more complex example that uses the generic could be created and the same issue would still exist, that the API cannot be called.\r\n\r\nConsider for example:\r\n```csharp\r\npublic static unsafe T M1\u003cT\u003e(delegate*\u003cT\u003e func) =\u003e func();\r\n```",
                                           "updatedAt":  "2024-08-02T17:47:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6HazwG",
                                           "createdAt":  "2024-08-06T19:02:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "This is indeed an issue, but moving to v10.\r\n\r\nThe workaround is to use `IntPtr` instead of the strongly-typed function pointer:\r\n```\r\n    public static unsafe void M1\u003cT\u003e(IntPtr action) =\u003e ((delegate*\u003cvoid\u003e)action)();\r\n```\r\n\r\nThe issue is the code in `SignatureHelper.AddOneArgTypeHelperWorker`  doesn\u0027t know how to add a signature, only type tokens and a function pointer needs to be a signature every time it is used (there is no token).  My WIP for this is at https://github.com/steveharter/runtime/tree/Issue100020. Somewhat unrelated, that branch also adds support for `Ldftn+Call` since we now can obtain the return type and parameter types from a function pointer, although we need to verify we want to support that. Normally, one would use `Ldftn+CallI` where `il.EmitCallI()` requires the signature be specified instead of obtaining from a `MethodInfo`.\r\n\r\n",
                                           "updatedAt":  "2024-08-06T19:02:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Ha0gX",
                                           "createdAt":  "2024-08-06T19:04:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "See also https://github.com/dotnet/runtime/issues/75348 for other remaining function pointer work around Invoke.",
                                           "updatedAt":  "2024-08-06T19:04:03Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "System.Reflection.Emit can\u0027t call a generic method having a function pointer parameter",
        "labels":  [
                       "bug",
                       "area-System.Reflection.Emit"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/101322",
        "createdAt":  "2024-04-20T00:39:57Z",
        "number":  101322,
        "author":  "masonwheeler",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-04-24T18:31:15Z",
        "body":  "### Description\n\nSub-issue of https://github.com/dotnet/runtime/issues/101298.\r\n\r\nThere is an error in this code, but the error message that gets raised in response does nothing to help with debugging the problem.  (Also, the error that exists arguably shouldn\u0027t be an error, but that\u0027s a whole other issue.)\n\n### Reproduction Steps\n\n```\r\nusing System.Reflection.Emit;\r\nusing System.Reflection;\r\n\r\nnamespace NestedTypeError\r\n{\r\n\tinternal class Program\r\n\t{\r\n\t\tstatic void Main(string[] args)\r\n\t\t{\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tvar type = BuildType();\r\n\t\t\t\tvar method = type.GetMethod(\"Invalid\")!;\r\n\t\t\t\tvar result = method.Invoke(null, []);\r\n\t\t\t\tConsole.WriteLine(result);\r\n\t\t\t}\r\n\t\t\tcatch (Exception ex)\r\n\t\t\t{\r\n\t\t\t\tConsole.WriteLine(ex.ToString());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tprivate static Type BuildType()\r\n\t\t{\r\n\t\t\tAssemblyBuilder assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(new(\"MyAssembly\"), AssemblyBuilderAccess.RunAndCollect);\r\n\t\t\tModuleBuilder moduleBuilder = assemblyBuilder.DefineDynamicModule(\"MyAssembly\");\r\n\t\t\tvar typeBuilder = moduleBuilder.DefineType(\"MyType\", TypeAttributes.Public, typeof(ValueType));\r\n\r\n\t\t\tvar nestedTypeBuilder = typeBuilder.DefineNestedType(\"InnerType\", TypeAttributes.NestedPrivate);\r\n\t\t\tvar ctor = nestedTypeBuilder.DefineDefaultConstructor(MethodAttributes.Public);\r\n\r\n\t\t\tvar value = nestedTypeBuilder.DefineMethod(\"Value\", MethodAttributes.Public, typeof(int), []);\r\n\t\t\tvar gen = value.GetILGenerator();\r\n\t\t\tgen.Emit(OpCodes.Ldc_I4_1);\r\n\t\t\tgen.Emit(OpCodes.Ret);\r\n\t\t\t//nestedTypeBuilder.CreateType();\r\n\r\n\t\t\tvar invalid = typeBuilder.DefineMethod(\"Invalid\", MethodAttributes.Public | MethodAttributes.Static, typeof(int), []);\r\n\t\t\tvar il = invalid.GetILGenerator();\r\n\t\t\til.Emit(OpCodes.Newobj, ctor);\r\n\t\t\til.Emit(OpCodes.Callvirt, value);\r\n\t\t\til.Emit(OpCodes.Ret);\r\n\r\n\t\t\treturn typeBuilder.CreateType();\r\n\t\t}\r\n\t}\r\n}\r\n```\n\n### Expected behavior\n\nThis will error out on the call to method.Invoke. A useful error message giving some clue as to the nature of the problem that would meaningfully aid in debugging it is expected.\n\n### Actual behavior\n\n```\r\nSystem.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation.\r\n ---\u003e System.TypeLoadException: Could not load type \u0027InnerType\u0027 from assembly \u0027MyAssembly, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\u0027.\r\n   at MyType.Invalid()\r\n   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)\r\n   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)\r\n   --- End of inner exception stack trace ---\r\n   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)\r\n   at System.Reflection.MethodBase.Invoke(Object obj, Object[] parameters)\r\n   at NestedTypeError.Program.Main(String[] args) in C:\\Users\\mason\\source\\repos\\Repro2\\NestedTypeError\\NteProgram.cs:line 14\r\n```\r\n\r\nSo the type `InnerType` cannot be loaded.  OK.  Why?  What\u0027s wrong with it?  In some cases, `TypeLoadExeption` gives a meaningful error message, but in this case, and several others I\u0027ve run across, it does not.\r\n\r\nThe error here is that `nestedTypeBuilder.CreateType()` was never called.  The error message really should reflect that.\r\n\r\n(Also, should that even be necessary for a nested type?  I can see decent arguments on both sides, but to me the .NET philosophy of \"the pit of success\" feels like the strongest argument.  When I call `typeBuilder.CreateType()`, I intuitively expect it to create *the entire type,* with all of its declared members.  Having it create \"everything except for the nested types\" feels inconsistent.)\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n.NET Core 8, Windows 10, x64.\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOezqkDg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc57OqQO",
                                           "createdAt":  "2024-04-20T00:40:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-reflection-emit\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-04-20T00:40:16Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Unhelpful error message for missing TypeBuilder.CreateType() call",
        "labels":  [
                       "area-System.Reflection.Emit",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/101343",
        "createdAt":  "2024-04-20T21:47:14Z",
        "number":  101343,
        "author":  "ceresgalax",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-26T20:25:23Z",
        "body":  "### Description\r\n\r\nWhen `GetCustomAttributes\u003cT\u003e()` is called on a type defined in a dynamic assembly created with AssemblyBuilder which has a custom attribute referencing another type in the dynamic assembly, a System.IO.FileNotFoundException exception is thrown.\r\n\r\nAlso note that when adding a Resolve callback to the AppDomain or ApplicationLoadContext and returning the AssemblyBuilder that contains the dynamic assembly, an exception will be thrown: `System.InvalidOperationException: Dynamically emitted assemblies are unsupported during host-based resolution.`, so this is not a possible workaround.\r\n\r\n### Reproduction Steps\r\n\r\n```c#\r\nusing System.Reflection;\r\nusing System.Reflection.Emit;\r\n\r\nnamespace ReproDAGetCustomAttributes;\r\n\r\n[AttributeUsage(AttributeTargets.Class)]\r\npublic class MyCustomAttribute(Type type) : Attribute\r\n{\r\n    private readonly Type _type = type;\r\n}\r\n\r\npublic static class Entry\r\n{\r\n    public static void Main()\r\n    {\r\n        AssemblyName an = new(\"MyDnamicAssembly\");\r\n        AssemblyBuilder ab = AssemblyBuilder.DefineDynamicAssembly(an, AssemblyBuilderAccess.RunAndCollect);\r\n        ModuleBuilder mb = ab.DefineDynamicModule(an.Name!);\r\n        \r\n        TypeBuilder typeABuilder = mb.DefineType(\"TypeA\", TypeAttributes.Class | TypeAttributes.Public);\r\n        Type typeA = typeABuilder.CreateType();\r\n\r\n        TypeBuilder typeBBuilder = mb.DefineType(\"TypeB\", TypeAttributes.Class | TypeAttributes.Public);\r\n        CustomAttributeBuilder cab = new(typeof(MyCustomAttribute).GetConstructor([typeof(Type)])!, [typeA]);\r\n        typeBBuilder.SetCustomAttribute(cab);\r\n        Type typeB = typeBBuilder.CreateType();\r\n        \r\n        typeB.GetCustomAttributes\u003cMyCustomAttribute\u003e(); // Throws exception\r\n    }\r\n}\r\n```\r\n\r\n### Expected behavior\r\n\r\n`typeB.GetCustomAttributes` should not throw an exception, and should return an instance of `MyCustomAttribute` constructed with the type of TypeA from the dynamic assembly.\r\n\r\n### Actual behavior\r\n\r\nAn exception is thrown when attempting to get the custom attributes of TypeB:\r\n```\r\nSystem.IO.FileNotFoundException: Could not load file or assembly \u0027MyDnamicAssembly, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\u0027. The system cannot find the file specified.\r\nFile name: \u0027MyDnamicAssembly, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\u0027\r\n   at System.Reflection.RuntimeAssembly.InternalLoad(AssemblyName assemblyName, StackCrawlMark\u0026 stackMark, AssemblyLoadContext assemblyLoadContext, RuntimeAssembly requestingAssembly, Boolean throwOnFileNotFound)\r\n   at System.Reflection.TypeNameParser.ResolveAssembly(String assemblyName)\r\n   at System.Reflection.TypeNameParser.GetType(String typeName, ReadOnlySpan`1 nestedTypeNames, String assemblyNameIfAny)\r\n   at System.Reflection.TypeNameParser.Parse()\r\n   at System.Reflection.TypeNameParser.GetTypeHelper(Char* pTypeName, RuntimeAssembly requestingAssembly, Boolean throwOnError, Boolean requireAssemblyQualifiedName)\r\n   at System.Reflection.CustomAttribute._CreateCaObject(RuntimeModule pModule, RuntimeType type, IRuntimeMethodInfo pCtor, Byte** ppBlob, Byte* pEndBlob, Int32* pcNamedArgs)\r\n   at System.Reflection.CustomAttribute.AddCustomAttributes(ListBuilder`1\u0026 attributes, RuntimeModule decoratedModule, Int32 decoratedMetadataToken, RuntimeType attributeFilterType, Boolean mustBeInheritable, ListBuilder`1 derivedAttributes)\r\n   at System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeType type, RuntimeType caType, Boolean inherit)\r\n   at System.Attribute.GetCustomAttributes(MemberInfo element, Type attributeType, Boolean inherit)\r\n   at System.Reflection.CustomAttributeExtensions.GetCustomAttributes[T](MemberInfo element)\r\n   at ReproDAGetCustomAttributes.Entry.Main()\r\n```\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\nTested with .NET 8.0.0, \u0026 8.0.1\r\nWindows 10 (x64) \u0026 macOS 14.3.1 (23D60) (ARM64)\r\n\r\n### Other information\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOhlEOtA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc57QeFH",
                                           "createdAt":  "2024-04-21T05:43:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-reflection-emit\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-04-21T05:43:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57tu7l",
                                           "createdAt":  "2024-04-24T18:34:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "buyaa-n",
                                           "body":  "Closing as duplicate of https://github.com/dotnet/runtime/issues/95829\r\n\r\nThe solution is discussed on the issue, look https://github.com/dotnet/runtime/issues/95829#issuecomment-1947072758 for example.",
                                           "updatedAt":  "2024-04-24T18:34:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57xhTe",
                                           "createdAt":  "2024-04-25T07:48:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ceresgalax",
                                           "body":  "Thank you for directing me to that issue.\r\n\r\nUnfortunately, using `AppDomain.CurrentDomain.AssemblyResolve` is not a solution for me, since I am defining my dynamic assembly into a collectible AssemblyLoadContext. Here is an example:\r\n```c#\r\nAssemblyLoadContext alc = new AssemblyLoadContext(name: null, isCollectible: true);\r\nAssemblyBuilder ab;\r\nType typeB;\r\n\r\nusing (_currentAssemblyLoadContext.EnterContextualReflection()) \r\n{\r\n    AssemblyName an = new(\"MyDnamicAssembly\");\r\n    ab = AssemblyBuilder.DefineDynamicAssembly(an, AssemblyBuilderAccess.RunAndCollect);\r\n    ModuleBuilder mb = ab.DefineDynamicModule(an.Name!);\r\n        \r\n    TypeBuilder typeABuilder = mb.DefineType(\"TypeA\", TypeAttributes.Class | TypeAttributes.Public);\r\n    Type typeA = typeABuilder.CreateType();\r\n\r\n    TypeBuilder typeBBuilder = mb.DefineType(\"TypeB\", TypeAttributes.Class | TypeAttributes.Public);\r\n    CustomAttributeBuilder cab = new(typeof(MyCustomAttribute).GetConstructor([typeof(Type)])!, [typeA]);\r\n    typeBBuilder.SetCustomAttribute(cab);\r\n    typeB = typeBBuilder.CreateType();\r\n}\r\n\r\nAppDomain.CurrentDomain.AssemblyResolve += (sender, args) =\u003e \r\n{\r\n    return args.Name == ab.FullName ? ab : null;\r\n};\r\n\r\ntypeB.GetCustomAttributes\u003cMyCustomAttribute\u003e(); // Throws exception\r\n```\r\n\r\nIn this example, the exception thrown is:\r\n```System.NotSupportedException: Resolving to a collectible assembly is not supported.```\r\n\r\nI am using a collectible AssemblyLoadContext so that I can re-create this dynamic assembly during runtime and unload the prior dynamic assembly after a new one is created.\r\n\r\nI\u0027d expect GetCustomAttributes to be able to use `AssemblyLoadContext.CurrentContextualReflectionContext` to find the dynamic assembly. I\u0027m not aware of any workarounds for this.",
                                           "updatedAt":  "2024-04-25T07:48:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc572Jgr",
                                           "createdAt":  "2024-04-25T17:23:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "This looks like a bug to me that we should fix. It should just work, without any workarounds.",
                                           "updatedAt":  "2024-04-25T17:23:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc58iwMS",
                                           "createdAt":  "2024-05-02T03:55:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "buyaa-n",
                                           "body":  "\u003e Unfortunately, using AppDomain.CurrentDomain.AssemblyResolve is not a solution for me, since I am defining my dynamic assembly into a collectible AssemblyLoadContext. Here is an example:\r\n\r\nAh, thank you for the example, debugging the sample code shows that RuntimeAssemblyBuilder loads the correct (`CurrentContextualReflectionContext`). I suspect the issue in the `AssemblyLoader` not in reflection emit\r\n\r\nhttps://github.com/dotnet/runtime/blob/71f8fb65a5a28018901823c19de57fe9451ab3b1/src/coreclr/System.Private.CoreLib/src/System/Reflection/Emit/RuntimeAssemblyBuilder.cs#L57-L58\r\n\r\n@elinor-fung could you take a look and change the area if needed?",
                                           "updatedAt":  "2024-05-02T03:55:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc58pEqi",
                                           "createdAt":  "2024-05-02T17:38:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "elinor-fung",
                                           "body":  "The underlying reason here is that `AssemblyBuilder.DefineDynamicAssembly` does not add the dynamic assembly to the ALC\u0027s cache of loaded assemblies that gets used when resolving assemblies by name. I don\u0027t think we\u0027d want to start adding them to the cache, since anyone could emit a dynamic assembly (or multiple even with the same name) - that could break any resolution for a different assembly that happens to have the same name.",
                                           "updatedAt":  "2024-05-02T17:38:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc58pPG6",
                                           "createdAt":  "2024-05-02T18:01:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "elinor-fung",
                                           "body":  "I\u0027m actually not entirely sure why `AssemblyLoadContext.Resolving` blocks returning dynamic assemblies (seems to be that way since coreclr existed) - @jkotas do you happen to know?\r\n\r\nOne reason I see would be the caching. The only thing I could think of would be to try to relax that if possible and internally avoid what that block is guarding against - like making sure dynamic assemblies returned don\u0027t get added to the cache, other things?",
                                           "updatedAt":  "2024-05-02T18:01:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc58pUIs",
                                           "createdAt":  "2024-05-02T18:13:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e I don\u0027t think we\u0027d want to start adding them to the cache, since anyone could emit a dynamic assembly (or multiple even with the same name) - that could break any resolution for a different assembly that happens to have the same name.\r\n\r\nI agree. On the other hand, it is very unexpected that assembly self-reference via type reference in a custom attribute does not work.\r\n\r\nThe cleanest would be to give each dynamic assembly its own ALC. What would break if we have done that?\r\n\r\n\u003e why AssemblyLoadContext.Resolving blocks returning dynamic assemblies (seems to be that way since coreclr existed) - @jkotas do you happen to know?\r\n\r\nI do not know. My guess that there was some problem with caching or lifetime tracking as you have said. ",
                                           "updatedAt":  "2024-05-02T18:13:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc58pWrj",
                                           "createdAt":  "2024-05-02T18:19:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e workarounds \r\n\r\nOn .NET 9, you can use `PersistedAssemblyBuilder`, save it into a MemoryStream, and load the MemoryStream into any assembly load context you want. It will avoid the odd corner cases in handling of dynamic assemblies in the runtime. ",
                                           "updatedAt":  "2024-05-02T18:19:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc58qYpG",
                                           "createdAt":  "2024-05-02T20:19:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "elinor-fung",
                                           "body":  "\u003e The cleanest would be to give each dynamic assembly its own ALC. What would break if we have done that?\r\n\r\nI imagine dependencies on other ALCs would have problems or confusing behaviour. Currently, `AssemblyLoadContext.EnterContextualReflection()` gets the assembly for `AssemblyBuilder.DefineDynamicAssembly` to be associated with / resolve dependencies against a specific ALC. If dynamic assemblies are always loaded into their own ALC, it would effectively stop respecting that contextual setting and potentially lead to similar confusion as what exists around `Assembly.LoadFile` always loading into a new ALC.",
                                           "updatedAt":  "2024-05-02T20:19:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc58wvE1",
                                           "createdAt":  "2024-05-03T14:35:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "We should be able to respect the contextual setting in the dedicated ALC. The Load method of the dedicated ALC can forward to the contextual `assemblyLoadContext` from `DefineDynamicAssembly`.",
                                           "updatedAt":  "2024-05-03T14:35:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc59QgLA",
                                           "createdAt":  "2024-05-08T21:09:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "Is this an accurate summary?\r\n- This is a bug and should be fixed without a workaround\r\n- Jan suggests that each AssemblyBuilder should have its own ALC (pending whether or not this breaks stuff too badly)\r\n- An ALC should be able to have a dependency on another ALC with shared types (supported today)\r\n- ~The user still needs to call ALC.EnterContextualReflection (is this correct?)~\r\n  - ~Fix \"System.NotSupportedException: Resolving to a collectible assembly is not supported.\"~\r\n- A potential workaround is to leverage the 9.0 AssemblyBuilder.Save feature.",
                                           "updatedAt":  "2024-05-08T23:20:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc59RKla",
                                           "createdAt":  "2024-05-08T23:20:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e The user still needs to call ALC.EnterContextualReflection (is this correct?)\r\n\r\nThis is not correct - I have edited your comment. I agree with the rest.",
                                           "updatedAt":  "2024-05-08T23:20:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GTsvS",
                                           "createdAt":  "2024-07-26T19:01:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "buyaa-n",
                                           "body":  "@elinor-fung is this still planned to be fixed in 9.0?",
                                           "updatedAt":  "2024-07-26T19:01:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GUOhE",
                                           "createdAt":  "2024-07-26T20:17:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODrwr5g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "buyaa-n",
                                                                               "createdAt":  "2024-07-26T20:24:51Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "elinor-fung",
                                           "body":  "I am not working on this. I don\u0027t believe anyone else is/has either.\r\n\r\nAlso note that giving each `AssemblyBuilder` its own ALC, assuming it doesn\u0027t break common scenarios, would still be an observable change (for example, it would still be seen in the API for getting the assembly\u0027s ALC), so I think it would fall under a breaking change.",
                                           "updatedAt":  "2024-07-26T20:17:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GUQ60",
                                           "createdAt":  "2024-07-26T20:25:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "buyaa-n",
                                           "body":  "OK, moving to future for now",
                                           "updatedAt":  "2024-07-26T20:25:17Z"
                                       }
                                   ],
                         "totalCount":  16
                     },
        "title":  "GetCustomAttributes throws Exception when attribute contains a type defined in a dynamic assembly.",
        "labels":  [
                       "area-System.Reflection.Emit"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/109398",
        "createdAt":  "2024-10-31T02:41:22Z",
        "number":  109398,
        "author":  "mconnew",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODRsuEQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "HongGit",
                                            "createdAt":  "2024-11-14T19:37:18Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mcortellino",
                                            "createdAt":  "2024-11-15T08:22:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "owenneil",
                                            "createdAt":  "2025-08-20T22:00:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "tehcrashxor",
                                            "createdAt":  "2025-08-21T18:36:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "joem-msft",
                                            "createdAt":  "2025-09-18T18:48:05Z"
                                        }
                                    ],
                          "totalCount":  5
                      },
        "updatedAt":  "2024-11-04T17:39:42Z",
        "body":  "### Description\n\nWhen an assembly loaded into a custom AssemblyLoadContext creates a proxy using DispatchProxy for an interface from an assembly loaded into that AssemblyLoadContext, the first custom ALC works fine. If you create a second custom AssemblyLoadContext and load the same assembly and try to create a proxy for the same interface, but for the interface type loaded into the second ALC, the returned proxy incorrectly implements the interface from the first ALC.  \nThis is an issue when the DispatchProxy proxyType is from the Default ALC (or at least not the same ALC as the interface being proxied). \n\n### Reproduction Steps\n\nI created a solution here which demonstrates the problem:  \nhttps://github.com/mconnew/IssueRepros/tree/main/DispatchProxyWithAlc\n\n### Expected behavior\n\nThe second custom ALC instance should create the proxy implementing the interface loaded into the second ALC instance.\n\n### Actual behavior\n\nThe second custom ALC instance creates the proxy implementing the interface that\u0027s loaded into the first ALC instance.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nExplicitly load the assembly which contains the proxyType into the ALC that contains the interface being proxied. The repro app purposefully puts the proxyType implementation into a third assembly to mimic the typical WCF scenario where the WCF client libraries are usually used from the default ALC and not explicitly loaded.\n\n### Configuration\n\n.NET 8\nWindows 11, x64\nNot specific to configuration, this had been reported by multiple users.\n\n### Other information\n\nThis is affecting WCF scenarios. This issue has been reported occurring with Azure Functions (via Microsoft support) and PowerPlatform Dataverse. [Here\u0027s the Dataverse issue](https://github.com/microsoft/PowerPlatform-DataverseServiceClient/issues/259) with it reported. Someone mentions about seeing the issue in Azure Functions at the end of this issue.  \n  \n[Here\u0027s an issue where it was previously reported](https://github.com/dotnet/runtime/issues/84755), and I don\u0027t believe the problem was fully understood and incorrectly closed as by design. Returning a proxy for an interface type different than the one you asked for (as the same interface in different ALC\u0027s at runtime are treated as different types) isn\u0027t the design of this feature.  \n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOkllK1g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6R914Z",
                                           "createdAt":  "2024-10-31T02:42:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mconnew",
                                           "body":  "I don\u0027t think this bug exists in DispatchProxy, I believe it\u0027s in the Ref.Emit implementation.",
                                           "updatedAt":  "2024-10-31T02:42:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6R98Ny",
                                           "createdAt":  "2024-10-31T03:13:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-reflection-emit\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-10-31T03:13:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6R-CAF",
                                           "createdAt":  "2024-10-31T03:45:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Likely the same root cause as #101343",
                                           "updatedAt":  "2024-10-31T03:45:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6SGFvV",
                                           "createdAt":  "2024-11-01T00:30:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD5XAsg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2024-11-01T02:54:31Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "steveharter",
                                                                               "createdAt":  "2024-11-04T17:34:00Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "mconnew",
                                           "body":  "@jkotas, I think I found the root cause of the problem. DispatchProxyGenerator looks up the ALC of the base proxyType and uses that as the key in s_alcProxyAssemblyMap which maps the ALC to an instance of ProxyAssembly. The ProxyAssembly class creates a persistent AssemblyBuilder and ModuleBuilder to hold generated types. When creating the first custom ALC, and the first generated proxy, because the base proxyType is from an assembly loaded into the default ALC, DispatchProxyGenerator creates a ProxyAssembly instance mapped to the default ALC. When creating the proxy, it references the proxied interface (due to implementing it), so the runtime interface type is resolved and kept track in the generated Assembly/AssemblyBuilder. When creating a proxy in the second ALC, as the base proxyType is in the default ALC, the same ProxyAssembly instance is used, which means the second generated proxy is created using the same AssemblyBuilder/ModuleBuilder as the first one. The process of adding implemented interfaces to the generated type does so using the types integer token value that\u0027s looked up using some QCalls. As the AssemblyBuilder already references that interface token value, there\u0027s no need to go to all the trouble to resolve it, that\u0027s already been done. So when the proxy is generated and an instance created, the type implemented is the one that AssemblyBuilder has already resolved, which is the instance from the first ALC. To reference the interface in a second ALC, a new ProxyAssembly instance would need to be used. \n\nSo this is a DispatchProxy bug. Basically the key for s_alcProxyAssemblyMap is incorrect. It should be a two-tuple of the proxyType ALC and the proxied interface type ALC. This way if the base proxyType is in the default ALC, but the interface type is in a custom ALC, you can have multiple custom ALC instances each proxying the same interface type and not end up with a cast problem as the proxies for the separate ALC\u0027s will be created by separate ProxyAssembly instances, which means separate AssemblyBuilder instances, so you won\u0027t cross contaminate type references. Just switching to keying off the interface ALC type won\u0027t be sufficient as you could have a single interface type instance from a single ALC that is used to create a DispatchProxy using the same base proxyType, but the proxyType Type instance could be for different ALC instances. You could have the following situation:\n\nDefault ALC  \n  DPI.dll - DispatchProxyUtil\n  Logging.dll - LoggingExtensions.WrapInterface\\\u003cT\\\u003e(T instance)\n\nALC1\n  Foo.dll - IFace1\n  DPI.dll - DispatchProxyUtil\n\nFoo.dll has some code which calls LoggingExtensions.WrapInterface to wrap calls to interface IFace1 with some logging. The code in Logging.dll uses DispatchProxy specifying DispatchProxyUtil as the base proxyType and uses the interface specified. DispatchProxyUtil has extensibility points which enables being able to run some code before and after proxying the call to the wrapped instance, which in this case is used to log how long the method took. The generated proxy should have proxyType ALC = Default and interface ALC = ALC1. The problem though is that the instance passed by Foo.dll to LoggingExtensions.WrapInterface is already a generated proxy created by some other code in Foo.dll using DispatchProxyUtil as the base proxyType. As ALC1 has DPI.dll loaded, this first proxy is created with proxyType ALC = ALC1 and interface ALC = ALC1. So when LoggingExtensions.WrapInterface takes the instance returned by DispatchProxy.Create and tries to cast it to DispatchProxyUtil to set up the logging behavior before returning it, if ProxyAssembly is only keyed off the interface ALC, the cast fails. This is because the ProxyAssembly instance for ALC1 will generate a proxy using the DispatchProxyUtil type loaded in ALC1, and when LoggingExtensions.WrapInterface tries to create a proxy, as it\u0027s the same interface from the same ALC, it would use the same ProxyAssembly instance which would use the DispatchProxyUtil type instance from ALC1. Then when WrapInterface tries to cast the returned implementation to DispatchProxyUtil, you\u0027ll get an invalid cast exception.\n\nThis way around is a lot more convoluted to come up with a breaking scenario than using the proxyType ALC as the key, so it might be okay to switch the set of broken scenarios to the smaller less likely set. I do believe we should use the full two-tuple though. That\u0027s going to be non-trivial to do though due to use of ConditionalWeakTable. You could do a double layered setup where s_alcProxyAssemblyMap is defined as `ConditionalWeakTable\u003cAssemblyLoadContext, ConditionalWeakTable\u003cAssemblyLoadContext, ProxyAssembly\u003e\u003e`. You just nest the lookup by each ALC one at a time. I don\u0027t think proxy creation itself should be considered a hot code path. You could also optimize things. Have a single static ProxyAssembly for the most common case that both types are the default ALC. Have a separate dictionary for the common case of neither type being in a collectible ALC (`Dictionary\u003cTuple\u003cAssemblyLoadContext,AssemblyLoadContext\u003e, ProxyAssembly\u003e`), only falling back to the two layered ConditionalWeakTable if either is collectible.  \n\nThe repro app I created also demonstrates another problem. If the base proxyType comes from the default ALC, you can\u0027t have the proxied interface type exist in a collectible ALC. You get an exception as trying to do so would pin the collectible ALC by having a type generated in the default ALC that references (by way of implementing it) an interface type from the collectible ALC. The utility method `AssemblyLoadContext.EnterContextualReflection` should be used to enable this scenario. If the interface type is in a collectible ALC, a call should be made to `EnterContextualReflection` to use the interface types ALC before instantiating the ProxyAssembly (presuming AssemblyBuilder/ModuleBuilder capture the ALC on creation, otherwise might need to do that on first proxy generation).\n",
                                           "updatedAt":  "2024-11-01T00:30:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6SWUrW",
                                           "createdAt":  "2024-11-04T17:39:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "Verified this issue existed back to v7. Moving to future based on assumed lower priority.\n\n@mconnew are you planning to continue to look at this and perhaps provide a fix for v10? Thanks for the issue, repro and research here.",
                                           "updatedAt":  "2024-11-04T17:39:36Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "DispatchProxy generates a proxy type implementing the interface from the wrong ALC",
        "labels":  [
                       "bug",
                       "area-System.Reflection.Emit"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/110686",
        "createdAt":  "2024-12-13T09:44:24Z",
        "number":  110686,
        "author":  "mattjacobsen",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC9c82g==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jp1337",
                                            "createdAt":  "2024-12-13T14:28:34Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-08-01T18:09:48Z",
        "body":  "### Description\n\nHello,\n\nI\u0027m struggling to read out a resource that was added to an Assembly with PersistedAssemblyBuilder. I\u0027m not sure if I\u0027m doing it wrong, the documentation is wrong, or there\u0027s actually a bug.\n\n\n\n\n\n### Reproduction Steps\n\nGiven the following code (which is just the [example code](https://learn.microsoft.com/en-us/dotnet/fundamentals/runtime-libraries/system-reflection-emit-persistedassemblybuilder#add-resources-with-persistedassemblybuilder) with 4 lines tacked on the end):\n```c#\nSetResource();\nstatic void SetResource()\n{\n    PersistedAssemblyBuilder ab = new PersistedAssemblyBuilder(new AssemblyName(\"MyAssembly\"), typeof(object).Assembly);\n    ab.DefineDynamicModule(\"MyModule\");\n    MetadataBuilder metadata = ab.GenerateMetadata(out BlobBuilder ilStream, out _);\n\n    using MemoryStream stream = new MemoryStream();\n    ResourceWriter myResourceWriter = new ResourceWriter(stream);\n    myResourceWriter.AddResource(\"AddResource 1\", \"First added resource\");\n    myResourceWriter.AddResource(\"AddResource 2\", \"Second added resource\");\n    myResourceWriter.AddResource(\"AddResource 3\", \"Third added resource\");\n    myResourceWriter.Close();\n    BlobBuilder resourceBlob = new BlobBuilder();\n    resourceBlob.WriteBytes(stream.ToArray());\n    metadata.AddManifestResource(ManifestResourceAttributes.Public, metadata.GetOrAddString(\"MyResource\"), default, (uint)resourceBlob.Count);\n\n    ManagedPEBuilder peBuilder = new ManagedPEBuilder(\n                    header: new PEHeaderBuilder(imageCharacteristics: Characteristics.Dll | Characteristics.ExecutableImage),\n                    metadataRootBuilder: new MetadataRootBuilder(metadata),\n                    ilStream: ilStream,\n                    managedResources: resourceBlob);\n\n    BlobBuilder blob = new BlobBuilder();\n    peBuilder.Serialize(blob);\n    using var fileStream = new FileStream(\"MyAssemblyWithResource.dll\", FileMode.Create, FileAccess.Write);\n    blob.WriteContentTo(fileStream);\n    fileStream.Close();\n\n    var readAssembly = Assembly.LoadFile(Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), \"MyAssemblyWithResource.dll\"));\n    string[] names = readAssembly.GetManifestResourceNames();\n    using var readStream = readAssembly.GetManifestResourceStream(names[0]);\n    ResourceReader reader = new ResourceReader(readStream);\n}\n```\n\n### Expected behavior\n\nI expect to be able to read the resource back out using ResourceReader.\n\n### Actual behavior\n\nBadImageFormatException\n\n### Regression?\n\nI tried the HEAD and the 9.0 tag, but nothing other than that.\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n.NET 9.0, Windows 10 x64\n\n### Other information\n\nThe example [here](https://learn.microsoft.com/en-us/dotnet/fundamentals/runtime-libraries/system-reflection-emit-persistedassemblybuilder#add-resources-with-persistedassemblybuilder) shows how you can add a byte array as a resource. Having added that array, I\u0027d now like to read it back out later on.\n\nIf, after writing the assembly to disk, I try and load the resource with\n\n```C#\nvar readAssembly = Assembly.LoadFile(Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), \"MyAssemblyWithResource.dll\"));\nstring[] names = readAssembly.GetManifestResourceNames();\nusing var readStream = readAssembly.GetManifestResourceStream(names[0]);\nResourceReader reader = new ResourceReader(readStream);\n```\n\nI receive the error \n\n\u003e An attempt was made to load a program with an incorrect format. (0x8007000B)\n\nat \n\n```C#\nusing var readStream = readAssembly.GetManifestResourceStream(names[0]);\n```\n\nAs far as I can tell (using dnSpy, looking at the assembly in a hex editor) the assembly contains the resource. If I modify the serialisation code to spit out a huge byte array, the size of the assembly grows accordingly, and I\u0027m able to see the bytes in my hex editor.\n\nWhen I debug the runtime I see the error is thrown here [peassembly.cpp:463](https://github.com/dotnet/runtime/blob/v9.0.0/src/coreclr/vm/peassembly.cpp)\n\n```c++\nvoid PEAssembly::GetEmbeddedResource(DWORD dwOffset, DWORD *cbResource, PBYTE *pbInMemoryResource)\n{\n    CONTRACTL\n    {\n        INSTANCE_CHECK;\n        THROWS;\n        GC_TRIGGERS;\n        MODE_ANY;\n        INJECT_FAULT(ThrowOutOfMemory(););\n    }\n    CONTRACTL_END;\n\n    PEImage* image = GetPEImage();\n    PEImageLayout* theImage = image-\u003eGetOrCreateLayout(PEImageLayout::LAYOUT_ANY);\n    if (!theImage-\u003eCheckResource(dwOffset))\n        ThrowHR(COR_E_BADIMAGEFORMAT);\n\n    COUNT_T size;\n    const void *resource = theImage-\u003eGetResource(dwOffset, \u0026size);\n\n    *cbResource = size;\n    *pbInMemoryResource = (PBYTE) resource;\n}\n```\n\nspecifically, ` CHECK(CheckOverflow(VAL32(pDir-\u003eVirtualAddress), offset));` in [pedecoder.cpp:1243](https://github.com/dotnet/runtime/blob/v9.0.0/src/coreclr/utilcode/pedecoder.cpp)\n\n```c++\nCHECK PEDecoder::CheckResource(COUNT_T offset) const\n{\n    CONTRACT_CHECK\n    {\n        INSTANCE_CHECK;\n        NOTHROW;\n        GC_NOTRIGGER;\n        PRECONDITION(CheckCorHeader());\n    }\n    CONTRACT_CHECK_END;\n\n    IMAGE_DATA_DIRECTORY *pDir = \u0026GetCorHeader()-\u003eResources;\n\n    CHECK(CheckOverflow(VAL32(pDir-\u003eVirtualAddress), offset));\n\n    RVA rva = VAL32(pDir-\u003eVirtualAddress) + offset;\n\n    // Make sure we have at least enough data for a length\n    CHECK(CheckRva(rva, sizeof(DWORD)));\n\n    // Make sure resource is within resource section\n    CHECK(CheckBounds(VAL32(pDir-\u003eVirtualAddress), VAL32(pDir-\u003eSize),\n                      rva + sizeof(DWORD), GET_UNALIGNED_VAL32((LPVOID)GetRvaData(rva))));\n\n    CHECK_OK;\n}\n```\n\nCheckOverflow is passed the VirtualAddress and the offset given with \n\n```c#\nmetadata.GetOrAddString(\"MyResource\"), default, (uint)resourceBlob.Count);\n```\n\nin the [example code](https://learn.microsoft.com/en-us/dotnet/fundamentals/runtime-libraries/system-reflection-emit-persistedassemblybuilder#add-resources-with-persistedassemblybuilder), which is over the end of the data. Looking at that, it doesn\u0027t seem that I didn\u0027t need an offset, but just passing in 0 didn\u0027t help much. I\u0027ve started reading around about the PE Header - it\u0027s really interesting and great to come down from the Typescript clouds - but I think I\u0027m out of my depth for the allotted time I have to learn to swim :-)",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOmIkOsA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6XdN2B",
                                           "createdAt":  "2024-12-13T09:49:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-resources\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-12-13T09:49:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6XhS75",
                                           "createdAt":  "2024-12-13T19:13:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-reflection-emit\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-12-13T19:13:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6YgKoz",
                                           "createdAt":  "2024-12-22T19:29:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "I have this working locally after fixing some issues with the sample:\n  - Offset to `AddManifestResource` should be 0, not the size of the blob.\n  - The size of the serialized `ResourceWriter` needs to be added to the resource blob before the actual data.\nand fixing an issue with an alignment Assert which appears to be perf related and is not necessary for functionality.\n\nI\u0027ll create a PR to fix the alignment and add a test, plus in the docs repo update the sample to something like this:\n```csharp\nstatic void SetResource()\n{\n    PersistedAssemblyBuilder ab = new PersistedAssemblyBuilder(new AssemblyName(\"MyAssemblyWithResource\"), typeof(object).Assembly);\n    ab.DefineDynamicModule(\"MyModule\");\n    MetadataBuilder metadata = ab.GenerateMetadata(out BlobBuilder ilStream, out _);\n\n    using MemoryStream memoryStream = new MemoryStream();\n    ResourceWriter myResourceWriter = new ResourceWriter(memoryStream);\n    myResourceWriter.AddResource(\"AddResource 1\", \"First added resource\");\n    myResourceWriter.AddResource(\"AddResource 2\", \"Second added resource\");\n    myResourceWriter.AddResource(\"AddResource 3\", \"Third added resource\");\n    myResourceWriter.Close();\n    \n    byte[] data = memoryStream.ToArray();\n    BlobBuilder resourceBlob = new BlobBuilder();\n    resourceBlob.WriteInt32(data.Length);\n    resourceBlob.WriteBytes(data);\n\n    metadata.AddManifestResource(\n        ManifestResourceAttributes.Public,\n        metadata.GetOrAddString(\"MyResource.resources\"),\n        implementation: default,\n        offset: 0);\n\n    ManagedPEBuilder peBuilder = new ManagedPEBuilder(\n                    header: PEHeaderBuilder.CreateLibraryHeader(),\n                    metadataRootBuilder: new MetadataRootBuilder(metadata),\n                    ilStream: ilStream,\n                    managedResources: resourceBlob);\n\n    BlobBuilder blob = new BlobBuilder();\n    peBuilder.Serialize(blob);\n    using FileStream fileStream = new (\"MyAssemblyWithResource.dll\", FileMode.Create, FileAccess.Write);\n    blob.WriteContentTo(fileStream);\n    fileStream.Close();\n\n    var readAssembly = Assembly.LoadFile(Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), \"MyAssemblyWithResource.dll\"));\n\n    // Use ResourceReader to read the resources\n    using Stream readStream = readAssembly.GetManifestResourceStream(\"MyResource.resources\")!;\n    using ResourceReader reader = new(readStream);\n    foreach (DictionaryEntry entry in reader)\n    {\n        Console.WriteLine($\"Key: {entry.Key}, Value: {entry.Value}\");\n    }\n\n    // Use ResourceManager to read the resources\n    ResourceManager rm = new ResourceManager(\"MyResource\", readAssembly);\n    ResourceSet resourceSet = rm.GetResourceSet(CultureInfo.InvariantCulture, createIfNotExists: true, tryParents: false);\n    foreach (DictionaryEntry entry in resourceSet)\n    {\n        Console.WriteLine($\"Key: {entry.Key}, Value: {entry.Value}\");\n    }\n}\n```\n",
                                           "updatedAt":  "2024-12-23T18:18:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6YiQ6w",
                                           "createdAt":  "2024-12-23T08:08:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEABPxQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "jp1337",
                                                                               "createdAt":  "2024-12-23T14:39:30Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "mattjacobsen",
                                           "body":  "thanks very much! Santa came early :-)\n\nKind regards,\n\nMatt",
                                           "updatedAt":  "2024-12-23T08:08:18Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "PersistedAssemblyBuilder: unable to retrieve resources added with AddManifestResource",
        "labels":  [
                       "bug",
                       "documentation",
                       "area-System.Reflection.Emit"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/110924",
        "createdAt":  "2024-12-24T04:17:32Z",
        "number":  110924,
        "author":  "DanielBThayer",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-26T10:53:08Z",
        "body":  "### Description\n\nWhen creating an enumeration via the DefineEnum on the ModuleBuilder, the emitted type\u0027s UnderlyingSystemType is set to the type being emitted (creating a circular reference path).  It should be set to the provided type.\n\n### Reproduction Steps\n\nModuleBuilder _moduleBuilder = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName(\"Test\"), AssemblyBuilderAccess.RunAndCollect).DefineDynamicModule(\"Test\");\n\nEnumBuilder builder = _moduleBuilder.DefineEnum(\"E_Test\", TypeAttributes.Public, typeof(int));\n\nbuilder.DefineLiteral(\"Low\", 0);\nbuilder.DefineLiteral(\"High\", 1);\n\nType type = builder.CreateType();\n\nif (type.UnderlyingSystemType == type)\n{\n    throw new Exception(\"Circular reference\");\n}\nelse if (type.UnderlyingSystemType != builder.UnderlyingSystemType)\n{\n    throw new Exception(\"This should never throw\");\n}\n\n\n### Expected behavior\n\nEmitted type has the underlying type set to the type defined in the DefineEnum call (\"Circular reference\" exception will be thrown)\n\n### Actual behavior\n\nEmitted type has the underlying type set to itself\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n.Net version: .Net 8.0.11\nOS: Windows 11, latest updates applied\nArch: x64\n\nSystem.Reflection: 4.3.0\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOmNWL-A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6YsPt6",
                                           "createdAt":  "2024-12-25T09:03:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "elgonzo",
                                           "body":  "What value do you expect for `type.UnderlyingSystemType`? If it is `int`, then `type.UnderlyingSystemType` is the wrong place to look for it. If you want to get the value type underlying an enum, you have to use the `type.GetEnumUnderlyingType()` or `Enum.GetUnderlyingType(Type)` method.\n",
                                           "updatedAt":  "2024-12-25T11:05:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Ys-8o",
                                           "createdAt":  "2024-12-25T15:27:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "`UnderlyingSystemType` is hardcoded to self for any runtime provided type:\n\nhttps://github.com/dotnet/runtime/blob/f3d43efa514a87f04aa994749409297e8f3e94e2/src/libraries/System.Private.CoreLib/src/System/RuntimeType.cs#L33\n\nIt\u0027s used for creating modifiers on type, not underlying numeric type of enums.\n\nhttps://github.com/dotnet/runtime/blob/f3d43efa514a87f04aa994749409297e8f3e94e2/src/libraries/System.Private.CoreLib/src/System/Reflection/ModifiedType.cs#L75",
                                           "updatedAt":  "2024-12-25T15:27:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6YtEEJ",
                                           "createdAt":  "2024-12-25T16:49:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Transient Reflection.Emit has somewhat broken implementation of `UnderlyingSystemType` that returns `GetEnumUnderlyingType`.\n\nFor example:\n```\nusing System.Reflection;\nusing System.Reflection.Emit;\n\nModuleBuilder _moduleBuilder = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName(\"Test\"), AssemblyBuilderAccess.RunAndCollect).DefineDynamicModule(\"Test\");\n\nEnumBuilder builder = _moduleBuilder.DefineEnum(\"E_Test\", TypeAttributes.Public, typeof(int));\n\nConsole.WriteLine(builder.UnderlyingSystemType);\n```\nPrints `System.Int32`.\n\nThis issue is requesting to replicate this behavior in runtime type universe. I agree with other commenters that it does not make sense. Instead, we may want to fix the transient Reflection.Emit implementation. \n\nNote that the persisted Reflection.Emit behaves as expected. There is a mismatch between transient and persisted Reflection.Emit behaviors.\n\nFor example:\n```\nusing System.Reflection;\nusing System.Reflection.Emit;\n\nModuleBuilder _moduleBuilder = new PersistedAssemblyBuilder(new AssemblyName(\"Test\"), typeof(object).Assembly).DefineDynamicModule(\"Test\");\n\nEnumBuilder builder = _moduleBuilder.DefineEnum(\"E_Test\", TypeAttributes.Public, typeof(int));\n\nConsole.WriteLine(builder.UnderlyingSystemType);\n```\nPrints `Type: E_Test`.\n",
                                           "updatedAt":  "2024-12-25T16:51:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Yw1_Y",
                                           "createdAt":  "2024-12-26T16:41:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "\u003e This issue is requesting to replicate this behavior in runtime type universe. I agree with other commenters that it does not make sense. Instead, we may want to fix the transient Reflection.Emit implementation.\n\nAgree - we should change the behavior of AssemblyBuilder to match the runtime behavior (to return `this`) which `PersistedAssemblyBuilder` also matches and which was discussed at https://github.com/dotnet/runtime/pull/106375.\n",
                                           "updatedAt":  "2024-12-26T16:41:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Yx4si",
                                           "createdAt":  "2024-12-27T01:21:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "DanielBThayer",
                                           "body":  "What is the point of the UnderlyingSystemType, if it points to type itself?  Then there is the documentation mismatch with the implementation.  The documentation seems to say it will refer to the system type which represents how the enumeration is stored (e.g. UInt16, Int16, UInt32, Int32, UInt64, Int64, etc).  I am referring to the documentation at:\n\n- https://learn.microsoft.com/en-us/dotnet/api/system.reflection.emit.enumbuilder.underlyingsystemtype?view=net-9.0#system-reflection-emit-enumbuilder-underlyingsystemtype\n- https://learn.microsoft.com/en-us/dotnet/api/system.reflection.emit.typebuilder.underlyingsystemtype?view=net-9.0#system-reflection-emit-typebuilder-underlyingsystemtype\n- https://learn.microsoft.com/en-us/dotnet/api/system.reflection.typedelegator.underlyingsystemtype?view=net-9.0#system-reflection-typedelegator-underlyingsystemtype\n\nFor reference, this issue was causing problems later on in my program when I was attempting to Marshal a byte array to a generic parameter type (e.g. T) of the method call (signature of the method is \"public static T CastByBytes\u003cT\u003e(byte[] data)\").  My work around was to evaluate the generic parameter type\u0027s type (i.e. using IsEnum, IsArray, typeof(bool), etc) to handle different cases causing issues with the code (e.g. bool is 4 bytes on x64 systems, but the source of the byte array has them as 1 byte).",
                                           "updatedAt":  "2024-12-27T01:21:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Y1Yv4",
                                           "createdAt":  "2024-12-28T01:37:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "`UnderlyingSystemType` is a property of the [`IReflect`](https://learn.microsoft.com/en-us/dotnet/api/system.reflection.ireflect) interface. In retrospect it should have been explicitly implemented by `Type`. Maybe we can hide it from Intellisense.",
                                           "updatedAt":  "2024-12-28T01:37:36Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "EnumBuilder.UnderlyingSystemType != EnumBuilder.CreateType().UnderlyingSystemType",
        "labels":  [
                       "bug",
                       "area-System.Reflection.Emit",
                       "breaking-change",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/111003",
        "createdAt":  "2024-12-30T20:07:02Z",
        "number":  111003,
        "author":  "jgh07",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-19T21:49:10Z",
        "body":  "### Description\n\nWhen using the new ``PersistedAssemblyBuilder`` introduced in .NET 9 and trying to load a field whose type is a function pointer, invalid IL gets generated, causing the application to crash with a ``System.MissingFieldException`` when executed.\n\n(On another note, is there currently a way of generating such fields using ``ILGenerator``? How do you get a ``Type`` object for a function pointer at runtime?)\n\n### Reproduction Steps\n\nThe following code reproduces the problem in .NET 9. It doesn\u0027t produce a working executable by itself since I did not set the entry point, so to execute code from the generated assembly, you would need to reference it by some other assembly.\n````csharp\nusing System;\nusing System.Reflection;\nusing System.Reflection.Emit;\n\nPersistedAssemblyBuilder ab = new(new(\"Test\"), typeof(object).Assembly);\nModuleBuilder mb = ab.DefineDynamicModule(\"Test.dll\");\nTypeBuilder tb = mb.DefineType(\"Program\");\n\nMethodBuilder methb = tb.DefineMethod(\"Main\", MethodAttributes.Public | MethodAttributes.Static);\nmethb.SetReturnType(typeof(void));\n\nILGenerator il = methb.GetILGenerator();\n\nil.Emit(OpCodes.Call, typeof(Container).GetMethod(\"Init\"));\n\nil.Emit(OpCodes.Ldc_I4_2);\nil.Emit(OpCodes.Ldc_I4_3);\nil.Emit(OpCodes.Ldsfld, typeof(Container).GetField(\"Method\"));\nil.EmitCalli(OpCodes.Calli, System.Runtime.InteropServices.CallingConvention.Winapi, typeof(int), [typeof(int), typeof(int)]);\nil.Emit(OpCodes.Call, typeof(Console).GetMethod(\"WriteLine\", BindingFlags.Public | BindingFlags.Static, null, [typeof(int)], []));\n\nil.Emit(OpCodes.Ret);\n\ntb.CreateType();\nab.Save(\"Test.dll\");\n\npublic unsafe static class Container\n{\n    public static delegate*\u003cint, int, int\u003e Method;\n\n    public static int Add(int a, int b) =\u003e a + b;\n    public static void Init() =\u003e Method = \u0026Add;\n}\n````\n\n### Expected behavior\n\nThe following IL is generated as the method body for ``Test::Main()`` when running under .NET Framework 4.8.1:\n````cil\ncall void [Issue]Container::Init()\nldc.i4.2\nldc.i4.3\nldsfld method int32 *(int32,int32) [Issue]Container::Method\ncalli unmanaged stdcall int32(int32,int32)\ncall void [mscorlib]System.Console::WriteLine(int32)\nret\n````\n\nThe generated application runs correctly and prints ``5``.\n\n### Actual behavior\n\nThe following IL is generated when running under .NET 9:\n````cil\ncall void [Issue]Container::Init()\nldc.i4.2\nldc.i4.3\nldsfld class [System.Private.CoreLib]$TR$2 [Issue]Container::Method\ncalli int32(int32,int32)\ncall void [System.Console]System.Console::WriteLine(int32)\nret\n````\nThe ``ldsfld`` instruction, instead of correctly using a function pointer as the field type, generates some garbage type (as is displayed by ildasm).\n\nWhen executed, the following exception is thrown:\n````\nUnhandled exception. System.MissingFieldException: Field not found: \u0027Container.Method\u0027.\n   at Program.Main()\n````\n\n### Regression?\n\nAPI was newly introduced with .NET 9. Works fine in .NET Framework 4.8.1.\n\n### Known Workarounds\n\nDon\u0027t know of any.\n\n### Configuration\n\n- .NET 9.0.100\n- Windows 11 23H2\n- Debug, x64\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOxYbFaA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6Y-sWf",
                                           "createdAt":  "2024-12-31T16:22:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jgh07",
                                           "body":  "Based on some further tesing, when **declaring new fields** of function pointer types, .NET 9 creates the same non-existent type as above and .NET Framework creates fields of type ``native int``. While that is not ideal either, it is at least better than in .NET 9, where the program will crash no matter what.\n\nI noticed that there is (active?) [work going on](https://github.com/dotnet/runtime/issues/75348) regarding function pointer types in Reflection.Emit, but I do feel like this can be considered a separate issue since it is dealing with functionality that used to work fine.",
                                           "updatedAt":  "2024-12-31T16:22:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7Fg6Xl",
                                           "createdAt":  "2025-09-19T20:36:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jgh07",
                                           "body":  "What\u0027s the current status of this? Is it on the table for .NET 11?",
                                           "updatedAt":  "2025-09-19T20:36:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7Fg_Pm",
                                           "createdAt":  "2025-09-19T20:46:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Are you interested in contributing the fix?",
                                           "updatedAt":  "2025-09-19T20:46:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7FhsVo",
                                           "createdAt":  "2025-09-19T21:49:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jgh07",
                                           "body":  "Sure, I\u0027d love to. I\u0027m not too well versed in .NET internals, but I\u0027ll try to get it working.",
                                           "updatedAt":  "2025-09-19T21:49:10Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "``ILGenerator`` does not properly handle function pointers",
        "labels":  [
                       "bug",
                       "area-System.Reflection.Emit"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/118238",
        "createdAt":  "2025-07-31T11:53:21Z",
        "number":  118238,
        "author":  "Kira-NT",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-04T07:40:05Z",
        "body":  "### Description\n\nCurrently, if you attempt to use the `ILGenerator.Emit(OpCode, MethodInfo)` overload on an `ILGenerator` instance obtained from `DynamicMethod.GetILGenerator()` with `OpCodes.Ldftn` or `OpCodes.Ldtoken` and another `DynamicMethod`, you will encounter an `ArgumentException` due to the following \"safeguard\":\n\nhttps://github.com/dotnet/runtime/blob/abc4c652eca9e02c4ff5d4dac0ceb58a4a15b8e3/src/coreclr/System.Private.CoreLib/src/System/Reflection/Emit/DynamicILGenerator.cs#L74-L80\n\nMono does the same thing in solidarity with CoreCLR:\n\nhttps://github.com/dotnet/runtime/blob/0cc6b0eb57924dd65a5b591776b5e7a40fee5bc1/src/mono/System.Private.CoreLib/src/System/Reflection/Emit/RuntimeILGenerator.Mono.cs#L714-L716\n\nHowever, it\u0027s not entirely clear why these checks exist in the first place. Both `ldftn` and `ldtoken` are perfectly valid operations on a `DynamicMethod` within the context of another `DynamicMethod`, i.e., this limitation does not exist at the runtime level, and it is only imposed on the consumer by the refemit library.\n\nMy guess is that there was a time, perhaps years ago, when the CLR did not support these operations on `DynamicMethod`s, and this check is a leftover artifact from that period, which appears to have been continuously ported through successive versions: from .NET Framework, to .NET Core, and finally to modern .NET - without anyone questioning why this restriction is still in place.\n\n### Reproduction Steps\n\n```csharp\nusing System.Reflection;\nusing System.Reflection.Emit;\n\nDynamicMethod addMethod = new(\"Add\", typeof(int), [typeof(int), typeof(int)], true);\nILGenerator addIl = addMethod.GetILGenerator();\naddIl.Emit(OpCodes.Ldarg_0);\naddIl.Emit(OpCodes.Ldarg_1);\naddIl.Emit(OpCodes.Add);\naddIl.Emit(OpCodes.Ret);\n\nDynamicMethod getAddMethodFunctionPointerMethod = new(\"\", typeof(nint), [], true);\nILGenerator getPointerIl = getAddMethodFunctionPointerMethod.GetILGenerator();\ngetPointerIl.Emit(OpCodes.Ldftn, addMethod);\ngetPointerIl.Emit(OpCodes.Ret);\nFunc\u003cnint\u003e getAddMethodFunctionPointer = getAddMethodFunctionPointerMethod.CreateDelegate\u003cFunc\u003cnint\u003e\u003e();\nConsole.WriteLine(getAddMethodFunctionPointer());\n```\n\n### Expected behavior\n\nShould print `Add`\u0027s function pointer.\n\n### Actual behavior\n\nThrows an `ArgumentException` on line 13:\n\n```csharp\ngetPointerIl.Emit(OpCodes.Ldftn, addMethod);\n```\n\n### Regression?\n\nNo, this operation has always been prohibited. However, at the very least in the latest versions of CLR, CoreCLR, and Mono, it is actually supported by the runtime, so there\u0027s just no good reason for this check to continue to exist.\n\n### Known Workarounds\n\nIt is possible to register a `DynamicMethod` within the scope of another `DynamicMethod` through alternative means *(e.g., via reflection or by inserting an unreachable call to the target method somewhere in the generated method body)* and then infer its resulting metadata token for use with the `ldftn` and `ldtoken` instructions. However, this approach is non-portable and it\u0027s highly dependent on the current runtime and its internal implementation details. So, it would be far more preferable for `ILGenerator` to simply stop discarding valid code.\n\n### Configuration\n\nThis bug affects every version of .NET Framework, .NET Core, and .NET released to date.\n\n### Other information\n\nHere\u0027s a complete example of what I\u0027m talking about:\n\n```csharp\nusing System.Reflection;\nusing System.Reflection.Emit;\n\nDynamicMethod addMethod = new(\"Add\", typeof(int), [typeof(int), typeof(int)], true);\nILGenerator addIl = addMethod.GetILGenerator();\naddIl.Emit(OpCodes.Ldarg_0);\naddIl.Emit(OpCodes.Ldarg_1);\naddIl.Emit(OpCodes.Add);\naddIl.Emit(OpCodes.Ret);\n\nDynamicMethod getMethodPointerAndHandleMethod = new(\"\", typeof(void), [typeof(nint).MakeByRefType(), typeof(RuntimeMethodHandle).MakeByRefType()]);\nILGenerator il = getMethodPointerAndHandleMethod.GetILGenerator();\nLabel actualMethodBody = il.DefineLabel();\n\n// The method \"call\" is here solely to register the \"Add\" method within the dynamic method\u0027s scope,\n// avoiding the need for extensive use of reflection. However, Mono and .NET (Fx, Core, etc.)\n// create metadata tokens in slightly different manners - this is why we need the ILGenerator APIs\n// to function correctly, so we don\u0027t have to manufacture these tokens through some cursed means.\nil.Emit(OpCodes.Br_S, actualMethodBody);\nil.Emit(OpCodes.Ldc_I4_0);\nil.Emit(OpCodes.Ldc_I4_0);\nil.Emit(OpCodes.Call, addMethod);\nil.Emit(OpCodes.Pop);\n#if MONO\nint addMethodMetadataToken = 1;\n#else\nint addMethodMetadataToken = 0x6000002;\n#endif\n\nil.MarkLabel(actualMethodBody);\nil.Emit(OpCodes.Ldarg_0);\nil.Emit(OpCodes.Ldftn, addMethodMetadataToken);\nil.Emit(OpCodes.Stind_I);\nil.Emit(OpCodes.Ldarg_1);\nil.Emit(OpCodes.Ldtoken, addMethodMetadataToken);\nil.Emit(OpCodes.Stobj, typeof(RuntimeMethodHandle));\nil.Emit(OpCodes.Ret);\n\nMethodFunc getMethodPointerAndHandle = (MethodFunc)getMethodPointerAndHandleMethod.CreateDelegate(typeof(MethodFunc));\ngetMethodPointerAndHandle(out nint addFunctionPointer, out RuntimeMethodHandle addHandle);\n\n// Mono 6.12, which is installed on my machine, lacks support for `calli`, so it just\n// coredumps whenever it encounters this instruction. If you\u0027re using Microsoft\u0027s\n// fork (any version released after 2021 or so), this won\u0027t be a problem, so you\n// can safely remove this check.\n#if !MONO\nunsafe\n{\n    var add1 = (delegate*\u003cint, int, int\u003e)addFunctionPointer;\n    Console.WriteLine(\"0x{0:X8}: 40 + 1 == {1}\", (nint)add1, add1(40, 1));  // 0x________: 40 + 1 == 41\n}\n#endif\n\nvar add2 = (Func\u003cint, int, int\u003e)Activator.CreateInstance(typeof(Func\u003cint, int, int\u003e), null, addFunctionPointer)!;\nConsole.WriteLine(\"{0}: 40 + 2 == {1}\", add2.Method, add2(40, 2)); // Int32 Add(Int32, Int32): 40 + 2 == 42\n\nvar add3 = (Func\u003cint, int, int\u003e)((MethodInfo)MethodBase.GetMethodFromHandle(addHandle)!).CreateDelegate(typeof(Func\u003cint, int, int\u003e));\nConsole.WriteLine(\"{0}: 40 + 3 == {1}\", add3.Method, add3(40, 3)); // Int32 Add(Int32, Int32): 40 + 3 == 43\n\nfile delegate void MethodFunc(out nint method, out RuntimeMethodHandle handle);\n```\n\nIf you run this code on .NET Framework, .NET Core, .NET, Mono (original), Mono (WineHQ), or Mono (Microsoft), you should see something like this:\n\n```\n0x7FC5E8B7B690: 40 + 1 == 41\nInt32 Add(Int32, Int32): 40 + 2 == 42\nInt32 Add(Int32, Int32): 40 + 3 == 43\n```\n\nThis demonstrates that the runtimes associated with the specified core libraries do support `ldftn` and `ldtoken` on `DynamicMethod` instances, and they return valid values in response to those instructions. Therefore, the checks currently present in `DynamicILGenerator` on CoreCLR and `RuntimeILGenerator` on Mono are verifiably incorrect and should be removed.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOuzqPTA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc67JE0-",
                                           "createdAt":  "2025-07-31T12:12:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-reflection-emit\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-07-31T12:12:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc67JXuG",
                                           "createdAt":  "2025-07-31T12:37:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "It should be intentionally blocked. With collectible functions, function pointers are GC-unsafe. It\u0027s a more realistic problem for `DynamicMethod` because they are collected individually.",
                                           "updatedAt":  "2025-07-31T12:37:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc67KThH",
                                           "createdAt":  "2025-07-31T13:45:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Kira-NT",
                                           "body":  "Could you please elaborate a bit more on your argument? I don\u0027t think I\u0027m following.\n\nFirst of all, as you yourself have pointed out, every method is potentially unloadable: either because it\u0027s a `DynamicMethod` that can be collected by GC entirely on its own, or because it\u0027s a part of an unloadable assembly - which is why we always need to keep a strong reference to a method somewhere if we want to use its raw function pointer. So, ~~banning~~ making certain instructions harder to use based on the assumption that it\u0027s merely \"more common\" for `DynamicMethod`s to get unloaded doesn\u0027t seem like a sound technical argument, at least in my view.\n\nSecondly, and arguably more importantly, `ILGenerator` is not the right place to enforce safety checks of any kind. The [documentation](https://learn.microsoft.com/en-us/dotnet/api/system.reflection.emit.ilgenerator?view=net-9.0) greets us with a giant warning that `ILGenerator` can produce invalid or straight up damaging IL if not verified by the programmer. So, what\u0027s the rationale behind disallowing valid IL then? Moreover, `ILGenerator` is one of the most, if not *the* most unsafe APIs available in .NET. It allows us to introduce GC or type safety holes, corrupt memory, or even construct an instance of the `void` type, and so on and so forth. And yet, `ILGenerator` doesn\u0027t seem to care, because its output is inherently unsafe and unverifiable, so it by its very nature demands that the programmer fully understands what they\u0027re diving into.",
                                           "updatedAt":  "2025-07-31T13:45:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc67MMHf",
                                           "createdAt":  "2025-07-31T16:09:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e ldtoken are perfectly valid operations\n\nNotice that the other ways to get RuntimeMethodHandle for dynamic methods are blocked as well. For example, `Console.WriteLine(dynamicMethod.MethodHandle)` is going to throw `InvalidOperationException: The requested operation is invalid for DynamicMethod.`.\n\nI agree with you that there should not be anything fundamental that prevents these operations from working (in unsafe way). However, it is not clear whether the rest of the runtime is going to handle the results produced by these operations gracefully.",
                                           "updatedAt":  "2025-07-31T18:44:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc67OSmQ",
                                           "createdAt":  "2025-07-31T19:17:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Kira-NT",
                                           "body":  "\u003e Notice that the other ways to RuntimeMethodHandle for dynamic methods are blocked as well.\n\nYep, that\u0027s true. It seems that back in the .NET Framework era, team was overly concerned with preventing us from shooting ourselves in the foot: `MethodHandle` throws, `GetMethodBody` throws *(well, ok, this one wouldn\u0027t be very useful unless the team had also decided to add `ResolveType`, `ResolveField`, and similar methods from `Module` to `MethodBody`)*, `ILGenerator.Emit` throws, `DynamicMethod` was wrapped in `RTDynamicMethod` half the time you encountered it in the wild, and so on and so forth.\n\nHowever, since the focus has now shifted drastically and .NET is happy to hand us the leg-shooting gun *(provided we know what we\u0027re doing and it helps performance)*, it would be interesting to see if at least some of those APIs could make a comeback :)\n\n\u003e I agree with you that there should not be anything fundamental that prevents these operations from working (in unsafe way).\n\nThis one would be the most obvious candidate for that, because it requires basically no work. And while it would technically be a *breaking* change, it affects a niche within a niche, and developers like myself, who dwell there, would actually be happy to see it.\n\nFor years, I honestly thought that `DynamicMethod`s were just weird like that, and that the runtime only and barely supported invoking them in a manner consistent with regular methods. So, whenever I needed a pointer to/a handle for a `DynamicMethod`, I always used a delegate to .NET\u0027s internal `GetMethodDescriptor()` *(or `mhandle`/`_mhandle` on Mono)*.\n\nOnly recently was I bitten yet again by `ILGenerator` throwing on the `ldftn` and `DynamicMethod` combo, and I finally decided to test whether those instructions are actually supported by the runtime. And it turns out - yep, they are.\n\n\u003e However, it is not clear whether the rest of the runtime is going to handle the results produced by these operations gracefully.\n\nIn my anecdotal experience, function pointers received from a `RuntimeMethodHandle` *(acquired via `DynamicMethod.GetMethodDescriptor()`, `mhandle`, or `_mhandle`)* are pretty stable, as long as a reference to the original `DynamicMethod` is kept somewhere, of course.\n\nHowever, I do know that `RuntimeMethodHandle.GetFunctionPointer()` and `ldftn` are slightly different, and sometimes return different pointers. Since I\u0027ve always used the former method to acquire such pointers, I don\u0027t have an extensive history of testing the latter. Though it seems to work fine as well.\n\nSo, it would definitely be helpful to get a comment from the CoreCLR and Mono teams on whether the runtime properly supports this case, and whether this limitation is purely a core library\u0027s safeguard to prevent us from accidentally creating a pointer to a GCed method.",
                                           "updatedAt":  "2025-07-31T19:17:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc67Oo9M",
                                           "createdAt":  "2025-07-31T19:57:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEcthaA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "Kira-NT",
                                                                               "createdAt":  "2025-07-31T20:14:26Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e it would definitely be helpful to get a comment from the CoreCLR and Mono teams on whether the runtime properly supports this case\n\nWe would be happy to accept a PR that removes this limitation as long as it is accompanied by sufficient test coverage that validates the results produced by these IL instructions work as expected in DynamicMethods. I expect that there are fixes required to make it properly supported. \n\n- For ldftn, the tests should validate that passing the function pointer to delegate constructor (using standard delegate creation sequence) works as expected and that the resulting delegate behaves correctly, including unloadability (the delegate should keep the target method alive). There are a few different cases of source and destination signatures to test.\n- For ldtoken, the tests should validate that the resulting RuntimeMethodHandle is usable - that the methods like RuntimeMethodHandle.Value, RuntimeMethodHandle.GetFunctionPointer or MethodBase.GetMethodFromHandle works as expected.",
                                           "updatedAt":  "2025-07-31T19:57:43Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "ILGenerator imposes artificial limitations on otherwise valid IL",
        "labels":  [
                       "area-System.Reflection.Emit",
                       "help wanted"
                   ]
    }
]
