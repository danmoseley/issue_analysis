[
    {
        "url":  "https://github.com/dotnet/runtime/issues/22838",
        "createdAt":  "2017-07-18T20:54:08Z",
        "number":  22838,
        "author":  "stephentoub",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODB42YA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jeanbern",
                                            "createdAt":  "2020-03-02T19:50:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mattzink",
                                            "createdAt":  "2020-05-06T17:06:40Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "zgramana",
                                            "createdAt":  "2020-06-22T17:48:51Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "0xfeeddeadbeef",
                                            "createdAt":  "2021-01-16T01:18:44Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "andriysavin",
                                            "createdAt":  "2021-02-03T10:52:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pakrym",
                                            "createdAt":  "2021-05-25T22:48:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "shravan2x",
                                            "createdAt":  "2021-06-24T20:49:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "airbreather",
                                            "createdAt":  "2021-08-29T12:12:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Tan90909090",
                                            "createdAt":  "2022-01-28T15:59:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hrumhurum",
                                            "createdAt":  "2023-01-28T22:04:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "austinw-fineart",
                                            "createdAt":  "2023-06-09T09:24:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "zawor",
                                            "createdAt":  "2024-01-08T09:40:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Arasfon",
                                            "createdAt":  "2024-02-04T13:51:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aromaa",
                                            "createdAt":  "2024-03-22T20:19:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "YarinOmesi",
                                            "createdAt":  "2024-05-06T19:07:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "tomrus88",
                                            "createdAt":  "2024-07-03T18:17:09Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aayjaychan",
                                            "createdAt":  "2024-08-14T13:38:57Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "freddyrios",
                                            "createdAt":  "2024-09-02T14:00:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "A9G-Data-Droid",
                                            "createdAt":  "2025-03-21T15:47:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jyrkive",
                                            "createdAt":  "2025-03-24T08:29:50Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "bazarniy",
                                            "createdAt":  "2025-04-30T11:32:16Z"
                                        }
                                    ],
                          "totalCount":  21
                      },
        "updatedAt":  "2023-07-24T23:00:13Z",
        "body":  "Just as we have a MemoryStream that works with `byte[]` and an UnmanagedMemoryStream that works with a `byte*` and a length, we should support treating `Memory\u003cbyte\u003e` and `ReadOnlyMemory\u003cbyte\u003e` as streams.\r\n\r\nIt’s possible we could get away with reimplementing `MemoryStream` on top of `Memory\u003cbyte\u003e`, but more than likely this would introduce regressions for at least some existing use cases, and it doesn\u0027t work with `ReadOnlyMemory\u003cbyte\u003e`.\r\n\r\nIt would be nice if we could potentially write something ala:\r\n```C#\r\nStream s = memory.TryGetArray(out var segment) ?\r\n    new MemoryStream(segment.Array, segment.Offset, segment.Count) :\r\n    new UnmanagedMemoryStream(\u0026memory.DangerousGetPinnableReference(), buffer.Length);\r\n```\r\nbut it\u0027s possible that TryGetArray could return false but the wrapped memory not inherently pinned, in which case the UnmanagedMemoryStream case would be wrapping a pointer to memory that could get moved.  To pin it and keep track of the pinning, you\u0027d need a wrapper Stream type anyway.\r\n\r\nSo, we could have two new stream types for these specific types:\r\n```C#\r\nnamespace System.IO\r\n{\r\n    public class BufferStream : Stream\r\n    {\r\n        public BufferStream(Memory\u003cbyte\u003e buffer);\r\n        public BufferStream(Memory\u003cbyte\u003e buffer, bool publiclyVisible);\r\n        public bool TryGetBuffer(out Memory\u003cbyte\u003e buffer);\r\n        … // overrides of all members on Stream\r\n    }\r\n\r\n    public class ReadOnlyBufferStream : Stream\r\n    {\r\n        public ReadOnlyBufferStream(ReadOnlyMemory\u003cbyte\u003e buffer);\r\n        public ReadOnlyBufferStream(ReadOnlyMemory\u003cbyte\u003e buffer, bool publiclyVisible);\r\n        public bool TryGetBuffer(out ReadOnlyMemory\u003cbyte\u003e buffer);\r\n        … // overrides of all members on Stream, with those that write throwing NotSupportedException\r\n    }\r\n}\r\n```\r\nThe name of BufferStream is unfortunately close to that of BufferedStream, and they mean very different things, but I’m not sure that’s important enough to consider a less meaningful name.\r\n\r\nAlternatively, we could hide these behind a factory, e.g.\r\n```C#\r\npublic static Stream ToStream(this Memory\u003cbyte\u003e buffer) =\u003e new BufferStream(buffer);\r\npublic static Stream ToStream(this ReadOnlyMemory\u003cbyte\u003e buffer) =\u003e new ReadOnlyBufferStream(buffer);\r\n```\r\nto keep them from needing to be public.\r\n\r\nEspecially if we do the latter, we would want to consider either adding TryGetBuffer virtuals to the base Stream class, or introducing an interface that could be queried for and which exposing such methods.\r\nThen for example code that uses Streams and has optimizations when working directly with the underlying data can query for the interface and special-case when the underlying `Buffer\u003cT\u003e` can be accessed, e.g.\r\n```C#\r\nnamespace System\r\n{\r\n    public interface IHasBuffer\u003cT\u003e\r\n    {\r\n        bool TryGetBuffer(out Memory\u003cT\u003e buffer);\r\n        bool TryGetBuffer(out ReadOnlyMemory\u003cT\u003e buffer);\r\n    }\r\n}\r\n```\r\nWe could implement this not only on `BufferStream` and `ReadOnlyBufferStream`, but also on `MemoryStream`, `UnmanagedMemoryStream`, and even on non-streams, basically anything that can hand out a representation of its internals as buffers.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOIyupOg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMyOTI1Mzg4Mw==",
                                           "createdAt":  "2017-09-13T18:20:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KrzysztofCwalina",
                                           "body":  "Now that we renamed the type to Memory\u003cT\u003e, the problem with BufferStream name goes away. Unfortunately another problem is created :-), i.e. what would we now call this stream type?\r\n\r\nAlso, where do we expect it to live? System.Memory.dll? \r\n\r\ncc: @ahsonkhan ",
                                           "updatedAt":  "2017-09-13T18:20:53Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5MDA2MzkzMA==",
                                           "createdAt":  "2020-02-23T12:31:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ohsorry",
                                           "body":  "\u003ewhere do we expect it to live\r\n\r\nAs I proposed.  Now read and write `Memory\u003cbyte\u003e` can only use `Slices/CopyTo` and then track the position manually . It would be convenient if `Memory\u003cbyte\u003e` could be treated like a stream.",
                                           "updatedAt":  "2020-02-23T12:31:51Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Consider adding {ReadOnly}SpanMemoryStream types",
        "labels":  [
                       "api-needs-work",
                       "area-System.Memory",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/23616",
        "createdAt":  "2017-09-20T21:00:13Z",
        "number":  23616,
        "author":  "Drawaes",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC4e8Ew==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jnm2",
                                            "createdAt":  "2017-09-20T22:35:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ektrah",
                                            "createdAt":  "2017-09-21T15:35:52Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "benaadams",
                                            "createdAt":  "2017-10-03T19:22:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "tmds",
                                            "createdAt":  "2017-10-05T16:30:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "roji",
                                            "createdAt":  "2018-07-08T08:26:31Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sa-exe",
                                            "createdAt":  "2018-07-18T17:31:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "patricksuo",
                                            "createdAt":  "2019-03-19T02:26:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2020-03-31T10:28:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "TailyFair",
                                            "createdAt":  "2020-04-10T07:00:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "egmkang",
                                            "createdAt":  "2020-09-29T08:56:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "alexandrvslv",
                                            "createdAt":  "2020-11-26T11:05:49Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "JohanLarsson",
                                            "createdAt":  "2021-08-01T17:32:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aeb-dev",
                                            "createdAt":  "2022-12-06T14:52:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "chinwobble",
                                            "createdAt":  "2023-01-03T05:40:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AlexRadch",
                                            "createdAt":  "2023-06-08T18:05:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sgf",
                                            "createdAt":  "2024-05-23T17:23:06Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "edwardneal",
                                            "createdAt":  "2024-06-08T17:53:43Z"
                                        }
                                    ],
                          "totalCount":  17
                      },
        "updatedAt":  "2025-01-28T16:29:35Z",
        "body":  "ref dotnet/runtime#23601\r\n\r\nWhen using span to read/write a block of memory you often end up with the following pattern\r\n\r\n```c#\r\nvar myspan = [someplace a span is allocated]\r\n\r\nspan.Write[TBD](someValue);\r\nspan = span.Slice(sizeof(typeof(someValue));\r\nspan.Write[TBD](someOtherValue);\r\nspan = span.Slice(.......\r\n\r\n```\r\n\r\nNow obviously that code is not 100% representative of real code but the overall pattern is. I have used span in a couple of real world apps and the pattern ends up being a mess. Write/Read then slice, Write/Read then slice again. It seems that as it is a very common pattern (from my use anyway) the abstraction that is often come up with is a struct wrapper that can \"hide\" that slicing away and instead \"advance\" the span on writes. Something like\r\n\r\n```c#\r\npublic struct BigEndianWriter\r\n{\r\n    private Span\u003cbyte\u003e _innerSpan;\r\n    \r\n    public BigEndianWriter(Span\u003cbyte\u003e innerSpan) =\u003e _innerSpan;\r\n}\r\n\r\npublic struct LittleEndianWriter\r\n{\r\n     private Span\u003cbyte\u003e _innerSpan;\r\n     \r\n     public LittleEndianWriter(Span\u003cbyte\u003e innerSpan) =\u003e _innerSpan;\r\n}\r\n\r\npublic struct BigEndianReader\r\n{\r\n    private ReadOnlySpan\u003cbyte\u003e _innerSpan;\r\n    \r\n    public BigEndianReader(ReadOnlySpan\u003cbyte\u003e innerSpan) =\u003e _innerSpan;\r\n}\r\n\r\npublic struct LittleEndianReader\r\n{\r\n     private ReadOnlySpan\u003cbyte\u003e _innerSpan;\r\n     \r\n     public LittleEndianReader(ReadOnlySpan\u003cbyte\u003e innerSpan) =\u003e _innerSpan;\r\n}\r\n```\r\n\r\nThe kinds of methods you would want to see on such a struct would be \r\n\r\n```c#\r\n\r\n//Readers only\r\npublic byte ReadByte();\r\npublic sbyte ReadByteS();\r\npublic short ReadInt16();\r\npublic ushort ReadUInt16();\r\npublic uint ReadUInt32();\r\npublic int ReadInt32();\r\npublic long ReadInt64();\r\npublic ulong ReadUInt64();\r\n\r\n//Writers only\r\npublic void WriteByte(byte value);\r\npublic void WriteSByte(sbyte value);\r\npublic void WriteUInt16(ushort value);\r\npublic void WriteInt16(short value);\r\npublic void WriteInt32(int value);\r\npublic void WriteUInt32(uint value);\r\npublic void WriteInt64(long value);\r\npublic void WriteUInt64(ulong value);\r\n   \r\n//Common\r\npublic int Length =\u003e _innerSpan.Length;\r\npublic Span Span =\u003e _innerSpan;\r\npublic void Advance(int count);\r\n```\r\n\r\nIf you want to \"peek/poke\" then you can just get out the span via `reader.Span` there is no need to provide them on the type.\r\n\r\n[EDIT] Add C# syntax highlight by @karelz\r\n[EDIT] Updated to more concrete design",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOnCJOSA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzMTAwMDMwMA==",
                                           "createdAt":  "2017-09-20T22:36:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jnm2",
                                           "body":  "I would use a reader as well as a writer for sure.",
                                           "updatedAt":  "2017-09-20T22:36:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzMTAxMTg3Nw==",
                                           "createdAt":  "2017-09-20T23:49:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Drawaes",
                                           "body":  "It should also have \"Peek\" methods that don\u0027t advance \r\n\r\n```\r\npublic int PeekBigEndianInt32();\r\n```",
                                           "updatedAt":  "2017-09-20T23:49:21Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzMTE5NTE2MQ==",
                                           "createdAt":  "2017-09-21T15:36:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ektrah",
                                           "body":  "+1.\r\n\r\nThe biggest problem with this is that [mutable structs are evil](https://stackoverflow.com/q/441309). It\u0027s quite likely that users will pass around a reader or writer struct by-value and be surprised that it doesn\u0027t advance, in particular since the existing [BinaryReader](https://docs.microsoft.com/en-us/dotnet/api/system.io.binaryreader?view=netcore-2.0)/[BinaryWriter](https://docs.microsoft.com/en-us/dotnet/api/system.io.binarywriter?view=netcore-2.0) types are classes. The [obvious solution](https://github.com/dotnet/csharplang/issues/859) doesn\u0027t seem popular.",
                                           "updatedAt":  "2017-09-21T15:36:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzMTIwMzYyMw==",
                                           "createdAt":  "2017-09-21T16:04:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Drawaes",
                                           "body":  "They are already at the boundary with stack only spans. Anyone writing and reading directly to spans I think can have an assumed level of knowledge. \r\n\r\n",
                                           "updatedAt":  "2017-09-21T16:04:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzMzkyOTY0MQ==",
                                           "createdAt":  "2017-10-03T18:07:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Drawaes",
                                           "body":  "/cc @davidfowl @benaadams @stephentoub \r\nThis is more like what I would like to deal with Spans for reading/writing.",
                                           "updatedAt":  "2017-10-03T18:07:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzMzk0MDUwMQ==",
                                           "createdAt":  "2017-10-03T18:44:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "Consider using a constructor argument as endianness specifier: `public SpanReader(Span\u003cbyte\u003e span, bool isBigEndian)`.\r\nThe endianness can now change at runtime. For example, reading endianness from a marker and then passing that to the reader constructor.\r\nI don\u0027t know if this impacts performance when the endianness is a compile-type constant compared to _typed_ endianness.",
                                           "updatedAt":  "2017-10-03T18:44:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzMzk0MTA3MA==",
                                           "createdAt":  "2017-10-03T18:46:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Drawaes",
                                           "body":  "it will make the struct bigger for a start as you need to store it and its a branch for each op, currently the struct will only be the size of a span, and as its basically a struct wrapper you can switch if you want by doing\r\n\r\n```c#\r\nvar bigEndian = new BigEndianWriter(littleEndian.Span);\r\n```",
                                           "updatedAt":  "2017-10-03T18:47:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNDQzMjcxMw==",
                                           "createdAt":  "2017-10-05T11:04:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "Adding two use-cases:\r\n- reading a file which has an endianness marker (e.g endianness is derived from magic number)\r\n- writing a file in the machine endianness\r\n\r\nThese use-cases cannot be handled with the proposed api without duplicating the code for big and little endian.",
                                           "updatedAt":  "2017-10-05T11:04:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNDQzNjQ5OQ==",
                                           "createdAt":  "2017-10-05T11:23:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Drawaes",
                                           "body":  "Stick an interface on it. Make your method generic  to avoid the box. A branch per op is a killer",
                                           "updatedAt":  "2017-10-05T11:23:25Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNDQzNzY1NA==",
                                           "createdAt":  "2017-10-05T11:29:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e Stick an interface on it. Make your method generic to avoid the box. A branch per op is a killer\r\n\r\nCan you stick an interface on a ref struct?",
                                           "updatedAt":  "2017-10-05T11:29:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNDQzODkzMw==",
                                           "createdAt":  "2017-10-05T11:36:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Drawaes",
                                           "body":  "I don\u0027t see why not? But others smarter than I would have to answer. I can honestly say however unless the JIT can optimise out that branch per read/write it would make this struct useless for me...",
                                           "updatedAt":  "2017-10-05T11:36:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNDQzOTk2Nw==",
                                           "createdAt":  "2017-10-05T11:41:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e I don\u0027t see why not? But others smarter than I would have to answer. I can honestly say however unless the JIT can optimise out that branch per read/write it would make this struct useless for me...\r\n\r\nMaybe there should be more structs/methods/...\r\nI\u0027m just bringing use-cases :)\r\n\r\nAccording to: https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.2/span-safety.md\r\n\r\n\u003e A ref struct type may not be declared to implement any interface",
                                           "updatedAt":  "2017-10-05T11:41:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNDUwNzY2Mg==",
                                           "createdAt":  "2017-10-05T15:48:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "Merging the Little and Big classes by using different methods.\r\nAnd adding an argument overload to Read/Write that accepts Endianness.\r\nPlus a generic \u003cT\u003e read/write.\r\nGives something like this:\r\n\r\n```C#\r\n\r\nenum Endianness\r\n{\r\n   Native,\r\n   BigEndian,\r\n   LittleEndian\r\n}\r\n\r\nref struct SpanReader\r\n{\r\n   SpanReader(ReadOnlySpan\u003cbyte\u003e);\r\n\r\n   public void Advance(int count);\r\n   \r\n   ushort ReadUInt16(Endianness = Endianness.Native);\r\n   ushort ReadUInt16LE();\r\n   ushort ReadUInt16BE();\r\n\r\n   T Read\u003cT\u003e() where T : struct;\r\n}\r\n\r\nref struct SpanWriter\r\n{\r\n   SpanWriter(Span\u003cbyte\u003e);\r\n\r\n   public void Advance(int count);\r\n   \r\n   void WriteUInt16(ushort value, Endianness = Endianness.Native);\r\n   void WriteUInt16LE(ushort value);\r\n   void WriteUInt16BE(ushort value);\r\n\r\n   void Write\u003cT\u003e(T) where T : struct;\r\n}\r\n```",
                                           "updatedAt":  "2017-10-05T16:30:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNTQwMDk4NQ==",
                                           "createdAt":  "2017-10-10T08:33:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "Do SpanReader/Writer need to store a Span? Or would it be allowed to store a pointer?\r\ne.g.\r\n```C#\r\n    unsafe ref struct SpanReader\r\n    {\r\n        private void* _data;\r\n        private int _length;\r\n\r\n        public ReadOnlySpan\u003cbyte\u003e Remaining =\u003e new ReadOnlySpan\u003cbyte\u003e(_data, _length);\r\n\r\n        public SpanReader(Span\u003cbyte\u003e span)\r\n        {\r\n            _data = Unsafe.AsPointer(ref span.DangerousGetPinnableReference());\r\n            _length = span.Length;\r\n        }\r\n\r\n        public T Read\u003cT\u003e() where T : struct\r\n        {\r\n            int size = Unsafe.SizeOf\u003cT\u003e();\r\n            if (size \u003e _length)\r\n            {\r\n                throw new ArgumentOutOfRangeException();\r\n            }\r\n            byte* data = (byte*)_data;\r\n            _data = data + size;\r\n            _length -= size;\r\n            return Unsafe.ReadUnaligned\u003cT\u003e(data);\r\n        }\r\n    }\r\n```\r\nWould that be more efficient?",
                                           "updatedAt":  "2017-10-10T08:33:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNTQwMzc3OQ==",
                                           "createdAt":  "2017-10-10T08:44:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Drawaes",
                                           "body":  "Not sure. I think if it\u0027s a lot faster then we should get whatever is slow fixed in the jit/runtime rather than optimising separately here...?",
                                           "updatedAt":  "2017-10-10T08:44:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNTQwOTc5Mw==",
                                           "createdAt":  "2017-10-10T09:07:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "\u003e Or would it be allowed to store a pointer?\r\n\r\nCould create a GC hole if the span dropped out scope\r\n\r\nThe reader/writer (as specified above) should/could be close to a zero cost convenience wrapper",
                                           "updatedAt":  "2017-10-10T09:07:20Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNTQxMjExOA==",
                                           "createdAt":  "2017-10-10T09:15:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e Could create a GC hole if the span dropped out scope\r\n\r\nCan the Span drop out of scope before the Reader/Writer? Looking at the stack order, it should out-live the reader/writer.",
                                           "updatedAt":  "2017-10-10T09:15:48Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNTQxNDg1OA==",
                                           "createdAt":  "2017-10-10T09:26:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "Create span, use in ctor, never reference it again?",
                                           "updatedAt":  "2017-10-10T09:26:09Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNTQxNzg0MQ==",
                                           "createdAt":  "2017-10-10T09:37:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e Create span, use in ctor, never reference it again?\r\n```C#\r\nvar span = new ReadOnlySpan\u003cbyte\u003e(new byte[1024]);\r\nvar reader = new SpanReader(span);\r\nvar value = reader.ReadUInt16();\r\n```\r\nAh, so the span may be out of scope on the last line, before the reader.",
                                           "updatedAt":  "2017-10-10T09:37:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNTQ0OTc5Ng==",
                                           "createdAt":  "2017-10-10T11:59:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ektrah",
                                           "body":  "\u003e ```csharp\r\n\u003e _data = Unsafe.AsPointer(ref span.DangerousGetPinnableReference());\r\n\u003e ```\r\n\r\nThe `ref` returned by `DangerousGetPinnableReference` isn\u0027t pinned. The GC is free to move the array inside the span around in memory, which makes the pointer invalid even if the span does not go out of scope.\r\n",
                                           "updatedAt":  "2017-10-10T11:59:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNTQ1MjAwMg==",
                                           "createdAt":  "2017-10-10T12:10:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e The ref returned by DangerousGetPinnableReference isn\u0027t pinned. The GC is free to move the array inside the span around in memory, which makes the pointer invalid even if the span does not go out of scope.\r\n\r\nI was aiming to re-use the pinning of the Span. As long as the Span does not go out of scope, the array is pinned by the Span (right?). As pointed out by @benaadams the Span can go out of scope, then the pinning is lost. So the SpanReader/Writer are responsible for pinning themselves (by including a Span member or a Pinnable\u003cT\u003e).",
                                           "updatedAt":  "2017-10-10T12:10:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNTQ1MjkxMw==",
                                           "createdAt":  "2017-10-10T12:14:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e the array is pinned by the Span (right?)\r\n\r\nNo, Span does not pin.",
                                           "updatedAt":  "2017-10-10T12:14:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNTQ1MzAwMQ==",
                                           "createdAt":  "2017-10-10T12:14:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ektrah",
                                           "body":  "\u003e As long as the Span does not go out of scope, the array is pinned by the Span (right?).\r\n\r\nThe span does not pin the array. `DangerousGetPinnableReference` returns a *pinnable* reference, not a *pinned* reference.",
                                           "updatedAt":  "2017-10-10T12:14:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNTQ1NjAxOQ==",
                                           "createdAt":  "2017-10-10T12:27:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "@stephentoub @ektrah Aha! TIL: Span does not pin! So pinning happens when the `fixed` keyword is used?",
                                           "updatedAt":  "2017-10-10T12:27:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNTQ1NjI4Mg==",
                                           "createdAt":  "2017-10-10T12:29:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e So pinning happens when the fixed keyword is used?\r\n\r\nYes.",
                                           "updatedAt":  "2017-10-10T12:29:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNTQ1ODkxOA==",
                                           "createdAt":  "2017-10-10T12:39:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Drawaes",
                                           "body":  "Hence the inner span stays ;)",
                                           "updatedAt":  "2017-10-10T12:39:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQwMzI3MTY2OA==",
                                           "createdAt":  "2018-07-08T08:27:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "roji",
                                           "body":  "+1 on this, am doing work on spanification/pipelinization of Npgsql and the write/slice/write/slice is really not nice to work with.",
                                           "updatedAt":  "2018-07-08T08:27:09Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQwNjAyMDc3NQ==",
                                           "createdAt":  "2018-07-18T17:59:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCivZnQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jgimness",
                                                                               "createdAt":  "2019-11-15T14:39:30Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Razmoth",
                                                                               "createdAt":  "2022-06-20T18:04:52Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "DaZombieKiller",
                                           "body":  "If anybody is interested, I just wrote up a quick implementation of a \"SpanReader\" based on this discussion:\r\n\r\nhttps://gist.github.com/DaZombieKiller/e0a3f4b3de21d998797eed33cda0f709\r\n\r\nJust note that it\u0027s not perfect and is subject to 3 AM programming, so feel free to ~~berate me~~ give me constructive criticism.",
                                           "updatedAt":  "2018-07-18T17:59:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ3MjUzNTU5NQ==",
                                           "createdAt":  "2019-03-13T17:53:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "@JeremyKuhne, is there anything more we want to do here after your BufferReader/Writer work, or can this issue be closed?",
                                           "updatedAt":  "2019-03-13T17:53:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ3NDE2NjE4MQ==",
                                           "createdAt":  "2019-03-19T01:48:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "JeremyKuhne",
                                           "body":  "\u003e  is there anything more we want to do here?\r\n\r\nWell the writer isn\u0027t done yet.  Additionally [`SequenceReader\u003cT\u003e`](https://apisof.net/catalog/System.Buffers.SequenceReader%3CT%3E) only supports `ReadOnlySequence\u003cT\u003e`.",
                                           "updatedAt":  "2019-03-19T01:48:55Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ3NDE4MzU0MA==",
                                           "createdAt":  "2019-03-19T03:22:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAoI54A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "stephentoub",
                                                                               "createdAt":  "2019-03-19T06:35:10Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "davidfowl",
                                                                               "createdAt":  "2019-05-07T02:42:45Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "karaziox",
                                                                               "createdAt":  "2019-05-07T02:43:26Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "I think it might be worth looking at adding span support even with the additional overhead ",
                                           "updatedAt":  "2019-03-19T03:22:53Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwNDc2ODAyMw==",
                                           "createdAt":  "2019-06-23T16:41:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xPaw",
                                           "body":  "When working with binary data, I find `BinaryReader` to be very useful. It would be quite nice if BinaryReader could accept a Span, instead of a Stream.",
                                           "updatedAt":  "2019-06-23T16:41:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUzNzM0MjYzNg==",
                                           "createdAt":  "2019-10-02T05:32:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steji113",
                                           "body":  "Is this something that will potentially be looked into for 5.0? I am looking for an efficient binary data reader that preferably operates over spans. I have a legacy binary protocol that is typically length prefixed messages that encodes various primitive types somewhat similarly to how MsgPack works. Our existing code uses `BinaryReader` but this does not have async support, nor is it the most efficient.",
                                           "updatedAt":  "2019-10-02T05:32:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2MTk1NTM1Mg==",
                                           "createdAt":  "2019-12-05T03:46:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e Well the writer isn\u0027t done yet. Additionally SequenceReader\u003cT\u003e only supports ReadOnlySequence\u003cT\u003e.\r\n\r\n\u003e I think it might be worth looking at adding span support even with the additional overhead\r\n\r\nSo the reader API then is:\r\n\r\n```cs\r\n    public ref struct SequenceReader\u003cT\u003e\r\n    {\r\n        public SequenceReader(ReadOnlySpan\u003cT\u003e span)\r\n```\r\n\r\nSome Sequence oriented members may not be supported.\r\n\r\nMaybe we should create a separate issue to split the reader and the writer API?\r\n\r\n\u003e Our existing code uses BinaryReader but this does not have async support, nor is it the most efficient.\r\n\r\nA Span reader won\u0027t have async support either because the `ref struct` can\u0027t live on the heap (which is necessary to capture async state).",
                                           "updatedAt":  "2019-12-05T03:46:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYxNjE0MjE4NA==",
                                           "createdAt":  "2020-04-19T14:02:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "shaggygi",
                                           "body":  "Just curious.  Is the plan for this issue to create a `SequenceWriter\u003cT\u003e` and if so, does it look like it will be added by .NET 5 release?  Thx.  (I\u0027m guessing this is different as I came across [282](https://github.com/dotnet/runtime/issues/282)).",
                                           "updatedAt":  "2020-04-19T23:46:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6cCrQv",
                                           "createdAt":  "2025-01-28T05:48:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Due to lack of recent activity, this issue has been marked as a candidate for backlog cleanup.  It will be closed if no further activity occurs within 14 more days. Any new comment (by anyone, not necessarily the author) will undo this process.\n\nThis process is part of our [issue cleanup automation](https://github.com/dotnet/runtime/blob/main/docs/issue-cleanup.md).\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-01-28T05:48:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6cIk5I",
                                           "createdAt":  "2025-01-28T16:29:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEFwEWQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "roji",
                                                                               "createdAt":  "2025-01-30T10:27:57Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jnm2",
                                                                               "createdAt":  "2025-02-09T17:49:50Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "NinoFloris",
                                           "body":  "SpanWriter would still be very welcome, keep it open please.",
                                           "updatedAt":  "2025-01-28T16:29:22Z"
                                       }
                                   ],
                         "totalCount":  37
                     },
        "title":  "Provide a stateful reader writer of span\u0027s",
        "labels":  [
                       "api-needs-work",
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/23950",
        "createdAt":  "2017-10-25T00:59:13Z",
        "number":  23950,
        "author":  "ahsonkhan",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODFFdLw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "arekbal",
                                            "createdAt":  "2018-04-22T19:55:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sjb-sjb",
                                            "createdAt":  "2019-06-02T17:26:09Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "NetMage",
                                            "createdAt":  "2020-06-10T21:17:52Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "qwertie",
                                            "createdAt":  "2021-02-03T19:01:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "bert2",
                                            "createdAt":  "2021-12-24T20:24:44Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "voroninp",
                                            "createdAt":  "2022-09-17T08:38:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "VadimOvchinnikov",
                                            "createdAt":  "2022-10-13T14:52:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "chhh",
                                            "createdAt":  "2022-10-19T06:00:26Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "chhh",
                                            "createdAt":  "2022-10-19T06:00:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ygoe",
                                            "createdAt":  "2022-11-30T23:33:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "virzak",
                                            "createdAt":  "2023-01-19T12:31:54Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "virzak",
                                            "createdAt":  "2023-01-19T12:31:59Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "frankhaugen",
                                            "createdAt":  "2023-07-02T16:17:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "0xfeeddeadbeef",
                                            "createdAt":  "2023-07-14T08:52:20Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "vchirikov",
                                            "createdAt":  "2023-08-03T14:10:46Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "filipesilva-l",
                                            "createdAt":  "2023-09-15T00:10:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AlexRadch",
                                            "createdAt":  "2023-11-06T17:43:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "qwertie",
                                            "createdAt":  "2024-07-29T08:02:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "scharnyw",
                                            "createdAt":  "2024-11-25T02:30:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "timcassell",
                                            "createdAt":  "2025-06-29T10:16:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "TahirAhmadov",
                                            "createdAt":  "2025-06-29T12:29:49Z"
                                        }
                                    ],
                          "totalCount":  21
                      },
        "updatedAt":  "2023-12-05T07:41:04Z",
        "body":  "## Rationale\r\nUsers should be able to pass `Memory\u003cT\u003e` to methods that take in `IEnumerable\u003cT\u003e` similar to array. Currently, this requires calling ToArray() to copy the contents of the `Memory\u003cT\u003e` into an array for it to work, and is unnecessary.\r\n\r\nFor example (from @eerhardt):\r\nhttps://github.com/dotnet/corefxlab/blob/master/src/System.Numerics.Tensors/System/Numerics/DenseTensor.cs#L10\r\n```C#\r\npublic void SomeMethod(DenseTensor\u003cfloat\u003e tensor)\r\n{\r\n   Memory\u003cfloat\u003e memory = tensor.Buffer;\r\n   var value = CreateBatch\u003cT\u003e(..., memory.ToArray(), ...);\r\n}\r\n```\r\n\r\nhttps://github.com/Microsoft/CNTK/blob/master/bindings/csharp/CNTKLibraryManagedDll/ShimApiClasses/ValueShim.cs#L104\r\n\r\n```C#\r\npublic static Value CreateBatch\u003cT\u003e(NDShape sampleShape, IEnumerable\u003cT\u003e batch, DeviceDescriptor device, bool readOnly = false)\r\n{\r\n    T[] batchAsArray = batch.ToArray();\r\n    return CreateBatch\u003cT\u003e(sampleShape, batchAsArray, 0, batchAsArray.Count(), device, readOnly);\r\n}\r\n```\r\n\r\nIf `Memory\u003cT\u003e` implemented `IEnumerable\u003cT\u003e`, then the ToArray() call would not be required. However, this would cause applications that reference System.Memory and `Memory\u003cT\u003e` for any scenario to be larger (when compiled AOT). Furthermore, if `Memory\u003cT\u003e` was an `IEnumerable\u003cT\u003e`, it might result in a pit of failure as it could lead to users unintentionally using the enumerator to iterate over the data rather than the more performant indexer on Memory.Span (especially for primitive types like `Memory\u003cbyte\u003e`). To discourage unnecessary use of the enumerator but still provide support for the scenarios where you need an IEnumerable, the proposed solution is to add an adapter class and a ToEnumerable extension method on `Memory\u003cT\u003e`.\r\n\r\nAs an FYI, `Span\u003cT\u003e` cannot implement `IEnumerable\u003cT\u003e` since it is a stack-only, byref type, and casting it to an interface would cause boxing. The compiler will throw and error: `\u0027Span\u003cT\u003e\u0027: ref structs cannot implement interfaces`\r\n\r\n## Proposed API\r\n```C#\r\nnamespace System\r\n{\r\n   public static class MemoryExtensions {\r\n     public static IEnumerable\u003cT\u003e ToEnumerable(this Memory\u003cT\u003e memory);\r\n   }\r\n}\r\n```\r\n\r\n## Usage\r\nTaking the above example, it would look as follows:\r\n```C#\r\npublic void SomeMethod(DenseTensor\u003cfloat\u003e tensor)\r\n{\r\n   Memory\u003cfloat\u003e memory = tensor.Buffer;\r\n   var value = CreateBatch\u003cT\u003e(..., memory.ToEnumerable(), ...);\r\n}\r\n```\r\n\r\n## Partial Implementation\r\n```C#\r\npublic static IEnumerable\u003cT\u003e ToEnumerable(this Memory\u003cT\u003e memory) =\u003e new MemoryEnumerable\u003cT\u003e(memory);\r\n\r\ninternal class MemoryEnumerable\u003cT\u003e : IEnumerable\u003cT\u003e\r\n{\r\n    ReadOnlyMemory\u003cT\u003e _memory;\r\n\r\n    public MemoryEnumerable(ReadOnlyMemory\u003cT\u003e memory) =\u003e _memory = memory;\r\n\r\n    public IEnumerator\u003cT\u003e GetEnumerator() =\u003e new MemoryEnumerator\u003cT\u003e(_memory);\r\n\r\n    IEnumerator IEnumerable.GetEnumerator() =\u003e new MemoryEnumerator\u003cT\u003e(_memory);\r\n}\r\n\r\ninternal class MemoryEnumerator\u003cT\u003e : IEnumerator\u003cT\u003e\r\n{\r\n    ReadOnlyMemory\u003cT\u003e _memory;\r\n    int _index;\r\n\r\n    public MemoryEnumerator(ReadOnlyMemory\u003cT\u003e memory) =\u003e _memory = memory;\r\n\r\n    public T Current =\u003e _memory.Span[_index];\r\n\r\n    object IEnumerator.Current =\u003e _memory.Span[_index];\r\n\r\n    public void Dispose()\r\n    {\r\n        throw new NotImplementedException();\r\n    }\r\n\r\n    public bool MoveNext()\r\n    {\r\n        _index++;\r\n        return _index \u003c_memory.Length;\r\n    }\r\n\r\n    public void Reset()\r\n    {\r\n        _index = 0;\r\n    }\r\n}\r\n\r\n```\r\n\r\ncc @eerhardt, @KrzysztofCwalina, @stephentoub, @jkotas, @terrajobst, @karelz, @ericstj ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOP_bXBA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzOTE4MTQxNQ==",
                                           "createdAt":  "2017-10-25T01:03:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCx4vQg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "qwertie",
                                                                               "createdAt":  "2021-02-03T19:01:12Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kronic",
                                                                               "createdAt":  "2022-12-28T23:05:06Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "svick",
                                           "body":  "Would other collection interfaces make sense too? Like `IReadOnlyList\u003cT\u003e`?",
                                           "updatedAt":  "2017-10-25T01:03:40Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzOTE4MTk3NQ==",
                                           "createdAt":  "2017-10-25T01:07:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e might result in a pit of failure as it could lead to users unintentionally using the enumerator to iterate over the data\r\n\r\nHow is Memory any more susceptible than IEnumerable on other types like List and T[]?",
                                           "updatedAt":  "2017-10-25T01:07:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzOTE4MzU2Ng==",
                                           "createdAt":  "2017-10-25T01:17:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEYZgZw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "virzak",
                                                                               "createdAt":  "2023-01-19T12:32:33Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Enderlook",
                                                                               "createdAt":  "2023-02-22T01:01:12Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "thejonan",
                                                                               "createdAt":  "2023-02-24T14:02:33Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "drwharris",
                                                                               "createdAt":  "2023-07-03T02:16:48Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "petrroll",
                                                                               "createdAt":  "2025-06-29T10:25:47Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  5
                                                         },
                                           "author":  "eerhardt",
                                           "body":  "Why can’t Memory{T} implement IEnumerable{T} directly?  That way you wouldn’t need to call a method, nor alloc a throw away object.",
                                           "updatedAt":  "2017-10-25T01:17:14Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzOTE4MzU5Mg==",
                                           "createdAt":  "2017-10-25T01:17:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ahsonkhan",
                                           "body":  "\u003e How is Memory any more susceptible than IEnumerable on other types like List and T[]?\r\n\r\nIt is just as susceptible. The difference being we can change `Memory\u003cT\u003e`.\r\n\r\n\u003e Why can’t Memory{T} implement IEnumerable{T} directly?  That way you wouldn’t need to call a method, nor alloc a throw away object.\r\n\r\nSee Rationale section:\r\n\u003e However, this would cause applications that reference System.Memory and `Memory\u003cT\u003e` for any scenario to be larger (when compiled AOT). Furthermore, if `Memory\u003cT\u003e` was an `IEnumerable\u003cT\u003e`, it might result in a pit of failure as it could lead to users unintentionally using the enumerator to iterate over the data rather than the more performant indexer on Memory.Span",
                                           "updatedAt":  "2017-10-25T01:19:21Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzOTE4NDA3Mw==",
                                           "createdAt":  "2017-10-25T01:20:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Why can’t Memory{T} implement IEnumerable{T} directly? That way you wouldn’t need to call a method, nor alloc a throw away object.\r\n\r\nYou always need to alloc a throw away object to get IEnumerable out of memory. If Memory implemented IEnumerable directly, casting to IEnumerable would box.",
                                           "updatedAt":  "2017-10-25T01:20:26Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzOTE4NTY3Nw==",
                                           "createdAt":  "2017-10-25T01:31:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "eerhardt",
                                           "body":  "Oh right.  I missed that Memory{T} is a struct. ",
                                           "updatedAt":  "2017-10-25T01:31:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzOTE4ODk0NA==",
                                           "createdAt":  "2017-10-25T01:53:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODBj2Yw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2017-10-25T16:14:10Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nietras",
                                                                               "createdAt":  "2017-10-26T10:17:16Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "wipiano",
                                                                               "createdAt":  "2018-08-14T10:44:39Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "SGmuwa",
                                                                               "createdAt":  "2019-10-04T13:50:15Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "strangeman375",
                                                                               "createdAt":  "2020-11-05T06:27:25Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "NetMage",
                                                                               "createdAt":  "2021-01-11T22:19:05Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "bernd5",
                                                                               "createdAt":  "2023-01-24T23:15:18Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Enderlook",
                                                                               "createdAt":  "2023-02-22T01:01:53Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "0xfeeddeadbeef",
                                                                               "createdAt":  "2023-07-14T08:53:39Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kucint",
                                                                               "createdAt":  "2023-07-24T06:18:54Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  10
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Partial Implementation\r\n\r\nThis is an implementation detail, but we should use the same allocated object as both the enumerable and enumerator in the common case, as is done by the compiler with iterators and in LINQ... this could potentially even just be implemented with an iterator:\r\n```C#\r\npublic static IEnumerable\u003cT\u003e ToEnumerable(this Memory\u003cT\u003e memory)\r\n{\r\n    for (int i = 0; i \u003c memory.Length; i++) yield return memory.Span[i];\r\n}\r\n```",
                                           "updatedAt":  "2017-10-25T16:01:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzOTM4MzA5MQ==",
                                           "createdAt":  "2017-10-25T16:09:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD8UMTA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2017-10-25T16:14:04Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "justinvp",
                                                                               "createdAt":  "2017-10-26T01:03:06Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nietras",
                                                                               "createdAt":  "2017-10-26T10:17:50Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "benaadams",
                                                                               "createdAt":  "2017-11-05T13:22:43Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "omariom",
                                                                               "createdAt":  "2017-11-06T18:34:32Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nil4",
                                                                               "createdAt":  "2017-11-07T20:05:10Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "arekbal",
                                                                               "createdAt":  "2018-04-22T20:03:24Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "NetMage",
                                                                               "createdAt":  "2020-06-10T21:18:42Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "qwertie",
                                                                               "createdAt":  "2021-02-10T18:12:40Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "smarts",
                                                                               "createdAt":  "2022-12-01T00:44:17Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "scharnyw",
                                                                               "createdAt":  "2024-11-25T02:29:42Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  11
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Span\u003cT\u003e cannot implement IEnumerable\u003cT\u003e since it is a stack-only, byref type, and casting it to an interface would cause boxing\r\n\r\nOnly tangentially related to this issue, have we considered giving Span an instance or extension GetEnumerator that returns a ref struct Enumerator?  And/or have there been any discussions about enabling the compiler to support foreach\u0027ing a span and generating optimal code for that?  Just as I can foreach an array and end up with asm equivalent to walking through each element, it\u0027d be nice to be able to do that with span as well, e.g.\r\n```C#\r\nforeach (T item in span)\r\n{\r\n    ...\r\n}\r\n```\r\nbeing the same as:\r\n```C#\r\nfor (int i = 0; i \u003c span.Length; i++)\r\n{\r\n    T item = span[i];\r\n    ...\r\n}\r\n```\r\n\r\nEDIT: C# doesn\u0027t currently support extension GetEnumerators in foreach; either it would need to be an instance method, or the language would need to be updated to either special-case span or enable extension GetEnumerators.\r\n\r\ncc: @VSadov, @MadsTorgersen ",
                                           "updatedAt":  "2017-10-25T16:33:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzOTQ3Njg5OA==",
                                           "createdAt":  "2017-10-25T21:27:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBysqow==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jnm2",
                                                                               "createdAt":  "2017-11-14T18:59:43Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "arekbal",
                                                                               "createdAt":  "2018-10-10T18:14:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "NetMage",
                                                                               "createdAt":  "2020-06-10T21:18:47Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "qwertie",
                                                                               "createdAt":  "2021-02-10T18:12:43Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Bananas-Are-Yellow",
                                                                               "createdAt":  "2021-07-15T18:05:03Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  5
                                                         },
                                           "author":  "KrzysztofCwalina",
                                           "body":  "Language support for foreach would be great.",
                                           "updatedAt":  "2017-10-25T21:27:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM0MjU3NzQ0MQ==",
                                           "createdAt":  "2017-11-07T18:30:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "terrajobst",
                                           "body":  "[Video](https://www.youtube.com/watch?v=HnKmLJcEM74\u0026t=0h4m12s)\n\nLooks good as proposed. `MemoryExtensions` doesn\u0027t exist yet but `SpanExtensions` will be renamed to it.",
                                           "updatedAt":  "2019-10-04T22:20:48Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM0MjY1MDAwMw==",
                                           "createdAt":  "2017-11-07T22:48:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBfnouQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "arekbal",
                                                                               "createdAt":  "2018-04-22T19:57:23Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "qwertie",
                                                                               "createdAt":  "2021-02-10T18:14:25Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "I opened https://github.com/dotnet/csharplang/issues/1085 for `foreach` support for `Span\u003cT\u003e` from the language side of things.  We still need to decide if we want to add `GetEnumerator` instance method to `Span\u003cT\u003e` and `ReadOnlySpan\u003cT\u003e`.",
                                           "updatedAt":  "2017-11-07T22:48:40Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM0MjY3MzM1Mg==",
                                           "createdAt":  "2017-11-08T00:49:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "FYI: The API review discussion was recorded - see https://youtu.be/HnKmLJcEM74?t=391 (13 min duration)",
                                           "updatedAt":  "2017-11-08T00:49:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM0NzYwNTU1OQ==",
                                           "createdAt":  "2017-11-28T17:47:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KrzysztofCwalina",
                                           "body":  "@ahsonkhan, should we close this issue now? We added the enumerator.\r\n\r\n[EDIT] Editing correct @ahsonkhan by @karelz",
                                           "updatedAt":  "2017-11-28T18:53:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM0NzYwNTkxMw==",
                                           "createdAt":  "2017-11-28T17:48:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e should we close this issue now? We added the enumerator.\r\n\r\nWe added one to span.  I don\u0027t think we added one to memory.",
                                           "updatedAt":  "2017-11-28T17:48:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM0NzYzOTYyNw==",
                                           "createdAt":  "2017-11-28T19:38:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KrzysztofCwalina",
                                           "body":  "I assume the one added to Memory would be a by ref struct, i.e. it would cache the span? If yes, I think it\u0027s fine to add it. Otherwise I think it\u0027s a perf trap.",
                                           "updatedAt":  "2017-11-28T19:39:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM0NzY0MTcyNg==",
                                           "createdAt":  "2017-11-28T19:45:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBcFC3Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2017-11-28T19:47:45Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "VSadov",
                                                                               "createdAt":  "2017-11-28T22:24:40Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "NetMage",
                                                                               "createdAt":  "2021-01-11T22:22:46Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "I would assume not, as you\u0027d most likely want to use it with LINQ and other such consumers. And if you did want a byref one, you could instead enumerate .Span.",
                                           "updatedAt":  "2017-11-28T19:45:54Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM0NzY3NTgzMA==",
                                           "createdAt":  "2017-11-28T21:52:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "VSadov",
                                           "body":  "We tried the same route with ImmutableArray - add an adapter class and ToEnumerable method (or was it AsList ? ) - we did not like boxing of ImmutableArray. \r\nAnyways people despised that so we ended up with IEnumerable anyways.",
                                           "updatedAt":  "2017-11-28T21:52:46Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM1NzA3Nzk4OQ==",
                                           "createdAt":  "2018-01-11T22:10:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ianhays",
                                           "body":  "Do we still want to add ```public static IEnumerable\u003cT\u003e ToEnumerable(this Memory\u003cT\u003e memory);``` even if we also add ```Memory\u003cT\u003e.GetEnumerator()``` a la https://github.com/dotnet/coreclr/pull/14922?",
                                           "updatedAt":  "2018-01-11T22:10:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM1NzA3OTQ0Ng==",
                                           "createdAt":  "2018-01-11T22:16:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "`Memory\u003cT\u003e` isn\u0027t getting `.GetEnumerator()` and `IEnumerable\u003cT\u003e ToEnumerable(this Memory\u003cT\u003e memory)` is a performance hole provided for compat (as you can\u0027t put a span in a `IEnumerator`), so is an explicit call. (As far as I understand)",
                                           "updatedAt":  "2018-01-11T22:16:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM1NzA4Mjg0OA==",
                                           "createdAt":  "2018-01-11T22:30:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ianhays",
                                           "body":  "\u003eMemory\u003cT\u003e isn\u0027t getting .GetEnumerator()\r\n\u003eas you can\u0027t put a span in a IEnumerator\r\n\r\nisn\u0027t that exactly what we\u0027re already doing [right here](https://github.com/dotnet/coreclr/blob/master/src/mscorlib/shared/System/Span.cs#L420) (though as Enumerator, not IEnumerator)? Or did you mean that you can\u0027t put a Memory into the Enumerator (which makes sense because it\u0027s not by-ref)?",
                                           "updatedAt":  "2018-01-11T22:30:21Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM1NzA4NzgzMQ==",
                                           "createdAt":  "2018-01-11T22:51:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCquruw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Timovzl",
                                                                               "createdAt":  "2022-08-17T18:46:07Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e isn\u0027t that exactly what we\u0027re already doing right here\r\n\r\nNo, that\u0027s a ref struct, and it doesn\u0027t implement `IEnumerator\u003cT\u003e`, and that\u0027s for `Span\u003cT\u003e`, not `Memory\u003cT\u003e`.  That\u0027s just implementing a pattern that\u0027s bindable to foreach by the C# compiler, no interfaces involved.\r\n\r\n\u003e even if we also add Memory\u003cT\u003e.GetEnumerator() a la dotnet/coreclr#14922?\r\n\r\nWe\u0027re not adding an `IEnumerable\u003cT\u003e` implementation to `Memory\u003cT\u003e`, as that likely ends up being more expensive than a ToEnumerable method.  Consider a method that accepts an `IEnumerable\u003cT\u003e`. If `Memory\u003cT\u003e` (a struct) implemented `IEnumerable\u003cT\u003e`, passing the struct to that method would box it, resulting in an allocation; then when that method calls GetEnumerator and gets back an `IEnumerator\u003cT\u003e`, that\u0027d be a second allocation.  In contrast, with a `ToEnumerable` method, the `IEnumerable\u003cT\u003e` that\u0027s returned can also implement `IEnumerator\u003cT\u003e`, such that the instance you get back can be the sole allocation in the 99% case where the enumerable is enumerated once.",
                                           "updatedAt":  "2018-01-11T22:51:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM1NzA5Nzg4NQ==",
                                           "createdAt":  "2018-01-11T23:41:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ianhays",
                                           "body":  "Thanks @stephentoub, I\u0027ve got some better context now. Your comments in [The API Review video on this topic](https://www.youtube.com/watch?v=HnKmLJcEM74\u0026feature=youtu.be\u0026t=391) helped too :)\r\n\r\n",
                                           "updatedAt":  "2018-01-11T23:41:51Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM1ODgwODM1NQ==",
                                           "createdAt":  "2018-01-18T22:51:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ianhays",
                                           "body":  "There\u0027s pushback in dotnet/corefx#26284 about this being implemented as an extension method so I closed it so we can decide for sure what the API shape will look like and where the API should live (MemoryMarshal? Some new class?)\r\n\r\ncc: @KrzysztofCwalina ",
                                           "updatedAt":  "2018-01-18T22:51:54Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMTM1NTA0Mg==",
                                           "createdAt":  "2020-11-03T20:21:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jhudsoncedaron",
                                           "body":  "Got here trying to pass a `Memory\u003cchar\u003e` to `.All()` linq method. Maybe not the most brilliant way to go about it. Ended up inlining the whole thing.",
                                           "updatedAt":  "2020-11-03T20:21:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMTM4MDE4Ng==",
                                           "createdAt":  "2020-11-03T21:20:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "terrajobst",
                                           "body":  "Looks [we didn\u0027t like](https://github.com/dotnet/corefx/pull/26284#issuecomment-358805150) the API we approved.\r\n\r\n@GrabYourPitchforks, could take a look and make a proposal?",
                                           "updatedAt":  "2020-11-03T21:20:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMTQ4MTcxOQ==",
                                           "createdAt":  "2020-11-04T02:49:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "joshudson",
                                           "body":  "I looked at the existing proposal and understand why it wasn\u0027t liked. I then called up the actual code of ReadOnlyMemory\u003cT\u003e and studied the Span property.\r\n\r\nIn my opinion, the only reasonable implementation is to pin `_object` in memory via a fresh `GCHandle` and return a struct iterator from `GetEnumerator()` that implements `IEnumerable` via an actual pointer, and uses `Dispose()` to release the pin on `_object`. This results in no allocations and only one type ladder at loop startup, and only one allocation to pass it to a linq function. I suppose another implementation is possible that basically involves re-implementing the guts of `Span` but it\u0027s more dangerous than `GCHandle`.\r\n\r\nImplementation shortcut: `Memory\u003cT\u003e.GetEnumerator() =\u003e ((ReadOnlyMemory\u003cT\u003ethis).GetEnumerator();`\r\n\r\nThis is theoretically within my capacity to implement.",
                                           "updatedAt":  "2020-11-04T02:52:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMTc1NjUwNg==",
                                           "createdAt":  "2020-11-04T14:15:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCx4veQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "NetMage",
                                                                               "createdAt":  "2021-01-11T22:24:57Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kronic",
                                                                               "createdAt":  "2022-12-28T23:08:07Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "joshudson",
                                           "body":  "So this is my API proposal.\r\n\r\n````\r\npartial class System.Memory\u003cT\u003e: IReadOnlyCollection\u003cT\u003e {\r\n    public struct IReadOnlyMemory\u003cT\u003e.Enumerator GetEnumerator();\r\n    int IReadOnlyCollection\u003cT\u003e.Count =\u003e Length;\r\n    IEnumerator\u003cT\u003e IEnumerator\u003cT\u003e GetEnumerator() =\u003e GetEnumerator();\r\n    IEnumerator IEnumerator.GetEnumerator() =\u003e GetEnumerator();\r\n}\r\n\r\npartial class System.Memory\u003cT\u003e: IReadOnlyCollection\u003cT\u003e {\r\n    public struct Enumerator GetEnumerator();\r\n    int IReadOnlyCollection\u003cT\u003e.Count =\u003e Length;\r\n    IEnumerator\u003cT\u003e IEnumerator\u003cT\u003e GetEnumerator() =\u003e GetEnumerator();\r\n    IEnumerator IEnumerator.GetEnumerator() =\u003e GetEnumerator();\r\n\r\n    public struct Enumerator() : IEnumerable\u003cT\u003e {\r\n        public bool MoveNext();\r\n        public T Current { get ; }\r\n        public void Reset();\r\n    }\r\n}\r\n````\r\n\r\nRationale for `IReadOnlyCollection\u003cT\u003e`: It\u0027s just `IEnumerable\u003cT\u003e` + `Count` and it\u0027s a convenient flag interface for an enumerable that\u0027s not expected to change out from under the caller while the caller retains a reference to it. With this proposed implementation, it\u0027s about as good as an Array for being enumerated so there\u0027s no downside.",
                                           "updatedAt":  "2020-11-04T14:15:36Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMTc3OTMzNw==",
                                           "createdAt":  "2020-11-04T14:54:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e the only reasonable implementation is to pin _object in memory via a fresh GCHandle and return a struct iterator from GetEnumerator() that implements IEnumerable via an actual pointer, and uses Dispose() to release the pin on _object\r\n\r\nGCHandles are relatively expensive, using one in a struct-based enumerator would make it too easy to accidentally not free one or double-free one, and you can\u0027t have pointers to arbitrary `T`s (any `T` is possible in `Memory\u003cT\u003e`, not just `unmanaged` types).\r\n\r\nIf we want to add an enumerator for this, it\u0027ll simply access `.Span[i]` on each iteration.  If we want to specialize the implementation for `T[]` in an attempt to optimize for a common case, that could be done as well, assuming performance data proved it out.\r\n\r\ne.g. pseudo code with an iterator:\r\n```C#\r\nstatic IEnumerable\u003cT\u003e Iterate\u003cT\u003e(ReadOnlyMemory\u003cT\u003e memory)\r\n{\r\n    if (MemoryMarshal.TryGetArray(memory, out ArraySegment\u003cT\u003e segment))\r\n    {\r\n        T[] array = segment.Array;\r\n        int end = segment.Offset + segment.Count;\r\n        for (int i = segment.Offset; i \u003c end; i++)\r\n        {\r\n            yield return array[i];\r\n        }\r\n    }\r\n    else\r\n    {\r\n        for (int i = 0; i \u003c memory.Length; i++)\r\n        {\r\n            yield return memory.Span[i];\r\n        }\r\n    }\r\n}\r\n```",
                                           "updatedAt":  "2020-11-04T14:55:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMTc4NzYyNw==",
                                           "createdAt":  "2020-11-04T15:08:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "joshudson",
                                           "body":  "\u003e using one in a struct-based enumerator would make it too easy to accidentally not free one\r\n\r\nIn which case essentially all of the GCHandle sample code is really unsafe.\r\n\r\n````\r\n    var gc = GCHandle.Alloc(...);\r\n    try {\r\n        // Stuff here\r\n    } finally {\r\n        gc.Free();\r\n    }\r\n````\r\n\r\nIs splittable in .NET Framework (.NET Core can\u0027t split it in any way I know). And most of the sample code doesn\u0027t even use finally blocks.\r\n\r\nI had gotten part-way through the design of an enumerator that uses a string or an array (there\u0027s only 3 things it can be) before abandoning it. Maybe that\u0027s just better.",
                                           "updatedAt":  "2020-11-04T15:08:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMTc4ODIxMQ==",
                                           "createdAt":  "2020-11-04T15:09:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e In which case essentially all of the GCHandle sample code is really unsafe\r\n\r\nI don\u0027t understand the claim.  The above as a pattern isn\u0027t unsafe (if by \"splittable in .NET Framework\" you mean because of thread aborts, then yes, the code would need to be changed to be reliable in the face of aborts, moving the Alloc call into the try and testing the state of `gc` in the finally block, but 99.999% of code isn\u0027t thread-abort-safe, and it\u0027s incredibly hard to make it such, which is why they no longer exist in core).\r\n\r\nMy point was that if you have a struct-based Enumerator whose ctor creates a GCHandle and whose Dispose frees the handle, then a) the consumer of the Enumerator may fail to call Dispose on the struct and now you have a leak, or b) the consumer of the Enumerator may make a copy of the struct and then Dispose each, and now you have a double-free of a GCHandle.",
                                           "updatedAt":  "2020-11-04T15:16:09Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMTc5MDQyMw==",
                                           "createdAt":  "2020-11-04T15:13:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "joshudson",
                                           "body":  "Given the samples as they were, I was under the impression that GCHandle had to work by being found by the GC tracer. As I said, most of the samples don\u0027t have finally blocks so the GCHandles don\u0027t get freed on the inner code taking any exception.",
                                           "updatedAt":  "2020-11-04T15:13:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMTc5MTEyNg==",
                                           "createdAt":  "2020-11-04T15:14:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e most of the samples don\u0027t have finally blocks so the GCHandles don\u0027t get freed on the inner code taking any exception\r\n\r\nWhich samples?",
                                           "updatedAt":  "2020-11-04T15:14:21Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMTc5MjI0MA==",
                                           "createdAt":  "2020-11-04T15:16:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "joshudson",
                                           "body":  "Starting from https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.gchandle?view=netcore-3.1",
                                           "updatedAt":  "2020-11-04T15:16:08Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMTc5MzE3Ng==",
                                           "createdAt":  "2020-11-04T15:17:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Yes, that sample should be tweaked, at the very least to move the callback allocation to before the Alloc call.",
                                           "updatedAt":  "2020-11-04T15:17:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMTgwNDQ1OA==",
                                           "createdAt":  "2020-11-04T15:36:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "joshudson",
                                           "body":  "So what do you think of an implementation that looks like this? I started this path earlier and tossed when I thought of the pointer idea that\u0027s going to be more trouble than its worth.\r\n\r\n    struct Enumerator {\r\n        private T[] srcArray;\r\n        private string srcString;\r\n        private Utf8String srcUtf8String;\r\n        private int start; // For Reset()\r\n        private int offset;\r\n        private int stop;\r\n\r\n        bool MoveNext() { if (offset == stop) return false; /* prevent overflow */ return (++offset != stop); }\r\n        T Current =\u003e {\r\n             if (srcArray is object) return srcArray[offset];\r\n             if (srcString is object) return (T)srcString[offset]; /* T is char so cast should disappear at runtime */\r\n             if (srcUtf8String is object) return (T)srcUtf8String[offset];\r\n             throw new InvalidOperationException(\"...\");\r\n        }\r\n    }\r\n\r\nIf you\u0027re just going to enumerate by accessing the span and paying for the type ladder every time, I can do that in my own extension method.",
                                           "updatedAt":  "2020-11-04T15:37:35Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMTgwNjc3Ng==",
                                           "createdAt":  "2020-11-04T15:40:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBVu9oA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2020-11-04T16:02:05Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "GrabYourPitchforks",
                                                                               "createdAt":  "2020-11-04T19:15:49Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e So what do you think of an implementation that looks like this?\r\n\r\nThat logic effectively already exists (in a more optimized form) in the `Span` property.  It\u0027d be better to just keep things simple and use `.Span[i]` rather than trying to replicate the logic in Current.",
                                           "updatedAt":  "2020-11-04T15:40:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMTkyNDQ5OQ==",
                                           "createdAt":  "2020-11-04T19:19:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "If the goal is to pass a `ROM\u003cT\u003e` to a LINQ method, any struct-based enumerator is going to end up being boxed anyway. I\u0027d honestly rather implement a `MemoryExtensions.ToEnumerable` extension method which returns an `IEnumerable\u003cT\u003e`. The implementation of the `IEnumerable\u003cT\u003e` can be dynamically chosen based on what the `ROM\u003cT\u003e` is actually backed by: an array, a string, or something else. The method would be documented as \"yup, this allocates the enumerator, but the scenario was that you\u0027re going to pass it to LINQ anyway, so... 🤷‍♀️.\"\r\n\r\n```cs\r\npublic static class MemoryExtensions\r\n{\r\n    public static IEnumerable\u003cT\u003e ToEnumerable(this ReadOnlyMemory\u003cT\u003e memory);\r\n}\r\n```",
                                           "updatedAt":  "2020-11-04T19:19:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMTkyODcyNA==",
                                           "createdAt":  "2020-11-04T19:27:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "joshudson",
                                           "body":  "@GrabYourPitchforks : That\u0027s where we started at the top of the issue and the API team rejected it. So I acted on the reason that was found, that is it\u0027s a trap if you enumerate it directly.",
                                           "updatedAt":  "2020-11-04T19:27:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMzcwMzMwOA==",
                                           "createdAt":  "2020-11-09T01:24:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCqutCQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "NetMage",
                                                                               "createdAt":  "2020-12-08T20:42:45Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Timovzl",
                                                                               "createdAt":  "2022-08-17T18:53:05Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "@joshudson Not quite. The implementation I suggested is different and should avoid the performance concerns. I suggested deconstructing the `Memory\u003cT\u003e` instance _at the call to `ToEnumerable()`_, which means that the deconstruction cost occurs upfront when the enumerator is created - not on each call to `MoveNext`. The public API would look identical to what has already been approved.\r\n\r\nThings get complicated if you\u0027re backed by a `MemoryManager\u003cT\u003e` instead of a `string` or a `T[]`, and enumerating an instance of that would still incur some overhead. But that shouldn\u0027t represent the majority case.",
                                           "updatedAt":  "2020-11-09T01:24:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc440w-2",
                                           "createdAt":  "2021-10-27T22:25:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AqlaSolutions",
                                           "body":  "Any news?",
                                           "updatedAt":  "2021-10-27T22:25:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc443hMo",
                                           "createdAt":  "2021-10-28T18:04:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "terrajobst",
                                           "body":  "@GrabYourPitchforks are you driving this? If not, who should be?",
                                           "updatedAt":  "2021-10-28T18:04:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4442VD",
                                           "createdAt":  "2021-10-29T04:46:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCTUgxA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "terrajobst",
                                                                               "createdAt":  "2021-11-03T01:14:03Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "stephentoub",
                                                                               "createdAt":  "2022-03-11T15:01:51Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CodingMadness",
                                                                               "createdAt":  "2022-03-16T23:35:50Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "@terrajobst I\u0027m not currently driving this because it seems to be low-priority. The salient point in this issue that people really reacted to was Steve\u0027s comment at https://github.com/dotnet/runtime/issues/23950#issuecomment-339383091, and we did indeed eventually get _foreach_ support over `Span\u003cT\u003e` instances.\r\n\r\nIf the consensus is that we should add this API, I\u0027m very much partial to my most recent comments starting at https://github.com/dotnet/runtime/issues/23950#issuecomment-721924499, as I think those largely address the performance trap that people were concerned with.",
                                           "updatedAt":  "2021-10-29T04:46:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc45ItHw",
                                           "createdAt":  "2021-11-03T01:14:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "terrajobst",
                                           "body":  "Sounds good.",
                                           "updatedAt":  "2021-11-03T01:14:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_w1kf",
                                           "createdAt":  "2022-03-17T00:15:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CodingMadness",
                                           "body":  "Hey guys, \r\n\r\nso we can do: foreach on spans, and AFAIK .NET makes a promise to use Duck-Typing for such constructs, like GetPinnableReference() to be used in fixed(....) but why is the compiler not smart enough (.NET 6.0 ) to infer that Span\u003cT\u003e is duck-typed to an IEnumerable\u003cT\u003e without implementing it\r\n\r\nCause when an extension method takes a T, where T : IEnumerable\u003eT\u003e, it could use internal Duck-Typing to infer, the type actually does the same as it being an IEnumerable\u003cT\u003e.\r\n\r\nWould be really nice if .NET could make ducktyping a thing, i mean coding all these LINQ things will be quite ugly :D",
                                           "updatedAt":  "2022-03-17T00:15:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_ytYC",
                                           "createdAt":  "2022-03-17T03:46:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e why is the compiler not smart enough (.NET 6.0 ) to infer that Span is duck-typed to an IEnumerable without implementing it\r\n\r\nC# compiler does infer that in .NET 6. `foreach` works on Span for several years. More discussion on this is captured in https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-12-04.md#foreach-for-span-and-readonlyspan . The discussion on duck-typing is more appropriate for https://github.com/dotnet/csharplang repo.",
                                           "updatedAt":  "2022-03-17T03:46:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_048V",
                                           "createdAt":  "2022-03-17T11:47:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CodingMadness",
                                           "body":  "\u003e C# compiler does infer that in .NET 6. `foreach` works on Span for several years.\r\n\r\nI already said that, good Sir, namely below: \r\n@jkotas \r\n\u003e so we can do: foreach on spans\r\n\r\nThis is a good thing, its just, we cannot make use of the Enumerable-LINQ-Extension methods sadly, cause the Compiler still strictly wants the callee of these methods to be of type IEnumerable\u003cT\u003e.\r\n\r\nThat is my Dilemma",
                                           "updatedAt":  "2022-03-17T11:47:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_1BlG",
                                           "createdAt":  "2022-03-17T12:31:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e cause the Compiler still strictly wants the callee of these methods to be of type IEnumerable.\r\n\r\nThe C# compiler couldn\u0027t fabricate a wrapper IEnumerable for the same reason Span doesn\u0027t implement IEnumerable: it\u0027s a ref struct that can\u0027t be boxed or otherwise copied to the heap. ",
                                           "updatedAt":  "2022-03-17T12:52:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_1aAU",
                                           "createdAt":  "2022-03-17T14:24:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CodingMadness",
                                           "body":  "@stephentoub yea ok, wanted just to get sure on this! Thanks and have a good and healthy Week!",
                                           "updatedAt":  "2022-03-17T14:24:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_1eBn",
                                           "createdAt":  "2022-03-17T15:13:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD8XGZg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CodingMadness",
                                                                               "createdAt":  "2022-03-20T01:09:23Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "theodorzoulias",
                                                                               "createdAt":  "2022-12-06T19:42:04Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "scharnyw",
                                                                               "createdAt":  "2024-11-25T09:20:28Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "Joe4evr",
                                           "body":  "@Shpendicus For what it\u0027s worth: [SpanLinq](https://github.com/YairHalberstadt/SpanLinq)",
                                           "updatedAt":  "2022-03-17T15:13:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_9tcE",
                                           "createdAt":  "2022-03-20T01:10:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD8XGUw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "scharnyw",
                                                                               "createdAt":  "2024-11-25T09:20:20Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "CodingMadness",
                                           "body":  "@Joe4evr i think they are on a really good track, I also saw a nuget package called: **NoAlloc** maybe you can try that one aswell 🗡️ ",
                                           "updatedAt":  "2022-03-20T01:10:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5P3YeT",
                                           "createdAt":  "2022-12-06T19:44:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODr6wag==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "qwertie",
                                                                               "createdAt":  "2024-07-29T08:05:37Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "eiriktsarpalis",
                                           "body":  "Marking as ready-for-review in light of the discussion in https://github.com/dotnet/runtime/issues/77209#issuecomment-1339857514. It has been suggested that `ReadOnlyMemory\u003cT\u003e` implementing `IEnumerable\u003cT\u003e` directly is desirable, since it would avoid the need for a dedicated \r\n```C#\r\nIEqualityComparer\u003cReadOnlyMemory\u003cT\u003e\u003e CreateMemoryComparer\u003cT\u003e(IEqualityComparer\u003cT\u003e)\r\n``` \r\nmethod and we can specialize the already approved\r\n```C#\r\nIEqualityComparer\u003cTEnumerable\u003e CreateEnumerableComparer\u003cTEnumerable, T\u003e(IEqualityComparer\u003cT\u003e) where TEnumerable : IEnumerable\u003cT\u003e\r\n``` \r\nmethod instead.",
                                           "updatedAt":  "2022-12-06T19:45:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iBAt0",
                                           "createdAt":  "2023-07-20T18:53:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODBVmsA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "terrajobst",
                                                                               "createdAt":  "2023-07-20T19:46:13Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "bartonjs",
                                           "body":  "[Video](https://www.youtube.com/watch?v=XKrNmVjiEpY\u0026t=1h20m52s)\n\nThis came up in API Review, and the main question that we had was \"why is `MemoryMarshal.ToEnumerable(ReadOnlyMemory\u003cT\u003e)` not good enough?\".  We didn\u0027t seem to see any discussion related to that existing member.",
                                           "updatedAt":  "2023-07-20T19:06:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iB7vo",
                                           "createdAt":  "2023-07-20T22:05:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jhudsoncedaron",
                                           "body":  "@bartonjs : I just now looked into it. It looks like this issue is an example of discovery fail. Oof. I would never think to look in namespace interopservices for something like that.\r\n\r\nIt\u0027s also a pretty terrible implementation, performance-wise. I left behind a much faster one in a comment above.",
                                           "updatedAt":  "2023-07-20T22:05:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iB_wH",
                                           "createdAt":  "2023-07-20T22:14:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "terrajobst",
                                           "body":  "\u003e I just now looked into it. It looks like this issue is an example of discovery fail. Oof. I would never think to look in namespace interopservices for something like that.\r\n\r\nThat\u0027s fair. I don\u0027t recall why we put it there but it seems to suggest the intent was to make it less discoverable.\r\n\r\n\u003e It\u0027s also a pretty terrible implementation, performance-wise. I left behind a much faster one in a comment above.\r\n\r\nI think this depends on what you want to achieve. If you just want to enumerate the contents in a `foreach` loop, then you shouldn\u0027t use this API at all. You should get the span once and `foreach` the span which the compiler will basically emit as `for` loop over the span and the JIT will probably be able to hoist bound checks outside the loop, which is as performant as you can get.\r\n\r\nBut if you need to pass the memory to an API that wants an `IEnumerable\u003cT\u003e` then you need to allocate a class. You could try to play tricks to avoid the allocation of the enumerator but that isn\u0027t necessarily safe if you want to allow multiple enumerations from the same instance. And I don\u0027t think the implementation can avoid requesting the span for each element, which isn\u0027t that cheap either. But I think all this overhead comes from the fact that the caller wants to go through `IEnumerable\u003cT\u003e`.\r\n\r\nCome to think of it, I believe we didn\u0027t want an API like `memory.ToEnumerable()` because it seems like a performance trap.",
                                           "updatedAt":  "2023-07-20T22:18:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iCBTX",
                                           "createdAt":  "2023-07-20T22:22:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jhudsoncedaron",
                                           "body":  "\"And I don\u0027t think the implementation can avoid requesting the span for each element\"\r\n\r\nYes it can. Since it is inside System.Private.CoreLib it can unwrap the Memory\u003cT\u003e, which is what I posted. Oh well.",
                                           "updatedAt":  "2023-07-20T22:22:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iCB4_",
                                           "createdAt":  "2023-07-20T22:25:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "terrajobst",
                                           "body":  "I can\u0027t seem to find your comment. Could you link it?",
                                           "updatedAt":  "2023-07-20T22:25:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iCB9b",
                                           "createdAt":  "2023-07-20T22:25:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODBWWqQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "terrajobst",
                                                                               "createdAt":  "2023-07-20T22:31:57Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "DaZombieKiller",
                                           "body":  "The APIs for unwrapping a `Memory\u003cT\u003e` are actually public (`MemoryMarshal.TryGetArray`, `MemoryMarshal.TryGetString` and `MemoryMarshal.TryGetMemoryManager`) so even if the method wasn\u0027t in the BCL it could do that.\r\n\r\nThe problem is when the `Memory\u003cT\u003e` isn\u0027t backed by a string or an array but rather a `MemoryManager`. The implementation could be made more efficient by using `Pin`, but as mentioned in API review it would most likely require a finalizer which would be non-ideal.",
                                           "updatedAt":  "2023-07-20T22:25:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iCDvJ",
                                           "createdAt":  "2023-07-20T22:31:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "terrajobst",
                                           "body":  "I see, you\u0027re suggesting an implementation for `ToEnumerable()` that can special case specific underlying types for a span (such as arrays and strings) and provide an implementation that wouldn\u0027t have to get the span for each element. I think that\u0027s fair and seems quite doable. For short spans, this might make it worse though, but we could measure that. For native memory or custom memory managers it would probably continue to be somewhat inefficient if we want some amount of safety. However, I can buy that these scenarios are more rare in practice as they most likely deal with byte buffers which one generally doesn\u0027t want to enumerate but parse.\r\n\r\nPersonally, I\u0027m somewhat questioning how common of a problem memory-\u003eenumerable is in practice. To some extent, I think of these features as opposites.",
                                           "updatedAt":  "2023-07-20T22:33:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iCKwX",
                                           "createdAt":  "2023-07-20T22:48:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "DaZombieKiller",
                                           "body":  "We\u0027re essentially entering the space of \"niche within niche\" here, but if you want to allow as many cases to be efficient as possible, it may make sense to add a new `virtual` method to `MemoryManager`:\r\n\r\n```cs\r\nnamespace System.Buffers;\r\n\r\npublic abstract partial class MemoryManager\u003cT\u003e\r\n{\r\n    public virtual IEnumerable\u003cT\u003e ToEnumerable()\r\n    {\r\n        // Default implementation using \u0027yield return\u0027\r\n    }\r\n}\r\n```\r\n\r\nAn example of the kind of code that might benefit from this is in the community toolkit. [There are APIs in the toolkit that offer the equivalent of `MemoryMarshal.Cast` for `Memory\u003cT\u003e` instances](https://github.com/CommunityToolkit/dotnet/blob/e071ed22b379f904820475db827be3ad04d3e96e/src/CommunityToolkit.HighPerformance/Extensions/ReadOnlyMemoryExtensions.cs#L82-L132), which hand back `MemoryManager\u003cT\u003e`-backed `Memory\u003cT\u003e`s that provide `MemoryMarshal.Cast`-ed `Span\u003cT\u003e`s. Having that extra virtual would allow those `MemoryManager`s (and any others like them) to avoid the performance penalty associated with the default `yield return` implementation.\r\n\r\nIs that worth it for such a niche use case though? I\u0027m skeptical.",
                                           "updatedAt":  "2023-07-20T22:51:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iCPUJ",
                                           "createdAt":  "2023-07-20T22:58:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODIbqIA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "CodingMadness",
                                                                               "createdAt":  "2023-10-03T04:14:47Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e It\u0027s also a pretty terrible implementation, performance-wise.\r\n\r\nhttps://github.com/dotnet/runtime/pull/89274 I put up earlier fixes that. ",
                                           "updatedAt":  "2023-07-20T22:58:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iCapx",
                                           "createdAt":  "2023-07-20T23:58:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jhudsoncedaron",
                                           "body":  "@stephentoub  Ah good that problem\u0027s going away.",
                                           "updatedAt":  "2023-07-20T23:58:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5trrvG",
                                           "createdAt":  "2023-12-05T07:41:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ionoy",
                                           "body":  "Is there a reason this wasn\u0027t exposed as an extension method?",
                                           "updatedAt":  "2023-12-05T07:41:03Z"
                                       }
                                   ],
                         "totalCount":  62
                     },
        "title":  "Provide IEnumerable\u003cT\u003e support for Memory\u003cT\u003e",
        "labels":  [
                       "api-needs-work",
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/24139",
        "createdAt":  "2017-11-14T22:57:42Z",
        "number":  24139,
        "author":  "Drawaes",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-01-16T04:42:23Z",
        "body":  "/cc @AtsushiKan\r\n\r\nref dotnet/corefx#24497\r\n\r\nFrom System.Memory.Tests\r\n\r\nSuspected test : (thanks @benaadams ) At a guess... would be the ParserTests.2gbOverflow which needs 4 * 2BG \u003e 8 GB to run\r\n\r\n```\r\nExecuted on dw7opv3vs0003HH\r\n2017-11-14 20:31:24,865: INFO: scriptrunner(33): _main: BuildTools Helix Script Runner v0.1 starting\r\n2017-11-14 20:31:24,865: INFO: helix_test_execution(24): __init__: Copying execution payload files from C:\\dotnetbuild\\work\\0f6bf7e2-4ce4-4832-b62e-da821b97c51b\\Work\\4b5eacd6-b225-4ea9-a5f7-441d3c2eba3b\\Unzip to C:\\dotnetbuild\\work\\0f6bf7e2-4ce4-4832-b62e-da821b97c51b\\Work\\4b5eacd6-b225-4ea9-a5f7-441d3c2eba3b\\Exec\\execution\r\n2017-11-14 20:31:24,865: INFO: io(27): copy_tree_to: Copying \u0027C:\\dotnetbuild\\work\\0f6bf7e2-4ce4-4832-b62e-da821b97c51b\\Work\\4b5eacd6-b225-4ea9-a5f7-441d3c2eba3b\\Unzip\\RunTests.cmd\u0027 to \u0027C:\\dotnetbuild\\work\\0f6bf7e2-4ce4-4832-b62e-da821b97c51b\\Work\\4b5eacd6-b225-4ea9-a5f7-441d3c2eba3b\\Exec\\execution\\RunTests.cmd\u0027\r\n2017-11-14 20:31:24,865: INFO: io(27): copy_tree_to: Copying \u0027C:\\dotnetbuild\\work\\0f6bf7e2-4ce4-4832-b62e-da821b97c51b\\Work\\4b5eacd6-b225-4ea9-a5f7-441d3c2eba3b\\Unzip\\System.Memory.Tests.dll\u0027 to \u0027C:\\dotnetbuild\\work\\0f6bf7e2-4ce4-4832-b62e-da821b97c51b\\Work\\4b5eacd6-b225-4ea9-a5f7-441d3c2eba3b\\Exec\\execution\\System.Memory.Tests.dll\u0027\r\n2017-11-14 20:31:24,865: INFO: io(27): copy_tree_to: Copying \u0027C:\\dotnetbuild\\work\\0f6bf7e2-4ce4-4832-b62e-da821b97c51b\\Work\\4b5eacd6-b225-4ea9-a5f7-441d3c2eba3b\\Unzip\\System.Memory.Tests.pdb\u0027 to \u0027C:\\dotnetbuild\\work\\0f6bf7e2-4ce4-4832-b62e-da821b97c51b\\Work\\4b5eacd6-b225-4ea9-a5f7-441d3c2eba3b\\Exec\\execution\\System.Memory.Tests.pdb\u0027\r\n2017-11-14 20:31:24,880: INFO: io(27): copy_tree_to: Copying \u0027C:\\dotnetbuild\\work\\0f6bf7e2-4ce4-4832-b62e-da821b97c51b\\Work\\4b5eacd6-b225-4ea9-a5f7-441d3c2eba3b\\Unzip\\xunit.console.netcore.exe\u0027 to \u0027C:\\dotnetbuild\\work\\0f6bf7e2-4ce4-4832-b62e-da821b97c51b\\Work\\4b5eacd6-b225-4ea9-a5f7-441d3c2eba3b\\Exec\\execution\\xunit.console.netcore.exe\u0027\r\n2017-11-14 20:31:24,880: INFO: io(27): copy_tree_to: Copying \u0027C:\\dotnetbuild\\work\\0f6bf7e2-4ce4-4832-b62e-da821b97c51b\\Work\\4b5eacd6-b225-4ea9-a5f7-441d3c2eba3b\\Unzip\\xunit.console.netcore.runtimeconfig.json\u0027 to \u0027C:\\dotnetbuild\\work\\0f6bf7e2-4ce4-4832-b62e-da821b97c51b\\Work\\4b5eacd6-b225-4ea9-a5f7-441d3c2eba3b\\Exec\\execution\\xunit.console.netcore.runtimeconfig.json\u0027\r\n2017-11-14 20:31:24,880: INFO: proc(23): run_and_log_output: Running: C:\\dotnetbuild\\work\\0f6bf7e2-4ce4-4832-b62e-da821b97c51b\\Work\\4b5eacd6-b225-4ea9-a5f7-441d3c2eba3b\\Unzip\\RunTests.cmd C:\\dotnetbuild\\work\\0f6bf7e2-4ce4-4832-b62e-da821b97c51b\\Payload\r\n2017-11-14 20:31:24,880: INFO: proc(26): run_and_log_output: CWD: C:\\dotnetbuild\\work\\0f6bf7e2-4ce4-4832-b62e-da821b97c51b\\Work\\4b5eacd6-b225-4ea9-a5f7-441d3c2eba3b\\Unzip\r\n2017-11-14 20:31:24,895: INFO: proc(54): run_and_log_output: Output: Using C:\\dotnetbuild\\work\\0f6bf7e2-4ce4-4832-b62e-da821b97c51b\\Payload as the test runtime folder.\r\n2017-11-14 20:31:24,895: INFO: proc(54): run_and_log_output: Output: Executing in C:\\dotnetbuild\\work\\0f6bf7e2-4ce4-4832-b62e-da821b97c51b\\Work\\4b5eacd6-b225-4ea9-a5f7-441d3c2eba3b\\Unzip\\ \r\n2017-11-14 20:31:24,895: INFO: proc(54): run_and_log_output: Output: Running tests... Start time: 20:31:24.89\r\n2017-11-14 20:31:24,895: INFO: proc(54): run_and_log_output: Output: \r\n2017-11-14 20:31:24,895: INFO: proc(54): run_and_log_output: Output: C:\\dotnetbuild\\work\\0f6bf7e2-4ce4-4832-b62e-da821b97c51b\\Work\\4b5eacd6-b225-4ea9-a5f7-441d3c2eba3b\\Unzip\u003eset XUNIT_PERFORMANCE_MIN_ITERATION=1 \r\n2017-11-14 20:31:24,895: INFO: proc(54): run_and_log_output: Output: \r\n2017-11-14 20:31:24,895: INFO: proc(54): run_and_log_output: Output: C:\\dotnetbuild\\work\\0f6bf7e2-4ce4-4832-b62e-da821b97c51b\\Work\\4b5eacd6-b225-4ea9-a5f7-441d3c2eba3b\\Unzip\u003eset XUNIT_PERFORMANCE_MAX_ITERATION=1 \r\n2017-11-14 20:31:24,895: INFO: proc(54): run_and_log_output: Output: \r\n2017-11-14 20:31:24,895: INFO: proc(54): run_and_log_output: Output: C:\\dotnetbuild\\work\\0f6bf7e2-4ce4-4832-b62e-da821b97c51b\\Work\\4b5eacd6-b225-4ea9-a5f7-441d3c2eba3b\\Unzip\u003ecall C:\\dotnetbuild\\work\\0f6bf7e2-4ce4-4832-b62e-da821b97c51b\\Payload\\dotnet.exe xunit.console.netcore.exe System.Memory.Tests.dll  -xml testResults.xml -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=failing \r\n2017-11-14 20:31:24,990: INFO: proc(54): run_and_log_output: Output: xUnit.net console test runner (64-bit .NET Core)\r\n2017-11-14 20:31:24,990: INFO: proc(54): run_and_log_output: Output: Copyright (C) 2014 Outercurve Foundation.\r\n2017-11-14 20:31:24,990: INFO: proc(54): run_and_log_output: Output: \r\n2017-11-14 20:31:25,084: INFO: proc(54): run_and_log_output: Output: Discovering: System.Memory.Tests\r\n2017-11-14 20:31:25,411: INFO: proc(54): run_and_log_output: Output: Discovered:  System.Memory.Tests\r\n2017-11-14 20:31:25,693: INFO: proc(54): run_and_log_output: Output: Starting:    System.Memory.Tests\r\n2017-11-14 20:31:27,661: INFO: proc(54): run_and_log_output: Output: [ParseInt32 \u00270\u0027,D to 0)]\r\n2017-11-14 20:31:48,457: INFO: proc(54): run_and_log_output: Output: [ParseInt32 \u00272\u0027,D to 2)]\r\n2017-11-14 20:32:06,128: INFO: proc(54): run_and_log_output: Output: [ParseInt32 \u002721\u0027,D to 21)]\r\n2017-11-14 20:32:23,223: INFO: proc(54): run_and_log_output: Output: [ParseInt32 \u0027+2\u0027,D to 2)]\r\n2017-11-14 20:32:40,924: INFO: proc(54): run_and_log_output: Output: [ParseInt32 \u0027-2\u0027,D to -2)]\r\n2017-11-14 20:32:57,706: INFO: proc(54): run_and_log_output: Output: [ParseInt32 \u00272147483647\u0027,D to 2147483647)]\r\n2017-11-14 20:33:14,471: INFO: proc(54): run_and_log_output: Output: [ParseInt32 \u0027-2147483648\u0027,D to -2147483648)]\r\n2017-11-14 20:33:31,707: INFO: proc(54): run_and_log_output: Output: [ParseInt32 \u00272147483648\u0027,D to (should-not-parse))]\r\n2017-11-14 20:33:48,144: INFO: proc(54): run_and_log_output: Output: [ParseInt32 \u0027-2147483649\u0027,D to (should-not-parse))]\r\n2017-11-14 20:34:00,503: INFO: proc(54): run_and_log_output: Output: [ParseInt32 \u002712345abcdefg1\u0027,D to 12345)]\r\n2017-11-14 20:34:11,926: INFO: proc(54): run_and_log_output: Output: [ParseInt32 \u00271234145abcdefg1\u0027,D to 1234145)]\r\n2017-11-14 20:34:23,176: INFO: proc(54): run_and_log_output: Output: [ParseInt32 \u0027abcdefghijklmnop1\u0027,D to 0)]\r\n2017-11-14 20:34:34,815: INFO: proc(54): run_and_log_output: Output: [ParseInt32 \u00271147483648\u0027,D to 1147483648)]\r\n2017-11-14 20:34:46,362: INFO: proc(54): run_and_log_output: Output: [ParseInt32 \u0027-1147483649\u0027,D to -1147483649)]\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOmhcJXA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM1NDg3NDExNg==",
                                           "createdAt":  "2018-01-02T21:00:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "@ahsonkhan - is there still a reason for this to be open?\r\n",
                                           "updatedAt":  "2018-01-02T21:00:51Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM1NDg3OTA2NA==",
                                           "createdAt":  "2018-01-02T21:24:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e is there still a reason for this to be open?\r\n\r\nYes, tests are still disabled against it.",
                                           "updatedAt":  "2018-01-02T21:24:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM1NDg4ODg2OA==",
                                           "createdAt":  "2018-01-02T22:11:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Can\u0027t repro this locally. \r\n\r\nWas it hung in one of those two tests or was the hang appearing somewhere else as a result of these two tests existing?\r\n\r\nThese two tests are the only ones performing two big allocations in a single test, but I can\u0027t come up with a theory of why that would be problematic. They\u0027re also among the hoggiest tests (8Gb) - could be they\u0027re just causing random OM exceptions in some other test that isn\u0027t a \"big allocation\" test?\r\n\r\n\r\n\r\n",
                                           "updatedAt":  "2018-01-02T22:11:10Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM1NDg5NzM2Nw==",
                                           "createdAt":  "2018-01-02T22:55:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "Can it use a MemoryMappedFile  instead of allocating 8Gb of RAM? Used to give my computer a fit when it was in corefxlab and I ran it:\r\n\r\n![image](https://user-images.githubusercontent.com/1142958/34503380-e31b57de-f00f-11e7-8abc-79c254b0d73f.png)\r\n\r\nCan the tests potentially run in parallel so need 16Gb?",
                                           "updatedAt":  "2018-01-02T22:55:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM1NDg5OTQwNQ==",
                                           "createdAt":  "2018-01-02T23:06:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "Everything would die on the test with nothing running after; last output when details output was on was:\r\n```\r\n2017-11-15 15:46:24,285: INFO: proc(54): run_and_log_output: \r\nOutput:    System.SpanTests.SpanTests.CopyToLargeSizeTest(bufferSize: 4294967296) [STARTING]\r\n```\r\nMy local experience was Windows was very unhappy working swap for a single contiguous block of memory larger than available memory. It did eventually complete after total system unresponsiveness",
                                           "updatedAt":  "2018-01-02T23:06:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM1NDkwMTAwNg==",
                                           "createdAt":  "2018-01-02T23:16:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Drawaes",
                                           "body":  "Yeah but it also doesn\u0027t run in isolation, so it truly kills the test run.",
                                           "updatedAt":  "2018-01-02T23:16:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM1NDkwMTg4NA==",
                                           "createdAt":  "2018-01-02T23:21:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Are we reasonably confident a MemoryMappedFile for 8gb won\u0027t cause the same agony as a 8gb memory allocation? \r\n\r\nThe AllocationHelper serializes big memory tests that uses it so they shouldn\u0027t be running in parallel. \r\n",
                                           "updatedAt":  "2018-01-02T23:21:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM1NDkwNDk5MQ==",
                                           "createdAt":  "2018-01-02T23:41:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "Don\u0027t know; however it only pretends to be contiguous memory and files can often be far larger than RAM - so hopefully the disk cache will be more used to it than the swap with actual live allocated memory",
                                           "updatedAt":  "2018-01-02T23:41:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM1NTU5MjUzOA==",
                                           "createdAt":  "2018-01-05T16:07:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "@benaadams - if you still have that computer, can you trying building this branch and running SpanTests.CopyToLargeSizeTest to see if switching to memory-mapped files still brings the puter to its knees?\r\n\r\nhttps://github.com/AtsushiKan/corefx/tree/test\r\n",
                                           "updatedAt":  "2018-01-05T16:07:09Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM2Mjk1MzAzNw==",
                                           "createdAt":  "2018-02-05T00:21:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ahsonkhan",
                                           "body":  "@AtsushiKan, is this issue still relevant or can it be closed?",
                                           "updatedAt":  "2018-02-05T00:21:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQxODg2NDQ0NA==",
                                           "createdAt":  "2018-09-05T20:08:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Closing due to age. If problems persist, there should be a specific issue opened.",
                                           "updatedAt":  "2018-09-05T20:08:09Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQxODg2ODMzMA==",
                                           "createdAt":  "2018-09-05T20:21:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Tests are still disabled against this, e.g. https://github.com/dotnet/corefx/blob/a10890f4ffe0fadf090c922578ba0e606ebdd16c/src/System.Memory/tests/ReadOnlySpan/CopyTo.cs#L131",
                                           "updatedAt":  "2018-09-05T20:21:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6KeY7k",
                                           "createdAt":  "2024-09-01T08:05:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Due to lack of recent activity, this issue has been marked as a candidate for backlog cleanup.  It will be closed if no further activity occurs within 14 more days. Any new comment (by anyone, not necessarily the author) will undo this process.\n\nThis process is part of our [issue cleanup automation](https://github.com/dotnet/runtime/blob/main/docs/issue-cleanup.md).\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-09-01T08:05:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6MKf3P",
                                           "createdAt":  "2024-09-15T12:03:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "This issue will now be closed since it had been marked `no-recent-activity` but received no further activity in the past 14 days. It is still possible to reopen or comment on the issue, but please note that the issue will be locked if it remains inactive for another 30 days.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-09-15T12:03:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6aFwlc",
                                           "createdAt":  "2025-01-11T10:48:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "There are still tests disabled against this issue",
                                           "updatedAt":  "2025-01-11T10:48:23Z"
                                       }
                                   ],
                         "totalCount":  15
                     },
        "title":  "Large memory test fails on outerloop",
        "labels":  [
                       "area-System.Memory",
                       "disabled-test",
                       "test-bug"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/24990",
        "createdAt":  "2018-02-09T17:00:08Z",
        "number":  24990,
        "author":  "sharwell",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODESocA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "4creators",
                                            "createdAt":  "2018-02-09T22:29:06Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jnm2",
                                            "createdAt":  "2018-02-09T22:43:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Tornhoof",
                                            "createdAt":  "2018-02-10T18:48:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ygc369",
                                            "createdAt":  "2018-02-11T01:13:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Wraith2",
                                            "createdAt":  "2022-01-23T00:58:16Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "wzchua",
                                            "createdAt":  "2022-01-23T06:41:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "vcsjones",
                                            "createdAt":  "2022-11-27T19:15:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MineCake147E",
                                            "createdAt":  "2023-10-07T10:34:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "msedi",
                                            "createdAt":  "2023-11-05T14:03:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "yhyu13",
                                            "createdAt":  "2024-04-10T04:46:03Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "matburton",
                                            "createdAt":  "2025-01-24T17:16:18Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "watk",
                                            "createdAt":  "2025-02-08T05:03:20Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ezhevita",
                                            "createdAt":  "2025-06-19T13:44:58Z"
                                        }
                                    ],
                          "totalCount":  13
                      },
        "updatedAt":  "2022-01-23T00:36:16Z",
        "body":  "## Summary\r\n\r\nThis proposal simplifies the use of disposable resources shared through code where single owner of the resource is either unclear, or complicates maintenance of the code. This situation is increasingly common when asynchronous code which needs to operate on a threading-agnostic API where the `Dispose` operation is explicitly called out as not safe for concurrent use.\r\n\r\nThe semantics of a safe, shared wrapper for `IDisposable` objects is challenging, especially when considerations are made for handling missing and/or multiple calls to `Dispose` and for weakly-held references. Providing a holder for managing lifetimes of these objects allows developers to focus on the semantics of the underlying shared object, which is always a challenge in itself.\r\n\r\n## Proposed API\r\n\r\n```csharp\r\nnamespace System.Memory\r\n{\r\n  public sealed class ReferenceCountedDisposable\u003cT\u003e : IDisposable\r\n    where T : class, IDisposable\r\n  {\r\n    public ReferenceCountedDisposable(T instance);\r\n\r\n    public T Target { get; }\r\n\r\n    public ReferenceCountedDisposable\u003cT\u003e TryAddReference();\r\n    public void Dispose();\r\n\r\n    public struct WeakReference\r\n    {\r\n      public WeakReference(ReferenceCountedDisposable\u003cT\u003e reference);\r\n\r\n      public ReferenceCountedDisposable\u003cT\u003e TryAddReference();\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## Semantics\r\n\r\nA reference-counting wrapper which allows multiple uses of a single disposable object in code, which is deterministically released (by calling `IDisposable.Dispose`) when the last reference is disposed.\r\n\r\nEach instance of `ReferenceCountedDisposable\u003cT\u003e` represents a counted reference (also referred to as a *reference* in the following documentation) to a target object. Each of these references has a lifetime, starting when it is constructed and continuing through its release. During this time, the reference is considered *alive*. Each reference which is alive owns exactly one reference to the target object, ensuring that it will not be disposed while still in use. A reference is released through either of the following actions:\r\n\r\n* The reference is explicitly released by a call to `Dispose`.\r\n* The reference is no longer in use by managed code and gets reclaimed by the garbage collector.\r\n\r\nWhile each instance of `ReferenceCountedDisposable\u003cT\u003e` should be explicitly disposed when the object is no longer needed by the code owning the reference, this implementation will not leak resources in the event one or more callers fail to do so. When all references to an object are explicitly released (i.e. by calling `Dispose`), the target object will itself be deterministically released by a call to `IDisposable.Dispose` when the last reference to it is released. However, in the event one or more references is not explicitly released, the underlying object will still become eligible for non-deterministic release (i.e. finalization) as soon as each reference to it is released by one of the two actions described previously.\r\n\r\nWhen using `ReferenceCountedDisposable\u003cT\u003e`, certain steps must be taken to ensure the target object is not disposed early.\r\n\r\n1. Use `ReferenceCountedDisposable\u003cT\u003e` consistently. In other words, do not mix code using reference-counted wrappers with code that references to the target directly.\r\n1. Only use the `ReferenceCountedDisposable\u003cT\u003e(T reference)` constructor one time per target object. Additional references to the same target object must only be obtained by calling `TryAddReference`.\r\n1. Do not call `IDisposable.Dispose` on the target object directly. It will be called automatically at the appropriate time, as described above.\r\n\r\nAll public methods on this type adhere to their pre- and post-conditions and will not invalidate state even in concurrent execution.\r\n\r\n### `ReferenceCountedDisposable\u003cT\u003e.TryAddReference`\r\n\r\nIncrements the reference count for the disposable object, and returns a new disposable reference to it. The returned object is an independent reference to the same underlying object. Disposing of the returned value multiple times will only cause the reference count to be decreased once.\r\n\r\nReturn value: a new `ReferenceCountedDisposable\u003cT\u003e` pointing to the same underlying object, if it has not yet been disposed; otherwise, `null` if this reference to the underlying object has already been disposed.\r\n\r\n### `ReferenceCountedDisposable\u003cT\u003e.WeakReference`\r\n\r\nRepresents a weak reference to a `ReferenceCountedDisposable\u003cT\u003e` which is capable of obtaining a new counted reference up until the point when the object is no longer accessible.\r\n\r\n### Differences between `TryAddReference` operations\r\n\r\nThe semantics of `ReferenceCountedDisposable\u003cT\u003e.TryAddReference` and `ReferenceCountedDisposable\u003cT\u003e.WeakReference.TryAddReference` are slightly different:\r\n\r\n* `ReferenceCountedDisposable\u003cT\u003e.TryAddReference`: This method returns `null` after *this reference* is disposed. In other words, it is possible for other references to the target object to still be held in code.\r\n* `ReferenceCountedDisposable\u003cT\u003e.WeakReference.TryAddReference`: This method returns `null` after *the last reference* to the target object is disposed.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOPMKTGw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM2NDUwNDI0OA==",
                                           "createdAt":  "2018-02-09T17:38:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sharwell",
                                           "body":  "## Example: Sharing memory mapped files\r\n\r\nRoslyn uses memory mapped files as a temporary data store to move infrequently-used data outside of the process. We found that closing memory mapped files is not instant, and holding a few thousand small instances had a noticeable impact on application shutdown performance. To improve overall performance, we moved from using individual files for units of data to using larger files capable of holding many pieces of data.\r\n\r\nDuring the transition, we moved from each data referencing its own memory mapped file to many data pieces referencing shared files. However, from the perspective of each individual data point it is beneficial to reason about the handle as still being owned by itself.\r\n\r\nImplementing this solution resulted in the following:\r\n\r\n* The shared service that manages memory mapped files holds a weak reference (`ReferenceCountedDisposable\u003cT\u003e.WeakReference`) to the most recently used memory mapped file which contains free storage space.\r\n* Data units each hold a `ReferenceCountedDisposable\u003cT\u003e` to the memory mapped file.\r\n* As long as one or more data units is still alive and using this file for storage, the service can use the weak reference to access the file (which is guaranteed to still be open) and allocate additional storage within it.\r\n* When the last data unit is disposed, the memory mapped file automatically and deterministically closes. However, each data unit continues to manage its own lifetime.\r\n\r\nThe change resulted in a reduction from several tens of thousands of memory mapped files to at most a few hundred. Local reasoning in the implementation was largely unchanged (a good thing), and the application as a whole used fewer resources (dotnet/roslyn#20439) and substantially improved shutdown performance (dotnet/roslyn#19493).",
                                           "updatedAt":  "2018-02-09T17:38:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM2NDU5MjQzNw==",
                                           "createdAt":  "2018-02-09T22:51:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jnm2",
                                           "body":  "If someone passes me a `ReferenceCountedDisposable\u003cFoo\u003e`, how do I know when to access `Target` directly versus calling `TryAddReference` first? Do I do the latter only if I\u0027m letting it escape the stack?",
                                           "updatedAt":  "2018-02-09T22:51:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM2NDU5MzU2MQ==",
                                           "createdAt":  "2018-02-09T22:57:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sharwell",
                                           "body":  "@jnm2 In our usage patterns, if you get an instance, you own that instance.",
                                           "updatedAt":  "2018-02-09T22:57:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM2NDU5NTk4OA==",
                                           "createdAt":  "2018-02-09T23:11:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jnm2",
                                           "body":  "@sharwell Cool. Found:\r\n\r\n[`TryAddReference` usages](http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Utilities/ReferenceCountedDisposable.cs,21b2df1541c1a160,references)\r\n\r\n[`WeakReference` `TryAddReference` usages](http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Utilities/ReferenceCountedDisposable.cs,51f570b93fca8612,references)",
                                           "updatedAt":  "2018-02-09T23:11:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc45hdhn",
                                           "createdAt":  "2021-11-10T12:12:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODm6reA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "M-L-Ml",
                                                                               "createdAt":  "2024-06-24T16:33:21Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "StephenCleary",
                                           "body":  "\u003e Only use the ReferenceCountedDisposable\u003cT\u003e(T reference) constructor one time per target object.\r\n\r\nIf the implementation uses ConditionalWeakTable, this restriction could be removed. Not sure if that would be worth the overhead, though.",
                                           "updatedAt":  "2021-11-10T12:12:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc45jUEg",
                                           "createdAt":  "2021-11-10T17:13:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sharwell",
                                           "body":  "@StephenCleary that\u0027s an interesting point. In the time since this was filed we\u0027ve seen a few other ways this pattern could be optimized as well. The main one would be allowing a type to own its own reference count field, which would remove the need to store that value in a separate location. Or, if the pattern is supported directly by the runtime, it could be allocated as a hidden field at the end of the object\u0027s location in memory (similar to how [std::make_shared](https://docs.microsoft.com/en-us/cpp/standard-library/memory-functions?view=msvc-170#make_shared) works).",
                                           "updatedAt":  "2021-11-10T17:15:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc45ktdJ",
                                           "createdAt":  "2021-11-11T02:05:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "StephenCleary",
                                           "body":  "@sharwell I\u0027m planning to add a ref counted disposable to Nito.Disposables shortly; I\u0027d love to hear any ideas or lessons learned. This one includes a weak ref that I haven\u0027t thought of before. Am I right in assuming it\u0027s not actually a *weak* reference, just a reference without a count? I.e., the target may be disposed but can\u0027t be GCed as long as a weak ref exists?",
                                           "updatedAt":  "2021-11-11T02:05:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc45mv2y",
                                           "createdAt":  "2021-11-11T16:51:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sharwell",
                                           "body":  "\u003e Am I right in assuming it\u0027s not actually a weak reference, just a reference without a count? I.e., the target may be disposed but can\u0027t be GCed as long as a weak ref exists?\r\n\r\nThe weak reference allows a new reference-counted strong reference to be obtained up until the point the object is disposed. If you call TryAddReference on the weak reference and it returns true, you know the target has not been disposed and will not be disposed prior to releasing the added reference.\r\n\r\nI do sometimes wish there was a `Lease()` method that added a reference without allocating for use in `using` statements. This gives up some of the correctness assurances of creating new class instances, but for specific use in a `using` statement it doesn\u0027t matter. Note that it can\u0027t be a `ref struct` because use in asynchronous methods is a primary use case.",
                                           "updatedAt":  "2021-11-11T16:53:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48wpMb",
                                           "createdAt":  "2022-01-23T00:36:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rickbrew",
                                           "body":  "I have a similar system in Paint.NET. It goes _much_ farther than what is described here, and is primarily used for COM interop. It basically reifies each \"ref\" (`AddRef()` / `QueryInterface()`) as a proxy object, which can then be disposed or GC\u0027d. I call it \"reference tracking,\" and it combines the strengths of garbage collection and reference counting, while eliminating the issues with circular references (albeit, at the cost of additional objects, of course). It\u0027s also useful for pure managed classes, and I do have a class, `SharedRef\u003cT\u003e`, which implements what\u0027s described here as a wrapper for `IDisposable` objects.\r\n\r\nWhat you\u0027re describing here is basically `std::shared_ptr\u003cT\u003e`, and it\u0027s very useful. I often need to have buffers that are shared between multiple areas of the app, and it\u0027s important that the underlying (native) memory is not freed while still in use. `IDisposable` does not permit this, as the first `Dispose()` call will free the memory, and there\u0027s no way to annotate an object as \"don\u0027t dispose this, its ownership is shared\" except by removing `IDisposable` entirely, which is undesirable.\r\n\r\nMy canonical example here for Paint.NET is when you have an image open, and you add a layer, draw something onto the layer, and then delete the layer. There\u0027s a background thread that is rendering a thumbnail for the Layers window, and while it does its best to cancel out early, there\u0027s still a generous window of time where it needs that buffer to be valid (after the Layer was deleted by the user and the underlying bitmap was `Dispose()`d). Reference counting / cooperative disposal is the solution here, and permits deterministic, eager freeing of the buffer when possible, without having to rely on the garbage collector.",
                                           "updatedAt":  "2022-01-23T00:36:16Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "API proposal: ReferenceCountedDisposable\u003cT\u003e",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/25400",
        "createdAt":  "2018-03-11T10:52:51Z",
        "number":  25400,
        "author":  "ektrah",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOAV2t4g==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aalmada",
                                            "createdAt":  "2018-04-27T13:53:50Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2022-03-14T13:07:43Z",
        "body":  "```csharp\r\npublic sealed class SafeMemoryHandle : SafeHandle\r\n{\r\n    public static SafeMemoryHandle Alloc(UIntPtr size) =\u003e VirtualAlloc(IntPtr.Zero, size, 0x3000, 0x04);\r\n    private SafeMemoryHandle() : base(IntPtr.Zero, true) { }\r\n    public override bool IsInvalid =\u003e handle == IntPtr.Zero;\r\n    protected override bool ReleaseHandle() =\u003e VirtualFree(handle, UIntPtr.Zero, 0x8000) != 0;\r\n    [DllImport(\"Kernel32.dll\")]\r\n    private static extern SafeMemoryHandle VirtualAlloc(IntPtr address, UIntPtr size, uint allocationType, uint protect);\r\n    [DllImport(\"Kernel32.dll\")]\r\n    private static extern int VirtualFree(IntPtr address, UIntPtr size, uint freeType);\r\n}\r\n```\r\n\r\nA SafeHandle like this has [a number of features](https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.safehandle(v=vs.110).aspx#Does):\r\n\r\n* it has magic P/Invoke support to avoid leaks,\r\n* it is thread-safe,\r\n* it does reference counting, and\r\n* disposing it doesn\u0027t release the handle until the reference count reaches 0.\r\n\r\nOverall, very similar to OwnedMemory.\r\n\r\nI would assume that a NativeOwnedMemory implementation should do most (all?) of this as well.\r\n\r\nThe question is: Is it envisioned that there will be implementations of OwnedMemory that are not thread-safe, not reference counting, or not delaying release when they are disposed before the reference count reaches 0? If not, shouldn\u0027t OwnedMemory provide the implementations for most of its methods and only leave allocation and release to derived classes (like SafeHandle)?\r\n\r\nShould NativeOwnedMemory wrap a SafeHandle to get those leak preventing features or is it fine to wrap an IntPtr? Should (Native)OwnedMemory  derive from CriticalFinalizerObject?\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOP5WEMQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM3MjEzMTYyMw==",
                                           "createdAt":  "2018-03-11T17:12:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "cc: @KrzysztofCwalina, @ahsonkhan",
                                           "updatedAt":  "2018-03-11T17:12:36Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM3MjgyNzE2NQ==",
                                           "createdAt":  "2018-03-13T21:37:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAT4M2w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "ektrah",
                                                                               "createdAt":  "2018-03-14T13:09:41Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "KrzysztofCwalina",
                                           "body":  "All good questions we discussed today. @GrabYourPitchforks volunteered to explore this space and propose tweaks.",
                                           "updatedAt":  "2018-03-13T21:37:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_lYQx",
                                           "createdAt":  "2022-03-14T13:07:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "@GrabYourPitchforks, is there anything to be done here, or should this be closed? Thanks.",
                                           "updatedAt":  "2022-03-14T13:07:43Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Deriving from OwnedMemory",
        "labels":  [
                       "enhancement",
                       "api-suggestion",
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/25925",
        "createdAt":  "2018-04-18T06:54:11Z",
        "number":  25925,
        "author":  "GrabYourPitchforks",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-08-28T13:26:34Z",
        "body":  "Currently APIs like `ReadOnlySequence\u003cT\u003e.Slice(SequencePosition, ...)` cannot validate certain aspects of their input parameters (such as that the provided _SequencePosition_ parameters are actually within the _this_ object) without incurring an O(n) traversal through the linked list of segments, where _n_ is the number of segments in the list. One option is to forego validation of the input parameters in this respect, but at the cost of the developer encountering undefined behavior in their application. A better solution would be to make validation constant-time so that the developer gets the benefit of parameter validation with minimal cost.\r\n\r\nOne potential way to do this would be to add a `public object Tag { get; protected set; }` property on the `ReadOnlySequenceSegment\u003cT\u003e` type. The general idea is that the tag identifies the linked list that this segment belongs to, and every segment within that linked list should reference the same tag object. The onus is on the creator of the individual segments to set the correct value. (By convention I\u0027d recommend that _Tag_ point to the last segment in the linked list, but the particular implementation doesn\u0027t matter as long as the tags for each segment have referential equality.) When the developer calls any API on `ReadOnlySequence\u003cT\u003e` that accepts a `SequencePosition` parameter, the API would check that the parameter\u0027s backing `ReadOnlySequenceSegment\u003cT\u003e.Tag` object has referential equality to the `ReadOnlySequence\u003cT\u003e.Start`\u0027s own backing `ReadOnlySequenceSegment\u003cT\u003e.Tag`. If the tags don\u0027t match, then the provided _SequencePosition_ doesn\u0027t belong to this instance, and the API should throw.\r\n\r\nAdditionally, as a potential optimization, the `ReadOnlySequence\u003cT\u003e` type could forego its existing logic of trying to special-case `T[]` vs. `string` vs `MemoryManager\u003cT\u003e` vs `ReadOnlySequenceSegment\u003cT\u003e` and could say simply that its own _SequencePosition_ instances are _always_ backed by a `ReadOnlySequenceSegment\u003cT\u003e`. In some cases this may result in an allocation internally, but this may pay for itself by resulting in much simpler / faster logic in `Slice` and other routines. The allocation penalty could also be optimized by having a custom internal `ReadOnlySequenceSegment\u003cT\u003e`-derived type with a finalizer and pulling a pooling trick [similar to what `PinnableBufferCache` does](https://referencesource.microsoft.com/#System/parent/parent/parent/InternalApis/NDP_Common/inc/PinnableBufferCache.cs,4a9f14fd83c457e5). It also has the added benefit that `ReadOnlySequence\u003cT\u003e` would no longer try to reach into `Memory\u003cT\u003e`\u0027s internals, which could provide better support in the future if we add a direct `void*` constructor to that type.\r\n\r\nThis latter optimization would be purely an implementation detail of `ReadOnlySequence\u003cT\u003e` and wouldn\u0027t change the public API surface. When combined with the _Tag_ proposal mentioned earlier, I think this is compelling in that it provides fast, robust parameter validation and simpler runtime logic for common operations.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOZRJSFg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM4MjM3MDg3Mw==",
                                           "createdAt":  "2018-04-18T12:34:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "Works...",
                                           "updatedAt":  "2018-04-18T12:34:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM4MjQ3NzM3MQ==",
                                           "createdAt":  "2018-04-18T18:05:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pakrym",
                                           "body":  "Good idea.\r\nSimilar thing to the tag can be accomplished by randomizing RunningIndex of the first segment. It would allow our bounds checking to catch most of the incorrect usages.\r\n\r\n\u003e By convention I\u0027d recommend that Tag point to the last segment in the linked list, but the particular implementation doesn\u0027t matter as long as the tags for each segment have referential equality\r\n\r\nThe last segment wouldn\u0027t work for pipelines that need to add/drop linked list nodes all the time and can\u0027t do O(n) operation every time a segment is appended. But we can just point to pipe itself.\r\n\r\n\u003e Additionally, as a potential optimization, the ReadOnlySequence\u003cT\u003e type could forego its existing logic of trying to special-case T[] vs. string vs MemoryManager\u003cT\u003e vs ReadOnlySequenceSegment\u003cT\u003e and could say simply that its own SequencePosition instances are always backed by a ReadOnlySequenceSegment\u003cT\u003e. \r\n\r\nThat was the initial design, @KrzysztofCwalina  was heavily against it.\r\n",
                                           "updatedAt":  "2018-04-18T19:22:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM4ODUyMDI4Mw==",
                                           "createdAt":  "2018-05-12T01:20:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ahsonkhan",
                                           "body":  "cc @JeremyKuhne, FYI.",
                                           "updatedAt":  "2018-05-12T01:20:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5k0vGy",
                                           "createdAt":  "2023-08-24T12:01:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Due to lack of recent activity, this issue has been marked as a candidate for backlog cleanup.  It will be closed if no further activity occurs within 14 more days. Any new comment (by anyone, not necessarily the author) will undo this process.\n\nThis process is part of our [issue cleanup automation](https://github.com/dotnet/runtime/blob/main/docs/issue-cleanup.md).",
                                           "updatedAt":  "2023-08-24T12:01:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5lElIW",
                                           "createdAt":  "2023-08-28T13:26:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "👀",
                                           "updatedAt":  "2023-08-28T13:26:28Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "Correctness checking and perf improvements on ReadOnlySequence",
        "labels":  [
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/27039",
        "createdAt":  "2018-08-01T00:10:42Z",
        "number":  27039,
        "author":  "cdmihai",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC1Rhew==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "raulsntos",
                                            "createdAt":  "2024-01-18T23:54:18Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-01-23T15:37:53Z",
        "body":  "MSBuild has a bunch of HashSet\u003cstring\u003e and Dictionaries with string keys. Due to how Equals and HashCode on ReadOnlyMemory are implemented, it\u0027s not possible to convert these collections to have ReadOnlyMemory\u003cchar\u003e as keys. An EqualityComparer which derived from the actual view in the string would help here.\r\n\r\n```c#\r\nvar set = new HashSet\u003cReadOnlyMemory\u003cchar\u003e\u003e(ReadOnlyMemory.StringComparer.OrdinalIgnoreCase);\r\nset.Add(\"FooBAR\".Slice(3));\r\nset.Contains(\"ZarBar\".Slice(3)); // awesome if this returned true\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOcaBJ_g==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQwOTU1MTY3OQ==",
                                           "createdAt":  "2018-08-01T12:05:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Wraith2",
                                           "body":  "I think this would tie in with https://github.com/dotnet/corefx/issues/31302 in some way but would probably require a specific `ReadOnlyMemory\u003cchar\u003e` comparer to be able to take advantage of the extension methods.\r\n\r\nThere is also a slight worry that while the name ReadOnlyMemory claims to be readonly it isn\u0027t actually guaranteeing anything about the underlying storage being immutable. String instances are (within managed bounds) immutable so using them as keys is ok, can you be certain that any `ReadOnlyMemory\u003cT\u003e` wrapping some object won\u0027t be mutated elsewhere?",
                                           "updatedAt":  "2018-08-01T12:05:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQwOTU5ODM5Ng==",
                                           "createdAt":  "2018-08-01T14:39:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODxyTMw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "IS4Code",
                                                                               "createdAt":  "2023-03-30T10:27:31Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "raulsntos",
                                                                               "createdAt":  "2024-01-18T23:54:34Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "aguzev",
                                                                               "createdAt":  "2024-09-11T07:17:51Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "benaadams",
                                           "body":  "`ReadOnlyMemory` as actual keys would perform badly and be problematic (wrapping mutable memory, holding reference to entire object just for a slice, lifetime issues)\r\n\r\nHowever maybe as an extension for lookups on a `string` dictionary or hashset? Though Span would likely be more flexible at that point...\r\n```csharp\r\npublic static CollectionExtensions\u003cTValue\u003e\r\n{\r\n    bool TryGetValue(this Dictionary\u003cstring, TValue\u003e dict, ReadOnlySpan\u003cchar\u003e key, out TValue value);\r\n    bool ContainsKey(this Dictionary\u003cstring, TValue\u003e dict, ReadOnlySpan\u003cchar\u003e key);\r\n}\r\n\r\npublic static CollectionExtensions\r\n{\r\n    bool TryGetValue(this HashSet\u003cstring\u003e dict, ReadOnlySpan\u003cchar\u003e equalValue, out string actualValue);\r\n    bool Contains(this HashSet\u003cstring\u003e dict, ReadOnlySpan\u003cchar\u003e key);\r\n}\r\n```",
                                           "updatedAt":  "2018-08-01T14:39:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQwOTYwODE5Mw==",
                                           "createdAt":  "2018-08-01T15:07:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODxyTJA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "aguzev",
                                                                               "createdAt":  "2024-09-11T07:17:47Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Wraith2",
                                           "body":  "So those methods would take the span convert to a string and then pass it to the dictionary? Unless the string borrowed the underlying storage that\u0027d require allocation of a new string each time which doesn\u0027t seem desirable.",
                                           "updatedAt":  "2018-08-01T15:07:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQwOTYyNTQ2NA==",
                                           "createdAt":  "2018-08-01T15:59:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "\u003e So those methods would take the span convert to a string and then pass it to the dictionary? \r\n\r\nNo they\u0027d need to be tied to the implementation; but they\u0027d also only be valid for `char` types. Would need to use the same hashcode as the string used in the Collection and also same comparer",
                                           "updatedAt":  "2018-08-01T15:59:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQwOTYzMDAxMw==",
                                           "createdAt":  "2018-08-01T16:11:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Wraith2",
                                           "body":  "I don\u0027t think that would work. The keys are stored in the entries in the dictionary so there do actually have to be real strings unless you change TKey to be something more generic like IEnumerable\u003cchar\u003e.",
                                           "updatedAt":  "2018-08-01T16:11:14Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQwOTYzMzI1NA==",
                                           "createdAt":  "2018-08-01T16:20:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "The keys in the Dictionary would be strings; doesn\u0027t mean the values used to look up have to be strings; they could be ReadOnlySpan.\r\n\r\ne.g. use case an intern Hashtable that returns strings for a ROS is the string has already been created",
                                           "updatedAt":  "2018-08-01T16:20:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQwOTYzNTQxNQ==",
                                           "createdAt":  "2018-08-01T16:27:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Wraith2",
                                           "body":  "In [Dictionary.FindEntry](https://github.com/dotnet/coreclr/blob/5164e76ce01fc36833a7f5e6fb7b1ec2f55c2262/src/System.Private.CoreLib/shared/System/Collections/Generic/Dictionary.cs#L415) the stored and lookup keys are passed to the provided comparer. Both must be of type TKey for IEqualityComparer.Equals and string is sealed so we can\u0027t derive our way out. Is there a way around this that I can\u0027t see?",
                                           "updatedAt":  "2018-08-01T16:27:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQwOTY3Mzk3MA==",
                                           "createdAt":  "2018-08-01T18:23:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "cdmihai",
                                           "body":  "True, putting string based view structs in hash based collections is hard because string is sealed.\r\n\r\nOne simplification might be to reduce the problem to just view struct lookups in string collections. The collection is prepopulated with strings, but lookup is done via view structs (*Segment, Span, Memory, Sequence, etc). In the end, TKey is reduced to an int via GetHashCode, so maybe Dictionary and HashSet could have an int based lookup?\r\n\r\n```c#\r\npublic HashSet\u003cT\u003e\r\n{\r\n    bool TryGetValue(int hashcode, out T actualValue);\r\n    bool ContainsKey(int hashCode);\r\n}\r\n```\r\n\r\nIt looks like it\u0027s exposing private implementation detail. But hashing is a core concept in lookup collections so that\u0027s ok, the only leaky part is the int.\r\n\r\nIt also does not address the need to have case insensitive hash codes for strings. Having String / StringComparer helpers for this would help: https://github.com/dotnet/corefx/issues/31302#issuecomment-409668448",
                                           "updatedAt":  "2018-08-01T18:23:50Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQwOTY3NTc3NA==",
                                           "createdAt":  "2018-08-01T18:29:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "\u003e In the end, TKey is reduced to an int via GetHashCode, so maybe Dictionary and HashSet could have an int based lookup?\r\n\r\nIt also needs equality testing; the hashcode `int` is a candidate check (in addition to bucket location) can be more than one entry with the same hashcode (it isn\u0027t a form of perfect compression)",
                                           "updatedAt":  "2018-08-01T18:30:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQwOTY4MDk3Mw==",
                                           "createdAt":  "2018-08-01T18:44:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "cdmihai",
                                           "body":  "Good point, forgot about collisions. Stack confined lambdas would help here, but that would need language modifications:\r\n\r\n```c#\r\npublic HashSet\u003cT\u003e\r\n{\r\n    bool TryGetValue(int hashcode, ref Func\u003cT, bool\u003e equalityChecker, out T actualValue);\r\n}\r\n```\r\n\r\n```c#\r\nvar set = new HashSet\u003cstring\u003e(){\"foo\", \"bar\"};\r\nvar slice = \"fooBAR\".Slice(3);\r\nset.TryGetValue(String.GetHashCode(slice, StringComparison.OrdinalIgnoreCase), ref s =\u003e slice.Equals(s.AsSpan(), StringComparison.OrdinalIgnoreCase), out var value);\r\n```\r\nAn alternative to ref lambdas would be introducing a structural typing idiom like foreach and Enumerable which would lookup Equals and GetHashCode on structs. This way, one would pass an IEqualityComparer looking struct to the lookup collection.",
                                           "updatedAt":  "2018-08-01T18:44:47Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQwOTY4Nzk0OQ==",
                                           "createdAt":  "2018-08-01T19:07:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Wraith2",
                                           "body":  "Using existing features we could have a new type `StringLikeKey` which contains a reference to something that\u0027s string like and can compare that to other string like things. The performance on comparison won\u0027t be perfect because there will be type detection but actual comparison is hopefully a rare event. The GetHashCode result can be cached in it which would slightly mitigate underlying mutation. it\u0027ll should probably be a class because we know we\u0027re going to store it in a bucket and there\u0027s no point copying it about. Sprinkle in some implicit conversions and it might work.\r\n\r\nThe original comment by @benaadams on perf would still stand though, if you add something to `Dictionary\u003cStringLikeKey,TValue\u003e` with a `ReadOnlyMemory\u003cchar\u003e` as the backing value you\u0027ve got to be careful to clear out that dictionary or risk causing problems. I can see it being a useful tool when parsing though, pull in a file as a single blob use it in lookups without reallocating pieces of it as strings and then discard the entire set of related structures.\r\n\r\nThe slicing string hashcode overload you mention would be dealt with by the hashcode extension for `ReadOnlySpan\u003cchar\u003e` in https://github.com/dotnet/corefx/issues/31302 , you just slice to span and hash that.\r\n\r\nWhen doing xml parsing I\u0027ve hit this same sort of issue. `NameTable` can be used to lookup common tokens but I can\u0027t use it with span without going to an `int` key and losing the collision capability.\r\n\r\nAs useful as span is I always seem to end up doing something slightly annoying at the intersection of span to string based code. It\u0027s a bit like going from generic to non-generic collections, slightly jarring.",
                                           "updatedAt":  "2018-08-01T19:45:51Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQwOTcwMTkwMQ==",
                                           "createdAt":  "2018-08-01T19:58:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAatUxg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "cdmihai",
                                                                               "createdAt":  "2018-08-01T20:28:16Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Wraith2",
                                                                               "createdAt":  "2018-08-01T21:46:29Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "4creators",
                                                                               "createdAt":  "2018-08-16T09:16:04Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "benaadams",
                                           "body":  "Might be better as a specific feature of a \"Power Collection\" https://github.com/dotnet/corefxlab/issues/2406 e.g. where the key is a string-type rather than trying to get the generic collections to work with this caveat for string-types?",
                                           "updatedAt":  "2018-08-01T19:58:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQyNDUwOTk1MQ==",
                                           "createdAt":  "2018-09-25T21:36:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODTv_qQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "stephentoub",
                                                                               "createdAt":  "2018-09-25T22:07:43Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "cdmihai",
                                                                               "createdAt":  "2018-10-08T17:24:37Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "greathow",
                                                                               "createdAt":  "2020-07-02T18:10:41Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "udlose",
                                                                               "createdAt":  "2024-01-23T14:25:27Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "KrzysztofCwalina",
                                           "body":  "Can we just implement `IEqualityComparer\u003cMemory\u003cchar\u003e\u003e` on StringComparer?",
                                           "updatedAt":  "2018-09-25T21:36:14Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ0MTkwNzc1Ng==",
                                           "createdAt":  "2018-11-27T04:38:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ahsonkhan",
                                           "body":  "\u003e Can we just implement `IEqualityComparer\u003cMemory\u003cchar\u003e\u003e` on StringComparer?\r\n\r\nIf StringComparer implemented `IEqualityComparer\u003cMemory\u003cchar\u003e\u003e`, would we need any additional APIs then?\r\n\r\ncc @GrabYourPitchforks ",
                                           "updatedAt":  "2018-11-27T04:38:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc45HGmq",
                                           "createdAt":  "2021-11-02T21:01:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "FWIW, during the `Utf8String` prototype I tried making `StringComparer` implement both `IComparer\u003cstring\u003e` and `IComparer\u003cUtf8String\u003e`. Ultimately this resulted in an issue that certain call sites were ambiguous due to overload resolution not being able to determine a best match, and our unit tests failed to compile. The incident count of these was very small, but it was non-zero. In a larger project I imagine adding extra `IComparer\u003cT\u003e` implementations would be more problematic.",
                                           "updatedAt":  "2021-11-02T21:01:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5xoEn-",
                                           "createdAt":  "2024-01-23T15:37:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "udlose",
                                           "body":  "looks like this can now be accomplished via MemoryExtensions",
                                           "updatedAt":  "2024-01-23T15:37:51Z"
                                       }
                                   ],
                         "totalCount":  16
                     },
        "title":  "Proposal: add EqualityComparer for ReadOnlyMemory\u003cchar\u003e to enable collections with memory backed strings",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/27156",
        "createdAt":  "2018-08-16T17:25:47Z",
        "number":  27156,
        "author":  "AArnott",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODHpIlQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Wraith2",
                                            "createdAt":  "2018-08-16T19:41:06Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "tomrus88",
                                            "createdAt":  "2018-08-18T13:04:49Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jnm2",
                                            "createdAt":  "2018-08-21T12:40:57Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "clairernovotny",
                                            "createdAt":  "2018-10-24T12:23:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "JamesNK",
                                            "createdAt":  "2019-10-21T00:41:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hexawyz",
                                            "createdAt":  "2020-01-03T12:46:25Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "george-chakhidze",
                                            "createdAt":  "2020-02-04T12:19:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "manfred-brands",
                                            "createdAt":  "2020-08-13T07:20:20Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "voronov-maxim",
                                            "createdAt":  "2020-10-07T09:26:52Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ntregillus",
                                            "createdAt":  "2020-10-30T02:47:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Mephistofeles",
                                            "createdAt":  "2020-12-16T23:09:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "0xfeeddeadbeef",
                                            "createdAt":  "2021-01-16T01:17:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "andriysavin",
                                            "createdAt":  "2021-02-03T10:48:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "HMBSbige",
                                            "createdAt":  "2021-05-07T04:39:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "shravan2x",
                                            "createdAt":  "2021-06-25T05:51:03Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DanilovSoft",
                                            "createdAt":  "2021-08-01T16:56:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "babrekel",
                                            "createdAt":  "2021-11-17T07:11:37Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "zgramana",
                                            "createdAt":  "2022-01-12T19:34:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ZJKung",
                                            "createdAt":  "2022-01-20T08:56:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Sly1024",
                                            "createdAt":  "2022-02-10T14:02:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AJK74",
                                            "createdAt":  "2022-10-16T09:02:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kronic",
                                            "createdAt":  "2023-06-01T19:16:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Volkmire",
                                            "createdAt":  "2023-11-09T08:03:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Kaayo",
                                            "createdAt":  "2023-12-24T12:24:51Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "exyi",
                                            "createdAt":  "2024-03-17T09:11:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2024-03-29T19:24:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "verdie-g",
                                            "createdAt":  "2024-06-23T23:10:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SoftStoneDevelop",
                                            "createdAt":  "2025-02-24T18:00:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Athari",
                                            "createdAt":  "2025-07-19T00:18:10Z"
                                        }
                                    ],
                          "totalCount":  29
                      },
        "updatedAt":  "2025-06-16T09:00:32Z",
        "body":  "I\u0027m re-implementing a protocol in terms of System.IO.Pipelines and striving for minimal allocations, especially of large objects. As part of this, I no longer have to allocate a large array for the entire message, since I read it as it comes in via `PipeReader`. \r\n\r\nAt some point I get to the main \"content\" which I need to deserialize. The deserialization API accepts a `TextReader`, which I plan to use a `StreamReader` for. But for that I need a `Stream` that will read from the `ReadOnlySequence\u003cbyte\u003e` that I got from the `PipeReader`. I\u0027m planning on writing this up myself in `Nerdbank.Streams` and exposing it as an `Stream ReadOnlySequence\u003cbyte\u003e.AsStream()` extension method.\r\n\r\nShould this be a built-in feature of .NET? I\u0027m imagining perhaps a `ReadOnlyMemoryStream` class with constructors that accepts `ReadOnlyMemory\u003cbyte\u003e` or `ReadOnlySequence\u003cbyte\u003e` .",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOsV1AnA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQxMzYyNDMxNw==",
                                           "createdAt":  "2018-08-16T17:31:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Related dotnet/runtime#26676 dotnet/runtime#25087\r\ncc @davidfowl ",
                                           "updatedAt":  "2018-08-16T17:31:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQxOTE1MTY5OQ==",
                                           "createdAt":  "2018-09-06T16:08:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Wraith2",
                                           "body":  "@AArnott did you get this implemented in your own package? because I\u0027ve just reached a point where it would be really useful.",
                                           "updatedAt":  "2018-09-06T16:08:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQxOTE1MjA0NQ==",
                                           "createdAt":  "2018-09-06T16:10:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "FWIW I think this should exist, but it ends up being a heap allocation. So It kinda sucks.",
                                           "updatedAt":  "2018-09-06T16:10:02Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQxOTE1NzYzMg==",
                                           "createdAt":  "2018-09-06T16:27:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAbtLdQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AArnott",
                                                                               "createdAt":  "2018-09-06T18:42:54Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Wraith2",
                                           "body":  "Allocation of the stream? presuming that I can get a section of the input sequence using Slice() I can stand a few allocs to create a container for that to avoid needing to copy the contents of the buffers.\r\n\r\nFor example i\u0027ll have a situation where there will 2Mib+ of compressed data in a pipe surrounded by some framing data. I want to identify the frame and payload limits then push out the payload section using a ROS slice, wrap that in decompression (and possible possibly crypto) stream and then use that as input to a streamed database parameter. ",
                                           "updatedAt":  "2018-09-06T16:27:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQxOTIwMDY3Nw==",
                                           "createdAt":  "2018-09-06T18:44:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODadhjQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "Wraith2",
                                                                               "createdAt":  "2018-09-06T19:01:57Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "Kaayo",
                                                                               "createdAt":  "2023-12-24T12:27:43Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "0xfeeddeadbeef",
                                                                               "createdAt":  "2024-03-13T19:21:44Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "AArnott",
                                           "body":  "\u003e did you get this implemented in your own package?\r\n\r\nYes, @Wraith2. It\u0027s documented [here](https://github.com/AArnott/Nerdbank.Streams/blob/master/doc/AsStream.md#readonlysequencebyte) and you can get it from [![NuGet package](https://img.shields.io/nuget/v/Nerdbank.Streams.svg)](https://nuget.org/packages/Nerdbank.Streams)",
                                           "updatedAt":  "2018-09-06T18:44:22Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQxOTI1Nzc1MQ==",
                                           "createdAt":  "2018-09-06T22:11:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "\u003e Allocation of the stream? presuming that I can get a section of the input sequence using Slice() I can stand a few allocs to create a container for that to avoid needing to copy the contents of the buffers.\r\n\r\nFor big buffers I agree. This was a significant amount of allocations if you\u0027re sending lots of data.",
                                           "updatedAt":  "2018-09-06T22:11:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQzMTI0OTcxNQ==",
                                           "createdAt":  "2018-10-19T05:33:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "@AArnott Can you propose an API? I\u0027d like to add this for 3.0, but we need an API proposal here. It gels nicely with the other APIs we\u0027d like to add to 3.0",
                                           "updatedAt":  "2018-10-19T05:33:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQzMTM1MjM2NA==",
                                           "createdAt":  "2018-10-19T12:51:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Whatever we do here, I\u0027d like to see it done in conjunction with https://github.com/dotnet/corefx/issues/22404, which is about creating streams for `Memory\u003cT\u003e` and `ReadOnlyMemory\u003cT\u003e`.  Note that we already have a `ReadOnlyMemoryStream\u003cT\u003e` in corefx (https://github.com/dotnet/corefx/blob/6b9440735abc9c4e369376bca097766527971a7a/src/Common/src/System/IO/ReadOnlyMemoryStream.cs), but it\u0027s internal, added in support of `ReadOnlyMemoryContent` for `HttpClient` (https://github.com/dotnet/corefx/pull/24006).  And of course we need to either put it behind a factory or do something about the name, as the writable equivalent would have an obvious conflict.",
                                           "updatedAt":  "2018-10-19T12:51:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQzMTM5NDAwNQ==",
                                           "createdAt":  "2018-10-19T15:03:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODMMUQA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "airbreather",
                                                                               "createdAt":  "2020-04-30T11:44:08Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "andriysavin",
                                                                               "createdAt":  "2021-02-03T10:50:06Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Volkmire",
                                                                               "createdAt":  "2023-11-09T08:03:58Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "AArnott",
                                           "body":  "How do you all feel about `AsStream()` extension methods that simply return `Stream` for these? That\u0027s how I do it in nerdbank.streams for most of these and it avoids such problems as additional classes, naming, etc. \r\n\r\nThe only time it doesn\u0027t work is when I need to expose special members. The only one I can think of now is if we create a (writable) stream over `Memory\u003cT\u003e`, which has fixed size and thus we might want to expose a `Stream`-derived class that defines a `Capacity` member (ala `MemoryStream`) so people understanding why writing may run out of space and can predict that.",
                                           "updatedAt":  "2018-10-19T15:03:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQzMjkxNDcwNg==",
                                           "createdAt":  "2018-10-25T04:56:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e How do you all feel about AsStream() extension methods that simply return Stream for these?\r\n\r\nSeems reasonable.",
                                           "updatedAt":  "2018-10-25T04:56:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2ODIyNDk4Mw==",
                                           "createdAt":  "2021-06-25T05:56:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCO0PmQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "zgramana",
                                                                               "createdAt":  "2022-01-12T19:33:24Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "tmbull",
                                                                               "createdAt":  "2022-02-15T20:48:20Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "shravan2x",
                                           "body":  "Would it be possible to include this in .NET 6?",
                                           "updatedAt":  "2021-06-25T05:56:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2ODMyOTE0Nw==",
                                           "createdAt":  "2021-06-25T08:43:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tomkerkhove",
                                           "body":  "💯",
                                           "updatedAt":  "2021-06-25T08:43:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6xXUCc",
                                           "createdAt":  "2025-06-16T09:00:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "TheConstructor",
                                           "body":  "\u003e Whatever we do here, I\u0027d like to see it done in conjunction with https://github.com/dotnet/corefx/issues/22404, which is about creating streams for `Memory\u003cT\u003e` and `ReadOnlyMemory\u003cT\u003e`. Note that we already have a `ReadOnlyMemoryStream\u003cT\u003e` in corefx (https://github.com/dotnet/corefx/blob/6b9440735abc9c4e369376bca097766527971a7a/src/Common/src/System/IO/ReadOnlyMemoryStream.cs), but it\u0027s internal, added in support of `ReadOnlyMemoryContent` for `HttpClient` ([dotnet/corefx#24006](https://github.com/dotnet/corefx/pull/24006)). And of course we need to either put it behind a factory or do something about the name, as the writable equivalent would have an obvious conflict.\n\nAt least starting with .NET 8 System.Memory.Data has something acking to a factory: `new BinaryData(readOnlyMemory).ToStream()`",
                                           "updatedAt":  "2025-06-16T09:00:32Z"
                                       }
                                   ],
                         "totalCount":  13
                     },
        "title":  "Feature request: Create a Stream that reads from a ReadOnlySequence\u003cbyte\u003e",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/27769",
        "createdAt":  "2018-10-30T15:10:03Z",
        "number":  27769,
        "author":  "thargy",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-08-28T11:01:22Z",
        "body":  "When calling `ReadOnlySequence\u003cT\u003e.TryGet(ref position, out memory)` with a position of `sequence.End` or `sequence.GetPosition(size)` the result is `true` and `memory` is an empty slice.  As this effectively is _not_ returning a segment or byte, is should probably return `false`.\r\n\r\nAs per [this comment](https://github.com/dotnet/corefx/issues/33089#issuecomment-434321865) from @pakrym, I\u0027m raising as a seperate issue.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOHgk1Nw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ0ODYxOTU1NA==",
                                           "createdAt":  "2018-12-19T14:43:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "cc @ahsonkhan ",
                                           "updatedAt":  "2018-12-19T14:43:25Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ5OTE1MTEzMA==",
                                           "createdAt":  "2019-06-05T16:12:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MarcoRossignoli",
                                           "body":  "\u003e As this effectively is not returning a segment or byte, is should probably return false.\r\n\r\n@ahsonkhan should we return false if empy segment is returned?",
                                           "updatedAt":  "2019-06-05T16:12:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwMzM0MTkyMg==",
                                           "createdAt":  "2019-06-18T22:56:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAq73dQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "davidfowl",
                                                                               "createdAt":  "2019-06-20T09:46:10Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "ahsonkhan",
                                           "body":  "\u003e should we return false if empy segment is returned?\r\n\r\nYes. If anyone would like to submit a fix for this with a test, that would be much appreciated. Otherwise, this issue will move to future.",
                                           "updatedAt":  "2019-06-18T22:56:18Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwMzUzODgyOA==",
                                           "createdAt":  "2019-06-19T12:26:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MarcoRossignoli",
                                           "body":  "@ahsonkhan are we sure of this update?Seem a breaking changes there are a lot of tests that fail.\r\nAgain there is a tailored made tests on this subject https://github.com/dotnet/corefx/blob/fd9801068f1baf8d69893da2a414eee7556e51b0/src/System.Memory/tests/ReadOnlyBuffer/ReadOnlySequenceTests.Empty.cs#L159\r\n\r\nMaybe before go on should be discussed on review?I mean it\u0027s a semantic changes.",
                                           "updatedAt":  "2019-06-19T12:26:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwMzYyMDQxMw==",
                                           "createdAt":  "2019-06-19T15:53:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ahsonkhan",
                                           "body":  "\u003e Seem a breaking changes there are a lot of tests that fail.\r\nAgain there is a tailored made tests on this subject\r\n\r\nAside from the `Empty_TryGet` test, was there others failing too? That test looks to be written specifically with the current behavior in mind.\r\n\r\n\u003e Maybe before go on should be discussed on review?I mean it\u0027s a semantic changes.\r\n\r\nThat\u0027s a good point. I am going to move it to future at this point given the impact of this issue doesn\u0027t seem quite that high to me, to make room for other 3.0 work.",
                                           "updatedAt":  "2019-06-19T15:53:35Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwMzY0NDA3OA==",
                                           "createdAt":  "2019-06-19T16:57:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "thargy",
                                           "body":  "\u003e That\u0027s a good point. I am going to move it to future at this point given the impact of this issue doesn\u0027t seem quite that high to me\r\n\r\nI had hoped that this would be changed for 3.0 as `ReadOnlySequence\u003cT\u003e` gains adoption more and more code would be affected by a breaking change, particularly if it is released in a minor revision later.  It is a relatively quick change to implement, though performance testing different approaches would probably be demanded due to the location.",
                                           "updatedAt":  "2019-06-19T16:57:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwMzkxOTkyNw==",
                                           "createdAt":  "2019-06-20T07:56:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MarcoRossignoli",
                                           "body":  "\u003e was there others failing too\r\n\r\nYes, did simple update here \r\n\r\nhttps://github.com/dotnet/corefx/blob/74032a608cf39d8eaa2955cc46d0ac677e3ae12c/src/System.Memory/src/System/Buffers/ReadOnlySequence.Helpers.cs#L78\r\n\r\nwith `return !memory.IsEmpty;` (let me know if it\u0027s not correct...I followed code path for tryget)\r\nwe only return false if  `positionObject` is `null`(above code)\r\nAnd get fails for:\r\n```\r\n5IEnumerable\u003cString\u003e (129 items)44\r\n--\r\nSystem.Memory.Tests.ReadOnlySequenceTestsEmpty.Empty_TryGet\r\nSystem.Memory.Tests.ReadOnlySequenceTestsEmpty.Empty_Enumerator\r\nSystem.Memory.Tests.SequenceReader.Advance.PastEmptySegments\r\nSystem.Memory.Tests.ReadOnlySequenceTestsCommonByte.TryGetStopsAtEndWhenEndIsFirstItemOfFull\r\nSystem.Memory.Tests.ReadOnlySequenceTestsCommonByte.TryGetReturnsEmptySegments\r\nSystem.Memory.Tests.ReadOnlySequenceTestsCommonByte.EnumerableStopsAtEndWhenEndIsFirstItemOfEmpty\r\nSystem.Memory.Tests.ReadOnlySequenceTestsCommonByte.EnumerableStopsAtEndWhenEndIsFirstItemOfFull\r\nSystem.Memory.Tests.ReadOnlySequenceTestsCommonByte.TryGetStopsAtEndWhenEndIsFirstItemOfEmpty\r\nSystem.Memory.Tests.SequenceReader.SegmentPerByte.TryReadTraversesSegments\r\nSystem.Memory.Tests.SequenceReader.SegmentPerByte.TryPeekReturnsDefaultInTheEnd\r\nSystem.Memory.Tests.SequenceReader.SegmentPerByte.AdvanceTo_AdvancePast\r\nSystem.Memory.Tests.SequenceReader.SegmentPerByte.AdvanceToEndThenPeekReturnsDefault\r\nSystem.Memory.Tests.SequenceReader.SegmentPerByte.AdvancingPastLengthThrows\r\nSystem.Memory.Tests.SequenceReader.SegmentPerByte.Advance_PositionIsCorrect(advanceBy: 1)\r\nSystem.Memory.Tests.SequenceReader.SegmentPerByte.Advance_PositionIsCorrect(advanceBy: 2)\r\nSystem.Memory.Tests.SequenceReader.SegmentPerByte.Advance_PositionIsCorrect(advanceBy: 3)\r\nSystem.Memory.Tests.SequenceReader.SegmentPerByte.AdvanceThrowsPastLengthMultipleSegments\r\nSystem.Memory.Tests.SequenceReader.SegmentPerByte.ReaderIndexIsCorrect\r\nSystem.Memory.Tests.SequenceReader.SegmentPerByte.AdvanceTraversesSegments\r\nSystem.Memory.Tests.SequenceReader.SegmentPerByte.AdvanceTo\r\nSystem.Memory.Tests.SequenceReader.SegmentPerByte.ReturnsCorrectCursor(takes: 0, end: False)\r\nSystem.Memory.Tests.SequenceReader.SegmentPerByte.ReturnsCorrectCursor(takes: 5, end: False)\r\nSystem.Memory.Tests.SequenceReader.SegmentPerByte.ReturnsCorrectCursor(takes: 10, end: False)\r\nSystem.Memory.Tests.SequenceReader.SegmentPerByte.ReturnsCorrectCursor(takes: 11, end: True)\r\nSystem.Memory.Tests.SequenceReader.SegmentPerByte.ReturnsCorrectCursor(takes: 12, end: True)\r\nSystem.Memory.Tests.SequenceReader.SegmentPerByte.ReturnsCorrectCursor(takes: 15, end: True)\r\nSystem.Memory.Tests.SequenceReader.SegmentPerByte.TryPeekTraversesSegments\r\nSystem.Memory.Tests.SequenceReader.SegmentPerByte.CopyToSmallerBufferWorks\r\nSystem.Memory.Tests.SequenceReader.SegmentPerByte.EmptySegmentsAreSkippedOnMoveNext\r\nSystem.Memory.Tests.SequenceReader.ReadTo.TryReadTo_Sequence(advancePastDelimiter: False, useEscapeOverload: False)\r\nSystem.Memory.Tests.SequenceReader.ReadTo.TryReadTo_Sequence(advancePastDelimiter: False, useEscapeOverload: True)\r\nSystem.Memory.Tests.SequenceReader.ReadTo.TryReadTo_Sequence(advancePastDelimiter: True, useEscapeOverload: False)\r\nSystem.Memory.Tests.SequenceReader.ReadTo.TryReadTo_Sequence(advancePastDelimiter: True, useEscapeOverload: True)\r\nSystem.Memory.Tests.SequenceReader.ReadTo.TryReadToSpan_Sequence(advancePastDelimiter: False)\r\nSystem.Memory.Tests.SequenceReader.ReadTo.TryReadToSpan_Sequence(advancePastDelimiter: True)\r\nSystem.Memory.Tests.SequenceReader.ReadTo.TryReadTo_Span(advancePastDelimiter: False, useEscapeOverload: False)\r\nSystem.Memory.Tests.SequenceReader.ReadTo.TryReadTo_Span(advancePastDelimiter: False, useEscapeOverload: True)\r\nSystem.Memory.Tests.SequenceReader.ReadTo.TryReadTo_Span(advancePastDelimiter: True, useEscapeOverload: False)\r\nSystem.Memory.Tests.SequenceReader.ReadTo.TryReadTo_Span(advancePastDelimiter: True, useEscapeOverload: True)\r\nSystem.Memory.Tests.SequenceReader.SegmentPerChar.AdvanceThrowsPastLengthMultipleSegments\r\nSystem.Memory.Tests.SequenceReader.SegmentPerChar.AdvanceTo\r\nSystem.Memory.Tests.SequenceReader.SegmentPerChar.AdvanceTraversesSegments\r\nSystem.Memory.Tests.SequenceReader.SegmentPerChar.Advance_PositionIsCorrect(advanceBy: 1)\r\nSystem.Memory.Tests.SequenceReader.SegmentPerChar.Advance_PositionIsCorrect(advanceBy: 2)\r\nSystem.Memory.Tests.SequenceReader.SegmentPerChar.Advance_PositionIsCorrect(advanceBy: 3)\r\nSystem.Memory.Tests.SequenceReader.SegmentPerChar.ReaderIndexIsCorrect\r\nSystem.Memory.Tests.SequenceReader.SegmentPerChar.ReturnsCorrectCursor(takes: 0, end: False)\r\nSystem.Memory.Tests.SequenceReader.SegmentPerChar.ReturnsCorrectCursor(takes: 5, end: False)\r\nSystem.Memory.Tests.SequenceReader.SegmentPerChar.ReturnsCorrectCursor(takes: 10, end: False)\r\nSystem.Memory.Tests.SequenceReader.SegmentPerChar.ReturnsCorrectCursor(takes: 11, end: True)\r\nSystem.Memory.Tests.SequenceReader.SegmentPerChar.ReturnsCorrectCursor(takes: 12, end: True)\r\nSystem.Memory.Tests.SequenceReader.SegmentPerChar.ReturnsCorrectCursor(takes: 15, end: True)\r\nSystem.Memory.Tests.SequenceReader.SegmentPerChar.CopyToSmallerBufferWorks\r\nSystem.Memory.Tests.SequenceReader.SegmentPerChar.AdvanceTo_AdvancePast\r\nSystem.Memory.Tests.SequenceReader.SegmentPerChar.TryPeekTraversesSegments\r\nSystem.Memory.Tests.SequenceReader.SegmentPerChar.AdvancingPastLengthThrows\r\nSystem.Memory.Tests.SequenceReader.SegmentPerChar.TryReadTraversesSegments\r\nSystem.Memory.Tests.SequenceReader.SegmentPerChar.EmptySegmentsAreSkippedOnMoveNext\r\nSystem.Memory.Tests.SequenceReader.SegmentPerChar.TryPeekReturnsDefaultInTheEnd\r\nSystem.Memory.Tests.SequenceReader.SegmentPerChar.AdvanceToEndThenPeekReturnsDefault\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SplitInThreeSegments.PositionOf_ReturnsPosition(raw: \\\"a\\\", searchFor: \u0027a\u0027, expectIndex: 0)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SplitInThreeSegments.PositionOf_ReturnsPosition(raw: \\\"ab\\\", searchFor: \u0027a\u0027, expectIndex: 0)\r\nSystem.Memory.Tests.SequenceReader.Rewind.RewindEmptyFirstSpan\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.ToArrayIsCorrect(length: 8)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.PositionOf_ReturnsPosition(raw: \\\"a\\\", searchFor: \u0027a\u0027, expectIndex: 0)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.PositionOf_ReturnsPosition(raw: \\\"ab\\\", searchFor: \u0027a\u0027, expectIndex: 0)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.PositionOf_ReturnsPosition(raw: \\\"aab\\\", searchFor: \u0027a\u0027, expectIndex: 0)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.PositionOf_ReturnsPosition(raw: \\\"acab\\\", searchFor: \u0027a\u0027, expectIndex: 0)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.PositionOf_ReturnsPosition(raw: \\\"acab\\\", searchFor: \u0027c\u0027, expectIndex: 1)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.PositionOf_ReturnsPosition(raw: \\\"abcdefghijklmnopqrstuvwxyz\\\", searchFor: \u0027l\u0027, expectIndex: 11)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.PositionOf_ReturnsPosition(raw: \\\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwx\\\"..., searchFor: \u0027l\u0027, expectIndex: 11)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.PositionOf_ReturnsPosition(raw: \\\"aaaaaaaaaaacmnopqrstuvwxyzabcdefghijklmnopqrstuvwx\\\"..., searchFor: \u0027m\u0027, expectIndex: 12)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.PositionOf_ReturnsPosition(raw: \\\"aaaaaaaaaaarmnopqrstuvwxyzabcdefghijklmnopqrstuvwx\\\"..., searchFor: \u0027r\u0027, expectIndex: 11)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.PositionOf_ReturnsPosition(raw: \\\"/localhost:5000/PATH/%2FPATH2/ HTTP/1.1\\\", searchFor: \u0027%\u0027, expectIndex: 21)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.PositionOf_ReturnsPosition(raw: \\\"/localhost:5000/PATH/%2FPATH2/?key=value HTTP/1.1\\\", searchFor: \u0027%\u0027, expectIndex: 21)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.PositionOf_ReturnsPosition(raw: \\\"/localhost:5000/PATH/PATH2/?key=value HTTP/1.1\\\", searchFor: \u0027?\u0027, expectIndex: 27)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.PositionOf_ReturnsPosition(raw: \\\"/localhost:5000/PATH/PATH2/ HTTP/1.1\\\", searchFor: \u0027 \u0027, expectIndex: 27)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Byte] \u003cget_ValidSliceCases\u003eb__24_0(System.Buffers.ReadOnlySequence`1[System.Byte]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Byte] \u003cget_ValidSliceCases\u003eb__24_1(System.Buffers.ReadOnlySequence`1[System.Byte]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Byte] \u003cget_ValidSliceCases\u003eb__24_2(System.Buffers.ReadOnlySequence`1[System.Byte]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Byte] \u003cget_ValidSliceCases\u003eb__24_3(System.Buffers.ReadOnlySequence`1[System.Byte]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Byte] \u003cget_ValidSliceCases\u003eb__24_4(System.Buffers.ReadOnlySequence`1[System.Byte]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Byte] \u003cget_ValidSliceCases\u003eb__24_5(System.Buffers.ReadOnlySequence`1[System.Byte]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Byte] \u003cget_ValidSliceCases\u003eb__24_6(System.Buffers.ReadOnlySequence`1[System.Byte]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Byte] \u003cget_ValidSliceCases\u003eb__24_7(System.Buffers.ReadOnlySequence`1[System.Byte]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Byte] \u003cget_ValidSliceCases\u003eb__24_8(System.Buffers.ReadOnlySequence`1[System.Byte]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Byte] \u003cget_ValidSliceCases\u003eb__24_9(System.Buffers.ReadOnlySequence`1[System.Byte]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Byte] \u003cget_ValidSliceCases\u003eb__24_10(System.Buffers.ReadOnlySequence`1[System.Byte]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Byte] \u003cget_ValidSliceCases\u003eb__24_11(System.Buffers.ReadOnlySequence`1[System.Byte]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Byte] \u003cget_ValidSliceCases\u003eb__24_12(System.Buffers.ReadOnlySequence`1[System.Byte]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Byte] \u003cget_ValidSliceCases\u003eb__24_13(System.Buffers.ReadOnlySequence`1[System.Byte]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsByte+SegmentPerByte.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Byte] \u003cget_ValidSliceCases\u003eb__24_14(System.Buffers.ReadOnlySequence`1[System.Byte]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Char] \u003cget_ValidSliceCases\u003eb__25_0(System.Buffers.ReadOnlySequence`1[System.Char]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Char] \u003cget_ValidSliceCases\u003eb__25_1(System.Buffers.ReadOnlySequence`1[System.Char]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Char] \u003cget_ValidSliceCases\u003eb__25_2(System.Buffers.ReadOnlySequence`1[System.Char]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Char] \u003cget_ValidSliceCases\u003eb__25_3(System.Buffers.ReadOnlySequence`1[System.Char]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Char] \u003cget_ValidSliceCases\u003eb__25_4(System.Buffers.ReadOnlySequence`1[System.Char]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Char] \u003cget_ValidSliceCases\u003eb__25_5(System.Buffers.ReadOnlySequence`1[System.Char]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Char] \u003cget_ValidSliceCases\u003eb__25_6(System.Buffers.ReadOnlySequence`1[System.Char]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Char] \u003cget_ValidSliceCases\u003eb__25_7(System.Buffers.ReadOnlySequence`1[System.Char]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Char] \u003cget_ValidSliceCases\u003eb__25_8(System.Buffers.ReadOnlySequence`1[System.Char]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Char] \u003cget_ValidSliceCases\u003eb__25_9(System.Buffers.ReadOnlySequence`1[System.Char]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Char] \u003cget_ValidSliceCases\u003eb__25_10(System.Buffers.ReadOnlySequence`1[System.Char]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Char] \u003cget_ValidSliceCases\u003eb__25_11(System.Buffers.ReadOnlySequence`1[System.Char]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Char] \u003cget_ValidSliceCases\u003eb__25_12(System.Buffers.ReadOnlySequence`1[System.Char]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Char] \u003cget_ValidSliceCases\u003eb__25_13(System.Buffers.ReadOnlySequence`1[System.Char]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.Slice_Works(func: Func`2 { Method = System.Buffers.ReadOnlySequence`1[System.Char] \u003cget_ValidSliceCases\u003eb__25_14(System.Buffers.ReadOnlySequence`1[System.Char]), Target = \u003c\u003ec { } })\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.PositionOf_ReturnsPosition(raw: \\\"a\\\", searchFor: \u0027a\u0027, expectIndex: 0)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.PositionOf_ReturnsPosition(raw: \\\"ab\\\", searchFor: \u0027a\u0027, expectIndex: 0)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.PositionOf_ReturnsPosition(raw: \\\"aab\\\", searchFor: \u0027a\u0027, expectIndex: 0)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.PositionOf_ReturnsPosition(raw: \\\"acab\\\", searchFor: \u0027a\u0027, expectIndex: 0)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.PositionOf_ReturnsPosition(raw: \\\"acab\\\", searchFor: \u0027c\u0027, expectIndex: 1)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.PositionOf_ReturnsPosition(raw: \\\"abcdefghijklmnopqrstuvwxyz\\\", searchFor: \u0027l\u0027, expectIndex: 11)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.PositionOf_ReturnsPosition(raw: \\\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwx\\\"..., searchFor: \u0027l\u0027, expectIndex: 11)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.PositionOf_ReturnsPosition(raw: \\\"aaaaaaaaaaacmnopqrstuvwxyzabcdefghijklmnopqrstuvwx\\\"..., searchFor: \u0027m\u0027, expectIndex: 12)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.PositionOf_ReturnsPosition(raw: \\\"aaaaaaaaaaarmnopqrstuvwxyzabcdefghijklmnopqrstuvwx\\\"..., searchFor: \u0027r\u0027, expectIndex: 11)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.PositionOf_ReturnsPosition(raw: \\\"/localhost:5000/PATH/%2FPATH2/ HTTP/1.1\\\", searchFor: \u0027%\u0027, expectIndex: 21)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.PositionOf_ReturnsPosition(raw: \\\"/localhost:5000/PATH/%2FPATH2/?key=value HTTP/1.1\\\", searchFor: \u0027%\u0027, expectIndex: 21)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.PositionOf_ReturnsPosition(raw: \\\"/localhost:5000/PATH/PATH2/?key=value HTTP/1.1\\\", searchFor: \u0027?\u0027, expectIndex: 27)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.PositionOf_ReturnsPosition(raw: \\\"/localhost:5000/PATH/PATH2/ HTTP/1.1\\\", searchFor: \u0027 \u0027, expectIndex: 27)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.ToArrayIsCorrect(length: 8)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SegmentPerChar.ToStringIsCorrect\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SplitInThreeSegments.PositionOf_ReturnsPosition(raw: \\\"a\\\", searchFor: \u0027a\u0027, expectIndex: 0)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsChar+SplitInThreeSegments.PositionOf_ReturnsPosition(raw: \\\"ab\\\", searchFor: \u0027a\u0027, expectIndex: 0)\r\nSystem.Memory.Tests.ReadOnlySequenceTestsCommonChar.EnumerableStopsAtEndWhenEndIsFirstItemOfEmpty\r\nSystem.Memory.Tests.ReadOnlySequenceTestsCommonChar.TryGetStopsAtEndWhenEndIsFirstItemOfEmpty\r\nSystem.Memory.Tests.ReadOnlySequenceTestsCommonChar.TryGetReturnsEmptySegments\r\nSystem.Memory.Tests.ReadOnlySequenceTestsCommonChar.EnumerableStopsAtEndWhenEndIsFirstItemOfFull\r\nSystem.Memory.Tests.ReadOnlySequenceTestsCommonChar.TryGetStopsAtEndWhenEndIsFirstItemOfFull\r\n```\r\nSame result if only update public `TryGet` api.",
                                           "updatedAt":  "2019-06-20T08:02:38Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "ReadOnlySequence\u003cT\u003e.TryGet() returns empty result",
        "labels":  [
                       "bug",
                       "area-System.Memory",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/27770",
        "createdAt":  "2018-10-30T15:13:33Z",
        "number":  27770,
        "author":  "thargy",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-07-11T18:55:28Z",
        "body":  "Currently calling `ReadOnlySequence\u003cT\u003e.GetPosition(offset, origin)` with a negative `offset` results in an `ArgumentOutOfRangeException`.\r\n\r\nAllowing negative offset\u0027s would allow code such as:\r\n```csharp\r\n// Get the last element in the sequence.\r\nsequence.GetPosition(-1, sequence.End);\r\n```\r\n\r\n(Raised at request of @pakrym, see [this comment](https://github.com/dotnet/corefx/issues/33089#issuecomment-434321865))",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYTx2Ow==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQzNDQwODg5NQ==",
                                           "createdAt":  "2018-10-30T18:04:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "It’ll be inefficient for multi-segmented backed sequences since it’s a singly linked list.",
                                           "updatedAt":  "2018-10-30T18:04:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQzNDQyMTk4Ng==",
                                           "createdAt":  "2018-10-30T18:41:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "thargy",
                                           "body":  "\u003e It’ll be inefficient for multi-segmented backed sequences since it’s a singly linked list.\r\n\r\nVery true, though in many use cases I suspect it will not need to backtrack more than one segment, and will most commonly be able to return a result in the origin\u0027s own segment; as the most common negative offset will be `-1`. In it\u0027s simplest form it can be implemented as `GetPosition(Origin position - offset)` which requires a full scan to get the origin\u0027s position and a second scan to get the actual position, so is still O(n).  This can be optimised when the origin lies in the first segment and when the offset lies in the origin\u0027s segments (two extremely common cases).",
                                           "updatedAt":  "2018-10-30T18:41:37Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ0ODczMjQ3NA==",
                                           "createdAt":  "2018-12-19T20:26:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ahsonkhan",
                                           "body":  "Have you looked at the Rewind API on the new SequenceReader? https://github.com/dotnet/corefx/blob/3172386e3e6f268b1811a831c6890665c3154f8a/src/System.Memory/src/System/Buffers/SequenceReader.cs#L151\r\n\r\nIt captures the common cases you mentioned quite well (since we can avoid the sequence walk), and generally would be called rarely anyway. I am not sure if we should provide such functionality on the ReadonlySequence itself since it would (probably) make GetPosition slower. For more meaningful higher-level workloads (parsing data, etc.), SequenceReader should be sufficient which is why we could justify introducing \"backwards\" lookup there.\r\n\r\nDo you have a scenario that requires ReadOnlySequence (and negative offsets) that SequenceReader doesn\u0027t fit for? That said, we should try supporting negative offsets here and measure the regression as a data point.\r\n\r\nAPI review notes/video where we discuss SequenceReader: https://github.com/dotnet/apireviews/tree/master/2018/System.Buffers.SequenceReader\r\n\r\n",
                                           "updatedAt":  "2018-12-19T20:26:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ0ODk2NjQwMg==",
                                           "createdAt":  "2018-12-20T11:34:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "thargy",
                                           "body":  "\u003e Have you looked at the Rewind API on the new SequenceReader?\r\n\r\nI think that was only committed a couple of weeks after this issue, so I didn\u0027t notice it; however it does pretty much what I suggested already, noticing that if the current index in the current span is greater than, or equal to the offset then it is a trivial operation, otherwise it needs to rescan from the start.\r\n\r\n\u003e I am not sure if we should provide such functionality on the ReadonlySequence itself since it would (probably) make GetPosition slower.\r\n\r\nYou will notice that GetPosition already checks for negative values [here](https://github.com/dotnet/corefx/blob/4c95ab00fa17b61598d1f206dbe2643ede81b69b/src/System.Memory/src/System/Buffers/ReadOnlySequence.cs#L473), instead of throwing an exception (yuck!), it could always call a private method for this \u0027edge\u0027 case to provide Rewind functionality directly.  As such, it is _unlikely_ that it will slow down the normal case by adding this functionality (to be proved with benchmarking of course).\r\n\r\n\u003e Do you have a scenario that requires ReadOnlySequence (and negative offsets) that SequenceReader doesn\u0027t fit for? That said, we should try supporting negative offsets here and measure the regression as a data point.\r\n\r\nIt\u0027s really about discoverability and expectation.  There\u0027s a method that takes a signed `offset` and `origin`.  An experienced .NET dev is likely to assume that negative offsets would therefore be supported (if there were no `origin` it wouldn\u0027t be implied).  This expectation is set by similar methods such as [`Stream.Seek`](https://docs.microsoft.com/en-us/dotnet/api/system.io.stream.seek?view=netframework-4.7.2) which do support negatives.\r\n\r\nAllowing negatives will make callers more able to avoid an additinoal `if` check.  In the case where caller needs to support moving forward or backwards, it would need to check whether the input is positive or negative (or use a boolean, etc.) then call the relevant method on `SequenceReader` (either `Advance` or `Reverse`).  `Reverse` then _rechecks_ the index to ensure it\u0027s not negative.  If `SequenceReader` used a more consistent `Seek` instead of 2 seperate methods, this would be mitigated somewhat, but there\u0027s already a `GetPosition` on the sequence itself, so why aren\u0027t we just using that?\r\n\r\nUnless there are provable performance implications to the \u0027common case\u0027 of positive `offset`s in allowing a negative `offset` then it would be my contention that it is far superior to avoid another unnecessary exception and support negative `offset`s in `GetPosition` directly.",
                                           "updatedAt":  "2018-12-20T11:34:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ0ODk3OTE4NQ==",
                                           "createdAt":  "2018-12-20T12:17:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "I\u0027m not opposed to this.\r\n\r\n\u003e Unless there are provable performance implications to the \u0027common case\u0027 of positive offsets in allowing a negative offset then it would be my contention that it is far superior to avoid another unnecessary exception and support negative offsets in GetPosition directly.\r\n\r\nThis would be part of the PR. @thargy do you have time to prove this out?",
                                           "updatedAt":  "2018-12-20T12:17:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ0OTAxODQ3Mw==",
                                           "createdAt":  "2018-12-20T14:34:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "thargy",
                                           "body":  "\u003e This would be part of the PR. @thargy do you have time to prove this out?\r\n\r\nMy wife an I normally volunteer to cover the Christmas period at work to allow more of my staff to take time off, so I\u0027m going to be pretty swamped over the next few weeks and I\u0027m not immediately set up to run the benchmarks.\r\n\r\nI suspect the opptimal implementation will be to use the existing `if` check to call a private `Reverse` method, in which case there is no possible reason the forward case (+ve `offset`) would be impacted as the existing code does the same `if` followed by a throw helper method so the IL size won\u0027t change and the +ve path remains identical.\r\n\r\nThe main benefit of benchmarking will be to see the performance of the negative path, but we already accept this is a less performant use case and the accompanying documentation should point out the implication of calling with a negative `offset` is that it can be unperformant if the offset moves the position to the preceeding chunk (it being a forward linked list).\r\n\r\nThe performance of a negative `offset` will be equivalent to either _very quick_ if in the same chunk (equivalent, if not identical, to a positive `offset` in the same chunk) or identical to a forward seek to the new position from the beginning of the sequence.",
                                           "updatedAt":  "2018-12-20T14:34:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ0OTE2MzczMg==",
                                           "createdAt":  "2018-12-20T23:02:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ahsonkhan",
                                           "body":  "\u003e You will notice that GetPosition already checks for negative values [here](https://github.com/dotnet/corefx/blob/4c95ab00fa17b61598d1f206dbe2643ede81b69b/src/System.Memory/src/System/Buffers/ReadOnlySequence.cs#L473), instead of throwing an exception (yuck!), it could always call a private method for this \u0027edge\u0027 case to provide Rewind functionality directly.  As such, it is _unlikely_ that it will slow down the normal case by adding this functionality (to be proved with benchmarking of course).\r\n\r\n\u003e I suspect the opptimal implementation will be to use the existing `if` check to call a private `Reverse` method, in which case there is no possible reason the forward case (+ve `offset`) would be impacted as the existing code does the same `if` followed by a throw helper method so the IL size won\u0027t change and the +ve path remains identical.\r\n\r\nUnfortunately, it isn\u0027t that straightforward :(\r\n\r\nThe method currently gets inlined by the JIT and adding a method call would no longer make it a candidate for inlining. The JIT is able to infer (at least as far as I know) that the throw code path never returns and is able to optimize the method much more. Adding a method call would end up causing a ~50% regression. Even if we were to explicitly mark the method as `AggressiveInlining` now, we would still see a ~30% regression since the disassembly is larger now.\r\n\r\nThe only way to get the performance to match your **expectations** would be to mark the method as NoInlining (and now there is barely any performance difference between adding a method call or just throwing). However, that means we would end up with the the 50%+ regression anyway. This is why I previously said \"it would (**probably**) make GetPosition slower\".\r\n\r\n**Disassembly difference between current and potential change:**\r\nhttps://www.diffchecker.com/NLd8gvIn\r\n\r\ncc @dotnet/jit-contrib \r\n\r\n\u003e Unless there are provable performance implications to the \u0027common case\u0027 of positive `offset`s in allowing a negative `offset` then it would be my contention that it is far superior to avoid another unnecessary exception and support negative `offset`s in `GetPosition` directly.\r\n\r\nLet\u0027s say we do something like this (where SeekNegative is explicitly marked as `NoInlining`):\r\n```C#\r\npublic SequencePosition GetPosition(long offset, SequencePosition origin)\r\n{\r\n    if (offset \u003c 0)\r\n        ThrowHelper.ThrowArgumentOutOfRangeException_OffsetOutOfRange();\r\n\r\n    return Seek(origin, _sequenceEnd, offset, ExceptionArgument.offset);\r\n}\r\n\r\n[MethodImpl(MethodImplOptions.AggressiveInlining)]\r\npublic SequencePosition GetPosition_new(long offset, SequencePosition origin)\r\n{\r\n    if (offset \u003c 0)\r\n        return SeekNegative(origin, _sequenceEnd, offset, ExceptionArgument.offset);\r\n\r\n    return Seek(origin, _sequenceEnd, offset, ExceptionArgument.offset);\r\n}\r\n```\r\n\r\n**Here are some results.**\r\n\r\n``` ini\r\n\r\nBenchmarkDotNet=v0.11.3, OS=Windows 10.0.17763.194 (1809/October2018Update/Redstone5)\r\nIntel Core i7-6700 CPU 3.40GHz (Skylake), 1 CPU, 8 logical and 4 physical cores\r\n.NET Core SDK=3.0.100-preview-009825\r\n  [Host] : .NET Core 3.0.0-preview-27206-02 (CoreCLR 4.6.27204.02, CoreFX 4.7.18.60501), 64bit RyuJIT\r\n  Core   : .NET Core 3.0.0-preview-27206-02 (CoreCLR 4.6.27204.02, CoreFX 4.7.18.60501), 64bit RyuJIT\r\n\r\nJob=Core  EnvironmentVariables=COMPlus_TieredCompilation=0  Runtime=Core  \r\nToolchain=.NET Core 3.0  \r\n\r\n```\r\n|         Method |     Mean |     Error |    StdDev | Ratio |\r\n|--------------- |---------:|----------:|----------:|------:|\r\n|    GetPosition | 30.74 ns | 0.3645 ns | 0.3231 ns |  1.00 |\r\n| GetPositionNew | 56.45 ns | 0.8405 ns | 0.7451 ns |  1.84 |\r\n\r\nMarking as `AggressiveInlining` explicitly\r\n\r\n|         Method |     Mean |     Error |    StdDev | Ratio | RatioSD |\r\n|--------------- |---------:|----------:|----------:|------:|--------:|\r\n|    GetPosition | 31.66 ns | 0.6538 ns | 1.1451 ns |  1.00 |    0.00 |\r\n| GetPositionNew | 44.30 ns | 1.0094 ns | 0.9442 ns |  1.36 |    0.05 |\r\n\r\nNow, we may be able to address some of the JIT issues here OR try to implement it more creatively, but it isn\u0027t a straightforward implementation change as one would expect and there is definitely a risk of regressing performance for the common case. What are your thoughts? Should we still do it?\r\n\r\n**Diff of disassembly for the whole benchmark:**\r\nhttps://www.diffchecker.com/h1ZcYNSN\r\n\r\nBenchmark itself:\r\n```C#\r\n[Benchmark(Baseline = true)]\r\npublic SequencePosition GetPosition()\r\n{\r\n    buffer.GetPosition(offset);\r\n    buffer.GetPosition(offset);\r\n    buffer.GetPosition(offset);\r\n    buffer.GetPosition(offset);\r\n    buffer.GetPosition(offset);\r\n    buffer.GetPosition(offset);\r\n    buffer.GetPosition(offset);\r\n    buffer.GetPosition(offset);\r\n    buffer.GetPosition(offset);\r\n    return buffer.GetPosition(offset);\r\n}\r\n\r\n[Benchmark]\r\npublic SequencePosition GetPositionNew()\r\n{\r\n    buffer.GetPosition_new(offset);\r\n    buffer.GetPosition_new(offset);\r\n    buffer.GetPosition_new(offset);\r\n    buffer.GetPosition_new(offset);\r\n    buffer.GetPosition_new(offset);\r\n    buffer.GetPosition_new(offset);\r\n    buffer.GetPosition_new(offset);\r\n    buffer.GetPosition_new(offset);\r\n    buffer.GetPosition_new(offset);\r\n    return buffer.GetPosition_new(offset);\r\n}\r\n```",
                                           "updatedAt":  "2018-12-20T23:02:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1MjI4MjA0MQ==",
                                           "createdAt":  "2019-01-08T12:31:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "thargy",
                                           "body":  "Sorry for the delay @ahsonkhan, I didn\u0027t notice you\u0027re excellent response!  I never realised the JIT could optimise for the throw condition, particularly as the throw is behind a static method invocation!  I always thought throws made things worse.  Or is it more that the method called never returns?\r\n\r\nThere is an \u0027argument\u0027 that the fact `GetPosition` _can_ throw will mean that consumers are more likely to wrap it in a `try...catch`, whereas if the method is changed to _never_ throw (returns an EOF SequencePosition, or similar for OOB values) that would mitigate this issue as `try...GetPosition...catch` would _probably_ be slower then `GetPositionNew`.  Not the strongest counter argument I admit.\r\n\r\nThis then comes down to the old trade off between performance and maintainability/reliability.  There\u0027s no \u0027right\u0027 answer to that question.  The only _easy_ way forward is to find a performant way for negative to be supported, if that can\u0027t be found then it\u0027s really up to you design committee.\r\n\r\nOut of interest is `SeekNegative` aggressively inlined or inlinable, and does that have an impact?  I also noticed you\u0027re still passing around `ExceptionAgument.offset`, there might be performance gains to be made by removing bound checks/exception handling further into the code that offset the loss.",
                                           "updatedAt":  "2019-01-08T12:31:34Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1MjM3MzI3NA==",
                                           "createdAt":  "2019-01-08T16:59:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAhXYhQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "thargy",
                                                                               "createdAt":  "2019-01-10T09:01:24Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "AndyAyersMS",
                                           "body":  "I would like to see this benchmarked as it is actually used somewhere.\r\n\r\nI worry that benchmarking `GetPosition` this way via repeated back to back calls may have introduced some artifacts. The fact that this method returns a struct coupled with inlining, the two internal call sites, and the repeated calls with unused results expose some jit issues in effectively using the stack for temporary structs. You can see aspects of this with the much larger stack frame in the \"new\" case (0x1A8 -\u003e 0x2E8) and corresponding larger offsets for locals. In actual use cases the amount of stack growth should be smaller.",
                                           "updatedAt":  "2019-01-08T16:59:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5hH3G2",
                                           "createdAt":  "2023-07-10T18:01:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODAY_2w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "thargy",
                                                                               "createdAt":  "2023-07-11T18:55:13Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  null,
                                           "body":  "Due to lack of recent activity, this issue has been marked as a candidate for backlog cleanup.  It will be closed if no further activity occurs within 14 more days. Any new comment (by anyone, not necessarily the author) will undo this process.\n\nThis process is part of our [issue cleanup automation](https://github.com/dotnet/runtime/blob/main/docs/issue-cleanup.md).",
                                           "updatedAt":  "2023-07-10T18:01:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5hPHY7",
                                           "createdAt":  "2023-07-11T18:55:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "thargy",
                                           "body":  "Is this being abandoned then?",
                                           "updatedAt":  "2023-07-11T18:55:23Z"
                                       }
                                   ],
                         "totalCount":  11
                     },
        "title":  "Feature Request: ReadOnlySequence\u003cT\u003e.GetPosition(offset, origin) should support negative offsets.",
        "labels":  [
                       "enhancement",
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/27834",
        "createdAt":  "2018-11-07T04:30:14Z",
        "number":  27834,
        "author":  "ahsonkhan",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-07-24T01:51:27Z",
        "body":  "**The behavior of `Slice(offset, SequencePosition)` should match `GetPosition(offset)` and `Slice(offset)`.**\r\nI should be able to slice a `ReadOnlySequence` past the current sequence if the next one is empty (for example: `[97] -\u003e []`).\r\n\r\n```C#\r\n[Fact]\r\npublic static void ReadOnlySequenceTest()\r\n{\r\n    string jsonString = \"a\";\r\n\r\n    ReadOnlyMemory\u003cbyte\u003e dataMemory = Encoding.UTF8.GetBytes(jsonString);\r\n\r\n    var firstSegment = new BufferSegment\u003cbyte\u003e(dataMemory.Slice(0, 1));\r\n    ReadOnlyMemory\u003cbyte\u003e secondMem = dataMemory.Slice(0, 0);\r\n    BufferSegment\u003cbyte\u003e secondSegment = firstSegment.Append(secondMem);\r\n\r\n    // A two segment sequence where the second one is empty: [a]-\u003e []\r\n    var sequence = new ReadOnlySequence\u003cbyte\u003e(firstSegment, 0, secondSegment, secondMem.Length);\r\n\r\n    SequencePosition expectedPosition = sequence.GetPosition(1);\r\n    Console.WriteLine(expectedPosition.GetInteger());   // 0\r\n    Console.WriteLine(expectedPosition.GetObject());    // System.Text.Json.Tests.BufferSegment`1[System.Byte]\r\n    Assert.True(((ReadOnlySequenceSegment\u003cbyte\u003e)expectedPosition.GetObject()).Memory.IsEmpty);\r\n\r\n    SequencePosition actualPosition = sequence.Slice(1).Start;\r\n    Console.WriteLine(actualPosition.GetInteger()); // 0\r\n    Console.WriteLine(actualPosition.GetObject());  // System.Text.Json.Tests.BufferSegment`1[System.Byte]\r\n    Assert.True(((ReadOnlySequenceSegment\u003cbyte\u003e)actualPosition.GetObject()).Memory.IsEmpty);\r\n    Assert.Equal(expectedPosition, actualPosition); // True\r\n\r\n    SequencePosition actualPosition2 = sequence.GetPosition(1, sequence.Start);\r\n    Console.WriteLine(actualPosition2.GetInteger());   // 0\r\n    Console.WriteLine(actualPosition2.GetObject());    // System.Text.Json.Tests.BufferSegment`1[System.Byte]\r\n    Assert.True(((ReadOnlySequenceSegment\u003cbyte\u003e)actualPosition2.GetObject()).Memory.IsEmpty);\r\n\r\n    // System.ArgumentOutOfRangeException : Specified argument was out of the range of valid values.\r\n\r\n    /*\r\n        System.ArgumentOutOfRangeException : Specified argument was out of the range of valid values.\r\n        Parameter name: start\r\n        Stack Trace:\r\n        E:\\GitHub\\Fork\\corefx\\src\\System.Memory\\src\\System\\ThrowHelper.cs(31,0): at System.ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument argument)\r\n        E:\\GitHub\\Fork\\corefx\\src\\System.Memory\\src\\System\\Buffers\\ReadOnlySequence.cs(281,0): at System.Buffers.ReadOnlySequence`1.Slice(Int64 start, SequencePosition end)\r\n        E:\\GitHub\\Fork\\corefx\\src\\System.Memory\\src\\System\\Buffers\\ReadOnlySequence.cs(388,0): at System.Buffers.ReadOnlySequence`1.Slice(Int32 start, SequencePosition end)\r\n        E:\\GitHub\\Fork\\corefx\\src\\System.Text.Json\\tests\\Utf8JsonReaderTests.TryGet.cs(357,0): at System.Text.Json.Tests.Utf8JsonReaderTests.ReadOnlySequenceTest()\r\n    */\r\n    sequence = sequence.Slice(1, sequence.Start);\r\n}\r\n```\r\n\r\nWe need to use the Slice overload that takes a `SequencePosition` for performance to avoid having to scan the segments from the beginning every time. Using `GetPosition` with `long` is too slow:\r\nhttps://github.com/dotnet/corefxlab/blob/63ef1a5db4fdbfcf9822b8cd2cbc3921b3d3cb9e/src/System.Text.JsonLab/System/Text/Json/JsonUtf8Reader.cs#L112\r\n\r\ncc @pakrym, @davidfowl ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYixm7Q==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ2OTQyNTc0Nw==",
                                           "createdAt":  "2019-03-04T21:19:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "devsko",
                                           "body":  "@ahsonkhan is this still a problem? Utf8JsonReader seems to work…\r\nhttps://github.com/dotnet/corefx/blob/master/src/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.cs#L118",
                                           "updatedAt":  "2019-03-04T21:19:35Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ2OTQyODcyMQ==",
                                           "createdAt":  "2019-03-04T21:28:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ahsonkhan",
                                           "body":  "There\u0027s still an issue with the ROSequence `.Slice` API. `GetPosition` works as expected which is why `Utf8JsonReader` can use it.",
                                           "updatedAt":  "2019-03-04T21:28:43Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ2OTQyOTU2Mw==",
                                           "createdAt":  "2019-03-04T21:31:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAkXVVQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ahsonkhan",
                                                                               "createdAt":  "2019-03-04T21:38:56Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "devsko",
                                           "body":  "I\u0027m asking because I think I just fixed dotnet/corefx#35254 (PR coming soon) and thought it might be related.",
                                           "updatedAt":  "2019-03-04T21:31:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ2OTQzMDIwMQ==",
                                           "createdAt":  "2019-03-04T21:33:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "devsko",
                                           "body":  "But I don\u0027t understand this issue. I would say the sample throws the exception as expected.",
                                           "updatedAt":  "2019-03-04T21:33:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ2OTQzMTg5Ng==",
                                           "createdAt":  "2019-03-04T21:38:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ahsonkhan",
                                           "body":  "\u003e But I don\u0027t understand this issue. I would say the sample throws the exception as expected.\r\n\r\n```C#\r\n// A two segment sequence where the second one is empty: [a]-\u003e []\r\nSequencePosition pos = sequence.GetPosition(1, sequence.Start); // success\r\nsequence = sequence.Slice(1, sequence.Start); // throws\r\n```\r\n\r\nWhy would you consider the exception when calling slice, expected?",
                                           "updatedAt":  "2019-03-04T21:38:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ2OTQzMzgzOQ==",
                                           "createdAt":  "2019-03-04T21:44:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAkXdzw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ahsonkhan",
                                                                               "createdAt":  "2019-03-04T22:15:18Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "devsko",
                                           "body":  "As I understand the API this means a slice from position 1 back to position 0. The second parameter is the end of the resulting slice. The second param of .GetPosition() has a different meaning. What slice would you expect it to return?",
                                           "updatedAt":  "2019-03-04T21:44:48Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ2OTQ0MzY3MQ==",
                                           "createdAt":  "2019-03-04T22:15:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAkXgBA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "devsko",
                                                                               "createdAt":  "2019-03-04T22:25:13Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "ahsonkhan",
                                           "body":  "\u003e As I understand the API this means a slice from position 1 back to position 0. The second parameter is the end of the resulting slice.\r\n\r\nActually, you are totally right. I confused the parameters of `GetPosition` and `Slice` (end vs origin). Passing in `sequence.Start` as the **end** position should continue to throw.\r\n```C#\r\npublic ReadOnlySequence\u003cT\u003e Slice(int start, SequencePosition end) { throw null; }\r\npublic ReadOnlySequence\u003cT\u003e Slice(long start, SequencePosition end) { throw null; }\r\npublic SequencePosition GetPosition(long offset, SequencePosition origin)\r\n```\r\n\r\nFor now, it looks like this issue is non-actionable. Let me page back the scenario where I was seeing an issue and double check the expected behavior.  I\u0027ll either update the issue or close it based on my findings. Thanks for bringing up the clarification and correcting me :)",
                                           "updatedAt":  "2019-03-04T22:15:20Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ2OTQ0NzA4Mw==",
                                           "createdAt":  "2019-03-04T22:26:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "devsko",
                                           "body":  "Sounds good. Other PR is ready.",
                                           "updatedAt":  "2019-03-04T22:26:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ5OTE0MTQzNg==",
                                           "createdAt":  "2019-06-05T15:47:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MarcoRossignoli",
                                           "body":  "\u003e For now, it looks like this issue is non-actionable. Let me page back the scenario where I was seeing an issue and double check the expected behavior. I\u0027ll either update the issue or close it based on my findings. Thanks for bringing up the clarification and correcting me :)\r\n\r\n@ahsonkhan should we close this or move future?",
                                           "updatedAt":  "2019-06-05T15:48:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ5OTY5NzUxNA==",
                                           "createdAt":  "2019-06-06T22:55:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ahsonkhan",
                                           "body":  "I haven\u0027t gotten a chance to look again. Moving to future for now. Thanks for the ping :)",
                                           "updatedAt":  "2019-06-06T22:55:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iLGbt",
                                           "createdAt":  "2023-07-24T01:42:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sowelipililimute",
                                           "body":  "i think running into this trying to use system.io.pipelines, i\u0027m not sure what this means i need to do to workaround this\r\n\r\nedit: \r\n\r\ni should\u0027ve provided more context:\r\n```c#\r\nvar result = await reader.ReadAtLeastAsync(2);\r\nvar buffer = result.Buffer;\r\nvar position = buffer.GetPosition(sizeof(UInt16));\r\nvar packetLengthBuffer = buffer.Slice(0, position);\r\nreader.AdvanceTo(packetLengthBuffer.End);\r\nif (result.IsCompleted)\r\n    return null;\r\n\r\nvar packetLength = ReadUInt16(packetLengthBuffer);        \r\nif (packetLength \u003c 3)\r\n    return null;\r\n\r\nConsole.WriteLine($\"{dbg} length {packetLength} contents: {Convert.ToHexString(packetLengthBuffer.First.Span)}\");\r\n\r\nresult = await reader.ReadAtLeastAsync(1);\r\nbuffer = result.Buffer;\r\nposition = buffer.GetPosition(sizeof(byte));\r\nvar packetTypeBuffer = buffer.Slice(0, position);\r\nreader.AdvanceTo(packetTypeBuffer.End);\r\nif (result.IsCompleted)\r\n    return null;\r\n\r\nvar packetType = ReadUInt8(packetTypeBuffer);\r\n\r\nConsole.WriteLine($\"{dbg} type {packetType} contents: {Convert.ToHexString(packetTypeBuffer.First.Span)}\");\r\n\r\nvar bodyLength = packetLength - 3;\r\n\r\nresult = await reader.ReadAtLeastAsync(bodyLength);\r\nbuffer = result.Buffer;\r\nposition = buffer.GetPosition(bodyLength);\r\nvar packetDataBuffer = buffer;\r\nreader.AdvanceTo(packetDataBuffer.End);\r\nif (result.IsCompleted)\r\n    return null;\r\n\r\nConsole.WriteLine($\"{dbg} body contents: {Encoding.UTF8.GetString(packetDataBuffer.First.Span)}\");\r\n// throws exception here ^^^\r\n// doesn\u0027t throw if i read bodyLength - 1 bytes, but i need that last byte\r\n\r\nreturn new(packetType, packetDataBuffer);\r\n```\r\n\r\ni\u0027m writing a tcp server using system.io.pipelines, and i\u0027m having trouble getting the last byte the client has sent before idling, seemingly matching this issue.",
                                           "updatedAt":  "2023-07-24T01:51:27Z"
                                       }
                                   ],
                         "totalCount":  11
                     },
        "title":  "ReadOnlySequence.Slice which accepts a SequencePosition throws ArgumentOutOfRangeException unexpectedly.",
        "labels":  [
                       "bug",
                       "area-System.Memory",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/28942",
        "createdAt":  "2019-03-12T02:44:54Z",
        "number":  28942,
        "author":  "layomia",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODMgExQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Gnbrkm41",
                                            "createdAt":  "2019-03-15T08:55:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "khellang",
                                            "createdAt":  "2019-10-21T13:49:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "watfordgnf",
                                            "createdAt":  "2019-10-28T14:42:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "airbreather",
                                            "createdAt":  "2019-11-01T12:53:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "theolivenbaum",
                                            "createdAt":  "2020-05-04T10:20:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ericwj",
                                            "createdAt":  "2020-11-09T16:01:32Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2022-03-17T18:09:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MineCake147E",
                                            "createdAt":  "2023-11-10T10:48:05Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Danila24ru",
                                            "createdAt":  "2024-12-16T13:56:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aelij",
                                            "createdAt":  "2025-08-25T12:24:20Z"
                                        }
                                    ],
                          "totalCount":  10
                      },
        "updatedAt":  "2022-03-02T17:44:26Z",
        "body":  "_This proposal stems from a discussion (https://github.com/dotnet/coreclr/pull/22999) regarding adding a new format specifier “I” to the UTF8 DateTime(Offset) parser (and subsequently formatter) for ISO 8601 strings. The new format was to be used by the `Utf8JsonReader/Writer`.\r\nGiven feedback, it is clear that adding a new format specifier requires further investigation and design.\r\nThe workaround for the `Utf8JsonReader/Writer` was to implement the parsing and formatting logic internally._\r\n\r\nWe are looking to add performant UTF-8 `DateTime(Offset)` read/write support (https://github.com/dotnet/corefx/issues/34690, https://github.com/dotnet/corefx/issues/34576) to the `Utf8JsonReader/Writer` for the following ISO 8601 profile:   \r\n\r\n`YYYY-MM-DD[Thh:mm[:ss[.s]][TZD]]` \r\n\r\nwhere:   \r\n\r\n`YYYY` = four-digit year   \r\n`MM` = two-digit month (01=January, etc.)   \r\n`DD` = two-digit day of month (01 through 31)   \r\n`T` = ‘T’ or ‘ ‘   \r\n`hh` = two digits of hour (00 through 23) (am/pm NOT allowed)   \r\n`mm` = two digits of minute (00 through 59)   \r\n`ss` = two digits of second (00 through 59)   \r\n`s` = one or more digits representing a decimal fraction of a second   \r\n`TZD` = time zone designator (Z or +hh:mm or -hh:mm or +hhmm or –hhmm or +hh or -hh)   \r\n\r\n### Rationale and Usage  \r\n\r\nISO 8601 is an unambiguous and prolific date and time standard, important for interoping with different systems/languages.  \r\n\r\nAs part of 3.0 we are adding the new `Utf8JsonReader/Writer/Document` types. We have implemented `(Try)GetDateTime(Offset)` and `WriteString(Value)` methods on the Json Reader/Writer types (https://github.com/dotnet/corefx/pull/35903, https://github.com/dotnet/corefx/pull/35966) to read and write ISO 8601 `DateTime(Offset)` strings. The parsing/formatting logic  is currently internal to the types: \r\n\r\n`Utf8JsonReader`\r\nhttps://github.com/dotnet/corefx/blob/ef1b1835a8459cee50d895b1e2040bb2336eeeda/src/System.Text.Json/src/System/Text/Json/Reader/JsonReaderHelper.Date.cs#L43-L357 \r\n\r\n`Utf8JsonWriter`\r\nhttps://github.com/dotnet/corefx/blob/52f3ad9f5f1276833fe8f53c79b5a995c8865df9/src/System.Text.Json/src/System/Text/Json/Writer/JsonWriterHelper.Date.cs#L22-L126\r\n\r\nThe proposal for adding ISO 8601 support is to add a new custom format specifier to the Utf8Parser/Formatter for the `(Try)GetDateTime(Offset)` methods to depend on (in place of the internal logic) with the following specifications.  This will be particularly beneficial if there is a need for flexible ISO 8601 processing beyond Json.  \r\n\r\n ### API (No changes)  \r\nAPI methods for DateTime reading and writing have already been approved. \r\n\r\n```C#   \r\npublic ref partial struct Utf8JsonReader   \r\n{ \r\n    public DateTime GetDateTime(); \r\n    public DateTimeOffset GetDateTimeOffset(); \r\n    public bool TryGetDateTime(out DateTime value); \r\n    public bool TryGetDateTimeOffset(out DateTimeOffset value); \r\n}   \r\n\r\npublic ref partial struct Utf8JsonWriter   \r\n{   \r\n    public void WriteString(System.ReadOnlySpan\u003cbyte\u003e utf8PropertyName, System.DateTime value, bool escape = true) { } \r\n    public void WriteString(System.ReadOnlySpan\u003cbyte\u003e utf8PropertyName, System.DateTimeOffset value, bool escape = true) { } \r\n    public void WriteString(System.ReadOnlySpan\u003cchar\u003e propertyName, System.DateTime value, bool escape = true) { } \r\n    public void WriteString(System.ReadOnlySpan\u003cchar\u003e propertyName, System.DateTimeOffset value, bool escape = true) { } \r\n    public void WriteStringValue(System.DateTime value) { } \r\n    public void WriteStringValue(System.DateTimeOffset value) { }  \r\n}   \r\n\r\npublic readonly partial struct JsonElement   \r\n{ \r\n    public DateTime GetDateTime(); \r\n    public DateTimeOffset GetDateTimeOffset(); \r\n    public bool TryGetDateTime(out DateTime value); \r\n    public bool TryGetDateTimeOffset(out DateTimeOffset value);   \r\n}   \r\n```   \r\n\r\n  These methods are could use the already existing `Utf8Parser/Formatter` types for parsing and formatting `DateTime` data to replace the internally implemented parse/format logic:  \r\n\r\n```C#  \r\npublic static partial class Utf8Parser  \r\n{ \r\n    public static bool TryParse(System.ReadOnlySpan\u003cbyte\u003e source, out System.DateTime value, out int bytesConsumed, char standardFormat = \u0027\\0\u0027) { throw null; } \r\n    public static bool TryParse(System.ReadOnlySpan\u003cbyte\u003e source, out System.DateTimeOffset value, out int bytesConsumed, char standardFormat = \u0027\\0\u0027) { throw null; }  \r\n}  \r\n\r\npublic static partial class Utf8Formatter  \r\n{ \r\n    public static bool TryFormat(System.DateTime value, System.Span\u003cbyte\u003e destination, out int bytesWritten, System.Buffers.StandardFormat format = default(System.Buffers.StandardFormat)) { throw null; } \r\n    public static bool TryFormat(System.DateTimeOffset value, System.Span\u003cbyte\u003e destination, out int bytesWritten, System.Buffers.StandardFormat format = default(System.Buffers.StandardFormat)) { throw null; }  \r\n}  \r\n```  \r\n\r\n### Details  \r\nOf note are the `format` and `standardFormat` parameters of the `TryParse` and `TryFormat` methods of the Utf8Parser/Formatter. The current options for the format are “G”/standard, “O”, and “R”. Of these, only “O” implements a profile of the ISO 8601 standard, the strict Round-trip format specifier: `yyyy\u0027-\u0027MM\u0027-\u0027dd\u0027T\u0027HH\u0027:\u0027mm\u0027:\u0027ss\u0027.\u0027fffffffK`. Most ISO 8601 adopters do not use this profile. Thus, it is beneficial to implement a new format which is more permissive and also very performant. We can call it “I”.  \r\n\r\n### Open Questions  \r\n- Outside of Json, do we have a need for UTF-8 ISO support?  \r\n- To what extent do we wish to support ISO 8601? Is the proposed profile sufficient? There are some variants which support using commas instead of periods etc. \r\n- If we are only supporting ISO 8601 for Json, should it remain as an implementation internal to `Utf8JsonReader/Writer` rather than rolling up to `Utf8Parser/Formatter`? \r\n- If ISO 8601 should be implemented on the `Utf8Parser/Formatter` types, should it be as a new API (e.g. `TryParseAsISO`/`TryFormatToISO` ) rather than a new format specifier (the `format`/`standardFormat` arguments)? \r\n- If we\u0027re adding ISO 8601 support to `Utf8Parser/Formatter`, do we also need/want to roll up support to `DateTime{Offset}.{Try}Parse/Format/ToString`?  \r\n\r\n### Pull Requests \r\n- The initial PR adding the new custom format specifier \"I\" to `Utf8Parser`: https://github.com/dotnet/coreclr/pull/22999. \r\n- The PR adding internal ISO 8601 parsing logic to `Utf8JsonReader`: https://github.com/dotnet/corefx/pull/35903. \r\n- The PR adding internal ISO 8601 formatting logic to `Utf8JsonWriter`: https://github.com/dotnet/corefx/pull/35903. ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOPwOj9w==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ3MjAwNTk3Nw==",
                                           "createdAt":  "2019-03-12T13:43:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBWKgZA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ericwj",
                                                                               "createdAt":  "2020-11-09T16:01:28Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e If we\u0027re adding ISO 8601 support to Utf8Parser/Formatter, do we also need/want to roll up support to DateTime{Offset}.{Try}Parse/Format/ToString?\r\n\r\nIf this format is as common as is cited, then I\u0027d say yes.  If there\u0027s value in adding support to the UTF8-based implementation, there\u0027s similar value in adding support to the UTF16-based implementation.",
                                           "updatedAt":  "2019-03-12T13:43:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYxMTM4ODY5MA==",
                                           "createdAt":  "2020-04-09T07:58:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCx69hw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "theolivenbaum",
                                                                               "createdAt":  "2020-05-04T10:20:54Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "robertmircea",
                                                                               "createdAt":  "2022-12-29T22:39:49Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "neuecc",
                                           "body":  "I\u0027ve created new logger that only supports directly write to UTF8 to support zero allocation formatting.\r\nhttps://github.com/Cysharp/ZLogger\r\nInternally, `Utf8Formatter.TryFormat(DateTime, StandardFormat)` is called.\r\n\r\nThe DateTime format is important when creating a human-readable log.\r\nAnd the default format is hard to read,\r\nI want to change like \"yyyy-MM-dd HH:mm:ss\", but it\u0027s not supported.\r\n\r\nFor example, I\u0027d be happy to write something like this\r\n\r\n```csharp\r\n// Additing Log\u0027s prefix\r\nlogging.AddZLoggerConsole(options =\u003e\r\n{\r\n    // Action\u003cIBufferWriter\u003cbyte\u003e, LogInfo\u003e?\r\n    options.PrefixFormatter = (writer, info) =\u003e ZString.Utf8Format(writer, \"[{0}][{1:yyyy-MM-dd HH:mm:ss}]\", info.LogLevel, info.Timestamp.DateTime.ToLocalTime());\r\n});\r\n\r\n// {1:yyyy-MM-dd HH:mm:ss} will translate to\r\n// Utf8Formatter.TryFormat(info.Timestamp, dest, out var written, StandardFormat.Parse(\"yyyy-MM-dd HH:mm:ss\"));\r\n\r\n// If you can set this option, you will get the following message\r\n// [Debug][2020-04-09 07:56:12]foo\r\nlogger.ZLogDebug(\"foo\");\r\n```",
                                           "updatedAt":  "2020-04-09T08:03:04Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYxMTU5OTA3OA==",
                                           "createdAt":  "2020-04-09T15:43:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "\u003e `ss` = two digits of second (00 through 59)\r\n\r\n.... officially 8601 allows for leap seconds, so the inclusive range should 00-60.  This is mostly fine as `DateTime(Offset)` will accept (valid) leap seconds (although it converts them to the 59th second).",
                                           "updatedAt":  "2020-04-09T15:43:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyNDE2MTM3NQ==",
                                           "createdAt":  "2020-11-09T17:32:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericwj",
                                           "body":  "Sorry for misusing this issue about an `I` format specifier to argue that `O` is broken and should be fixed, but it appears to me to be the right place for being highly related. For use with JSON, I think ISO8601 is usually overkill. Rather, the `O` specifier should be enough to work with formats conforming to [RFC3339](https://tools.ietf.org/html/rfc3339).\r\n\r\nSo, although running the risk of duplicating issues that you fixed in `JsonSerializer` and will adopt to fix with `I`, can I ask for `O` \r\n* at least to mean the same with `Utf8Parser` as it does with `DateTime/Offset` - i.e. to use the format\r\n`yyyy\u0027-\u0027MM\u0027-\u0027dd\u0027T\u0027HH\u0027:\u0027mm\u0027:\u0027ss\u0027.\u0027FFFFFFFK`  \r\ninstead of  \r\n`yyyy\u0027-\u0027MM\u0027-\u0027dd\u0027T\u0027HH\u0027:\u0027mm\u0027:\u0027ss\u0027.\u0027fffffffK`  \r\nor better yet to accept *any number* of fractional digits, including none?\r\n* with `Utf8Formatter` to honor *any* `StandardFormat.Precision` - even those larger than 7? Idk up to 98 is fine. The parameter is ignored completely right now.\r\n* with `Utf8Parser` to properly set the `DateTimeKind`? At least parsing a date ending in `Z` produces `Unspecified`, which parsing with `O` should never produce unless the timezone is absent completely. Even `DateTime.TryParseExact(\u0027O\u0027)` produces `Unspecified` given a string containing a timezone and parsing with `RoundTripKind`? That is a bug too, or I don\u0027t get it.\r\n\r\nAnd can I ask for `DateTime/Offset.ToString()` not to throw and produce the requested number of digits when given a custom format string with any number of `f` or `F` characters in it?\r\n\r\nThumbs up for extracting what `JsonSerializer` does into generally useful API, since even just wanting to serialize UTC but convert to local after deserialization is a reason to write a `JsonConverter` after which the `JsonSerializer` behavior cannot be reproduced. Another good reason is that only reading this issue explains to me the surprise after surprise I ran into after having setup `JsonSerializerOptions` with a converter added and not looking back much after that.",
                                           "updatedAt":  "2020-11-09T17:32:37Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyNDI3NzI0OA==",
                                           "createdAt":  "2020-11-09T21:04:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "\u003e  even those larger than 7? Idk up to 98 is fine.\r\n\r\nIn particular, Java (and NodaTime, and probably some databases) supports _storing and passing_ nanosecond precision, so 9 digits would help with interoperability.  (In terms of a maximum limit, the 19 maximum digits available were NTP to shift to a 64-bit fractional second should likely be enough, although even that is overkill)\r\n\r\nHowever, note that actually/accurately getting a timestamp that precise requires special hardware - no consumer/server hardware is going to do it - and the best that can be done is 7 digits (... in most cases - some hardware or older software stacks may still be limited to less than 3).  Doing this may also play havoc with round tripping (because ingestion could only accept 7 digits, and so would return truncated values).",
                                           "updatedAt":  "2020-11-09T21:04:34Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyNDI5MTA4OQ==",
                                           "createdAt":  "2020-11-09T21:32:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericwj",
                                           "body":  "Sure, `TimeSpan.FromSeconds(1).Ticks == 10_000_000` and `new DateTimeOffset(10_000_000, default) == \"01/01/0001 00:00:01 +00:00\"` exactly.\r\n\r\nI was not talking about getting the precision. That requires not using `DateTime` or `DateTimeOffset` in the first place indeed - and thus also using some different way of parsing and formatting, different from the `Utf8Parser/Formatter` and `DateTime/Offset` API.\r\n\r\nI\u0027m just talking about accepting and producing the required format that can be expressed through the existing API, truncating or rounding to 7 digits when parsing and producing zero padding on formatting.",
                                           "updatedAt":  "2020-11-09T21:36:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_A6P3",
                                           "createdAt":  "2022-03-02T17:44:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ovska",
                                           "body":  "Is there yet a consensus on whether this should be implemented, as the issue is still open but with a suggestion-label? For what it\u0027s worth, I think it\u0027s an important missing piece in Utf8Parser.",
                                           "updatedAt":  "2022-03-02T17:44:26Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "Add flexible ISO 8601 support to Utf8Parser/Formatter (and beyond?)",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/29758",
        "createdAt":  "2019-06-04T03:18:45Z",
        "number":  29758,
        "author":  "daveaglick",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODAFxhA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Gnbrkm41",
                                            "createdAt":  "2019-06-04T16:47:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "StanislavPrusac",
                                            "createdAt":  "2019-06-11T08:09:51Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "StanislavPrusac",
                                            "createdAt":  "2019-06-11T08:09:57Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "TheCodeTraveler",
                                            "createdAt":  "2019-09-23T19:13:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "tomrus88",
                                            "createdAt":  "2019-10-24T01:27:16Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "xsoheilalizadeh",
                                            "createdAt":  "2020-01-04T19:00:42Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "xsoheilalizadeh",
                                            "createdAt":  "2020-01-04T19:00:47Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "Jjagg",
                                            "createdAt":  "2020-01-14T16:53:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Jjagg",
                                            "createdAt":  "2020-01-14T16:53:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Symbai",
                                            "createdAt":  "2020-01-20T00:21:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pentp",
                                            "createdAt":  "2020-06-30T21:10:57Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "drmathias",
                                            "createdAt":  "2020-08-20T19:18:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Eli-Black-Work",
                                            "createdAt":  "2021-04-22T09:00:33Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "feO2x",
                                            "createdAt":  "2021-12-06T04:45:58Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kronic",
                                            "createdAt":  "2021-12-06T11:08:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "wstaelens",
                                            "createdAt":  "2022-01-18T07:59:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MendelMonteiro",
                                            "createdAt":  "2022-02-04T07:30:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "randomC0der",
                                            "createdAt":  "2022-03-23T02:05:04Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pablocom",
                                            "createdAt":  "2022-03-30T08:47:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "wertzui",
                                            "createdAt":  "2022-07-22T13:05:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "khamroevjs",
                                            "createdAt":  "2022-09-20T22:22:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "nesterenko-kv",
                                            "createdAt":  "2022-10-17T09:33:17Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "nesterenko-kv",
                                            "createdAt":  "2022-10-17T09:33:18Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "N0D4N",
                                            "createdAt":  "2022-11-01T07:41:03Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dimkasta",
                                            "createdAt":  "2023-03-11T11:23:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "j0nimost",
                                            "createdAt":  "2023-04-25T04:26:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "HunteRoi",
                                            "createdAt":  "2023-06-07T12:02:52Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aradalvand",
                                            "createdAt":  "2023-07-30T18:51:15Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "glyder",
                                            "createdAt":  "2023-09-05T00:27:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "akarboush",
                                            "createdAt":  "2023-09-22T11:47:31Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "CodingMadness",
                                            "createdAt":  "2023-10-03T23:07:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sveinungf",
                                            "createdAt":  "2023-10-04T22:11:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "arknu",
                                            "createdAt":  "2025-03-14T10:04:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pabloramirez-ej",
                                            "createdAt":  "2025-03-14T15:07:20Z"
                                        }
                                    ],
                          "totalCount":  34
                      },
        "updatedAt":  "2024-08-18T21:19:40Z",
        "body":  "It would be useful to have `Replace()` methods for `ReadOnlySpan\u003cchar\u003e` similar to the ones for `string`. This was briefly mentioned in dotnet/runtime#22434 but then [the `Replace` API was removed from the proposal](https://github.com/dotnet/corefx/issues/21395#issuecomment-359906138) for needing more work. As far as I can tell, it hasn\u0027t been revisited yet.\r\n\r\nHere\u0027s my proposal to get things started:\r\n```csharp\r\npublic static class MemoryExtensions\r\n{\r\n    public static ReadOnlySpan\u003cchar\u003e Replace(\r\n        this ReadOnlySpan\u003cchar\u003e str,\r\n        ReadOnlySpan\u003cchar\u003e oldValue,\r\n        ReadOnlySpan\u003cchar\u003e newValue);\r\n\r\n    // If buffer is null or too small a new internal one will be created with the correct size and bufferCount = 0, return value is the created buffer\r\n    // If buffer is the correct size it will be filled and bufferCount = buffer.Length (how much was filled), return value is the filled buffer\r\n    // If buffer is too big it will be filled and bufferCount = how much was filled, return value is a slice of the filled buffer\r\n    public static ReadOnlySpan\u003cchar\u003e Replace(\r\n        this ReadOnlySpan\u003cchar\u003e str,\r\n        ReadOnlySpan\u003cchar\u003e oldValue,\r\n        ReadOnlySpan\u003cchar\u003e newValue,\r\n        Span\u003cchar\u003e buffer,\r\n        out int bytesWritten)\r\n}\r\n```\r\n\r\nI think this covers almost all use cases including those where the user wants to provide their own refillable buffer to reduce allocations. These two APIs have the following features:\r\n- Provides an overload that works almost exactly like the `string` version.\r\n- The overload that takes a buffer can be used when the user doesn\u0027t want the `Replace` method to allocate an internal buffer.\r\n- If the provided buffer isn\u0027t large enough, a new one will be allocated ensuring success. I prefer this over a try pattern where the replace call might fail - I don\u0027t think failing string operations is a user-friendly option.\r\n- The `bytesWritten` value can be checked to see if the provided buffer was used or filled (and by how much) and the caller can act accordingly.\r\n\r\nQuestion: would we also want a `public static ReadOnlySpan\u003cchar\u003e Replace(this ReadOnlySpan\u003cchar\u003e str, char oldChar, char newChar)`? If so, that\u0027s probably easy enough to implement separately since we don\u0027t need to calculate the final buffer size or look ahead to determine matching.\r\n\r\nI\u0027ve been working out a naive implementation alongside the API definition to clarify my thoughts on the API surface. Here\u0027s what I\u0027ve got so far - I include it for reference and as a point of discussion (and also to get any tips on how to further reduce allocations or improve performance, it\u0027s not quite as light or fast as the OOTB `string.Replace()` though I suspect there are still some optimizations to be had):\r\n\r\n\u003cdetails\u003e\u003csummary\u003eExpand\u003c/summary\u003e\r\n\r\n```csharp\r\npublic static class SpanExtensions\r\n{\r\n    public static ReadOnlySpan\u003cchar\u003e Replace(\r\n    this ReadOnlySpan\u003cchar\u003e str,\r\n    ReadOnlySpan\u003cchar\u003e oldValue,\r\n    ReadOnlySpan\u003cchar\u003e newValue) =\u003e\r\n    Replace(str, oldValue, newValue, null, out int _);\r\n\r\n    public static ReadOnlySpan\u003cchar\u003e Replace(\r\n        this ReadOnlySpan\u003cchar\u003e str,\r\n        ReadOnlySpan\u003cchar\u003e oldValue,\r\n        ReadOnlySpan\u003cchar\u003e newValue,\r\n        Span\u003cchar\u003e buffer,\r\n        out int bytesWritten)\r\n    {\r\n        if (str == null)\r\n        {\r\n            throw new ArgumentNullException(nameof(str));\r\n        }\r\n        if (oldValue == null)\r\n        {\r\n            throw new ArgumentNullException(nameof(oldValue));\r\n        }\r\n        if (oldValue.Length == 0)\r\n        {\r\n            throw new ArgumentException(\"String cannot be of zero length\", nameof(oldValue));\r\n        }\r\n\r\n        // When they\u0027re both equal just return the original\r\n        bytesWritten = 0;\r\n        if (newValue != null \u0026\u0026 oldValue.Equals(newValue, StringComparison.Ordinal))\r\n        {\r\n            return str;\r\n        }\r\n\r\n        // Get the replacement positions// Figure out the replacement positions\r\n        // Partly lifted from logic in StringBuilder.Replace()\r\n        int[] replacements = null;\r\n        int replacementsCount = 0;\r\n        int strIndex = 0;\r\n        for (int c = 0; c \u003c str.Length; c++)\r\n        {\r\n            if (str[c] == oldValue[strIndex])\r\n            {\r\n                strIndex++;\r\n            }\r\n            if (strIndex == oldValue.Length)\r\n            {\r\n                if (replacements == null)\r\n                {\r\n                    replacements = new int[5];\r\n                }\r\n                else if (replacementsCount \u003e replacements.Length)\r\n                {\r\n                    // From StringBuilder.Replace() - grow by 1.5x but more in the begining\r\n                    int[] newReplacements = new int[replacements.Length * 3 / 2 + 4];\r\n                    Array.Copy(replacements, newReplacements, replacements.Length);\r\n                    replacements = newReplacements;\r\n                }\r\n                replacements[replacementsCount++] = c - strIndex + 1;\r\n                strIndex = 0;\r\n            }\r\n        }\r\n\r\n        // Return the original string if no replacements were performed\r\n        if (replacementsCount == 0)\r\n        {\r\n            return str;\r\n        }\r\n\r\n        // Size the buffer\r\n        if (buffer == null || buffer.Length \u003c str.Length + ((newValue.Length - oldValue.Length) * replacementsCount))\r\n        {\r\n            // Create a new buffer because the passed in one wasn\u0027t the right size\r\n            buffer = new char[str.Length + ((newValue.Length - oldValue.Length) * replacementsCount)];\r\n        }\r\n        else\r\n        {\r\n            // Use the existing buffer and set the count\r\n            bytesWritten = str.Length + ((newValue.Length - oldValue.Length) * replacementsCount);\r\n        }\r\n\r\n        // Perform replacements\r\n        strIndex = 0;\r\n        int charsIndex = 0;\r\n        for (int c = 0; c \u003c replacementsCount; c++)\r\n        {\r\n            // Copy up to the next replacement\r\n            while (strIndex \u003c replacements[c])\r\n            {\r\n                buffer[charsIndex++] = str[strIndex++];\r\n            }\r\n\r\n            // Perform the replacement (use strIndex to temporarily hold value index)\r\n            strIndex = 0;\r\n            while (strIndex \u003c newValue.Length)\r\n            {\r\n                buffer[charsIndex++] = newValue[strIndex++];\r\n            }\r\n            strIndex = replacements[c] + oldValue.Length;\r\n        }\r\n\r\n        // No more replacements, copy the rest of the string\r\n        while (strIndex \u003c str.Length)\r\n        {\r\n            buffer[charsIndex++] = str[strIndex++];\r\n        }\r\n\r\n        // Slice the buffer if we didn\u0027t use the whole thing\r\n        return charsIndex == bytesWritten ? buffer : buffer.Slice(0, charsIndex);\r\n    }\r\n}\r\n```\r\n\u003c/details\u003e\r\n\r\ncc @davkean who expressed an interest in this API.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOiNDx9Q==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ5ODUwOTkyMw==",
                                           "createdAt":  "2019-06-04T03:50:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "daveaglick",
                                           "body":  "Feedback on Twitter seems to be that a `TryReplace` version should be provided as well (or instead). I’d amend the proposal to include...\r\n```csharp\r\npublic static bool TryReplace(\r\n    this ReadOnlySpan\u003cchar\u003e str,\r\n    ReadOnlySpan\u003cchar\u003e oldValue,\r\n    ReadOnlySpan\u003cchar\u003e newValue,\r\n    Span\u003cchar\u003e buffer,\r\n    out int bufferSize)\r\n}\r\n```\r\n...where `bufferSize` would always indicate the required number of char regardless of success (so a properly sized buffer could be allocated in a second pass on failure). This overload would not attempt to allocate a new buffer if the provided one is not sufficient.\r\n\r\nI do feel like having “just works” versions are important. Not everyone is going to care about allocations or performance and will want to control those - I’m guessing as `Span` (and particularly `ReadOnlySpan\u003cchar\u003e`) become more popular and common, there will be users who have a string-like span from somewhere else and just want to do string-like operations without actually converting to and from strings.",
                                           "updatedAt":  "2019-06-04T03:50:47Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ5ODY0NTYwNw==",
                                           "createdAt":  "2019-06-04T12:13:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "daveaglick",
                                           "body":  "Thought about this some more, here\u0027s an updated proposal:\r\n\r\n```csharp\r\npublic static class MemoryExtensions\r\n{\r\n    // Allocates a new buffer, fills it, and returns it\r\n    public static ReadOnlySpan\u003cchar\u003e Replace(\r\n        this ReadOnlySpan\u003cchar\u003e str,\r\n        ReadOnlySpan\u003cchar\u003e oldValue,\r\n        ReadOnlySpan\u003cchar\u003e newValue);\r\n\r\n    // Always returns the required buffer size regardless of success\r\n    public static bool TryReplace(\r\n        this ReadOnlySpan\u003cchar\u003e str,\r\n        ReadOnlySpan\u003cchar\u003e oldValue,\r\n        ReadOnlySpan\u003cchar\u003e newValue,\r\n        Span\u003cchar\u003e buffer,\r\n        out int bufferSize);\r\n\r\n    // Always returns the required buffer size regardless of success\r\n    public static bool TryReplace(\r\n        this Span\u003cchar\u003e str,\r\n        ReadOnlySpan\u003cchar\u003e oldValue,\r\n        ReadOnlySpan\u003cchar\u003e newValue,\r\n        out int bufferSize);\r\n\r\n    // Allocates a new buffer, fills it, and returns it\r\n    public static ReadOnlySpan\u003cchar\u003e Replace(\r\n        this ReadOnlySpan\u003cchar\u003e str,\r\n        char oldChar,\r\n        char newChar);\r\n\r\n    // Don\u0027t need to return buffer size since it\u0027s it same as input length\r\n    public static bool TryReplace(\r\n        this ReadOnlySpan\u003cchar\u003e str,\r\n        char oldChar,\r\n        char newChar\r\n        Span\u003cchar\u003e buffer);\r\n\r\n    // This will always succeed\r\n    public static void Replace(\r\n        this Span\u003cchar\u003e str,\r\n        char oldChar,\r\n        char newChar);\r\n}\r\n```\r\n\r\n- Removed the overload that maybe allocates or maybe fills - on second thought that seems both more confusing and less helpful than I initially thought it would be.\r\n- Added an overload that takes a `Span\u003cchar\u003e` as both the initial input and the buffer to fill (overwriting what was in it).\r\n- Added overloads for `char`\r\n\r\nOne other thought/question I had was about what to do when using an overload that fills a provided buffer when either the old value is the same as the new value or no replacements need to be performed. In the overloads where a new buffer is allocated we can just return the original input. In the overloads where we\u0027re filling a provided buffer, should the buffer still be filled by copying over the content from the original input verbatim or should we somehow indicate the original input contains the results and no replacement is needed (I.e., return `true` with a `bufferSize` of 0 or -1)? My first thought is that filling the buffer regardless is better for consistency, but then we miss out on a not-uncommon optimization (is copying to the buffer really that much of a performance impact?).",
                                           "updatedAt":  "2019-06-04T12:13:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ5ODY3MjA2MA==",
                                           "createdAt":  "2019-06-04T13:29:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODZ6X3A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pablocom",
                                                                               "createdAt":  "2022-03-30T08:52:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MineCake147E",
                                                                               "createdAt":  "2023-06-10T04:44:21Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CodingMadness",
                                                                               "createdAt":  "2023-10-03T23:11:25Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Bysza",
                                                                               "createdAt":  "2024-03-08T19:03:21Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "vcsjones",
                                           "body":  "I like the API idea and agree it\u0027s useful, I have some thoughts on the shape though.\r\n\r\nReturning spans from a method is generally not something I would use unless the span\u0027s creation is guaranteed not to allocate (like if you are returning a slice of a span parameter). \r\n\r\n\u003eI do feel like having “just works” versions are important. Not everyone is going to care about allocations or performance and will want to control those\r\n\r\nIn those circumstances I do not think using `Span\u003cT\u003e` is an appropriate choice and I would suggest using `string` again. I think if APIs are designed as such to make it seem that string is somehow obsolete, when that is very far from the truth, is problematic. A big-but-not-always use case for `Span\u003cT\u003e` is to be in control of allocations.\r\n\r\n---------\r\n\r\nSome of these API suggestions like `Replace(Span\u003cchar\u003e str, char oldChar, char newChar)` look like they could be useful if they were generalized over `IEquatable\u003cT\u003e`. Perhaps then the API could be:\r\n\r\n```csharp\r\npublic static void Replace(Span\u003cT\u003e span, T oldItem, T newItem) where T : IEquatable\u003cT\u003e\r\n```\r\n\r\nIt looks like all of them could actually be over `IEquatable\u003cT\u003e`, for example:\r\n\r\n```csharp\r\nSpan\u003cbyte\u003e a = stackalloc byte[] { 1, 2, 3, 4, 5 };\r\nReadOnlySpan\u003cbyte\u003e replacement = stackalloc byte[] { 0, 0, 0 };\r\nReadOnlySpan\u003cbyte\u003e replacee = stackalloc byte[] { 2, 3 };\r\nReadOnlySpan\u003cbyte\u003e buffer = stackalloc byte[256];\r\na.Replace(replacee, replacement, out var bufferSize);\r\n\r\n// buffer =\u003e { 1, 0, 0, 0, 4, 5, ... }\r\n```\r\n\r\nI don\u0027t know if that is an API that makes sense, but in at least one case it seems to make sense to me. If warranted specialized implementations for `char` could be done that uses SIMD later.",
                                           "updatedAt":  "2019-06-04T13:29:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ5ODc1Mjk2MA==",
                                           "createdAt":  "2019-06-04T16:48:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Gnbrkm41",
                                           "body":  "Great to see this idea catching on!\r\n\r\nRelated Issue: https://github.com/dotnet/corefx/issues/36460 (There were some additional discussions about span based overloads of replace)",
                                           "updatedAt":  "2019-06-04T16:48:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48mflk",
                                           "createdAt":  "2022-01-19T18:00:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "Discussions also in https://github.com/dotnet/runtime/issues/29111 and https://github.com/dotnet/runtime/issues/22434",
                                           "updatedAt":  "2022-01-19T18:00:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5eNyHC",
                                           "createdAt":  "2023-06-07T12:04:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODqFMDg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CodingMadness",
                                                                               "createdAt":  "2023-10-03T23:11:39Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "aradalvand",
                                                                               "createdAt":  "2023-10-11T03:55:21Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hughbe",
                                                                               "createdAt":  "2023-10-23T12:46:25Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "valkovsa",
                                                                               "createdAt":  "2023-11-20T15:25:32Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Towernter",
                                                                               "createdAt":  "2024-03-08T08:19:31Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "IanKemp",
                                                                               "createdAt":  "2024-07-16T15:50:58Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "brendangooden",
                                                                               "createdAt":  "2024-07-17T05:09:39Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  7
                                                         },
                                           "author":  "HunteRoi",
                                           "body":  "Any news on the topic?",
                                           "updatedAt":  "2023-06-07T12:04:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6E_q6a",
                                           "createdAt":  "2024-07-16T15:51:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "IanKemp",
                                           "body":  "Sad that we\u0027re up to .NET 9 almost and no movement on this...",
                                           "updatedAt":  "2024-07-16T15:51:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6I0JcS",
                                           "createdAt":  "2024-08-18T19:52:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Phylum123",
                                           "body":  "Isn\u0027t this what you are looking for?\r\n\r\nhttps://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.replace?view=net-8.0\r\n",
                                           "updatedAt":  "2024-08-18T19:52:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6I0PH1",
                                           "createdAt":  "2024-08-18T21:19:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wertzui",
                                           "body":  "`MemoryExtensions.Replace` takes arguments of type `T` and not `ReadonlySpan\u003cT\u003e`. ",
                                           "updatedAt":  "2024-08-18T21:19:38Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "ReadOnlySpan\u003cchar\u003e Replace extensions",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/13128",
        "createdAt":  "2019-07-23T06:29:28Z",
        "number":  13128,
        "author":  "davidfowl",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC96eRg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "julealgon",
                                            "createdAt":  "2025-01-06T19:31:06Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-01-06T19:34:50Z",
        "body":  "As an example https://github.com/dotnet/coreclr/blob/53b1a71d230851f32a2bf904ed030f2755bcf253/src/System.Private.CoreLib/shared/System/Span.Fast.cs#L76-L92. None of these specify the argument that is out of range (e.g. start).",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOmWjFig==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUxNDIwMzMwMw==",
                                           "createdAt":  "2019-07-23T13:11:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEBOX3w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "julealgon",
                                                                               "createdAt":  "2025-01-06T19:31:01Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "I believe at the time this was done explicitly to minimize code size, but I don\u0027t know the details of the measurements performed and whether the impact was meaningful or not.\r\n\r\ncc: @ahsonkhan, @GrabYourPitchforks ",
                                           "updatedAt":  "2019-07-23T14:32:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ZaMWK",
                                           "createdAt":  "2025-01-06T19:34:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "julealgon",
                                           "body":  "The fact that the methods have multiple values that can be out of range makes this seem more important to me for disambiguation purposes -\u003e debugging.\n\n\u003e I believe at the time this was done explicitly to minimize code size\n\n@stephentoub is there any other way this could be optimized? It seems bad to me to encourage not properly populating common exception fields like these because of those concerns.",
                                           "updatedAt":  "2025-01-06T19:34:39Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Specify the argument name when throwing arugment out of range exceptions in Span APIs",
        "labels":  [
                       "enhancement",
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/282",
        "createdAt":  "2019-11-26T12:02:31Z",
        "number":  282,
        "author":  "DaZombieKiller",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCztjQA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "reflectronic",
                                            "createdAt":  "2020-02-24T04:33:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ForkBug",
                                            "createdAt":  "2022-02-03T11:31:06Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lilinus",
                                            "createdAt":  "2022-11-07T09:00:31Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "austindrenski",
                                            "createdAt":  "2023-11-01T19:37:44Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2022-02-03T13:03:46Z",
        "body":  "Currently, there appears to be no writable equivalent to the `ReadOnlySequence\u003cT\u003e` APIs in the framework. This complicates matters when dealing with non-contiguous mutable buffers (such as in a custom memory allocator).\r\n\r\nBelow is the basic API surface I\u0027d expect to see (effectively the API surface of `ReadOnlySequence\u003cT\u003e`, but writable), although ideally this would be accompanied by a `SequenceWriter\u003cT\u003e` type (which I believe is out of scope for this proposal).\r\n```cs\r\npublic abstract class SequenceSegment\u003cT\u003e\r\n{\r\n    protected SequenceSegment();\r\n    public Memory\u003cT\u003e Memory { get; protected set; }\r\n    public SequenceSegment\u003cT\u003e Next { get; protected set; }\r\n    public long RunningIndex { get; protected set; }\r\n}\r\n\r\npublic readonly struct Sequence\u003cT\u003e\r\n{\r\n    public static readonly Sequence\u003cT\u003e Empty;\r\n    public Sequence(SequenceSegment\u003cT\u003e startSegment, int startIndex, SequenceSegment\u003cT\u003e endSegment, int endIndex);\r\n    public Sequence(Memory\u003cT\u003e memory);\r\n    public Sequence(T[] array);\r\n    public Sequence(T[] array, int start, int length);\r\n    public SequencePosition End { get; }\r\n    public Memory\u003cT\u003e First { get; }\r\n    public Span\u003cT\u003e FirstSpan { get; }\r\n    public bool IsEmpty { get; }\r\n    public bool IsSingleSegment { get; }\r\n    public long Length { get; }\r\n    public SequencePosition Start { get; }\r\n    public Enumerator GetEnumerator();\r\n    public SequencePosition GetPosition(long offset);\r\n    public SequencePosition GetPosition(long offset, SequencePosition origin);\r\n    public Sequence\u003cT\u003e Slice(int start, int length);\r\n    public Sequence\u003cT\u003e Slice(int start, SequencePosition end);\r\n    public Sequence\u003cT\u003e Slice(long start);\r\n    public Sequence\u003cT\u003e Slice(long start, long length);\r\n    public Sequence\u003cT\u003e Slice(long start, SequencePosition end);\r\n    public Sequence\u003cT\u003e Slice(SequencePosition start);\r\n    public Sequence\u003cT\u003e Slice(SequencePosition start, int length);\r\n    public Sequence\u003cT\u003e Slice(SequencePosition start, long length);\r\n    public Sequence\u003cT\u003e Slice(SequencePosition start, SequencePosition end);\r\n    public bool TryGet(ref SequencePosition position, out Memory\u003cT\u003e memory, bool advance = true);\r\n    public override string ToString();\r\n    \r\n    public struct Enumerator\r\n    {\r\n        public Enumerator(in Sequence\u003cT\u003e sequence);\r\n        public Memory\u003cT\u003e Current { get; }\r\n        public bool MoveNext();\r\n    }\r\n}\r\n```\r\n\r\nQuestions:\r\n\r\n- Is the current lack of a `Sequence\u003cT\u003e` type a conscious, deliberate decision? Or was it simply left out because it was never brought up/needed at the time the API was designed?\r\n- How would the addition of this type affect `System.IO.Pipelines`?\r\n- Should `SequenceSegment\u003cT\u003e` subclass `ReadOnlySequenceSegment\u003cT\u003e`?\r\n  - If not, should a conversion be provided? Although unlike subclassing, this would incur GC allocations.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOPVRQUA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4OTc1OTg3NQ==",
                                           "createdAt":  "2020-02-21T17:46:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "@ahsonkhan speaking:\r\n\r\nWhat is the scenario you are targeting with this API?\r\n\r\n\u003e - Is the current lack of a `Sequence\u003cT\u003e` type a conscious, deliberate decision? Or was it simply left out because it was never brought up/needed at the time the API was designed?\r\n\r\n@davidfowl - did we intentionally leave this out from the initial design when pipelines/sequence was being prototyped in corefxlab?",
                                           "updatedAt":  "2020-02-22T06:03:26Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4OTc2Mjk2NQ==",
                                           "createdAt":  "2020-02-21T17:54:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "DaZombieKiller",
                                           "body":  "\u003e What is the scenario you are targeting with this API?\r\n\r\nI was intending to use it for a scripting VM\u0027s memory heap (which can often be accessed non-contiguously), and figured it\u0027d be convenient to have `Sequence\u003cT\u003e` for passing it around.\r\n\r\nFor additional use cases, I\u0027d like to refer to the `Pipelines.Sockets.Unofficial` project, which offers an implementation of `Sequence\u003cT\u003e` for its arena allocation API: https://mgravell.github.io/Pipelines.Sockets.Unofficial/docs/arenas",
                                           "updatedAt":  "2020-02-22T08:42:04Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5MDAwNjM3NQ==",
                                           "createdAt":  "2020-02-22T22:56:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODLl-5g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AArnott",
                                                                               "createdAt":  "2020-02-22T23:17:56Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "DaZombieKiller",
                                                                               "createdAt":  "2020-02-23T05:06:40Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "reflectronic",
                                                                               "createdAt":  "2020-02-24T04:33:37Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "austindrenski",
                                                                               "createdAt":  "2023-11-01T19:38:11Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "\u003e @davidfowl - did we intentionally leave this out from the initial design with pipelines/sequence was being prototyped in corefxlab?\r\n\r\nIBufferWriter\\\u003cT\\\u003e is the thing you want, not Sequence\\\u003cT\\\u003e. You need a way to write data that you can also read as a ReadOnlySequence\\\u003cT\\\u003e. I was hoping ArrayBufferWriter could be this but its for contiguous memory.\r\n\r\nBut have no fear, @AArnott has your back https://github.com/AArnott/Nerdbank.Streams/blob/66186b4fa1daafcacb657ee09a9ea4c6a1194f98/doc/Sequence.md.\r\n\r\nThis should be added to the BCL.\r\n",
                                           "updatedAt":  "2020-02-22T22:56:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5MDAyODQ2MA==",
                                           "createdAt":  "2020-02-23T05:18:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "DaZombieKiller",
                                           "body":  "@davidfowl \r\n\u003e But have no fear, @AArnott has your back https://github.com/AArnott/Nerdbank.Streams/blob/66186b4fa1daafcacb657ee09a9ea4c6a1194f98/doc/Sequence.md.\r\n\r\nThat looks almost perfect for my purposes, although it lacks the ability to seek backwards in the sequence, which would be needed to enable writes to arbitrary positions.",
                                           "updatedAt":  "2020-02-23T05:18:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5MDEwOTk4MA==",
                                           "createdAt":  "2020-02-23T20:04:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AArnott",
                                           "body":  "@DaZombieKiller You want random write access rather than append-only?\r\nWould you need *insert* capabilities or simply overwrite of existing bytes?",
                                           "updatedAt":  "2020-02-23T20:05:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5MDExMDQwNQ==",
                                           "createdAt":  "2020-02-23T20:09:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "DaZombieKiller",
                                           "body":  "@AArnott I have no need for insertion, only the ability to write to an arbitrary position in the sequence, overwriting anything already present there.",
                                           "updatedAt":  "2020-02-23T20:09:25Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5MDExMDUxOA==",
                                           "createdAt":  "2020-02-23T20:10:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AArnott",
                                           "body":  "Well, that extends beyond anything `IBufferWriter\u003cbyte\u003e` would ever expose. What API are you imagining you\u0027d use while writing to arbitrary positions? Keep in mind the backing buffers are broken up into potentially many backing arrays, at somewhat arbitrary positions.",
                                           "updatedAt":  "2020-02-23T20:10:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5MDExMDU5Nw==",
                                           "createdAt":  "2020-02-23T20:11:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AArnott",
                                           "body":  "BTW, if your writing at arbitrary positions is limited to what I call \"length prefixing\", I have [a solution for that too](https://github.com/AArnott/Nerdbank.Streams/blob/master/doc/PrefixingBufferWriter.md).",
                                           "updatedAt":  "2020-02-23T20:11:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5MDExMTQwMQ==",
                                           "createdAt":  "2020-02-23T20:18:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "DaZombieKiller",
                                           "body":  "\u003e What API are you imagining you\u0027d use while writing to arbitrary positions?\r\n\r\nI was imagining a situation where I could retrieve a `Sequence\u003cT\u003e` starting at a requested position, and then enumerate its `Memory\u003cT\u003e`s. Something along these lines (forgive the likely bad example, I just woke up):\r\n```cs\r\nvoid WriteBytes(SequencePosition position, ReadOnlySpan\u003cbyte\u003e bytes)\r\n{\r\n    var slice = sequence.Slice(position);\r\n    slice.EnsureAvailable(bytes.Length);\r\n\r\n    foreach (Memory\u003cbyte\u003e memory in slice)\r\n    {\r\n        if (bytes.Length == 0)\r\n            break;\r\n\r\n        if (memory.Length \u003e= bytes.Length)\r\n        {\r\n            bytes.CopyTo(memory.Span);\r\n            break;\r\n        }\r\n\r\n        var span = bytes.Slice(0, memory.Length);\r\n        span.CopyTo(memory);\r\n        bytes = bytes.Slice(memory.Length);\r\n    }\r\n}\r\n```",
                                           "updatedAt":  "2020-02-23T20:18:53Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5MDExMTcyOA==",
                                           "createdAt":  "2020-02-23T20:22:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AArnott",
                                           "body":  "Ya, I think your example might need some tweaking to make sense. Or at least some code comments.\r\n\r\nWhat is the scenario for this? If you\u0027re just trying to recycle memory, `Sequence\u003cT\u003e` can already do that. ",
                                           "updatedAt":  "2020-02-23T20:22:18Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5MDExMjEyMA==",
                                           "createdAt":  "2020-02-23T20:26:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "DaZombieKiller",
                                           "body":  "My use case is a memory heap for a virtual machine, which I briefly mentioned earlier. The VM has instructions that can access random memory locations. Memory is allocated for \"out of bounds\" accesses. An alternative implementation I was considering was a sparse array, but I was hoping I could leverage `ReadOnlySequence\u003cT\u003e` and a writable equivalent.",
                                           "updatedAt":  "2020-02-23T20:26:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5MDExNjMyMQ==",
                                           "createdAt":  "2020-02-23T21:08:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "Seems achievable with a Seek functionality but it’s for the writer not the reader. So the Sequence\\\u003cT\\\u003e would have a Seek to move the current writing head. That seems fine to me",
                                           "updatedAt":  "2020-02-23T21:08:21Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5MDQxMzQ5OQ==",
                                           "createdAt":  "2020-02-24T16:20:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AArnott",
                                           "body":  "@DaZombieKiller Are you expecting `Sequence\u003cT\u003e` to support sparse buffers behind the scenes then, where your sequence is allegedly very long but only allocates buffers to back non-zero writes?",
                                           "updatedAt":  "2020-02-24T16:20:20Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5MDQ0NDY3NQ==",
                                           "createdAt":  "2020-02-24T17:14:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "DaZombieKiller",
                                           "body":  "@AArnott That would be an ideal scenario, yes.",
                                           "updatedAt":  "2020-02-24T17:14:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5MDQ4MjE1NA==",
                                           "createdAt":  "2020-02-24T18:34:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AArnott",
                                           "body":  "IMO that\u0027s a far cry different from what `IBufferWriter\u003cT\u003e` and `ReadOnlySequence\u003cT\u003e` were ever intended to address. I wonder why this would be better than sparse arrays by themselves.\r\n\r\n`ReadOnlySequence\u003cT\u003e` as a struct doesn\u0027t have support for sparse arrays, so to represent huge amounts of \u0027empty space\u0027 you\u0027d have to actually allocate huge arrays, or repeatedly use smaller arrays, where each repeat still allocates a tracking object.",
                                           "updatedAt":  "2020-02-24T18:34:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5MDU3ODEyOA==",
                                           "createdAt":  "2020-02-24T22:19:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOA8Z47w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AArnott",
                                                                               "createdAt":  "2020-02-24T22:49:32Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "DaZombieKiller",
                                           "body":  "If sparse arrays are out of scope for `IBufferWriter\u003cT\u003e` and `(ReadOnly)Sequence\u003cT\u003e` then that\u0027s fine, I\u0027ll likely just end up using sparse arrays directly in that case. I appreciate you taking the time to address this.\r\n\r\nI\u0027ll leave this issue open so that it can track a potential BCL implementation of `Sequence\u003cT\u003e` in the future, assuming there are plans to do something of the sort.",
                                           "updatedAt":  "2020-02-24T22:19:34Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3ODc0MjIzMg==",
                                           "createdAt":  "2021-02-14T07:54:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sharwell",
                                           "body":  "While a segment of `T[]` can be represented by `Span\u003cT\u003e`, a segment of [`SegmentedArray\u003cT\u003e`](https://github.com/dotnet/roslyn/blob/master/src/Dependencies/Collections/SegmentedArray%601.cs) can be represented by `Sequence\u003cT\u003e`. This abstraction would simplify the process of modifying [`ArraySortHelper`](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/ArraySortHelper.cs) to operate on segmented arrays.",
                                           "updatedAt":  "2021-02-14T07:54:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49VFBQ",
                                           "createdAt":  "2022-02-03T12:21:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ForkBug",
                                           "body":  "\u003e @ahsonkhan speaking:\r\n\u003e \r\n\u003e What is the scenario you are targeting with this API?\r\n\u003e \r\n\r\nWe encounter a scenario which needs `SequenceSegment\u003cT\u003e`:\r\n1.\tIt’s a network application.\r\n2.\tThe network stack has been split into multiple layers.\r\n3.\tThe upmost layer may send millions of packets in one session. \r\n4.\tSome layers may add another header to the one packet, whiles others layers may do transforming to the packet (like encryption).\r\n5.\tTherefore, the encryption or socket layer may receive something like `IList\u003cArraysegment\u003e`\r\n6. The layers number won’t be changed, at least in one release. \r\n7. There is no new/allocation on every packet. IList and Arraysegment would be reused.\r\n \r\nPipeline is too complicated for sending, and may impact the performance.  \r\n\r\nActually, `SequenceSegment\u003cT\u003e` is just a replacement of `IList\u003cArraysegment\u003e`. The reason of  why `SequenceSegment\u003cT\u003e` is required, is the same as `IList\u003cArraysegment\u003e` on socket.\r\n\r\n\r\n\r\n",
                                           "updatedAt":  "2022-02-03T13:03:46Z"
                                       }
                                   ],
                         "totalCount":  18
                     },
        "title":  "Proposal: writable equivalents of ReadOnlySequence\u003cT\u003e APIs",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/518",
        "createdAt":  "2019-12-04T19:17:06Z",
        "number":  518,
        "author":  "zlatanov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODAW2hQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "msschl",
                                            "createdAt":  "2024-05-07T09:53:56Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "msschl",
                                            "createdAt":  "2024-05-07T09:53:58Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "msschl",
                                            "createdAt":  "2024-05-07T09:54:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AArnott",
                                            "createdAt":  "2024-11-11T20:40:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "khellang",
                                            "createdAt":  "2025-03-21T12:18:01Z"
                                        }
                                    ],
                          "totalCount":  5
                      },
        "updatedAt":  "2024-11-12T03:38:28Z",
        "body":  "I think it\u0027s rather unfortunate that ReadOnlySequences cannot be easily checked for value equality. The framework has such extension methods for Spans and ReadOnlySpans - **SequenceEqual** and the type that has Sequence in its name doesn\u0027t.\r\n\r\nImplementing it efficiently is tricky because one needs to consider that segments may not be of the same size and even there can be empty segments that need to be ignored.\r\n\r\nProposed API\r\n---\r\n``` csharp\r\nclass MemoryExtensions\r\n{\r\n    static bool SequenceEqual\u003cT\u003e(this in ReadOnlySequence\u003cT\u003e x, in ReadOnlySequence\u003cT\u003e y);\r\n    static bool SequenceEqual\u003cT\u003e(this in ReadOnlySequence\u003cT\u003e x, in ReadOnlySpan\u003cT\u003e y);\r\n}\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOkypcaA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2MTgyMjMxNQ==",
                                           "createdAt":  "2019-12-04T20:20:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "scalablecory",
                                           "body":  "This seems reasonable to me, though I worry it may provide additional encouragement for people to directly use `ReadOnlySequence`.",
                                           "updatedAt":  "2019-12-04T20:20:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2MTgyNDYzMA==",
                                           "createdAt":  "2019-12-04T20:27:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "The API seems reasonable enough, but I don\u0027t understand the scenario for it. `ReadOnlySequence\u003cT\u003e` is generally used to represent a potentially large amount of data, and I can\u0027t think of many scenarios offhand where somebody would want to compare two potentially-large buffers for equality.",
                                           "updatedAt":  "2019-12-04T20:27:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2MTg1NTAzMw==",
                                           "createdAt":  "2019-12-04T21:50:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "zlatanov",
                                           "body":  "@GrabYourPitchforks My use case is not actually about large buffers but comes directly from the usage of SequenceReader\u003cT\u003e.\r\n\r\nLet\u0027s say you have an input that is abstracted from you using Pipelines (i.e. PipeReader). The reader part is exposed through SequenceReader\u003cT\u003e over a ReadOnlySequence\u003cT\u003e.\r\n\r\nMy use case is using AMQP 1.0 protocol and certain types in it which are `cache-able` by design, but I\u0027ve done similar things for JSON payloads as well, where I need to compare property names without really needing to decode them as string.\r\n\r\nThe problem with the above example is when what you\u0027re trying to read occupies more than one segment. In the past when I\u0027ve encountered such cases I usually rent memory, do copy, then release when done.\r\n\r\nAs a side note to this - almost every time I\u0027ve needed to compare sequence of bytes, I\u0027ve also needed a good hashing function for memory. I don\u0027t think anything like this exists as of now, am I right?",
                                           "updatedAt":  "2019-12-04T21:50:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2MTg2MzQ0Mw==",
                                           "createdAt":  "2019-12-04T22:13:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOA2kLag==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "zlatanov",
                                                                               "createdAt":  "2019-12-04T23:06:03Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "GrabYourPitchforks",
                                                                               "createdAt":  "2019-12-05T06:48:27Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "scalablecory",
                                           "body":  "\u003e ... I\u0027ve done similar things for JSON payloads as well, where I need to compare property names without really needing to decode them as string ... The problem with the above example is when what you\u0027re trying to read occupies more than one segment. In the past when I\u0027ve encountered such cases I usually rent memory, do copy, then release when done.\r\n\r\nI\u0027d generally recommend against operating directly on a ROS like this when you\u0027ve got small tokens. It is typically very rare for a small token to cross a boundary and not worth it to complicate things to handle that with zero-copy -- it\u0027s really easy to actually write worse-performing code when doing so. For small tokens like JSON properties, I like to use an efficient helper method like so:\r\n\r\n```c#\r\n// return underlying Memory if possible. if the length crosses segments, copy to tempStorage and return that.\r\nReadOnlySpan\u003cbyte\u003e ReadBytes(ref SequenceReader reader, int length, Span\u003cbyte\u003e tempStorage);\r\n```\r\n\r\nAnd use it as:\r\n\r\n```c#\r\nSequenceReader reader = ...;\r\nSpan\u003cbyte\u003e tempStorage = stackalloc byte[256];\r\n\r\nReadOnlySpan\u003cbyte\u003e token = ReadBytes(ref reader, 10, tempStorage);\r\n```",
                                           "updatedAt":  "2019-12-04T22:13:47Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2MTk5ODUzOQ==",
                                           "createdAt":  "2019-12-05T06:57:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "\u003e As a side note to this - almost every time I\u0027ve needed to compare sequence of bytes, I\u0027ve also needed a good hashing function for memory. I don\u0027t think anything like this exists as of now, am I right?\r\n\r\nThere\u0027s the APIs in the _System.Security.Cryptography_ namespace, but otherwise the framework doesn\u0027t provide a general-purpose hashing function over raw binary buffers. I don\u0027t think the framework would be able to choose a suitable default for collision resistance or digest size, and there would be concerns over whether the algorithm would need to be stable across framework versions. Contrast this to `string.GetHashCode`, which we say is good enough to be able to store `string` instances as keys within a `Dictionary\u003cstring, ...\u003e`, but we make no hard guarantees as to the strength of the algorithm used under the covers, and we\u0027re free to change the algorithm between framework versions. (In the case of `string.GetHashCode`, the algorithm changes every time the process is torn down and restarted.)",
                                           "updatedAt":  "2019-12-05T06:57:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5CQqZr",
                                           "createdAt":  "2022-04-28T02:13:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "StephenCleary",
                                           "body":  "\u003e the framework doesn\u0027t provide a general-purpose hashing function over raw binary buffers.\r\n\r\nSince this was written, [hashing arbitrary binary buffers has been added in .NET 6 (`HashCode`)](https://docs.microsoft.com/en-us/dotnet/api/system.hashcode.addbytes?view=net-6.0). This is a \"GetHashCode strength\" kind of hash code, and not a strong (identity preserving) hash. For strong hashes, [`IncrementalHash` is still the way to go](https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.incrementalhash.appenddata?view=net-6.0#system-security-cryptography-incrementalhash-appenddata(system-readonlyspan((system-byte))))",
                                           "updatedAt":  "2022-04-28T02:13:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6TKeb6",
                                           "createdAt":  "2024-11-11T20:48:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AArnott",
                                           "body":  "For my case, it\u0027s simply by-value equality testing, which can be useful in testing (e.g. to ensure serialization was correct).",
                                           "updatedAt":  "2024-11-11T20:48:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6TKlxo",
                                           "createdAt":  "2024-11-11T21:11:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AArnott",
                                           "body":  "FWIW, here is what I whipped up for my own purposes:\n\nhttps://github.com/dotnet/Nerdbank.Streams/blob/97996a453c3a5efaecf824a9d16e4d3259188308/src/Nerdbank.Streams/ReadOnlySequenceExtensions.cs#L31-L105",
                                           "updatedAt":  "2024-11-12T03:38:28Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "API proposal: SequenceEqual implementations for ReadOnlySequence\u003cT\u003e",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/2010",
        "createdAt":  "2020-01-22T13:57:22Z",
        "number":  2010,
        "author":  "Pheubel",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-01-13T19:36:11Z",
        "body":  "Parsing tokens from a string with string.split and a dictionary\u003cthings\u003e causes allocations.\r\nThese allocations can be avoided by handling the token string as a span and splitting the tokens and using them for dictionary look-ups.\r\n\r\n## Proposed API\r\nA dictionary based on `Dictionary\u003cTKey,TValue\u003e` but with additional functions for first class ReadOnlySpan\u003cTKey\u003e support.\r\n```cs\r\n[DebuggerDisplay(\"Count = {Count}\")]\r\npublic class MemoryDictionary\u003cTKey, TValue\u003e : IDictionary\u003cReadOnlyMemory\u003cTKey\u003e, TValue\u003e, IDictionary, IReadOnlyDictionary\u003cReadOnlyMemory\u003cTKey\u003e, TValue\u003e\r\n    where TKey : notnull, IEquatable\u003cTKey\u003e\r\n{\r\n    private int[] _buckets;\r\n    private Entry[] _entries;\r\n    private int _count;\r\n    private int _freeList;\r\n    private int _freeCount;\r\n    private int _version;\r\n    private IMemoryEqualityComparer\u003cTKey\u003e _comparer;\r\n    private KeyCollection _keys;\r\n    private ValueCollection _values;\r\n    private const int StartOfFreeList = -3;\r\n\r\n    public MemoryDictionary();\r\n    public MemoryDictionary(int capacity);\r\n    public MemoryDictionary(IMemoryEqualityComparer\u003cTKey\u003e comparer);\r\n    public MemoryDictionary(int capacity, IMemoryEqualityComparer\u003cTKey\u003e comparer);\r\n    public MemoryDictionary(IDictionary\u003cReadOnlyMemory\u003cTKey\u003e, TValue\u003e dictionary);\r\n    public MemoryDictionary(IDictionary\u003cReadOnlyMemory\u003cTKey\u003e, TValue\u003e dictionary, IMemoryEqualityComparer\u003cTKey\u003e comparer);\r\n    public MemoryDictionary(IEnumerable\u003cKeyValuePair\u003cReadOnlyMemory\u003cTKey\u003e, TValue\u003e\u003e collection);\r\n    public MemoryDictionary(IEnumerable\u003cKeyValuePair\u003cReadOnlyMemory\u003cTKey\u003e, TValue\u003e\u003e collection, IMemoryEqualityComparer\u003cTKey\u003e comparer);\r\n\r\n    public int Count { get; }\r\n    public KeyCollection Keys { get; }\r\n    public ValueCollection Values { get; }\r\n    public IMemoryEqualityComparer\u003cTKey\u003e Comparer { get; }\r\n\r\n    public TValue this[ReadOnlyMemory\u003cTKey\u003e key] { get; set; }\r\n\r\n    public TValue Get(ReadOnlyMemory\u003cTKey\u003e key);\r\n    public TValue GetWithSpan(ReadOnlySpan\u003cTKey\u003e key);\r\n    public bool TryGetValue(ReadOnlyMemory\u003cTKey\u003e key, out TValue value);\r\n    public bool TryGetValueWithSpan(ReadOnlySpan\u003cTKey\u003e key, [MaybeNullWhen(false)] out TValue value);\r\n\r\n    public Enumerator GetEnumerator();\r\n\r\n    public void Add(ReadOnlyMemory\u003cTKey\u003e key, TValue value);\r\n    public bool TryAdd(ReadOnlyMemory\u003cTKey\u003e key, TValue value);\r\n\r\n    public bool Remove(ReadOnlyMemory\u003cTKey\u003e key);\r\n    public bool Remove(ReadOnlyMemory\u003cTKey\u003e key, out TValue value) =\u003e RemoveWithSpan(key.Span, out value);\r\n    public bool RemoveWithSpan(ReadOnlySpan\u003cTKey\u003e key);\r\n    public bool RemoveWithSpan(ReadOnlySpan\u003cTKey\u003e key, [MaybeNullWhen(false)] out TValue value);\r\n\r\n    public void Clear();\r\n\r\n    public bool ContainsKey(ReadOnlyMemory\u003cTKey\u003e key);\r\n    public bool ContainsValue(TValue value);\r\n\r\n    private int FindEntry(ReadOnlyMemory\u003cTKey\u003e key);\r\n    private int FindEntry(ReadOnlySpan\u003cTKey\u003e key);\r\n\r\n    private bool TryInsert(ReadOnlyMemory\u003cTKey\u003e key, TValue value, InsertionBehavior behavior);\r\n\r\n    private void CopyTo(KeyValuePair\u003cReadOnlyMemory\u003cTKey\u003e, TValue\u003e[] array, int index);\r\n    private int Initialize(int capacity);\r\n\r\n    public int EnsureCapacity(int capacity);\r\n    private void Resize();\r\n    private void Resize(int newSize, bool forceNewHashCodes);\r\n    public void TrimExcess();\r\n    public void TrimExcess(int capacity);\r\n            \r\n    private static bool IsCompatibleKey(object key);\r\n\r\n    ICollection\u003cReadOnlyMemory\u003cTKey\u003e\u003e IDictionary\u003cReadOnlyMemory\u003cTKey\u003e, TValue\u003e.Keys { get; }\r\n    IEnumerable\u003cReadOnlyMemory\u003cTKey\u003e\u003e IReadOnlyDictionary\u003cReadOnlyMemory\u003cTKey\u003e, TValue\u003e.Keys { get; }\r\n    ICollection IDictionary.Keys { get; }\r\n\r\n    ICollection\u003cTValue\u003e IDictionary\u003cReadOnlyMemory\u003cTKey\u003e, TValue\u003e.Values { get; }\r\n    IEnumerable\u003cTValue\u003e IReadOnlyDictionary\u003cReadOnlyMemory\u003cTKey\u003e, TValue\u003e.Values { get; }\r\n    ICollection IDictionary.Values { get; }\r\n\r\n    object IDictionary.this[object key] { get; set; }\r\n\r\n    IEnumerator IEnumerable.GetEnumerator();\r\n    IDictionaryEnumerator IDictionary.GetEnumerator();\r\n\r\n    void ICollection\u003cKeyValuePair\u003cReadOnlyMemory\u003cTKey\u003e, TValue\u003e\u003e.Add(KeyValuePair\u003cReadOnlyMemory\u003cTKey\u003e, TValue\u003e keyValuePair);\r\n    void IDictionary.Add(object key, object value);\r\n    bool ICollection\u003cKeyValuePair\u003cReadOnlyMemory\u003cTKey\u003e, TValue\u003e\u003e.Contains(KeyValuePair\u003cReadOnlyMemory\u003cTKey\u003e, TValue\u003e keyValuePair);\r\n    bool IDictionary.Contains(object key);\r\n    bool ICollection\u003cKeyValuePair\u003cReadOnlyMemory\u003cTKey\u003e, TValue\u003e\u003e.Remove(KeyValuePair\u003cReadOnlyMemory\u003cTKey\u003e, TValue\u003e keyValuePair);\r\n    void IDictionary.Remove(object key);\r\n\r\n    IEnumerator\u003cKeyValuePair\u003cReadOnlyMemory\u003cTKey\u003e, TValue\u003e\u003e IEnumerable\u003cKeyValuePair\u003cReadOnlyMemory\u003cTKey\u003e, TValue\u003e\u003e.GetEnumerator();\r\n\r\n    bool ICollection\u003cKeyValuePair\u003cReadOnlyMemory\u003cTKey\u003e, TValue\u003e\u003e.IsReadOnly { get; }\r\n    bool IDictionary.IsReadOnly { get; }\r\n\r\n    bool IDictionary.IsFixedSize { get; }\r\n\r\n    void ICollection.CopyTo(Array array, int index);\r\n    void ICollection\u003cKeyValuePair\u003cReadOnlyMemory\u003cTKey\u003e, TValue\u003e\u003e.CopyTo(KeyValuePair\u003cReadOnlyMemory\u003cTKey\u003e, TValue\u003e[] array, int index);\r\n    \r\n    bool ICollection.IsSynchronized { get; }\r\n    object ICollection.SyncRoot { get; }\r\n    \r\n    private enum InsertionBehavior : byte\r\n    {\r\n        None = 0,\r\n        OverwriteExisting = 1,\r\n        ThrowOnExisting = 2\r\n    }\r\n\r\n    private struct Entry\r\n    {\r\n        public int next;\r\n        public uint hashCode;\r\n        public ReadOnlyMemory\u003cTKey\u003e key;\r\n        public TValue value;\r\n    }\r\n\r\n    public struct Enumerator : IEnumerator\u003cKeyValuePair\u003cReadOnlyMemory\u003cTKey\u003e, TValue\u003e\u003e,\r\n        IDictionaryEnumerator\r\n    {\r\n        private readonly MemoryDictionary\u003cTKey, TValue\u003e _dictionary;\r\n        private readonly int _version;\r\n        private int _index;\r\n        private KeyValuePair\u003cReadOnlyMemory\u003cTKey\u003e, TValue\u003e _current;\r\n        private readonly int _getEnumeratorRetType;  // What should Enumerator.Current return\r\n\r\n        internal const int DictEntry = 1;\r\n        internal const int KeyValuePair = 2;\r\n\r\n        internal Enumerator(MemoryDictionary\u003cTKey, TValue\u003e dictionary, int getEnumeratorRetType);\r\n\r\n        public bool MoveNext();\r\n\r\n        public KeyValuePair\u003cReadOnlyMemory\u003cTKey\u003e, TValue\u003e Current { get; }\r\n\r\n        public void Dispose();\r\n\r\n        object IEnumerator.Current { get; }\r\n\r\n        void IEnumerator.Reset();\r\n\r\n        DictionaryEntry IDictionaryEnumerator.Entry { get; }\r\n\r\n        object IDictionaryEnumerator.Key { get; }\r\n\r\n        object IDictionaryEnumerator.Value { get; }\r\n    }\r\n\r\n    [DebuggerDisplay(\"Count = {Count}\")]\r\n    public sealed class KeyCollection : ICollection\u003cReadOnlyMemory\u003cTKey\u003e\u003e, ICollection, IReadOnlyCollection\u003cReadOnlyMemory\u003cTKey\u003e\u003e\r\n    {\r\n        private MemoryDictionary\u003cTKey, TValue\u003e _dictionary;\r\n\r\n        public KeyCollection(MemoryDictionary\u003cTKey, TValue\u003e dictionary);\r\n\r\n        public Enumerator GetEnumerator();\r\n\r\n        public void CopyTo(ReadOnlyMemory\u003cTKey\u003e[] array, int index);\r\n\r\n        public int Count { get; }\r\n\r\n        bool ICollection\u003cReadOnlyMemory\u003cTKey\u003e\u003e.IsReadOnly { get; }\r\n\r\n        void ICollection\u003cReadOnlyMemory\u003cTKey\u003e\u003e.Add(ReadOnlyMemory\u003cTKey\u003e item);\r\n\r\n        void ICollection\u003cReadOnlyMemory\u003cTKey\u003e\u003e.Clear();\r\n\r\n        bool ICollection\u003cReadOnlyMemory\u003cTKey\u003e\u003e.Contains(ReadOnlyMemory\u003cTKey\u003e item);\r\n\r\n        bool ICollection\u003cReadOnlyMemory\u003cTKey\u003e\u003e.Remove(ReadOnlyMemory\u003cTKey\u003e item);\r\n\r\n        IEnumerator\u003cReadOnlyMemory\u003cTKey\u003e\u003e IEnumerable\u003cReadOnlyMemory\u003cTKey\u003e\u003e.GetEnumerator();\r\n\r\n        IEnumerator IEnumerable.GetEnumerator();\r\n\r\n        void ICollection.CopyTo(Array array, int index);\r\n\r\n        bool ICollection.IsSynchronized { get; }\r\n\r\n        object ICollection.SyncRoot { get; }\r\n\r\n        public struct Enumerator : IEnumerator\u003cReadOnlyMemory\u003cTKey\u003e\u003e, IEnumerator\r\n        {\r\n            private readonly MemoryDictionary\u003cTKey, TValue\u003e _dictionary;\r\n            private int _index;\r\n            private readonly int _version;\r\n            private ReadOnlyMemory\u003cTKey\u003e _currentKey;\r\n\r\n            internal Enumerator(MemoryDictionary\u003cTKey, TValue\u003e dictionary);\r\n\r\n            public void Dispose();\r\n\r\n            public bool MoveNext();\r\n\r\n            public ReadOnlyMemory\u003cTKey\u003e Current { get; }\r\n\r\n            object IEnumerator.Current { get; }\r\n\r\n            void IEnumerator.Reset();\r\n        }\r\n    }\r\n\r\n    [DebuggerDisplay(\"Count = {Count}\")]\r\n    public sealed class ValueCollection : ICollection\u003cTValue\u003e, ICollection, IReadOnlyCollection\u003cTValue\u003e\r\n    {\r\n        private MemoryDictionary\u003cTKey, TValue\u003e _dictionary;\r\n\r\n        public ValueCollection(MemoryDictionary\u003cTKey, TValue\u003e dictionary);\r\n\r\n        public Enumerator GetEnumerator();\r\n\r\n        public void CopyTo(TValue[] array, int index);\r\n\r\n        public int Count { get; }\r\n\r\n        bool ICollection\u003cTValue\u003e.IsReadOnly { get; }\r\n\r\n        void ICollection\u003cTValue\u003e.Add(TValue item);\r\n\r\n        bool ICollection\u003cTValue\u003e.Remove(TValue item);\r\n\r\n        void ICollection\u003cTValue\u003e.Clear();\r\n\r\n        bool ICollection\u003cTValue\u003e.Contains(TValue item);\r\n\r\n        IEnumerator\u003cTValue\u003e IEnumerable\u003cTValue\u003e.GetEnumerator();\r\n\r\n        IEnumerator IEnumerable.GetEnumerator();\r\n\r\n        void ICollection.CopyTo(Array array, int index);\r\n\r\n        bool ICollection.IsSynchronized { get; }\r\n\r\n        object ICollection.SyncRoot { get; }\r\n\r\n        public struct Enumerator : IEnumerator\u003cTValue\u003e, IEnumerator\r\n        {\r\n            private readonly MemoryDictionary\u003cTKey, TValue\u003e _dictionary;\r\n            private int _index;\r\n            private readonly int _version;\r\n            private TValue _currentValue;\r\n\r\n            internal Enumerator(MemoryDictionary\u003cTKey, TValue\u003e dictionary);\r\n\r\n            public void Dispose();\r\n\r\n            public bool MoveNext();\r\n\r\n            public TValue Current { get; }\r\n\r\n            object IEnumerator.Current { get; }\r\n\r\n            void IEnumerator.Reset();\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\nFor equality comparing keys with spans the normal IEqualityComparer\u003cT\u003e has to be extended\r\n```cs\r\npublic interface IMemoryEqualityComparer\u003cT\u003e : IEqualityComparer\u003cReadOnlyMemory\u003cT\u003e\u003e\r\n{\r\n    bool Equals(ReadOnlyMemory\u003cT\u003e x, ReadOnlySpan\u003cT\u003e y);\r\n    int GetHashCode(ReadOnlySpan\u003cT\u003e span);\r\n}\r\n```\r\n\r\nThe default MemoryEqualityComparer\u003cT\u003e would look like this\r\n```cs\r\npublic class MemoryEqualityComparer\u003cT\u003e : IMemoryEqualityComparer\u003cT\u003e\r\n    where T : IEquatable\u003cT\u003e\r\n{\r\n    public static MemoryEqualityComparer\u003cT\u003e Default { get; }\r\n\r\n    private MemoryEqualityComparer();\r\n\r\n    public bool Equals(ReadOnlyMemory\u003cT\u003e x, ReadOnlyMemory\u003cT\u003e y);\r\n    public bool Equals(ReadOnlyMemory\u003cT\u003e x, ReadOnlySpan\u003cT\u003e y);\r\n\r\n    public int GetHashCode(ReadOnlyMemory\u003cT\u003e memory);\r\n    public int GetHashCode(ReadOnlySpan\u003cT\u003e span);\r\n}\r\n```\r\n\r\n## example of usage:\r\n```cs\r\n[Flags]\r\npublic enum ScopeField\r\n{\r\n    Identity = 1 \u003c\u003c 0,\r\n    IdentityEmail = Identity | (1 \u003c\u003c 1),\r\n    IdentityMemberships = Identity | (1 \u003c\u003c 2)\r\n}\r\n\r\nprivate readonly static Dictionary\u003cReadOnlyMemory\u003cchar\u003e, ScopeField\u003e _mapping = new Dictionary\u003cReadOnlyMemory\u003cchar\u003e, ScopeField\u003e()\r\n{\r\n    [\"identity\".AsMemory()] = ScopeField.Identity,\r\n    [\"identity[email]\".AsMemory()] = ScopeField.IdentityEmail,\r\n    [\"identity.memberships\".AsMemory()] = ScopeField.IdentityMemberships\r\n};\r\n\r\npublic static ScopeField ParseScopeStringWithSpan(string scopeString)\r\n{\r\n    ScopeField scopeValue = 0;\r\n    var scopeSpan = scopeString.AsSpan();\r\n\r\n    while (scopeSpan.Length != 0)\r\n    {\r\n        int sliceIndex = scopeSpan.IndexOf(\u0027 \u0027);\r\n        if (sliceIndex != -1)\r\n        {\r\n            if (sliceIndex == 0)\r\n            { \r\n                scopeSpan = scopeSpan.Slice(1);\r\n                continue;\r\n            }\r\n\r\n            scopeValue |= _mapping.GetWithSpan(scopeSpan.Slice(0, sliceIndex));\r\n            scopeSpan = scopeSpan.Slice(sliceIndex + 1);\r\n        }\r\n        else\r\n        {\r\n            scopeValue |= _mapping.GetWithSpan(scopeSpan);\r\n            break;\r\n        }\r\n    }\r\n\r\n    return scopeValue;\r\n}\r\n```\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOmkIrkw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NzgxMjI3MQ==",
                                           "createdAt":  "2020-01-23T18:29:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "scalablecory",
                                           "body":  "Related: https://github.com/dotnet/corefx/issues/31942",
                                           "updatedAt":  "2020-01-23T18:29:54Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4OTc1ODQwMw==",
                                           "createdAt":  "2020-02-21T17:42:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "This API design needs to be thought through (including figuring out the lifetime of the `Memory\u003cT\u003e` once it is in the dictionary). Maybe we can start a prototype in corefxlab: https://github.com/dotnet/corefxlab",
                                           "updatedAt":  "2020-02-21T17:42:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6aQiuT",
                                           "createdAt":  "2025-01-13T19:35:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jilles-sg",
                                           "body":  "The existing https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2.getalternatelookup?view=net-9.0 and string comparers can be used to look up in a `Dictionary\u003cstring, TValue\u003e` by a `ReadOnlySpan\u003cchar\u003e` key. These features were introduced in .NET 9 for #27229.\n\nBy creating a custom comparer that implements `IEqualityComparer\u003cReadOnlyMemory\u003cT\u003e\u003e` and `IAlternateEqualityComparer\u003cReadOnlySpan\u003cT\u003e,ReadOnlyMemory\u003cT\u003e\u003e`, the exact request of this issue can be implemented. Since the lifetime of the `ReadOnlyMemory\u003cT\u003e` is problematic, this may not be appropriate for the BCL.",
                                           "updatedAt":  "2025-01-13T19:35:59Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "[Suggestion]Specialized Dictionary\u003cReadOnlyMemory\u003cTKey\u003e,TValue\u003e with first class ReadOnlySpan\u003cTKey\u003e support",
        "labels":  [
                       "api-needs-work",
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/2167",
        "createdAt":  "2020-01-24T21:24:09Z",
        "number":  2167,
        "author":  "GrabYourPitchforks",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC5b8iQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "antonfirsov",
                                            "createdAt":  "2020-01-25T00:17:06Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sakno",
                                            "createdAt":  "2022-06-14T22:56:58Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Thealexbarney",
                                            "createdAt":  "2023-06-19T16:16:03Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MineCake147E",
                                            "createdAt":  "2023-08-21T06:48:17Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hamarb123",
                                            "createdAt":  "2024-06-27T02:25:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "En3Tho",
                                            "createdAt":  "2024-07-17T11:21:40Z"
                                        }
                                    ],
                          "totalCount":  6
                      },
        "updatedAt":  "2023-07-06T14:46:01Z",
        "body":  "Forked from a conversation at https://github.com/dotnet/corefx/issues/26465.\r\n\r\nAPI proposal:\r\n\r\n```cs\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public static class Unsafe\r\n    {\r\n        public static int AlignOf\u003cT\u003e();\r\n    }\r\n}\r\n```\r\n\r\nThe behavior of this API would be that it returns the natural alignment (in bytes) of the data type `T`. This is most useful for components which need to *reinterpret_cast* between two different types `T` and `U` and wish to check ahead of time whether alignment problems might result. See further discussion of this scenario at https://github.com/dotnet/corefx/issues/26465.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYMlotQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3ODM0NzYwOA==",
                                           "createdAt":  "2020-01-24T23:57:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "Would this be the heap alignment or stack alignment of the type (as these sometimes differ)?\r\n\r\nWhat would the consideration be when the native alignment of a type and the heap alignment differ (e.g. `Vector128\u003cT\u003e` is 16-byte aligned on the stack and in native, but is 8-byte aligned for the heap)?",
                                           "updatedAt":  "2020-01-24T23:57:50Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3ODM1NzAwNg==",
                                           "createdAt":  "2020-01-25T00:50:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "I would assume heap-alignment, since that\u0027s the worst-case scenario where a VM or compiler might naturally put a field of type `T` insider of a larger object. That\u0027s assuming I\u0027m understanding the scenario correctly.",
                                           "updatedAt":  "2020-01-25T00:50:55Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3ODM1OTc4Nw==",
                                           "createdAt":  "2020-01-25T01:08:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "`System.Runtime.CompilerServices.Unsafe` is runtime agnostic today. This API cannot be implemented in runtime agnostic way. Adding it to `System.Runtime.CompilerServices.Unsafe` would mean killing it as runtime agnostic package. Should be rather be somewhere else?\r\n\r\n\u003e understanding the scenario correctly.\r\n\r\nYup, there is a lot of different values that this method can return depending on what it is meant to be  used for...",
                                           "updatedAt":  "2020-01-25T01:08:47Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3ODM2MTMyNw==",
                                           "createdAt":  "2020-01-25T01:19:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "In ECMA-335, Sec. I.12.6.2, the below clause appears.\r\n\r\n\u003e Otherwise, if the data is not properly aligned, and no `unaligned.` prefix has been specified, executing the instruction can generate unaligned memory faults or incorrect data.\r\n\r\nIf we wanted to use this sentence as a guide, then the return value of `AlignOf\u003cT\u003e()` might be defined as \"the address alignment value at which accessing a pointer of type `T*` will not generate unaligned memory faults or incorrect data on the current architecture, even if the instruction has not been decorated with an `unaligned.` prefix.\"\r\n\r\nOver at https://github.com/dotnet/corefx/issues/26368#issuecomment-358437182 (which eventually led to this proposal) there\u0027s discussion about some architectures possibly generating faults when trying to access unaligned data. But TBH I\u0027m not familiar enough with the silicon to speak to that.",
                                           "updatedAt":  "2020-01-25T01:19:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3ODM2NTU0Nw==",
                                           "createdAt":  "2020-01-25T01:59:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "There is a number of cases where misaligned `T*` will not generate fault, but accessing it comes with performance penalty. Would any penalty be acceptable? 1.5x? 5x? 15x?",
                                           "updatedAt":  "2020-01-25T01:59:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY2NTc3NDc1Ng==",
                                           "createdAt":  "2020-07-29T16:42:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericstj",
                                           "body":  "Given the linked issue was moved to future, and the timing for 5.0, will also move this to future as well.  @GrabYourPitchforks feel free to move as you see fit.\r\n\r\nAlso given @jkotas comment about this being runtime-specific, my inclination would be to put this in a System.Memory-related-type instead of Unsafe.",
                                           "updatedAt":  "2020-07-29T16:42:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY2NTc5MDQ3Ng==",
                                           "createdAt":  "2020-07-29T17:13:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "Agree on both counts. Though perhaps if it\u0027s runtime-dependent and meant for interop, then `System.Runtime.InteropServices` would be preferred over `System.Memory`?",
                                           "updatedAt":  "2020-07-29T17:13:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY2NTg1NzM4OA==",
                                           "createdAt":  "2020-07-29T19:28:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericstj",
                                           "body":  "Yeah, I considered that too (EG: Marshal) however I got the impression it was useful for more scenarios than interop.  EG: Intrinsics and optimizing perf might care about alignment.",
                                           "updatedAt":  "2020-07-29T19:28:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5E4_4Y",
                                           "createdAt":  "2022-06-14T23:06:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sakno",
                                           "body":  "Probably yes, it is valuable in scenarios rather than interop. I\u0027ve attached the rejected PR that prevents some optimizations in `ConcurrentDictionary` due to absence of `alignof`.",
                                           "updatedAt":  "2022-06-14T23:06:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5gyWi1",
                                           "createdAt":  "2023-07-06T14:46:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEGG9gQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "sakno",
                                                                               "createdAt":  "2023-07-06T15:30:28Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "En3Tho",
                                                                               "createdAt":  "2024-07-17T11:32:27Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alewmt",
                                                                               "createdAt":  "2025-02-12T13:00:39Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "xtqqczze",
                                           "body":  "In absence of this API, there is a workaround:\r\n\r\n```csharp\r\n[StructLayout(LayoutKind.Sequential)]\r\nprivate struct AlignOfHelper\u003cT\u003e where T : unmanaged\r\n{\r\n    public byte dummy;\r\n    public T data;\r\n}\r\npublic unsafe static int AlignOf\u003cT\u003e() where T : unmanaged\r\n{\r\n    return sizeof(AlignOfHelper\u003cT\u003e) - sizeof(T);\r\n}\r\n```\r\n\r\nAdapted from: https://github.com/Unity-Technologies/UnityCsReference/blob/e7d9de5f09767c3320b6dab51bc2c2dc90447786/Runtime/Export/Unsafe/UnsafeUtility.cs#L121-L132",
                                           "updatedAt":  "2023-07-06T14:46:00Z"
                                       }
                                   ],
                         "totalCount":  10
                     },
        "title":  "API proposal: Unsafe.AlignOf\u003cT\u003e()",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/33598",
        "createdAt":  "2020-03-14T22:22:32Z",
        "number":  33598,
        "author":  "blankensteiner",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC72o5g==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "alefranz",
                                            "createdAt":  "2020-07-22T08:23:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AdamDotNet",
                                            "createdAt":  "2020-09-03T16:46:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Vazde",
                                            "createdAt":  "2021-06-30T12:58:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rwkarg",
                                            "createdAt":  "2021-08-09T17:09:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "vchirikov",
                                            "createdAt":  "2021-11-16T10:55:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "bg719",
                                            "createdAt":  "2022-01-07T20:59:16Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "shadeglare",
                                            "createdAt":  "2022-02-06T18:43:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "nycdotnet",
                                            "createdAt":  "2022-05-04T13:47:36Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "abe545",
                                            "createdAt":  "2022-05-04T14:00:16Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "chande",
                                            "createdAt":  "2022-05-04T14:01:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "nramsey34",
                                            "createdAt":  "2022-05-04T14:03:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "oleksiistetsiuk",
                                            "createdAt":  "2022-05-04T14:06:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ido-namely",
                                            "createdAt":  "2022-05-04T14:19:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "accu4x",
                                            "createdAt":  "2022-05-04T15:48:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pentp",
                                            "createdAt":  "2023-05-09T15:22:49Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "justindbaur",
                                            "createdAt":  "2024-02-24T16:32:52Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "grbell-ms",
                                            "createdAt":  "2024-04-11T20:08:45Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2024-05-10T19:11:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "issue-dispenser",
                                            "createdAt":  "2024-10-16T02:53:48Z"
                                        }
                                    ],
                          "totalCount":  19
                      },
        "updatedAt":  "2023-05-06T20:03:14Z",
        "body":  "Hi\r\nI\u0027m writing my own serializer using Utf8JsonWriter and Utf8JsonReader.\r\nI have performance tested:\r\n* Utf8JsonWriter.Utf8JsonWriter(Stream utf8Json, JsonWriterOptions options = default) with a MemoryStream.\r\n* Utf8JsonWriter.Utf8JsonWriter(IBufferWriter\u003cbyte\u003e bufferWriter, JsonWriterOptions options = default) with an ArrayBufferWriter.\r\n* Utf8JsonWriter.Utf8JsonWriter(IBufferWriter\u003cbyte\u003e bufferWriter, JsonWriterOptions options = default) with a PooledByteBufferWriter.\r\n\r\nThe latter outperforms the first two and it would be awesome if it could be made public (it\u0027s internal now). I noticed that once ArrayBufferWriter was internal, but was made public, so I\u0027m hoping the same thing could happen here :-)",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOW5MbCQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5OTE0NDA0MQ==",
                                           "createdAt":  "2020-03-14T22:44:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOA-JNfw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2020-03-14T22:48:07Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "The libraries team isn\u0027t yet exposing \"dangerous\" types like this that use `ArrayPool` under the covers. The reason for this is that it\u0027s extremely easy to misuse these types, which could lead to global memory corruption of the application and would be nearly impossible to debug. This would do more harm than good to the ecosystem at large without a language feature that can enforce proper usage of these types.\r\n\r\nThink of it as conceptually similar to the below code, where the compiler enforces lifetime management of the spans to prevent the application from encountering strange failures at runtime.\r\n\r\n```cs\r\npublic static Span\u003cbyte\u003e GetSpanFoo()\r\n{\r\n    Span\u003cbyte\u003e theSpan = new byte[100];\r\n    return theSpan; // ok\r\n}\r\n\r\npublic static Span\u003cbyte\u003e GetSpanBar()\r\n{\r\n    Span\u003cbyte\u003e theSpan = stackalloc byte[100];\r\n    return theSpan; // compiler fails on this line\r\n}\r\n```\r\n\r\nSee also https://github.com/dotnet/runtime/issues/25587, where the proposed `ValueStringBuilder` suffers from a similar problem.",
                                           "updatedAt":  "2020-03-14T22:44:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5OTE1MDY4Nw==",
                                           "createdAt":  "2020-03-15T00:13:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "blankensteiner",
                                           "body":  "Hi @GrabYourPitchforks \r\nI see. Maybe we can find an alternative then since it would be a shame if only JsonSerializer can make Utf8JsonWriter use it.\r\nI\u0027ve seen other teams at Microsoft that places stuff in an \"Internal\" namespace, but make them public. Could that be a solution? Moving PooledByteBufferWriter to \u0027System.Text.Json.Internal\u0027 and thereby signaling that it\u0027s meant for internal use and therefore could be subject to change and/or \"dangerous\" to use?",
                                           "updatedAt":  "2020-03-15T00:13:08Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYwMTA2NjAzNQ==",
                                           "createdAt":  "2020-03-19T09:04:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "blankensteiner",
                                           "body":  "E.g https://github.com/dotnet/efcore/blob/master/src/EFCore/Internal/AsyncLock.cs",
                                           "updatedAt":  "2020-03-19T09:04:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY1ODUzNjE3MQ==",
                                           "createdAt":  "2020-07-15T04:18:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBKXfWQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "GrabYourPitchforks",
                                                                               "createdAt":  "2020-07-15T04:22:08Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "layomia",
                                           "body":  "Moving to System.Memory since it is a general purpose ask related to buffers/IBufferWriter.",
                                           "updatedAt":  "2020-07-15T04:18:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY1ODUzODQ3Mg==",
                                           "createdAt":  "2020-07-15T04:28:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "I 100% agree. We were overly cautious with ArrayBufferWriter but we avoid using it internally because we want to be efficient. I think it should be possible to use the ArrayBufferWriter with pooled buffers.",
                                           "updatedAt":  "2020-07-15T04:28:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY2NTIxODE1Mg==",
                                           "createdAt":  "2020-07-28T18:57:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MithrilMan",
                                           "body":  "I feel the need of a PooledByteBuffer too as stated in #40007 \r\nI understand the concern of misuse, then why don\u0027t hide the behavior behind a constructor overload `ArrayBufferWriter(bool usePool)`? (semi joke)\r\nBTW I don\u0027t feel the exmple of Span fitting the ArrayPool problem (Maybe I\u0027m underestimating some problem, I can just think about misusing PooledByteBuffer as a long living object not returning rented memory cause the pool to be constant out of memory causing it to keep allocating memory out of the memory pool)\r\n",
                                           "updatedAt":  "2020-07-28T18:57:53Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY2NTMzNTAyNg==",
                                           "createdAt":  "2020-07-28T22:54:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCbO00A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MithrilMan",
                                                                               "createdAt":  "2020-07-29T00:12:05Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "GSPP",
                                                                               "createdAt":  "2020-07-29T07:37:34Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "SGodeletAtBunnings",
                                                                               "createdAt":  "2021-10-07T01:08:08Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nycdotnet",
                                                                               "createdAt":  "2022-05-04T13:51:35Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "petermcneely",
                                                                               "createdAt":  "2022-05-04T13:52:35Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "andriipetrenko85",
                                                                               "createdAt":  "2022-05-04T13:57:08Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "abe545",
                                                                               "createdAt":  "2022-05-04T14:00:14Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "akashbhat25",
                                                                               "createdAt":  "2022-05-04T14:00:50Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "chande",
                                                                               "createdAt":  "2022-05-04T14:01:34Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nramsey34",
                                                                               "createdAt":  "2022-05-04T14:05:22Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "oleksiistetsiuk",
                                                                               "createdAt":  "2022-05-04T14:06:27Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "accu4x",
                                                                               "createdAt":  "2022-05-04T15:49:08Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "astonshane",
                                                                               "createdAt":  "2022-05-04T18:12:50Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  13
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "\u003e I understand the concern of misuse, then why don\u0027t hide the behavior behind a constructor overload\r\n\r\nThis isn\u0027t the typical pattern used by the .NET team.\r\n\r\nHere\u0027s a better analogy: we don\u0027t often make thread safety guarantees with many of our types. For example, if you have two threads operating on a `List\u003cT\u003e` concurrently, they\u0027re going to cause data corruption since we don\u0027t make any thread safety guarantees on that type. But the important distinction is that they corrupt data _only within that one `List\u003cT\u003e` instance_. Other `List\u003cT\u003e` instances in use by your app will be just fine.\r\n\r\nWith `PooledByteBufferWriter` (this issue) and `ValueStringBuilder` (see https://github.com/dotnet/runtime/issues/25587), misuse of the API is _potentially fatal to the application_. Two threads accidentally touch a single `PooledByteBufferWriter`? Accidentally make a copy-by-value of a `ValueStringBuilder`? You\u0027ve now inadvertently returned the same array to the array pool _twice_. This can lead to all sorts of problems, from the annoying (exception messages don\u0027t display correctly) to the disastrous (your web service starts sending responses to the wrong users).\r\n\r\nThe reason we generally don\u0027t like using constructor overloads for this is that the entity who makes the safety decision (whoever called the new ctor) and the entity who consumes the buffer writer are often in different libraries. We don\u0027t like being in a situation where somebody tests against one implementation and believes that things just work, and then they\u0027re handed a different implementation and things fall over in unexpected and unpredictable ways. That\u0027s why for both this issue and for https://github.com/dotnet/runtime/issues/25587 we\u0027re brainstorming some kind of compiler or runtime support that would __enforce__ correct behavior on the part of the consumers. If we can get that working, then the concerns about passing these types around dissipates quite a bit.",
                                           "updatedAt":  "2020-07-28T22:54:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5bkxsJ",
                                           "createdAt":  "2023-05-05T14:42:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "osexpert",
                                           "body":  "Maybe it should be called PooledArrayBufferWriter instead of PooledByteBufferWriter?\r\nYou could be forced to provide a private ArrayPool in the ctor to avoid global memory corruption (just like RecyclableMemoryStream has RecyclableMemoryStreamManager, and manager is the private pool)",
                                           "updatedAt":  "2023-05-06T20:03:14Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Make PooledByteBufferWriter public",
        "labels":  [
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/35981",
        "createdAt":  "2020-05-07T19:04:09Z",
        "number":  35981,
        "author":  "carlossanlop",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-07-24T23:01:01Z",
        "body":  "### Summary\r\n\r\nMethod invocations that receive integer arguments for a start and a length and apply them on an array or a segment, can get the arguments simplified in two specific cases:\r\n\r\n### Case 1: Exclude both `start` and `length` arguments\r\nConsider this code:\r\n```cs\r\nbyte[] buffer = { /*...*/ };\r\nReadOnlyMemory\u003cbyte\u003e memory = buffer.AsMemory(0, buffer.length);\r\n```\r\nBoth `start` and `length` arguments can be removed when `start = 0` and `length = buffer.Length`:\r\n```cs\r\nReadOnlyMemory\u003cbyte\u003e memory = buffer.AsMemory();\r\n```\r\n\r\n---\r\n\r\n### Case 2: Exclude the `length` argument\r\nConsider this code:\r\n```cs\r\nbyte[] buffer = { /*...*/ };\r\nint offsetValue = /* A number between 0 and buffer.Length */;\r\nReadOnlyMemory\u003cbyte\u003e memory = buffer.AsMemory(offsetValue, buffer.length - offsetValue);\r\n```\r\nThe `length` argument can be removed when `start = offsetValue` and `length = buffer.Length - offsetValue`\r\n```cs\r\nReadOnlyMemory\u003cbyte\u003e memory = buffer.AsMemory(offsetValue);\r\n```\r\n\r\n---\r\n### Method list\r\n\r\nThe list we know so far is the following (can be expanded):\r\n```cs\r\nSystem.ArraySegment\u003cT\u003e.Slice(int index, int count)\r\nSystem.MemoryExtensions.AsMemory(string text, int start, int length)\r\nSystem.MemoryExtensions.AsMemory\u003cT\u003e(ArraySegment\u003cT\u003e segment, int start, int length)\r\nSystem.MemoryExtensions.AsMemory\u003cT\u003e(T[] array, int start, int length)\r\nSystem.MemoryExtensions.AsSpan(string text, int start, int length)\r\nSystem.MemoryExtensions.AsSpan\u003cT\u003e(ArraySegment\u003cT\u003e segment, int start, int length)\r\nSystem.MemoryExtensions.AsSpan\u003cT\u003e(T[] array, int start, int length)\r\nSystem.Memory\u003cT\u003e.ctor(T[] array, int start, int length)\r\nSystem.Memory\u003cT\u003e.Slice(int start, int length)\r\nSystem.ReadOnlySpan\u003cT\u003e.ctor(T[] array, int start, int length)\r\nSystem.ReadOnlySpan\u003cT\u003e.Slice(int start, int length)\r\nSystem.ReadOnlyMemory\u003cT\u003e.ctor(T[] array, int start, int length)\r\nSystem.ReadOnlyMemory\u003cT\u003e.Slice(int start, int length)\r\nSystem.Span\u003cT\u003e.ctor(T[] array, int start, int length)\r\nSystem.Span\u003cT\u003e.Slice(int start, int length)\r\n```\r\n---\r\n### Examples to detect\r\n#### For case 1:\r\nThe value in the `start` argument can be an integer, a variable, or even a method call, but it must also be part of the `length` argument, as the value being substracted from the length of the array or segment. Examples:\r\n```cs\r\nbyte[] buffer = { /*...*/ };\r\nint offset = 5;\r\n\r\nMemory\u003cbyte\u003e a = buffer.AsMemory(1, buffer.Length - 1);\r\nSpan\u003cbyte\u003e b = buffer.AsSpan(offset, buffer.Length - offset);\r\nSpan\u003cbyte\u003e c = buffer.AsSpan().Slice(offset, buffer.Length - offset);\r\nReadOnlyMemory\u003cbyte\u003e d = new ReadOnlySpan\u003cbyte\u003e(buffer, GetOffset(), buffer.Length - GetOffset());\r\n```\r\nThe invocations get converted to:\r\n```cs\r\nMemory\u003cbyte\u003e a = buffer.AsMemory(1);\r\nSpan\u003cbyte\u003e b = buffer.AsSpan(offset);\r\nSpan\u003cbyte\u003e c = buffer.AsSpan().Slice(offset);\r\nReadOnlyMemory\u003cbyte\u003e d = new ReadOnlySpan\u003cbyte\u003e(buffer, GetOffset());\r\n```\r\n\r\n**Note**: We can discuss if we would like to exclude method calls in the first version of the analyzer, and include it in a future expansion.\r\n\r\n#### For case 2:\r\nA) The value in the `start` argument is 0, and the value in the `length` argument is the length of the array or segment. Examples:\r\n```cs\r\nbyte[] buffer = { /*...*/ };\r\nMemory\u003cbyte\u003e a = buffer.AsMemory(0, buffer.Length);\r\nSpan\u003cbyte\u003e b = buffer.AsSpan(0, buffer.Length);\r\n```\r\nThe invocations get converted to:\r\n```cs\r\nMemory\u003cbyte\u003e a = buffer.AsMemory();\r\nSpan\u003cbyte\u003e b = buffer.AsSpan();\r\n```\r\n\r\n**Note**: The `Slice` method does not get modified. See the \"Examples to _not_ detect\" section below for an explanation.\r\n\r\n---\r\n### Examples to _not_ detect\r\n\r\nA) The offset and/or length arguments are saved in variables in previous lines. The initial version of this analyzer should not detect this case, but it can be considered for a future expansion.\r\n\r\n#### For case 1:\r\n```cs\r\nbyte[] buffer = { /*...*/ };\r\nint length = buffer.Length - 1;\r\nbuffer.AsMemory(1, length);\r\n```\r\n\r\n```cs\r\nbyte[] buffer = { /*...*/ };\r\nint offset = 1;\r\nint length = buffer.Length - offset;\r\nbuffer.AsMemory(offset, length);\r\n```\r\n\r\n#### For case 2:\r\n\r\n```cs\r\nbyte[] buffer = { /*...*/ };\r\nint length = buffer.Length ;\r\nbuffer.AsMemory(0, length);\r\n```\r\n\r\n```cs\r\nbyte[] buffer = { /*...*/ };\r\nint offset = 0;\r\nint length = buffer.Length;\r\nbuffer.AsMemory(offset, length);\r\n```\r\n\r\nB) For case 2, the `Slice` methods must be handled in a special way, since they do not have an overload without arguments. We can exclude this case in the initial version of the analyzer, and we can consider it for future expansions.\r\nThere are 4 possible routes to take for `Slice`:\r\n```cs\r\nbyte[] buffer = { /*...*/ };\r\nSpan\u003cbyte\u003e a = buffer.AsSpan().Slice(0, buffer.Length);\r\n```\r\n- The invocation can be simplified:\r\n```cs\r\nSpan\u003cbyte\u003e a = buffer.AsSpan().Slice(0);\r\n```\r\n- Or can get the `Slice` invocation removed altogether:\r\n```cs\r\nSpan\u003cbyte\u003e a = buffer.AsSpan();\r\n```\r\n- Or can warn about an unnecessary `Slice` (if such rule does not exist yet).\r\n- Or can do nothing.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOJeCzeA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNTQ0MDQxMw==",
                                           "createdAt":  "2020-05-07T19:04:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Dotnet-GitSync-Bot",
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. Please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2020-05-07T19:04:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNTQ2NTk5MA==",
                                           "createdAt":  "2020-05-07T19:58:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC2XnjQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "carlossanlop",
                                                                               "createdAt":  "2020-05-07T21:46:09Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Eli-Black-Work",
                                                                               "createdAt":  "2023-02-20T02:37:21Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "This would apply to AsSpan as well.",
                                           "updatedAt":  "2020-05-07T19:58:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNTU1MDczNg==",
                                           "createdAt":  "2020-05-07T23:40:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "@jeffhandley (or @bartonjs ) when proposing an analyzer, is it sufficient to just label \"code-analyzer\" and the analyzer crew will see it? Or should there be an \"untriaged\" column on https://github.com/dotnet/runtime/projects/46 ? ",
                                           "updatedAt":  "2020-05-07T23:40:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNTU4NzQxNg==",
                                           "createdAt":  "2020-05-08T02:01:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBDkrJg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "danmoseley",
                                                                               "createdAt":  "2020-05-08T04:45:00Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "danmoseley",
                                                                               "createdAt":  "2020-05-08T04:45:09Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "bartonjs",
                                           "body":  "@danmosemsft We\u0027re currently using api-suggestion for that, making it similar to API proposals.",
                                           "updatedAt":  "2020-05-08T02:01:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNjg2MTA0Mw==",
                                           "createdAt":  "2020-05-11T18:01:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "@bartonjs can we consider this a small improvement over the existing rule, or should we consider it a separate api-suggestion that needs to get approved before I start coding it? I have this other issue opened in the roslyn-analyzers repo to improve over the already merged code: https://github.com/dotnet/roslyn-analyzers/issues/3612",
                                           "updatedAt":  "2020-05-11T18:02:37Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNjg3MjA3OQ==",
                                           "createdAt":  "2020-05-11T18:21:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bartonjs",
                                           "body":  "If you\u0027re tweaking an existing one, that\u0027s a tweak.  For making a new one (new rule ID, new class, new messages), it\u0027s a new one :smile:.\r\n\r\nIt seems conceptually easy for a new one; but you should try to describe it like I did in https://github.com/dotnet/runtime/issues/33763: What is it going to fix? (Description and examples) What is it not going to fix? (Description and samples).\r\n\r\nE.g.\r\n* It should apply to both AsMemory and AsSpan--is there anything else the pattern generalizes for? (using the ctors directly, for example.  Are there other, similar methods?)\r\n* I don\u0027t expect that an initial version would detect when the length was saved to a local variable, so that would be a good \"expect to not match\".  Or, you could put it in a section of \"possible future expansion\".\r\n* Similarly, if it was `target.AsSpan(x, y)` and the previous line was `y = target.Length - x`\r\n* For not matching: `target.AsSpan(x, y)` where `y` is a method call.  Or a literal.  Or an unrelated variable. Or whatever.  Just something to show \"this sort of call doesn\u0027t get modified\".  Which becomes the basis of a negative test.\r\n\r\nI think the biggest thing holding back green-lighting a new analyzer is the first bullet... we\u0027ve already identified that it\u0027s not just `AsMemory`, but also `AsSpan`, and probably some ReadOnlyMemory/Memory/ReadOnlySpan/Span ctors.  Maybe ArraySegment has some similar ctors.\r\nMaybe it should also simplify AsSpan(0) to AsSpan() (repeat across the matrix).  And, therefore, target.AsSpan(0, target.Length) to `target.AsSpan()`.",
                                           "updatedAt":  "2020-05-11T18:21:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNjg4NDczNg==",
                                           "createdAt":  "2020-05-11T18:43:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "@danmosemsft We aren\u0027t yet regularly triaging analyzer suggestions. I intend for us to do a round of triage on them as we\u0027re winding down our effort on the ones marked as .NET 5.0. I don\u0027t expect to add any more into 5.0 though, so any new suggestions are most likely to be tagged as Future.",
                                           "updatedAt":  "2020-05-11T18:43:51Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNzAwODUyMA==",
                                           "createdAt":  "2020-05-11T22:55:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "\u003e_I think the biggest thing holding back green-lighting a new analyzer is the first bullet_\r\n\r\nThanks for the explanation, @bartonjs. ~~Since I already opened dotnet/roslyn-analyzers#3612 to track the specific tweaks we want to add to the already merged Roslyn analyzer for `Stream.ReadAsync/WriteAsync`,~~ I say we use the current issue to specifically propose the new Roslyn analyzer for the generic case that will cover all the `Memory`, `ReadOnlyMemory`, `Span`, `ReadOnlySpan` and potentially `ArraySegment` cases.\r\n\r\nUnless there are any objections, I will edit the title and the main description later today, and will explain what is going to be fixed and what is not, per your suggestion.\r\n\r\nEdit: Ignore my first sentence. There\u0027s no point in working on the tweaks for the merged analyzer. This issue should track all cases.",
                                           "updatedAt":  "2020-05-11T22:58:34Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNzAxNTA4Mw==",
                                           "createdAt":  "2020-05-11T23:15:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "@jeffhandley sounds good\r\n[edit -- I remember why I asked -- so that we can mark up for grabs that that we would like but don\u0027t plan to do.]",
                                           "updatedAt":  "2020-05-11T23:16:46Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyODgxODEwOQ==",
                                           "createdAt":  "2020-05-14T18:40:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "Description updated.",
                                           "updatedAt":  "2020-05-14T18:40:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzNTQ4MzAwMA==",
                                           "createdAt":  "2020-05-28T17:16:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bartonjs",
                                           "body":  "\u003e The value in the start argument can be an integer, a variable, or even a method call, but it must also be part of the length argument, as the value being substracted from the length of the array or segment. \r\n\r\nMethod calls, or anything involving a member-access expression that isn\u0027t a field-access expression, are slightly dangerous to replace, because they could have side effects.  Reducing two calls to one can thus change the behavior of a program.  That might mean that the fixer batch ID needs to be different for member-access replacement, so someone can bulk apply all of the safe fixes then manually walk through the others.\r\n\r\n```C#\r\npublic int GetLength()\r\n{\r\n    _callCount++;\r\n    return _length;\r\n}\r\n```",
                                           "updatedAt":  "2020-05-28T17:16:56Z"
                                       }
                                   ],
                         "totalCount":  11
                     },
        "title":  "Roslyn analyzer/fixer: Simplify invocations that receive a start/offset and a count/length",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory",
                       "code-analyzer",
                       "code-fixer"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/36993",
        "createdAt":  "2020-05-26T00:18:26Z",
        "number":  36993,
        "author":  "Kuinox",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-05-10T19:33:36Z",
        "body":  "## Background and Motivation\r\nI wanted to implement my own SequenceReader for a library i\u0027m writing.\r\nIt\u0027s basically a few changes to how works the SequenceReader.\r\nBut sadly, the SequenceReader uses an internal helper wrote specifically for the SequenceReader as we can see in the comment: \r\nhttps://github.com/dotnet/runtime/blob/master/src/libraries/System.Memory/src/System/Buffers/ReadOnlySequence.Helpers.cs#L635  \r\nI don\u0027t think the SequenceReader should use internal API, or it would mean that the ReadOnlySequenceAPI is not enough open to do our own SequenceReader while keeping the same performance.\r\n\r\n## Proposed API\r\n\r\nI don\u0027t think exposing publicly ReadOnlySequence\u003cT\u003e.GetFirstSpan is a good idea.\r\nAnd I don\u0027t have any proposition to how to solve this.\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOMea_Tg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzNDEzMDE2Nw==",
                                           "createdAt":  "2020-05-26T16:22:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xqrzd",
                                           "body":  "I ran into the same problem for a different reason (I needed SequenceReader for a .net standard library, and there\u0027s no nuget package for SequenceReader). The only place I needed GetFirstSpan was for SequenceReader\u0027s constructor, in which case you can replace\r\n```\r\nsequence.GetFirstSpan(out ReadOnlySpan\u003cT\u003e first, out _nextPosition);\r\n```\r\nwith\r\n```\r\nvar first = sequence.First.Span;\r\n_nextPosition = sequence.GetPosition(first.Length);\r\n```",
                                           "updatedAt":  "2020-05-26T16:22:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzNDQyODMxNQ==",
                                           "createdAt":  "2020-05-27T04:57:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "scalablecory",
                                           "body":  "@Kuinox can you expand on what your `SequenceReader` is doing differently?\r\n\r\nNote there\u0027s a closely related `ReadOnlySequence\u003cT\u003e.FirstSpan` property, though it does not retrieve a position.",
                                           "updatedAt":  "2020-05-27T04:57:22Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzNDQ5ODkyNA==",
                                           "createdAt":  "2020-05-27T08:04:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Kuinox",
                                           "body":  "I changed the _moreData local to an enum to store an extra flag.  \r\nI set this flag in case of out of bound reading, it allow to remove the bool returned by most Read helpers, because I can simply check this error flag.  \r\nThe result is a simpler code when reading a sequence, where I simply can read the content then check if there was any error.",
                                           "updatedAt":  "2020-05-27T08:04:34Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgzNzIwNTgzOA==",
                                           "createdAt":  "2021-05-10T19:33:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "JeremyKuhne",
                                           "body":  "Note that the internal method is critical for performance. The right follow up for this is probably to investigate options for making the helper public.",
                                           "updatedAt":  "2021-05-10T19:33:36Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "SequenceReader should not rely on internal method ReadOnlySequence\u003cT\u003e.GetFirstSpan.",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/39466",
        "createdAt":  "2020-07-16T19:47:12Z",
        "number":  39466,
        "author":  "jkotas",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODC-01Q==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "qbit86",
                                            "createdAt":  "2020-07-18T22:54:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "theodorzoulias",
                                            "createdAt":  "2021-02-25T05:31:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "adamsitnik",
                                            "createdAt":  "2021-11-17T08:50:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "raulsntos",
                                            "createdAt":  "2023-08-15T11:24:20Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lakecherry",
                                            "createdAt":  "2023-10-14T10:45:37Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rampaa",
                                            "createdAt":  "2025-04-30T20:05:31Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hamarb123",
                                            "createdAt":  "2025-05-29T23:52:19Z"
                                        }
                                    ],
                          "totalCount":  7
                      },
        "updatedAt":  "2021-10-29T13:27:16Z",
        "body":  "Sort overloads that take `TComparer` as a generic argument were approved in https://github.com/dotnet/runtime/issues/19969 . However, the implementation did not take advantage of the generic `TComparer` and the `TComparer` overload is actually the less  efficient option.\r\n\r\nThis issue tracks fixing the implementation of `Sort\u003cT, TComparer\u003e` to take full advantage of the generic `TComparer`.\r\n\r\nFull context: https://github.com/dotnet/runtime/pull/37941#issuecomment-647766576",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOOOg8tw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY1OTYzMTI5MQ==",
                                           "createdAt":  "2020-07-16T19:47:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @eiriktsarpalis\nNotify danmosemsft if you want to be subscribed.",
                                           "updatedAt":  "2020-07-16T19:47:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY1OTYzMzc0Nw==",
                                           "createdAt":  "2020-07-16T19:52:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "cc @nietras",
                                           "updatedAt":  "2020-07-16T19:52:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY2MDA2ODA4Ng==",
                                           "createdAt":  "2020-07-17T11:57:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "nietras",
                                           "body":  "@jkotas thanks. Moving conversation from https://github.com/dotnet/runtime/pull/37941#issuecomment-659633427 here :)\r\n\r\n\u003e  For time line, I do not expect we would be able to get this change into .NET 5.\r\n\r\nI was really hoping we could get this in. The changes shouldn\u0027t be that big. As far as I understood, from a standup video I think, \"feature freeze\"/branch for .NET 5 RC might happen around 8th of August. That\u0027s doable in my view. Could you perhaps expand on why you think it won\u0027t be possible? What\u0027s the deadline? :)\r\n\r\n\u003e \"unsafe\" cast of `Comparison\u003cT\u003e` to `Comparison\u003cobject\u003e`\r\n\u003e Why would that be needed?\r\n\r\nThe idea here is to replace the `Comparison\u003cT\u003e` C# code path with a `TComparer` path e.g.\r\n```csharp\r\n    internal partial class ComparerArraySortHelper\u003cT, TComparer\u003e\r\n        where TComparer : IComparer\u003cT\u003e\r\n    {\r\n        public void Sort(Span\u003cT\u003e keys, TComparer comparer)\r\n        {\r\n```\r\n\r\nwe then need to support `Comparison\u003cT\u003e` via e.g.\r\n```csharp\r\n    internal readonly struct ComparisonComparer\u003cT\u003e : IComparer\u003cT\u003e\r\n    {\r\n        private readonly Comparison\u003cT\u003e _comparison;\r\n\r\n        public ComparisonComparer(Comparison\u003cT\u003e comparison) =\u003e\r\n            _comparison = comparison;\r\n\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n        public int Compare([AllowNull] T x, [AllowNull] T y) =\u003e\r\n            _comparison(x, y);\r\n    }\r\n```\r\n`Compare` can now be inlined for value types via https://github.com/dotnet/runtime/issues/10048. :+1:\r\n\r\nHowever, this won\u0027t work for reference types. At least not to my knowledge. Inlining and generics and all. The idea then would be to support reference types via internal trickery (if needed!) and use below for **all** reference types:\r\n```csharp\r\n    internal readonly struct ObjectComparisonComparer : IComparer\u003cobject\u003e\r\n    {\r\n        private readonly Comparison\u003cobject\u003e _comparison;\r\n\r\n        public ObjectComparisonComparer(Comparison\u003cobject\u003e comparison) =\u003e\r\n            _comparison = comparison;\r\n\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n        public int Compare([AllowNull] object x, [AllowNull] object y) =\u003e\r\n            _comparison(x, y);\r\n    }\r\n```\r\nIf the runtime can be changed to not having to have this, that would be great and would solve a long standing issue for me.\r\n\r\n\u003e whether it would make sense to delete the TComparer overloads from the public surface for now until we can get the right implementation for them in place.\r\n\r\nVery much hope we can get the implementation in and not change the public surface. The actual changes to the sorting code as such are minimal. :)",
                                           "updatedAt":  "2020-07-17T11:58:08Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY2MDEwMDI4MA==",
                                           "createdAt":  "2020-07-17T13:14:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e I was really hoping we could get this in. The changes shouldn\u0027t be that big\r\n\r\nI agree for functional correctness. I suspect that this work will uncover codegen issues that we won\u0027t have time to fix in next 3 weeks. ",
                                           "updatedAt":  "2020-07-17T13:14:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY2MDEwOTk3Ng==",
                                           "createdAt":  "2020-07-17T13:33:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "nietras",
                                           "body":  "\u003e will uncover codegen issues that we won\u0027t have time to fix in next 3 weeks.\r\n\r\nThat is of course a possibility/concern, given my experience with codegen here incl. net5 previews I am pretty optimistic, though. :) We should try at least. But I need guidance on how to refactor the whole ArraySortHelper stuff and whether the Comparison\u003cobject\u003e trick is viable/acceptable. My guess would be that if you, @jkotas, did this you could do the code changes in a couple of hours. 😉",
                                           "updatedAt":  "2020-07-17T13:33:54Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY2MDExMzAzOQ==",
                                           "createdAt":  "2020-07-17T13:40:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Comparison trick is viable/acceptable\r\n\r\nIf it was the only workaround for the codegen issues in the change, I think it would be acceptable. I suspect that the problem that it is trying to workaround is going to be present in more situations that are not possible to workaround.",
                                           "updatedAt":  "2020-07-17T13:40:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc446Dy3",
                                           "createdAt":  "2021-10-29T13:27:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @GrabYourPitchForks, @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nSort overloads that take `TComparer` as a generic argument were approved in https://github.com/dotnet/runtime/issues/19969 . However, the implementation did not take advantage of the generic `TComparer` and the `TComparer` overload is actually the less  efficient option.\r\n\r\nThis issue tracks fixing the implementation of `Sort\u003cT, TComparer\u003e` to take full advantage of the generic `TComparer`.\r\n\r\nFull context: https://github.com/dotnet/runtime/pull/37941#issuecomment-647766576\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejkotas\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Memory`, `tenet-performance`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003eFuture\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-10-29T13:27:15Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "Sort\u003cT, TComparer\u003e extensions performance",
        "labels":  [
                       "area-System.Memory",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/44351",
        "createdAt":  "2020-11-06T12:35:19Z",
        "number":  44351,
        "author":  "antonfirsov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-07-09T07:09:51Z",
        "body":  "`System.Buffers.Text.Tests.Base64EncoderUnitTests.EncodeTooLargeSpan` test hang in in:\r\n\r\nhttps://dev.azure.com/dnceng/public/_build/results?buildId=877008\u0026view=ms.vss-test-web.build-test-results-tab\r\n(net6.0-windows-Debug-x64-CoreCLR_release-Windows.10.Amd64.Server19H1.ES.Open)\r\n\r\nhttps://helixre8s23ayyeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-pull-44246-merge-d0435e106c844e1b8e/System.Memory.Tests/console.1eb45cee.log?sv=2019-07-07\u0026se=2020-11-25T21%3A20%3A41Z\u0026sr=c\u0026sp=rl\u0026sig=U3vXcd%2B3cmRt8pldKzKKdpi4Q0ADmohzWT9WnwwEFm0%3D",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOLMVJAw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMzE0NTUxOA==",
                                           "createdAt":  "2020-11-06T15:37:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "I suspect it\u0027s not actually a hang and that it was just taking a really long time encoding 2GB in the Base64.EncodeToUtf8 call.  Unfortunately there\u0027s no dump included to confirm or deny that.",
                                           "updatedAt":  "2020-11-06T15:37:02Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMzE2NDM3Mw==",
                                           "createdAt":  "2020-11-06T16:12:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "In any case the \"System.Memory.Tests Work Item\" failed in OuterLoop, and not 100% sure, but it\u0027s probably not the first time I\u0027ve seen this happening. If it occurs regularly we probably want to do something about it.",
                                           "updatedAt":  "2020-11-06T16:12:50Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyNDI0MzAxNw==",
                                           "createdAt":  "2020-11-09T19:56:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "Is there anything special about the machine this was running on? I wouldn\u0027t expect this test to take _that_ long unless system memory was so tight that we were hitting the pagefile over and over and over again. Maybe we can use `VirtualLock` to play tricks here?\r\n",
                                           "updatedAt":  "2020-11-09T19:56:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc1MTEyNjYxOQ==",
                                           "createdAt":  "2020-12-24T22:45:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "https://engsrvprod.kusto.windows.net/engineeringdata?query=H4sIAAAAAAAEAGWRQU%2fCQBCF7036H0YuQFJoqSQaknoQNcFEE0IN56U72gV2h8xugzX%2beLeAUOMedg%2fz5r1vZpfEm5lDbSEM4vgb9iUywpMyypYoIctACodOaeylSZoMRulgdAPJeJKmk3EyTK%2fHiT%2f9MPjXegeG9r3B6DaRffjrzgqN3NavQiNYJ9jZvXIldBa19SjDTsutLfUwv5IX1MT1MEfrbKft%2ffip3JQkwlUGycVn4YSrbOPQzf0sVLluU1yTMrBRRmbKGGR4ppUFMs07k5fuexamKA%2f5jO82LlFIG2vhUfiUvmNaY%2bFgXmGFDW10Rokgr3f%2bbs8SnfcUwZSMpS2%2bsYqOwREsT79yhLDEDlb1ZbUSbQGHSqW1YPWFUFBlXM8v2utaDMfkByo2yLn4CIMw%2bAFf8FUS8gEAAA%3d%3d\u0026web=0\r\n```\r\nWorkItems \r\n| where Finished \u003e now(-180d)  \r\n| where FriendlyName == \"System.Memory.Tests\"\r\n| where Status == \u0027Timeout\u0027\r\n| join kind=inner Jobs on JobId\r\n| where Branch == \"refs/heads/master\"\r\n| sort by Finished desc \r\n| summarize count()  by QueueName, Type, DockerTag\r\n```\r\n\r\nQueueName | Type | DockerTag | count_\r\n-- | -- | -- | --\r\nwindows.10.amd64.server20h1.open | test/functional/cli/outerloop/ | mcr.microsoft.com/dotnet-buildtools/prereqs:windowsservercore-2004-helix-amd64-20200904200251-272704c | 43\r\nwindows.10.amd64.serverrs5.open | test/functional/cli/outerloop/ | mcr.microsoft.com/dotnet-buildtools/prereqs:nanoserver-1809-helix-amd64-08e8e40-20200107182504 | 14\r\nwindows.10.amd64.serverrs5.open | test/functional/cli/outerloop/ |   | 10\r\nwindows.10.amd64.server19h1.open | test/functional/cli/outerloop/ |   | 7\r\nwindows.81.amd64.open | test/functional/cli/outerloop/ |   | 4\r\nwindows.10.amd64.serverrs5.open.rt | test/functional/cli/outerloop/ | mcr.microsoft.com/dotnet-buildtools/prereqs:nanoserver-1809-helix-amd64-08e8e40-20200107182504 | 4\r\nwindows.10.amd64.server19h1.open.rt | test/functional/cli/outerloop/ |   | 3\r\nwindows.10.amd64.open | test/functional/cli/innerloop/ |   | 2\r\nubuntu.1804.amd64.open | test/functional/cli/outerloop/ |   | 2\r\nwindows.10.amd64.serverrs5.open.rt | test/functional/cli/outerloop/ |   | 2\r\nubuntu.1604.amd64.open | test/functional/cli/innerloop/ | mcr.microsoft.com/dotnet-buildtools/prereqs:fedora-30-helix-20200512010621-4f8cef7 | 1\r\nwindows.10.amd64.serverrs5.open | test/functional/cli/innerloop/ |   | 1\r\nubuntu.1604.amd64.open | test/functional/cli/innerloop/ |   | 1\r\nwindows.81.amd64.open.rt | test/functional/cli/outerloop/ |   | 1\r\nwindows.10.amd64.server20h1.open.rt | test/functional/cli/outerloop/ | mcr.microsoft.com/dotnet-buildtools/prereqs:windowsservercore-2004-helix-amd64-20200904200251-272704c | 1\r\n\r\nSeems almost exclusively a Windows problem. I don\u0027t know how to get info on the memory though. Will have to ask engineering folks after holidays.",
                                           "updatedAt":  "2020-12-24T22:45:37Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc1MTEyNjc4Nw==",
                                           "createdAt":  "2020-12-24T22:48:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "Also, I looked at 5-10 console logs and it was always System.Buffers.Text.Tests.Base64EncoderUnitTests.EncodeTooLargeSpan",
                                           "updatedAt":  "2020-12-24T22:48:16Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "System.Memory.Tests Work Item fails without reports, long running Base64EncoderUnitTests.EncodeTooLargeSpan",
        "labels":  [
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/48678",
        "createdAt":  "2021-02-24T02:58:44Z",
        "number":  48678,
        "author":  "jnm2",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOBhIzSg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SingleAccretion",
                                            "createdAt":  "2021-02-24T04:26:25Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-03-12T23:55:05Z",
        "body":  "@tannergooding confirmed that this analyzer would be worth suggesting.\r\n\r\nThis pattern leaves a dangerous GC hole if using slow span, and there is a better alternative if using fast span:\r\n\r\n```cs\r\nfixed (void* pointer = \u0026something)\r\n    return new Span\u003cSomething\u003e(pointer, someLength);\r\n```\r\n\r\nIf MemoryMarshal.CreateSpan exists, then you are on a platform that supports fast span and you are safe because the span turns the pointer back into a ref internally, and the ref is updated by the GC if the GC moves `something` around in memory. Even though this syntax is safe on this platform, MemoryMarshal.CreateSpan should be suggested anyway instead of the syntax that is only safe on some platforms. Plus, there is no need to do any pinning:\r\n\r\n```cs\r\nreturn MemoryMarshal.CreateSpan(ref something, someLength);\r\n```\r\n\r\nHowever, if MemoryMarshal.CreateSpan does not exist, then you are on a platform that does not support fast span. Then there is a GC hole, meaning that as soon as the span is created and the `fixed` block ends, the GC may move the memory containing `something`, and the span that has been created does not get updated by the GC because slow span can\u0027t internally store a ref for the GC to update. There is no way to create a span from an arbitrary ref that is safe from GC race conditions on platforms using slow span.\r\n\r\nThis warning applies any time a span is created around a pointer declared by a `fixed` block and the span outlives the `fixed` block.\r\n\r\nWould it make sense to include this in the .NET 6 analyzers? https://github.com/dotnet/runtime/issues/43617\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOLts5cg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NDcxMjk2Mw==",
                                           "createdAt":  "2021-02-24T02:59:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @GrabYourPitchForks\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n@tannergooding confirmed that this analyzer would be worth suggesting.\r\n\r\nThis pattern leaves a dangerous GC hole if using slow span, and there is a better alternative if using fast span:\r\n\r\n```cs\r\nfixed (void* pointer = \u0026something)\r\n    return new Span\u003cSomething\u003e(pointer, someLength);\r\n```\r\n\r\nIf MemoryMarshal.CreateSpan exists, then you are on a platform that supports fast span and you are safe because the span turns the pointer back into a ref internally, and the ref is updated by the GC if the GC moves `something` around in memory. Even though this syntax is safe on this platform, MemoryMarshal.CreateSpan should be suggested anyway instead of the syntax that is only safe on some platforms. Plus, there is no need to do any pinning:\r\n\r\n```cs\r\nreturn MemoryMarshal.CreateSpan(ref something, someLength);\r\n```\r\n\r\nHowever, if MemoryMarshal.CreateSpan does not exist, then you are on a platform that does not support fast span. Then there is a GC hole, meaning that as soon as the span is created and the `fixed` block ends, the GC may move the memory containing `something`, and the span that has been created does not get updated by the GC because slow span can\u0027t internally store a ref for the GC to update. There is no way to create a span from an arbitrary ref that is safe from GC race conditions on platforms using slow span.\r\n\r\nWould it make sense to include this in the .NET 6 analyzers? https://github.com/dotnet/runtime/issues/43617\r\n\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejnm2\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Memory`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-02-24T02:59:04Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NDczNjM4Mw==",
                                           "createdAt":  "2021-02-24T04:02:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "SingleAccretion",
                                           "body":  "\u003e Then there is a GC hole, meaning that as soon as the span is created and the fixed block ends, the GC may move the memory containing something, and the span that has been created does not get updated by the GC because slow span can\u0027t internally store a ref for the GC to update.\r\n\r\nPerhaps it is my lack of understanding, but isn\u0027t that expected? We are creating a span with a pointer, once the source is no longer pinned, all bets should be off - there are no guarantees for pointers with respect to GC memory when it is not fixed.",
                                           "updatedAt":  "2021-02-24T04:02:10Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NDc0MDM5NA==",
                                           "createdAt":  "2021-02-24T04:09:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jnm2",
                                           "body":  "@SingleAccretion That\u0027s why this is a pattern in the wild that is dangerous and should get a warning, especially with a nudge to use `MemoryMarshal.CreateSpan` to avoid pinning even on platforms where the pattern happens to be safe.",
                                           "updatedAt":  "2021-02-24T04:09:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NDc0MDQxOQ==",
                                           "createdAt":  "2021-02-24T04:09:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCNPQNA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jnm2",
                                                                               "createdAt":  "2021-02-24T04:09:51Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jasonsparc",
                                                                               "createdAt":  "2022-02-05T14:44:29Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e We are creating a span with a pointer, once the source is no longer pinned, all bets should be off - there are no guarantees for pointers with respect to GC memory when it is not fixed.\r\n\r\nWhen fast span exists, it \"works\" because you effectively went `ref-\u003epinned pointer-\u003eref` and then unpinned. It\u0027s still not \"good\" and using `MemoryMarshal.CreateSpan` is preferred since it stays a `ref` the whole time.\r\n\r\nIt\u0027s only a GC hole for slow span because you are doing `ref-\u003epinned pointer` and then unpinning, which means the `ref` can move and the pointer won\u0027t update",
                                           "updatedAt":  "2021-02-24T04:09:35Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NDc0ODM5OQ==",
                                           "createdAt":  "2021-02-24T04:26:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "SingleAccretion",
                                           "body":  "\u003e That\u0027s why this is a pattern in the wild that is dangerous and should get a warning, especially with a nudge to use MemoryMarshal.CreateSpan to avoid pinning even on platforms where the pattern happens to be safe.\r\n\r\nI see. I suppose I was distracted by how \"obviously wrong\" the code looked. 👍 to the proposal.",
                                           "updatedAt":  "2021-02-24T04:26:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NDc1MjY1MA==",
                                           "createdAt":  "2021-02-24T04:35:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Are there examples you can point to of code using the OOB span actually doing this pattern?",
                                           "updatedAt":  "2021-02-24T04:36:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NDgxMTc0MA==",
                                           "createdAt":  "2021-02-24T06:10:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "\u003e `return MemoryMarshal.CreateSpan(ref something, someLength);`\r\n\r\nThat\u0027s still an unsafe equivalent. The caller is responsible for ensuring that the reference is still valid once it\u0027s returned to their caller. For example, the code below will compile without warning, but if you call this method and attempt to use the returned span you\u0027re in for a bad time.\r\n\r\n```cs\r\npublic static Span\u003cint\u003e GetSpan()\r\n{\r\n    int i = 0;\r\n    return MemoryMarshal.CreateSpan(ref i, 1);\r\n}\r\n```\r\n\r\nThe language traditionally hasn\u0027t put in too many safeguards once the developer drops down to unsafe code. But if these are straightforward to write, would find common problems, and have a low false positive rate, I\u0027m hard-pressed to find a good argument against it.",
                                           "updatedAt":  "2021-02-24T06:10:26Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NTE3OTIyNw==",
                                           "createdAt":  "2021-02-24T15:59:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e That\u0027s still an unsafe equivalent.\r\n\r\nI think the key difference here is that while `MemoryMarshal.CreateSpan` might allow you to leak the contents of the stack, it won\u0027t leave you tracking some arbitrary GC memory.\r\nLikewise, `MemoryMarshal.CreateSpan` can be done correctly via additional analysis and eventually transitioned to the safe alternative: https://github.com/dotnet/csharplang/blob/master/proposals/low-level-struct-improvements.md\r\n\r\nUsing `fixed` however is error prone because people don\u0027t understand the GC hole left on slow-span. I\u0027ve seen a number of discussions where people are fine with taking the unsafe dependency on `CreateSpan`, but where they try to work around it not existing on NS2.0 and end up with an accidental GC hole until someone comes along and warns them.",
                                           "updatedAt":  "2021-02-24T15:59:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NTIyODY1Mw==",
                                           "createdAt":  "2021-02-24T17:08:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "\u003e I think the key difference here is that while MemoryMarshal.CreateSpan might allow you to leak the contents of the stack, it won\u0027t leave you tracking some arbitrary GC memory.\n\nWhat\u0027s the practical difference? Whether I stomp on stack memory or heap memory, bad things will ensue. IMO if we create analyzers they should try to catch as many of these cases as practical.\n\nI agree with your assertion that these APIs can be used reliably given disciplined callers. Hopefully we\u0027ve not shipped APIs which can never be used reliably. :)\n\nEdit: safely -\\\u003e reliably",
                                           "updatedAt":  "2021-02-24T17:08:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjExOTAyNg==",
                                           "createdAt":  "2021-02-25T18:43:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jozkee",
                                           "body":  "cc @carlossanlop @buyaa-n ",
                                           "updatedAt":  "2021-02-25T18:43:09Z"
                                       }
                                   ],
                         "totalCount":  10
                     },
        "title":  "Using `fixed` to create a new span should result in a warning",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory",
                       "code-analyzer",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/52065",
        "createdAt":  "2021-04-29T17:23:19Z",
        "number":  52065,
        "author":  "tannergooding",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCx86cg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "filipnavara",
                                            "createdAt":  "2021-04-29T17:28:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jaredpar",
                                            "createdAt":  "2021-04-29T17:28:36Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Enderlook",
                                            "createdAt":  "2021-04-29T18:05:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "xoofx",
                                            "createdAt":  "2021-04-29T19:28:43Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "KirillOsenkov",
                                            "createdAt":  "2021-04-29T19:30:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "KirillOsenkov",
                                            "createdAt":  "2021-04-29T19:30:55Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Sergio0694",
                                            "createdAt":  "2021-04-29T19:44:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ltrzesniewski",
                                            "createdAt":  "2021-04-29T19:48:47Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "ltrzesniewski",
                                            "createdAt":  "2021-04-29T19:48:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hypeartist",
                                            "createdAt":  "2021-04-29T19:54:41Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "hypeartist",
                                            "createdAt":  "2021-04-29T19:54:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Wraith2",
                                            "createdAt":  "2021-04-29T22:29:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ForNeVeR",
                                            "createdAt":  "2021-04-30T01:32:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "nietras",
                                            "createdAt":  "2021-04-30T15:22:06Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "giladfrid009",
                                            "createdAt":  "2021-05-02T02:43:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DaveSenn",
                                            "createdAt":  "2021-05-14T23:55:54Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "DaveSenn",
                                            "createdAt":  "2021-05-14T23:55:57Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kronic",
                                            "createdAt":  "2021-05-26T19:23:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kant2002",
                                            "createdAt":  "2021-07-13T10:26:35Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "kant2002",
                                            "createdAt":  "2021-07-13T10:26:37Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SeeminglyScience",
                                            "createdAt":  "2021-07-25T02:31:48Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "SeeminglyScience",
                                            "createdAt":  "2021-07-25T02:31:50Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "svick",
                                            "createdAt":  "2021-07-25T07:05:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DaZombieKiller",
                                            "createdAt":  "2021-09-08T01:26:46Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "DaZombieKiller",
                                            "createdAt":  "2021-09-08T01:26:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AraHaan",
                                            "createdAt":  "2021-09-08T03:02:29Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "AraHaan",
                                            "createdAt":  "2021-09-08T03:02:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rickbrew",
                                            "createdAt":  "2021-09-08T13:57:44Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aromaa",
                                            "createdAt":  "2021-10-15T10:36:57Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AlgorithmsAreCool",
                                            "createdAt":  "2021-12-19T15:04:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "petarpetrovt",
                                            "createdAt":  "2022-01-06T07:23:36Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SupinePandora43",
                                            "createdAt":  "2022-03-16T05:47:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "exyi",
                                            "createdAt":  "2022-04-07T10:09:51Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "SupinePandora43",
                                            "createdAt":  "2022-04-12T15:53:26Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "Seb-stian",
                                            "createdAt":  "2022-04-13T09:22:09Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Seb-stian",
                                            "createdAt":  "2022-04-13T09:22:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Kuinox",
                                            "createdAt":  "2022-04-30T00:20:47Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "Kuinox",
                                            "createdAt":  "2022-04-30T00:20:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "xparadoxical",
                                            "createdAt":  "2022-05-16T08:32:49Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "xparadoxical",
                                            "createdAt":  "2022-05-16T08:32:50Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ZacharyPatten",
                                            "createdAt":  "2022-06-08T17:23:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "N0D4N",
                                            "createdAt":  "2022-07-29T08:49:33Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "jnm2",
                                            "createdAt":  "2022-10-24T18:46:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "acaly",
                                            "createdAt":  "2023-02-26T13:45:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "brianrourkeboll",
                                            "createdAt":  "2023-04-12T15:03:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "goncalo",
                                            "createdAt":  "2023-04-20T09:56:45Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Qiu233",
                                            "createdAt":  "2023-06-08T16:57:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "TFlippy",
                                            "createdAt":  "2023-07-07T02:22:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "0xced",
                                            "createdAt":  "2023-07-09T06:22:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "trevorgray",
                                            "createdAt":  "2023-08-15T07:56:21Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "trevorgray",
                                            "createdAt":  "2023-08-15T07:56:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MihaZupan",
                                            "createdAt":  "2023-09-21T21:07:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "timcassell",
                                            "createdAt":  "2023-10-08T04:15:32Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "aloraman",
                                            "createdAt":  "2023-10-28T12:00:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jwosty",
                                            "createdAt":  "2023-11-08T15:00:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "0xfeeddeadbeef",
                                            "createdAt":  "2023-11-26T14:27:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "frankbuckley",
                                            "createdAt":  "2024-01-05T09:51:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Kryptos-FR",
                                            "createdAt":  "2024-01-19T13:48:06Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "tanveerbadar",
                                            "createdAt":  "2024-01-22T03:47:36Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "tanveerbadar",
                                            "createdAt":  "2024-01-22T03:47:42Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "drewnoakes",
                                            "createdAt":  "2024-01-27T11:44:20Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jetersen",
                                            "createdAt":  "2024-02-10T07:06:25Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "amongonz",
                                            "createdAt":  "2024-03-09T18:44:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "elringus",
                                            "createdAt":  "2024-03-09T19:51:52Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "elringus",
                                            "createdAt":  "2024-03-09T19:51:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kettlemug",
                                            "createdAt":  "2024-04-14T14:41:54Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "kettlemug",
                                            "createdAt":  "2024-04-14T14:41:55Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "noelex",
                                            "createdAt":  "2024-05-02T09:23:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "issue-dispenser",
                                            "createdAt":  "2024-09-23T06:59:52Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-10-14T12:48:36Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "FaustVX",
                                            "createdAt":  "2024-10-14T16:57:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "FaustVX",
                                            "createdAt":  "2024-10-14T16:57:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DL444",
                                            "createdAt":  "2024-10-18T15:35:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Prunkles",
                                            "createdAt":  "2024-11-03T17:22:31Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2024-12-21T11:58:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "nikolai-mb",
                                            "createdAt":  "2024-12-21T22:16:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "edwardneal",
                                            "createdAt":  "2024-12-22T20:13:33Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lofcz",
                                            "createdAt":  "2025-01-05T16:58:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pentp",
                                            "createdAt":  "2025-01-20T15:06:04Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "maxkatz6",
                                            "createdAt":  "2025-02-05T11:06:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hughbe",
                                            "createdAt":  "2025-02-05T21:42:16Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "h3xds1nz",
                                            "createdAt":  "2025-02-17T14:54:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "KeterSCP",
                                            "createdAt":  "2025-02-24T08:18:09Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lilinus",
                                            "createdAt":  "2025-02-24T12:53:05Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "TonuFish",
                                            "createdAt":  "2025-03-03T01:48:51Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hendriklhf",
                                            "createdAt":  "2025-03-20T21:31:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Jeremy-Price",
                                            "createdAt":  "2025-05-15T16:28:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PranavSenthilnathan",
                                            "createdAt":  "2025-06-07T19:42:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MitchRazga",
                                            "createdAt":  "2025-06-20T09:48:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "frencsi",
                                            "createdAt":  "2025-08-04T14:49:15Z"
                                        }
                                    ],
                          "totalCount":  90
                      },
        "updatedAt":  "2025-02-10T02:00:52Z",
        "body":  "## Background and Motivation\r\n\r\nIt is not uncommon, in performance oriented code, to want to `stackalloc` for small/short-lived collections. However, the exact size is not always well known in which case you want to fallback to creating an array instead.\r\n\r\n## Proposed API\r\n\r\n```csharp\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public static unsafe partial class Unsafe\r\n    {\r\n        public static Span\u003cT\u003e Stackalloc\u003cT\u003e(int length);\r\n        public static Span\u003cT\u003e StackallocOrCreateArray\u003cT\u003e(int length);\r\n        public static Span\u003cT\u003e StackallocOrCreateArray\u003cT\u003e(int length, int maxStackallocLength);\r\n    }\r\n}\r\n```\r\n\r\nThese APIs would be `intrinsic` to the JIT and would effectively be implemented as the following, except specially inlined into the function so the `localloc` scope is that of the calling method:\r\n```csharp\r\npublic static Span\u003cT\u003e StackallocOrCreateArray\u003cT\u003e(int length, int maxStackallocLength)\r\n{\r\n    return ((sizeof(T) * length) \u003c maxStackallocLength) ? stackalloc T[length] : new T[length];\r\n}\r\n```\r\n\r\nThe variant that doesn\u0027t take `maxStackallocLength` would use some implementation defined default. Windows currently uses `1024`.\r\n\r\nAny `T` would be allowed and the JIT would simply do `new T[length]` for any types that cannot be stack allocated (reference types).",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOhDWSHA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTQ0ODIzNw==",
                                           "createdAt":  "2021-04-29T17:23:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @GrabYourPitchForks, @carlossanlop\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n## Background and Motivation\r\n\r\nIt is not uncommon, in performance oriented code, to want to `stackalloc` for small/short-lived collections. However, the exact size is not always well known in which case you want to fallback to creating an array instead.\r\n\r\n## Proposed API\r\n\r\n```csharp\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public static unsafe partial class Unsafe\r\n    {\r\n        public static Span\u003cT\u003e Stackalloc(int length);\r\n        public static Span\u003cT\u003e StackallocOrCreateArray\u003cT\u003e(int length);\r\n        public static Span\u003cT\u003e StackallocOrCreateArray\u003cT\u003e(int length, int maxStackallocLength);\r\n    }\r\n}\r\n```\r\n\r\nThese APIs would be `intrinsic` to the JIT and would effectively be implemented as the following, except specially inlined into the function so the `localloc` scope is that of the calling method:\r\n```csharp\r\npublic static Span\u003cT\u003e StackallocOrCreateArray\u003cT\u003e(int length, int maxStackallocLength)\r\n{\r\n    return ((sizeof(T) * length) \u003c maxStackallocLength) ? stackalloc T[length] : new T[length];\r\n}\r\n```\r\n\r\nThe variant that doesn\u0027t take `maxStackallocLength` would use some implementation defined default. Windows currently uses `1024`.\r\n\r\nAny `T` would be allowed and the JIT would simply do `new T[length]` for any types that cannot be stack allocated (reference types).\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003etannergooding\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Memory`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-04-29T17:23:25Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTQ0OTc4OA==",
                                           "createdAt":  "2021-04-29T17:25:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "This issue came up on Twitter again (https://twitter.com/jaredpar/status/1387798562117873678?s=20) and we have valid use cases in the framework and compiler.\r\n\r\nThis has been somewhat stuck in limbo as runtime/framework saying \"we need language support first\" and the language saying \"we need the runtime/framework to commit to doing this first\".\r\n\r\nWe should review and approve this to unblock the language from committing to their work and can do all the appropriate implementation/prep work on the runtime side, without actually making it public until the language feature is available.\r\n\r\nCC. @jkotas, @jaredpar, @GrabYourPitchforks ",
                                           "updatedAt":  "2021-04-29T17:25:46Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTQ1MTkyOQ==",
                                           "createdAt":  "2021-04-29T17:29:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "There would not be an API which opts to use the `ArrayPool` today. We don\u0027t use the `ArrayPool` for any type, but rather only specific sets of types. An API which does use some `ArrayPool` would likely need to return some other type which indicates whether the type needs to be returned.\r\n\r\n`Stackalloc` was added at the request of Jared who gave the following reasoning:\r\n\u003e stackalloc\r\n\u003e * returns a pointer hence no var \r\n\u003e * works only on where T: unmanaged \r\n\u003e\r\n\u003e Yes we could use a runtime feature flag to let the compiler remove the restriction on where T : unmanaged. But that doesn\u0027t fix the var issue. At the point we\u0027re adding new APIs for stack alloc then seems better to simplify and use them for all forms of stack alloc. Makes the code more consistent, lets you have the same type of call sites (can flip between forms without having to also say flip var) ",
                                           "updatedAt":  "2021-04-29T17:29:10Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTQ1MjI2NQ==",
                                           "createdAt":  "2021-04-29T17:29:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "Related to https://github.com/dotnet/runtime/issues/25423. That proposal is a bit light on concrete APIs, but it suggests behaviors / analyzers / other ecosystem goodness we\u0027d likely want to have around this construct.",
                                           "updatedAt":  "2021-04-29T17:31:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTQ1Mzg2MQ==",
                                           "createdAt":  "2021-04-29T17:32:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD2Kafg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "tannergooding",
                                                                               "createdAt":  "2021-04-29T17:32:52Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "Joe4evr",
                                                                               "createdAt":  "2021-04-29T20:07:17Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "danfma",
                                                                               "createdAt":  "2022-06-12T14:29:46Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "iam3yal",
                                                                               "createdAt":  "2024-10-15T06:48:38Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "jaredpar",
                                           "body":  "This does require language changes to work correctly but the implementation is very straight forward. The compiler will just treat all of these calls as if they are not safe to escape from the calling method. Effectively it would have the same lifetime limitation as calling `stackalloc` today. \r\n\r\nI think the best approach is to just have the compiler trigger on the FQN of the method. Essentially any API with this signature in any assembly would be treated this way. That would make it easier to write code that multi-targets between .NET Core and .NET Framework as the framework side of this could be implemented as `new T[length]` in all cases.\r\n\r\nThe other advantage of this API is that w can once again *var all the things*. \r\n\r\n```c#\r\nvar local1 = stackalloc int[42]; // int*\r\nvar local2 = Unsafe.StackAlloc\u003cint\u003e(42); // Span\u003cint\u003e\r\n```",
                                           "updatedAt":  "2021-04-29T17:32:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTQ1Nzc5OQ==",
                                           "createdAt":  "2021-04-29T17:38:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "This is one of those features that requires a joint work from all runtimes/JIT/language/libraries. Our .NET 6 budget for features in this space was taken by the generic numerics. We should include this proposal next time we do planning in this area.\r\n\r\nApproving this API without the resource commintment won\u0027t achieve much.",
                                           "updatedAt":  "2021-04-29T17:38:22Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTQ2Mjc4OQ==",
                                           "createdAt":  "2021-04-29T17:46:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e Approving this API without the resource commintment won\u0027t achieve much.\r\n\r\nIt gives us a surface on which this can be implemented given \"free time\" and can be prioritized appropriately.\r\n\r\nThe library work is approving the API and exposing the surface area.\r\nThe language work is recognizing these methods and based on Jared\u0027s comment is relatively trivial.\r\n\r\nThe JIT work should just be implementing it as a recursive named intrinsic and then creating the relevant nodes for:\r\n```csharp\r\nif ((sizeof(T) * length) \u003c maxStackallocLength)\r\n{\r\n    var x = stackalloc T[length];\r\n    return new Span\u003cT\u003e(x, length);\r\n}\r\nelse   \r\n{\r\n    var x = new T[length];\r\n    return new Span\u003cT\u003e(x);\r\n}\r\n```\r\n\r\nThis is fairly straightforward, except for the `newobj` calls which involves getting the relevant method tokens",
                                           "updatedAt":  "2021-04-29T17:47:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTQ2ODI5Mw==",
                                           "createdAt":  "2021-04-29T17:53:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e The JIT work should just be implementing it as a recursive named intrinsic and then creating the relevant nodes for:\r\n\r\nI do not think we would want to do a naive implementation like this. I think we would want to do explicit life-time tracking even when the lenght is over the threashold.",
                                           "updatedAt":  "2021-04-29T17:53:47Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTQ3MDU4MA==",
                                           "createdAt":  "2021-04-29T17:57:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e I think we would want to do explicit life-time tracking even when the lenght is over the threashold.\r\n\r\nWhat\u0027s the scenario where the JIT needs to do additional tracking that isn\u0027t already covered by the language rules and by the existing tracking for `Span\u003cT\u003e`?\r\n\r\nUsers can and already do write the above today, just manually inlined. We are looking at doing exactly this already in one of the `BigInteger` PRs.\r\nThis is an API on `Unsafe` that exists to help simplify the logic and behave like `alloca` does in C/C++ and can be immensely simplified/unblock scenarios by doing the trivial implementation.\r\nIt then becomes a drop in replacement for what users are already doing.",
                                           "updatedAt":  "2021-04-29T17:57:37Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTQ3NTYwNQ==",
                                           "createdAt":  "2021-04-29T18:05:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEaDaCg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "gfoidl",
                                                                               "createdAt":  "2021-04-29T18:22:19Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Sergio0694",
                                                                               "createdAt":  "2021-04-29T19:46:51Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nietras",
                                                                               "createdAt":  "2021-04-30T15:24:35Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "JimBobSquarePants",
                                                                               "createdAt":  "2021-05-11T02:04:58Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "N0D4N",
                                                                               "createdAt":  "2021-07-28T12:02:47Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jaredpar",
                                                                               "createdAt":  "2022-06-07T17:13:00Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "geeknoid",
                                                                               "createdAt":  "2022-06-07T17:53:06Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "noelex",
                                                                               "createdAt":  "2024-05-02T09:29:28Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-10-14T12:48:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "DL444",
                                                                               "createdAt":  "2024-10-22T12:51:17Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nikolai-mb",
                                                                               "createdAt":  "2024-12-21T22:18:27Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pentp",
                                                                               "createdAt":  "2025-01-20T15:15:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "mwadams",
                                                                               "createdAt":  "2025-07-10T08:24:00Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  13
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e What\u0027s the scenario where the JIT needs to do additional tracking that isn\u0027t already covered by the language rules and by the existing tracking for Span\u003cT\u003e?\r\n\r\nWe would be leaving performance on the table. \r\n\r\nMajority of the existing stackalloc uses are using ArrayPool as the fallback. If the new API is not using pooled memory as the fallback, the majority of the existing stackalloc sites won\u0027t be able to use it.",
                                           "updatedAt":  "2021-04-29T18:08:14Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTQ4MjI0NA==",
                                           "createdAt":  "2021-04-29T18:16:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jaredpar",
                                           "body":  "\u003e It is also could be a common pattern to use stackalloc or ArrayPool, e.g.:\r\n\r\nThat requires a different level of language support. Supporting the non-arraypool case is very straight forward. It\u0027s just generalizing the existing lifetime restrictions we associate with `stackalloc` to instead be a collection of API calls. It\u0027s closer to a bug fix level of work than a new feature. \r\n\r\nThe `ArrayPool` case is very doable but it\u0027s definitely in the \"new feature\" category because we have to do the work to handle `Free` and design some cases around it. Example: do we make locals initialized with these APIs as unassignable? If we allow reassignment then we have to consider how that impacts us calling `Free` with the resulting value. Solvable items but definitely a bit of design work that needs to go into it.\r\n\r\n",
                                           "updatedAt":  "2021-04-29T18:16:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTQ4MjgzOA==",
                                           "createdAt":  "2021-04-29T18:16:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "That really sounds like an additional ask and one isn\u0027t strictly needed at the same time.\r\n\r\nPooling has a lot of different considerations and we ourselves largely only use it with a few primitive types (namely `byte`), not any `T`. It likewise requires:\r\n* a way to get the array from a `Span\u003cT\u003e`\r\n* knowing that `Span\u003cT\u003e` definitely points to the start of an `Array`\r\n* may involve custom pooling and not just `ArrayPool`\r\n* etc\r\n\r\nI think its doable, but we could also unblock many scenarios with the above today and with minimal work.",
                                           "updatedAt":  "2021-04-29T18:16:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTQ4MzMxNQ==",
                                           "createdAt":  "2021-04-29T18:17:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e The ArrayPool case is very doable but it\u0027s definitely in the \"new feature\" category because we have to do the work to handle Free and design some cases around it.\r\n\r\nI do not think we would necessarily want to deal with the pooling in Roslyn, nor have it backed by the ArrayPool as it exist today.",
                                           "updatedAt":  "2021-04-29T18:18:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTQ4NTQwOQ==",
                                           "createdAt":  "2021-04-29T18:20:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCgplqA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "geeknoid",
                                                                               "createdAt":  "2022-06-07T17:54:21Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e we could also unblock many scenarios with the above today and with minimal work.\r\n\r\nI do not see those scenarios. The minimal work just lets you do the same thing as what you can do with stackalloc today, just maybe saves you a few characters. ",
                                           "updatedAt":  "2021-04-29T18:20:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTQ5MDAyMw==",
                                           "createdAt":  "2021-04-29T18:28:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e I do not see those scenarios\r\n\r\nThey exist everywhere that `alloca` is used in native. They exist in 3rd party libraries like `ImageSharp`.\r\nThey exist for types where array pooling isn\u0027t desirable because pooling has its own overhead and costs (and generally cost per type).\r\n\r\nNone of the existing proposals or discussions around this, including https://github.com/dotnet/runtime/issues/25423 which has been around for 3 years, have really covered pooling as that is considered a more advanced scenario.\r\n\r\nThis covers the case of \"I want to allocate on the stack for small data and on the heap for larger data\" and where the limit for that might vary between platforms and architectures. Windows for example has a 1MB stack by default and uses 1024 bytes. Linux uses a 4MB stack and might want a different limit.\r\n\r\nEncountering large lengths is typically expected to be rare, but not impossible. Its not unreasonable to simply new up an unpooled array in that scenario.\r\n",
                                           "updatedAt":  "2021-04-29T18:28:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTQ5MzYzNA==",
                                           "createdAt":  "2021-04-29T18:33:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "Pooling, for example, is likely only beneficial for types like `byte`, `char`, or `int` which are (for the vast majority case) the only usages in the BCL: \u003chttps://source.dot.net/#System.Private.CoreLib/ArrayPool.cs,704a680ba600a2a4,references\u003e",
                                           "updatedAt":  "2021-04-29T18:33:20Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTQ5Nzk0Ng==",
                                           "createdAt":  "2021-04-29T18:40:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEFXyQw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2021-04-29T18:41:19Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "gfoidl",
                                                                               "createdAt":  "2021-04-29T18:45:28Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "DarkBullNull",
                                                                               "createdAt":  "2021-04-29T19:27:16Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "john-h-k",
                                                                               "createdAt":  "2021-04-29T19:31:24Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Sergio0694",
                                                                               "createdAt":  "2021-04-29T19:48:18Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "samsosa",
                                                                               "createdAt":  "2021-04-29T22:50:24Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ForNeVeR",
                                                                               "createdAt":  "2021-04-30T01:38:28Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "strangeman375",
                                                                               "createdAt":  "2021-04-30T05:31:05Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kronic",
                                                                               "createdAt":  "2021-05-26T19:27:44Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MichalPetryka",
                                                                               "createdAt":  "2021-08-09T16:16:40Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "geeknoid",
                                                                               "createdAt":  "2022-06-07T17:55:04Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "N0D4N",
                                                                               "createdAt":  "2022-07-29T08:49:52Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hrrrrustic",
                                                                               "createdAt":  "2022-09-05T16:53:24Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "d2dyno1",
                                                                               "createdAt":  "2023-07-05T11:37:05Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tanveerbadar",
                                                                               "createdAt":  "2024-01-22T03:53:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jetersen",
                                                                               "createdAt":  "2024-02-10T07:07:21Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "DL444",
                                                                               "createdAt":  "2024-10-22T12:58:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nikolai-mb",
                                                                               "createdAt":  "2025-02-05T15:44:28Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  18
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "`stackalloc + new`:\r\n```csharp\r\n    Span\u003cbyte\u003e span = Unsafe.StackallocOrCreateArray(len, 1024);\r\n    // vs \r\n    Span\u003cbyte\u003e span = len \u003e 1024 ? new byte[len] : stackalloc byte[1024];\r\n```\r\nIndeed just saves a few characters (but nice to have).\r\n\r\nBut `stackalloc + arraypool` should save a lot 🙂 :\r\n```csharp\r\n    byte[] arrayFromPool = null;\r\n    Span\u003cbyte\u003e span = len \u003e 1024 ? (arrayFromPool = ArrayPool\u003cbyte\u003e.Shared.Rent(len)) : stackalloc byte[1024];\r\n    try\r\n    {\r\n    }\r\n    finally\r\n    {\r\n        if (arrayFromPool != null)\r\n            ArrayPool\u003cbyte\u003e.Shared.Return(arrayFromPool );\r\n    }\r\n\r\n    // vs \r\n    Span\u003cbyte\u003e span = Unsafe.StackallocOrPool(len, 1024);\r\n```\r\n",
                                           "updatedAt":  "2021-04-29T18:40:18Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTUwMDM3Ng==",
                                           "createdAt":  "2021-04-29T18:44:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC6QYDA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tannergooding",
                                                                               "createdAt":  "2021-04-29T18:47:02Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "goncalo",
                                                                               "createdAt":  "2023-04-20T10:00:53Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "jaredpar",
                                           "body":  "\u003e Indeed just saves a few characters (but nice to have).\r\n\r\nHas a couple of other benefits: \r\n\r\n1. Path forward for supporting `unmanaged` types in `stackalloc`, particularly for code that needs to cross compile between .NET Core and Framework\r\n2. Supports `var` \r\n",
                                           "updatedAt":  "2021-04-29T18:44:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTUwMDg1MQ==",
                                           "createdAt":  "2021-04-29T18:45:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jaredpar",
                                           "body":  "\u003e But stackalloc + arraypool should save a lot \r\n\r\nI\u0027m now seeing conflicting advice on whether or not arrays should be returned to the pool in a `finally`. Had others suggest that the `finally` is too much overhead and best to just let the array leak in the case of an exception. ",
                                           "updatedAt":  "2021-04-29T18:45:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTUwMjE1Mw==",
                                           "createdAt":  "2021-04-29T18:47:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBpGsmw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "EgorBo",
                                                                               "createdAt":  "2021-04-29T19:26:03Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "gfoidl",
                                           "body":  "@EgorBo your example with the pool would save even more when the Span\u003cbyte\u003e is sliced to the desired length (as it\u0027s often needed that way when the length is given as argument).",
                                           "updatedAt":  "2021-04-29T18:47:34Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTUwMzc4MQ==",
                                           "createdAt":  "2021-04-29T18:50:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBpGeGA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "GrabYourPitchforks",
                                                                               "createdAt":  "2021-04-29T18:58:42Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e They exist for types where array pooling isn\u0027t desirable because pooling has its own overhead and costs (and generally cost per type).\r\n\r\nThis is due to current array pool design limitations. This is fixable by treating management of explicit lifetime memory as core runtime feature.\r\n\r\n\u003e I\u0027m now seeing conflicting advice on whether or not arrays should be returned to the pool in a finally\r\n\r\nThis depends on how performance sensitive your code is and how frequenly you expect exceptions to occur inside the scope. If your code is perf critical (e.g. number formatting) and you do not expect exceptions to ever occur inside the scope (e.g. the only exception you ever expect is out of memory), it is better to avoid finally as it is the common case in dotnet/runtime libraries.",
                                           "updatedAt":  "2021-04-29T19:00:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTUxMjUwOQ==",
                                           "createdAt":  "2021-04-29T19:04:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e This is due to current array pool design limitations. This is fixable by treating management of explicit lifetime memory as core runtime feature.\r\n\r\nThat also sounds like a feature that is potentially several releases out and which is going to require users and the compiler to review where it is good/correct to use.\r\n\r\nSomething like proposed here is usable in the interim, including for cases like `params Span\u003cT\u003e`. It represents something that many languages do provide and which is part of the \"standard\" set of memory allocation APIs commonly exposed by languages.\r\nIt likewise fills a gap for languages that don\u0027t have unsafe support or which don\u0027t have an implicit conversion to span, such as F#: https://github.com/fsharp/fslang-suggestions/issues/720\r\n\r\nHaving to do `Span\u003cbyte\u003e span = len \u003e 1024 ? new byte[len] : stackalloc byte[1024];` everywhere and then go and find/update every callsite if you end up changing the behavior or size limit isn\u0027t great.\r\nHaving an API is good for the same reason all helper/utility methods are good and helps with refactorings, maintainability, finding usages of the pattern, etc. It also allows it to easily be customized for different stack sizes, at least for Unix vs Windows and possibly vs MacOS or ARM or 32-bit vs 64-bit.\r\n\r\n\r\n\r\n",
                                           "updatedAt":  "2021-04-29T19:04:10Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTUzMTY2Mw==",
                                           "createdAt":  "2021-04-29T19:35:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODO13uQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jwosty",
                                                                               "createdAt":  "2023-12-07T14:51:10Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "xoofx",
                                           "body":  "What about making the allocator not necessarily bound to `new byte[len]` or `ArrayPool\u003cbyte\u003e.Shared.Rent(len)` (e.g could come from e.g unmanaged memory pool)\r\n\r\n```c#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public static unsafe partial class Unsafe\r\n    {\r\n        public static Span\u003cT\u003e Stackalloc\u003cTAllocator, T\u003e(int length, TAllocator allocator) \r\n                                                 where TAllocator: ISpanAllocator\u003cT\u003e\r\n        // ...\r\n    }\r\n    \r\n    public interface ISpanAllocator\u003cT\u003e {\r\n         Span\u003cT\u003e Allocate(int length);   \r\n    }\r\n}\r\n```",
                                           "updatedAt":  "2021-04-29T19:37:05Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTUzMjAxNA==",
                                           "createdAt":  "2021-04-29T19:36:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBpGzNg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tannergooding",
                                                                               "createdAt":  "2021-04-29T19:39:18Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "benaadams",
                                           "body":  "\u003e Any `T` would be allowed and the JIT would simply do new `T[length]` for any types that cannot be stack allocated (reference types).\r\n\r\nCould also allocate a series of ref fields (all null); and then allow indexing them as via Span",
                                           "updatedAt":  "2021-04-29T19:36:09Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTUzNTYwNQ==",
                                           "createdAt":  "2021-04-29T19:41:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e What about making the allocator not necessarily bound to new byte[len] or ArrayPool\u003cbyte\u003e.Shared.Rent(len)\r\n\r\nI think any API that isn\u0027t tracking either `T*` or `T[]` would need to return something like `DisposableSpan\u003cT\u003e` so the appropriate `free` could occur (or would need language support for the relevant `TAllocator.Free` to be called).\r\n\r\nOtherwise, I think it falls into the general camp of what it seems @jkotas is proposing with runtime supported lifetime tracking.",
                                           "updatedAt":  "2021-04-29T19:42:18Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTUzNjczOQ==",
                                           "createdAt":  "2021-04-29T19:43:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBpHlHA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "tannergooding",
                                                                               "createdAt":  "2021-04-29T19:44:39Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "MihaZupan",
                                                                               "createdAt":  "2021-04-29T21:21:12Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "xoofx",
                                           "body":  "\u003e I think any API that isn\u0027t tracking either `T*` or `T[]` would need to return something like `DisposableSpan\u003cT\u003e` so the appropriate `free` could occur (or would need language support for the relevant `TAllocator.Free` to be called).\r\n\r\nOh, yeah true, Let\u0027s do it! 😅 ",
                                           "updatedAt":  "2021-04-29T19:43:20Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTU1MDQ5NQ==",
                                           "createdAt":  "2021-04-29T19:51:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xoofx",
                                           "body":  "That starts to be as painful as implementing `IEnumerable\u003cT\u003e` 🙃 \r\n\r\n```c#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public static unsafe partial class Unsafe\r\n    {\r\n        public static TState Stackalloc\u003cTAllocator, TState, T\u003e(int length, TAllocator allocator, out Span\u003cT\u003e span) \r\n                                                 where TAllocator: ISpanAllocator\u003cT, TState\u003e\r\n        // ...\r\n    }\r\n    \r\n    public interface ISpanAllocator\u003cT, TState\u003e {\r\n        Span\u003cT\u003e Allocate(int length, out TState state);   \r\n        void Release(TState state);\r\n    }\r\n}\r\n```\r\n\r\n[Edit] Removed `where TState: IDisposable` as we have already `ISpanAllocator.Release`\r\n[Edit2] Arg, actually, maybe it was better with the IDiposable, I told you, it\u0027s more painful than IEnumerable",
                                           "updatedAt":  "2021-04-29T19:58:43Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTU1MDU4NA==",
                                           "createdAt":  "2021-04-29T19:51:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Tornhoof",
                                           "body":  "The concepts which return some kind of pooled array overlap with ``IMemoryOwner``.\r\nThe duality of Span vs. IMemoryOwner shows up in e.g. MS FASTER. https://github.com/microsoft/FASTER/blob/master/cs/src/core/VarLen/SpanByteAndMemory.cs\r\n",
                                           "updatedAt":  "2021-04-29T19:51:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTY0NTg4NA==",
                                           "createdAt":  "2021-04-29T22:51:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e \u003e I do not see those scenarios\r\n\r\n\u003e They exist everywhere that alloca is used in native. They exist in 3rd party libraries like ImageSharp.\r\n\r\nI went through all existing stackallocs in ImageSharp. I do not see any of them matching the naive pattern. Where would this API be used in ImageSharp?",
                                           "updatedAt":  "2021-04-29T22:51:50Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTY1MDU5NQ==",
                                           "createdAt":  "2021-04-29T23:01:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e Where would this API be used in ImageSharp?\r\n\r\nLooks like I was either misremembering or its been changed. They are using `ArrayPool\u003cT\u003e` right now: https://github.com/SixLabors/ImageSharp.Drawing/blob/d8960b8e2e55875d2c4f990f5fc439b846af1230/src/ImageSharp.Drawing/Shapes/InternalPath.cs#L231-L234",
                                           "updatedAt":  "2021-04-29T23:01:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTc5ODE2Mw==",
                                           "createdAt":  "2021-04-30T04:36:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODsX8bw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tanveerbadar",
                                                                               "createdAt":  "2024-01-22T03:57:34Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "BoyBaykiller",
                                                                               "createdAt":  "2024-08-01T03:32:22Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "xoofx",
                                           "body":  "But I\u0027m a bit worried of the limitations of this proposal, e.g if it is hardcoding to a particular underlying allocator (being new or shared ArrayPool) or to a hardcoded heuristic... After frankly, it\u0027s not the end of the world, we are not blocked today as we can perfectly write manually such code. Yes, It can be laborious if we go through the full pattern with array pool + try/finally + dispose but it still sounds to me like a nice to have.\r\n\r\nThough, one function that would be helpful to develop wiser stackalloc heuristics is something like `RuntimeHelpers.GetAvailableStackSizeInBytes()` (I think a similar request was formulated on previous issues)",
                                           "updatedAt":  "2021-04-30T04:37:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgzMDE1MzkxNg==",
                                           "createdAt":  "2021-04-30T14:58:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "iSazonov",
                                           "body":  "\u003e These APIs would be intrinsic to the JIT\r\n\r\nI wonder why we need the new API at all if it can be intrinsic in some ways because everything we need is known in advance.\r\n\r\nIf user writes:\r\n```c#\r\nvar buffer = new T[length];\r\n```\r\nand compiler has MaxStackallocLength and it can directly put follow implementation:\r\n```c#\r\nvar buffer = ((sizeof(T) * length) \u003c MaxStackallocLength) ? stackalloc T[length] : new T[length];\r\n```\r\nand if the length is known at compile time, it can immediately simplify the expression (this could also be optimized at runtime too). \r\n\r\nI guess this could work well most of the time. Otherwise we could have turned off this new behavior with a compiler directive.\r\n\r\n-----\r\n\r\n\u003e Majority of the existing stackalloc uses are using ArrayPool as the fallback. If the new API is not using pooled memory as the fallback, the majority of the existing stackalloc sites won\u0027t be able to use it.\r\n\r\nCompiler could replace:\r\n```c#\r\nvar buffer = new T[length];\r\n```\r\nwith\r\n```c#\r\nvar buffer = ((sizeof(T) * length) switch\r\n    \u003c MaxStackallocLength) =\u003e stackalloc T[length],\r\n    \u003c MaxPooledLength) =\u003e  ArrayPool\u003cT\u003e.Shared.Rent(length),\r\n    _ =\u003e new T[length];\r\n```\r\nAgain we could have turned off this new behavior with a compiler directive.\r\n\r\nIn special cases, we can use compiler directives to tell the compiler the best values for MaxStackallocLength and MaxPooledLength.",
                                           "updatedAt":  "2021-04-30T14:58:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgzMDIyMTk0OA==",
                                           "createdAt":  "2021-04-30T16:45:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kkokosa",
                                           "body":  "I see again a new round of `stackalloc`, `ArrayPool`, \"sufficent stack\" discussion :) Just for a reference 👉 https://github.com/dotnet/runtime/issues/24963",
                                           "updatedAt":  "2021-04-30T16:46:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgzNzY1MTY2OQ==",
                                           "createdAt":  "2021-05-11T02:16:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBqUo4w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tannergooding",
                                                                               "createdAt":  "2021-05-11T02:46:08Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "JimBobSquarePants",
                                           "body":  "@tannergooding you weren’t misremembering, it was there but we’ve managed to incrementally remove all requirements as we optimised the code. The ArrayPool usage is gone now also. ",
                                           "updatedAt":  "2021-05-11T02:16:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc400RWl",
                                           "createdAt":  "2021-07-24T22:21:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Thealexbarney",
                                           "body":  "What about a general language feature that took inspiration from C macros and C# source generators that could expand a \"function call\" into something else? This way users would be able to write their own `StackallocOrCreateArray\u003cT\u003e` that\u0027s tailored to their specific case.\r\n\r\nLike the suggestion that the APIs be a specialized JIT intrinsic that operates in the frame of the caller, except more general. Maybe a function that could still only access arguments passed to it and its own variables which would still be scoped to itself, but could do things like stackalloc or return. It could be inlined into the caller by the C# or JIT compiler.\r\n\r\nThat idea is somewhat limited due to trying to be safer than straight text replacement, and I admit I don\u0027t know what other issues it might bring up.\r\n\r\nA more powerful feature might be able to turn something like\r\n```cs\r\nLog.Info($\"Some expensive expression: {ExpensiveFoo()}\");\r\n```\r\ninto\r\n```cs\r\nif (Log.InfoLogEnabled) {\r\n    Log.LogImpl(LogLevel.Info, $\"Some expensive expression: {ExpensiveFoo()}\");\r\n}\r\n```\r\n\r\nCurrently you\u0027d have to either move the check if logging\u0027s enabled into the caller, always build the string passed into the log function, or pass a lambda, all of which either have larger maintenance or performance costs to some degree.\r\n\r\nI don\u0027t know if either of these completely solve the `ArrayPool` case. It would at least need some work on the design. For example, a user could use a struct like the following and then add a `using var returner = new ArrayPoolReturner\u003cT\u003e();` before trying to do `stackalloc` or allocate the array, but that could easily cause problems when doing something like assigning the allocated `Span\u003cT\u003e` to a variable outside the scope where `StackallocOrCreateArray\u003cT\u003e` is called.\r\n\r\n```cs\r\nstruct ArrayPoolReturner\u003cT\u003e : IDisposable {\r\n    private T[] _array;\r\n    \r\n    public void SetRentedArray(T[] array) { /* impl */ }\r\n    \r\n    public void Dispose()\r\n    {\r\n        if(_array != null)\r\n            ArrayPool\u003cT\u003e.Shared.Return(_array);\r\n            \r\n        _array = null;\r\n    }\r\n}\r\n```",
                                           "updatedAt":  "2021-07-24T22:21:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc400UzH",
                                           "createdAt":  "2021-07-25T01:18:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBzxIkQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "PathogenDavid",
                                                                               "createdAt":  "2021-07-25T08:18:31Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Joe4evr",
                                                                               "createdAt":  "2021-07-25T20:00:08Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "acaly",
                                           "body":  "@Thealexbarney There is a planned interpolated string improvement that solves your logger scenario: https://github.com/dotnet/csharplang/blob/f4d1c13a6a2ffd09b2e46b0bed57f2629640e440/proposals/improved-interpolated-strings.md.",
                                           "updatedAt":  "2021-07-25T01:23:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4000SN",
                                           "createdAt":  "2021-07-25T21:35:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Thealexbarney",
                                           "body":  "\u003e @Thealexbarney There is a planned interpolated string improvement that solves your logger scenario\r\n\r\nAh, I wasn\u0027t aware of that part of the new interpolated string APIs. Although the logging example was meant as more of a scenario that most people would be familiar with rather than the only reason for bringing up the idea.",
                                           "updatedAt":  "2021-07-25T21:35:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42h9qa",
                                           "createdAt":  "2021-09-08T03:10:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AraHaan",
                                           "body":  "\u003e ## Background and Motivation\r\n\u003e \r\n\u003e It is not uncommon, in performance oriented code, to want to `stackalloc` for small/short-lived collections. However, the exact size is not always well known in which case you want to fallback to creating an array instead.\r\n\u003e ## Proposed API\r\n\u003e \r\n\u003e ```cs\r\n\u003e namespace System.Runtime.CompilerServices\r\n\u003e {\r\n\u003e     public static unsafe partial class Unsafe\r\n\u003e     {\r\n\u003e         public static Span\u003cT\u003e Stackalloc\u003cT\u003e(int length);\r\n\u003e         public static Span\u003cT\u003e StackallocOrCreateArray\u003cT\u003e(int length);\r\n\u003e         public static Span\u003cT\u003e StackallocOrCreateArray\u003cT\u003e(int length, int maxStackallocLength);\r\n\u003e     }\r\n\u003e }\r\n\u003e ```\r\n\u003e \r\n\u003e These APIs would be `intrinsic` to the JIT and would effectively be implemented as the following, except specially inlined into the function so the `localloc` scope is that of the calling method:\r\n\u003e \r\n\u003e ```cs\r\n\u003e public static Span\u003cT\u003e StackallocOrCreateArray\u003cT\u003e(int length, int maxStackallocLength)\r\n\u003e {\r\n\u003e     return ((sizeof(T) * length) \u003c maxStackallocLength) ? stackalloc T[length] : new T[length];\r\n\u003e }\r\n\u003e ```\r\n\u003e \r\n\u003e The variant that doesn\u0027t take `maxStackallocLength` would use some implementation defined default. Windows currently uses `1024`.\r\n\u003e \r\n\u003e Any `T` would be allowed and the JIT would simply do `new T[length]` for any types that cannot be stack allocated (reference types).\r\n\r\nHow would the stackalloced buffer remain valid after that function returns? I thought about this and I think the way stackalloc works today is that it lives only until the function returns, then it is freed (GC\u0027d).\r\n\r\nAlso if it does work, what about ref types, that later needs resized? a prime example is my open Pull request in dotnet/winforms that is a bit tricky because I either have to: A: rent a 32k buffer all at once and stack overflow the thing with a super large stack allocation, or B: Use ArrayPool (also something that can fail the tests in that repository), or C: Some way to allocate a clean buffer using something like this, but later be able to ``realloca`` that stuff using stackalloc for the ref type (or create an array).",
                                           "updatedAt":  "2021-09-08T03:10:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42iCOt",
                                           "createdAt":  "2021-09-08T03:58:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOB5bNag==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "Joe4evr",
                                                                               "createdAt":  "2021-09-08T06:02:31Z"
                                                                           },
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "AraHaan",
                                                                               "createdAt":  "2021-09-08T06:23:14Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "\u003e How would the stackalloced buffer remain valid after that function returns? I thought about this and I think the way stackalloc works today is that it lives only until the function returns, then it is freed (GC\u0027d).\r\n\r\nI think this is in the text you\u0027re quoting: \"These APIs would be intrinsic to the JIT and would effectively be implemented as the following, except specially inlined into the function so the localloc scope is that of the calling method:\"",
                                           "updatedAt":  "2021-09-08T03:58:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Vu66K",
                                           "createdAt":  "2023-02-21T12:03:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Xyncgas",
                                           "body":  "When parsing compressed stream, I find myself decompressing the stream and then parsing the result, the decompression is local to the function and not exposed to the user therefore instead of asking user to pass in a buffer I would much rather creating a buffer in stack to put the compressed bytes before decompressing them and transforming them and the size is small (a couple bytes)\r\n\r\nWhich is hard to do in F#\r\n\r\nand the guys from F# seems to favor this instead of giving me a function that does stackalloac and returns a span\r\n\r\nalso while we are at it, would be nice to have value type equivalent of, MemoryStream and BinarySerializer for me to use together with stack allocated buffer\r\n\r\nAlthough without these I can still use other hacks to decompress the bytes to stack buffer without MemoryStream or BinaryWriter/BinaryReader",
                                           "updatedAt":  "2023-02-21T12:26:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5obCds",
                                           "createdAt":  "2023-10-08T04:39:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD1_Ozw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "TimothyMakkison",
                                                                               "createdAt":  "2024-08-20T22:26:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-10-14T12:49:46Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "timcassell",
                                           "body":  "\u003e Any `T` would be allowed and the JIT would simply do `new T[length]` for any types that cannot be stack allocated (reference types).\r\n\r\nWhy can\u0027t stackalloc reference types be supported? I get that the GC doesn\u0027t track it, but why can\u0027t it?",
                                           "updatedAt":  "2023-10-08T04:39:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5obfFJ",
                                           "createdAt":  "2023-10-08T14:00:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "weltkante",
                                           "body":  "\u003e Why can\u0027t stackalloc reference types be supported?\r\n\r\nBecause the contract of a reference to a reference type is that anyone can take and keep such a reference for later, something allocated on a stack won\u0027t be able to hold that contract. You\u0027d need to come up with a new contract to support what you\u0027re asking for, or allow breaking the memory safety of .NET",
                                           "updatedAt":  "2023-10-08T14:00:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5obfid",
                                           "createdAt":  "2023-10-08T14:08:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "\u003e \u003e Why can\u0027t stackalloc reference types be supported?\r\n\u003e \r\n\u003e Because the contract of a reference to a reference type is that anyone can take and keep such a reference for later, something allocated on a stack won\u0027t be able to hold that contract. You\u0027d need to come up with a new contract to support what you\u0027re asking for, or allow breaking the memory safety of .NET\r\n\r\nI\u0027m talking about `stackalloc object[length]`, not `stackalloc object()`.",
                                           "updatedAt":  "2023-10-08T14:08:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5obfsv",
                                           "createdAt":  "2023-10-08T14:11:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ayende",
                                           "body":  "Consider this code:\r\n\r\n```\r\n// Assume [SkipLocalInit]\r\nvar items = stackalloc string[2];\r\nitems[0] = new string(\u0027a\u0027, 255);\r\nGC.Collect();\r\nConsole.WriteLine(items[0]);\r\n```\r\n\r\nThe problem is likely that you now need to scan the stack itself for those roots as well.\r\nAnd there is also an issue with the _second_ value there, which may be garbage because of the `SkipLocalInit`, leaving aside the fact that raw buffers like that are problematic, since they are often used in.... interesting ways.",
                                           "updatedAt":  "2023-10-08T14:11:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5obgMz",
                                           "createdAt":  "2023-10-08T14:21:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "\u003e The problem is likely that you now need to scan the stack itself for those roots as well.\r\n\r\nWhat\u0027s the problem with that? Afaik, the GC already scans the stack for references.\r\n\r\n\u003e And there is also an issue with the _second_ value there, which may be garbage because of the `SkipLocalInit`.\r\n\r\nThere\u0027s an easy solution to that: the runtime enforces zero-initializing managed types, ignoring `SkipLocalsInit`. I think it already does that with managed locals anyway.",
                                           "updatedAt":  "2023-10-08T14:21:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EDRtM",
                                           "createdAt":  "2024-07-08T22:23:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODvK-xA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "TimothyMakkison",
                                                                               "createdAt":  "2024-08-21T22:32:11Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "PatVax",
                                           "body":  "\u003e Consider this code:\r\n\u003e \r\n\u003e ```\r\n\u003e // Assume [SkipLocalInit]\r\n\u003e var items = stackalloc string[2];\r\n\u003e items[0] = new string(\u0027a\u0027, 255);\r\n\u003e GC.Collect();\r\n\u003e Console.WriteLine(items[0]);\r\n\u003e ```\r\n\u003e \r\n\u003e The problem is likely that you now need to scan the stack itself for those roots as well. And there is also an issue with the _second_ value there, which may be garbage because of the `SkipLocalInit`, leaving aside the fact that raw buffers like that are problematic, since they are often used in.... interesting ways.\r\n\r\nThis code already works:\r\n```csharp\r\nBuffer b = new();\r\nConsole.WriteLine(b[0] is null);\r\nConsole.WriteLine(b[1] is null);\r\nConsole.WriteLine(b[2] is null);\r\n\r\nb[0] = new string(\"Test\");\r\n\r\nConsole.WriteLine(b[0]);\r\n\r\nGC.Collect(2, GCCollectionMode.Default, true);\r\nGC.WaitForPendingFinalizers();\r\n\r\nConsole.WriteLine(b[0]);\r\n\r\n[InlineArray(3)]\r\nstruct Buffer\r\n{\r\n    private string? _element;\r\n}\r\n```\r\n\r\nWhy wouldn\u0027t it work with shorter syntax like `stackalloc string[3]` or `Unsafe.Stackalloc\u003cstring\u003e(3)`?",
                                           "updatedAt":  "2024-07-08T22:23:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EIH9Z",
                                           "createdAt":  "2024-07-09T06:46:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ayende",
                                           "body":  "You are missing the `[SkipLocalInit]` scenario. In that case, there may be garbage there. ",
                                           "updatedAt":  "2024-07-09T06:46:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EI_4Z",
                                           "createdAt":  "2024-07-09T08:34:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "PatVax",
                                           "body":  "Given my understanding of `[SkipLocalsInit]` is correct:\r\n\r\n```csharp\r\nRun();\r\nRun();\r\n\r\n[SkipLocalsInit]\r\nvoid Run()\r\n{\r\n    Buffer b = new();\r\n    Console.WriteLine(b[0] is null);\r\n    Console.WriteLine(b[1] is null);\r\n    Console.WriteLine(b[2] is null);\r\n\r\n    b[0] = new string(\"Test\");\r\n\r\n    Console.WriteLine(b[0]);\r\n\r\n    GC.Collect(2, GCCollectionMode.Default, true);\r\n    GC.WaitForPendingFinalizers();\r\n\r\n    Console.WriteLine(b[0]);\r\n}\r\n\r\n[InlineArray(3)]\r\nstruct Buffer\r\n{\r\n    private string? _element;\r\n}\r\n```\r\n\r\nStill gives correct Output. Even though at the second call `b[0]` should definitely be not null after the first call.",
                                           "updatedAt":  "2024-07-09T08:34:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EKHAY",
                                           "createdAt":  "2024-07-09T10:12:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "weltkante",
                                           "body":  "\u003e Given my understanding of [SkipLocalsInit] is correct:\r\n\r\nYou declared it but aren\u0027t using it, calling the constructor initializes, stackalloc doesn\u0027t. You\u0027d want to try `Unsafe.SkipInit` in addition to the attribute to create the variable, not call the constructor (though I don\u0027t know if it\u0027d even let you do that, it would be a recipe to generate corrupt memory, treating garbage memory as a valid reference, causing access violations or memory corruption if you try to dereference them)",
                                           "updatedAt":  "2024-07-09T10:15:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ENZIc",
                                           "createdAt":  "2024-07-09T16:08:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD1_T_w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "BlinD-HuNTeR",
                                                                               "createdAt":  "2024-10-14T12:44:19Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-10-14T12:49:57Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "0xfeeddeadbeef",
                                                                               "createdAt":  "2024-10-14T12:58:53Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "`[SkipLocalsInit]` and `Unsafe.SkipInit` are ignored for `reference type` fields/locals. It is a strict requirement that these always be `null` or valid if they point into the GC heap (which couldn\u0027t be guaranteed for arbitrary memory).",
                                           "updatedAt":  "2024-07-09T16:08:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Pt2U-",
                                           "createdAt":  "2024-10-14T12:57:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "colejohnson66",
                                           "body":  "\u003e \u003e Any `T` would be allowed and the JIT would simply do `new T[length]` for any types that cannot be stack allocated (reference types).\n\u003e \n\u003e Why can\u0027t stackalloc reference types be supported? I get that the GC doesn\u0027t track it, but why can\u0027t it?\n\nEven more curious is why `[InlineArray]` support was added, but stackalloc was never revisited:\n\nhttps://sharplab.io/#v2:C4LgTgrgdgPgAgJgIwFgBQcAMACOSB0AStMAJYC2ApvgMID25ADqQDaVgDK7AbqQMaUAzgG506OAGZcCbDRYBDQYPQBvdNg3SE6zWrSaD2DsHl8A1gEEWLOn3nBKAEwAqAC1JQA5gB48mAHzY8tgAvNiOlABm8hAswKL6hhryANqE8lCODPgcrvJgTvgAcpQAHsAAFAAsCACUALqh2ABEDoLAzQlJGgCqgpRuHp4V8rVdmgC+YokajGCk3PaUuEgAbNjQgvKRy3BV2H0D7l4VHIwZvkgB2ILnULU6GnrdKwCcFbcZ+AAylF7ArjGj0MkToYGwFQ8wGwpCamGEMOw3hudx+f08AIRpAA1NiHjNDM8Xpo8O8ACTNFIqUgAGgQE0aYRUFSgEChtR6UC2O3wFkEAAU6FD2BUCpEURkUqR6rUQKUABwTJoqT5QKWNAD8GpaLNiLFqzQmzSBBIMUwJ5uBKQAklAWB5KBYwGB5ABPap1erAyQ3YCQPjQ4ymSzWWxLFzHHzOfzAgwAd1c7GWzmwIGkwKJSTmCyW2BTAH1KGwqFBgPDgeaJkA\n\n```csharp\nusing System;\nusing System.Runtime.CompilerServices;\n\npublic class Class\n{\n    public static void Main()\n    {\n        StackAllocatedThing\u003cstring\u003e a = default;\n        a[Random.Shared.Next(42)] = \"test\";\n        UseThing(a);\n    }\n\n    private static unsafe void UseThing(Span\u003cstring\u003e span)\n    {\n        Console.WriteLine(span.Length);\n        for (int i = 0; i \u003c span.Length; i++)\n        {\n            Console.WriteLine($\"[{i,2}] = {(nuint)Unsafe.AsPointer(ref span[i]):x8} = {span[i] ?? \"(null)\"}\");\n        }\n    }\n\n    [InlineArray(42)]\n    public struct StackAllocatedThing\u003cT\u003e\n        where T : class\n    {\n        private T _element0;\n    }\n}\n```\n\nIdeally, `StackAllocatedThing\u003cstring\u003e a = default` could just be `Span\u003cstring\u003e a = stackalloc string[42]`, but we can\u0027t.",
                                           "updatedAt":  "2024-10-14T12:57:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6PuYVt",
                                           "createdAt":  "2024-10-14T13:37:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jaredpar",
                                           "body":  "\u003e Even more curious is why [InlineArray] support was added,\n\nThe inability to use fixed sized buffers of types other than core primitives was a significant blocker for low level scenarios. It\u0027s a restriction that goes back to C# 1.0 and a sore point since then. This hit a tipping point a few releases ago, the C# and runtime team collaborated to solve that problem and `[InlineArray]` was the result. \n\n\u003e Ideally, StackAllocatedThing\u003cstring\u003e a = default could just be Span\u003cstring\u003e a = stackalloc string[42], but we can\u0027t.\n\nThat is a reasonable language suggestion. Essentially, create a language feature `stackallloc \u003ctype\u003e[\u003ccount\u003e]` that under the hood is backed by a `[InlineArray]`. It\u0027s been suggested a couple of times. The reason it hasn\u0027t happened is there just hasn\u0027t been enough of a need to have us take it on (nor is there a full proposal for this). \n\n",
                                           "updatedAt":  "2024-10-14T13:37:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6PvCyn",
                                           "createdAt":  "2024-10-14T14:45:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "colejohnson66",
                                           "body":  "Except a language-level translation won\u0027t suffice because stackallocs don\u0027t always have a compile-time size. `stackalloc T[count]` is a common thing. Why can\u0027t the runtime just remove that restriction?",
                                           "updatedAt":  "2024-10-14T14:45:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6PvVbA",
                                           "createdAt":  "2024-10-14T15:09:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD2BKuA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "0xfeeddeadbeef",
                                                                               "createdAt":  "2024-10-14T15:13:37Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "weltkante",
                                                                               "createdAt":  "2024-10-14T15:18:52Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jaredpar",
                                                                               "createdAt":  "2024-10-14T16:10:40Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e stackalloc T[count] is a common thing\n\nIt\u0027s not *that* common, in part because it is very expensive and often slower than simply `new T[count]`. `stackalloc` *can* come with many additional considerations, needs stack overflow checks, more expensive zeroing, buffer overrun protection, and more things due to the potential security issues that occur.\n\nIt is then \"best practice\" to keep stack allocations small (all stackallocs for a single method should typically add up to not more than 1024 bytes) and to never make them \"dynamic\" in length (instead rounding up to the largest buffer size). \n\nThis guidance is true even in native code (C, C++, assembly, etc) and not following it can in some cases interfere with or break internal CPU optimizations (such as mirroring stack spills to the register file).",
                                           "updatedAt":  "2024-10-14T15:09:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6P0zPY",
                                           "createdAt":  "2024-10-15T06:13:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD2m1PA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-10-15T13:19:50Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Aniobodo",
                                                                               "createdAt":  "2024-10-16T19:06:02Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "Aniobodo",
                                           "body":  "\u003e It is then \"best practice\" to keep stack allocations small (all stackallocs for a single method should typically add up to not more than 1024 bytes) and to **_never_** make them \"dynamic\" in length (instead rounding up to the largest buffer size).\n\u003e \n\nDynamic length works well if you reliably know your data source.\n\n\n",
                                           "updatedAt":  "2024-10-15T06:13:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6P61Pe",
                                           "createdAt":  "2024-10-15T17:05:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "Dynamic lengths function as intended in many scenarios. However, they can lead to various issues including hurting performance and potentially opening yourself up to security problems (even if the data source is known).\n\nThere are multiple recommendations in this space that are effectively industry standard and they allow you to achieve the same overall thing without introducing the same risks. Those industry standards and recommendations should be considered alongside any API exposed here or future work done by the runtime to enable new scenarios.",
                                           "updatedAt":  "2024-10-15T17:05:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dIfgq",
                                           "createdAt":  "2025-02-05T09:52:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "The example from https://github.com/dotnet/runtime/pull/112178 adds a motivation to introduce the API 🙂 \n![Image](https://github.com/user-attachments/assets/b55db926-48eb-47da-b221-5560ceb201aa)",
                                           "updatedAt":  "2025-02-05T09:52:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dI8JD",
                                           "createdAt":  "2025-02-05T10:41:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEFW7HQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MitchRazga",
                                                                               "createdAt":  "2025-02-05T11:15:44Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hamarb123",
                                                                               "createdAt":  "2025-02-05T11:18:15Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "PaulusParssinen",
                                                                               "createdAt":  "2025-02-05T11:19:15Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2025-02-05T14:16:39Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "@jkotas how would we feel about the following shape (possibly with a better name than `StackallocOrRentedBuffer`):\n```csharp\nnamespace System.Runtime.CompilerServices\n{\n    public static unsafe partial class Unsafe\n    {\n        public static int DefaultStackallocThreshold { get; }\n\n        // TODO: Determine which compiler attributes or keywords need to be added for correct lifetime tracking.\n\n        [Intrinsic]\n        public static Span\u003cT\u003e StackallocOrCreateArray\u003cT\u003e(int length) =\u003e StackallocOrCreateArray(length, DefaultStackallocThreshold);\n\n        [Intrinsic]\n        public static Span\u003cT\u003e StackallocOrCreateArray\u003cT\u003e(int length, int maxStackallocLength) =\u003e new T[length];\n\n        [Intrinsic]\n        public static StackallocOrRentedBuffer\u003cT\u003e StackallocOrRentArray\u003cT\u003e(int length) =\u003e StackallocOrRentArray(length, DefaultStackallocThreshold);\n\n        [Intrinsic]\n        public static StackallocOrRentedBuffer\u003cT\u003e StackallocOrRentArray\u003cT\u003e(int length, int maxStackallocLength)\n        {\n            T[] rentedArray = ArrayPool\u003cT\u003e.Shared.Rent(length);\n            return new StackallocOrRentedBuffer(rentedArray.AsSpan(0, length), rentedArray);\n        }\n    }\n\n    public ref struct StackallocOrRentedBuffer\u003cT\u003e\n    {\n        private Span\u003cT\u003e _buffer;\n        private T[]? _rentedArray;\n\n        public StackallocOrRentedBuffer(Span\u003cT\u003e buffer, T[]? rentedArray = null)\n        {\n            _buffer = buffer;\n            _rentedArray = rentedArray;\n        }\n\n        public static implicit operator Span\u003cT\u003e(StackallocOrRentedBuffer value) =\u003e value._buffer;\n\n        public static implicit operator ReadOnlySpan\u003cT\u003e(StackallocOrRentedBuffer value) =\u003e value._buffer;\n\n        public void Dispose()\n        {\n            if (_rentedArray is not null)\n            {\n                ArrayPool\u003cT\u003e.Shared.Return(_rentedArray);\n                _rentedArray = null;\n            }\n        }\n    }\n}\n```\n\nThis:\n* covers the desire to allow for renting or for allocating a new array\n* gives a way to centrally manage a default threshold while also giving users control to customize it for special scenarios\n* allows users renting to utilize `using ...` such that a try/finally return of the rented buffer occurs -or- to call dispose themselves, without worrying about whether it was actually rented\n* has a safe managed implementation that never stackallocates, avoiding the issue of needing language support\n* can be handled intrinsically by the JIT, such that we logically emit the `(length \u003c= threshold) ? stackalloc[] : new T[]`\n\nThe biggest complexity here is getting the JIT to \"call\" `ArrayPool\u003cT\u003e.Shared.Rent` for the `StackallocOrRent` scenario. However, there are a few ways that can be handled.... For example, we could avoid the complexity by recognizing the call and effectively having the JIT transform it from `GT_CALL` into `(length \u003c= threshold) ? stackalloc[] : GT_CALL` and simply allowing the inliner to inline the actual `ArrayPool\u003cT\u003e.Shared.Rent` call itself, this should be relatively easy for the importer to do and wouldn\u0027t require more significant JIT/VM changes to support.",
                                           "updatedAt":  "2025-02-05T12:54:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dI9BG",
                                           "createdAt":  "2025-02-05T10:43:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEFVhmQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "PaulusParssinen",
                                                                               "createdAt":  "2025-02-05T11:19:44Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "Such a shape would simplify the example @EgorBo just shared down to:\n```csharp\nStackallocOrRentedBuffer powersOf1e9Buffer = Unsafe.StackallocOrRent\u003cuint\u003e(powersOf1e9BufferLength);\n\n// ...\n\npowersOf1e9Buffer.Dispose();\n```",
                                           "updatedAt":  "2025-02-05T10:43:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dJGuS",
                                           "createdAt":  "2025-02-05T11:00:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "Another benefit of such APIs would be that the Roslyn compiler could use them instead of us exposing `InlineArray2/3/4/5\u003cT\u003e`: https://github.com/dotnet/runtime/issues/111973\n\nAs the JIT could ensure that the GC tracking is correct for a stackallocated reference type `T` and thus avoid the need to expose concrete types for whatever is internal implementation detail of the code around `params Span\u003cT\u003e`",
                                           "updatedAt":  "2025-02-05T11:00:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dJY8E",
                                           "createdAt":  "2025-02-05T11:35:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "\u003e Such a shape would simplify the example [@EgorBo](https://github.com/EgorBo) just shared down to:\n\u003e \n\u003e StackallocOrRentedBuffer powersOf1e9Buffer = Unsafe.StackallocOrRent\u003cuint\u003e(powersOf1e9BufferLength);\n\u003e \n\u003e // ...\n\u003e \n\u003e powersOf1e9Buffer.Dispose();\n\nNon-critical dispose would additionally allow it to be simplified down to this :)\n\n```csharp\nusing StackallocOrRentedBuffer\u003cuint\u003e powersOf1e9Buffer = Unsafe.StackallocOrRent\u003cuint\u003e(powersOf1e9BufferLength);\n```\n\nI generally agree with the idea that they shouldn\u0027t be returned in the case of an exception (as you might have it stored somewhere - although with this API design, you could write the lifetimes such that it\u0027s not possible I think, it may already be that way, but I haven\u0027t checked for sure), and there\u0027s the benefit wrt no try/finally for what most developers are likely to type (the `using`) if we\u0027re being honest.\n\nNote: this is just a nice-to-have for the most part imo, as opposed to something that I think should block this proposal.\n\n\u003e ArrayPool\u003cT\u003e.Shared.Return(_rentedArray);\n\nAre we sure we don\u0027t want to clear ever? I think at least an overload of dispose with clear as an option would be good, and perhaps the default should be true for managed types also. (e.g., with the current design as written, you might store a reference into it, have an exception thrown before you got around to clearing it, return the array without clearing it in the finally, and then potentially leak the reference as a result)\n\n\u003e Another benefit of such APIs would be that the Roslyn compiler could use them instead of us exposing `InlineArray2/3/4/5\u003cT\u003e`: [#111973](https://github.com/dotnet/runtime/issues/111973)\n\u003e \n\u003e As the JIT could ensure that the GC tracking is correct for a stackallocated reference type `T` and thus avoid the need to expose concrete types for whatever is internal implementation detail of the code around `params Span\u003cT\u003e`\n\nI don\u0027t agree with this usage personally, for 2 reasons: 1. (the trivially solveable one) if we do this, we should also expose an `Unsafe.Stackalloc\u003cT\u003e` imo; 2. my understanding is that there\u0027s benefits over using a proper normal local over dynamically stack-allocated memory, so unless the suggestion is for the roslyn to just pre-emptively stackalloc \u0026 store in local in advance for the whole duration of the method (which has its own issues, as this introduces hidden allocations or cost for using the pool when you didn\u0027t want/need it), then my understanding is that it would potentially regress some scenarios.\n\nIf we were to do something like this, imo it should be reserved for only high item count / total size scenarios, or dynamic scenarios (which would be questionable to do implicitly regardless).\n\nBeyond those comments, I personally think the proposal is good :)",
                                           "updatedAt":  "2025-02-05T11:47:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dJc0x",
                                           "createdAt":  "2025-02-05T11:43:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "I like the proposed API shape just to simplify what we already have. The question is - can we make it safer? Can it avoid using the thread pool under the hood if it sees that the pooled array escapes outside of the scope (using inter-procedure analysis)? Or at least help developers diagnose issues where it does",
                                           "updatedAt":  "2025-02-05T11:44:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dJnc3",
                                           "createdAt":  "2025-02-05T12:04:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e Are we sure we don\u0027t want to clear ever? I think at least an overload of dispose with clear as an option would be good, and perhaps the default should be true for managed types also. (e.g., with the current design as written, you might store a reference into it, have an exception thrown before you got around to clearing it, return the array without clearing it in the finally, and then potentially leak the reference as a result)\n\nClearing would require tracking extra state. It could be an option, but its also not something the BCL normally does and it\u0027s not the default for `ArrayPool\u003cT\u003e`\n\nIf you need to clear, its not difficult to do `buffer.Clear()` or similar (same as you might opt to do on allocation). But, we also aren\u0027t blocked from adding such an overload in the future if enough requests happen.\n\n\u003e If we were to do something like this, imo it should be reserved for only high item count / total size scenarios, or dynamic scenarios (which would be questionable to do implicitly regardless).\n\nThe JIT can optimize constant sizes to not emit the fallback path, because it statically knows its under the threshold. This makes it zero cost for anything that isn\u0027t dynamic. If it is dynamic, then you want the branch to avoid the potential dangers of stackoverflow.\n\nThus, there is no need for just a `Unsafe.Stackalloc\u003cT\u003e`, you can either use `stackalloc` because its \"safe\" for unknown lengths of unmanaged types, or you use the `StackallocOr*` API with reference types, because its not safe for dynamic lengths.",
                                           "updatedAt":  "2025-02-05T12:04:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dJ35F",
                                           "createdAt":  "2025-02-05T12:31:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "\u003e \u003e Are we sure we don\u0027t want to clear ever? I think at least an overload of dispose with clear as an option would be good, and perhaps the default should be true for managed types also. (e.g., with the current design as written, you might store a reference into it, have an exception thrown before you got around to clearing it, return the array without clearing it in the finally, and then potentially leak the reference as a result)\n\u003e \n\u003e Clearing would require tracking extra state. It could be an option, but its also not something the BCL normally does and it\u0027s not the default for `ArrayPool\u003cT\u003e`\n\u003e \n\u003e If you need to clear, its not difficult to do `buffer.Clear()` or similar (same as you might opt to do on allocation). But, we also aren\u0027t blocked from adding such an overload in the future if enough requests happen.\n\nIt could simply pass `RuntimeHelpers.IsReferenceOrContainsReferences\u003cT\u003e()` by default (this doesn\u0027t require extra state) (this is what I meant by `and perhaps the default should be true for managed types also` 😁), and have an overload of Dispose (or something named similar if we don\u0027t want to confuse people by making it the same sig as the `Dispose(bool disposing)` pattern) that allows the user to specify if they wanted different behaviour.\n\n\u003e The JIT can optimize constant sizes to not emit the fallback path, because it statically knows its under the threshold. This makes it zero cost for anything that isn\u0027t dynamic. If it is dynamic, then you want the branch to avoid the potential dangers of stackoverflow.\n\u003e \n\u003e Thus, there is no need for just a `Unsafe.Stackalloc\u003cT\u003e`, you can either use `stackalloc` because its \"safe\" for unknown lengths of unmanaged types, or you use the `StackallocOr*` API with reference types, because its not safe for dynamic lengths.\n\nAnd this doesn\u0027t run into issues with causing pessimisation over the exiting solution in other dynamic scenarios, like calling a function with `params ROS\u003cobject/T\u003e` in a loop or in a branch (or both)? My understanding was that this is part of the reason (but not the whole reason, obviously) that we added `InlineArray` in the first place, as opposed to just having an api to stackalloc any type that the c# compiler could call. If so, then that sounds fine :)",
                                           "updatedAt":  "2025-02-05T12:34:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dKMvy",
                                           "createdAt":  "2025-02-05T12:42:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEFW7xw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hamarb123",
                                                                               "createdAt":  "2025-02-05T12:44:42Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2025-02-05T14:17:45Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e And this doesn\u0027t run into issues with causing pessimisation over the exiting solution in other dynamic scenarios, ...?\n\nIt should not. For static lengths and/or for the intrinsic API in particular there should be nothing preventing us from hoisting such a case since we know the scoping of it due to the lifetime. There\u0027s also nothing preventing Roslyn from doing said hoisting itself since it would already be something implicitly done behind the scenes.\n\nThere\u0027s tradeoffs, its just a suggestion for how this could also benefit that scenario.\n\n\u003e It could simply pass RuntimeHelpers.IsReferenceOrContainsReferences\u003cT\u003e() by default (this doesn\u0027t require extra state) \n\nYes, but its tradeoffs and largely irrelevant to the basic shape getting a nod of approval so we can finally take it to API review. We can discuss additional concepts like clearing in API review and decide if a third overload or parameter is warranted.",
                                           "updatedAt":  "2025-02-05T12:42:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dMggm",
                                           "createdAt":  "2025-02-05T15:48:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEFgq6Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "aromaa",
                                                                               "createdAt":  "2025-02-05T15:56:42Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "0xfeeddeadbeef",
                                                                               "createdAt":  "2025-02-05T23:42:43Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2025-02-06T14:44:19Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e @jkotas how would we feel about the following shape\n\nIt is still an unsafe API with similar problems as ValueStringBuilder. I think we should be shooting for a construct that makes it impossible to introduce a memory safety bug.",
                                           "updatedAt":  "2025-02-05T15:48:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dNlqp",
                                           "createdAt":  "2025-02-05T17:33:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MitchRazga",
                                           "body":  "\u003e It is still an unsafe API with similar problems as ValueStringBuilder. I think we should be shooting for a construct that makes it impossible to introduce a memory safety bug.\n\nPerhaps something along the lines of [ref struct destructor](https://github.com/dotnet/csharplang/discussions/1110)?",
                                           "updatedAt":  "2025-02-05T17:33:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dN7uT",
                                           "createdAt":  "2025-02-05T18:12:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e It is still an unsafe API with similar problems as ValueStringBuilder. I think we should be shooting for a construct that makes it impossible to introduce a memory safety bug.\n\n@jkotas could you elaborate a bit on what you\u0027d be expecting the long term solution to be, possible with some pseudo-code?\n\nNotably I don\u0027t see the potential issue with `StackallocOrCreateArray\u003cT\u003e()`. That is we only need provide an analyzer encouraging users to do `scoped Span\u003cT\u003e buffer = Unsafe.StackallocOrCreateArray\u003cT\u003e(...)` themselves. Because we know it stackallocs or creates an array, there is no need for a disposal pattern and the `scoped` keeps it from escaping. A language feature that allows us to declare the signature as `scoped Span\u003cT\u003e StackallocOrCreateArray\u003cT\u003e(int length)` would be even better and make this implicit, but it isn\u0027t \"required\". So this API seems completely safe to expose and doesn\u0027t necessarily have to be on the `Unsafe` class, its rather just a power API and this is a convenient place for it.\n\nWith the `StackallocOrRentedBuffer` you do have the issue of:\n```csharp\nscoped StackallocOrRentedBuffer\u003cT\u003e buffer = Unsafe.StackallocOrRentArray\u003cT\u003e(...);\nscoped Span\u003cT\u003e span = buffer;\n\nbuffer.Dispose();\nspan[0] = ...; // mutating a buffer that\u0027s been returned to the array pool\n```\n\nThis issue exists because of how `Dispose` works on structs in general and there isn\u0027t really a \"safe\" option for it without the language exposing a much more expensive language feature around ownership/lifetimes and `move only` semantics (you need to ensure prior instances become dead on copy and need to ensure that it understand `Dispose` \"ends\" the scope early so any derived buffers also end at that point in time).\n\nWhile this danger does exist on the latter, the same danger notably already exists in the paths that would use it just hidden around much more convoluted API surface. So it seems like exposing such an API is still improving safety and would be worth it for power users given the other feature may still be years out.\n\nShort of a language feature, I could see the signature being `Span\u003cT\u003e StackallocOrRentArray\u003cT\u003e(int length)` to avoid this issue (with the same note about an analyzer and requiring the asignee involve `scoped`), but it would require the JIT to internally emit a `T[]` local and cleanup for such values in the function epilogue. This seems doable, just a bit more expensive to achieve.",
                                           "updatedAt":  "2025-02-05T18:12:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dPUl3",
                                           "createdAt":  "2025-02-05T21:16:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEFwHig==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tannergooding",
                                                                               "createdAt":  "2025-02-05T21:53:16Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "omariom",
                                                                               "createdAt":  "2025-02-06T14:13:52Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2025-02-06T14:44:00Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jnm2",
                                                                               "createdAt":  "2025-02-09T18:19:40Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "jaredpar",
                                           "body":  "\u003e That is we only need provide an analyzer encouraging users to do scoped Span\u003cT\u003e buffer = Unsafe.StackallocOrCreateArray\u003cT\u003e(...) themselves.\n\nRather than an analyzer I think we\u0027d want to encode this into the compiler. This has come up a few times in the past. Essentially how can the runtime mark an API that is `ref struct` returning as \"cannot escape calling method\"? Once that is in place APIs like this could be tagged with the attribute and it would just fall into our existing `ref` safety logic. Don\u0027t even need an explicit `scoped` cause compiler will infer the lifetime correctly to be `scoped`. It\u0027s a fairly low cost item for the compiler, just never had the runtime motivation to go through with it.\n\n\u003e Short of a language feature, ... \n\nI\u0027m _somewhat_ warry of taking this entire idea and encoding it as a language feature. Basically I\u0027m hesitant about having `Span\u003cbyte\u003e b = malloc(...)`. That is putting too much logic into the compiler that feels like it should really be in the runtime. I\u0027m definitely supportive though of ideas like I mentioned above where we can help give you the tools to enforce APIs like this. \n\n",
                                           "updatedAt":  "2025-02-05T21:16:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dPiRi",
                                           "createdAt":  "2025-02-05T21:48:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rickbrew",
                                           "body":  "Yeah I\u0027d love to have something like this but it would probably need even more compiler support\n\n```cs\nusing StackAllocOrCustomAllocBuffer\u003cT\u003e buffer = Unsafe.StackAllocOrCustomAlloc\u003cT\u003e(length, static len =\u003e MyCustomWin32HeapAllocator(len));\n```",
                                           "updatedAt":  "2025-02-05T21:48:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dQIYa",
                                           "createdAt":  "2025-02-05T23:18:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "I presume the perfect solution is something like this:\n```cs\nbyte[] buffer = Buffer.AllocateTempBuffer(len);\n```\nand the JIT/C# either uses `stackalloc` (if it\u0027s not inside a loop, size is not too big), `ArrayPool` (if it can guarantee that the buffer never escapes the current scope and the Return is correctly placed - this is tricky as most likely it requires an inter-procedure analysis) or heap alloc otherwise.\n\nMaybe even just `byte[] buffer = new byte[len];` Although, in this case it might be tricky/against the spec to use ArrayPool internally.\n\nMeanwhile Tanner\u0027s impl looks good as an internal helper to replace all ugly code we have in BCL IMO.",
                                           "updatedAt":  "2025-02-05T23:18:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dQJbV",
                                           "createdAt":  "2025-02-05T23:20:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEFbNpg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "EgorBo",
                                                                               "createdAt":  "2025-02-05T23:33:51Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jaredpar",
                                           "body":  "\u003e byte[] buffer = Buffer.AllocateTempBuffer(len);\n\nIf the issue is around determining escape, why a `byte[]` vs. a `Span\u003cbyte\u003e`? The latter with compiler help should be much easier to guarantee about escape. ",
                                           "updatedAt":  "2025-02-05T23:20:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dQOho",
                                           "createdAt":  "2025-02-05T23:38:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "\u003e \u003e byte[] buffer = Buffer.AllocateTempBuffer(len);\n\u003e \n\u003e If the issue is around determining escape, why a `byte[]` vs. a `Span\u003cbyte\u003e`? The latter with compiler help should be much easier to guarantee about escape.\n\nGood point. Although, say I have:\n```cs\nvoid Test(bool cond)\n{\n    char tmp = \u0027x\u0027;\n    ref char c = ref tmp;\n    if (cond)\n    {\n        Span\u003cchar\u003e span = Buffer.AllocateTempBuffer(100000);\n        c = ref span[0];  // escapes the current scope?\n        // ArrayPoo.Return is no longer legal here?\n    }\n    c = \u0027x\u0027; // out of scope\n}\n```",
                                           "updatedAt":  "2025-02-05T23:38:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dQSjo",
                                           "createdAt":  "2025-02-05T23:51:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEFgqNA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "h3xds1nz",
                                                                               "createdAt":  "2025-02-05T23:55:14Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "quixoticaxis",
                                                                               "createdAt":  "2025-02-06T00:53:02Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "timcassell",
                                                                               "createdAt":  "2025-02-06T01:05:33Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2025-02-06T14:42:53Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e I presume the perfect solution is something like this:\n\nAt the end of the day, there\u0027s a balance between fine tuning perf by hand and relying on implicit optimizations. Within implicit optimizations there is then a further balance between things that can be statically relied on and things which require heuristics.\n\nFor things we can statically guarantee, I think it\u0027s completely acceptable to rely on the implicit optimizations. This is especially true for things like standard for loops allowing bounds check elimination as the code stays idiomatic, safe, and achieves the desired performance. I likewise imagine there are some scenarios where the JIT can better understand lifetimes by knowing things are ref structs and similar and so there are some viable optimizations that can be done here statically.\n\nHowever, for things that rely on heuristics like deciding whether a `T[]` can be stack allocated based on escape analysis, I don\u0027t think this is a viable solution for users writing perf-critical code and is instead simply a \"nice to have\" for all other regular non perf critical code. That is, things like `BigInteger` or other framework APIs are intentionally choosing to stackalloc within a given threshold and the places this buffer is used are then often in context of complex code where it is passed through non-inlined or large callsites and so the escape analysis will fail. We could of course try and track additional metadata per method and build up a form of Whole Program Analysis as we get into Tier 1 or even some Tier 2, but this adds a lot of overhead and expense that I expect is unlikely to pay off. I expect its especially unlikely to pay off if we\u0027re already hand tuning known perf sensitive scenarios with the relevant helpers.\n\nThere\u0027s also the consideration that by trying to optimize all code to the extreme, we can actually reduce the performance of the whole application. The stack is intentionally small/limited, CPUs have hardware level features that assume call depth is smallish and that assume the number of stack slots used per call is relatively small. They have features like tracking the last 12-15 return addresses so that it is cheap to leave a method. They have features like mirroring stack spills to the larger internal register file to avoid the penalties with memory accesses or polluting L1 cache for something that is only ever going to be CPU local. If you start stack allocating or start renting from the pool implicitly for all cases of `new T[]`, then you actually risk reducing performance for the application and leaving nothing available for the bits of code that were hand tuned to utilize those features instead. -- For example, code that was expecting to rent from the pool for perf may find it drained because code that didn\u0027t actually benefit from using the pool went and got the available allocations first. It\u0027s all a balance and sometimes it will win and sometimes it won\u0027t, but the things that were explicitly tuned are the ones we actually care about being fast.\n\nSo at the end of the day, I don\u0027t think we\u0027re ever going to be getting rid of features like proposed here; they will always exist and always have a place for use. I think then the right thing is trying to ensure that when they are exposed we strike the right balance of ensuring they are safe, understandable, and helper users write more idiomatic looking code while still being explicit that they want a particular optimization to kick in.",
                                           "updatedAt":  "2025-02-05T23:51:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dQeMg",
                                           "createdAt":  "2025-02-06T00:32:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEFbgjQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tannergooding",
                                                                               "createdAt":  "2025-02-06T00:36:23Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "EgorBo",
                                                                               "createdAt":  "2025-02-06T00:44:16Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "jaredpar",
                                           "body":  "\u003e Good point. Although, say I have:\n\n```csharp\nvoid Test(bool cond)\n{\n    char tmp = \u0027x\u0027;\n    ref char c = ref tmp;\n    if (cond)\n    {\n        // With compiler integration this would be implicitly scoped. \n        Span\u003cchar\u003e span = Buffer.AllocateTempBuffer(100000);\n        \n        // This is now illegal because you\u0027re attempting to escape `span` to a broader\n        // scope\n        c = ref span[0];  // escapes the current scope?\n  \n    }\n    c = \u0027x\u0027; // never get here \n}\n```\n\nCan see the impact by making `span` explicitly `scoped` ([sharplab](https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA0AXEUCuA7NAExAGoAfAAQCYBGAWACgKAGAAgpoDoAZASzwCOAbkYt2XPoM4BRBAAdYAZ0W8IeRSIaMAKjEUYAFADMAhgBtFMAJSaKKVrv0HgECGdaQ8hK4wDejVkCPAAsTKFYMAFs5VgBeVgByBATNINZYIxCwjzj0mEyouVSg3kyDT28AoP8GNLSAenrWAHVeDGCPCGjeMxhw/gwYAHMoEwxVPAjg3kVWAHcIHDNCVmAYVl5os14wNrMAT1ZFSDkYQk5WKrqjk7PWAGU5EzwAHjBQqAA+I6fJ+IAhHBGIx9TgAQTMZggYDGMF00UBwL6BhozDRaJsVzqWIaTQAkpDhuZWHgIHMcUEwLkMj9ngBtZgAXSEgUarD0MNOs3a6zAOCgsDwGBuEFOAH4KaymmCBSZ9gAFVycABKMAw/MmMxJEFYULwQz6uqJ7mCfRgEtqQQAvliqfEkilWGzFsKIJljqKYIwbVomDQkOwqKxESCoH4sRQAMziAOPZ5vD7fCFQmGDeFyEPIgZHXgAL2scW+7SgZJJSzMAEJNFagA))\n\nNote: my assumption here is that `AllocateTempBuffer` would desire to have lifetime of _current scope_. If the intent is that it\u0027s always _current method_ then that is equally doable and the sample would start compiling. That does complicate a bit _when_ the free happens. But in terms of lifetime it\u0027s not much different to add both options if we decide to go this route. ",
                                           "updatedAt":  "2025-02-06T00:34:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dQftR",
                                           "createdAt":  "2025-02-06T00:38:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "\u003e Can see the impact by making span explicitly scoped\n\nThe question is - can you enforce it? Or the safety is going to be based on an analyzer that will suggest user to put `scoped` there? \n\nAh, the answer is here https://github.com/dotnet/runtime/issues/52065#issuecomment-2638039415",
                                           "updatedAt":  "2025-02-06T00:43:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dQk7Z",
                                           "createdAt":  "2025-02-06T00:58:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEFxgsw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "EgorBo",
                                                                               "createdAt":  "2025-02-06T01:07:19Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2025-02-06T14:42:39Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2025-02-10T02:01:01Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2025-02-10T04:23:54Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "jaredpar",
                                           "body":  "\u003e The question is - can you enforce it? Or the safety is going to be based on an analyzer that will suggest user to put scoped there?\n\n\u003e Ah, the answer is here https://github.com/dotnet/runtime/issues/52065#issuecomment-2638039415\n\nCorrect. My suggestion was the language provide a mechanism to let the runtime dictate that a `ref struct` returning method had a specific lifetime. Imagine for example there was an attribute that said `[LifetimeCurrentMethod]` or `[LifetimeCurrentScope]` that compiler would recognize as part of it\u0027s lifetime rules. \n\n```csharp\n\nSpan\u003cbyte\u003e Use1() =\u003e M1(); // Error: M1 is safe to escape to current method\nSpan\u003cbyte\u003e Use2() =\u003e M2(); // okay\n\n[LifetimeCurrentMethod]\nSpan\u003cbyte\u003e M1() =\u003e ...\nSpan\u003cbyte\u003e M2() =\u003e ...;\n```\n\nThe attributes would allow only to _restrict_ returned lifetimes, not increase them.",
                                           "updatedAt":  "2025-02-06T00:58:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dwlcv",
                                           "createdAt":  "2025-02-10T02:00:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEGD9WQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "0xfeeddeadbeef",
                                                                               "createdAt":  "2025-02-10T04:17:53Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2025-02-10T04:23:27Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "omariom",
                                                                               "createdAt":  "2025-02-10T16:05:17Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jaredpar",
                                                                               "createdAt":  "2025-02-11T04:48:48Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Sergio0694",
                                                                               "createdAt":  "2025-02-12T06:05:08Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  5
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e @jkotas could you elaborate a bit on what you\u0027d be expecting the long term solution to be, possible with some pseudo-code?\n\nThe discussion between Jared and Egor above is a good example of the kind of solutions we should be thinking about.\n\n\u003e it seems like exposing such an API is still improving safety and would be worth it for power users given the other feature may still be years out.\n\nReplacing unsafe APIs with a bit more safe unsafe APIs is not very appealing to me. We can do it occasionally if there is a strong motivation, but it won\u0027t get us to where we need to be. Memory safety is not like performance where the incremental approach works fine.\n\n\u003e feature may still be years out\n\nI expect that we will need to be prioritizing memory safety related features higher compared to where we were in the past. Message from our CEO: [Prioritizing security above all else](https://blogs.microsoft.com/blog/2024/05/03/prioritizing-security-above-all-else/).",
                                           "updatedAt":  "2025-02-10T02:00:52Z"
                                       }
                                   ],
                         "totalCount":  78
                     },
        "title":  "Expose a `malloca` API that either stackallocs or creates an array.",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/53622",
        "createdAt":  "2021-06-02T18:16:40Z",
        "number":  53622,
        "author":  "gfoidl",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-07-13T06:04:05Z",
        "body":  "In \r\nhttps://github.com/dotnet/runtime/blob/dbb05eba3b229df3d4c15ce08de9f84c7febb7b3/src/libraries/System.Private.CoreLib/src/System/MemoryExtensions.cs#L135-L154\r\n`ExceptionArgument.start` is used, but `length` may be the faulty argument.\r\n\r\nhttps://github.com/dotnet/runtime/blob/dbb05eba3b229df3d4c15ce08de9f84c7febb7b3/src/libraries/System.Private.CoreLib/src/System/ReadOnlySpan.cs#L350-L362\r\nonly throws `ArgumentOutOfRangeException` without specifying the paramname.\r\n{RO}S ctor does it the same way.\r\n\r\nSimilar for `AsMemory(this string? text, int start, int length);`.\r\n\r\nShould the behavior of MemoryExtensions.AsSpan/AsMemory be aligned to the one of Slice?\r\n\r\nFor reference see also https://github.com/dotnet/runtime/pull/53463#discussion_r642749460",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOM61mww==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1MzI3NjEyMg==",
                                           "createdAt":  "2021-06-02T18:16:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @GrabYourPitchForks, @carlossanlop\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nIn \r\nhttps://github.com/dotnet/runtime/blob/dbb05eba3b229df3d4c15ce08de9f84c7febb7b3/src/libraries/System.Private.CoreLib/src/System/MemoryExtensions.cs#L135-L154\r\n`ExceptionArgument.start` is used, but `length` may be the faulty argument.\r\n\r\nhttps://github.com/dotnet/runtime/blob/dbb05eba3b229df3d4c15ce08de9f84c7febb7b3/src/libraries/System.Private.CoreLib/src/System/ReadOnlySpan.cs#L350-L362\r\nonly throws `ArgumentOutOfRangeException` without specifying the paramname.\r\n{RO}S ctor does it the same way.\r\n\r\nSimilar for `AsMemory(this string? text, int start, int length);`.\r\n\r\nShould the behavior of MemoryExtensions.AsSpan/AsMemory be aligned to the one of Slice?\r\n\r\nFor reference see also https://github.com/dotnet/runtime/pull/53463#discussion_r642749460\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003egfoidl\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Memory`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-06-02T18:16:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1MzI4NDUwOQ==",
                                           "createdAt":  "2021-06-02T18:30:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEbUyTA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "gfoidl",
                                                                               "createdAt":  "2021-06-02T18:35:50Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "vcsjones",
                                                                               "createdAt":  "2021-06-02T18:57:16Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MihaZupan",
                                                                               "createdAt":  "2025-07-21T16:57:36Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "Initial thoughts: If we wanted to unify this, I\u0027d prefer to remove the argument entirely rather than try to figure out which of \"length\" or \"offset\" is correct. Since this is such a hot code path we don\u0027t have the luxury of inserting the extra few instructions it\u0027d take to figure out a better parameter name.",
                                           "updatedAt":  "2021-06-02T18:30:34Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1MzQ5MzE1OQ==",
                                           "createdAt":  "2021-06-03T01:33:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xtqqczze",
                                           "body":  "Removing the argument entirely could be a good option, but I thought that instead we could call a new throw helper method:\r\n`ThrowHelper.ThrowAsSpanArgumentOutOfRangeExceptions(text, start, length)`\r\n\r\n`AsSpan1` and `AsSpan2` below have the same length of bytecode, but in theory performance should be improved in the latter, as the the reg-reg movs are effectively free due to register renaming:\r\n\r\nhttps://sharplab.io/#v2:C4LghgzgtgPgAgJgIwFgBQcAMACOSB0AIgJZgDmAdgPYTDEDGE+AwlQCYCmAghWADYBPCMQgBudFlwEASgFcKdKBxZUoAB2J8OAJwDKOgG4MOYiTjz45C4kvwBJBTqpr92o/RPi06AMQVZfHxgAEZa2By8oRzoEgDMUgBsuAjYALIcUFTaAgCiAB7AEcJUFBDYAN7o2NW48XhJ0hxgbADyFIK6amAUADz0ABZg2gB82FwQnd0AFMD9IlKYAPzYhQUANNjECti0Q8AbW8DYWhRkswCUVTWVaDV3mwBm2DMcBdgAvO/Y/oGXt/fVG4AgHEJ5TXbaI4AQi+OBgMGOETO/WwMOwmD+wKx2AAKv1tFQAO4ACQ4fDUOnweIJhK42jIsiUChasmALQe0m6ZA4+Q8ajoJSmvI4/OIJTpDKZwHwEOA5y82JqcAA7NhOA8wAFgArgQBfGL/EFgqayQ7nWXYUYms2raUAGSRs2w8OepoU5xOyMtrrNLwK+AdpydAFodsA9udMYrcfiiaTyZTqUSJYyImzWezOaceXk+QKKELcyL8ympTLw5D5QasSq0hksgJUkMIIM+CxtE1CpMCx2ngBVUpgB7KLhsNhTXt1zLZJvaFv8fAAcQ4wEaw47FA8fUGIz9co2UwovrdcotAHoAFTYB5ZDzYABeTmDr0KpTFFGwF7P5w2nouOuqfVDVqRJsEaZo2g6LpegGIZRnGbsEBmOYyjwJYVhfA5tllLCjj/foo0BK4jWeW0Pi+H4+EI+4gWjUFngtNE4QRfDUVhajoxjGl4wpbQqVjWkJmg0s0xZNkOS5HM83fCA9w2HDESDAiAOxWt1U1PhtWI+4gO0u56Kma13QtK0T3OW0A0dFEXSMuVWNM30LMDL1Q1lSM9OBJMSTJXj+JpBDhPpVNmQzCTs2FUUSlk215IrfZFORKtvGAu5a3SadG2bVt207DhuwnDh+0HYd8FHcdJ3ShtZ3nNtl1XQqdAiLdYN3W0f2eI93Vs804uwS9r1vDgHyfF8infT9v1/KykruIDdLQQ4dF4Phwn8KBsAiksgqldBaOqAB9TA1m0nDtPw460HmuA6iQJJEC4uMfJ0CptIAbUIKgTAAOSoergFkbQKAAXW0xbAf4UC4AAFge2lttE0Ks25Tb30LaTxXh7YhklNNqL2+5Zhpb4OEJbAfuAOx1C0KUODYFHBRmmogLud7PogcnGn+wGQeAsHlshmGvIC7oRJC8Skak4sZKmNDlhizZsLi3CEoubT8buQmiWJ0nycptRqbTWn6YLRnAPQXUgA=",
                                           "updatedAt":  "2021-06-03T01:33:48Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1MzQ5NzA4Ng==",
                                           "createdAt":  "2021-06-03T01:45:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "@xtqqczze Normally I think that would be an ok idea, but these methods are inlined into their callers, which means that registers don\u0027t always match up as one would expect. And, if literal integer values are used, registers might be skipped entirely. Now this new code introduces _additional_ shuffling beyond what previously existed.\r\n\r\nTo see this in action, define the two methods below, then mark `AsSpan` and `AsSpan2` as aggressive-inlining.\r\n\r\n```cs\r\n    private static ReadOnlySpan\u003cchar\u003e DoIt(string foo)\r\n    {\r\n        return AsSpan(foo, 3, 4);\r\n    }\r\n\r\n    private static ReadOnlySpan\u003cchar\u003e DoIt2(string foo)\r\n    {\r\n        return AsSpan2(foo, 3, 4);\r\n    }\r\n```\r\n\r\nIn this scenario, __DoIt__ is 62 bytes of codegen (x64), while __DoIt2__ is 71 bytes of codegen (x64).",
                                           "updatedAt":  "2021-06-03T01:48:54Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NDQyMDY5OQ==",
                                           "createdAt":  "2021-06-04T07:08:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBv4zXQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "xtqqczze",
                                                                               "createdAt":  "2021-06-23T16:42:27Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "gfoidl",
                                           "body":  "Let\u0027s just remove the paramName, and go for performance. If the caller needs to distinguish between start, and length the caller can provide the necessary code*.\r\n\r\n\\* in practice I\u0027ve never encountered such a need for span, and friends. These cases (in user-code) should be covered by tests anyway, so any AOR-exception can be examined and fixed.",
                                           "updatedAt":  "2021-06-04T07:08:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2Njk5NTcxMw==",
                                           "createdAt":  "2021-06-23T16:42:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xtqqczze",
                                           "body":  "Also:\r\n\r\nhttps://github.com/dotnet/runtime/blob/c0ed319ba3164bfbd9c2c4d66f68f29f8cd78b04/src/libraries/System.Private.CoreLib/src/System/MemoryExtensions.cs#L109-L122\r\n\r\nhttps://github.com/dotnet/runtime/blob/c0ed319ba3164bfbd9c2c4d66f68f29f8cd78b04/src/libraries/System.Private.CoreLib/src/System/ReadOnlySpan.cs#L333-L339\r\n\r\nIn this case `ExceptionArgument.start` in `AsSpan` is meaningful, although inconsistent with `Span\u003cT\u003e.Slice`.\r\n\r\nIf we keep the `ExceptionArgument` we could create new `ThrowHelper.ThrowStartArgumentOutOfRangeException` for smaller code size.\r\n\r\n",
                                           "updatedAt":  "2021-06-23T16:42:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2NzAwMjA1MQ==",
                                           "createdAt":  "2021-06-23T16:52:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xtqqczze",
                                           "body":  "\u003e If we keep the `ExceptionArgument` we could create new `ThrowHelper.ThrowStartArgumentOutOfRangeException` for smaller code size.\r\n\r\nSee https://github.com/xtqqczze/dotnet-runtime/commit/fe0ea4f066c76e12d548a1e60056ed8f50fadb92 for an example _(also on this branch there are a few `ThrowHelper` changes I think would be good for performance)._\r\n",
                                           "updatedAt":  "2021-06-23T16:52:25Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "MemoryExtensions.AsSpan/AsMemory throws different exception than {ReadOnly}Span.Slice",
        "labels":  [
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/53655",
        "createdAt":  "2021-06-03T01:39:36Z",
        "number":  53655,
        "author":  "GrabYourPitchforks",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-07-13T05:59:39Z",
        "body":  "Based on a conversation at https://github.com/dotnet/runtime/pull/53652#discussion_r644414001.\r\n\r\nIn the implementation of `MemoryExtensions.IndexOfAny\u003cT\u003e(ROS\u003cT\u003e, ROS\u003cT\u003e)` \\[[see code](https://github.com/dotnet/runtime/blob/dbb05eba3b229df3d4c15ce08de9f84c7febb7b3/src/libraries/System.Private.CoreLib/src/System/MemoryExtensions.cs#L692)\\], small needle spans are special-cased for _T=byte_ and _T=char_ and sent to specialized helpers in `SpanHelpers`. But for any other _T_, these small needle spans are not special-cased, and control flow goes to the generalized `SpanHelpers.IndexOfAny\u003cT\u003e(ref T, int, ref T, int)` routine, even though n-ary specialized helpers exist.\r\n\r\nWe should consider special-casing these lengths within the `MemoryExtensions.IndexOfAny` and `LastIndexOfAny` methods and funneling to the specialized n-ary helpers. Or, if there\u0027s a specific reason this logic was left out for non-byte / non-char types _T_, we should put a comment in the code to clarify why this logic has been excluded.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOMt9M3A==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1MzQ5NTAwNA==",
                                           "createdAt":  "2021-06-03T01:39:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @GrabYourPitchForks, @carlossanlop\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nBased on a conversation at https://github.com/dotnet/runtime/pull/53652#discussion_r644414001.\r\n\r\nIn the implementation of `MemoryExtensions.IndexOfAny\u003cT\u003e(ROS\u003cT\u003e, ROS\u003cT\u003e)` \\[[see code](https://github.com/dotnet/runtime/blob/dbb05eba3b229df3d4c15ce08de9f84c7febb7b3/src/libraries/System.Private.CoreLib/src/System/MemoryExtensions.cs#L692)\\], small needle spans are special-cased for _T=byte_ and _T=char_ and sent to specialized helpers in `SpanHelpers`. But for any other _T_, these small needle spans are not special-cased, and control flow goes to the generalized `SpanHelpers.IndexOfAny\u003cT\u003e(ref T, int, ref T, int)` routine, even though n-ary specialized helpers exist.\r\n\r\nWe should consider special-casing these lengths within the `MemoryExtensions.IndexOfAny` and `LastIndexOfAny` methods and funneling to the specialized n-ary helpers. Or, if there\u0027s a specific reason this logic was left out for non-byte / non-char types _T_, we should put a comment in the code to clarify why this logic has been excluded.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eGrabYourPitchforks\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Memory`, `tenet-performance`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-06-03T01:39:38Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "MemoryMarshal.IndexOfAny/LastIndexOfAny for non-primitives does not special-case small needle spans",
        "labels":  [
                       "area-System.Memory",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/53821",
        "createdAt":  "2021-06-07T17:41:21Z",
        "number":  53821,
        "author":  "tannergooding",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCBg6NQ==",
                          "nodes":  [
                                        {
                                            "content":  "EYES",
                                            "user":  "Sergio0694",
                                            "createdAt":  "2021-06-07T18:15:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "saucecontrol",
                                            "createdAt":  "2021-11-08T03:14:56Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "AraHaan",
                                            "createdAt":  "2021-11-08T03:23:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AraHaan",
                                            "createdAt":  "2021-11-08T03:23:39Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2021-11-08T03:28:33Z",
        "body":  "### Description\r\n\r\nThe following program on full framework (or anywhere using `portable span`) fails with \u0027Cannot use type \u0027S\u0027. Only value types without pointers or references are supported.\u0027\r\n\r\n```csharp\r\nusing System;\r\n\r\nunsafe struct S { public void* x; }\r\n\r\nunsafe class Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        Span\u003cS\u003e x = new Span\u003cS\u003e(null, 0);\r\n    }\r\n}\r\n```\r\n\r\nThis is thrown as part of `SpanHelpers.IsReferenceOrContainsReferences\u003cT\u003e()` which currently only checks `Type.IsPrimitive` and `Type.IsValueType` and causes issues in netstandard libraries, particularly around interop, that may be dealing with structs containing pointers.\r\n\r\nI believe simply also checking `Type.IsPointer` would be sufficient here.\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOOWLaDA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NjEzNDQ1NA==",
                                           "createdAt":  "2021-06-07T17:41:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @GrabYourPitchForks, @carlossanlop\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\nThe following program on full framework (or anywhere using `portable span`) fails with \u0027Cannot use type \u0027S\u0027. Only value types without pointers or references are supported.\u0027\r\n\r\n```csharp\r\nusing System;\r\n\r\nunsafe struct S { public void* x; }\r\n\r\nunsafe class Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        Span\u003cS\u003e x = new Span\u003cS\u003e(null, 0);\r\n    }\r\n}\r\n```\r\n\r\nThis is thrown as part of `SpanHelpers.IsReferenceOrContainsReferences\u003cT\u003e()` which currently only checks `Type.IsPrimitive` and `Type.IsValueType` and causes issues in netstandard libraries, particularly around interop, that may be dealing with structs containing pointers.\r\n\r\nI believe simply also checking `Type.IsPointer` would be sufficient here.\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003etannergooding\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Memory`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-06-07T17:41:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NjEzNTEzMg==",
                                           "createdAt":  "2021-06-07T17:42:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "CC. @jkotas, @jeffhandley, @ericstj, @ViktorHofer \r\n\r\nIs this something that we would consider for servicing or are there complications/reasons why this is hard/not possible?\r\n\r\n-- This was raised for the microsoft/ClangSharp repo which has helper methods for returning a `Span\u003cT\u003e` over certain native allocations (which involve pointer types)",
                                           "updatedAt":  "2021-06-07T17:42:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NjE1MjAzMQ==",
                                           "createdAt":  "2021-06-07T18:10:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCBg6fw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tannergooding",
                                                                               "createdAt":  "2021-06-07T18:15:39Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AraHaan",
                                                                               "createdAt":  "2021-11-08T03:24:27Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "jkotas",
                                           "body":  "I do not think that this meets the 2.1 servicing bar: \"High impact for significant number of customers without reasonable workaround\". \r\n\r\nI would not be opposed to servicing this if somebody can provide justification that meets the servicing bar. We have shipped multiple servicing updates of https://www.nuget.org/packages/System.Memory/ and I do not recall hearing any issues with it.",
                                           "updatedAt":  "2021-06-07T18:10:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NjE1NTY1MA==",
                                           "createdAt":  "2021-06-07T18:15:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "The workaround would be to change your struct\u0027s field types to _IntPtr_ instead of having actual pointers. That said, I don\u0027t know how much pain this would cause in the consuming app (do they now need to add a cast to every field access?), and this might not be feasible if the struct is auto-generated or provided by a third party lib.",
                                           "updatedAt":  "2021-06-07T18:15:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NjE1ODE2MQ==",
                                           "createdAt":  "2021-06-07T18:18:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e The workaround would be to change your struct\u0027s field types to IntPtr instead of having actual pointers\r\n\r\nRight, and I\u0027m not going to do that for ClangSharp. It would make the surface significantly worse on .NET Core/.NET 5+ and only one person has reported it so far in the 2 years its been this way.\r\n\r\nLikewise, as you pointed out, it would require changes to the ClangSharp P/Invoke generator itself to basically never generate pointers in \"compat\" mode, which just seems strictly worse 😄 ",
                                           "updatedAt":  "2021-06-07T18:18:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NjE1OTc3MQ==",
                                           "createdAt":  "2021-06-07T18:20:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "The most \"frustrating\" part is that the following is legal as the check only exists for the pointer constructor:\r\n```csharp\r\nS[] a = new S[5];\r\nSpan\u003cS\u003e x = new Span\u003cS\u003e(a);\r\n```\r\n\r\nBut this also means that there is a workaround, just one that involves allocating.",
                                           "updatedAt":  "2021-06-07T18:20:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc45YstN",
                                           "createdAt":  "2021-11-08T03:17:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "saucecontrol",
                                           "body":  "I just hit this today in a library that\u0027s targeting ns2.0 and netcoreapp3.1.  Definitely a confusing error message given there\u0027s no technical reason it shouldn\u0027t work.",
                                           "updatedAt":  "2021-11-08T03:17:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc45YtoM",
                                           "createdAt":  "2021-11-08T03:26:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AraHaan",
                                           "body":  "I agree, sometimes one needs to store unmanaged function pointers in said structs as well (where they call the Windows APIs to get the function\u0027s address to \"call\" it and assign it to that struct\u0027s member).\r\n\r\nA prime example is a C++ class member function marked ``extern \"C\"`` and exported, so then you go about it to retrieve it in C# using function pointers.",
                                           "updatedAt":  "2021-11-08T03:28:33Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Portable Span\u003cT\u003e incorrectly throws for a struct containing a pointer",
        "labels":  [
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/62835",
        "createdAt":  "2021-12-15T07:47:17Z",
        "number":  62835,
        "author":  "medo64",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-03-13T00:03:17Z",
        "body":  "It is really easy to accidentally wrap byte array into a ReadOnlyMemory structure and thus change what might seem unchangeable on the surface. For example take the following code:\r\n\r\n```C#\r\nstatic ReadOnlyMemory\u003cbyte\u003e SomeMethodOrConstructor(ReadOnlyMemory\u003cbyte\u003e memory)\r\n{\r\n    return memory;\r\n}\r\n\r\nvar buffer = new byte[] { 1, 2, 3, };  // create buffer\r\nvar memory = SomeMethodOrConstructor(buffer);  // pass buffer to wrap it into ReadOnlyMemory\r\n\r\nbuffer[1] = 42;  // change array used\r\n\r\nforeach (var b in memory.Span)\r\n{\r\n    Console.Write(b.ToString(\"X2\"));\r\n}  // this will output 012A03; while one may expect 010203 as they might assume ReadOnlyMemory is indeed readonly\r\n```\r\n\r\nMind you, I\u0027m not reporting this behavior as a bug. It\u0027s completely expected and understandable why that happens.\r\n\r\nHowever, this error can happen easily by accident as `ReadOnlyMemory\u003cT\u003e` overloads will happily accept byte array and after variable gets move over a few classes or methods it might not be obvious we\u0027re changing an array that should logically be read-only.\r\n\r\nIt would be great to have an analyzer that would warn of such pattern.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYQKC1g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc47Rg_W",
                                           "createdAt":  "2021-12-15T07:47:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nIt is really easy to accidentally wrap byte array into a ReadOnlyMemory structure and thus change what might seem unchangeable on the surface. For example take the following code:\r\n\r\n```C#\r\nstatic ReadOnlyMemory\u003cbyte\u003e SomeMethodOrConstructor(ReadOnlyMemory\u003cbyte\u003e memory)\r\n{\r\n    return memory;\r\n}\r\n\r\nvar buffer = new byte[] { 1, 2, 3, };  // create buffer\r\nvar memory = SomeMethodOrConstructor(buffer);  // pass buffer to wrap it into ReadOnlyMemory\r\n\r\nbuffer[1] = 42;  // change array used\r\n\r\nforeach (var b in memory.Span)\r\n{\r\n    Console.Write(b.ToString(\"X2\"));\r\n}  // this will output 012A03; while one may expect 010203 as they might assume ReadOnlyMemory is indeed readonly\r\n```\r\n\r\nMind you, I\u0027m not reporting this behavior as a bug. It\u0027s completely expected and understandable why that happens.\r\n\r\nHowever, this error can happen easily by accident as `ReadOnlyMemory\u003cT\u003e` overloads will happily accept byte array and after variable gets move over a few classes or methods it might not be obvious we\u0027re changing an array that should logically be read-only.\r\n\r\nIt would be great to have an analyzer that would warn of such pattern.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003emedo64\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Memory`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-12-15T07:47:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc47R9Y_",
                                           "createdAt":  "2021-12-15T09:22:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gfoidl",
                                           "body":  "\u003e `ReadOnlyMemory\u003cT\u003e` overloads will happily accept byte array and after variable gets move over a few classes or methods it might not be obvious we\u0027re changing an array that should logically be read-only.\r\n\r\nIf the ROM is used (consequently), then you aren\u0027t allowed to set an value via indexer (CS0021), so you can\u0027t change the array that way.\r\n\r\nIn your example you work on the array again, not the ROM. \r\n```\r\nmemory[1] = 42;  // change array used\r\n```\r\nwill fail to compile.\r\n\r\nFor the case `buffer[1]` no analyzer should warn, as this could be by intention, so some analyzer like that would mean a lot of false positives and even more work to selectively disable the analyzer-warning, so the use of that analyzer would go to zero.\r\n\r\nBesides that unit tests should cover mis-use of indexers anyway.\r\n\r\n",
                                           "updatedAt":  "2021-12-15T09:22:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc47VymG",
                                           "createdAt":  "2021-12-16T08:56:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "@buyaa-n @carlossanlop how complex would it be to implement such analyzer?\r\n\r\ncc @GrabYourPitchforks ",
                                           "updatedAt":  "2021-12-16T08:56:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc47YEhf",
                                           "createdAt":  "2021-12-16T20:20:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCHEDuQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "adamsitnik",
                                                                               "createdAt":  "2021-12-17T09:11:48Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "buyaa-n",
                                           "body":  "Tracking all usages of a byte array would not be cheap, especially for non-local variables cases (fields/properties)",
                                           "updatedAt":  "2021-12-16T20:20:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5hAoLW",
                                           "createdAt":  "2023-07-09T00:28:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wegylexy",
                                           "body":  "If you do that like this, you won\u0027t have access to the underlying buffer to mess with.\r\n```cs\r\nvar memory = SomeMethodOrConstructor(new byte[] { 1, 2, 3, });\r\n```\r\nIf you keep a reference to the underlying buffer, it would seem intentional to enable updating the values privately by the producer while exposing a read-only interface to the consumer.\r\n\r\nThe analyzer should not warn about this by default, if ever implemented.",
                                           "updatedAt":  "2023-07-09T00:28:57Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "Analyzer warning about changing underlying array of ReadOnlyMemory struct",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory",
                       "code-analyzer"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/68428",
        "createdAt":  "2022-04-12T23:57:24Z",
        "number":  68428,
        "author":  "performanceautofiler",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-06-22T01:41:53Z",
        "body":  "### Run Information\r\n\r\nArchitecture | x86\r\n-- | --\r\nOS | Windows 10.0.18362\r\nBaseline | [285b8259af30e255980b1ebfb2ddd60ca291a83a](https://github.com/dotnet/runtime/commit/285b8259af30e255980b1ebfb2ddd60ca291a83a)\r\nCompare | [0c64bdf3afc1fdc9166ad6c22c1990d3e0a6c509](https://github.com/dotnet/runtime/commit/0c64bdf3afc1fdc9166ad6c22c1990d3e0a6c509)\r\nDiff | [Diff](https://github.com/dotnet/runtime/compare/285b8259af30e255980b1ebfb2ddd60ca291a83a...0c64bdf3afc1fdc9166ad6c22c1990d3e0a6c509)\r\n\r\n\r\n### Regressions in System.Memory.ReadOnlySpan\r\n\r\nBenchmark | Baseline | Test | Test/Base | Test Quality | Edge Detector | Baseline IR | Compare IR | IR Ratio | Baseline ETL | Compare ETL\r\n-- | -- | -- | -- | -- | -- | -- | -- | -- | -- | --\r\n[IndexOfString - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x86_Windows 10.0.18362/System.Memory.ReadOnlySpan.IndexOfString(input%3a%20%22StrIng%22%2c%20value%3a%20%22string%22%2c%20comparisonType%3a%20OrdinalIgnoreCase).html\u003e) | 20.22 ns | 21.71 ns | 1.07 | 0.01 | False | | |\r\n\r\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/04_12_2022/refs/heads/main_x86_Windows%2010.0.18362_Regression/System.Memory.ReadOnlySpan_1.png\u003e)\r\n[Test Report](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/04_12_2022/refs/heads/main_x86_Windows%2010.0.18362_Regression/System.Memory.ReadOnlySpan.html\u003e)\r\n\r\n### Repro\r\n\r\n```cmd\r\ngit clone https://github.com/dotnet/performance.git\r\npy .\\performance\\scripts\\benchmarks_ci.py -f net6.0 --filter \u0027System.Memory.ReadOnlySpan*\u0027\r\n```\r\n\u003cdetails\u003e\r\n\r\n### Payloads\r\n\r\n[Baseline](\u003chttps://helixdi8s23ayyeko0k025g8.blob.core.windows.net/helix-job-2329c72a-c3e0-49a5-987e-efe02073fe7f7399baa7f604c8791/fb916119-dda6-4d77-bccf-5bfe49f3a616.zip?sv=2019-07-07\u0026se=2022-05-09T05%3A02%3A38Z\u0026sr=c\u0026sp=rl\u0026sig=Xo8DrfLB1j5IN9slqJFdkL9R0lSe9QY3yn6%2F7O3qW%2Bo%3D\u003e)\r\n[Compare](\u003chttps://helixdi8s23ayyeko0k025g8.blob.core.windows.net/helix-job-85415d1d-2bc3-4d2b-a337-b3ff0f988d397e14c13f47e4ce0b8/46941294-9041-4cd2-a2c9-15eff2b22d82.zip?sv=2019-07-07\u0026se=2022-05-09T17%3A28%3A36Z\u0026sr=c\u0026sp=rl\u0026sig=GMA595HtBxsYpMPSN3zuvVw6lbQWyvKU5DvHB%2F2brFM%3D\u003e)\r\n### Histogram\r\n\r\n#### System.Memory.ReadOnlySpan.IndexOfString(input: \"StrIng\", value: \"string\", comparisonType: OrdinalIgnoreCase)\r\n\r\n```log\r\n\r\n```\r\n### Description of detection logic\r\n```IsRegressionBase: Marked as regression because the compare was 5% greater than the baseline, and the value was not too small.\r\nIsRegressionChecked: Marked as regression because the three check build points were 0.05 greater than the baseline.\r\nIsImprovementBase: Marked as not an improvement because the compare was not 5% less than the baseline, or the value was too small.\r\nIsRegressionBase: Marked as regression because the compare was 5% greater than the baseline, and the value was not too small.\r\nIsRegressionChecked: Marked as regression because the three check build points were 0.05 greater than the baseline.\r\nIsRegressionWindowed: Marked as regression because 21.708424795274013 \u003e 20.97468532055912.\r\nIsChangePoint: Marked as a change because one of 3/17/2022 6:54:53 PM, 4/9/2022 5:43:54 AM, 4/12/2022 5:02:33 PM falls between 4/4/2022 4:14:58 AM and 4/12/2022 5:02:33 PM.\r\nIsRegressionStdDev: Marked as regression because -32.95537559884967 (T) = (0 -21.692417802325732) / Math.Sqrt((0.05449117002768166 / (42)) + (0.015887934761378314 / (15))) is less than -2.0040447832881556 = MathNet.Numerics.Distributions.StudentT.InvCDF(0, 1, (42) + (15) - 2, .025) and -0.07962205868801316 = (20.09260335851878 - 21.692417802325732) / 20.09260335851878 is less than -0.05.\r\nIsImprovementBase: Marked as not an improvement because the compare was not 5% less than the baseline, or the value was too small.\r\nIsChangeEdgeDetector: Marked not as a regression because Edge Detector said so.\r\n\r\n```\r\n\r\n### Docs\r\n\r\n[Profiling workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/profiling-workflow-dotnet-runtime.md)\r\n[Benchmarking workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/benchmarking-workflow-dotnet-runtime.md)\r\n\r\n\u003c/details\u003e\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHObJWYnA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5B_BtG",
                                           "createdAt":  "2022-04-22T23:32:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-04-22T23:32:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5B_BxG",
                                           "createdAt":  "2022-04-22T23:32:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "DrewScoggins",
                                           "body":  "Related to https://github.com/dotnet/runtime/pull/67758 @EgorBo ",
                                           "updatedAt":  "2022-04-22T23:32:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5B_DAG",
                                           "createdAt":  "2022-04-22T23:41:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCZaUmw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "DrewScoggins",
                                                                               "createdAt":  "2022-04-22T23:42:19Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "This is the worst possible case for the vectorization change, it\u0027s a very short string with a hit on index 0. I\u0027m assuming this is an acceptable price to pay.",
                                           "updatedAt":  "2022-04-22T23:41:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5B_EE2",
                                           "createdAt":  "2022-04-22T23:47:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-globalization\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Run Information\r\n\r\nArchitecture | x86\r\n-- | --\r\nOS | Windows 10.0.18362\r\nBaseline | [285b8259af30e255980b1ebfb2ddd60ca291a83a](https://github.com/dotnet/runtime/commit/285b8259af30e255980b1ebfb2ddd60ca291a83a)\r\nCompare | [0c64bdf3afc1fdc9166ad6c22c1990d3e0a6c509](https://github.com/dotnet/runtime/commit/0c64bdf3afc1fdc9166ad6c22c1990d3e0a6c509)\r\nDiff | [Diff](https://github.com/dotnet/runtime/compare/285b8259af30e255980b1ebfb2ddd60ca291a83a...0c64bdf3afc1fdc9166ad6c22c1990d3e0a6c509)\r\n\r\n\r\n### Regressions in System.Memory.ReadOnlySpan\r\n\r\nBenchmark | Baseline | Test | Test/Base | Test Quality | Edge Detector | Baseline IR | Compare IR | IR Ratio | Baseline ETL | Compare ETL\r\n-- | -- | -- | -- | -- | -- | -- | -- | -- | -- | --\r\n[IndexOfString - Duration of single invocation](\u003chttps://pvscmdupload.blob.core.windows.net/reports/allTestHistory/refs/heads/main_x86_Windows 10.0.18362/System.Memory.ReadOnlySpan.IndexOfString(input%3a%20%22StrIng%22%2c%20value%3a%20%22string%22%2c%20comparisonType%3a%20OrdinalIgnoreCase).html\u003e) | 20.22 ns | 21.71 ns | 1.07 | 0.01 | False | | |\r\n\r\n![graph](\u003chttps://pvscmdupload.blob.core.windows.net/autofilereport/autofilereports/04_12_2022/refs/heads/main_x86_Windows%2010.0.18362_Regression/System.Memory.ReadOnlySpan_1.png\u003e)\r\n[Test Report](\u003chttps://pvscmdupload.blob.core.windows.net/autofilereport/autofilereports/04_12_2022/refs/heads/main_x86_Windows%2010.0.18362_Regression/System.Memory.ReadOnlySpan.html\u003e)\r\n\r\n### Repro\r\n\r\n```cmd\r\ngit clone https://github.com/dotnet/performance.git\r\npy .\\performance\\scripts\\benchmarks_ci.py -f net6.0 --filter \u0027System.Memory.ReadOnlySpan*\u0027\r\n```\r\n\u003cdetails\u003e\r\n\r\n### Payloads\r\n\r\n[Baseline](\u003chttps://helixdi8s23ayyeko0k025g8.blob.core.windows.net/helix-job-2329c72a-c3e0-49a5-987e-efe02073fe7f7399baa7f604c8791/fb916119-dda6-4d77-bccf-5bfe49f3a616.zip?sv=2019-07-07\u0026se=2022-05-09T05%3A02%3A38Z\u0026sr=c\u0026sp=rl\u0026sig=Xo8DrfLB1j5IN9slqJFdkL9R0lSe9QY3yn6%2F7O3qW%2Bo%3D\u003e)\r\n[Compare](\u003chttps://helixdi8s23ayyeko0k025g8.blob.core.windows.net/helix-job-85415d1d-2bc3-4d2b-a337-b3ff0f988d397e14c13f47e4ce0b8/46941294-9041-4cd2-a2c9-15eff2b22d82.zip?sv=2019-07-07\u0026se=2022-05-09T17%3A28%3A36Z\u0026sr=c\u0026sp=rl\u0026sig=GMA595HtBxsYpMPSN3zuvVw6lbQWyvKU5DvHB%2F2brFM%3D\u003e)\r\n### Histogram\r\n\r\n#### System.Memory.ReadOnlySpan.IndexOfString(input: \"StrIng\", value: \"string\", comparisonType: OrdinalIgnoreCase)\r\n\r\n```log\r\n\r\n```\r\n### Description of detection logic\r\n```IsRegressionBase: Marked as regression because the compare was 5% greater than the baseline, and the value was not too small.\r\nIsRegressionChecked: Marked as regression because the three check build points were 0.05 greater than the baseline.\r\nIsImprovementBase: Marked as not an improvement because the compare was not 5% less than the baseline, or the value was too small.\r\nIsRegressionBase: Marked as regression because the compare was 5% greater than the baseline, and the value was not too small.\r\nIsRegressionChecked: Marked as regression because the three check build points were 0.05 greater than the baseline.\r\nIsRegressionWindowed: Marked as regression because 21.708424795274013 \u003e 20.97468532055912.\r\nIsChangePoint: Marked as a change because one of 3/17/2022 6:54:53 PM, 4/9/2022 5:43:54 AM, 4/12/2022 5:02:33 PM falls between 4/4/2022 4:14:58 AM and 4/12/2022 5:02:33 PM.\r\nIsRegressionStdDev: Marked as regression because -32.95537559884967 (T) = (0 -21.692417802325732) / Math.Sqrt((0.05449117002768166 / (42)) + (0.015887934761378314 / (15))) is less than -2.0040447832881556 = MathNet.Numerics.Distributions.StudentT.InvCDF(0, 1, (42) + (15) - 2, .025) and -0.07962205868801316 = (20.09260335851878 - 21.692417802325732) / 20.09260335851878 is less than -0.05.\r\nIsImprovementBase: Marked as not an improvement because the compare was not 5% less than the baseline, or the value was too small.\r\nIsChangeEdgeDetector: Marked not as a regression because Edge Detector said so.\r\n\r\n```\r\n\r\n### Docs\r\n\r\n[Profiling workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/profiling-workflow-dotnet-runtime.md)\r\n[Benchmarking workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/benchmarking-workflow-dotnet-runtime.md)\r\n\r\n\u003c/details\u003e\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eperformanceautofiler[bot]\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Globalization`, `tenet-performance`, `tenet-performance-benchmarks`, `untriaged`, `refs/heads/main`, `RunKind=micro`, `Windows 10.0.18362`, `Regression`, `CoreClr`, `x86`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-04-22T23:47:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5B_FiW",
                                           "createdAt":  "2022-04-23T00:06:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tarekgh",
                                           "body":  "@EgorBo could you please advise if this regression is acceptable in the failed case. Looks it is `x86` specific too.",
                                           "updatedAt":  "2022-04-23T00:09:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5slZic",
                                           "createdAt":  "2023-11-21T21:44:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Run Information\r\n\r\nArchitecture | x86\r\n-- | --\r\nOS | Windows 10.0.18362\r\nBaseline | [285b8259af30e255980b1ebfb2ddd60ca291a83a](https://github.com/dotnet/runtime/commit/285b8259af30e255980b1ebfb2ddd60ca291a83a)\r\nCompare | [0c64bdf3afc1fdc9166ad6c22c1990d3e0a6c509](https://github.com/dotnet/runtime/commit/0c64bdf3afc1fdc9166ad6c22c1990d3e0a6c509)\r\nDiff | [Diff](https://github.com/dotnet/runtime/compare/285b8259af30e255980b1ebfb2ddd60ca291a83a...0c64bdf3afc1fdc9166ad6c22c1990d3e0a6c509)\r\n\r\n\r\n### Regressions in System.Memory.ReadOnlySpan\r\n\r\nBenchmark | Baseline | Test | Test/Base | Test Quality | Edge Detector | Baseline IR | Compare IR | IR Ratio | Baseline ETL | Compare ETL\r\n-- | -- | -- | -- | -- | -- | -- | -- | -- | -- | --\r\n[IndexOfString - Duration of single invocation](\u003chttps://pvscmdupload.blob.core.windows.net/reports/allTestHistory/refs/heads/main_x86_Windows 10.0.18362/System.Memory.ReadOnlySpan.IndexOfString(input%3a%20%22StrIng%22%2c%20value%3a%20%22string%22%2c%20comparisonType%3a%20OrdinalIgnoreCase).html\u003e) | 20.22 ns | 21.71 ns | 1.07 | 0.01 | False | | |\r\n\r\n![graph](\u003chttps://pvscmdupload.blob.core.windows.net/autofilereport/autofilereports/04_12_2022/refs/heads/main_x86_Windows%2010.0.18362_Regression/System.Memory.ReadOnlySpan_1.png\u003e)\r\n[Test Report](\u003chttps://pvscmdupload.blob.core.windows.net/autofilereport/autofilereports/04_12_2022/refs/heads/main_x86_Windows%2010.0.18362_Regression/System.Memory.ReadOnlySpan.html\u003e)\r\n\r\n### Repro\r\n\r\n```cmd\r\ngit clone https://github.com/dotnet/performance.git\r\npy .\\performance\\scripts\\benchmarks_ci.py -f net6.0 --filter \u0027System.Memory.ReadOnlySpan*\u0027\r\n```\r\n\u003cdetails\u003e\r\n\r\n### Payloads\r\n\r\n[Baseline](\u003chttps://helixdi8s23ayyeko0k025g8.blob.core.windows.net/helix-job-2329c72a-c3e0-49a5-987e-efe02073fe7f7399baa7f604c8791/fb916119-dda6-4d77-bccf-5bfe49f3a616.zip?sv=2019-07-07\u0026se=2022-05-09T05%3A02%3A38Z\u0026sr=c\u0026sp=rl\u0026sig=Xo8DrfLB1j5IN9slqJFdkL9R0lSe9QY3yn6%2F7O3qW%2Bo%3D\u003e)\r\n[Compare](\u003chttps://helixdi8s23ayyeko0k025g8.blob.core.windows.net/helix-job-85415d1d-2bc3-4d2b-a337-b3ff0f988d397e14c13f47e4ce0b8/46941294-9041-4cd2-a2c9-15eff2b22d82.zip?sv=2019-07-07\u0026se=2022-05-09T17%3A28%3A36Z\u0026sr=c\u0026sp=rl\u0026sig=GMA595HtBxsYpMPSN3zuvVw6lbQWyvKU5DvHB%2F2brFM%3D\u003e)\r\n### Histogram\r\n\r\n#### System.Memory.ReadOnlySpan.IndexOfString(input: \"StrIng\", value: \"string\", comparisonType: OrdinalIgnoreCase)\r\n\r\n```log\r\n\r\n```\r\n### Description of detection logic\r\n```IsRegressionBase: Marked as regression because the compare was 5% greater than the baseline, and the value was not too small.\r\nIsRegressionChecked: Marked as regression because the three check build points were 0.05 greater than the baseline.\r\nIsImprovementBase: Marked as not an improvement because the compare was not 5% less than the baseline, or the value was too small.\r\nIsRegressionBase: Marked as regression because the compare was 5% greater than the baseline, and the value was not too small.\r\nIsRegressionChecked: Marked as regression because the three check build points were 0.05 greater than the baseline.\r\nIsRegressionWindowed: Marked as regression because 21.708424795274013 \u003e 20.97468532055912.\r\nIsChangePoint: Marked as a change because one of 3/17/2022 6:54:53 PM, 4/9/2022 5:43:54 AM, 4/12/2022 5:02:33 PM falls between 4/4/2022 4:14:58 AM and 4/12/2022 5:02:33 PM.\r\nIsRegressionStdDev: Marked as regression because -32.95537559884967 (T) = (0 -21.692417802325732) / Math.Sqrt((0.05449117002768166 / (42)) + (0.015887934761378314 / (15))) is less than -2.0040447832881556 = MathNet.Numerics.Distributions.StudentT.InvCDF(0, 1, (42) + (15) - 2, .025) and -0.07962205868801316 = (20.09260335851878 - 21.692417802325732) / 20.09260335851878 is less than -0.05.\r\nIsImprovementBase: Marked as not an improvement because the compare was not 5% less than the baseline, or the value was too small.\r\nIsChangeEdgeDetector: Marked not as a regression because Edge Detector said so.\r\n\r\n```\r\n\r\n### Docs\r\n\r\n[Profiling workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/profiling-workflow-dotnet-runtime.md)\r\n[Benchmarking workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/benchmarking-workflow-dotnet-runtime.md)\r\n\r\n\u003c/details\u003e\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eperformanceautofiler[bot]\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`arch-x86`, `area-System.Memory`, `os-windows`, `tenet-performance`, `tenet-performance-benchmarks`, `runtime-coreclr`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003eFuture\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-11-21T21:44:14Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "[Perf] Regressions in System.Memory.ReadOnlySpan",
        "labels":  [
                       "arch-x86",
                       "area-System.Memory",
                       "os-windows",
                       "tenet-performance",
                       "tenet-performance-benchmarks",
                       "runtime-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/69605",
        "createdAt":  "2022-05-20T13:44:10Z",
        "number":  69605,
        "author":  "mgravell",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCjSOeA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Wraith2",
                                            "createdAt":  "2022-05-20T14:24:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aromaa",
                                            "createdAt":  "2022-05-20T15:15:55Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2022-05-20T15:37:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "omariom",
                                            "createdAt":  "2022-05-20T22:10:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AlgorithmsAreCool",
                                            "createdAt":  "2022-05-23T17:07:50Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Enderlook",
                                            "createdAt":  "2022-06-20T21:01:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kronic",
                                            "createdAt":  "2022-06-23T06:45:12Z"
                                        }
                                    ],
                          "totalCount":  7
                      },
        "updatedAt":  "2022-07-10T19:45:48Z",
        "body":  "### Background and motivation\r\n\r\n`Memory\u003cT\u003e`/`Span\u003cT\u003e` (and the read-only variants, and `ReadOnlySequence\u003cT\u003e`) are awesome. However, they have some weaknesses when it comes to pooling and lifetime considerations. When the lifetime is scoped inside a single deterministic context (i.e. \"rent, do a thing, return\"), it works great; but when lifetime needs to pass *outside* of that context: things get wobbly.\r\n\r\nNote: this only matters for high throughput scenarios - it is niche; but those scenarios happen *a lot*; I have multiple examples from within MSFT, and from external consumers, where this is a bottleneck.\r\n\r\nExample scenarios:\r\n\r\n1. a deserializer (for something like RPC, or whatever) needs to create some payloads - for example `Memory\u003cbyte\u003e` for raw blob payloads (which happens more than you might expect), or `ReadOnlyMemory\u003cSomeChunkyStruct\u003e` for the \"items\" data associated with a request - and wants to do that *as efficiently as possible* (again: very high volume); what we want to do is implement `IDisposable` on the type, and have the type release the data when possible\r\n2. some protocol parser (think Kestrel/pipelines) sees data that it is receiving from a `Pipe`; rather than copy this data out to a separate pool to offload it (so the `Pipe` can keep looking for more frames), it would like to \"preserve\" this memory, so that it can be passed as a QUWI/Task/whatever to a marshaller on a different thread to parse, which can then release this data at some undetermined future time\r\n\r\nexisting parallels:\r\n\r\n1. There is already `IMemoryOwner\u003cT\u003e`, which allows `Dispose()` later; this would *sort of* fit scenario 1, but it forces an object allocation *per memory* (because of the API shape); it doesn\u0027t fit sequential slab allocation very well, and it does not fit scenario 2 at all.\r\n2. The array pool a partial fit, and `MemoryMarshal.TryGetArray` allows us to see that data *can be considered an array*, but: we can\u0027t see which (if any) array pool data came from, nor can we tell if the data we\u0027re looking at is one slice of something that has actually be sliced and diced multiple times from the array.\r\n3. It is possible to construct a custom `Memory\u003cT\u003e`-like type which has a \"do this thing afterwards\" callback, but this creates yet more memory-like types, and the requirement to store *at least* a delegate (and more likely: a delegate and state object, i.e. something like `Action\u003cobject, Memory\u003cT\u003e\u003e callback`) in addition to the existing `Memory\u003cT\u003e` fields: makes the type very wide and expensive.\r\n\r\nI would like to address both of these at the BCL layer in a common API, based on experiments that I have performed successfully locally. In particular, using custom memory managers and the existing memory API mean that the system also extends naturally to work with `ReadOnlySequence\u003cT\u003e`, for larger payloads (note: caveat here: netfx has a bug in `ReadOnlySequence\u003cT\u003e` which is now fixed in code but not yet deployed; see https://github.com/dotnet/runtime/issues/67295). Using a custom memory manager means that `Memory\u003cT\u003e` and `ReadOnlyMemory\u003cT\u003e` can be used directly without any additional field cost, and it can be used in existing types. This custom memory manager (which could be, for example, a slab that underpins the data) would then essentially have ref-counting, with \"preserve\" (including pin) being +1 and \"release\" (/dispose? also: including unpin) being -1; when it hits zero: *then* the memory manager performs whatever the appropriate action is for this scenario.\r\n\r\nExisting memory uses that aren\u0027t using this category of memory-manager: are unaffected.\r\n\r\n---\r\n\r\nNote: I\u0027ve implemented this model multiple times in isolation, but that usage is then library specific and cannot be consumed readily over multiple libraries.\r\n\r\n### API Proposal\r\n\r\nThis essentially boils down to 2 methods (3 if we want to be able to test \"do you support this?\" without changing the count), and a base-type memory-manager:\r\n\r\n1. `bool TryPreserve()`\r\n2. `bool TryRelease()`\r\n3 `bool SupportsPreserve()`\r\n\r\nThese could either be provided via extension method, or directly on `Memory\u003cT\u003e` - I would suggest the extension method is less friction; and would check (for example, via `TryGetMemoryManager` if extn, or directly on the object if via `Memory\u003cT\u003e`) whether the new memory-manager base-type is involved - if so: forward the method and return `true`, if not: just say `false`; the memory manager would be akin to:\r\n\r\n``` c#\r\npublic abstract class RefCountedMemoryManager\u003cT\u003e : MemoryManager\u003cT\u003e\r\n{\r\n    public abstract void Preserve();\r\n    public abstract void Release();\r\n}\r\n\r\npublic static class MemoryExtensions\r\n{\r\n    // ...\r\n    public static bool TryPreserve(this Memory\u003cT\u003e memory)\r\n    {\r\n        if (MemoryMarshal.TryGetMemoryManager\u003cRefCountedMemoryManager\u003cT\u003e, T\u003e(memory, out var manager))\r\n        {\r\n            manager.Preserve();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // ... (3 methods, presumably for Memory\u003cT\u003e and ReadOnlyMemory\u003cT\u003e; perhaps also `ReadOnlySequence\u003cT\u003e`)\r\n}\r\n```\r\n\r\n(edit: it has also been suggested by @davidfowl to use methods like `SequenceMarshal.TryPreserve` etc and make them non-extension methods - to make them harder to find and use incorrectly; I can see the wisdom of this!)\r\n\r\nIf desired, a lot of the thread-safe count management could be handled by a default implementation, just leaving the final \"I\u0027m at zero; release the thing\" for the implementor.\r\n\r\nIt may be desirable to include a slab-based memory allocator, although perhaps implementations are best left to specific scenarios.\r\n\r\n### API Usage\r\n\r\nscenario 1:\r\n\r\na custom allocator API is provided to a serialization library, so: when constructing `Memory\u003cbyte\u003e`, it uses that allocator to get memory, without needing to know anything about them (the allocator API is not part of this discussion); that allocator would obtain chunks from a slab, calling `TryPreserve()` to increment the count; consuming code can then do:\r\n\r\n```\r\nclass Foo : IDisposable\r\n{\r\n    public Memory\u003cbyte\u003e SomePayload {get;}\r\n    // ...\r\n    public void Dispose()\r\n    {\r\n        SomePayload.TryRelease();\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\nAs payloads are released, the slab\u0027s counter eventually reaches zero and the data is efficiently recycled\r\n\r\n---\r\n\r\nscenario 2:\r\n\r\na protocol handler sees data from a `Pipe` - this could be a single `Memory\u003cbyte\u003e` segment, or a `ReadOnlySequence\u003cbyte\u003e` by considering each segment in turn; assume that the `Pipe` is pooling aware, meaning: the memory allocator is already incrementing the counter when handing it out; when done (`AdvanceTo`, end-of-block), it would then call `TryRelease()`.\r\n\r\nthe protocol handler choosing to process data on a separate worker, it would call `TryPreserve()` on the data; if this returns `true`, it can simply continue, safe that the data is now protected and will outlive the `Pipe`\u0027s recycle (otherwise, a defensive copy will be needed, which it already needs today for this scenario). The worker then picks up this data, processes it, and calls `TryRelease`. At the later of the second `TryRelease` from the `Pipe` and the protocol worker, the data becomes recycled as appropriate.\r\n\r\n\r\n\r\n### Alternative Designs\r\n\r\n- `IMemoryOwner\u003cT\u003e` and accept the allocations\r\n- a fatter memory-like-type\r\n\r\n(neither of which works with `ReadOnlySequence\u003cT\u003e`)\r\n\r\n\r\n### Risks\r\n\r\nIf you screw up ref-counting: you can release data too soon, or not-at-all. In the not-at-all case GC still kicks in, although we\u0027re likely to be talking about larger slabs, so: it is an advanced API that should only be used in specific scenarios; it is not envisaged as massive *numbers of direct consumers*, but the indirect usage is very significant.\r\n\r\nUltimately, this is no different to the array-pool usage today - just: the array-pool is essentially just count of one or zero. If you release data too soon, or multiple times, to the array-pool: bad things. Same story.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHORS6dJg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5Dhvgn",
                                           "createdAt":  "2022-05-20T13:44:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-05-20T13:44:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DhwAp",
                                           "createdAt":  "2022-05-20T13:46:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mgravell",
                                           "body":  "Thanks bot; I\u0027m guessing this is area-System.Memory or area-System.Buffers, both of which are @jeffhandley - but I don\u0027t have write-permissions for that.",
                                           "updatedAt":  "2022-05-20T13:46:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Dh2xN",
                                           "createdAt":  "2022-05-20T14:14:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\r\n\r\n`Memory\u003cT\u003e`/`Span\u003cT\u003e` (and the read-only variants, and `ReadOnlySequence\u003cT\u003e`) are awesome. However, they have some weaknesses when it comes to pooling and lifetime considerations. When the lifetime is scoped inside a single deterministic context (i.e. \"rent, do a thing, return\"), it works great; but when lifetime needs to pass *outside* of that context: things get wobbly.\r\n\r\nNote: this only matters for high throughput scenarios - it is niche; but those scenarios happen *a lot*; I have multiple examples from within MSFT, and from external consumers, where this is a bottleneck.\r\n\r\nExample scenarios:\r\n\r\n1. a deserializer (for something like RPC, or whatever) needs to create some payloads - for example `Memory\u003cbyte\u003e` for raw blob payloads (which happens more than you might expect), or `ReadOnlyMemory\u003cSomeChunkyStruct\u003e` for the \"items\" data associated with a request - and wants to do that *as efficiently as possible* (again: very high volume); what we want to do is implement `IDisposable` on the type, and have the type release the data when possible\r\n2. some protocol parser (think Kestrel/pipelines) sees data that it is receiving from a `Pipe`; rather than copy this data out to a separate pool to offload it (so the `Pipe` can keep looking for more frames), it would like to \"preserve\" this memory, so that it can be passed as a QUWI/Task/whatever to a marshaller on a different thread to parse, which can then release this data at some undetermined future time\r\n\r\nexisting parallels:\r\n\r\n1. There is already `IMemoryOwner\u003cT\u003e`, which allows `Dispose()` later; this would *sort of* fit scenario 1, but it forces an object allocation *per memory* (because of the API shape); it doesn\u0027t fit sequential slab allocation very well, and it does not fit scenario 2 at all.\r\n2. The array pool a partial fit, and `MemoryMarshal.TryGetArray` allows us to see that data *can be considered an array*, but: we can\u0027t see which (if any) array pool data came from, nor can we tell if the data we\u0027re looking at is one slice of something that has actually be sliced and diced multiple times from the array.\r\n3. It is possible to construct a custom `Memory\u003cT\u003e`-like type which has a \"do this thing afterwards\" callback, but this creates yet more memory-like types, and the requirement to store *at least* a delegate (and more likely: a delegate and state object, i.e. something like `Action\u003cobject, Memory\u003cT\u003e\u003e callback`) in addition to the existing `Memory\u003cT\u003e` fields: makes the type very wide and expensive.\r\n\r\nI would like to address both of these at the BCL layer in a common API, based on experiments that I have performed successfully locally. In particular, using custom memory managers and the existing memory API mean that the system also extends naturally to work with `ReadOnlySequence\u003cT\u003e`, for larger payloads (note: caveat here: netfx has a bug in `ReadOnlySequence\u003cT\u003e` which is now fixed in code but not yet deployed; see https://github.com/dotnet/runtime/issues/67295). Using a custom memory manager means that `Memory\u003cT\u003e` and `ReadOnlyMemory\u003cT\u003e` can be used directly without any additional field cost, and it can be used in existing types. This custom memory manager (which could be, for example, a slab that underpins the data) would then essentially have ref-counting, with \"preserve\" (including pin) being +1 and \"release\" (/dispose? also: including unpin) being -1; when it hits zero: *then* the memory manager performs whatever the appropriate action is for this scenario.\r\n\r\nExisting memory uses that aren\u0027t using this category of memory-manager: are unaffected.\r\n\r\n---\r\n\r\nNote: I\u0027ve implemented this model multiple times in isolation, but that usage is then library specific and cannot be consumed readily over multiple libraries.\r\n\r\n### API Proposal\r\n\r\nThis essentially boils down to 2 methods (3 if we want to be able to test \"do you support this?\" without changing the count), and a base-type memory-manager:\r\n\r\n1. `bool TryPreserve()`\r\n2. `bool TryRelease()`\r\n3 `bool SupportsPreserve()`\r\n\r\nThese could either be provided via extension method, or directly on `Memory\u003cT\u003e` - I would suggest the extension method is less friction; and would check (for example, via `TryGetMemoryManager` if extn, or directly on the object if via `Memory\u003cT\u003e`) whether the new memory-manager base-type is involved - if so: forward the method and return `true`, if not: just say `false`; the memory manager would be akin to:\r\n\r\n``` c#\r\npublic abstract class RefCountedMemoryManager\u003cT\u003e : MemoryManager\u003cT\u003e\r\n{\r\n    public abstract void Preserve();\r\n    public abstract void Release();\r\n}\r\n\r\npublic static class MemoryExtensions\r\n{\r\n    // ...\r\n    public static bool TryPreserve(this Memory\u003cT\u003e memory)\r\n    {\r\n        if (MemoryMarshal.TryGetMemoryManager\u003cRefCountedMemoryManager\u003cT\u003e, T\u003e(memory, out var manager))\r\n        {\r\n            manager.Preserve();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // ... (3 methods, presumably for Memory\u003cT\u003e and ReadOnlyMemory\u003cT\u003e; perhaps also `ReadOnlySequence\u003cT\u003e`)\r\n}\r\n```\r\n\r\n(edit: it has also been suggested by @davidfowl to use methods like `SequenceMarshal.TryPreserve` etc and make them non-extension methods - to make them harder to find and use incorrectly; I can see the wisdom of this!)\r\n\r\nIf desired, a lot of the thread-safe count management could be handled by a default implementation, just leaving the final \"I\u0027m at zero; release the thing\" for the implementor.\r\n\r\nIt may be desirable to include a slab-based memory allocator, although perhaps implementations are best left to specific scenarios.\r\n\r\n### API Usage\r\n\r\nscenario 1:\r\n\r\na custom allocator API is provided to a serialization library, so: when constructing `Memory\u003cbyte\u003e`, it uses that allocator to get memory, without needing to know anything about them (the allocator API is not part of this discussion); that allocator would obtain chunks from a slab, calling `TryPreserve()` to increment the count; consuming code can then do:\r\n\r\n```\r\nclass Foo : IDisposable\r\n{\r\n    public Memory\u003cbyte\u003e SomePayload {get;}\r\n    // ...\r\n    public void Dispose()\r\n    {\r\n        SomePayload.TryRelease();\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\nAs payloads are released, the slab\u0027s counter eventually reaches zero and the data is efficiently recycled\r\n\r\n---\r\n\r\nscenario 2:\r\n\r\na protocol handler sees data from a `Pipe` - this could be a single `Memory\u003cbyte\u003e` segment, or a `ReadOnlySequence\u003cbyte\u003e` by considering each segment in turn; assume that the `Pipe` is pooling aware, meaning: the memory allocator is already incrementing the counter when handing it out; when done (`AdvanceTo`, end-of-block), it would then call `TryRelease()`.\r\n\r\nthe protocol handler choosing to process data on a separate worker, it would call `TryPreserve()` on the data; if this returns `true`, it can simply continue, safe that the data is now protected and will outlive the `Pipe`\u0027s recycle (otherwise, a defensive copy will be needed, which it already needs today for this scenario). The worker then picks up this data, processes it, and calls `TryRelease`. At the later of the second `TryRelease` from the `Pipe` and the protocol worker, the data becomes recycled as appropriate.\r\n\r\n\r\n\r\n### Alternative Designs\r\n\r\n- `IMemoryOwner\u003cT\u003e` and accept the allocations\r\n- a fatter memory-like-type\r\n\r\n(neither of which works with `ReadOnlySequence\u003cT\u003e`)\r\n\r\n\r\n### Risks\r\n\r\nIf you screw up ref-counting: you can release data too soon, or not-at-all. In the not-at-all case GC still kicks in, although we\u0027re likely to be talking about larger slabs, so: it is an advanced API that should only be used in specific scenarios; it is not envisaged as massive *numbers of direct consumers*, but the indirect usage is very significant.\r\n\r\nUltimately, this is no different to the array-pool usage today - just: the array-pool is essentially just count of one or zero. If you release data too soon, or multiple times, to the array-pool: bad things. Same story.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003emgravell\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Memory`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-05-20T14:14:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5FLp0m",
                                           "createdAt":  "2022-06-20T17:15:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "@GrabYourPitchforks @jkotas was this problem discussed in the past? ",
                                           "updatedAt":  "2022-06-20T17:15:49Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "[API Proposal]: [ReadOnly]Memory\u003cT\u003e lifetime / pooling considerations",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/72968",
        "createdAt":  "2022-07-27T23:17:47Z",
        "number":  72968,
        "author":  "GrabYourPitchforks",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCo87ew==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2022-07-27T23:18:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Enderlook",
                                            "createdAt":  "2022-07-27T23:32:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Joe4evr",
                                            "createdAt":  "2022-07-28T04:46:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Tornhoof",
                                            "createdAt":  "2022-07-28T04:55:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DaZombieKiller",
                                            "createdAt":  "2022-07-28T07:22:15Z"
                                        }
                                    ],
                          "totalCount":  5
                      },
        "updatedAt":  "2023-07-24T23:00:16Z",
        "body":  "## API proposal: `MemoryExtensions.ReferenceEqual`\r\n\r\nSee https://github.com/dotnet/runtime/issues/54794 for context. In a nutshell, we want developers to stop using the equality and inequality operators on `Span\u003cT\u003e` and `ReadOnlySpan\u003cT\u003e`.\r\n\r\n```cs\r\nReadOnlySpan\u003cchar\u003e span1, span2;\r\n\r\n// Don\u0027t do this\r\n// It checks for *referential* equality, which you probably didn\u0027t intend!\r\nbool areEqual = (span1 == span2);\r\n\r\n// Do this instead\r\n// It checks for *content* equality, which you probably intended.\r\nbool areEqual = span1.SequenceEqual(span2);\r\n```\r\n\r\nBut there are some cases where callers really do need to check for referential equality, such as if they\u0027re trying to special-case \"an arbitrary empty span\" vs. \"a span that specifically references _nullptr_.\" Another use case is string interning dictionaries, where callers may want to know as an optimization whether a span references _a specific instance_ of a string value rather than simply containing the same contents.\r\n\r\n### Proposed API\r\n\r\n```cs\r\nnamespace System\r\n{\r\n    // new APIs added to existing class (asm: System.Memory)\r\n    public partial static class MemoryExtensions\r\n    {\r\n        public static bool ReferenceEqual\u003cT\u003e(this ReadOnlySpan\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other);\r\n        public static bool ReferenceEqual\u003cT\u003e(this Span\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other);\r\n    }\r\n}\r\n```\r\n\r\n### Discussion\r\n\r\nIf we eventually obsolete the span equality comparison operators, callers will need to answer the question \"was this comparison intended to be a referential equality comparison or a value equality comparison?\" We\u0027re betting on that most callers wanted value equality and will opt to change their call sites to target the existing `SequenceEqual` method. The new `ReferenceEqual` method proposed here provides an alternative for developers to preserve reference-equality comparison without needing to `#pragma warning disable ...` every call to the existing equality operators.\r\n\r\n.NET already exposes two related contepts: `static bool object.ReferenceEquals(object, object)`, which is pure referential equality; and `static bool MemoryExtensions.SequenceEqual\u003cT\u003e(Span\u003cT\u003e, Span\u003cT\u003e) where T : IEquatable\u003cT\u003e`, which performs content equality comparison.\r\n\r\nFor consistency with the existing `MemoryExtensions.SequenceEqual` API, we\u0027ll keep its parameter names in the proposed `MemoryExtensions.ReferenceEqual` API. We\u0027ll also drop the _s_ from `ReferenceEquals` to match the existing extension method naming conventions.\r\n\r\n### Risks\r\n\r\nThe name `ReferenceEqual` might inadvertently convey \"_only_ referential equality\" instead of the intended \"_both_ referential _and_ length equality\" behavior. That is, somebody might expect the following to return _true_.\r\n\r\n```cs\r\nReadOnlySpan\u003cchar\u003e span1 = \"Hello!\";\r\nReadOnlySpan\u003cchar\u003e span2 = span1.Slice(0, 2);\r\nbool equal = span1.ReferenceEqual(span2); // they both start at (reference) the same place!\r\n```\r\n\r\nWe may be able to mitigate this risk through careful messaging and encouraging callers to think about \"references to blocks of memory\" rather than \"references to addresses in memory\". If you consider that a block of memory contains both a start and an end position - as distinct from just a single address - then the analogy makes sense.\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOSC9_uA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5HYCmU",
                                           "createdAt":  "2022-07-27T23:27:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCpvUzA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "acaly",
                                                                               "createdAt":  "2022-07-30T16:23:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "adamsitnik",
                                                                               "createdAt":  "2022-08-02T15:28:00Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "alexrp",
                                           "body":  "\u003e The name `ReferenceEqual` might inadvertently convey \"only referential equality\"\r\n\r\nFWIW, that was what I expected at first glance.\r\n\r\nConsidering that and the potential confusion with `object.ReferenceEquals()`, I feel like there has to be a better name here, though I don\u0027t have any good suggestions off the top of my head.",
                                           "updatedAt":  "2022-07-27T23:27:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HZHWn",
                                           "createdAt":  "2022-07-28T07:24:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCqAv2w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alexrp",
                                                                               "createdAt":  "2022-07-28T08:12:14Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "sakno",
                                                                               "createdAt":  "2022-07-28T11:06:55Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "adamsitnik",
                                                                               "createdAt":  "2022-08-02T15:20:06Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Joe4evr",
                                                                               "createdAt":  "2022-08-04T10:12:45Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "DaZombieKiller",
                                           "body":  "\u003e I feel like there has to be a better name here, though I don\u0027t have any good suggestions off the top of my head.\r\n\r\nMaybe `MemoryMarshal.AreSame`/`MemoryExtensions.IsSame`, mirroring `Unsafe.AreSame`?",
                                           "updatedAt":  "2022-07-28T07:24:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HZ0rH",
                                           "createdAt":  "2022-07-28T10:19:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Joe4evr",
                                           "body":  "\u003e The name `ReferenceEqual` might inadvertently convey \"_only_ referential equality\" instead of the intended \"_both_ referential _and_ length equality\" behavior. That is, somebody might expect the following to return _true_.\r\n\r\n`ReferenceAndLengthEquals`? 🙃 ",
                                           "updatedAt":  "2022-07-28T10:19:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Havlq",
                                           "createdAt":  "2022-07-28T14:08:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "I had considered \"are same\" but didn\u0027t like it because \"same\" and \"equal\" are too similar. The ambiguity would still exist.\n\nAnother alternative is `RangeEqual`, which clearly indicates it\u0027s talking about a range of memory. It also works with the Range slicing operator, which is a nice coincidence.",
                                           "updatedAt":  "2022-07-28T14:08:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Htle9",
                                           "createdAt":  "2022-08-02T19:34:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "terrajobst",
                                           "body":  "* We don\u0027t like `ReferenceEquals` because it\u0027s not clear that it covers start and length (as opposed to just start)\r\n\r\n```C#\r\nnamespace System;\r\n\r\npublic partial static class MemoryExtensions\r\n{\r\n    public static bool ReferenceEqual\u003cT\u003e(this ReadOnlySpan\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other);\r\n    public static bool ReferenceEqual\u003cT\u003e(this Span\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other);\r\n}\r\n```",
                                           "updatedAt":  "2022-08-02T19:34:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HvA_p",
                                           "createdAt":  "2022-08-03T05:39:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlreinke",
                                           "body":  "`IdentityEqual`?",
                                           "updatedAt":  "2022-08-03T05:39:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5IL3-4",
                                           "createdAt":  "2022-08-10T18:05:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "Moving to 8.0.0 since we don\u0027t have agreement on the name yet.",
                                           "updatedAt":  "2022-08-10T18:05:16Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "API proposal: MemoryExtensions.ReferenceEqual",
        "labels":  [
                       "api-needs-work",
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/75317",
        "createdAt":  "2022-09-09T01:01:26Z",
        "number":  75317,
        "author":  "neon-sunset",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC-eEdQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MichalPetryka",
                                            "createdAt":  "2022-09-09T11:28:52Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "budgetdevv",
                                            "createdAt":  "2022-09-28T03:39:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "GSPP",
                                            "createdAt":  "2022-10-06T10:46:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "antomys",
                                            "createdAt":  "2023-06-26T15:22:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jnm2",
                                            "createdAt":  "2024-04-27T10:57:28Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "jnm2",
                                            "createdAt":  "2024-04-27T10:57:31Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "reflectronic",
                                            "createdAt":  "2024-04-27T21:39:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MaxMahem",
                                            "createdAt":  "2025-01-26T06:26:26Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "MaxMahem",
                                            "createdAt":  "2025-01-26T06:26:34Z"
                                        }
                                    ],
                          "totalCount":  9
                      },
        "updatedAt":  "2025-01-28T05:49:03Z",
        "body":  "### Background and motivation\r\n\r\nWhile working with various solutions both internal and external, it appears there is a commonly used pattern to split strings just once which can be improved with an allocation-free helper.\r\n\r\nSpecifically, such patterns are especially common when processing headers, fields in JSON payloads, delimited pairs of values, etc.\r\nFor example, when handling OAuth2.0 headers, the often found pattern is the following:\r\n```cs\r\nvar header = \"Authorization: Bearer mF_9.B5f-4.1JqM\";\r\nvar token = header.Split(\u0027:\u0027)[1].Trim();\r\n// remove \u0027Bearer\u0027 and handle auth\r\n```\r\n\r\nWhile it has acceptable performance, we may be able to do better by providing convenience methods which would allow to handle \"split once\" cases idiomatically while simultaneously nudging the developers towards performance-oriented APIs.\r\n\r\nIn fact, when dealing with similar scenarios, Rust decided to explicitly have a dedicated function over consuming a split iterator: https://doc.rust-lang.org/std/primitive.str.html#method.split_once.\r\n\r\nUPD: Proposal amended with `SplitFirst/SplitLast` suggestion by @MichalPetryka\r\n\r\n### API Proposal\r\n#### Concerns and open questions\r\nQ: Too many overloads / the API is unnecessarily complex\r\nA: It\u0027s a suggested tradeoff in order to support `string`, `{ReadOnly}Memory\u003cT\u003e` and  `{ReadOnly}Span\u003cT\u003e`. The rationale behind it is to reduce boilerplate and have good discoverability i.e. when writing `string.Split` it becomes very easy to discover and use `.SplitFirst` without having to \"know\" that such API exists beforehand.\r\n\r\nQ: `StringComparison` overloads\r\nA: They have been omitted for brevity. It may be profitable to either add them or delegate them to a more complex APIs suggested in https://github.com/dotnet/runtime/issues/93 or https://github.com/dotnet/runtime/issues/76186. If you have any concerns, please let me know\r\n\r\nQ: Exception handling, `.Empty` span/memory vs `Exception`\r\nA: Since the API is intended to be used as a short-form, the suggested behavior is to return matched slices in `Segment` and `Remainder`, with `Remainder` being `IsEmpty` when the sliced source has no separator\r\n\r\n```csharp\r\npublic static class MemoryExtensions\r\n{\r\n    public static (string, string) SplitFirst(this string source, char separator);\r\n    public static (string, string) SplitFirst(this string source, ReadOnlySpan\u003cchar\u003e separator);\r\n\r\n    public static Split\u003cT\u003e SplitFirst\u003cT\u003e(this Span\u003cT\u003e source, T separator) where T : IEquatable\u003cT\u003e;\r\n    public static Split\u003cT\u003e SplitFirst\u003cT\u003e(this Span\u003cT\u003e source, ReadOnlySpan\u003cT\u003e separator) where T : IEquatable\u003cT\u003e;\r\n\r\n    public static ReadOnlySplit\u003cT\u003e SplitFirst\u003cT\u003e(this ReadOnlySpan\u003cT\u003e source, T separator) where T : IEquatable\u003cT\u003e;\r\n    public static ReadOnlySplit\u003cT\u003e SplitFirst\u003cT\u003e(this ReadOnlySpan\u003cT\u003e source, ReadOnlySpan\u003cT\u003e separator) where T : IEquatable\u003cT\u003e;\r\n\r\n    public static (Memory\u003cT\u003e Segment, Memory\u003cT\u003e Remainder) SplitFirst\u003cT\u003e(this Memory\u003cT\u003e source, T separator)  where T : IEquatable\u003cT\u003e;\r\n    public static (Memory\u003cT\u003e Segment, Memory\u003cT\u003e Remainder) SplitFirst\u003cT\u003e(this Memory\u003cT\u003e source, ReadOnlySpan\u003cT\u003e separator) where T : IEquatable\u003cT\u003e;\r\n\r\n    public static (ReadOnlyMemory\u003cT\u003e Segment, ReadOnlyMemory\u003cT\u003e Remainder) SplitFirst\u003cT\u003e(this ReadOnlyMemory\u003cT\u003e source, T separator) where T : IEquatable\u003cT\u003e;\r\n    public static (ReadOnlyMemory\u003cT\u003e Segment, ReadOnlyMemory\u003cT\u003e Remainder) SplitFirst\u003cT\u003e(this ReadOnlyMemory\u003cT\u003e source, ReadOnlySpan\u003cT\u003e separator) where T : IEquatable\u003cT\u003e;\r\n\r\n    public static (string, string) SplitLast(this string source, char separator);\r\n    public static (string, string) SplitLast(this string source, ReadOnlySpan\u003cchar\u003e separator);\r\n\r\n    public static Split\u003cT\u003e SplitLast\u003cT\u003e(this Span\u003cT\u003e source, T separator) where T : IEquatable\u003cT\u003e;\r\n    public static Split\u003cT\u003e SplitLast\u003cT\u003e(this Span\u003cT\u003e source, ReadOnlySpan\u003cT\u003e separator) where T : IEquatable\u003cT\u003e;\r\n\r\n    public static ReadOnlySplit\u003cT\u003e SplitLast\u003cT\u003e(this ReadOnlySpan\u003cT\u003e source, T separator) where T : IEquatable\u003cT\u003e;\r\n    public static ReadOnlySplit\u003cT\u003e SplitLast\u003cT\u003e(this ReadOnlySpan\u003cT\u003e source, ReadOnlySpan\u003cT\u003e separator) where T : IEquatable\u003cT\u003e;\r\n\r\n    public static (Memory\u003cT\u003e Segment, Memory\u003cT\u003e Remainder) SplitLast\u003cT\u003e(this Memory\u003cT\u003e source, T separator) where T : IEquatable\u003cT\u003e;\r\n    public static (Memory\u003cT\u003e Segment, Memory\u003cT\u003e Remainder) SplitLast\u003cT\u003e(this Memory\u003cT\u003e source, ReadOnlySpan\u003cT\u003e separator) where T : IEquatable\u003cT\u003e;\r\n\r\n    public static (ReadOnlyMemory\u003cT\u003e Segment, ReadOnlyMemory\u003cT\u003e Remainder) SplitLast\u003cT\u003e(this ReadOnlyMemory\u003cT\u003e source, T separator) where T : IEquatable\u003cT\u003e;\r\n    public static (ReadOnlyMemory\u003cT\u003e Segment, ReadOnlyMemory\u003cT\u003e Remainder) SplitLast\u003cT\u003e(this ReadOnlyMemory\u003cT\u003e source, ReadOnlySpan\u003cT\u003e separator) where T : IEquatable\u003cT\u003e;\r\n\r\n    // RefValueTuple? :)\r\n    public readonly ref struct Split\u003cT\u003e\r\n    {\r\n        public Span\u003cT\u003e Segment { get; }\r\n\r\n        public Span\u003cT\u003e Remainder { get; }\r\n\r\n        public void Deconstruct(out Span\u003cT\u003e segment, out Span\u003cT\u003e remainder);\r\n    }\r\n\r\n    public readonly ref struct ReadOnlySplit\u003cT\u003e\r\n    {\r\n        public ReadOnlySpan\u003cT\u003e Segment { get; }\r\n\r\n        public ReadOnlySpan\u003cT\u003e Remainder { get; }\r\n\r\n        public void Deconstruct(out ReadOnlySpan\u003cT\u003e segment, out ReadOnlySpan\u003cT\u003e remainder);\r\n    }\r\n}\r\n```\r\nReference impl.: https://gist.github.com/neon-sunset/df6fb9fe6bb71f11c2b47fbeae55e6da\r\n\r\n### API Usage\r\nSimple use\r\n```csharp\r\nvar (name, surname) = \"John-Doe\".SplitFirst(\u0027-\u0027);\r\n```\r\n\r\nMethod chaining\r\n```cs\r\nvar middleName = \"Stanley Bartholomew Burnside\"\r\n    .AsMemory()\r\n    .SplitFirst(\u0027 \u0027)\r\n    .Remainder\r\n    .SplitLast(\u0027 \u0027)\r\n    .Segment;\r\n```\r\n\r\nSlicing bearer token out of full header string\r\n```csharp\r\n// In async middleware\r\nvar header = \"Authorization: Bearer mF_9.B5f-4.1JqM\";\r\nvar token = header.AsMemory().SplitLast(\u0027 \u0027).Remainder.Trim();\r\n\r\nif (token.Length is 0)\r\n{\r\n  // set unauthorized\r\n}\r\n```\r\n\r\nRetrieving arbitrary data from a text field\r\n```csharp\r\nvar message = \"FinalNotification::Suspended\\r\\n\";\r\n\r\nvar (messageType, status) = message \r\n    .AsSpan()\r\n    .TrimEnd(\"\\r\\n\")\r\n    .SplitFirst(\"::\");\r\n```\r\n\r\n### Alternative Designs\r\n\r\nExisting `string.Split(...)` overloads, https://github.com/dotnet/runtime/issues/93 and https://github.com/dotnet/runtime/issues/76186\r\n\r\n### Risks\r\n\r\nMinimal, the API is intended to co-exist with more complex versions like split iterator suggested in an alternate design.\r\nIf there will be demand, it allows for further extension with `.Split{First/Last}(this Span\u003cT\u003e source...)` overloads.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOnAqF9w==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5J_gRT",
                                           "createdAt":  "2022-09-09T01:01:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nWhile working with various solutions both internal and external, it appears there is a commonly used pattern to split strings just once which can be improved with an allocation-free helper similar to `split_once()` function in Rust.\r\n\r\nSpecifically, such patterns are especially common when processing headers and fields in JSON payloads.\r\nFor example, when handling OAuth2.0 headers, the often found pattern is the following:\r\n```cs\r\nvar header = \"Authorization: Bearer mF_9.B5f-4.1JqM\";\r\nvar token = header.Split(\u0027:\u0027)[0].Trim();\r\n// remove \u0027Bearer\u0027 and handle auth\r\n```\r\n\r\nWhile it has acceptable performance, we may be able to do better by providing convenience methods which would allow to handle \"split once\" cases idiomatically while simultaneously nudging the developers towards performance-oriented APIs.\r\n\n\n### API Proposal\n\n```csharp\r\nnamespace System.Text:\r\n\r\npublic static class SplitHelpers\r\n{\r\n    public static (ReadOnlyMemory\u003cchar\u003e Left, ReadOnlyMemory\u003cchar\u003e Right) SplitOnce(\r\n        this string source, char separator);\r\n\r\n    public static (ReadOnlyMemory\u003cchar\u003e Left, ReadOnlyMemory\u003cchar\u003e Right) SplitOnce(\r\n        this string source, ReadOnlySpan\u003cchar\u003e separator);\r\n\r\n    public static (ReadOnlyMemory\u003cchar\u003e Left, ReadOnlyMemory\u003cchar\u003e Right) SplitOnce(\r\n        this ReadOnlyMemory\u003cchar\u003e source, char separator);\r\n\r\n    public static (ReadOnlyMemory\u003cchar\u003e Left, ReadOnlyMemory\u003cchar\u003e Right) SplitOnce(\r\n        this ReadOnlyMemory\u003cchar\u003e source, ReadOnlySpan\u003cchar\u003e separator);\r\n\r\n    public static ReadOnlySpanSplit\u003cchar\u003e SplitOnce(this ReadOnlySpan\u003cchar\u003e source, char separator);\r\n\r\n    public static ReadOnlySpanSplit\u003cchar\u003e SplitOnce(\r\n        this ReadOnlySpan\u003cchar\u003e source, ReadOnlySpan\u003cchar\u003e separator);\r\n\r\n    public static SpanSplit\u003cchar\u003e SplitOnce(this Span\u003cchar\u003e source, char separator);\r\n\r\n    public static SpanSplit\u003cchar\u003e SplitOnce(this Span\u003cchar\u003e source, ReadOnlySpan\u003cchar\u003e separator);\r\n\r\n    // RefValueTuple? :)\r\n    public readonly ref struct ReadOnlySpanSplit\u003cT\u003e\r\n    {\r\n        public readonly ReadOnlySpan\u003cT\u003e Left;\r\n\r\n        public readonly ReadOnlySpan\u003cT\u003e Right;\r\n        ...\r\n        public void Deconstruct(out ReadOnlySpan\u003cT\u003e left, out ReadOnlySpan\u003cT\u003e right)\r\n        {\r\n            left = Left;\r\n            right = Right;\r\n        }\r\n\r\n    public readonly ref struct SpanSplit\u003cT\u003e\r\n    {\r\n        public readonly ReadOnlySpan\u003cT\u003e Left;\r\n\r\n        public readonly ReadOnlySpan\u003cT\u003e Right;\r\n        ...\r\n        public void Deconstruct(out ReadOnlySpan\u003cT\u003e left, out ReadOnlySpan\u003cT\u003e right)\r\n        {\r\n            left = Left;\r\n            right = Right;\r\n        }\r\n    }\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nvar (name, surname) = \"John Doe\".SplitOnce(\u0027 \u0027);\r\n\r\nvar messageHeader = \"FinalNotification::Suspended\\r\\n\";\r\nvar (notificationKind, status) = messageHeader\r\n    .AsSpan()\r\n    .TrimEnd(\"\\r\\n\")\r\n    .SplitOnce(\"::\");\r\n```\r\n\r\nHeader example:\r\n```csharp\r\nvar header = \"Authorization: Bearer mF_9.B5f-4.1JqM\";\r\n\r\n// Get token slice out of string. Because split consists of two ROMs,\r\n// the operations are both allocation free and work in scenarios like async middleware\r\nvar token = header.SplitOnce(\u0027:\u0027).Right.Trim();\r\n```\n\n### Alternative Designs\n\nEither keep using currently available methods or rely on hand-written/nuget extensions.\n\n### Risks\n\nBecause `string.SplitOnce(...` will return a tuple of two `ReadOnlyMemory\u003cchar\u003e` slices, the users that haven\u0027t worked with spans/memory previously might have to check documentation.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eneon-sunset\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Memory`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-09-09T01:01:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KBKZz",
                                           "createdAt":  "2022-09-09T10:50:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "neon-sunset",
                                           "body":  "Here are the numbers for prototype impl. that can only handle `char` separator from https://gist.github.com/neon-sunset/df6fb9fe6bb71f11c2b47fbeae55e6da\r\n```cs\r\n[MemoryDiagnoser]\r\npublic class SplitBenchmarks\r\n{\r\n    [Params(\r\n        \"Authorization: test-token\",\r\n        \"longstringlongstringlongstringlongstringlongstring:longstringlongstring\")]\r\n    public string Value = string.Empty;\r\n\r\n    [Benchmark(Baseline = true)]\r\n    public int Split() =\u003e Value.Split(\u0027:\u0027)[1].Length;\r\n\r\n    [Benchmark]\r\n    public int SplitOnce() =\u003e Value.SplitOnce(\u0027:\u0027).Right.Length;\r\n}\r\n```\r\n``` ini\r\nBenchmarkDotNet=v0.13.1, OS=macOS 13.0 (22A5331f) [Darwin 22.1.0]\r\nApple M1 Pro, 1 CPU, 8 logical and 8 physical cores\r\n.NET SDK=7.0.100-rc.2.22452.3\r\n  [Host]     : .NET 7.0.0 (7.0.22.42212), Arm64 RyuJIT\r\n  DefaultJob : .NET 7.0.0 (7.0.22.42212), Arm64 RyuJIT\r\n```\r\n|    Method |                Value |      Mean |     Error |    StdDev | Ratio |  Gen 0 | Allocated |\r\n|---------- |--------------------- |----------:|----------:|----------:|------:|-------:|----------:|\r\n|     **Split** | **Autho(...)token [25]** | **27.656 ns** | **0.0579 ns** | **0.0484 ns** |  **1.00** | **0.0026** |     **136 B** |\r\n| SplitOnce | Autho(...)token [25] |  9.679 ns | 0.0789 ns | 0.0700 ns |  0.35 |      - |         - |\r\n|           |                      |           |           |           |       |        |           |\r\n|     **Split** | **longs(...)tring [71]** | **38.610 ns** | **0.1104 ns** | **0.1033 ns** |  **1.00** | **0.0045** |     **232 B** |\r\n| SplitOnce | longs(...)tring [71] | 11.267 ns | 0.0596 ns | 0.0557 ns |  0.29 |      - |         - |\r\n",
                                           "updatedAt":  "2022-09-09T10:51:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KBikd",
                                           "createdAt":  "2022-09-09T12:29:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ovska",
                                           "body":  "Seems like a large and complicated api surface, considering it can be done with an `IndexOf` and two slices, as is done the linked implementation.",
                                           "updatedAt":  "2022-09-10T10:55:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KBuCx",
                                           "createdAt":  "2022-09-09T13:16:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "There\u0027s also an existing proposal with a lot of discussion and work around splitting support for spans here:\r\nhttps://github.com/dotnet/runtime/issues/934",
                                           "updatedAt":  "2022-09-09T13:16:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KBwc2",
                                           "createdAt":  "2022-09-09T13:26:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "neon-sunset",
                                           "body":  "\u003e There\u0027s also an existing proposal with a lot of discussion and work around splitting support for spans here:\r\n\u003e #934\r\n\r\nThanks, I have seen the linked proposal but thought the above use case is a \"low hanging fruit\" that can serve one of the most often used `.Split()` scenarios sufficient to warrant a separate proposal.",
                                           "updatedAt":  "2022-09-14T23:33:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KBzDf",
                                           "createdAt":  "2022-09-09T13:36:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e but thought the above use case is a \"low hanging fruit\"\r\n\r\nIt just doesn\u0027t seem like it saves a lot.  Presumably all of these would have to throw an exception if the separator wasn\u0027t found (putting everything into one of the two sides seems arbitrary and likely bug-inducing), and I\u0027m not sure that actually maps to the majority use case where this would be used (you have a header parsing example, but I struggle to imagine real-world usage for header parsing that would be ok with the proposed semantics when the separator wasn\u0027t found).  And even then it\u0027s not saving a whole lot, e.g.\r\n```C#\r\n(ReadOnlySpan\u003cchar\u003e firstName, ReadOnlySpan\u003cchar\u003e lastName) = name.SplitFirst(\u0027 \u0027);\r\n```\r\ninstead of:\r\n```C#\r\nint pos = name.IndexOf(\u0027 \u0027);\r\nReadOnlySpan\u003cchar\u003e firstName = name[0..pos];\r\nReadOnlySpan\u003cchar\u003e lastName = name[pos+1..];\r\n```\r\nwhere the latter is also more flexible, doesn\u0027t require learning about a new method, etc.\r\n\r\nPersonally, it doesn\u0027t seem worth it to me.  Happy to hear opinions from others, though.",
                                           "updatedAt":  "2022-09-09T13:36:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KB33e",
                                           "createdAt":  "2022-09-09T13:54:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "neon-sunset",
                                           "body":  "\u003e Presumably all of these would have to throw an exception if the separator wasn\u0027t found (putting everything into one of the two sides seems arbitrary and likely bug-inducing), and I\u0027m not sure that actually maps to the majority use case where this would be used (you have a header parsing example, but I struggle to imagine real-world usage for header parsing that would be ok with the proposed semantics when the separator wasn\u0027t found).\r\n\r\nAgree, I don\u0027t have a strong opinion on which is better, throwing an exception or returning the right slice as empty. Implementation-wise, not all code wants EH and the expectation is to just check `right.Length is 0` since there was no separator therefore there is nothing to \"split off\".\r\n\r\n~~The intention is to nudge developers who don\u0027t know or don\u0027t use slice-like types to `ROM\u003cchar\u003e` and etc. towards more performant code. Someone would just write `var (_, trailer) = string.SplitLast(...);` without thinking twice and get the desired behavior.~~",
                                           "updatedAt":  "2023-01-13T17:51:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5LHyzD",
                                           "createdAt":  "2022-09-28T03:19:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "neon-sunset",
                                           "body":  "The API proposal has been updated with the following changes:\r\n1. Align `this string source` overload to return `(string, string)` which is consistent with BCL convention for `string.Trim()` vs `span.Trim()`;\r\n2. Add short Q\u0026A section to provide additional context\r\n3. Reformat API definition for readability",
                                           "updatedAt":  "2023-01-13T17:31:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5fUiyd",
                                           "createdAt":  "2023-06-20T17:28:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "neon-sunset",
                                           "body":  "Is there anything that can be done to move forward with the proposal?\r\n\r\nThe pattern appears to be quite popular: https://grep.app/search?q=%5C.Split%5C%28%27.%28.%29%27%5C%29%5C%5B%28.%29%5C%5D\u0026regexp=true\u0026case=true\u0026filter[lang][0]=C%23",
                                           "updatedAt":  "2023-06-20T17:28:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc58ARjV",
                                           "createdAt":  "2024-04-27T10:36:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "neon-sunset",
                                           "body":  "@dotnet/area-system-memory is there any work or discussion required for this proposal to become ready for review?",
                                           "updatedAt":  "2024-04-27T10:36:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc58A2wM",
                                           "createdAt":  "2024-04-27T12:58:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e @dotnet/area-system-memory is there any work or discussion required for this proposal to become ready for review?\r\n\r\nI continue to not see it as being worthwhile. A lot of surface area for something that\u0027s already supported in multiple ways.",
                                           "updatedAt":  "2024-04-27T13:04:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc58BB2W",
                                           "createdAt":  "2024-04-27T13:20:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "neon-sunset",
                                           "body":  "Working with strings in advanced implementations in C# is very nice through spans, and such a scenario is well-covered there, yes.\r\n\r\nHowever, the average user will not be reaching out for those, and may even be (incorrectly) advised to avoid them. I believe there is surprisingly big gap between an analyzer suggesting to replace `text.Split(\u0027,\u0027, 2)[0]` with `text.SplitFirst(\u0027,\u0027).Segment` and reaching for the three-liner with a span, in how the user arrives upon these.\r\n\r\nIt seems *not* doing so would go against overall trend of C# to offer more APIs to streamline common operations in a performant way.\r\n\r\nI understand that it *is* trivial and not worth it for a caliber of developer that works on optimizing .NET, but that\u0027s not the case for the average codebase more preoccupied with moving a json from an incoming request to an entity in DB, so the cost accrues.\r\n\r\nPlease close/reject the proposal if you believe that such API does not make sense in .NET.",
                                           "updatedAt":  "2024-04-27T13:32:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6b0hJT",
                                           "createdAt":  "2025-01-26T06:34:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEECGQQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "neon-sunset",
                                                                               "createdAt":  "2025-01-26T07:01:08Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "MaxMahem",
                                           "body":  "FWIW I independently came up with a similar implementation, which I found very useful for working with Spans. So I at least found this API valuable.",
                                           "updatedAt":  "2025-01-26T06:34:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6b7wjI",
                                           "createdAt":  "2025-01-27T15:52:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEEPkkw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "neon-sunset",
                                                                               "createdAt":  "2025-01-28T05:34:50Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jilles-sg",
                                           "body":  "I think this can be valuable if the API is improved to make it easier to check whether the separator was found. For example (using `ReadOnlySpan\u003cchar\u003e` since it\u0027s most restrictive):\n\n- Returning a boolean and passing the segments via `out` parameters.\n- Returning a `ref struct` that pretends to be an array of one or two `ReadOnlySpan\u003cchar\u003e` with a `Length` property and an indexer.\n\nThe latter can be consumed by indexing `[0]`, `[1]` or `[^1]` or using a list pattern.\n\nAlthough the number of lines saved per use of the API is low, it is common in some kinds of code.\n\nIt might be enough to have methods for `ReadOnlySpan\u003cT\u003e where T: IEquatable\u003cT\u003e` only (so `ReadOnlySpan\u003cchar\u003e` and `ReadOnlySpan\u003cbyte\u003e`) since the other cases would be rarer, and often when splitting a `string` it\u0027s not needed to materialize both segments as a `string`.",
                                           "updatedAt":  "2025-01-27T15:52:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6cCk6A",
                                           "createdAt":  "2025-01-28T05:25:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MaxMahem",
                                           "body":  "As for the \"how to handle delimiter not found\" case I think returning the entire string in the first span and an empty segment in the second is the most logical.\n\n1. This matches the behavior of `String.Split`, which returns the entire string as the only element of an array if the delimiter is not found.\n2. It feels like a logical response to the instruction given by the method. \"Split this span into portions before and after this delimiter.\" Since the marker is not found, all elements lie before it.\n3. If the result is some sort of deconstructable container, an empty span can handled via pattern matching, ala:\n```cs\nvar (left, right) = span.SplitFirst(delimiter) is (_, not []) split ? split : throw new Exception(\"Delimiter Not Found\");\n```",
                                           "updatedAt":  "2025-01-28T05:26:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6cCoX3",
                                           "createdAt":  "2025-01-28T05:38:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "neon-sunset",
                                           "body":  "@jilles-sg funnily enough, the indexer segment access (with deconstruction alternative) is what I settled on in the latest iteration of internal helpers to deal with this too. Works nicely whenever the index is a constant. I don\u0027t distinguish whether the separator was found for `SplitOnce` however. If someone needs a stricter implementation, they can do it with IndexOf. The common case usually either cares about slicing off a segment or splitting key-value pairs into two where input is either known to be valid or the downstream logic would fail regardless when e.g. integer parsing. The choices can be yak shaved here but ultimately it is most important for the extension to be completely optimal and easy to use in the common scenario.\n\nAlternatively, we can also mirror parsing: throwing `SplitOnce` and non-throwing `TrySplitOnce` variants. Rust implementation does this by returning `Option\u003c(\u0026str, \u0026str)\u003e` - closer to the latter.\n\nWhat matters most is getting anything that let\u0027s us finally do away with every new codebase having tons of `text.Split(\u0027=\u0027)[0]` and `text.Split(\u0027=\u0027)[1]`s that need to be fixed :)",
                                           "updatedAt":  "2025-01-28T05:49:03Z"
                                       }
                                   ],
                         "totalCount":  16
                     },
        "title":  "[API Proposal]: SplitFirst/SplitLast methods for strings and (ReadOnly)Span/Memory\u003cT\u003e slices",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/75642",
        "createdAt":  "2022-09-14T22:00:19Z",
        "number":  75642,
        "author":  "stephentoub",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC-S3iQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DaMatrix",
                                            "createdAt":  "2022-12-18T19:29:20Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "neon-sunset",
                                            "createdAt":  "2023-05-11T09:07:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "GaryHuan9",
                                            "createdAt":  "2023-07-07T13:34:04Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kzrnm",
                                            "createdAt":  "2023-11-02T18:38:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hendriklhf",
                                            "createdAt":  "2023-11-22T11:54:57Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MineCake147E",
                                            "createdAt":  "2024-02-07T08:45:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "JeremyKuhne",
                                            "createdAt":  "2024-06-12T22:40:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "adamsitnik",
                                            "createdAt":  "2024-06-13T09:17:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-06-20T10:50:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MrJul",
                                            "createdAt":  "2024-10-24T15:34:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "frederik-hoeft",
                                            "createdAt":  "2024-12-01T15:48:45Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dotlogix",
                                            "createdAt":  "2025-01-20T15:03:49Z"
                                        }
                                    ],
                          "totalCount":  12
                      },
        "updatedAt":  "2023-07-08T14:32:11Z",
        "body":  "### Background and motivation\r\n\r\nMost of our vectorized implementations on MemoryExtensions check RuntimeHelpers.IsBitwiseEquatable to determine whether vectorization is feasible.  Today, IsBitwiseEquatable is hardcoded to a finite list of primitive types; https://github.com/dotnet/runtime/pull/75640 extends that further, but overriding `Equals` / implementing `IEquatable\u003cT\u003e` opts you out again. Developers can still get the vectorization benefits of these implementations, but it\u0027s awkward and unsafe, e.g. with a type like:\r\n```C#\r\nstruct MyColor : IEquatable\u003cT\u003e { ... }\r\n```\r\ninstead of:\r\n```C#\r\nReadOnlySpan\u003cMyColor\u003e colors = ...;\r\nMyColor value = ...;\r\nreturn colors.IndexOf(value);\r\n```\r\nit\u0027s something more like:\r\n```C#\r\nReadOnlySpan\u003cMyColor\u003e colors = ...;\r\nMyColor value = ...;\r\nreturn MemoryMarshal.Cast\u003cMyColor, int\u003e(colors).IndexOf(Unsafe.As\u003cMyColor, int\u003e(ref value));\r\n```\r\nand most importantly, it\u0027s something someone has to write code for on each use rather than it \"just work\"ing.\r\n\r\nIf we instead expose a way for a type to be annotated as \"You can trust that my Equals override and/or IEquatable implementation are identical to bitwise equality semantics\", then we can special-case IsBitwiseEquatable to recognize this annotation, and everything else just lights up.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System;\r\n\r\npublic interface IBitwiseEquatable\u003cT\u003e : IEquatable\u003cT\u003e\r\n{\r\n    // no additional methods, it\u0027s just a marker interface\r\n}\r\n```\r\n\r\n### API Usage\r\n\r\n```C#\r\nstruct MyColor : IBitwiseEquatable\u003cMyColor\u003e\r\n{\r\n    private byte R, G, B, A;\r\n\r\n    public bool Equals(MyColor other) =\u003e R == other.R \u0026\u0026 G == other.G \u0026\u0026 B == other.B \u0026\u0026 A == other.A;\r\n\r\n    public override bool Equals(object obj) =\u003e obj is MyColor c \u0026\u0026 Equals(c);\r\n\r\n    public override int GetHashCode() =\u003e HashCode.Combine(R, G, B, A);\r\n}\r\n```\r\n\r\n### Alternative Designs\r\n\r\nIt could also be an attribute, e.g.\r\n```C#\r\nnamespace System;\r\n\r\n[AttributeUsage(AttributeTargets.Struct, Inherited = false, AllowMultiple = false)]\r\npublic sealed class BitwiseEquatableAttribute : Attribute\r\n{\r\n    public BitwiseEquatableAttribute() { }\r\n}\r\n```\r\nthat could then be applied to the type, e.g.\r\n```C#\r\n[BitwiseEquatable]\r\nstruct MyColor : IEquatable\u003cMyColor\u003e\r\n{\r\n    private byte R, G, B, A;\r\n\r\n    public bool Equals(MyColor other) =\u003e R == other.R \u0026\u0026 G == other.G \u0026\u0026 B == other.B \u0026\u0026 A == other.A;\r\n\r\n    public override bool Equals(object obj) =\u003e obj is MyColor c \u0026\u0026 Equals(c);\r\n\r\n    public override int GetHashCode() =\u003e HashCode.Combine(R, G, B, A);\r\n}\r\n```\r\n\r\n### Risks\r\n\r\nIt\u0027s yet one more thing a developer implementing equality would need to think about.  We\u0027d probably want the C# compiler to emit it in some situations for records, and anything we do around https://github.com/dotnet/runtime/issues/48733 should also factor it in.  We might also want analyzers that try to flag types which implement IBitwiseEquality but don\u0027t integrate all fields into its Equals, don\u0027t do a simple field-by-field comparison or unsafe-cast-memcmp in their Equals, etc.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYP9blA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5KWPYI",
                                           "createdAt":  "2022-09-14T22:00:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nMost of our vectorized implementations on MemoryExtensions check RuntimeHelpers.IsBitwiseEquatable to determine whether vectorization is feasible.  Today, IsBitwiseEquatable is hardcoded to a finite list of primitive types; https://github.com/dotnet/runtime/pull/75640 extends that further, but overriding `Equals` / implementing `IEquatable\u003cT\u003e` opts you out again. Developers can still get the vectorization benefits of these implementations, but it\u0027s awkward and unsafe, e.g. with a type like:\r\n```C#\r\nstruct MyColor : IEquatable\u003cT\u003e { ... }\r\n...\r\ninstead of:\r\n```C#\r\nReadOnlySpan\u003cMyColor\u003e colors = ...;\r\nMyColor value = ...;\r\nreturn colors.IndexOf(value);\r\n```\r\nit\u0027s something more like:\r\n```C#\r\nReadOnlySpan\u003cMyColor\u003e colors = ...;\r\nMyColor value = ...;\r\nreturn MemoryMarshal.Cast\u003cMyColor, int\u003e(colors).IndexOf(Unsafe.As\u003cMyColor, int\u003e(ref value));\r\n```\r\nand most importantly, it\u0027s something someone has to write code for on each use rather than it \"just work\"ing.\r\n\r\nIf we instead expose a way for a type to be annotated as \"You can trust that my Equals override and/or IEquatable implementation are identical to bitwise equality semantics\", then we can special-case IsBitwiseEquatable to recognize this annotation, and everything else just lights up.\n\n### API Proposal\n\n```csharp\r\nnamespace System;\r\n\r\npublic interface IBitwiseEquatable\u003cT\u003e : IEquatable\u003cT\u003e\r\n{\r\n    // no additional methods, it\u0027s just a marker interface\r\n}\r\n```\n\n### API Usage\n\n```C#\r\nstruct MyColor : IBitwiseEquatable\u003cMyColor\u003e\r\n{\r\n    private byte R, G, B, A;\r\n\r\n    public bool Equals(MyColor other) =\u003e R == other.R \u0026\u0026 G == other.G \u0026\u0026 B == other.B \u0026\u0026 A == other.A;\r\n\r\n    public override bool Equals(object obj) =\u003e obj is MyColor c \u0026\u0026 Equals(c);\r\n\r\n    public override int GetHashCode() =\u003e HashCode.Combine(R, G, B, A);\r\n}\r\n```\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\nIt\u0027s yet one more thing a developer implementing equality would need to think about.  We\u0027d probably want the C# compiler to emit it in some situations for records, and anything we do around https://github.com/dotnet/runtime/issues/48733 should also factor it in.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003estephentoub\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Memory`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e8.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-09-14T22:00:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KWaPT",
                                           "createdAt":  "2022-09-14T23:07:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "The biggest issue is that bitwise equality is not just checking all fields, floating point data blocks it too but the thing that\u0027d break it the most is padding between struct fields. With it being platform specific, it\u0027s impossible to verify it with an analyzer reliably.\r\n\r\nI could rather see the VM being able to check it at runtime or going the other way around with the interfaces and having `ISequentialEquatable` that\u0027d contain statics operating on spans of the type.",
                                           "updatedAt":  "2022-09-14T23:07:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KWbTm",
                                           "createdAt":  "2022-09-14T23:15:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e With it being platform specific, it\u0027s impossible to verify it with an analyzer reliably.\r\n\r\nIt wouldn\u0027t need to verify perfectly. It could flag provably wrong usage. ",
                                           "updatedAt":  "2022-09-14T23:15:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KWbgZ",
                                           "createdAt":  "2022-09-14T23:16:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "An attribute could force some sort of Auto layout with Pack 1 for it, although it\u0027d be a bit awkward and wouldn\u0027t play nice with platforms that don\u0027t support unaligned loads.",
                                           "updatedAt":  "2022-09-14T23:16:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KWcbJ",
                                           "createdAt":  "2022-09-14T23:24:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "neon-sunset",
                                           "body":  "Would it be viable for this interface or attribute to indirectly but publicly expose https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/comutilnative.cpp#L1642 ? So that violating `CanCompareBits` condition would be a compile time error and require user maybe do some additional work with analyzer hints instead while allowing for custom layout as long as it satisfies the condition?\r\n",
                                           "updatedAt":  "2022-09-14T23:24:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KWetj",
                                           "createdAt":  "2022-09-14T23:43:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "To be clear, my intent wasn\u0027t to say \"dear runtime, please always use memcmp regardless of whether it\u0027s valid\", but rather \"dear runtime, i\u0027m ok if you use memcmp instead of my Equals\". The latter doesn\u0027t require the runtime to use memcmp but rather just let\u0027s it, and it wouldn\u0027t if the type wasn\u0027t ammenable, just as it doesn\u0027t today in ValueType.Equals if the type\u0027s layout isn\u0027t ammenable. The analyzer I mention would be to help flag cases where they\u0027d obviously have different semantics, e.g. Equals was only comparing one of multiple fields.",
                                           "updatedAt":  "2022-09-14T23:46:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KWlrw",
                                           "createdAt":  "2022-09-15T00:33:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Alternative Designs\r\n\r\nPattern-match the IL in the Equals method. No public APIs needed, just works, even for existing code.",
                                           "updatedAt":  "2022-09-15T00:33:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KWpf_",
                                           "createdAt":  "2022-09-15T01:02:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Pattern-match the IL in the Equals method. No public APIs needed, just works, even for existing code.\r\n\r\nThat sounds fairly fragile, but if we can make it work well enough on enough cases, sure.  Do we have existing examples outside of the JIT/compiler where we do that?",
                                           "updatedAt":  "2022-09-15T01:03:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KWqeK",
                                           "createdAt":  "2022-09-15T01:09:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "E.g. ILLinker has quite a bit of IL pattern matching.",
                                           "updatedAt":  "2022-09-15T01:09:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KWrwu",
                                           "createdAt":  "2022-09-15T01:19:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e E.g. ILLinker has quite a bit of IL pattern matching.\r\n\r\nThanks, sure, I meant examples in the VM...?",
                                           "updatedAt":  "2022-09-15T01:19:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KWt5e",
                                           "createdAt":  "2022-09-15T01:37:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "I do not see anything like this in the VM currently. We used to have it in the past (e.g. for CER). It is not that hard to add ad-hoc IL parser.\r\n\r\nOr if we want to have all (fragile) optimizations under src\\clr\\jit, I guess we can figure out a way how to teach the JIT to do this sort of analysis.",
                                           "updatedAt":  "2022-09-15T01:37:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Sch82",
                                           "createdAt":  "2023-01-15T17:46:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericwj",
                                           "body":  "Pattern matching would be awesome. Especially for countless structs with just one field.\r\n\r\nBut how will this translate to C#? The following is still not out of the box available:\r\n```C#\r\nnew ConsoleColor[0].AsSpan().IndexOfAnyExcept(ConsoleColor.Red)\r\n```\r\n\r\nWould it mean the type constraints `where T : IEquatable\u003cT\u003e?` on the members of `MemoryExtensions` should be dropped?\r\n\r\nI found the current version of C# is actually able to distinguish between `MemoryMarshal.IndexOf\u003cT\u003e(..) where T : IEquatable\u003cT\u003e?` and `MyEnumExtensions.IndexOf\u003cE\u003e(..) where E : struct, Enum` which I believe was a problem before.\r\n\r\nIf `MemoryExtensions.IndexOf\u003cT\u003e` keeps its type constraint, it\u0027d be possible to put some 600 lines of code like the following in another class and ship it:\r\n```C#\r\n[MethodImpl(MethodImplOptions.AggressiveInlining)]\r\npublic static int IndexOf\u003cE\u003e(this ReadOnlySpan\u003cE\u003e span, E other) where E : unmanaged, Enum =\u003e Unsafe.SizeOf\u003cE\u003e() switch {\r\n    1 =\u003e MemoryMarshal.Cast\u003cE, byte  \u003e(span).IndexOf(Unsafe.As\u003cE, byte  \u003e(ref other)),\r\n    2 =\u003e MemoryMarshal.Cast\u003cE, ushort\u003e(span).IndexOf(Unsafe.As\u003cE, ushort\u003e(ref other)),\r\n    4 =\u003e MemoryMarshal.Cast\u003cE, uint  \u003e(span).IndexOf(Unsafe.As\u003cE, uint  \u003e(ref other)),\r\n    8 =\u003e MemoryMarshal.Cast\u003cE, ulong \u003e(span).IndexOf(Unsafe.As\u003cE, ulong \u003e(ref other)),\r\n    _ =\u003e throw new InvalidCastException()\r\n};\r\n```\r\nPoke me if you want a copy of mine.",
                                           "updatedAt":  "2023-01-15T17:46:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5So8Fz",
                                           "createdAt":  "2023-01-18T04:16:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Would it mean the type constraints where T : IEquatable\u003cT\u003e? on the members of MemoryExtensions should be dropped?\r\n\r\nhttps://github.com/dotnet/runtime/issues/75639#issuecomment-1247461067",
                                           "updatedAt":  "2023-01-18T04:16:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5SsqhQ",
                                           "createdAt":  "2023-01-18T17:19:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericwj",
                                           "body":  "OK you\u0027re already considering that. Still, enums are a bit of a lost child imho here again. Here the JIT takes care of it and that is what `IBitwiseEquatable` is for, but I\u0027m sure it\u0027d be useful in various places as a type constraint regardless and enums fall short in these situations. Enums are great for intelligable debugging. Imho otherwise they\u0027re just numbers and it keeps annoying me that there is no way to treat them about equally as such. Requiring the `switch` above stinks. And at least the JIT in `ilc` has to ask Redhawk for help which causes them to be widened to `uint` iirc and that already massively reduces e.g. performance of `IndexOf` by a factor 2 or 4 depeding on the underlying type, plus depending on what assembly is generated dropping out of vectorization or a mere `repne cmps` style loop.\r\n\r\nIs this as a larger issue on the radar anywhere? Or is it considered not possible? Is it just ECMA blocking any improvement in smarts about enums by the compiler/jit/runtime? Could they get `IBitwiseEquatable` and for all I care `IBinaryInteger\u003cE\u003e`?",
                                           "updatedAt":  "2023-01-18T17:27:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5W9W9E",
                                           "createdAt":  "2023-03-07T21:53:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e Pattern-match the IL in the Equals method. No public APIs needed, just works, even for existing code.\r\n\r\n@jkotas, how strongly do you feel about this approach?\r\n\r\nLooking at marking this as `ready-for-review` and while some IL analysis for implicit light up via `RuntimeHelpers.IsBitwiseEquatable` would be nice; doing so would require it to be made public (https://github.com/dotnet/runtime/issues/46017).\r\n\r\nNotably the two approaches don\u0027t seem mutually exclusive, so we could have bother the marker interface for explicit opt-in and eventually add some VM support for implicit light up as well.",
                                           "updatedAt":  "2023-03-07T21:53:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5W9zXO",
                                           "createdAt":  "2023-03-07T23:44:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "If we believe that the pattern matching approach is viable, marking interface that has to be manually implement by users is unnecessary baggage. I do not think it makes sense to add this baggage as a quick fix that we will have to live with forever. We are here for the long run.\r\n\r\nAlso, the interface as proposed is not expressive enough. It does not compose using generics. For example, it is not possible to express that `Vector\u003cbyte\u003e` is bitwise equatable, but `Vector\u003cfloat\u003e` is not. Or you cannot use it to express that `ValueTuple\u003cbyte, byte\u003e` is bitwise equatable. The pattern matching approach does not have these problems.",
                                           "updatedAt":  "2023-03-07T23:44:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5W9-dK",
                                           "createdAt":  "2023-03-08T00:39:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e If we believe that the pattern matching approach is viable,\r\n\r\nWe\u0027ll have many scenarios where the arbitrary IL analysis is \"expensive\", and potentially more expensive than any of the analysis we\u0027re doing today given it will typically require inlining and recursive analysis of each inlinee and I expect this cost will be the most prohibitive factor.\r\n\r\nConsider for example that `Equals(obj)` is typically implemented as `(obj is T other) \u0026\u0026 Equals(other)`. You then have `Equals(T)` that is often implemented as `this == other`. Record types will themselves also be implemented using `Equals()` recursively on each field by default.\r\n\r\nThe pattern matching will also get tripped up on some code. Consider some of the optimizations we\u0027ve done in our own code to ensure things are maintainable or performant. That is, we have code that specializes per `T`, we have code that lights up using vectorization, etc.\r\n\r\n\u003e Also, the interface as proposed is not expressive enough\r\n\r\nI think we\u0027re going to hit some limitations no matter which approach we go with.\r\n\r\nThe marker-interface based approach allows opt in, but as you mentioned can\u0027t readily represent things like `Vector128\u003cT\u003e` which are only bitwise equatable if the `T` is bitwise equatable.\r\n\r\nAn attribute based approach is slightly more extensible. You could imagine having `Vector128\u003c[BitwiseEquatableIfBitwiseEquatable] T\u003e` (bad name, but somewhat matching how the `[NotNullIfNotNull]` attribute works for nullable-reference types).\r\n\r\nYou could also imagine having some well known `static abstract` method such that `typeof(T).IsBitwiseEquatable` could simply execute it and determine if the things is considered equatable or not. The common case would be constant true/false. Cases like `Vector128\u003cT\u003e` would return per `T`, but that is optimized in general by the JIT -- There would need to be the level of indirection since we don\u0027t have support for doing something like `if (T is IBitwiseEquatable\u003cT\u003e) { T.Method(); }` today. The JIT could still do it, however, and could be simplified if the language gets the ability to \"bridge generic constraints\" in the future (that is, call a more constrained API from a less constrained context after having done a relevant check).\r\n\r\nThere are many options, and none are perfect, but I expect we\u0027ll need more than just one given the complexities involved in such checks.",
                                           "updatedAt":  "2023-03-08T00:42:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5W-DqB",
                                           "createdAt":  "2023-03-08T01:06:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e We\u0027ll have many scenarios where the arbitrary IL analysis is \"expensive\"\r\n\r\nThe analysis should be significantly cheaper than JITing the Equals method and everything called by it.\r\n\r\n\u003e I expect we\u0027ll need more than just one given the complexities involved in such checks.\r\n\r\nI am not convinced about it. We do not need to do the optimization for 100% of the cases - we never do. It is enough to address 90+% of the cases and the IL pattern matching should be good enough for that. People should be always able use workarounds like `MemoryMarshal.Cast` for the complex cases that are not addressed by the runtime and when it is important to them.",
                                           "updatedAt":  "2023-03-08T01:07:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5W-E-q",
                                           "createdAt":  "2023-03-08T01:14:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e The analysis should be significantly cheaper than JITing the Equals method and everything called by it.\r\n\r\nCould you elaborate? It\u0027s certainly cheaper than jitting, but it basically requires doing the initial import of the IL and inlining of other methods to get basic control flow handled. That also involves one of the more expensive parts of inlining, which is all the token resolution.",
                                           "updatedAt":  "2023-03-08T01:14:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5W-Hnu",
                                           "createdAt":  "2023-03-08T01:26:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "We will JIT or even inline the Equals method today and we are fine with how much it costs. I am saying that paying a fraction of this cost to perform this analysis is acceptable, it is not prohibitively expensive.",
                                           "updatedAt":  "2023-03-08T01:26:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5W-KwR",
                                           "createdAt":  "2023-03-08T01:42:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "👍, if we were to do this I think it would be overall simpler to do it in the JIT where we already have the infrastructure to produce some basic blocks and do simple control flow analysis.\r\n\r\nIt may also fit into the long-standing issue/request to be able to \"cache\" simple heuristics about the compiled or analyzed code. Knowing if an `Equals` method is `IBitwiseEquatable` equivalent is one, tracking if a method is much cheaper than it appears such as due to large amounts of specialization or dead code elimination is another. There have been several other heuristics that have been discussed in the past as well.\r\n\r\nOne could imagine such heuristics being cached as part of crossgen as well, much as usage of `Isa.IsSupported` checks are for hardware intrinsics.\r\n",
                                           "updatedAt":  "2023-03-08T01:42:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5g_1uU",
                                           "createdAt":  "2023-07-08T14:32:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODP7ARw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "aianlinb",
                                                                               "createdAt":  "2023-12-18T09:19:47Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "Would maybe introducing this API:\r\n```cs\r\npublic static class RuntimeHelpers\r\n{\r\n    public static bool BitwiseEquals\u003cT\u003e(T left, T right) where T : unmanaged\r\n}\r\n```\r\nand then pattern patching `Equals` to be:\r\n```cs\r\npublic bool Equals(Guid guid) =\u003e RuntimeHelpers.BitwiseEquals(this, guid);\r\n```\r\nsimplify things here? That way we wouldn\u0027t need to detect complex equals logic and the JIT would be able to emit the most efficient thing it can.",
                                           "updatedAt":  "2023-07-08T14:32:11Z"
                                       }
                                   ],
                         "totalCount":  22
                     },
        "title":  "[API Proposal]: IBitwiseEquatable\u003cT\u003e",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/76843",
        "createdAt":  "2022-10-10T21:00:18Z",
        "number":  76843,
        "author":  "MihaZupan",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-10-11T07:46:17Z",
        "body":  "The `(ReadOnlySpan\u003cT\u003e span, ReadOnlySpan\u003cT\u003e values)` overloads of different `IndexOfAny` helpers have inconsistent inlining hints:\r\n\r\nhttps://github.com/dotnet/runtime/blob/6811cc4dcb4aaabbfa471c0bff101ee70b237fc0/src/libraries/System.Private.CoreLib/src/System/MemoryExtensions.cs#L1297-L1298\r\nhttps://github.com/dotnet/runtime/blob/6811cc4dcb4aaabbfa471c0bff101ee70b237fc0/src/libraries/System.Private.CoreLib/src/System/MemoryExtensions.cs#L1566-L1567\r\nvs.\r\nhttps://github.com/dotnet/runtime/blob/6811cc4dcb4aaabbfa471c0bff101ee70b237fc0/src/libraries/System.Private.CoreLib/src/System/MemoryExtensions.cs#L681-L682\r\nhttps://github.com/dotnet/runtime/blob/6811cc4dcb4aaabbfa471c0bff101ee70b237fc0/src/libraries/System.Private.CoreLib/src/System/MemoryExtensions.cs#L924-L925\r\n\r\n---\r\n\r\nFrom @stephentoub in https://github.com/dotnet/runtime/pull/76740#discussion_r991631527:\r\n\u003e a) we should make these consistent, and b) we should seriously reconsider the aggressive inlining that\u0027s on there (or consider how IsKnownConstant could be used here).  If the values passed is a constant, then the JIT can do a good job of trimming away all of these branches.  But if it\u0027s not, it results in significant code bloat to the call site, e.g. this:\r\n```C#\r\nprivate static bool Contains(string text, string values) =\u003e\r\n    text.AsSpan().IndexOfAny(values) \u003e= 0;\r\n```\r\n\u003e results in this:\r\n```\r\n; Assembly listing for method ConsoleApp15.Program:Contains(System.String,System.String):bool\r\n; Emitting BLENDED_CODE for X64 CPU with AVX - Windows\r\n; optimized code\r\n; rsp based frame\r\n; partially interruptible\r\n; No PGO data\r\n; 2 inlinees with PGO data; 23 single block inlinees; 1 inlinees without PGO data\r\n\r\nG_M000_IG01:                ;; offset=0000H\r\n       4883EC48             sub      rsp, 72\r\n \r\nG_M000_IG02:                ;; offset=0004H\r\n       4885C9               test     rcx, rcx\r\n       7475                 je       SHORT G_M000_IG10\r\n \r\nG_M000_IG03:                ;; offset=0009H\r\n       4C8D410C             lea      r8, bword ptr [rcx+0CH]\r\n       8B4908               mov      ecx, dword ptr [rcx+08H]\r\n \r\nG_M000_IG04:                ;; offset=0010H\r\n       8BC1                 mov      eax, ecx\r\n       4885D2               test     rdx, rdx\r\n       7442                 je       SHORT G_M000_IG08\r\n \r\nG_M000_IG05:                ;; offset=0017H\r\n       488D4A0C             lea      rcx, bword ptr [rdx+0CH]\r\n       448B4A08             mov      r9d, dword ptr [rdx+08H]\r\n \r\nG_M000_IG06:                ;; offset=001FH\r\n       8BD0                 mov      edx, eax\r\n       89542444             mov      dword ptr [rsp+44H], edx\r\n       48894C2438           mov      bword ptr [rsp+38H], rcx\r\n       4183F905             cmp      r9d, 5\r\n       0F871B010000         ja       G_M000_IG15\r\n       418BC1               mov      eax, r9d\r\n       4C8D0D2A010000       lea      r9, [reloc @RWD00]\r\n       458B0C81             mov      r9d, dword ptr [r9+4*rax]\r\n       4C8D15BBFFFFFF       lea      r10, G_M000_IG02\r\n       4D03CA               add      r9, r10\r\n       41FFE1               jmp      r9\r\n \r\nG_M000_IG07:                ;; offset=004FH\r\n       B8FFFFFFFF           mov      eax, -1\r\n       E904010000           jmp      G_M000_IG16\r\n \r\nG_M000_IG08:                ;; offset=0059H\r\n       33C9                 xor      rcx, rcx\r\n       4533C9               xor      r9d, r9d\r\n       EBBF                 jmp      SHORT G_M000_IG06\r\n \r\nG_M000_IG09:                ;; offset=0060H\r\n       488B4C2438           mov      rcx, bword ptr [rsp+38H]\r\n       480FBF01             movsx    rax, word  ptr [rcx]\r\n       498BC8               mov      rcx, r8\r\n       8BD0                 mov      edx, eax\r\n       448B442444           mov      r8d, dword ptr [rsp+44H]\r\n       FF1587A32000         call     [System.SpanHelpers:IndexOfValueType[short,DontNegate`1[short]](byref,short,int):int]\r\n       E9DF000000           jmp      G_M000_IG16\r\n \r\nG_M000_IG10:                ;; offset=007EH\r\n       33C9                 xor      rcx, rcx\r\n       4533C0               xor      r8d, r8d\r\n       4987C8               xchg     rcx, r8\r\n       EB88                 jmp      SHORT G_M000_IG04\r\n \r\nG_M000_IG11:                ;; offset=0088H\r\n       488B4C2438           mov      rcx, bword ptr [rsp+38H]\r\n       4C0FBF09             movsx    r9, word  ptr [rcx]\r\n       480FBF4102           movsx    rax, word  ptr [rcx+02H]\r\n       498BC8               mov      rcx, r8\r\n       418BD1               mov      edx, r9d\r\n       448BC0               mov      r8d, eax\r\n       448B4C2444           mov      r9d, dword ptr [rsp+44H]\r\n       FF15BEBE2000         call     [System.SpanHelpers:IndexOfAnyValueType[short,DontNegate`1[short]](byref,short,short,int):int]\r\n       E9AE000000           jmp      G_M000_IG16\r\n \r\nG_M000_IG12:                ;; offset=00AFH\r\n       488B4C2438           mov      rcx, bword ptr [rsp+38H]\r\n       4C0FBF09             movsx    r9, word  ptr [rcx]\r\n       480FBF4102           movsx    rax, word  ptr [rcx+02H]\r\n       4C0FBF5104           movsx    r10, word  ptr [rcx+04H]\r\n       89542420             mov      dword ptr [rsp+20H], edx\r\n       498BC8               mov      rcx, r8\r\n       418BD1               mov      edx, r9d\r\n       448BC0               mov      r8d, eax\r\n       458BCA               mov      r9d, r10d\r\n       FF1570C62000         call     [System.SpanHelpers:IndexOfAnyValueType[short,DontNegate`1[short]](byref,short,short,short,int):int]\r\n       E980000000           jmp      G_M000_IG16\r\n \r\nG_M000_IG13:                ;; offset=00DDH\r\n       488B4C2438           mov      rcx, bword ptr [rsp+38H]\r\n       4C0FBF09             movsx    r9, word  ptr [rcx]\r\n       480FBF4102           movsx    rax, word  ptr [rcx+02H]\r\n       4C0FBF5104           movsx    r10, word  ptr [rcx+04H]\r\n       480FBF4906           movsx    rcx, word  ptr [rcx+06H]\r\n       894C2420             mov      dword ptr [rsp+20H], ecx\r\n       89542428             mov      dword ptr [rsp+28H], edx\r\n       498BC8               mov      rcx, r8\r\n       418BD1               mov      edx, r9d\r\n       448BC0               mov      r8d, eax\r\n       458BCA               mov      r9d, r10d\r\n       FF1559DE2000         call     [System.SpanHelpers:IndexOfAnyValueType[short,DontNegate`1[short]](byref,short,short,short,short,int):int]\r\n       EB4C                 jmp      SHORT G_M000_IG16\r\n \r\nG_M000_IG14:                ;; offset=0111H\r\n       488B4C2438           mov      rcx, bword ptr [rsp+38H]\r\n       4C0FBF09             movsx    r9, word  ptr [rcx]\r\n       480FBF4102           movsx    rax, word  ptr [rcx+02H]\r\n       4C0FBF5104           movsx    r10, word  ptr [rcx+04H]\r\n       4C0FBF5906           movsx    r11, word  ptr [rcx+06H]\r\n       480FBF4908           movsx    rcx, word  ptr [rcx+08H]\r\n       44895C2420           mov      dword ptr [rsp+20H], r11d\r\n       894C2428             mov      dword ptr [rsp+28H], ecx\r\n       89542430             mov      dword ptr [rsp+30H], edx\r\n       498BC8               mov      rcx, r8\r\n       418BD1               mov      edx, r9d\r\n       448BC0               mov      r8d, eax\r\n       458BCA               mov      r9d, r10d\r\n       FF154B842000         call     [System.SpanHelpers:IndexOfAnyValueType[short](byref,short,short,short,short,short,int):int]\r\n       EB0E                 jmp      SHORT G_M000_IG16\r\n \r\nG_M000_IG15:                ;; offset=014FH\r\n       498BC8               mov      rcx, r8\r\n       4C8B442438           mov      r8, bword ptr [rsp+38H]\r\n       FF15A3222000         call     [System.MemoryExtensions:IndexOfAnyProbabilistic(byref,int,byref,int):int]\r\n \r\nG_M000_IG16:                ;; offset=015DH\r\n       F7D0                 not      eax\r\n       C1E81F               shr      eax, 31\r\n \r\nG_M000_IG17:                ;; offset=0162H\r\n       4883C448             add      rsp, 72\r\n       C3                   ret      \r\n \r\nRWD00  \tdd\t0000004Bh ; case G_M000_IG07\r\n       \tdd\t0000005Ch ; case G_M000_IG09\r\n       \tdd\t00000084h ; case G_M000_IG11\r\n       \tdd\t000000ABh ; case G_M000_IG12\r\n       \tdd\t000000D9h ; case G_M000_IG13\r\n       \tdd\t0000010Dh ; case G_M000_IG14\r\n\r\n; Total bytes of code 359\r\n```\r\n\r\ncc: @EgorBo ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOS-80Xg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5L7ODU",
                                           "createdAt":  "2022-10-10T21:00:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThe `(ReadOnlySpan\u003cT\u003e span, ReadOnlySpan\u003cT\u003e values)` overloads of different `IndexOfAny` helpers have inconsistent inlining hints:\r\n\r\nhttps://github.com/dotnet/runtime/blob/6811cc4dcb4aaabbfa471c0bff101ee70b237fc0/src/libraries/System.Private.CoreLib/src/System/MemoryExtensions.cs#L1297-L1298\r\nhttps://github.com/dotnet/runtime/blob/6811cc4dcb4aaabbfa471c0bff101ee70b237fc0/src/libraries/System.Private.CoreLib/src/System/MemoryExtensions.cs#L1566-L1567\r\nvs.\r\nhttps://github.com/dotnet/runtime/blob/6811cc4dcb4aaabbfa471c0bff101ee70b237fc0/src/libraries/System.Private.CoreLib/src/System/MemoryExtensions.cs#L681-L682\r\nhttps://github.com/dotnet/runtime/blob/6811cc4dcb4aaabbfa471c0bff101ee70b237fc0/src/libraries/System.Private.CoreLib/src/System/MemoryExtensions.cs#L924-L925\r\n\r\nFrom @stephentoub in https://github.com/dotnet/runtime/pull/76740#discussion_r991631527:\r\n\u003e a) we should make these consistent, and b) we should seriously reconsider the aggressive inlining that\u0027s on there (or consider how IsKnownConstant could be used here).  If the values passed is a constant, then the JIT can do a good job of trimming away all of these branches.  But if it\u0027s not, it results in significant code bloat to the call site, e.g. this:\r\n```C#\r\nprivate static bool Contains(string text, string values) =\u003e\r\n    text.AsSpan().IndexOfAny(values) \u003e= 0;\r\n```\r\n\u003e results in this:\r\n```\r\n; Assembly listing for method ConsoleApp15.Program:Contains(System.String,System.String):bool\r\n; Emitting BLENDED_CODE for X64 CPU with AVX - Windows\r\n; optimized code\r\n; rsp based frame\r\n; partially interruptible\r\n; No PGO data\r\n; 2 inlinees with PGO data; 23 single block inlinees; 1 inlinees without PGO data\r\n\r\nG_M000_IG01:                ;; offset=0000H\r\n       4883EC48             sub      rsp, 72\r\n \r\nG_M000_IG02:                ;; offset=0004H\r\n       4885C9               test     rcx, rcx\r\n       7475                 je       SHORT G_M000_IG10\r\n \r\nG_M000_IG03:                ;; offset=0009H\r\n       4C8D410C             lea      r8, bword ptr [rcx+0CH]\r\n       8B4908               mov      ecx, dword ptr [rcx+08H]\r\n \r\nG_M000_IG04:                ;; offset=0010H\r\n       8BC1                 mov      eax, ecx\r\n       4885D2               test     rdx, rdx\r\n       7442                 je       SHORT G_M000_IG08\r\n \r\nG_M000_IG05:                ;; offset=0017H\r\n       488D4A0C             lea      rcx, bword ptr [rdx+0CH]\r\n       448B4A08             mov      r9d, dword ptr [rdx+08H]\r\n \r\nG_M000_IG06:                ;; offset=001FH\r\n       8BD0                 mov      edx, eax\r\n       89542444             mov      dword ptr [rsp+44H], edx\r\n       48894C2438           mov      bword ptr [rsp+38H], rcx\r\n       4183F905             cmp      r9d, 5\r\n       0F871B010000         ja       G_M000_IG15\r\n       418BC1               mov      eax, r9d\r\n       4C8D0D2A010000       lea      r9, [reloc @RWD00]\r\n       458B0C81             mov      r9d, dword ptr [r9+4*rax]\r\n       4C8D15BBFFFFFF       lea      r10, G_M000_IG02\r\n       4D03CA               add      r9, r10\r\n       41FFE1               jmp      r9\r\n \r\nG_M000_IG07:                ;; offset=004FH\r\n       B8FFFFFFFF           mov      eax, -1\r\n       E904010000           jmp      G_M000_IG16\r\n \r\nG_M000_IG08:                ;; offset=0059H\r\n       33C9                 xor      rcx, rcx\r\n       4533C9               xor      r9d, r9d\r\n       EBBF                 jmp      SHORT G_M000_IG06\r\n \r\nG_M000_IG09:                ;; offset=0060H\r\n       488B4C2438           mov      rcx, bword ptr [rsp+38H]\r\n       480FBF01             movsx    rax, word  ptr [rcx]\r\n       498BC8               mov      rcx, r8\r\n       8BD0                 mov      edx, eax\r\n       448B442444           mov      r8d, dword ptr [rsp+44H]\r\n       FF1587A32000         call     [System.SpanHelpers:IndexOfValueType[short,DontNegate`1[short]](byref,short,int):int]\r\n       E9DF000000           jmp      G_M000_IG16\r\n \r\nG_M000_IG10:                ;; offset=007EH\r\n       33C9                 xor      rcx, rcx\r\n       4533C0               xor      r8d, r8d\r\n       4987C8               xchg     rcx, r8\r\n       EB88                 jmp      SHORT G_M000_IG04\r\n \r\nG_M000_IG11:                ;; offset=0088H\r\n       488B4C2438           mov      rcx, bword ptr [rsp+38H]\r\n       4C0FBF09             movsx    r9, word  ptr [rcx]\r\n       480FBF4102           movsx    rax, word  ptr [rcx+02H]\r\n       498BC8               mov      rcx, r8\r\n       418BD1               mov      edx, r9d\r\n       448BC0               mov      r8d, eax\r\n       448B4C2444           mov      r9d, dword ptr [rsp+44H]\r\n       FF15BEBE2000         call     [System.SpanHelpers:IndexOfAnyValueType[short,DontNegate`1[short]](byref,short,short,int):int]\r\n       E9AE000000           jmp      G_M000_IG16\r\n \r\nG_M000_IG12:                ;; offset=00AFH\r\n       488B4C2438           mov      rcx, bword ptr [rsp+38H]\r\n       4C0FBF09             movsx    r9, word  ptr [rcx]\r\n       480FBF4102           movsx    rax, word  ptr [rcx+02H]\r\n       4C0FBF5104           movsx    r10, word  ptr [rcx+04H]\r\n       89542420             mov      dword ptr [rsp+20H], edx\r\n       498BC8               mov      rcx, r8\r\n       418BD1               mov      edx, r9d\r\n       448BC0               mov      r8d, eax\r\n       458BCA               mov      r9d, r10d\r\n       FF1570C62000         call     [System.SpanHelpers:IndexOfAnyValueType[short,DontNegate`1[short]](byref,short,short,short,int):int]\r\n       E980000000           jmp      G_M000_IG16\r\n \r\nG_M000_IG13:                ;; offset=00DDH\r\n       488B4C2438           mov      rcx, bword ptr [rsp+38H]\r\n       4C0FBF09             movsx    r9, word  ptr [rcx]\r\n       480FBF4102           movsx    rax, word  ptr [rcx+02H]\r\n       4C0FBF5104           movsx    r10, word  ptr [rcx+04H]\r\n       480FBF4906           movsx    rcx, word  ptr [rcx+06H]\r\n       894C2420             mov      dword ptr [rsp+20H], ecx\r\n       89542428             mov      dword ptr [rsp+28H], edx\r\n       498BC8               mov      rcx, r8\r\n       418BD1               mov      edx, r9d\r\n       448BC0               mov      r8d, eax\r\n       458BCA               mov      r9d, r10d\r\n       FF1559DE2000         call     [System.SpanHelpers:IndexOfAnyValueType[short,DontNegate`1[short]](byref,short,short,short,short,int):int]\r\n       EB4C                 jmp      SHORT G_M000_IG16\r\n \r\nG_M000_IG14:                ;; offset=0111H\r\n       488B4C2438           mov      rcx, bword ptr [rsp+38H]\r\n       4C0FBF09             movsx    r9, word  ptr [rcx]\r\n       480FBF4102           movsx    rax, word  ptr [rcx+02H]\r\n       4C0FBF5104           movsx    r10, word  ptr [rcx+04H]\r\n       4C0FBF5906           movsx    r11, word  ptr [rcx+06H]\r\n       480FBF4908           movsx    rcx, word  ptr [rcx+08H]\r\n       44895C2420           mov      dword ptr [rsp+20H], r11d\r\n       894C2428             mov      dword ptr [rsp+28H], ecx\r\n       89542430             mov      dword ptr [rsp+30H], edx\r\n       498BC8               mov      rcx, r8\r\n       418BD1               mov      edx, r9d\r\n       448BC0               mov      r8d, eax\r\n       458BCA               mov      r9d, r10d\r\n       FF154B842000         call     [System.SpanHelpers:IndexOfAnyValueType[short](byref,short,short,short,short,short,int):int]\r\n       EB0E                 jmp      SHORT G_M000_IG16\r\n \r\nG_M000_IG15:                ;; offset=014FH\r\n       498BC8               mov      rcx, r8\r\n       4C8B442438           mov      r8, bword ptr [rsp+38H]\r\n       FF15A3222000         call     [System.MemoryExtensions:IndexOfAnyProbabilistic(byref,int,byref,int):int]\r\n \r\nG_M000_IG16:                ;; offset=015DH\r\n       F7D0                 not      eax\r\n       C1E81F               shr      eax, 31\r\n \r\nG_M000_IG17:                ;; offset=0162H\r\n       4883C448             add      rsp, 72\r\n       C3                   ret      \r\n \r\nRWD00  \tdd\t0000004Bh ; case G_M000_IG07\r\n       \tdd\t0000005Ch ; case G_M000_IG09\r\n       \tdd\t00000084h ; case G_M000_IG11\r\n       \tdd\t000000ABh ; case G_M000_IG12\r\n       \tdd\t000000D9h ; case G_M000_IG13\r\n       \tdd\t0000010Dh ; case G_M000_IG14\r\n\r\n; Total bytes of code 359\r\n```\r\n\r\ncc: @EgorBo \n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eMihaZupan\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Memory`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-10-10T21:00:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5L7uKn",
                                           "createdAt":  "2022-10-11T00:40:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "I assume the idea behind some of these Aggressiveinlining is the fact that mostly these APIs are used with constant input, so if e.g. IndexOfAny will be inlined then conditions like these will be folded https://github.com/dotnet/runtime/blob/6811cc4dcb4aaabbfa471c0bff101ee70b237fc0/src/libraries/System.Private.CoreLib/src/System/MemoryExtensions.cs#L1313",
                                           "updatedAt":  "2022-10-11T00:40:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5L7wnL",
                                           "createdAt":  "2022-10-11T00:58:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "Could `IsKnownConstant(values.Length)` be used here without `AggressiveInlining` to get the JIT to only inline this if these branches will actually be eliminated?",
                                           "updatedAt":  "2022-10-11T00:58:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5L7xjW",
                                           "createdAt":  "2022-10-11T01:05:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "\u003e Could `IsKnownConstant(values.Length)` be used here without `AggressiveInlining` to get the JIT to only inline this if these branches will actually be eliminated?\r\n\r\nIn theory - yes, and in fact that was the initial implementation: \"if IsKnownConstant is fed with a constant -\u003e always inline\" Unfortunately, it led to unexpected results, e.g.\r\n\r\n```csharp\r\nvoid Foo(int x)\r\n{\r\nif (IsKnownConstant(x) \u0026\u0026 x == 42)\r\n{\r\n// do some logic for x == 42\r\n}\r\n// heavy logic\r\n}\r\n```\r\nJIT is not (yet) able to figure out that user wants this function to inline not only when x is a constant but also == 42. So this `Foo` function was effectively \"always inline\" for any const output.",
                                           "updatedAt":  "2022-10-11T01:06:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5L7yLm",
                                           "createdAt":  "2022-10-11T01:09:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "In this case, would that actually be fine since these methods will always be reduced to a single branch for constant inputs though?\r\nThat is, we don\u0027t really care about the result of `IsKnownConstant`, just to tell the JIT to \"inline this method if the input is constant\".",
                                           "updatedAt":  "2022-10-11T01:09:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5L7zRe",
                                           "createdAt":  "2022-10-11T01:17:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "\u003e In this case, would that actually be fine\r\n\r\nYes, but it won\u0027t be fine in other cases, I hit this problem when I was working on https://github.com/dotnet/runtime/pull/64821\r\n\r\n\u003e just to tell the JIT to \"inline this method if the input is constant\".\r\n\r\nIn that case it has to be a different intrinsic then. Something like `void RuntimeHelpers.InlineIfConst(x)` if it\u0027s worth the effort.",
                                           "updatedAt":  "2022-10-11T01:17:15Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "Inconsistent inlining of IndexOfAny vs IndexOfAnyExcept helpers",
        "labels":  [
                       "area-System.Memory",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/77959",
        "createdAt":  "2022-11-07T01:05:34Z",
        "number":  77959,
        "author":  "stephentoub",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC-d6zw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "akarboush",
                                            "createdAt":  "2024-03-19T06:19:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sunkin351",
                                            "createdAt":  "2025-01-26T00:36:48Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2025-01-14T22:03:02Z",
        "body":  "### Background and motivation\r\n\r\nIt turns out it\u0027s quite common to want to search for whitespace (`char.IsWhiteSpace`) or things other than whitespace (`!char.IsWhiteSpace`).  This is true not only in regex (`\\s` and `\\S`) (according to our [nuget regex database](https://github.com/dotnet/runtime-assets/blob/main/src/System.Text.RegularExpressions.TestData/Regex_RealWorldPatterns.json) there are ~13,000 occurrences of a regex that\u0027s simply `\\s`) but also in many open-coded loops, e.g.\r\n- https://github.com/dotnet/sdk/blob/4a27d47440dd3eaefbdb31135ef8867f6758161f/src/Tasks/Microsoft.NET.Build.Tasks/LockFileExtensions.cs#L127-L138\r\n- https://github.com/JimmyCushnie/JimmysUnityUtilities/blob/834059548b2b392d692ddcf28194692e3ae7b2c1/Scripts/Extensions/Csharp%20types/StringBuilderExtensions.cs#L68-L77\r\n- https://github.com/cake-build/cake/blob/a0298c0b5f76f819f0cc0d16ac9ef55d8b26adf9/src/Cake.Core/Configuration/Parser/ConfigurationParser.cs#L107-L117\r\n- https://github.com/rubberduck-vba/Rubberduck/blob/3a9b233cf6ab519773d188e77d09ee8d8111bf49/Rubberduck.Core/UI/Refactorings/AnnotateDeclaration/AnnotationArgumentViewModel.cs#L195-L198\r\n- https://github.com/aspnet/Razor/blob/5439cfe540084edd673b7ed626f2ec9cf3f13b18/src/Microsoft.AspNetCore.Razor.Language/DirectiveTokenEditHandler.cs#L36-L47\r\n- https://github.com/OmniSharp/omnisharp-roslyn/blob/3ae5c8acd7ea3f03ab9e24c28280a320c573721a/src/OmniSharp.Cake/Configuration/Parser/ConfigurationParser.cs#L94-L104\r\n- https://github.com/Unity-Technologies/UnityCsReference/blob/332310b494c5416cdae6c1209dbae7cfa6847c8d/Editor/Mono/Scripting/Compilers/MicrosoftResponseFileParser.cs#L195-L202\r\n- https://github.com/PowerShell/PowerShell/blob/a2ee05400f8cb4a44cd87742f95ebc2c3472e649/src/System.Management.Automation/engine/parser/DebugViewWriter.cs#L1197-L1205\r\n- https://github.com/mono/mono/blob/e2c5f4b0ad1a6b21ca0735f0b35b8611d4ad87b3/mcs/class/referencesource/System.Core/Microsoft/Scripting/Ast/DebugViewWriter.cs#L1155-L1162\r\n- https://github.com/stripe/stripe-dotnet/blob/42dbc8371c5a4ee36df8933e6d72c2c2e3e41d2e/src/Stripe.net/Infrastructure/StringUtils.cs#L9\r\n- https://github.com/mono/mono/blob/e2c5f4b0ad1a6b21ca0735f0b35b8611d4ad87b3/mcs/class/referencesource/System.Web/UI/Util.cs#L995-L1002\r\n- https://github.com/VahidN/EFSecondLevelCache.Core/blob/1de038417ba22c40d9ebe411b67c9e1a7e4ad838/src/EFSecondLevelCache.Core/EFQueryExpressionVisitor.cs#L883-L893\r\n- https://github.com/InstaSharp/InstaSharp/blob/7ab2aad6bdef175dd63620bf39f74fcf02696898/src/InstaSharp/Extensions/StringExtensions.cs#L13-L18\r\n- https://github.com/FirelyTeam/Fhir.Metrics/blob/dd574b76077280299fd7104c754481a2e143ca72/src/Fhir.Metrics/Utils/Parser.cs#L57\r\n- https://github.com/baohaojun/beagrep/blob/b1d56ef14d1d663d43b6af198600caa21623d2f2/Util/StringFu.cs#L388-L394\r\n- https://github.com/dotnet/runtime/blob/264d7391ec9f6e698051db0621c5e090d0ae4710/src/libraries/System.Private.CoreLib/src/System/MemoryExtensions.Globalization.cs#L17-L25\r\n- https://github.com/dotnet/runtime/blob/264d7391ec9f6e698051db0621c5e090d0ae4710/src/libraries/System.Linq.Expressions/src/System/Linq/Expressions/DebugViewWriter.cs#L1194-L1204\r\n- https://github.com/dotnet/runtime/blob/264d7391ec9f6e698051db0621c5e090d0ae4710/src/libraries/System.Private.CoreLib/src/System/MemoryExtensions.Trim.cs#L568-L589\r\n- \r\n\r\nEtc.  We should expose these as dedicated helpers, whether or not we\u0027re able to improve performance over a simple loop (we might be able to, for at least some kinds of input).\r\n\r\n### API Proposal\r\n\r\n```diff\r\nnamespace System;\r\n\r\npublic static class MemoryExtensions\r\n{\r\n+   public static int IndexOfAnyWhiteSpace(this ReadOnlySpan\u003cchar\u003e span);\r\n+   public static int IndexOfAnyExceptWhiteSpace(this ReadOnlySpan\u003cchar\u003e span);\r\n+   public static int LastIndexOfAnyWhiteSpace(this ReadOnlySpan\u003cchar\u003e span);\r\n+   public static int LastIndexOfAnyExceptWhiteSpace(this ReadOnlySpan\u003cchar\u003e span);\r\n}\r\n```\r\n\r\n- This is only proposed for `ReadOnlySpan\u003cchar\u003e` and not also `Span\u003cchar\u003e`, since the most common case by far is expected to be spans derived from strings.  The existing MemoryExtensions.IsWhiteSpace is also only exposed for `ReadOnlySpan\u003cchar\u003e`.\r\n\r\n### API Usage\r\n\r\ne.g. MemoryExtensions.IsWhiteSpace could be rewritten as simply:\r\n```csharp\r\npublic static bool IsWhiteSpace(this ReadOnlySpan\u003cchar\u003e span) =\u003e span.IndexOfAnyExceptWhiteSpace() \u003c 0;\r\n```\r\n\r\n### Alternative Designs\r\n\r\nIf we want to expose these but don\u0027t want them to be so prominent, once https://github.com/dotnet/runtime/issues/68328 is implemented (assuming it sticks with the proposed design), this could instead be exposed as a static property on `IndexOfAnyValues`:\r\n```diff\r\npublic static class IndexOfAnyValues\r\n{\r\n+   public static IndexOfAnyValues\u003cchar\u003e WhiteSpace { get; }\r\n}\r\n```\r\nin which case the same functionality could be achieved with:\r\n```C#\r\nint wsIndex = span.IndexOfAny(IndexOfAnyValues.WhiteSpace); // or IndexOfAnyExcept\r\n```\r\nThe WhiteSpace property would cache a specialized concrete implementation that does what the proposed IndexOfAnyWhiteSpace would do.\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOmnJ-yg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5NyB_Y",
                                           "createdAt":  "2022-11-07T01:05:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nIt turns out it\u0027s quite common to want to search for whitespace (`char.IsWhiteSpace`) or things other than whitespace (`!char.IsWhiteSpace`).  This is true not only in regex (`\\s` and `\\S`) (according to our [nuget regex database](https://github.com/dotnet/runtime-assets/blob/main/src/System.Text.RegularExpressions.TestData/Regex_RealWorldPatterns.json) there are ~13,000 occurrences of a regex that\u0027s simply `\\s`) but also in many open-coded loops, e.g.\r\n- https://github.com/dotnet/sdk/blob/4a27d47440dd3eaefbdb31135ef8867f6758161f/src/Tasks/Microsoft.NET.Build.Tasks/LockFileExtensions.cs#L127-L138\r\n- https://github.com/JimmyCushnie/JimmysUnityUtilities/blob/834059548b2b392d692ddcf28194692e3ae7b2c1/Scripts/Extensions/Csharp%20types/StringBuilderExtensions.cs#L68-L77\r\n- https://github.com/cake-build/cake/blob/a0298c0b5f76f819f0cc0d16ac9ef55d8b26adf9/src/Cake.Core/Configuration/Parser/ConfigurationParser.cs#L107-L117\r\n- https://github.com/rubberduck-vba/Rubberduck/blob/3a9b233cf6ab519773d188e77d09ee8d8111bf49/Rubberduck.Core/UI/Refactorings/AnnotateDeclaration/AnnotationArgumentViewModel.cs#L195-L198\r\n- https://github.com/aspnet/Razor/blob/5439cfe540084edd673b7ed626f2ec9cf3f13b18/src/Microsoft.AspNetCore.Razor.Language/DirectiveTokenEditHandler.cs#L36-L47\r\n- https://github.com/OmniSharp/omnisharp-roslyn/blob/3ae5c8acd7ea3f03ab9e24c28280a320c573721a/src/OmniSharp.Cake/Configuration/Parser/ConfigurationParser.cs#L94-L104\r\n- https://github.com/Unity-Technologies/UnityCsReference/blob/332310b494c5416cdae6c1209dbae7cfa6847c8d/Editor/Mono/Scripting/Compilers/MicrosoftResponseFileParser.cs#L195-L202\r\n- https://github.com/PowerShell/PowerShell/blob/a2ee05400f8cb4a44cd87742f95ebc2c3472e649/src/System.Management.Automation/engine/parser/DebugViewWriter.cs#L1197-L1205\r\n- https://github.com/mono/mono/blob/e2c5f4b0ad1a6b21ca0735f0b35b8611d4ad87b3/mcs/class/referencesource/System.Core/Microsoft/Scripting/Ast/DebugViewWriter.cs#L1155-L1162\r\n- https://github.com/stripe/stripe-dotnet/blob/42dbc8371c5a4ee36df8933e6d72c2c2e3e41d2e/src/Stripe.net/Infrastructure/StringUtils.cs#L9\r\n- https://github.com/mono/mono/blob/e2c5f4b0ad1a6b21ca0735f0b35b8611d4ad87b3/mcs/class/referencesource/System.Web/UI/Util.cs#L995-L1002\r\n- https://github.com/VahidN/EFSecondLevelCache.Core/blob/1de038417ba22c40d9ebe411b67c9e1a7e4ad838/src/EFSecondLevelCache.Core/EFQueryExpressionVisitor.cs#L883-L893\r\n- https://github.com/InstaSharp/InstaSharp/blob/7ab2aad6bdef175dd63620bf39f74fcf02696898/src/InstaSharp/Extensions/StringExtensions.cs#L13-L18\r\n- https://github.com/FirelyTeam/Fhir.Metrics/blob/dd574b76077280299fd7104c754481a2e143ca72/src/Fhir.Metrics/Utils/Parser.cs#L57\r\n- https://github.com/baohaojun/beagrep/blob/b1d56ef14d1d663d43b6af198600caa21623d2f2/Util/StringFu.cs#L388-L394\r\n- https://github.com/dotnet/runtime/blob/264d7391ec9f6e698051db0621c5e090d0ae4710/src/libraries/System.Private.CoreLib/src/System/MemoryExtensions.Globalization.cs#L17-L25\r\n- https://github.com/dotnet/runtime/blob/264d7391ec9f6e698051db0621c5e090d0ae4710/src/libraries/System.Linq.Expressions/src/System/Linq/Expressions/DebugViewWriter.cs#L1194-L1204\r\n- https://github.com/dotnet/runtime/blob/264d7391ec9f6e698051db0621c5e090d0ae4710/src/libraries/System.Private.CoreLib/src/System/MemoryExtensions.Trim.cs#L568-L589\r\n- \r\n\r\nEtc.  We should expose these as dedicated helpers, whether or not we\u0027re able to improve performance over a simple loop (we might be able to, for at least some kinds of input).\n\n### API Proposal\n\n```diff\r\nnamespace System;\r\n\r\npublic static class MemoryExtensions\r\n{\r\n+   public static int IndexOfAnyWhiteSpace(this ReadOnlySpan\u003cchar\u003e span);\r\n+   public static int IndexOfAnyExceptWhiteSpace(this ReadOnlySpan\u003cchar\u003e span);\r\n}\r\n```\r\n\r\n- This is only proposed for `ReadOnlySpan\u003cchar\u003e` and not also `Span\u003cchar\u003e`, since the most common case by far is expected to be spans derived from strings.  The existing MemoryExtensions.IsWhiteSpace is also only exposed for `ReadOnlySpan\u003cchar\u003e`.\n\n### API Usage\n\ne.g. MemoryExtensions.IsWhiteSpace could be rewritten as simply:\r\n```csharp\r\npublic static bool IsWhiteSpace(this ReadOnlySpan\u003cchar\u003e span) =\u003e span.IndexOfAnyExceptWhiteSpace() \u003c 0;\r\n```\n\n### Alternative Designs\n\nIf we want to expose these but don\u0027t want them to be so prominent, once https://github.com/dotnet/runtime/issues/68328 is implemented (assuming it sticks with the proposed design), this could instead be exposed as a static property on `IndexOfAnyValues`:\r\n```diff\r\npublic static class IndexOfAnyValues\r\n{\r\n+   public static IndexOfAnyValues\u003cchar\u003e WhiteSpace { get; }\r\n}\r\n```\r\nin which case the same functionality could be achieved with:\r\n```C#\r\nint wsIndex = span.IndexOfAny(IndexOfAnyValues.WhiteSpace); // or IndexOfAnyExcept\r\n```\r\nThe WhiteSpace property would cache a specialized concrete implementation that does what the proposed IndexOfAnyWhiteSpace would do.\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003estephentoub\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Memory`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e8.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-11-07T01:05:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5N0pj0",
                                           "createdAt":  "2022-11-07T13:52:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "The proposal LGTM. I assume we are going to provide a vectorized implementation for the most frequent cases (`Latin1`)?",
                                           "updatedAt":  "2022-11-07T13:52:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5N0xqx",
                                           "createdAt":  "2022-11-07T14:15:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCwQA-A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "adamsitnik",
                                                                               "createdAt":  "2022-11-07T15:00:34Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MihaZupan",
                                                                               "createdAt":  "2022-11-27T23:02:00Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e I assume we are going to provide a vectorized implementation for the most frequent cases (Latin1)?\r\n\r\nAt least experiment with one.  I think the methods would be worth adding even if not vectorized; I listed some examples of places code is doing this same operation, but there are many more... it\u0027s surprisingly common.  That said, I think it\u0027d be worth trying to vectorize it and see what the perf looks like, in particular when there\u0027s non-ASCII input.  My initial thought was we\u0027d basically vectorize the search for all the ASCII whitespace chars (0x9 through 0xD and 0x20) as well as anything \u003e 0x7F, and if we find anything \u003e 0x7F, then fall back to a scalar loop just using char.IsWhiteSpace (I don\u0027t know if there\u0027d be an efficient way to vectorize the search for the Unicode whitespace characters).  My main concern with this would be that if the input wasn\u0027t ASCII, we\u0027d likely frequently be paying the overhead of an initial vector on top of then taking the scalar path.",
                                           "updatedAt":  "2022-11-07T14:18:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5UlPjU",
                                           "createdAt":  "2023-02-06T13:06:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "#80963 means that this could be vectorized when using `IndexOfAnyValues` (at least for non-except overloads), but if we expect matches to commonly occur at the start of the input (e.g. Trim), we may not want to use it anyway due to the added overhead.",
                                           "updatedAt":  "2023-02-06T13:06:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Wklqj",
                                           "createdAt":  "2023-03-02T19:23:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bartonjs",
                                           "body":  "[Video](https://www.youtube.com/watch?v=q5V2PiDqBRg\u0026t=0h7m16s)\r\n\r\nLooks good as proposed.\r\n\r\nWhen looking for consistency, we saw that the `ReadOnlySpan\u003cchar\u003e` methods on MemoryExtensions are not entirely consistent with whether there\u0027s also a `Span\u003cchar\u003e` overload.  In the event that the `Span\u003cchar\u003e` members are desired, they\u0027re approved by pattern-matching.\r\n\r\nNotably, MemoryExtensions.IsWhiteSpace does not have a `Span\u003cchar\u003e` overload.\r\n\r\n```C#\r\nnamespace System;\r\n\r\npublic static partial class MemoryExtensions\r\n{\r\n    public static int IndexOfAnyWhiteSpace(this ReadOnlySpan\u003cchar\u003e span);\r\n    public static int IndexOfAnyExceptWhiteSpace(this ReadOnlySpan\u003cchar\u003e span);\r\n    public static int LastIndexOfAnyWhiteSpace(this ReadOnlySpan\u003cchar\u003e span);\r\n    public static int LastIndexOfAnyExceptWhiteSpace(this ReadOnlySpan\u003cchar\u003e span);\r\n\r\n    // Edit: APIs approved as part of #86528\r\n    public static bool ContainsAnyWhiteSpace(this ReadOnlySpan\u003cchar\u003e span);\r\n    public static bool ContainsAnyExceptWhiteSpace(this ReadOnlySpan\u003cchar\u003e span);\r\n}\r\n```\r\n\r\n",
                                           "updatedAt":  "2023-07-23T06:55:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Yrwdm",
                                           "createdAt":  "2023-03-29T02:38:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "As of #83992, the regex source generator will now emit its own variants of these, e.g. if it needs to search for `\\s` it\u0027ll emit:\r\n```C#\r\n        /// \u003csummary\u003eFinds the next index of any character that matches a whitespace character.\u003c/summary\u003e\r\n        internal static int IndexOfAnyWhiteSpace(this ReadOnlySpan\u003cchar\u003e span)\r\n        {\r\n            int i = span.IndexOfAnyExcept(Utilities.s_asciiExceptWhiteSpace);\r\n            if ((uint)i \u003c (uint)span.Length)\r\n            {\r\n                if (span[i] \u003c= 0x7f)\r\n                {\r\n                    return i;\r\n                }\r\n        \r\n                do\r\n                {\r\n                    if (char.IsWhiteSpace(span[i]))\r\n                    {\r\n                        return i;\r\n                    }\r\n                    i++;\r\n                }\r\n                while ((uint)i \u003c (uint)span.Length);\r\n            }\r\n        \r\n            return -1;\r\n        }\r\n        \r\n        /// \u003csummary\u003eSupports searching for characters in or not in \"\\0\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\a\\b\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f!\\\"#$%\u0026amp;\u0027()*+,-./0123456789:;\u0026lt;=\u0026gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\u007f\".\u003c/summary\u003e\r\n        internal static readonly IndexOfAnyValues\u003cchar\u003e s_asciiExceptWhiteSpace = IndexOfAnyValues.Create(\"\\0\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\a\\b\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f!\\\"#$%\u0026\u0027()*+,-./0123456789:;\u003c=\u003e?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\u007f\");\r\n```\r\nand for `\\S`:\r\n```C#\r\n        /// \u003csummary\u003eFinds the next index of any character that matches any character other than a space character.\u003c/summary\u003e\r\n        internal static int IndexOfAnyExceptWhiteSpace(this ReadOnlySpan\u003cchar\u003e span)\r\n        {\r\n            int i = span.IndexOfAnyExcept(Utilities.s_asciiWhiteSpace);\r\n            if ((uint)i \u003c (uint)span.Length)\r\n            {\r\n                if (span[i] \u003c= 0x7f)\r\n                {\r\n                    return i;\r\n                }\r\n        \r\n                do\r\n                {\r\n                    if (!char.IsWhiteSpace(span[i]))\r\n                    {\r\n                        return i;\r\n                    }\r\n                    i++;\r\n                }\r\n                while ((uint)i \u003c (uint)span.Length);\r\n            }\r\n        \r\n            return -1;\r\n        }\r\n        \r\n        /// \u003csummary\u003eSupports searching for characters in or not in \"\\t\\n\\v\\f\\r \".\u003c/summary\u003e\r\n        internal static readonly IndexOfAnyValues\u003cchar\u003e s_asciiWhiteSpace = IndexOfAnyValues.Create(\"\\t\\n\\v\\f\\r \");\r\n```\r\n(It\u0027s capable now of emitting many variations of these... it just chooses good names for the methods for these known sets, but will generate a similarly shaped method for any set it doesn\u0027t have a better strategy for.)\r\n\r\nI suggest we put this issue on hold until we get some more experience with those implementations and how they fair.  Once we\u0027re happy with them, we can effectively promote them up to MemoryExtensions per this issue, and the regex source generator / compiler can be changed to use those instead.",
                                           "updatedAt":  "2023-03-29T02:38:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5eYOPD",
                                           "createdAt":  "2023-06-08T21:40:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODANaLA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AlexRadch",
                                                                               "createdAt":  "2023-07-10T05:01:36Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "A nit - the names `IndexOfAnyWhiteSpace` and `IndexOfAnyExceptWhiteSpace` read very strangely to me. I know we\u0027re establishing a pattern around _Any_ and _AnyExcept_, but is it possible to tweak these names to make them a little more human? Breaking the naming pattern in this instance might help improve readability and understandability.\r\n\r\nI\u0027m assuming the respective definitions are \"return the index of the first whitespace char you see; or -1 if you find no whitespace chars or the string is empty\" and \"return the index of the first non-whitespace char you see; or -1 if the string contains only whitespace chars or is empty.\"\r\n\r\nSome proposals:\r\n\r\n* `IndexOfWhiteSpace` and `IndexOfNonWhiteSpace` (remove the \"any\", since the term whitespace already implies a set of possible matching characters rather than a single possible char match)\r\n* `IndexOfAnyWhiteSpace` and `IndexOfAnyNonWhiteSpace` (keep the \"any\"; change the \"except\" to \"non\")",
                                           "updatedAt":  "2023-06-08T21:40:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5xA61H",
                                           "createdAt":  "2024-01-17T15:37:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "The capitalization of space in WhiteSpace is jarring for me given we consistently write whitespace as a single word even in this very issue. ",
                                           "updatedAt":  "2024-01-17T15:37:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5xA_YX",
                                           "createdAt":  "2024-01-17T15:46:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOECd46g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "danmoseley",
                                                                               "createdAt":  "2024-01-17T18:21:09Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AlexRadch",
                                                                               "createdAt":  "2025-01-14T22:34:20Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e The capitalization of space in WhiteSpace is jarring for me given we consistently write whitespace as a single word even in this very issue.\r\n\r\nI don\u0027t disagree, but we have `char.IsWhiteSpace`, `Rune.IsWhiteSpace`, `string.IsNullOrWhiteSpace`, `MemoryExtensions.IsWhiteSpace`, `ArgumentException.ThrowIfNullOrWhiteSpace`, `FromBase64TransformMode.IgnoreWhiteSpaces`, ... outside of System.Xml and one enum value in regex, we\u0027ve pretty consistently used \"WhiteSpace\" rather than \"Whitespace\" and shouldn\u0027t change now.",
                                           "updatedAt":  "2024-01-17T15:46:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5xCU-3",
                                           "createdAt":  "2024-01-17T18:47:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bartonjs",
                                           "body":  "It was contentious enough that Krzysztof wrote it in the table of correct spellings in Framework Design Guidelines 2nd edition (or maybe even first).\r\n\r\n\u003e Pascal: WhiteSpace, Camel: whiteSpace, Not: Whitespace\r\n\r\nWhich is in opposition to Timestamp:\r\n\r\n\u003e Pascal: Timestamp, Camel: timestamp, Not: TimeStamp\r\n\r\n",
                                           "updatedAt":  "2024-01-17T18:47:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6acn7K",
                                           "createdAt":  "2025-01-14T22:03:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AlexRadch",
                                           "body":  "\u003e Looks good as proposed.\n\n@bartonjs The proposed method, **ContainsAnyExceptWhiteSpace**, is essentially a negation of the existing **IsWhiteSpace** method. I suggest reconsidering its addition, as it appears redundant given the functionality already provided by **IsWhiteSpace**.",
                                           "updatedAt":  "2025-01-14T22:03:00Z"
                                       }
                                   ],
                         "totalCount":  11
                     },
        "title":  "[API Proposal]: MemoryExtensions.IndexOfAny{Except}WhiteSpace",
        "labels":  [
                       "api-approved",
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/78877",
        "createdAt":  "2022-11-26T20:53:30Z",
        "number":  78877,
        "author":  "rickbrew",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCsQkUQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Zintom",
                                            "createdAt":  "2022-11-27T13:18:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "damian-666",
                                            "createdAt":  "2023-01-15T20:46:34Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "damian-666",
                                            "createdAt":  "2023-01-15T20:46:34Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2023-03-19T01:51:15Z",
        "body":  "Methods such as `Span.Fill()` and `MemoryExtensions.IndexOfAnyExcept()` have vectorized code paths when the element size is 1, 2, 4, or 8 (and some other criteria). I\u0027d like to request these be extended to cover 16 byte elements as well.\r\n\r\nIf I understand correctly, this should now be feasible to implement now that `Vector128\u003cT\u003e` can be used cross-architecture, e.g. when `Vector128.IsHardwareAccelerated` is true, instead of having to write architecture-specific intrinsics.\r\n\r\nIn Paint.NET, I have a bunch of methods that I\u0027m converting from my own vectorized code over to using runtime methods:\r\n\r\n- `BitwiseFill` -- Obviously can just use `Unsafe.InitBlockUnaligned()`. This was written in a time before `Span\u003cT\u003e` was super great (e.g. .NET Framework)\r\n- `BitwiseEquals` -- Similar story\r\n- `BitwiseIsHomogenous` -- Checks that a buffer of `T`\u0027s is all the same bitwise value, and returns that value. I\u0027m switching this to use `MemoryExtensions.IndexOfAnyExcept()`.\r\n- `BitwiseAllEqualTo` -- Similar to `BitwiseIsHomogeous`, except you provide the comparison `T`.\r\n\r\nThe last two methods are important for Paint.NET\u0027s memory use and performance. My rendering engine is tile-based, which means almost all rendering and bitmap storage is broken up into 128x128 pixel tiles. When a tile is _homogenous_ -- its pixels are all the same color -- I can free that bitmap and replace it with a cached singleton bitmap that is filled with that color. This allows me to save a lot of memory in some important scenarios, such as when a user is working on an image that has many layers, but where most layers are only sparsely populated (mostly filled with `#00000000` in other words). This also helps performance by way of improving CPU cache utilization.\r\n\r\nRegarding the request for 16-byte elements: Almost all of Paint.NET\u0027s CPU-side pixel-pushing is for `ColorBgra32` or `ColorPbgra32` (premultiplied) pixels, which are 4 bytes. My new v5.0 release is now doing a lot of processing on the GPU, which is mostly done with `ColorRgba128Float` / `ColorPrgba128Float`. I don\u0027t work with these buffers on the CPU, _but_ in a future version I am planning to expand layers so they can support non-`ColorBgra32` pixel formats (e.g. `ColorRgba64` and `ColorRgba128Float`). In that case I will need vectorized versions of the above methods that can handle 16-byte elements. The methods are very fast -- they rarely show up in a profiler such as Windows Performance Analyzer -- and this would help keep them that way.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOV-u5GQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5PKWOW",
                                           "createdAt":  "2022-11-26T20:53:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-11-26T20:53:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PKWZi",
                                           "createdAt":  "2022-11-26T20:57:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nMethods such as `Span.Fill()` and `MemoryExtensions.IndexOfAnyExcept()` have vectorized code paths when the element size is 1, 2, 4, or 8 (and some other criteria). I\u0027d like to request these be extended to cover 16 byte elements as well.\r\n\r\nIf I understand correctly, this should now be feasible to implement now that `Vector128\u003cT\u003e` can be used cross-architecture, e.g. when `Vector128.IsHardwareAccelerated` is true, instead of having to write architecture-specific intrinsics.\r\n\r\nIn Paint.NET, I have a bunch of methods that I\u0027m converting from my own vectorized code over to using runtime methods:\r\n\r\n- `BitwiseFill` -- Obviously can just use `Unsafe.InitBlockUnaligned()`. This was written in a time before `Span\u003cT\u003e` was super great (e.g. .NET Framework)\r\n- `BitwiseEquals` -- Similar story\r\n- `BitwiseIsHomogenous` -- Checks that a buffer of `T`\u0027s is all the same bitwise value, and returns that value. I\u0027m switching this to use `MemoryExtensions.IndexOfAnyExcept()`.\r\n- `BitwiseAllEqualTo` -- Similar to `BitwiseIsHomogeous`, except you provide the comparison `T`.\r\n\r\nThe last two methods are important for Paint.NET\u0027s memory use and performance. My rendering engine is tile-based, which means almost all rendering and bitmap storage is broken up into 128x128 pixel tiles. When a tile is _homogenous_ -- its pixels are all the same color -- I can free that bitmap and replace it with a cached singleton bitmap that is filled with that color. This allows me to save a lot of memory in some important scenarios, such as when a user is working on an image that has many layers, but where most layers are only sparsely populated (mostly filled with `#00000000` in other words). This also helps performance by way of improving CPU cache utilization.\r\n\r\nRegarding the request for 16-byte elements: Almost all of Paint.NET\u0027s CPU-side pixel-pushing is for `ColorBgra32` or `ColorPbgra32` (premultiplied) pixels, which are 4 bytes. My new v5.0 release is now doing a lot of processing on the GPU, which is mostly done with `ColorRgba128Float` / `ColorPrgba128Float`. I don\u0027t work with these buffers on the CPU, _but_ in a future version I am planning to expand layers so they can support non-`ColorBgra32` pixel formats (e.g. `ColorRgba64` and `ColorRgba128Float`). In that case I will need vectorized versions of the above methods that can handle 16-byte elements. The methods are very fast -- they rarely show up in a profiler such as Windows Performance Analyzer -- and this would help keep them that way.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003erickbrew\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Memory`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-11-26T20:57:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5X67kZ",
                                           "createdAt":  "2023-03-19T01:51:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "brantburnett",
                                           "body":  "I may be misreading things, but `Span\u003cT\u003e.Fill` appears to already vectorize 16-byte and even 32-byte primitives where CPU support is available: https://github.com/dotnet/runtime/pull/51365\r\n\r\nI do agree that it may be possible to handle bitwise-equatable 16-byte primitives through a vectorized path in `MemoryExtensions.IndexOfAnyExcept`.\r\n",
                                           "updatedAt":  "2023-03-19T01:51:14Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Add vectorized code paths to cover 16-byte element sizes (e.g. Span.Fill, MemoryExtensions.IndexOfAnyExcept)",
        "labels":  [
                       "area-System.Memory",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/80875",
        "createdAt":  "2023-01-19T20:15:09Z",
        "number":  80875,
        "author":  "steveisok",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-22T16:54:41Z",
        "body":  "Looks like `CreateDelegate` in https://github.com/dotnet/runtime/blob/4e0195e02fac31032cc8ffd759a6054e3107844a/src/libraries/System.Memory/tests/Span/IndexOfAnyValues.cs#L18-L22 \r\n\r\nis something mono aot can\u0027t handle.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOU0zQxA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5TTNDE",
                                           "createdAt":  "2023-01-19T20:15:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nLooks like `CreateDelegate` in https://github.com/dotnet/runtime/blob/4e0195e02fac31032cc8ffd759a6054e3107844a/src/libraries/System.Memory/tests/Span/IndexOfAnyValues.cs#L18-L22 \r\n\r\nis something mono aot can\u0027t handle.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003esteveisok\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Memory`, `os-ios`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-01-19T20:15:21Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "[iOS] SpanTests.IndexOfAnyValues_GetValues test fails trying to JIT in AOT mode",
        "labels":  [
                       "area-System.Memory",
                       "disabled-test",
                       "os-ios"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/84838",
        "createdAt":  "2023-04-14T13:58:33Z",
        "number":  84838,
        "author":  "YohDeadfall",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODCanBg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Charlieface",
                                            "createdAt":  "2024-06-20T11:11:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "bent-rasmussen",
                                            "createdAt":  "2025-05-15T13:10:48Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2024-07-19T16:35:06Z",
        "body":  "### Background and motivation\n\nThe `MemoryExtensions` type provides `SequenceCompareTo` methods which has just two overloads, but none of them is accepting a custom element comparer making it impossible to compare two sequences without allocating new buffers or without implementing the required overload outside of the standard library.\r\n\r\nAt the same time the type has overloads accepting a custom equality comparer for equality comparison.\r\n\r\nIf it\u0027s approved, I would like to provide an implementation for it.\n\n### API Proposal\n\n```csharp\r\nnamespace System;\r\n\r\npublic static class MemoryExtensions\r\n{\r\n    public static int SequenceCompareTo(this Span\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other, IComparer\u003cT\u003e? comparer = default);\r\n\r\n    public static int SequenceCompareTo(this ReadOnlySpan\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other, IComparer\u003cT\u003e? comparer = default);\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nSpan\u003cstring\u003e s1;\r\nSpan\u003cstring\u003e s2;\r\n\r\nint result = s1.SequenceCompareTo(StringComparer.CurrentCultureIgnoreCase);\r\n```\r\n\n\n### Alternative Designs\n\nWhen two input sequences are arrays, then one of them can be casted to `IStructuralComparable` and do comparison, but that solution isn\u0027t obvious because the interface is implemented explicitly. In addition to that `CompareTo` of the interface accepts a non-generic `IComparer` which looses type safety and potentially hurts performance (if there\u0027s no under the hood cast of the passed comparer to `IComparer\u003cT\u003e` to be used then).\r\n\r\nIf both sequences were received as spans, then to use the mentioned alternative solution `ToArray` must be called on the spans which leads to unwanted memory allocations.\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOZZWVcA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5Z6um_",
                                           "createdAt":  "2023-04-14T13:58:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nThe `MemoryExtensions` type provides `SequenceCompareTo` methods which has just two overloads, but none of them is accepting a custom element comparer making it impossible to compare two sequences without allocating new buffers or without implementing the required overload outside of the standard library.\r\n\r\nAt the same time the type has overloads accepting a custom equality comparer for equality comparison.\r\n\r\nIf it\u0027s approved, I would like to provide an implementation for it.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Collections.Generic;\r\n\r\npublic static class MemoryExtensions\r\n{\r\n    public static int SequenceCompareTo(this Span\u003cT\u003e span, Span\u003cT\u003e other, IComparer\u003cT\u003e? comparer = default);\r\n\r\n    public static int SequenceCompareTo(this ReadOnlySpan\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other, IComparer\u003cT\u003e? comparer = default);\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nSpan\u003cstring\u003e s1;\r\nSpan\u003cstring\u003e s2;\r\n\r\nint result = s1.SequenceCompareTo(StringComparer.CurrentCultureIgnoreCase);\r\n```\r\n\n\n### Alternative Designs\n\nWhen two input sequences are arrays, then one of them can be casted to `IStructuralComparable` and do comparison, but that solution isn\u0027t obvious because the interface is implemented explicitly. In addition to that `CompareTo` of the interface accepts a non-generic `IComparer` which looses type safety and potentially hurts performance (if there\u0027s no under the hood cast of the passed comparer to `IComparer\u003cT\u003e` to be used then).\r\n\r\nIf both sequences were received as spans, then to use the mentioned alternative solution `ToArray` must be called on the spans which leads to unwanted memory allocations.\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eYohDeadfall\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Memory`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-04-14T13:58:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Z7yCj",
                                           "createdAt":  "2023-04-14T15:49:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "cucumber-sp",
                                           "body":  "I don\u0027t think it\u0027s possible to add `IComparer\u003cT\u003e` overload to existing API without losing performance. Right now it uses Avx2 and per-byte comparison for values. Using any comparer, even default, will make it much slower. ",
                                           "updatedAt":  "2023-04-14T15:49:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Z77fT",
                                           "createdAt":  "2023-04-14T15:59:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "YohDeadfall",
                                           "body":  "\u003e Right now it uses Avx2 and per-byte comparison for values. Using any comparer, even default, will make it much slower.\r\n\r\nDon\u0027t see it: \r\n\r\nhttps://github.com/dotnet/runtime/blob/a0e23f41e8f40db72b6203855d9858aadb7193ee/src/libraries/System.Private.CoreLib/src/System/SpanHelpers.T.cs#L1288-L1305\r\n\r\nIf there\u0027s no comparer or it is a default one, then fallback to an overload without a comparer as it happens for equality. \r\n\r\nhttps://github.com/dotnet/runtime/blob/932efb5824f10622664feebceb486b032b615ccd/src/libraries/System.Private.CoreLib/src/System/MemoryExtensions.cs#L2201-L2203",
                                           "updatedAt":  "2023-04-14T15:59:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5llYwQ",
                                           "createdAt":  "2023-09-03T12:57:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "Is there anything preventing this from being ready to review?",
                                           "updatedAt":  "2023-09-03T12:57:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5llY6p",
                                           "createdAt":  "2023-09-03T13:00:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "This is the proposal next to the existing methods, for reference:\r\n```diff\r\n namespace System;\r\n \r\n public static partial class MemoryExtensions\r\n {\r\n     public static bool SequenceEqual\u003cT\u003e(this ReadOnlySpan\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other) where T : IEquatable\u003cT\u003e?;\r\n     public static bool SequenceEqual\u003cT\u003e(this Span\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other) where T : IEquatable\u003cT\u003e?;\r\n     public static bool SequenceEqual\u003cT\u003e(this ReadOnlySpan\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other, IEqualityComparer\u003cT\u003e? comparer = null);\r\n     public static bool SequenceEqual\u003cT\u003e(this Span\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other, IEqualityComparer\u003cT\u003e? comparer = null);\r\n     public static int SequenceCompareTo\u003cT\u003e(this ReadOnlySpan\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other) where T : IComparable\u003cT\u003e?;\r\n     public static int SequenceCompareTo\u003cT\u003e(this Span\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other) where T : IComparable\u003cT\u003e?;\r\n+    public static int SequenceCompareTo(this ReadOnlySpan\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other, IComparer\u003cT\u003e? comparer = null);\r\n+    public static int SequenceCompareTo(this Span\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other, IComparer\u003cT\u003e? comparer = null);\r\n }\r\n\r\n```",
                                           "updatedAt":  "2023-09-03T13:05:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5llZD0",
                                           "createdAt":  "2023-09-03T13:02:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "@YohDeadfall You should change the `Span\u003cT\u003e` overload to take `ReadOnlySpan\u003cT\u003e` as the second argument, not `Span\u003cT\u003e`, just like the existing overload always take a `ReadOnlySpan\u003cT\u003e` as the second argument (and like I showed in the comment above). There\u0027s no need to require it to be mutable. The only reason there are overloads for the first argument being both readonly and non-readonly is that when it only takes `ReadOnlySpan\u003cT\u003e`, the extension method wouldn\u0027t show up on `Span\u003cT\u003e`. But this is not a problem for the other arguments.",
                                           "updatedAt":  "2023-09-03T13:03:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5llZJv",
                                           "createdAt":  "2023-09-03T13:04:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "Also, `MemoryExtensions` is in `System`, not `System.Collections.Generic`.",
                                           "updatedAt":  "2023-09-03T13:04:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5llZVw",
                                           "createdAt":  "2023-09-03T13:07:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODFme8g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "Neme12",
                                                                               "createdAt":  "2023-09-03T13:08:59Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "YohDeadfall",
                                           "body":  "@Neme12, thank you! Fixed the proposal.",
                                           "updatedAt":  "2023-09-03T13:07:33Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "[API Proposal]: SequenceCompareTo accepting a custom comparer",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/85468",
        "createdAt":  "2023-04-27T15:37:29Z",
        "number":  85468,
        "author":  "neon-sunset",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC9p_LA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2023-05-12T13:33:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aAndrzej-dev",
                                            "createdAt":  "2023-07-10T21:24:45Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MineCake147E",
                                            "createdAt":  "2023-08-18T02:26:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Enderlook",
                                            "createdAt":  "2024-12-21T15:52:26Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2024-07-19T16:35:07Z",
        "body":  "### Background and motivation\r\n\r\nCurrently, there are numerous types that have `.AsSpan()` method.\r\nHowever, because as of today it is impossible to use ref structs in generic constraints, it is impossible to implement a generic container type that would conveniently support spans as element lookup argument as well as a variety of different scenarios.\r\nWith this interface, it will be possible to constraint around `SomeCollection\u003cT, U\u003e where T : IReadOnlySpanConvertible\u003cU\u003e` and expose methods such as `.TryGet(ReadOnlySpan\u003cU\u003e)` in a generic way.\r\nIt would be likely expected that types will be implementing either of those, allowing for the user to cast Span to ROS as needed afterwards.\r\n\r\nThe goal is to enable easy accepting and passing of types that don\u0027t necessarily have the lifetime constraints of span but which can provide one.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\npublic interface ISpanConvertible\u003cT\u003e : IReadOnlySpanConvertible\u003cT\u003e\r\n{\r\n    new Span\u003cT\u003e AsSpan();\r\n\r\n    ReadOnlySpan\u003cT\u003e IReadOnlySpanConvertible\u003cT\u003e.AsSpan() =\u003e AsSpan();\r\n}\r\n\r\npublic interface IReadOnlySpanConvertible\u003cT\u003e\r\n{\r\n    ReadOnlySpan\u003cT\u003e AsSpan();\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\nThis is somewhat crude example, I think we will need a better way to express the pattern below (Extensions?) without forcing the users to specify both generic type arguments i.e. only T instead of T, U.\r\n```csharp\r\n// Fancy the value\r\nvar collection = new SpanSupportingCollection\u003cchar\u003e();\r\ncollection.Add(\"hello world!\"); // Add\u003cT\u003e where T : IReadOnlySpanConvertible\u003cchar\u003e -\u003e collection copies the element to private container, be it span, pooled array or something else\r\n\r\nvar span = \"hello world!\\r\\n\".AsSpan().Trim(\"\\r\\n\");\r\n\r\n// Contains\u003cT\u003e where T : IReadOnlySpanConvertible\u003cU\u003e and, as of .NET 8, ROS\u003cU\u003e would implement it on itself\r\n// Or we can just expose a non-generic overload\r\nDebug.Assert(collection.Contains(span));\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nRely on implicit/explicit casting to spans and just accept spans instead.\r\n\r\n### Risks\r\n\r\nN/A",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOZhdwWA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5a86j2",
                                           "createdAt":  "2023-04-27T15:37:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nCurrently, there are numerous types that have `.AsSpan()` method.\r\nHowever, because as of today it is impossible to use ref structs in generic constraints, it is impossible to implement a generic container type that would conveniently support spans as element lookup argument as well as a variety of different scenarios.\r\nWith this interface, it will be possible to constrain around `SomeCollection\u003cT\u003e where T : IReadOnlySpanProvider\u003cU\u003e` and expose methods such as `.TryGet(ReadOnlySpan\u003cU\u003e)` in a generic way.\r\nIt would be likely expected that types will be implementing either of those, allowing for the user to cast Span to ROS as needed afterwards.\n\n### API Proposal\n\n```csharp\r\npublic interface ISpanProvider\u003cT\u003e\r\n{\r\n    public Span\u003cT\u003e AsSpan();\r\n}\r\n\r\npublic interface IReadOnlySpanProvider\u003cT\u003e\r\n{\r\n    public ReadOnlySpan\u003cT\u003e AsSpan();\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\n// Fancy the value\r\nvar collection = new SpanSupportingCollection\u003cstring\u003e(); // where T : IReadOnlySpanProvider\u003cU\u003e\r\nc.Add(\"hello world!\");\r\n\r\nvar span = \"hello world\\r\\n\".AsSpan().Trim(\"\\r\\n\");\r\n\r\n// collection implements Contains(ROS\u003cU\u003e) based on the provider constraint\r\nDebug.Assert(collection.Contains(span));\r\n```\r\n\n\n### Alternative Designs\n\nPerhaps a better pattern will be possible with Extensions and ref structs in generic arguments?\n\n### Risks\n\nN/A\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eneon-sunset\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Memory`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-04-27T15:37:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5a9QV4",
                                           "createdAt":  "2023-04-27T16:35:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "DrkWzrd",
                                           "body":  "What if one class can (or should) implement both interfaces? The signature of the methods should be different. `AsSpan\u003cT\u003e()`, `AsReadOnlySpan\u003cT\u003e()` (if it can be generic it should be generic, maybe there are types can be \"spanned\" in many ways, chars, bytes, integers...\r\n\r\nBut I agree that this should be done as much soon as you can, in order to avoid breaking changes in future versions and with user-made extension methods.",
                                           "updatedAt":  "2023-04-27T16:35:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5a9ejy",
                                           "createdAt":  "2023-04-27T17:23:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "neon-sunset",
                                           "body":  "@DrkWzrd that is true, but this can be done with explicit interface implementation i.e. `IReadOnlySpanProvider\u003cT\u003e.AsSpan() { ... }`. This is because `string` has `.AsSpan()` which returns ROS yet `T[]` returns just Span. Under the condition of both interfaces being implemented, I think it would make sense for `Span\u003cT\u003e` return taking precedence over `ROS\u003cT\u003e`, ideally Roslyn should always be able to target type such a use case if my understanding is correct. The initial idea is that only one of these is implemented, since `Span\u003cT\u003e` can be assigned to `ROS\u003cT\u003e` as needed.",
                                           "updatedAt":  "2023-04-27T17:23:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5a-rGv",
                                           "createdAt":  "2023-04-27T20:25:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODD_yTA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2023-05-12T13:33:57Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MineCake147E",
                                                                               "createdAt":  "2023-08-18T02:27:00Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "Should `ISpanProvider\u003cT\u003e` autoimplement `IReadOnlySpanProvider\u003cT\u003e` with a DIM?",
                                           "updatedAt":  "2023-04-27T20:25:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5a-zMo",
                                           "createdAt":  "2023-04-27T20:41:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "neon-sunset",
                                           "body":  "@MichalPetryka  This makes perfect sense, thanks, proposal updated.",
                                           "updatedAt":  "2023-04-27T20:43:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5dQmjh",
                                           "createdAt":  "2023-05-26T16:22:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "CC. @stephentoub for input.\r\n\r\nThe general premise seems reasonable and it would allow some potentially interesting optimizations (such as in LINQ). I\u0027m not necessarily sold on the name, however.",
                                           "updatedAt":  "2023-05-26T16:22:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5dQpuj",
                                           "createdAt":  "2023-05-26T16:35:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "The main issue here would be with safety on resizable collections like `List\u003cT\u003e`.",
                                           "updatedAt":  "2023-05-26T16:35:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5dQrCt",
                                           "createdAt":  "2023-05-26T16:40:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "I seem to remember discussing this on other issues in the past, but my search skills are failing me now.\r\n\r\nMy main concern would be around how we navigate the safety divide, which @MichalPetryka just alluded to.\r\n\r\nImplementing it also exposes what might otherwise be an implementation detail (that you\u0027re backed by contiguous memory), though a collection implementer could decide how important it is lock themselves into a particular implementation like that.  We decided for `List\u003cT\u003e` we could never change it, anyway, but there aren\u0027t that many other collections in .NET we\u0027d say the same thing for.  `T[]`, `string`, `List\u003cT\u003e`, and `ImmutableArray\u003cT\u003e`... beyond that, few come to mind.",
                                           "updatedAt":  "2023-05-26T16:40:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5mF3BY",
                                           "createdAt":  "2023-09-10T13:17:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "DrkWzrd",
                                           "body":  "@stephentoub \r\n\r\n\u003e Implementing it also exposes what might otherwise be an implementation detail (that you\u0027re backed by contiguous memory), though a collection implementer could decide how important it is lock themselves into a particular implementation like that\r\n\r\nIf this is a big concern, instead of implement this both interfaces, maybe just implement `IReadOnly` and instead of `Span`, switch to `IReadOnlySequenceable\u003cT\u003e` (naming is hard). This will be a little headache for implementers, but you ensure you can do what ever you want and not get locked in an scenario only valid if you use contiguous memory.\r\n\r\nI think this might be addressed as \"If we need to write inside it, it must be with `Span`/`Memory` and must be contiguous\". It\u0027s still useful in some scenarios, like `String`, `Utf8String` or maybe some other user-created types with an array as storage.\r\n\r\nBut \"If you want to read it, it can be a series of different fragments of memory in an sequence. It could be one only fragment, but you will have to ask for yourself.\"\r\n\r\n\u003e My main concern would be around how we navigate the safety divide\r\n\r\nMaybe ensuring that if you want read, you\u0027ll get only the count (or ask to user) and if you want to write, ensuring a minimumCapacity for the span.\r\n\r\n```C#\r\npublic interface ISpanConvertible\u003cT\u003e : IReadOnlySpanConvertible\u003cT\u003e\r\n{\r\n    Span\u003cT\u003e AsSpan(int minimumCapacity);  //if it doesn\u0027t exceed the original capacity, keep the original capacity.\r\n}\r\n\r\npublic interface IReadOnlySpanConvertible\u003cT\u003e\r\n{\r\n    ReadOnlySpan\u003cT\u003e AsReadOnlySpan(bool trimToCount= true); //or length, or size, or the opposite \"bool keepCapacity\" but i don\u0027t see any use in this;\r\n}\r\n\r\npublic interface IReadOnlySequenceable\u003cT\u003e\r\n{\r\n   ReadOnlySequence\u003cT\u003e AsReadOnlySequence(bool trimToCount = true);\r\n}\r\n```\r\nPS: I\u0027m not sure about using the same signature and DIM for `ROS` and `Span`.",
                                           "updatedAt":  "2023-09-10T13:20:20Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "[API Proposal]: `ISpanConvertible\u003cT\u003e`/`IReadOnlySpanConvertible\u003cT\u003e` interface to generalize types with `.AsSpan()` method",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/87691",
        "createdAt":  "2023-06-16T14:03:58Z",
        "number":  87691,
        "author":  "MihaZupan",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-19T16:35:11Z",
        "body":  "We have an existing analyzer/fixer [CA2249](https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2249) that flags patterns like `string.IndexOf(\u0027a\u0027) \u003e= 0` and suggests replacing the call with `string.Contains(\u0027a\u0027)`.\r\n\r\nWe should consider expanding that to also flag patterns like\r\n- `span.IndexOf(\u0027a\u0027) \u003e= 0` =\u003e `span.Contains(\u0027a\u0027)`\r\n- `span.IndexOfAny(\u0027a\u0027, \u0027b\u0027) \u003e= 0` =\u003e `span.ContainsAny(\u0027a\u0027, \u0027b\u0027)`\r\n- `span.IndexOfAnyExcept(\u0027a\u0027, \u0027b\u0027) \u003e= 0` =\u003e `span.ContainsAnyExcept(\u0027a\u0027, \u0027b\u0027)`\r\n\r\nand their inverse variants\r\n- `span.IndexOf(\u0027a\u0027) \u003c 0` =\u003e `!span.Contains(\u0027a\u0027)`\r\n- `span.IndexOfAny(\u0027a\u0027, \u0027b\u0027) \u003c 0` =\u003e `!span.ContainsAny(\u0027a\u0027, \u0027b\u0027)`\r\n- `span.IndexOfAnyExcept(\u0027a\u0027, \u0027b\u0027) \u003c 0` =\u003e `!span.ContainsAnyExcept(\u0027a\u0027, \u0027b\u0027)`\r\n\r\nUnlike with strings, these shouldn\u0027t run into issues w.r.t. culture.\r\n\r\nSuggested category: usage / performance\r\nSuggested severity: suggestion",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOXw2scg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5fDaxy",
                                           "createdAt":  "2023-06-16T14:04:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nWe have an existing analyzer/fixer [CA2249](https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2249) that flags patterns like `string.IndexOf(\u0027a\u0027) \u003e= 0` and suggests replacing the call with `string.Contains(\u0027a\u0027)`.\r\n\r\nWe should consider expanding that to also flag patterns like\r\n- `span.IndexOf(\u0027a\u0027) \u003e= 0` =\u003e `span.Contains(\u0027a\u0027)`\r\n- `span.IndexOfAny(\u0027a\u0027, \u0027b\u0027) \u003e= 0` =\u003e `span.ContainsAny(\u0027a\u0027, \u0027b\u0027)`\r\n- `span.IndexOfAnyExcept(\u0027a\u0027, \u0027b\u0027) \u003e= 0` =\u003e `span.ContainsAnyExcept(\u0027a\u0027, \u0027b\u0027)`\r\n\r\nUnlike with strings, these shouldn\u0027t run into issues w.r.t. culture.\r\n\r\nSuggested category: usage / performance\r\nSuggested severity: suggestion\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eMihaZupan\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Memory`, `code-analyzer`, `code-fixer`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-06-16T14:04:08Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "[Analyzer]: Extend string IndexOf =\u003e Contains analyzers to Span IndexOf/IndexOfAny/IndexOfAnyExcept",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory",
                       "code-analyzer",
                       "code-fixer",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/89804",
        "createdAt":  "2023-08-01T19:56:56Z",
        "number":  89804,
        "author":  "dersia",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-08-05T23:01:45Z",
        "body":  "### Background and motivation\r\n\r\nOur aspnet web api backend takes files from the frontend and uploads those to Azure Storage Blobs.\r\n\r\nWe use BlobClient.Upload and we also have to call update on the properties to set the content-type of the blob.\r\nWith the new Media-Type on `BinaryData` (https://github.com/dotnet/runtime/pull/89605) we would like to take advantage of this feature so don\u0027t have to make multiple calls on the BlobClient, and in general I think there is benefit in using `BinaryData` overall.\r\nBut as of today `BinaryData.FromStream()` copies the stream as you can see here https://github.com/dotnet/runtime/blob/f60757ad40a36b44d471f1cb72614368eb51a1fd/src/libraries/System.Memory.Data/src/System/BinaryData.cs#L173-L208\r\n\r\nBecause of this `BinaryData` is not useable for us. So I would like to suggest an API that would not copy the stream. \r\n\r\nThis makes `BinaryData` convenient to use and avoid extra allocation. \r\n\r\n### API Proposal\r\n\r\n```cs\r\nnamespace System;\r\n\r\npublic class BinaryData\r\n{\r\n    // existing methods with https://github.com/dotnet/runtime/pull/89605\r\n    public static BinaryData FromStream(Stream stream);\r\n    public static BinaryData FromStream(Stream stream, string? mediaType);\r\n    public static Task\u003cBinaryData\u003e FromStreamAsync(Stream stream, CancellationToken cancellationToken = default);\r\n    public static Task\u003cBinaryData\u003e FromStreamAsync(Stream stream, string? mediaType, CancellationToken cancellationToken = default);\r\n\r\n    // new api\r\n    public static BinaryData FromStream(Stream stream, bool copyContent = true);\r\n    public static BinaryData FromStream(Stream stream, string? mediaType, bool copyContent = true);\r\n    public static Task\u003cBinaryData\u003e FromStreamAsync(Stream stream, bool copyContent = true, CancellationToken cancellationToken = default);\r\n    public static Task\u003cBinaryData\u003e FromStreamAsync(Stream stream, string? mediaType, bool copyContent = true, CancellationToken cancellationToken = default);\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n\r\n```csharp\r\npublic async Task UploadBlob(Stream fileStream, string mediaType, CancellationToken cancellationToken = default)\r\n{\r\n    var data = BinrayData.FromString(fileStream, mediaType, false);\r\n    await blobClient.UploadAsync(data, stream, true, cancellationToken).ConfigureAwait(false);\r\n}\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nAlternatively `FromStream` could be overloaded but I think this would be a source breaking change.\r\nAnother alternative would be to make FromStream not to copy at all, but I think this will be a breaking behavior and might lead to bugs, where it \"just\" works for users even if the underlying stream was closed in the meantime.  \r\n\r\n### Risks\r\n\r\nIf called with copyContent false, this could lead to an exception, if the underlying stream is closed, but I think this is something that users are familiar with and with the bool parameter explicitly set to false, users are opting into this behavior and therefor it should be fine, if an exception is thrown.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOh05loA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5jALSJ",
                                           "createdAt":  "2023-08-01T19:57:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-io\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nOur aspnet web api backend takes files from the frontend and uploads those to Azure Storage Blobs.\r\n\r\nWe use BlobClient.Upload and we also have to call update on the properties to set the content-type of the blob.\r\nWith the new Media-Type on `BinaryData` (https://github.com/dotnet/runtime/pull/89605) we would like to take advantage of this feature so don\u0027t have to make multiple calls on the BlobClient, and in general I think there is benefit in using `BinaryData` overall.\r\nBut as of today `BinaryData.FromStream()` copies the stream as you can see here https://github.com/dotnet/runtime/blob/f60757ad40a36b44d471f1cb72614368eb51a1fd/src/libraries/System.Memory.Data/src/System/BinaryData.cs#L173\r\n\r\nBecause of this `BinaryData` is not useable for us. So I would like to suggest an API that would not copy the stream. \r\n\r\nThis makes `BinaryData` convenient to use and avoid extra allocation. \n\n### API Proposal\n\n```cs\r\nnamespace System;\r\n\r\npublic class BinaryData\r\n{\r\n    // existing methods with https://github.com/dotnet/runtime/pull/89605\r\n    public static BinaryData FromStream(Stream stream);\r\n    public static BinaryData FromStream(Stream stream, string? mediaType);\r\n    public static Task\u003cBinaryData\u003e FromStreamAsync(Stream stream, CancellationToken cancellationToken = default);\r\n    public static Task\u003cBinaryData\u003e FromStreamAsync(Stream stream, string? mediaType, CancellationToken cancellationToken = default);\r\n\r\n    // new api\r\n    public static BinaryData FromStream(Stream stream, bool copyContent = true);\r\n    public static BinaryData FromStream(Stream stream, string? mediaType, bool copyContent = true);\r\n    public static Task\u003cBinaryData\u003e FromStreamAsync(Stream stream, bool copyContent = true, CancellationToken cancellationToken = default);\r\n    public static Task\u003cBinaryData\u003e FromStreamAsync(Stream stream, string? mediaType, bool copyContent = true, CancellationToken cancellationToken = default);\r\n}\r\n```\r\n\n\n### API Usage\n\n\r\n```csharp\r\npublic async Task UploadBlob(Stream fileStream, string mediaType, CancellationToken cancellationToken = default)\r\n{\r\n    var data = BinrayData.FromString(fileStream, mediaType, false);\r\n    await blobClient.UploadAsync(data, stream, true, cancellationToken).ConfigureAwait(false);\r\n}\r\n```\r\n\n\n### Alternative Designs\n\nAlternatively `FromStream` could be overloaded but I think this would be a source breaking change.\r\nAnother alternative would be to make FromStream not to copy at all, but I think this will be a breaking behavior and might lead to bugs, where it \"just\" works for users even if the underlying stream was closed in the meantime.  \n\n### Risks\n\nIf called with copyContent false, this could lead to an exception, if the underlying stream is closed, but I think this is something that users are familiar with and with the bool parameter explicitly set to false, users are opting into this behavior and therefor it should be fine, if an exception is thrown.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003edersia\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.IO`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-08-01T19:57:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5jCSbU",
                                           "createdAt":  "2023-08-02T06:02:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\r\n\r\nOur aspnet web api backend takes files from the frontend and uploads those to Azure Storage Blobs.\r\n\r\nWe use BlobClient.Upload and we also have to call update on the properties to set the content-type of the blob.\r\nWith the new Media-Type on `BinaryData` (https://github.com/dotnet/runtime/pull/89605) we would like to take advantage of this feature so don\u0027t have to make multiple calls on the BlobClient, and in general I think there is benefit in using `BinaryData` overall.\r\nBut as of today `BinaryData.FromStream()` copies the stream as you can see here https://github.com/dotnet/runtime/blob/f60757ad40a36b44d471f1cb72614368eb51a1fd/src/libraries/System.Memory.Data/src/System/BinaryData.cs#L173-L208\r\n\r\nBecause of this `BinaryData` is not useable for us. So I would like to suggest an API that would not copy the stream. \r\n\r\nThis makes `BinaryData` convenient to use and avoid extra allocation. \r\n\r\n### API Proposal\r\n\r\n```cs\r\nnamespace System;\r\n\r\npublic class BinaryData\r\n{\r\n    // existing methods with https://github.com/dotnet/runtime/pull/89605\r\n    public static BinaryData FromStream(Stream stream);\r\n    public static BinaryData FromStream(Stream stream, string? mediaType);\r\n    public static Task\u003cBinaryData\u003e FromStreamAsync(Stream stream, CancellationToken cancellationToken = default);\r\n    public static Task\u003cBinaryData\u003e FromStreamAsync(Stream stream, string? mediaType, CancellationToken cancellationToken = default);\r\n\r\n    // new api\r\n    public static BinaryData FromStream(Stream stream, bool copyContent = true);\r\n    public static BinaryData FromStream(Stream stream, string? mediaType, bool copyContent = true);\r\n    public static Task\u003cBinaryData\u003e FromStreamAsync(Stream stream, bool copyContent = true, CancellationToken cancellationToken = default);\r\n    public static Task\u003cBinaryData\u003e FromStreamAsync(Stream stream, string? mediaType, bool copyContent = true, CancellationToken cancellationToken = default);\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n\r\n```csharp\r\npublic async Task UploadBlob(Stream fileStream, string mediaType, CancellationToken cancellationToken = default)\r\n{\r\n    var data = BinrayData.FromString(fileStream, mediaType, false);\r\n    await blobClient.UploadAsync(data, stream, true, cancellationToken).ConfigureAwait(false);\r\n}\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nAlternatively `FromStream` could be overloaded but I think this would be a source breaking change.\r\nAnother alternative would be to make FromStream not to copy at all, but I think this will be a breaking behavior and might lead to bugs, where it \"just\" works for users even if the underlying stream was closed in the meantime.  \r\n\r\n### Risks\r\n\r\nIf called with copyContent false, this could lead to an exception, if the underlying stream is closed, but I think this is something that users are familiar with and with the bool parameter explicitly set to false, users are opting into this behavior and therefor it should be fine, if an exception is thrown.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003edersia\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Memory`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-08-02T06:02:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wuD4v",
                                           "createdAt":  "2024-01-15T00:09:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "I don\u0027t understand the proposal. What is the behavior when not copying? Are you proposing storing the Stream object and then reading from it later when the BinaryData is consumed? That seems like a non-starter, as for example it would push a lot of possibly asynchronous and exceptional work into existing members, like the implicit cast to span. ",
                                           "updatedAt":  "2024-01-15T00:09:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5yUTg-",
                                           "createdAt":  "2024-01-30T21:28:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dersia",
                                           "body":  "@stephentoub  Sorry for the late reply.\r\n\r\nBasically yes, I am suggesting to store the Stream object and probably with an additional `leaveOpen` argument.\r\nI would like to clarify why I am suggesting this.\r\n\r\nThe problem that we are having is that we have an http endpoint that takes files. these files need to be uploaded to azure blob-storage and we also need to set the ContentType of those blobs. The Azure SDKs that do upload to Azure Storage Account have multiple overloads, for example one that takes a stream and also one that takes BinaryData. The feature that was added in https://github.com/dotnet/runtime/pull/89605 allows for BinaryData to also set the ContentType during upload and we want to make use of this feature. When using the Stream overload on the BlobClient, we would also need to make another call to update the Blob Properties so we can set the ContentType. Having said that, there is already an overload on `BinaryData` which takes a Stream as an argument, the problem with that overload is, that it copies the original stream and this does not work with lager files and we ran into memory exceptions.\r\n\r\nAs far as I understand the Runtime has already APIs that take Streams and handle correct behavior with streams, so I don\u0027t quite understand what would make this different or exceptional in that regard, but then again, you are the expert and I hope you can enlighten me here.\r\nAlso the overload that takes `BinaryData` with a stream argument as of today is internally creates a `MemoryStream` internally and copys the original stream and hase to then work with that stream, which is converted to a span so I don\u0027t quite understand why it couldn\u0027t do the same with the original stream?\r\n\r\nSorry again for the late reply and thank you,\r\nSia",
                                           "updatedAt":  "2024-01-30T21:28:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6FfU7z",
                                           "createdAt":  "2024-07-19T16:34:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODs5LXw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "KrzysztofCwalina",
                                                                               "createdAt":  "2024-08-05T22:59:43Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e As far as I understand the Runtime has already APIs that take Streams and handle correct behavior with streams, so I don\u0027t quite understand what would make this different or exceptional in that regard\n\nThe problem is the rest of the BinaryData surface area assumes the type stores all the data, which then means that methods like ToArray, ToMemory, and the implicit cast to `ReadOnlyMemory\u003cT\u003e` would all start doing I/O, not only significantly changing their performance profile, but also leading to I/O that likely should have been done asynchronously now either being done synchronously, or worse, being done asynchronously but blocking (sync over async).",
                                           "updatedAt":  "2024-07-19T16:34:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Ff1dM",
                                           "createdAt":  "2024-07-19T17:20:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "julealgon",
                                           "body":  "\u003e Our aspnet web api backend takes files from the frontend and uploads those to Azure Storage Blobs.\r\n\r\nHave you considered using pre-signed blob upload links, send those to the frontend, and have it upload directly to Azure through them?\r\n- https://learn.microsoft.com/en-us/rest/api/storageservices/delegate-access-with-shared-access-signature\r\n\r\nI know this doesn\u0027t directly answer your proposal, but figured I\u0027d mention anyways in case you were not aware of this option which tends to be substantially more efficient than roundtripping all the data twice via an indirection (your API).",
                                           "updatedAt":  "2024-07-19T17:20:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6HTmWg",
                                           "createdAt":  "2024-08-05T23:01:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KrzysztofCwalina",
                                           "body":  "cc: @seanmcc-msft",
                                           "updatedAt":  "2024-08-05T23:01:44Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "[API Proposal]: Add Method FromStream(Async) to BinaryData that does not copy ",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/90003",
        "createdAt":  "2023-08-04T08:58:53Z",
        "number":  90003,
        "author":  "Youssef1313",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-10-11T20:09:14Z",
        "body":  "### Description\n\nUsing the following benchmark:\r\n\r\n```csharp\r\n    private static readonly object[] s_arr = new object[] { new(), new(), new(), new(), new(), new(), new() };\r\n    private static readonly object s_obj = new();\r\n    [Benchmark(Baseline = true)]\r\n    public void WithoutSpan()\r\n    {\r\n        var arr = new object[s_arr.Length + 1];\r\n        Array.Copy(s_arr, arr, s_arr.Length);\r\n        arr[s_arr.Length] = s_obj;\r\n    }\r\n\r\n    [Benchmark]\r\n    public void WithSpan()\r\n    {\r\n        var arr = new object[s_arr.Length + 1];\r\n        Span\u003cobject\u003e arrSpan = MemoryMarshal.CreateSpan(ref MemoryMarshal.GetArrayDataReference(arr), arr.Length);\r\n        Span\u003cobject\u003e span = MemoryMarshal.CreateSpan(ref MemoryMarshal.GetArrayDataReference(s_arr), s_arr.Length);\r\n        span.CopyTo(arrSpan);\r\n        arrSpan[s_arr.Length] = s_obj;\r\n    }\r\n```\n\n### Reproduction Steps\n\nThe benchmark outcome is:\r\n\r\n|      Method |     Mean |    Error |   StdDev |   Median | Ratio | RatioSD |  Gen 0 | Gen 1 | Gen 2 | Allocated |\r\n|------------ |---------:|---------:|---------:|---------:|------:|--------:|-------:|------:|------:|----------:|\r\n| WithoutSpan | 14.83 ns | 0.344 ns | 0.970 ns | 14.35 ns |  1.00 |    0.00 | 0.0421 |     - |     - |      88 B |\r\n|    WithSpan | 11.40 ns | 0.160 ns | 0.125 ns | 11.37 ns |  0.70 |    0.03 | 0.0421 |     - |     - |      88 B |\n\n### Expected behavior\n\n`Array.Copy` should be roughly the same speed as Span.CopyTo. I think at least `Array.Copy` implementaiton could just internally convert both arrays to spans with `MemoryMarshal.CreateSpan(ref MemoryMarshal.GetArrayDataReference(arr), arr.Length);` and then use Span.CopyTo.\r\n\r\nOr probably there is something else that could be optimized in Array.Copy.\n\n### Actual behavior\n\n-\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOaM_vIw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5jQhKv",
                                           "createdAt":  "2023-08-04T08:58:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-linq\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nUsing the following benchmark:\r\n\r\n```csharp\r\n    private static readonly object[] s_arr = new object[] { new(), new(), new(), new(), new(), new(), new() };\r\n    private static readonly object s_obj = new();\r\n    [Benchmark(Baseline = true)]\r\n    public void WithoutSpan()\r\n    {\r\n        var arr = new object[s_arr.Length + 1];\r\n        Array.Copy(s_arr, arr, s_arr.Length);\r\n        arr[s_arr.Length] = s_obj;\r\n    }\r\n\r\n    [Benchmark]\r\n    public void WithSpan()\r\n    {\r\n        var arr = new object[s_arr.Length + 1];\r\n        Span\u003cobject\u003e arrSpan = MemoryMarshal.CreateSpan(ref MemoryMarshal.GetArrayDataReference(arr), arr.Length);\r\n        Span\u003cobject\u003e span = MemoryMarshal.CreateSpan(ref MemoryMarshal.GetArrayDataReference(s_arr), s_arr.Length);\r\n        span.CopyTo(arrSpan);\r\n        arrSpan[s_arr.Length] = s_obj;\r\n    }\r\n```\n\n### Reproduction Steps\n\nThe benchmark outcome is:\r\n\r\n|      Method |     Mean |    Error |   StdDev |   Median | Ratio | RatioSD |  Gen 0 | Gen 1 | Gen 2 | Allocated |\r\n|------------ |---------:|---------:|---------:|---------:|------:|--------:|-------:|------:|------:|----------:|\r\n| WithoutSpan | 14.83 ns | 0.344 ns | 0.970 ns | 14.35 ns |  1.00 |    0.00 | 0.0421 |     - |     - |      88 B |\r\n|    WithSpan | 11.40 ns | 0.160 ns | 0.125 ns | 11.37 ns |  0.70 |    0.03 | 0.0421 |     - |     - |      88 B |\n\n### Expected behavior\n\n`Array.Copy` should be roughly the same speed as Span.CopyTo. I think at least `Array.Copy` implementaiton could just internally convert both arrays to spans with `MemoryMarshal.CreateSpan(ref MemoryMarshal.GetArrayDataReference(arr), arr.Length);` and then use Span.CopyTo.\r\n\r\nOr probably there is something else that could be optimized in Array.Copy.\n\n### Actual behavior\n\n-\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eYoussef1313\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Linq`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-08-04T08:58:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5jQjhR",
                                           "createdAt":  "2023-08-04T09:06:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nUsing the following benchmark:\r\n\r\n```csharp\r\n    private static readonly object[] s_arr = new object[] { new(), new(), new(), new(), new(), new(), new() };\r\n    private static readonly object s_obj = new();\r\n    [Benchmark(Baseline = true)]\r\n    public void WithoutSpan()\r\n    {\r\n        var arr = new object[s_arr.Length + 1];\r\n        Array.Copy(s_arr, arr, s_arr.Length);\r\n        arr[s_arr.Length] = s_obj;\r\n    }\r\n\r\n    [Benchmark]\r\n    public void WithSpan()\r\n    {\r\n        var arr = new object[s_arr.Length + 1];\r\n        Span\u003cobject\u003e arrSpan = MemoryMarshal.CreateSpan(ref MemoryMarshal.GetArrayDataReference(arr), arr.Length);\r\n        Span\u003cobject\u003e span = MemoryMarshal.CreateSpan(ref MemoryMarshal.GetArrayDataReference(s_arr), s_arr.Length);\r\n        span.CopyTo(arrSpan);\r\n        arrSpan[s_arr.Length] = s_obj;\r\n    }\r\n```\n\n### Reproduction Steps\n\nThe benchmark outcome is:\r\n\r\n|      Method |     Mean |    Error |   StdDev |   Median | Ratio | RatioSD |  Gen 0 | Gen 1 | Gen 2 | Allocated |\r\n|------------ |---------:|---------:|---------:|---------:|------:|--------:|-------:|------:|------:|----------:|\r\n| WithoutSpan | 14.83 ns | 0.344 ns | 0.970 ns | 14.35 ns |  1.00 |    0.00 | 0.0421 |     - |     - |      88 B |\r\n|    WithSpan | 11.40 ns | 0.160 ns | 0.125 ns | 11.37 ns |  0.70 |    0.03 | 0.0421 |     - |     - |      88 B |\n\n### Expected behavior\n\n`Array.Copy` should be roughly the same speed as Span.CopyTo. I think at least `Array.Copy` implementaiton could just internally convert both arrays to spans with `MemoryMarshal.CreateSpan(ref MemoryMarshal.GetArrayDataReference(arr), arr.Length);` and then use Span.CopyTo.\r\n\r\nOr probably there is something else that could be optimized in Array.Copy.\n\n### Actual behavior\n\n-\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eYoussef1313\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Memory`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-08-04T09:06:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5jQkfB",
                                           "createdAt":  "2023-08-04T09:09:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "One lets you violate type safety, the other doesn\u0027t:\r\n\r\n```csharp\r\nusing System;\r\nusing System.Runtime.InteropServices;\r\n\r\nobject[] s_arr = new object[] { new(), new(), new(), new(), new(), new(), new() };\r\n\r\n{\r\n    object[] arr = new string[s_arr.Length + 1];\r\n    Span\u003cobject\u003e arrSpan = MemoryMarshal.CreateSpan(ref MemoryMarshal.GetArrayDataReference(arr), arr.Length);\r\n    Span\u003cobject\u003e span = MemoryMarshal.CreateSpan(ref MemoryMarshal.GetArrayDataReference(s_arr), s_arr.Length);\r\n    span.CopyTo(arrSpan);\r\n\r\n    // string[] now has an object in it\r\n    Console.WriteLine(arr[0]);\r\n}\r\n\r\n{\r\n    object[] arr = new string[s_arr.Length + 1];\r\n    Array.Copy(s_arr, arr, s_arr.Length);\r\n}\r\n```",
                                           "updatedAt":  "2023-08-04T09:09:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5jQm_v",
                                           "createdAt":  "2023-08-04T09:16:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Youssef1313",
                                           "body":  "@MichalStrehovsky Would it then make sense to have a new overload `Array.Copy\u003cT\u003e(T[] sourceArray, T[] destinationArray, int length)`? In this case, it might be safe to skip type checks since we know the arrays are the same type at compile-time?",
                                           "updatedAt":  "2023-08-04T09:16:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5jQokS",
                                           "createdAt":  "2023-08-04T09:22:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "This is array covariance at play. Notice `object[] arr = new string[s_arr.Length + 1];` - the static type is `object[]` but one cannot store an object in it.",
                                           "updatedAt":  "2023-08-04T09:22:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5jQpiH",
                                           "createdAt":  "2023-08-04T09:25:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Youssef1313",
                                           "body":  "Oh indeed. So I assume there is nothing to optimize here given that Array.Copy should have type-safety right?",
                                           "updatedAt":  "2023-08-04T09:25:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5jRD8Y",
                                           "createdAt":  "2023-08-04T10:51:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODHnl5w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2023-08-04T13:26:22Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2023-08-24T18:28:51Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "p6laris",
                                                                               "createdAt":  "2023-09-24T00:05:38Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "Using `MemoryMarshal.CreateSpan` skips the array safety check when creating writable span. If you use `AsSpan`, I\u0027d expect the results to be closer.",
                                           "updatedAt":  "2023-08-04T10:51:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5jRyGz",
                                           "createdAt":  "2023-08-04T13:26:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Would it then make sense to have a new overload Array.Copy\u003cT\u003e(T[] sourceArray, T[] destinationArray, int length)?\r\n\r\nCheck the discussion in https://github.com/dotnet/runtime/issues/18497.\r\n\r\n\u003e I assume there is nothing to optimize here given that Array.Copy should have type-safety right?\r\n\r\nIn theory, `Array.Copy` can be turned into aggressively inlined method and the \"happy path\" checks can be turned into JIT intrinsics. It would shave a bit of the overhead depending on the shape of the callsite at the cost of introducing measurable code bloat.",
                                           "updatedAt":  "2023-08-04T13:26:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5oxFdq",
                                           "createdAt":  "2023-10-11T13:25:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wstaelens",
                                           "body":  "~~array.copy does a check on size, while copyto just throws.~~\r\n\r\n```\r\n            byte[] a = new byte[48];\r\n            Array.Fill\u003cbyte\u003e(a, 1);\r\n\r\n            byte[] b = new byte[40];\r\n            Array.Fill\u003cbyte\u003e(b, 9);\r\n\r\n            Array.Copy(a, 0, b, 4, 36); // works\r\n\r\n\r\n            ReadOnlySpan\u003cbyte\u003e asp = a.AsSpan();\r\n\r\n            byte[] c = new byte[40];\r\n            Array.Fill\u003cbyte\u003e(c, 8);\r\n            Span\u003cbyte\u003e csp = c.AsSpan(4, 36);\r\n            a.CopyTo(csp); // System.ArgumentException: \u0027Destination is too short. (Parameter \u0027destination\u0027)\u0027\r\n```\r\n~~wish .CopyTo behaved the same as Array.Copy without throwing argumentexception destination is too short\r\n(see: https://github.com/dotnet/runtime/issues/20529 )~~",
                                           "updatedAt":  "2023-10-11T14:15:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5oxPu3",
                                           "createdAt":  "2023-10-11T13:49:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Just slice the input array, e.g. instead of\r\n```C#\r\na.CopyTo(csp);\r\n```\r\ndo:\r\n```C#\r\na.AsSpan(0, 36).CopyTo(csp);\r\n```\r\nto specify which portion of the array you want to copy, just as you specify it with Array.Copy (the second and fifth arguments).",
                                           "updatedAt":  "2023-10-11T13:49:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5oxTs7",
                                           "createdAt":  "2023-10-11T13:57:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wstaelens",
                                           "body":  "@stephentoub I know, only a bit annoying to find these span conversion (array.copy --\u003e copyto) bugs at runtime and having to write it each time like this as I work with (readonly)spans being passed around with different sizes.\r\n\r\n```a.Slice(0, Math.Min(csp.Length, a.Length)).CopyTo(csp);```  \r\n\r\n(a is ReadOnlySpan\u003cbyte\u003e in this case)",
                                           "updatedAt":  "2023-10-11T13:57:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5oxVM5",
                                           "createdAt":  "2023-10-11T14:01:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "If `a` and `csp` were arrays, how is that different than needing to do:\r\n```C#\r\nArray.Copy(a, 0, csp, 0, Math.Min(csp.Length, a.Length));\r\n```\r\n? Regardless of which you\u0027re using, you need to specify from where you want to copy, to where you want to copy, and how much you want to copy.",
                                           "updatedAt":  "2023-10-11T14:01:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5oxbt4",
                                           "createdAt":  "2023-10-11T14:14:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODJXJdA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "stephentoub",
                                                                               "createdAt":  "2023-10-11T15:02:27Z"
                                                                           },
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "danmoseley",
                                                                               "createdAt":  "2023-10-11T20:08:55Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "wstaelens",
                                           "body":  "@stephentoub nvm, I should take a break ☕  🤦‍♂️ \r\n\r\nMislooked at the last index of Array.Copy (sorry have been bitshifting code all day) My fault. 🤦‍♂️ 🤦‍♂️ \r\n\r\n(I thought I was having the same issue as with https://github.com/dotnet/runtime/issues/52188 )",
                                           "updatedAt":  "2023-10-11T14:14:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5oz-8j",
                                           "createdAt":  "2023-10-11T20:09:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "We\u0027ve all been there @wstaelens  😀",
                                           "updatedAt":  "2023-10-11T20:09:14Z"
                                       }
                                   ],
                         "totalCount":  14
                     },
        "title":  "`Array.Copy` is slower than `Span.CopyTo`",
        "labels":  [
                       "area-System.Memory",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/90419",
        "createdAt":  "2023-08-11T18:36:16Z",
        "number":  90419,
        "author":  "dumkin",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-19T16:21:10Z",
        "body":  "### Background and motivation\r\n\r\nI\u0027m using System.IO.Pipelines to read and write to a socket. This works well if I need to read line by line, separating lines with a single byte delimiter **\u0027\\n\u0027 (one byte)**, but for example the implementation of SMTP I have to look for new lines with a delimiter in the form of a **\"\\r\\n\"u8**. Therefore, I would like to use the current API to search for a new string with a delimiter as a substring\r\n\r\nMoreover, from what I understand, it will generally just start working if you copy the old functions and change the type T to ReadOnlySpan\u003cT\u003e, because \".Span.IndexOf(value);\" already has an overload on ReadOnlySpan\u003cT\u003e.\r\n\r\n### API Proposal\r\n\r\nCurrent:\r\n\r\n```csharp\r\npublic static class BuffersExtensions\r\n{\r\n    public static SequencePosition? PositionOf\u003cT\u003e(in this ReadOnlySequence\u003cT\u003e source, T value) where T : IEquatable\u003cT\u003e?\r\n    \r\n    private static SequencePosition? PositionOfMultiSegment\u003cT\u003e(in ReadOnlySequence\u003cT\u003e source, T value) where T : IEquatable\u003cT\u003e?\r\n}\r\n```\r\n\r\nNew API:\r\n\r\n```csharp\r\npublic static class BuffersExtensions\r\n{\r\n    public static SequencePosition? PositionOf\u003cT\u003e(in this ReadOnlySequence\u003cT\u003e source, T value) where T : IEquatable\u003cT\u003e?\r\n    public static SequencePosition? PositionOf\u003cT\u003e(in this ReadOnlySequence\u003cT\u003e source, ReadOnlySpan\u003cT\u003e value) where T : IEquatable\u003cT\u003e?\r\n\r\n    private static SequencePosition? PositionOfMultiSegment\u003cT\u003e(in ReadOnlySequence\u003cT\u003e source, T value) where T : IEquatable\u003cT\u003e?\r\n    private static SequencePosition? PositionOfMultiSegment\u003cT\u003e(in ReadOnlySequence\u003cT\u003e source, ReadOnlySpan\u003cT\u003e value) where T : IEquatable\u003cT\u003e?\r\n}\r\n```\r\n\r\n### API Usage\r\n\r\n```csharp\r\nbool TryReadLine(ref ReadOnlySequence\u003cbyte\u003e buffer, out ReadOnlySequence\u003cbyte\u003e line)\r\n{\r\n    // Look for a EOL in the buffer.\r\n    SequencePosition? position = buffer.PositionOf(\"\\r\\n\"u8);\r\n\r\n    if (position == null)\r\n    {\r\n        line = default;\r\n        return false;\r\n    }\r\n\r\n    // Skip the line + the \\n.\r\n    line = buffer.Slice(0, position.Value);\r\n    buffer = buffer.Slice(buffer.GetPosition(1, position.Value));\r\n    return true;\r\n}\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOY9ml-g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5j2aX6",
                                           "createdAt":  "2023-08-11T18:36:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nI\u0027m using System.IO.Pipelines to read and write to a socket. This works well if I need to read line by line, separating lines with a single byte delimiter **\u0027\\n\u0027 (one byte)**, but for example the implementation of SMTP I have to look for new lines with a delimiter in the form of a **\"\\r\\n\"u8**. Therefore, I would like to use the current API to search for a new string with a delimiter as a substring\r\n\r\nMoreover, from what I understand, it will generally just start working if you copy the old functions and change the type T to ReadOnlySpan\u003cT\u003e, because \".Span.IndexOf(value);\" already has an overload on ReadOnlySpan\u003cT\u003e.\n\n### API Proposal\n\nCurrent:\r\n\r\n```csharp\r\npublic static class BuffersExtensions\r\n{\r\n    public static SequencePosition? PositionOf\u003cT\u003e(in this ReadOnlySequence\u003cT\u003e source, T value) where T : IEquatable\u003cT\u003e?\r\n    \r\n    private static SequencePosition? PositionOfMultiSegment\u003cT\u003e(in ReadOnlySequence\u003cT\u003e source, T value) where T : IEquatable\u003cT\u003e?\r\n}\r\n```\r\n\r\nNew API:\r\n\r\n```csharp\r\npublic static class BuffersExtensions\r\n{\r\n    public static SequencePosition? PositionOf\u003cT\u003e(in this ReadOnlySequence\u003cT\u003e source, T value) where T : IEquatable\u003cT\u003e?\r\n    public static SequencePosition? PositionOf\u003cT\u003e(in this ReadOnlySequence\u003cT\u003e source, ReadOnlySpan\u003cT\u003e value) where T : IEquatable\u003cT\u003e?\r\n\r\n    private static SequencePosition? PositionOfMultiSegment\u003cT\u003e(in ReadOnlySequence\u003cT\u003e source, T value) where T : IEquatable\u003cT\u003e?\r\n    private static SequencePosition? PositionOfMultiSegment\u003cT\u003e(in ReadOnlySequence\u003cT\u003e source, ReadOnlySpan\u003cT\u003e value) where T : IEquatable\u003cT\u003e?\r\n}\r\n```\n\n### API Usage\n\n```csharp\r\nbool TryReadLine(ref ReadOnlySequence\u003cbyte\u003e buffer, out ReadOnlySequence\u003cbyte\u003e line)\r\n{\r\n    // Look for a EOL in the buffer.\r\n    SequencePosition? position = buffer.PositionOf(\"/r/n\"u8);\r\n\r\n    if (position == null)\r\n    {\r\n        line = default;\r\n        return false;\r\n    }\r\n\r\n    // Skip the line + the \\n.\r\n    line = buffer.Slice(0, position.Value);\r\n    buffer = buffer.Slice(buffer.GetPosition(1, position.Value));\r\n    return true;\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003edumkin\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Memory`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-08-11T18:36:23Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "[API Proposal]:  \u0027System.Memory\u0027 Add PositionOf with \u0027ReadOnlySpan\u003cT\u003e value\u0027 argument function",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/90939",
        "createdAt":  "2023-08-22T18:07:30Z",
        "number":  90939,
        "author":  "Darcara",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-11-01T02:30:49Z",
        "body":  "### Description\n\n`ReadOnlyMemory.Slice(start, length)` will throw an `ArgumentOutOfRangeException` with the Parameter \u0027start\u0027, even if the start parameter is actually in the range of the `ReadOnlyMemory` and length is out of bounds.\r\n\r\n`Memory.Slice(start, length)` will throw the same exception without `paramName` set.\r\n\r\n`Span.Slice` and `ReadOnlySpan.Slice` will always throw `ArgumentOutOfRangeException` without `paramName` set\n\n### Reproduction Steps\n\n```csharp\r\n// ArgumentOutOfRangeException: Specified argument was out of the range of valid values. (Parameter \u0027start\u0027)\r\nMemory\u003cByte\u003e.Empty.Slice(4);\r\n// ArgumentOutOfRangeException: Specified argument was out of the range of valid values.\r\nMemory\u003cByte\u003e.Empty.Slice(4, 5);\r\n// ArgumentOutOfRangeException: Specified argument was out of the range of valid values. (Parameter \u0027start\u0027)\r\nReadOnlyMemory\u003cByte\u003e.Empty.Slice(4);\r\n// ArgumentOutOfRangeException: Specified argument was out of the range of valid values. (Parameter \u0027start\u0027)\r\nReadOnlyMemory\u003cByte\u003e.Empty.Slice(4, 5);\r\n// ArgumentOutOfRangeException: Specified argument was out of the range of valid values. (Parameter \u0027start\u0027)\r\nnew ReadOnlyMemory\u003cByte\u003e(new Byte[5]).Slice(4, 5);\r\n\r\n// ArgumentOutOfRangeException: Specified argument was out of the range of valid values.\r\nSpan\u003cByte\u003e.Empty.Slice(4);\r\n// ArgumentOutOfRangeException: Specified argument was out of the range of valid values.\r\nSpan\u003cByte\u003e.Empty.Slice(4, 5);\r\n// ArgumentOutOfRangeException: Specified argument was out of the range of valid values.\r\nReadOnlySpan\u003cByte\u003e.Empty.Slice(4);\r\n// ArgumentOutOfRangeException: Specified argument was out of the range of valid values.\r\nReadOnlySpan\u003cByte\u003e.Empty.Slice(4, 5);\r\n```\n\n### Expected behavior\n\n`Span`, `ReadOnlySpan`, `Memory` and `ReadOnlyMemory` should have the same behavior. I would expect at least `Memory` and `ReadOnlyMemory` to be consistent.\r\n\r\nCase 5: `new ReadOnlyMemory\u003cByte\u003e(new Byte[5]).Slice(4, 5)` should throw an exception without `paramName` set (to be consistent with the others), or preferably complain about `length`, if the others start doing so too.\n\n### Actual behavior\n\nsee reproduction steps\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n```\r\n.NET SDK:\r\n Version:   7.0.400\r\n Commit:    73bf45718d\r\nHost:\r\n  Version:      7.0.10\r\n  Architecture: x64\r\n  Commit:       a6dbb800a4 \r\n```\r\n\r\nPersists at least since SDK: 7.0.202 - Host: 7.0.4\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOkhoDqg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5kpzHJ",
                                           "createdAt":  "2023-08-22T18:07:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\n`ReadOnlyMemory.Slice(start, length)` will throw an `ArgumentOutOfRangeException` with the Parameter \u0027start\u0027, even if the start parameter is actually in the range of the `ReadOnlyMemory` and length is out of bounds.\r\n\r\n`Memory.Slice(start, length)` will throw the same exception without `paramName` set.\r\n\r\n`Span.Slice` and `ReadOnlySpan.Slice` will always throw `ArgumentOutOfRangeException` without `paramName` set\n\n### Reproduction Steps\n\n```csharp\r\n// ArgumentOutOfRangeException: Specified argument was out of the range of valid values. (Parameter \u0027start\u0027)\r\nMemory\u003cByte\u003e.Empty.Slice(4);\r\n// ArgumentOutOfRangeException: Specified argument was out of the range of valid values.\r\nMemory\u003cByte\u003e.Empty.Slice(4, 5);\r\n// ArgumentOutOfRangeException: Specified argument was out of the range of valid values. (Parameter \u0027start\u0027)\r\nReadOnlyMemory\u003cByte\u003e.Empty.Slice(4);\r\n// ArgumentOutOfRangeException: Specified argument was out of the range of valid values. (Parameter \u0027start\u0027)\r\nReadOnlyMemory\u003cByte\u003e.Empty.Slice(4, 5);\r\n// ArgumentOutOfRangeException: Specified argument was out of the range of valid values. (Parameter \u0027start\u0027)\r\nnew ReadOnlyMemory\u003cByte\u003e(new Byte[5]).Slice(4, 5);\r\n\r\n// ArgumentOutOfRangeException: Specified argument was out of the range of valid values.\r\nSpan\u003cByte\u003e.Empty.Slice(4);\r\n// ArgumentOutOfRangeException: Specified argument was out of the range of valid values.\r\nSpan\u003cByte\u003e.Empty.Slice(4, 5);\r\n// ArgumentOutOfRangeException: Specified argument was out of the range of valid values.\r\nReadOnlySpan\u003cByte\u003e.Empty.Slice(4);\r\n// ArgumentOutOfRangeException: Specified argument was out of the range of valid values.\r\nReadOnlySpan\u003cByte\u003e.Empty.Slice(4, 5);\r\n```\n\n### Expected behavior\n\n`Span`, `ReadOnlySpan`, `Memory` and `ReadOnlyMemory` should have the same behavior. I would expect at least `Memory` and `ReadOnlyMemory` to be consistent.\r\n\r\nCase 5: `new ReadOnlyMemory\u003cByte\u003e(new Byte[5]).Slice(4, 5)` should throw an exception without `paramName` set (to be consistent with the others), or preferably complain about `length`, if the others start doing so too.\n\n### Actual behavior\n\nsee reproduction steps\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n```\r\n.NET SDK:\r\n Version:   7.0.400\r\n Commit:    73bf45718d\r\nHost:\r\n  Version:      7.0.10\r\n  Architecture: x64\r\n  Commit:       a6dbb800a4 \r\n```\r\n\r\nPersists at least since SDK: 7.0.202 - Host: 7.0.4\n\n### Other information\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eDarcara\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Memory`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-08-22T18:07:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6SGgOq",
                                           "createdAt":  "2024-11-01T02:30:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "YoshiRulz",
                                           "body":  "See also #53622.",
                                           "updatedAt":  "2024-11-01T02:30:48Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Inconsistent Exceptions for ReadOnlyMemory.Slice",
        "labels":  [
                       "area-System.Memory",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/91426",
        "createdAt":  "2023-08-31T21:49:06Z",
        "number":  91426,
        "author":  "Neme12",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC4nUiw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "alexrp",
                                            "createdAt":  "2023-08-31T21:56:50Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2023-09-10T22:34:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MineCake147E",
                                            "createdAt":  "2024-03-06T03:03:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "tats-u",
                                            "createdAt":  "2024-04-21T11:11:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Dubzer",
                                            "createdAt":  "2024-06-13T19:28:44Z"
                                        }
                                    ],
                          "totalCount":  5
                      },
        "updatedAt":  "2024-07-22T16:59:03Z",
        "body":  "Currently, `ReadOnlySpan\u003cchar\u003e.ToString` has a special-cased implementation that simply returns the string. It would be nice if this worked for spans of `Rune` as well.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOZg_Q9A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5lcbXw",
                                           "createdAt":  "2023-09-01T00:35:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nCurrently, `ReadOnlySpan\u003cchar\u003e.ToString` has a special-cased implementation that simply returns the string. It would be nice if this worked for spans of `Rune` as well.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eNeme12\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Memory`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-09-01T00:35:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5mDPWh",
                                           "createdAt":  "2023-09-08T19:23:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODZer2w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "Neme12",
                                                                               "createdAt":  "2023-09-08T19:25:14Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2023-09-10T22:34:52Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "p6laris",
                                                                               "createdAt":  "2023-09-23T23:59:24Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "MineCake147E",
                                                                               "createdAt":  "2024-03-06T03:03:27Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "I mentioned this in Discord chat the other day, but it would be neat if we had a feature like this:\r\n\r\n```cs\r\npublic interface ISpanStringable\u003cT\u003e {\r\n    static string ToString(ReadOnlySpan\u003cT\u003e buffer);\r\n}\r\n\r\npublic readonly struct char : ISpanStringable\u003cchar\u003e { /* ... */ }\r\npublic readonly struct Rune : ISpanStringable\u003cRune\u003e { /* ... */ }\r\n\r\npublic ref struct Span\u003cT\u003e {\r\n    public override string ToString() {\r\n        if (T is ISpanStringable\u003cT\u003e) { return T.ToString(this); }\r\n        else { /* fallback logic */ }\r\n    }\r\n}\r\n```\r\n\r\nThen we could even get rid of Span\u0027s existing char specialization within ToString, and _any_ type can add its own specialization of this.",
                                           "updatedAt":  "2023-09-08T19:23:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5mDPwL",
                                           "createdAt":  "2023-09-08T19:25:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "That said, I do question the value of this particular specialization, since I expect it to be exceedingly rare to have a contiguous collection of `Rune` instances. I\u0027m struggling to think of a use case for this.",
                                           "updatedAt":  "2023-09-08T19:25:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5mDPw3",
                                           "createdAt":  "2023-09-08T19:25:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "I love that idea.",
                                           "updatedAt":  "2023-09-08T19:25:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5mDP-O",
                                           "createdAt":  "2023-09-08T19:26:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "In my case, I\u0027m representing a `Grapheme` as a sequence of `Rune`s and therefore work with `ReadOnlySpan\u003cRune\u003e` regularly.",
                                           "updatedAt":  "2023-09-08T19:26:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5mDQXS",
                                           "createdAt":  "2023-09-08T19:28:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "\u003e I love that idea.\r\n\r\nIf only it could also work for UTF-8 though. 😔 It\u0027s such a shame that Utf8Char was never added and we have to forever live with such a bad debugging experience. 😔",
                                           "updatedAt":  "2023-09-08T19:31:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5mDaSu",
                                           "createdAt":  "2023-09-08T20:09:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "neon-sunset",
                                           "body":  "(first and foremost, apologies for the plug, really, but it\u0027s relevant work)\r\n\u003e If only it could also work for UTF-8 though.\r\n\r\nhttps://github.com/U8String/U8String/blob/main/src/U8Enumerators.cs#L203 +\r\nhttps://github.com/U8String/U8String/blob/main/src/Shared/U8Conversions.cs\r\n\r\nGenerally speaking, any improvements to the current state of .NET APIs for working with text are very welcome.\r\nIn this particular case, I think the better option would be introducing Unicode scalars to UTF-16 conversion on something like\r\n```cs\r\nnamespace System.Text.Unicode;\r\n\r\npublic static partial class Utf16\r\n{\r\n    OperationStatus FromUnicode(ReadOnlySpan\u003cbyte\u003e source, Span\u003cchar\u003e destination, out int bytesRead, out int charsWritten);\r\n\r\n    OperationStatus FromUnicode(ReadOnlySpan\u003cRune\u003e source, Span\u003cchar\u003e destination, out int runesRead, out int charsWritten);\r\n}\r\n```\r\nand then subsequent methods which augment this for a more convenient usage. Unlike `ROS\u003cchar\u003e` -\u003e `string` conversions, decoding `Rune`s to `string`s is not a common operation so special-casing `ROS\u003cRune\u003e.ToString()` seems rather counterintuitive.\r\n\r\nWhile such API are being discussed, you can already convert `Span\u003cRune\u003e` to `string` with the following snippet instead: \r\n```csharp\r\nvar text = \"hello world\";\r\nvar runes = text.EnumerateRunes().ToArray();\r\nvar decoded = Encoding.UTF32.GetString(MemoryMarshal.Cast\u003cRune, byte\u003e(runes));\r\n\r\nAssert.Equal(text, decoded);\r\n```",
                                           "updatedAt":  "2023-09-08T20:12:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5mDbKP",
                                           "createdAt":  "2023-09-08T20:13:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "@neon-sunset Sorry, I don\u0027t understand how what you\u0027re saying is related to this proposal.\r\n\r\n\u003e While such API are being discussed, you can already convert Span\u003cRune\u003e to string with the following snippet instead:\r\n\r\nI know I can manually convert it to string, but it helps with debugging to be able to see it immediately, just like it\u0027s really useful with `ReadOnlySpan\u003cchar\u003e`.",
                                           "updatedAt":  "2023-09-08T20:14:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5mDbgK",
                                           "createdAt":  "2023-09-08T20:15:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "\u003e I mentioned this in Discord chat the other day, but it would be neat if we had a feature like this:\r\n\r\nIt\u0027s almost tempting to call that interface `ISpanFormattable` 😄",
                                           "updatedAt":  "2023-09-08T20:15:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5mDe30",
                                           "createdAt":  "2023-09-08T20:30:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODGMeGw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Neme12",
                                                                               "createdAt":  "2023-09-08T20:31:10Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "```cs\r\nvar decoded = Encoding.UTF32.GetString(MemoryMarshal.Cast\u003cRune, byte\u003e(runes));\r\n```\r\n\r\nThis will result in undefined behavior. The bit pattern which backs a `Rune` instance is not guaranteed to be a little-endian UTF-32 code point.",
                                           "updatedAt":  "2023-09-08T20:30:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5mDgcR",
                                           "createdAt":  "2023-09-08T20:37:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "I just do a quick `string.Concat(runes.ToArray())` when debugging. There are more efficient ways of course. Although it would be nice if there was an easier way to do this efficiently.",
                                           "updatedAt":  "2023-09-08T21:01:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5mDrVn",
                                           "createdAt":  "2023-09-08T21:24:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "neon-sunset",
                                           "body":  "\u003e This will result in undefined behavior. The bit pattern which backs a Rune instance is not guaranteed to be a little-endian UTF-32 code point.\r\n\r\nYes, I realize that this is pretty much a workaround, but the probability that such code will run on s390x is exceedingly small. For library code, it will get guarded behind a check for endianness.",
                                           "updatedAt":  "2023-09-08T21:27:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5mDsV-",
                                           "createdAt":  "2023-09-08T21:29:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "alexrp",
                                           "body":  "\u003e Yes, but the probability that such code will run on s390x is exceedingly small. For library code, it will get guarded behind a check for endianness.\r\n\r\nThe point is that `Rune` currently happening to have a `uint` field that happens to represent a UTF-32 code point is an implementation detail that is allowed to change.",
                                           "updatedAt":  "2023-09-08T21:29:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5mDsW1",
                                           "createdAt":  "2023-09-08T21:29:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODGMwxg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Neme12",
                                                                               "createdAt":  "2023-09-08T21:30:34Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "\u003e Yes, I realize that this is pretty much a workaround, but the probability that such code will run on s390x is exceedingly small. For library code, it will get guarded behind a check for endianness.\r\n\r\nYou\u0027re assuming that `Rune` will always consist of only one int-sized backing field, and that the backing field will always be a machine-endian representation of the scalar value with no reserved bits or other twiddling. This is not guaranteed behavior. By relying on this, you\u0027re relying on an unsupported implementation detail.",
                                           "updatedAt":  "2023-09-08T21:29:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5mDtaJ",
                                           "createdAt":  "2023-09-08T21:34:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "neon-sunset",
                                           "body":  "\u003e You\u0027re assuming that Rune will always consist of only one int-sized backing field, and that the backing field will always be a machine-endian representation of the scalar value with no reserved bits or other twiddling. This is not guaranteed behavior. By relying on this, you\u0027re relying on an unsupported implementation detail.\r\n\r\nMy comments did not imply this is a *good* solution, just a one that works for now. If it sounds otherwise, I apologize. If `Rune` and other APIs for working with Unicode change and improve, I\u0027m all for it :)",
                                           "updatedAt":  "2023-09-08T21:34:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5mDukc",
                                           "createdAt":  "2023-09-08T21:38:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "\u003e You\u0027re assuming that Rune will always consist of only one int-sized backing field, and that the backing field will always be a machine-endian representation of the scalar value with no reserved bits or other twiddling.\r\n\r\nCouldn\u0027t it be changed though to guarantee this? That would be useful for people doing interop with UTF-32 as they could always use `ReadOnlySpan\u003cRune\u003e`. After all, we do have such blittability guarantees for `char`, so why not for `Rune`.",
                                           "updatedAt":  "2023-09-08T21:38:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5mD9D0",
                                           "createdAt":  "2023-09-08T22:54:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "\u003e Couldn\u0027t it be changed though to guarantee this? That would be useful for people doing interop with UTF-32 as they could always use `ReadOnlySpan\u003cRune\u003e`.\r\n\r\nWe can always make whatever guarantees we want. :) But this would stop us from making other optimizations, such as squirreling away the UTF-8 length in the top 2 bits of the struct value (that would certainly simplify getting the UTF-8 byte count!), having supplementary-plane runes represented behind the scenes as `(first_char \u003c\u003c 16) | last_char`, which would make `ToString` much faster, etc.\r\n\r\n\u003e After all, we do have such blittability guarantees for `char`, so why not for `Rune`.\r\n\r\n`char` is a fundamental data type and interop was built in to its original design. That\u0027s not the case for arbitrary structs like `Rune`.",
                                           "updatedAt":  "2023-09-08T22:54:24Z"
                                       }
                                   ],
                         "totalCount":  17
                     },
        "title":  "Provide an implementation of `ReadOnlySpan\u003cRune\u003e.ToString`",
        "labels":  [
                       "area-System.Memory",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/91514",
        "createdAt":  "2023-09-03T00:45:17Z",
        "number":  91514,
        "author":  "Neme12",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODDsVFQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Charlieface",
                                            "createdAt":  "2025-06-12T00:02:22Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-07-19T16:21:14Z",
        "body":  "### Background and motivation\r\n\r\n`MemoryExtensions` has really useful `SequenceEqual` and `SequenceCompareTo` methods. For `IEnumerable`, there is a `SequenceEqual` method as well, but sadly no `SequenceCompareTo`. So this is what I\u0027m proposing.\r\n\r\n\u003cs\u003eAlso, I noticed that the `SequenceCompareTo` methods on `MemoryExtensions` have no overloads that take a comparer, while the `SequenceEqual` methods do. I\u0027m adding this to the proposal as well just because this feels like an omission.\u003c/s\u003e EDIT: There is an existing issue for this: #84838\r\n\r\n### API Proposal\r\n\r\n```diff\r\n namespace System;\r\n \r\n public static partial class MemoryExtensions\r\n {\r\n     public static bool SequenceEqual\u003cT\u003e(this ReadOnlySpan\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other) where T : IEquatable\u003cT\u003e?;\r\n     public static bool SequenceEqual\u003cT\u003e(this Span\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other) where T : IEquatable\u003cT\u003e?;\r\n     public static bool SequenceEqual\u003cT\u003e(this ReadOnlySpan\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other, IEqualityComparer\u003cT\u003e? comparer = null);\r\n     public static bool SequenceEqual\u003cT\u003e(this Span\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other, IEqualityComparer\u003cT\u003e? comparer = null);\r\n     public static int SequenceCompareTo\u003cT\u003e(this ReadOnlySpan\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other) where T : IComparable\u003cT\u003e?;\r\n     public static int SequenceCompareTo\u003cT\u003e(this Span\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other) where T : IComparable\u003cT\u003e?;\r\n }\r\n \r\n namespace System.Linq;\r\n \r\n public static partial class Enumerable\r\n {\r\n     public static bool SequenceEqual\u003cTSource\u003e(this IEnumerable\u003cTSource\u003e first, IEnumerable\u003cTSource\u003e second);\r\n     public static bool SequenceEqual\u003cTSource\u003e(this IEnumerable\u003cTSource\u003e first, IEnumerable\u003cTSource\u003e second, IEqualityComparer\u003cTSource\u003e? comparer);\r\n+    public static int SequenceCompareTo\u003cTSource\u003e(this IEnumerable\u003cTSource\u003e first, IEnumerable\u003cTSource\u003e second);\r\n+    public static int SequenceCompareTo\u003cTSource\u003e(this IEnumerable\u003cTSource\u003e first, IEnumerable\u003cTSource\u003e second, IComparer\u003cTSource\u003e? comparer);\r\n }\r\n```\r\n\r\n### API Usage\r\n\r\n```csharp\r\npublic int CompareTo(Grapheme other) =\u003e\r\n    _runes.SequenceCompareTo(other._runes);\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOZZCe8g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5lkJfQ",
                                           "createdAt":  "2023-09-03T00:45:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\n`MemoryExtensions` has really useful `SequenceEqual` and `SequenceCompareTo` methods. For `IEnumerable`, there is a `SequenceEqual` method as well, but sadly no `SequenceCompareTo`. So this is what I\u0027m proposing.\r\n\r\nAlso, I noticed that the `SequenceCompareTo` methods on `MemoryExtensions` have no overloads that take a comparer, while the `SequenceEqual` methods do. I\u0027m adding this to the proposal as well just because this feels like an omission.\n\n### API Proposal\n\n```diff\r\n namespace System;\r\n \r\n public static partial class MemoryExtensions\r\n {\r\n     public static bool SequenceEqual\u003cT\u003e(this ReadOnlySpan\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other) where T : IEquatable\u003cT\u003e?;\r\n     public static bool SequenceEqual\u003cT\u003e(this Span\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other) where T : IEquatable\u003cT\u003e?;\r\n     public static bool SequenceEqual\u003cT\u003e(this ReadOnlySpan\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other, IEqualityComparer\u003cT\u003e? comparer = null);\r\n     public static bool SequenceEqual\u003cT\u003e(this Span\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other, IEqualityComparer\u003cT\u003e? comparer = null);\r\n     public static int SequenceCompareTo\u003cT\u003e(this ReadOnlySpan\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other) where T : IComparable\u003cT\u003e?;\r\n     public static int SequenceCompareTo\u003cT\u003e(this Span\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other) where T : IComparable\u003cT\u003e?;\r\n+    public static int SequenceCompareTo\u003cT\u003e(this ReadOnlySpan\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other, IComparer\u003cT\u003e? comparer = null);\r\n+    public static int SequenceCompareTo\u003cT\u003e(this Span\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other, IComparer\u003cT\u003e? comparer = null);\r\n \r\n }\r\n \r\n namespace System.Linq;\r\n \r\n public static partial class Enumerable\r\n {\r\n     public static bool SequenceEqual\u003cTSource\u003e(this IEnumerable\u003cTSource\u003e first, IEnumerable\u003cTSource\u003e second);\r\n     public static bool SequenceEqual\u003cTSource\u003e(this IEnumerable\u003cTSource\u003e first, IEnumerable\u003cTSource\u003e second, IEqualityComparer\u003cTSource\u003e? comparer);\r\n+    public static int SequenceCompareTo\u003cTSource\u003e(this IEnumerable\u003cTSource\u003e first, IEnumerable\u003cTSource\u003e second);\r\n+    public static int SequenceCompareTo\u003cTSource\u003e(this IEnumerable\u003cTSource\u003e first, IEnumerable\u003cTSource\u003e second, IComparer\u003cTSource\u003e? comparer);\r\n }\r\n```\n\n### API Usage\n\n```csharp\r\npublic int CompareTo(Grapheme other) =\u003e\r\n    _runes.SequenceCompareTo(other._runes);\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eNeme12\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Memory`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-09-03T00:45:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5lkJ7y",
                                           "createdAt":  "2023-09-03T00:59:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "Oh, there is an existing issue for the second part already: #84838. I\u0027m removing that from this proposal.",
                                           "updatedAt":  "2023-09-03T01:01:46Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[API Proposal]: Add `SequenceCompareTo` methods to `Enumerable`",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/91515",
        "createdAt":  "2023-09-03T00:53:27Z",
        "number":  91515,
        "author":  "Neme12",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-19T16:21:15Z",
        "body":  "### Background and motivation\r\n\r\n`MemoryExtensions` has really useful `SequenceEqual` and `SequenceCompareTo` methods for checking equality based on the contents rather than reference equality. So does `Enumerable`. It would be really useful to have a corresponding `GetSequenceHashCode` method as well that combines the hash codes of the individual items.\r\n\r\n### API Proposal\r\n\r\n```diff\r\n namespace System;\r\n\r\n public static partial class MemoryExtensions\r\n {\r\n     public static bool SequenceEqual\u003cT\u003e(this ReadOnlySpan\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other) where T : IEquatable\u003cT\u003e?;\r\n     public static bool SequenceEqual\u003cT\u003e(this Span\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other) where T : IEquatable\u003cT\u003e?;\r\n     public static bool SequenceEqual\u003cT\u003e(this ReadOnlySpan\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other, IEqualityComparer\u003cT\u003e? comparer = null);\r\n     public static bool SequenceEqual\u003cT\u003e(this Span\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other, IEqualityComparer\u003cT\u003e? comparer = null);\r\n+    public static int GetSequenceHashCode\u003cT\u003e(this ReadOnlySpan\u003cT\u003e span, IEqualityComparer\u003cT\u003e? comparer = null);\r\n+    public static int GetSequenceHashCode\u003cT\u003e(this Span\u003cT\u003e span, IEqualityComparer\u003cT\u003e? comparer = null);\r\n }\r\n \r\n namespace System.Linq;\r\n\r\n public static partial class Enumerable\r\n {\r\n     public static bool SequenceEqual\u003cTSource\u003e(this IEnumerable\u003cTSource\u003e first, IEnumerable\u003cTSource\u003e second);\r\n     public static bool SequenceEqual\u003cTSource\u003e(this IEnumerable\u003cTSource\u003e first, IEnumerable\u003cTSource\u003e second, IEqualityComparer\u003cTSource\u003e? comparer);\r\n+    public static int GetSequenceHashCode\u003cTSource\u003e(this IEnumerable\u003cTSource\u003e source);\r\n+    public static int GetSequenceHashCode\u003cTSource\u003e(this IEnumerable\u003cTSource\u003e source, IEqualityComparer\u003cTSource\u003e? comparer);\r\n }\r\n\r\n```\r\n\r\n### API Usage\r\n\r\n```csharp\r\npublic bool Equals(Grapheme other) =\u003e\r\n    _runes.SequenceEqual(other._runes);\r\n\r\npublic int CompareTo(Grapheme other) =\u003e\r\n    _runes.SequenceCompareTo(other._runes);\r\n\r\npublic override int GetHashCode() =\u003e\r\n    _runes.GetSequenceHashCode();\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOZZZKfA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5lkJwP",
                                           "createdAt":  "2023-09-03T00:53:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\n`MemoryExtensions` has really useful `SequenceEqual` and `SequenceCompareTo` methods for checking equality based on the contents rather than reference equality. So does `Enumerable`. It would be useful to have a corresponding `GetSequenceHashCode` method as well.\n\n### API Proposal\n\n```diff\r\n namespace System;\r\n\r\n public static partial class MemoryExtensions\r\n {\r\n     public static bool SequenceEqual\u003cT\u003e(this ReadOnlySpan\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other) where T : IEquatable\u003cT\u003e?;\r\n     public static bool SequenceEqual\u003cT\u003e(this Span\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other) where T : IEquatable\u003cT\u003e?;\r\n     public static bool SequenceEqual\u003cT\u003e(this ReadOnlySpan\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other, IEqualityComparer\u003cT\u003e? comparer = null);\r\n     public static bool SequenceEqual\u003cT\u003e(this Span\u003cT\u003e span, ReadOnlySpan\u003cT\u003e other, IEqualityComparer\u003cT\u003e? comparer = null);\r\n+    public static int GetSequenceHashCode\u003cT\u003e(this ReadOnlySpan\u003cT\u003e span, IEqualityComparer\u003cT\u003e? comparer = null);\r\n+    public static int GetSequenceHashCode\u003cT\u003e(this Span\u003cT\u003e span, IEqualityComparer\u003cT\u003e? comparer = null);\r\n }\r\n \r\n namespace System.Linq;\r\n\r\n public static partial class Enumerable\r\n {\r\n     public static bool SequenceEqual\u003cTSource\u003e(this IEnumerable\u003cTSource\u003e first, IEnumerable\u003cTSource\u003e second);\r\n     public static bool SequenceEqual\u003cTSource\u003e(this IEnumerable\u003cTSource\u003e first, IEnumerable\u003cTSource\u003e second, IEqualityComparer\u003cTSource\u003e? comparer);\r\n+    public static int GetSequenceHashCode\u003cTSource\u003e(this IEnumerable\u003cTSource\u003e first, IEnumerable\u003cTSource\u003e second);\r\n+    public static int GetSequenceHashCode\u003cTSource\u003e(this IEnumerable\u003cTSource\u003e first, IEnumerable\u003cTSource\u003e second, IEqualityComparer\u003cTSource\u003e? comparer);\r\n }\r\n\r\n```\n\n### API Usage\n\n```csharp\r\npublic bool Equals(Grapheme other) =\u003e\r\n    _runes.SequenceEqual(other._runes);\r\n\r\npublic int CompareTo(Grapheme other) =\u003e\r\n    _runes.SequenceCompareTo(other._runes);\r\n\r\npublic override int GetHashCode() =\u003e\r\n    _runes.GetSequenceHashCode();\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eNeme12\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Memory`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-09-03T00:53:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5lle9G",
                                           "createdAt":  "2023-09-03T14:46:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "I would make them methods of `HashCode`.",
                                           "updatedAt":  "2023-09-03T14:46:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5llfCH",
                                           "createdAt":  "2023-09-03T14:48:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ovska",
                                           "body":  "FWIW there\u0027s an implementation of this for Spans the quasi-official [CommunityToolkit.HighPerformance](https://www.nuget.org/packages/CommunityToolkit.HighPerformance) package.\r\n\r\nhttps://github.com/CommunityToolkit/dotnet/blob/main/src/CommunityToolkit.HighPerformance/Helpers/HashCode%7BT%7D.cs",
                                           "updatedAt":  "2023-09-03T14:48:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5llhLd",
                                           "createdAt":  "2023-09-03T15:27:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "I think they fit in nicely next to the existing `SequenceEqual` methods, as both are often used in conjunction with each other. And the methods should also take an optional `IEqualityComparer\u003cT\u003e`, like the existing `SequenceEqual` methods do, which also makes me think it fits better in with `Enumerable`, since `IEqualityComparer\u003cT\u003e` is a collection thing and exists in `System.Collections.Generic`.",
                                           "updatedAt":  "2023-09-03T15:27:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5llkD5",
                                           "createdAt":  "2023-09-03T16:20:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "reflectronic",
                                           "body":  "I don\u0027t know how useful it is to have a standalone GetHashCode method. Unlike equality or comparisons, the hash code is rarely used outside the implementation of a hash-based collection like Dictionary or HashSet. And, nearly all of these collections use an abstraction like IEqualityComparer rather than coding against a specific implementation like this one. \r\n\r\nhttps://github.com/dotnet/runtime/issues/77209 proposed an IEqualityComparer implementation that does structural equality for collections. It presents the same functionality in a way that\u0027s more useful out-of-the-box. Sadly the proposal was canned but I think it\u0027d be best for this proposal to follow along the same vein.",
                                           "updatedAt":  "2023-09-03T16:20:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5llkp8",
                                           "createdAt":  "2023-09-03T16:34:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "@reflectronic It\u0027s not rare at all. Any time you override equality on a struct or a class (which is pretty common), you should also be overriding GetHashCode. That doesn\u0027t mean you\u0027ll actually use it, but you should still override it. That\u0027s where I needed this API if you look at the usage example.",
                                           "updatedAt":  "2023-09-03T16:35:28Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "[API Proposal]: Add `MemoryExtensions.GetSequenceHashCode`",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/91743",
        "createdAt":  "2023-09-07T16:15:35Z",
        "number":  91743,
        "author":  "MihaZupan",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODA706Q==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "istipeti",
                                            "createdAt":  "2025-04-07T15:33:12Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-01-23T15:22:58Z",
        "body":  "https://github.com/dotnet/roslyn-analyzers/pull/6898 is adding an analyzer that will flag uses like\r\n```c#\r\nconst string MyValues = \"abcdef\";\r\n\r\nspan.IndexOfAny(MyValues);\r\n```\r\nand offer a fixer to replace it with\r\n```c#\r\nprivate static readonly SearchValues\u003cchar\u003e s_myValues = SearchValues.Create(MyValues);\r\nconst string MyValues = \"abcdef\";\r\n\r\nspan.IndexOfAny(s_myValues);\r\n```\r\n\r\nFor patterns like these, we should consider using interceptors to automagically rewrite them to use `SearchValues`, without requiring the user to extract the values to a field.\r\nThe logic could also be smarter and rewrite the above example to use `IndexOfAnyInRange` directly instead.\r\n\r\nThis would also help projects that multi-target to TFMs that don\u0027t have `SearchValues`, as it would let them take advantage of the perf improvements without extra `#if` `#else`s.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOm5MA3A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5l8y2A",
                                           "createdAt":  "2023-09-07T16:15:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nhttps://github.com/dotnet/roslyn-analyzers/pull/6898 is adding an analyzer that will flag uses like\r\n```c#\r\nconst string MyValues = \"abcdef\";\r\n\r\nspan.IndexOfAny(MyValues);\r\n```\r\nand offer a fixer to replace it with\r\n```c#\r\nprivate static readonly SearchValues\u003cchar\u003e s_myValues = SearchValues.Create(MyValues);\r\nconst string MyValues = \"abcdef\";\r\n\r\nspan.IndexOfAny(s_myValues);\r\n```\r\n\r\nFor patterns like these, we should consider using interceptors to automagically rewrite them to use `SearchValues`, without requiring the user to extract the values to a field.\r\n\r\nThis would also help project that multi-target to TFMs that don\u0027t have `SearchValues`, as it would let them take advantage of the perf improvements without extra `#if` `#else`s.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eMihaZupan\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Memory`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-09-07T16:15:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5mtSvl",
                                           "createdAt":  "2023-09-18T10:35:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "It sounds reasonable, but does it have any downsides? Like longer startup (initialization of a static field) etc? If so, how could we tell whether it should be applied to all possible places or only selected ones?",
                                           "updatedAt":  "2023-09-18T10:35:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5m4EDO",
                                           "createdAt":  "2023-09-19T16:06:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "Yes, it could affect startup somewhat. Creating the `SearchValues` themselves is pretty cheap (order of 100s of ns), so my guess is that any runtime costs of having extra fields / cctors could show up.\r\nI wouldn\u0027t expect users to have too many such instances in their apps though.",
                                           "updatedAt":  "2023-09-19T16:06:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6bkwDc",
                                           "createdAt":  "2025-01-23T15:22:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "Probably a more interesting use case for this now would also be replacing `IndexOf(\"literal\")`/`Contains(\"literal\")`, where using SV is an incremental improvement, but one that usually isn\u0027t worth making code less readable for.",
                                           "updatedAt":  "2025-01-23T15:22:57Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Consider using interceptors for IndexOfAny-like calls",
        "labels":  [
                       "area-System.Memory",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/93841",
        "createdAt":  "2023-10-23T04:32:34Z",
        "number":  93841,
        "author":  "Tacodiva",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-19T16:15:09Z",
        "body":  "### Background and motivation\r\n\r\nCurrently, the API provides `Memory\u003cT\u003e`, a reference to some memory on the heap. This memory could be anything, like a slice of a managed array, a region of unmanaged memory, or some other arbitrary memory scheme. When pinned, the low-level handle to this arbitrary memory is a `MemoryHandle`. It can hold onto a reference to arbitrary memory by storing two things, a `GCHandle` and an `IPinnable`. The `GCHandle` is used for situations where the memory referenced is a part of a managed object (like a section of an array), while the `IPinnable` is used for situations where the referenced memory is managed by an external mechanism (like a `MemoryManager\u003cT\u003e`). If no memory management is required for the reference, than neither of them have to be used (for example, a constant region of memory which is never deallocated wouldn\u0027t need either). \r\n\r\nStructs like `Memory\u003cT\u003e` are useful because they provide a high-level view onto something low-level. API authors get the power to deal with the nitty-gritty memory when they need to, while all the end user sees is the pretty structs. Currently however, `MemoryHandle` is pretty much completely opaque, making it unnecessarily difficult to reason about its contents on a low level.\r\n\r\nThe example that compelled me to make this suggestion is one where I want to store a `Memory\u003cT\u003e` in unmanaged memory. It is currently possible to to this by creating a `GCHandle` to the `MemoryHandle`, then storing that in unmanaged memory (along with the actual fixed pointer), disposing both the `MemoryHandle` and the `GCHandle` pointing to the memory handle when finished. However, in the most common usecase of my API, the `MemoryHandle` is a reference to a part of a managed array, meaning it itself is essentially just a pointer and a `GCHandle` which I could just store directly, but can\u0027t because the handle is not exposed. Instead, I am forced into unnecessarily boxing the `MemoryHandle` so I can get a `GCHandle` to it in a very hot code path.\r\n\r\n### API Proposal\r\n\r\n```diff\r\nnamespace System.Buffers;\r\n\r\npublic unsafe struct MemoryHandle // ...\r\n{\r\n    // ...\r\n    \r\n+    public GCHandle Handle { get; }\r\n\r\n+    public IPinnable? Pinnable { get; }\r\n\r\n    // ...\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\npublic unsafe void MyAPI(Memory\u003cbyte\u003e buffer)\r\n{\r\n    MemoryHandle bufferHandle = buffer.Pin();\r\n\r\n    // Will will now turn our buffer handle into a GCHandle\r\n\r\n    GCHandle handle;\r\n    \r\n    bool hasHandle = bufferHandle.Handle.IsAllocated;\r\n    bool hasPinnable = bufferHandle.Pinnable != null;\r\n\r\n    if (hasHandle \u0026\u0026 !hasPinnable)\r\n    {\r\n        // Only a GCHandle means we can just store the GCHandle\r\n        handle = bufferHandle.Handle;\r\n    } \r\n    else if (hasPinnable \u0026\u0026 !hasHandle)\r\n    {\r\n        // Only an IPinnable means we can store a GCHandle to the pinnable.\r\n        handle = GCHandle.Alloc(bufferHandle.Pinnable);\r\n    }\r\n    else if (hasPinnable \u0026\u0026 hasHandle)\r\n    {\r\n        // If we have both, we can store a GCHandle to the boxed MemoryHandle\r\n        // Note that I don\u0027t think this will even happen under normal circumstances but it could happen if \r\n        //  a custom `MemoryManager\u003cT\u003e` is created which returns a MemoryHandle with both.\r\n        handle = GCHandle.Alloc(bufferHandle);\r\n    }\r\n    else\r\n    {\r\n        // If we have neither, we don\u0027t need to store any handles\r\n        handle = default;\r\n    }\r\n\r\n    StoreUnmanaged(bufferHandle.Pointer, handle);\r\n}\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nFor my use case, it is possible to write a new struct which represents a `MemoryHandle` but is able to be stored in unmanaged memory (that\u0027s probably what I would end up doing anyway), but I don\u0027t know that this use is common enough to warrant that, and there are different implementation approaches that one might take depending on the usecase. It is my opinion that with these low-level APIs, there\u0027s very little reason to hide things that could be used to improve performance, which is exactly what `MemoryHandle` is doing.\r\n\r\n### Risks\r\n\r\n(Not sure if this is a \u0027risk\u0027 but...) I did notice that the design I\u0027ve suggested introduces what is a bit of an anti-pattern regarding `MemoryHandle.Dispose`. If you are pulling the `GCHandle` and `IPinnable` out of the `MemoryHandle`, you shouldn\u0027t dispose it because that will free the handle / unpin the reference. I\u0027m not sure how big of a problem that is, but thought I\u0027d include it here.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOacuHUA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5pw5j2",
                                           "createdAt":  "2023-10-23T04:41:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nCurrently, the API provides `Memory\u003cT\u003e`, a reference to some memory on the heap. This memory could be anything, like a slice of a managed array, a region of unmanaged memory, or some other arbitrary memory scheme. When pinned, the low-level handle to this arbitrary memory is a `MemoryHandle`. It can hold onto a reference to arbitrary memory by storing two things, a `GCHandle` and an `IPinnable`. The `GCHandle` is used for situations where the memory referenced is a part of a managed object (like a section of an array), while the `IPinnable` is used for situations where the referenced memory is managed by an external mechanism (like a `MemoryManager\u003cT\u003e`). If no memory management is required for the reference, than neither of them have to be used (for example, a constant region of memory which is never deallocated wouldn\u0027t need either). \r\n\r\nStructs like `Memory\u003cT\u003e` are useful because they provide a high-level view onto something low-level. API authors get the power to deal with the nitty-gritty memory when they need to, while all the end user sees is the pretty structs. Currently however, `MemoryHandle` is pretty much completely opaque, making it unnecessarily difficult to reason about its contents on a low level.\r\n\r\nThe example that compelled me to make this suggestion is one where I want to store a `Memory\u003cT\u003e` in unmanaged memory. It is currently possible to to this by creating a `GCHandle` to the `MemoryHandle`, then storing that in unmanaged memory (along with the actual fixed pointer), disposing both the `MemoryHandle` and the `GCHandle` pointing to the memory handle when finished. However, in the most common usecase of my API, the `MemoryHandle` is a reference to a part of a managed array, meaning it itself is essentially just a pointer and a `GCHandle` which I could just store directly, but can\u0027t because the handle is not exposed. Instead, I am forced into unnecessarily boxing the `MemoryHandle` so I can get a `GCHandle` to it in a very hot code path.\n\n### API Proposal\n\n```diff\r\nnamespace System.Buffers;\r\n\r\npublic unsafe struct MemoryHandle // ...\r\n{\r\n    // ...\r\n    \r\n+    public GCHandle Handle { get; }\r\n\r\n+    public IPinnable? Pinnable { get; }\r\n\r\n    // ...\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\npublic unsafe void MyAPI(Memory\u003cbyte\u003e buffer) {\r\n\r\n    MemoryHandle bufferHandle = buffer.Pin();\r\n\r\n    // Turn our buffer handle into a GCHandle\r\n    GCHandle handle = default;\r\n\r\n    if (bufferHandle.Handle.IsAllocated \u0026\u0026 bufferHandle.Pinnable == null)\r\n    {\r\n        handle = bufferHandle.Handle;\r\n    } \r\n    else if (bufferHandle.Pinnable != null)\r\n    {\r\n        // In this example, we just box bufferHandle but something smarter could be done here too,\r\n        //  like sticking the pinnable in an array and assigning it an index to store instead. \r\n        handle = GCHandle.Alloc(bufferHandle);\r\n    }\r\n\r\n    StoreUnmanaged(bufferHandle.Pointer, handle);\r\n}\r\n```\r\n\n\n### Alternative Designs\n\nFor my use case, it is possible to write a new struct which represents a `MemoryHandle` but is able to be stored in unmanaged memory (that\u0027s probably what I would end up doing anyway), but I don\u0027t know that this use is common enough to warrant that, and there are different implementation approaches that one might take depending on the usecase. It is my opinion that with these low-level APIs, there\u0027s very little reason to hide things that could be used to improve performance, which is exactly what `MemoryHandle` is doing.\n\n### Risks\n\n(Not sure if this is a \u0027risk\u0027 but...) I did notice that the design I\u0027ve suggested introduces what is a bit of an anti-pattern regarding `MemoryHandle.Dispose`. If you are pulling the `GCHandle` and `IPinnable` out of the `MemoryHandle`, you shouldn\u0027t dispose it because that will free the handle / unpin the reference. I\u0027m not sure how big of a problem that is, but thought I\u0027d include it here.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eTacodiva\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Memory`, `untriaged`, `needs-area-label`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-10-23T04:41:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5px-o4",
                                           "createdAt":  "2023-10-23T08:44:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "... Would it be beneficial to you to just use native memory, and then expose it to C#?  That is, invert the storage direction?",
                                           "updatedAt":  "2023-10-23T08:44:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5py4dQ",
                                           "createdAt":  "2023-10-23T11:01:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Tacodiva",
                                           "body":  "\u003e ... Would it be beneficial to you to just use native memory, and then expose it to C#? That is, invert the storage direction?\r\n\r\nYes for sure, it would be easier if i did that, but I would prefer it if the consumer of the API I\u0027m creating didn\u0027t have to deal with that. Just passing in the managed `Memory\u003cT\u003e` is so much cleaner.\r\n\r\nFor some context, I\u0027m coding a graphics API where the model data (like vertices and stuff) needs to be held by unmanaged memory while a frame is being rendered. I\u0027d really like it if you could just pass in a `Memory\u003cT\u003e` and I could just use it as is without having to copy everything.",
                                           "updatedAt":  "2023-10-23T11:01:30Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "[API Proposal]: Expose MemoryHandle\u0027s inner GCHandle and IPinnable",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/95320",
        "createdAt":  "2023-11-28T11:05:55Z",
        "number":  95320,
        "author":  "bevanweiss",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-19T16:15:12Z",
        "body":  "### Background and motivation:\r\nAs the SequenceReader is a component quite commonly used in the performance optimized System.IO.Pipelines API, it would be nice for it to have a full complement of low level Read methods which are endian-aware (such that higher level code appears clean and consistent in accessing the lower level memory sequences presented by the System.IO.Pipelines APIs and others).\r\nThere is support for some of the C# built-in types, but many are currently lacking.\r\n\r\n### API Proposal:\r\nThe addition of the following methods:\r\n```diff\r\nnamespace System.Buffers;\r\n\r\npublic static partial class SequenceReaderExtensions\r\n{\r\n...\r\n+        public static bool TryReadBigEndian(this ref System.Buffers.SequenceReader\u003cbyte\u003e reader, out ushort value;\r\n+        public static bool TryReadBigEndian(this ref System.Buffers.SequenceReader\u003cbyte\u003e reader, out uint value);\r\n+        public static bool TryReadBigEndian(this ref System.Buffers.SequenceReader\u003cbyte\u003e reader, out ulong value);\r\n+        public static bool TryReadBigEndian(this ref System.Buffers.SequenceReader\u003cbyte\u003e reader, out ulong value);\r\n+        public static bool TryReadBigEndian(this ref System.Buffers.SequenceReader\u003cbyte\u003e reader, out nint value);\r\n+        public static bool TryReadBigEndian(this ref System.Buffers.SequenceReader\u003cbyte\u003e reader, out nuint value);\r\n+        public static bool TryReadBigEndian(this ref System.Buffers.SequenceReader\u003cbyte\u003e reader, out System.Int128 value);\r\n+        public static bool TryReadBigEndian(this ref System.Buffers.SequenceReader\u003cbyte\u003e reader, out System.UInt128 value);\r\n+        public static bool TryReadBigEndian(this ref System.Buffers.SequenceReader\u003cbyte\u003e reader, out System.Half value);\r\n+        public static bool TryReadBigEndian(this ref System.Buffers.SequenceReader\u003cbyte\u003e reader, out single value);\r\n+        public static bool TryReadBigEndian(this ref System.Buffers.SequenceReader\u003cbyte\u003e reader, out double value);\r\n...\r\n+        public static bool TryReadLittleEndian(this ref System.Buffers.SequenceReader\u003cbyte\u003e reader, out ushort value);\r\n+        public static bool TryReadLittleEndian(this ref System.Buffers.SequenceReader\u003cbyte\u003e reader, out uint value);\r\n+        public static bool TryReadLittleEndian(this ref System.Buffers.SequenceReader\u003cbyte\u003e reader, out ulong value);\r\n+        public static bool TryReadLittleEndian(this ref System.Buffers.SequenceReader\u003cbyte\u003e reader, out nint value);\r\n+        public static bool TryReadLittleEndian(this ref System.Buffers.SequenceReader\u003cbyte\u003e reader, out nuint value);\r\n+        public static bool TryReadLittleEndian(this ref System.Buffers.SequenceReader\u003cbyte\u003e reader, out System.Int128 value);\r\n+        public static bool TryReadLittleEndian(this ref System.Buffers.SequenceReader\u003cbyte\u003e reader, out System.UInt128 value);\r\n+        public static bool TryReadLittleEndian(this ref System.Buffers.SequenceReader\u003cbyte\u003e reader, out System.Half value);\r\n+        public static bool TryReadLittleEndian(this ref System.Buffers.SequenceReader\u003cbyte\u003e reader, out single value);\r\n+        public static bool TryReadLittleEndian(this ref System.Buffers.SequenceReader\u003cbyte\u003e reader, out double value);\r\n...\r\n}\r\n```\r\n\r\nI also believe that consideration should be given to supporting the decimal C# datatype as well.\r\n```diff\r\nnamespace System.Buffers;\r\n\r\npublic static partial class SequenceReaderExtensions\r\n{\r\n+        //NOTE: Throws NotImplemented on LittleEndian architecture\r\n+        public static bool TryReadBigEndian(this ref System.Buffers.SequenceReader\u003cbyte\u003e reader, out decimal value);\r\n\r\n+        //NOTE: Throws NotImplemented on BigEndian architecture\r\n+        public static bool TryReadLittleEndian(this ref System.Buffers.SequenceReader\u003cbyte\u003e reader, out decimal value);\r\n}\r\n```\r\nThe reason I believe this should be considered is not strictly for the Endian handling aspect, but more for the Sequence handling aspect.\r\nAs the decimal is a native C# type, when using the SequenceReader API it doesn\u0027t feel appropriate that an API-user would need to concern themselves over re-assembling this native C# type themselves from potentially split sequences.\r\n\r\nWith the decimal being constructed of a 96bit integer, and a 32 bit flag, I\u0027m unsure how it would strictly be handled in terms of endian swapping.  I would however suggest that the API should be included in the SequenceReader, for completeness, but where the opposing read (BigEndian on little endian architecture and vice versa) would throw a NotImplemented exception.  The current implementation could then only handle the endianness of the architecture until BinaryPrimatives supports this handling also.\r\n\r\n\r\n### API Usage:\r\n```csharp\r\nusing System.Buffers;\r\n\r\nnamespace My.Magic.Bus;\r\npublic struct MyCustomStruct\r\n{\r\n    public uint CustomerIndex;\r\n    public decimal CustomersBigMoney;\r\n}\r\n\r\npublic static class MyCustomStructSequenceReaderExtensions\r\n{\r\n    public static bool TryReadBigEndian(this ref System.Buffers.SequenceReader\u003cbyte\u003e reader, out MyCustomStruct value)\r\n    {\r\n        MyCustomStruct temp;\r\n        bool success = true;\r\n        success \u0026= reader.TryReadBigEndian(out temp.CustomerIndex);\r\n        success \u0026= reader.TryReadBigEndian(out temp.CustomersBigMoney);\r\n        value = temp;\r\n        return success;\r\n    }\r\n\r\n    public static bool TryReadLittleEndian(this ref System.Buffers.SequenceReader\u003cbyte\u003e reader, out MyCustomStruct value)\r\n    {\r\n        MyCustomStruct temp;\r\n        bool success = true;\r\n        success \u0026= reader.TryReadLittleEndian(out temp.CustomerIndex);\r\n        success \u0026= reader.TryReadLittleEndian(out temp.CustomersBigMoney);\r\n        value = temp;\r\n        return success;\r\n    }\r\n}\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHObU8KIQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5tEb73",
                                           "createdAt":  "2023-11-28T13:46:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-io\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nIt appears that BinaryPrimatives now contains Endian Aware reads / writes for Single / Double types (as well as unsigned types)\r\nhttps://github.com/dotnet/runtime/pull/6864/files\r\n\r\nIt would be ideal if the StreamReader type supported similar.\r\nhttps://github.com/dotnet/runtime/blob/8557ef23f8b8d5b1c599e901d53ced04ee9a4d7c/src/libraries/System.Memory/ref/System.Memory.cs#L114-L119\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ebevanweiss\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.IO`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-11-28T13:46:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5tKzX1",
                                           "createdAt":  "2023-11-29T09:42:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nIt appears that BinaryPrimatives now contains Endian Aware reads / writes for Single / Double types (as well as unsigned types)\r\nhttps://github.com/dotnet/runtime/pull/6864/files\r\n\r\nIt would be ideal if the SequenceReader type supported similar.\r\nhttps://github.com/dotnet/runtime/blob/8557ef23f8b8d5b1c599e901d53ced04ee9a4d7c/src/libraries/System.Memory/ref/System.Memory.cs#L114-L119\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ebevanweiss\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.IO`, `area-System.Memory`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-11-29T09:42:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5tMcOx",
                                           "createdAt":  "2023-11-29T14:15:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "This issue has been marked `needs-author-action` and may be missing some important information.",
                                           "updatedAt":  "2023-11-29T14:15:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5tMeRK",
                                           "createdAt":  "2023-11-29T14:20:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "Can you please update the proposal to follow the API review template? Our general API review process is detailed here: https://github.com/dotnet/runtime/blob/main/docs/project/api-review-process.md and we need, at minimum, a clear section detailing the signatures of the APIs being requested (such as in https://github.com/dotnet/runtime/issues/93046).\r\n\r\nIt would be ideal if you could ensure the same types supported by `BinaryPrimitives` are being requested to be supported by `SequenceReader` so we can review them all at once. What looks to be missing is:\r\n* `Double`\r\n* `Half`\r\n* `Int128`\r\n* `IntPtr`\r\n* `Single`\r\n* `UInt16`\r\n* `UInt32`\r\n* `UInt64`\r\n* `UInt128`\r\n* `UIntPtr`",
                                           "updatedAt":  "2023-11-29T14:20:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5tM04Z",
                                           "createdAt":  "2023-11-29T15:08:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "\u003e What looks to be missing is\r\n\r\nWhat about `decimal`?",
                                           "updatedAt":  "2023-11-29T15:08:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5tM22x",
                                           "createdAt":  "2023-11-29T15:12:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "There is no decimal API in `BinaryPrimitives` and I don\u0027t expect we have any plans of adding one either. `Decimal` is not a simple primitive with a trivially defined layout. It is a complex struct explicitly composed of several fields.",
                                           "updatedAt":  "2023-11-29T15:12:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5tQ4t8",
                                           "createdAt":  "2023-11-30T05:42:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "In the era with generic math, do we still need to declare such API exhaustively for each type?",
                                           "updatedAt":  "2023-11-30T05:42:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5tREsV",
                                           "createdAt":  "2023-11-30T06:38:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bevanweiss",
                                           "body":  "\u003e In the era with generic math, do we still need to declare such API exhaustively for each type?\r\n\r\nI think \u0027yes\u0027.\r\nIf you\u0027ve got an example of (performant) code that would work \u0027generically\u0027 for all the types shown above, let us know.\r\n\r\nChallenges of generics here\r\n\r\n1. No generic support for size constraints (you can\u0027t have something compile-type select a target method from sizeof(..))\r\n2. Even if you could, not all types even of the same size are the same internal format (i.e. decimal vs UInt128 / Int128)",
                                           "updatedAt":  "2023-11-30T06:38:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5tRarg",
                                           "createdAt":  "2023-11-30T08:07:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "\u003e 1. No generic support for size constraints (you can\u0027t have something compile-type select a target method from sizeof(..))\r\n\r\nYou can just use a bunch of `if` and `else` for value types. Generic specialization will take care of it.\r\n\r\n\u003e 2. Even if you could, not all types even of the same size are the same internal format (i.e. decimal vs UInt128 / Int128)\r\n\r\nThey are the same, when following definition of BinaryPrimitives.\r\n\r\nWhen all the data types are just treated as a byte sequence, the API can be implemented very efficiently:\r\n\r\n1. Choose the integer type with same size, and use `Unsafe.BitCast` to convert back and forth.\r\n2. Delegate to IBinaryInteger.Read{Big|Little}Endian on the integer type.\r\n\r\nThe problem is that there\u0027s no common interface to express all fixed-length scalar number types. ",
                                           "updatedAt":  "2023-11-30T08:07:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5tTwoh",
                                           "createdAt":  "2023-11-30T14:35:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e Generic specialization will take care of it.\r\n\r\nThis is not a guarantee. It doesn\u0027t work with Mono today, doesn\u0027t work with Unity, doesn\u0027t work for reference types, can be disabled for some scenarios, etc.\r\n\r\n\u003e Choose the integer type with same size, and use Unsafe.BitCast to convert back and forth.\r\n\r\nWe do not want to encourage developers to make use of `Unsafe.*` to achieve \"basic functionality\".\r\n\r\n\u003e Delegate to IBinaryInteger.Read{Big|Little}Endian on the integer type.\r\n\r\nEndianness reversal isn\u0027t one of the things we added general support for. It was discussed, and ultimately rejected, because it often cannot make sense for more complex types.\r\n\r\nThe closest we have is the ability to read/write values as a two\u0027s complement representation, which only applies to `IBinaryInteger\u003cT\u003e` and isn\u0027t necessarily the same as it doesn\u0027t provide guarantees about fitting a particular format. It could be the shortest two\u0027s complement representation, it could be a fixed length, it could some arbitrary other length as long as it\u0027s two\u0027s complement.\r\n\r\n\u003e The problem is that there\u0027s no common interface to express all fixed-length scalar number types.\r\n\r\nThis was also intentional, there is too big of a split between the different scenarios users may want. They may only want language primitives, they may want only runtime primitives, they may want only ABI primitives, they may want any fixed-length type, etc.\r\n\r\nSuch interfaces would\u0027ve largely just been marker interfaces and would have had concerns around versioning over time and the implications of expanding the set in them, given how users might try to use them.\r\n\r\n--------------------------\r\n\r\nIf `SequenceReader` hadn\u0027t already exposed these APIs, I would have just said that users should use `BinaryPrimitives` to do all endianness related conversions. However, since we did expose them (partially due to historical layering considerations), it is reasonable to give users the \"full\" experience here and get the full set of common overloads.",
                                           "updatedAt":  "2023-11-30T14:35:20Z"
                                       }
                                   ],
                         "totalCount":  10
                     },
        "title":  "[API Proposal]: SequenceReader missing endian-aware read methods for C# built-in ValueTypes",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/96587",
        "createdAt":  "2024-01-07T01:11:33Z",
        "number":  96587,
        "author":  "stephentoub",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODBlzMQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-01-07T01:55:33Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "vcsjones",
                                            "createdAt":  "2024-01-07T03:40:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "HighPerfDotNet",
                                            "createdAt":  "2024-01-07T05:12:57Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "campersau",
                                            "createdAt":  "2024-01-07T09:19:57Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "martincostello",
                                            "createdAt":  "2024-01-07T11:12:36Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "KennethHoff",
                                            "createdAt":  "2024-01-07T11:16:09Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MichalPetryka",
                                            "createdAt":  "2024-01-07T14:49:03Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "neon-sunset",
                                            "createdAt":  "2024-01-07T16:55:25Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2024-01-07T22:12:58Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "adamsitnik",
                                            "createdAt":  "2024-01-08T10:11:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "alexrp",
                                            "createdAt":  "2024-01-08T16:03:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "RenderMichael",
                                            "createdAt":  "2024-01-15T05:50:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MineCake147E",
                                            "createdAt":  "2024-01-15T21:42:49Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Joe4evr",
                                            "createdAt":  "2024-01-25T10:59:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hendriklhf",
                                            "createdAt":  "2024-01-28T20:10:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Neme12",
                                            "createdAt":  "2024-04-10T20:36:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "frasten",
                                            "createdAt":  "2024-05-14T22:55:49Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "raulsntos",
                                            "createdAt":  "2024-05-21T14:11:16Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "stevejgordon",
                                            "createdAt":  "2024-07-18T06:12:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AlexRadch",
                                            "createdAt":  "2024-08-14T13:22:33Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sveinungf",
                                            "createdAt":  "2024-11-21T08:53:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rampaa",
                                            "createdAt":  "2025-04-23T12:58:01Z"
                                        }
                                    ],
                          "totalCount":  22
                      },
        "updatedAt":  "2025-07-14T18:15:21Z",
        "body":  "If a `Span\u003cT\u003e` parameter is never written to by a method body, it\u0027s better for the parameter to be a `ReadOnlySpan\u003cT\u003e` rather than `Span\u003cT\u003e`. Doing so:\r\n- Prevents inadvertent mistakes by preventing the method from erroneously writing to the memory (short of using unsafe code)\r\n- Advertizes to the caller the semantics of the callee (that it won\u0027t be mutating the argument)\r\n- Can have better performance for the caller, e.g. if the caller has an array of reference types, constructing a `ReadOnlySpan\u003cT\u003e` is cheaper than constructing a `Span\u003cT\u003e`, as the latter needs to perform a variance check and the former does not.\r\n\r\nWe could extend such an analyzer to locals as well. This can also handle {ReadOnly}Memory. \r\n\r\nAnd we should probably allow it to be configurable around visibility, e.g. default to only applying to internal/private members but allow it to be applied to public, too.\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOqFLkog==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5wDQrm",
                                           "createdAt":  "2024-01-07T01:11:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nIf a `Span\u003cT\u003e` parameter is never written to by a method body, it\u0027s better for the parameter to be a `ReadOnlySpan\u003cT\u003e` rather than `Span\u003cT\u003e`. Doing so:\r\n- Prevents inadvertent mistakes by preventing the method from erroneously writing to the memory (short of using unsafe code)\r\n- Advertizes to the caller the semantics of the callee (that it won\u0027t be mutating the argument)\r\n- Can have better performance for the caller, e.g. if the caller has an array of reference types, constructing a `ReadOnlySpan\u003cT\u003e` is cheaper than constructing a `Span\u003cT\u003e`, as the latter needs to perform a variance check and the former does not.\r\n\r\nWe could extend such an analyzer to locals as well.\r\n\r\nAnd we should probably allow it to be configurable around visibility, e.g. default to only applying to internal/private members but allow it to be applied to public, too.\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003estephentoub\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Memory`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-01-07T01:11:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wDQ-5",
                                           "createdAt":  "2024-01-07T01:17:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "alexrp",
                                           "body":  "Presumably this would apply to `Memory\u003cT\u003e` as well?",
                                           "updatedAt":  "2024-01-07T01:17:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wDREj",
                                           "createdAt":  "2024-01-07T01:19:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Presumably this would apply to `Memory\u003cT\u003e` as well?\r\n\r\nIt could, yes.",
                                           "updatedAt":  "2024-01-07T01:19:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wDTOA",
                                           "createdAt":  "2024-01-07T02:00:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "\u003e default to only applying to internal/private members but allow it to be applied to public, too\r\n\r\nArgh.\r\nOn the one hand, during initial design time you want it to apply to public members.\r\nDuring maintenance, not necessarily so much....",
                                           "updatedAt":  "2024-01-07T02:00:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wDvgX",
                                           "createdAt":  "2024-01-07T11:21:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KennethHoff",
                                           "body":  "\u003e And we should probably allow it to be configurable around visibility, e.g. default to only applying to internal/private members but allow it to be applied to public, too.\r\n\r\nTangential, but is there a system that allows you to tag a project as \"internal\" such that public members - for the sake of analyzers and whatnot - are classified as internal and vice versa. For me personally, there\u0027s no difference other than hiding stuff from other projects in the same solution for if I use public vs internal, but many analyzers works differently based on it.\r\n\r\nIf there is no such system, would you consider it? Doing it manually for each analyzer is in no way sustainable ( some only function for internal, some only for public, and so on)",
                                           "updatedAt":  "2024-01-07T11:21:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wJoxr",
                                           "createdAt":  "2024-01-08T18:00:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Tangential, but is there a system that allows you to tag a project as \"internal\" such that public members - for the sake of analyzers and whatnot - are classified as internal and vice versa. For me personally, there\u0027s no difference other than hiding stuff from other projects in the same solution for if I use public vs internal, but many analyzers works differently based on it.\r\n\r\nNot to my knowledge. You could open an issue in roslyn-analyzers about such configuration.",
                                           "updatedAt":  "2024-01-08T18:00:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56GAMI",
                                           "createdAt":  "2024-04-10T20:36:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "This actually seems like it would be useful for `ref` parameters too to make them `ref readonly` (or `in`). But it\u0027s really hard to determine whether it\u0027s actually written to and whether the semantics will be the same with readonly (no additional copies), as the compiler doesn\u0027t provide any APIs to determine where structs are copied during their invocation as far as I recall.",
                                           "updatedAt":  "2024-04-10T20:38:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GK-se",
                                           "createdAt":  "2024-07-25T17:21:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bartonjs",
                                           "body":  "[Video](https://www.youtube.com/watch?v=mUMGod4PVq8\u0026t=0h0m0s)\n\n* Detect when an input parameter or a local could be ReadOnlySpan or ReadOnlyMemory instead of Span or Memory\r\n* The analyzer shouldn\u0027t analyze parameters on overridden members\r\n* The analyzer will probably not provide analysis for a Span that gets used in a `fixed` statement, rather than decide if it has read semantics or write semantics on the pointer.\r\n* It should be on by default for non-visible members, with an opt-in for public.\r\n  * Pipedream: It should run on \"new code\", if we could determine that.\r\n\r\nFixer: Obviously\r\nCategory: Reliability\r\nSeverity: Info",
                                           "updatedAt":  "2024-07-25T19:02:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6oUuSi",
                                           "createdAt":  "2025-04-23T11:41:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rampaa",
                                           "body":  "If we should prefer ReadOnlySpan/ReadOnlyMemory over their non-readonly counterparts, shouldn\u0027t the BCL expose extension methods for them whenever appropriate? I\u0027ve found issues like https://github.com/dotnet/runtime/issues/21121 which were closed as completed, but I currently see no extension method named `AsReadOnlySpan`. Also for things like `CollectionsMarshal.AsSpan`, shouldn\u0027t there be a `CollectionsMarshal.ReadOnlySpan` counterpart as well? Should I open `API Suggestion`s for these matters?",
                                           "updatedAt":  "2025-04-23T11:41:21Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "[Analyzer Proposal]: Span parameter that could be a ReadOnlySpan parameter",
        "labels":  [
                       "api-approved",
                       "area-System.Memory",
                       "help wanted",
                       "code-analyzer",
                       "code-fixer"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/96844",
        "createdAt":  "2024-01-11T15:04:54Z",
        "number":  96844,
        "author":  "AlexRadch",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-19T16:15:14Z",
        "body":  "### Background and motivation\r\n\r\nI need to find all the words in the buffer. `WordChars` are the characters that make up words.\r\n\r\nI implemented this `Words(ReadOnlyMemory Memory, char[] WordChars)` method through the `Split(ReadOnlyMemory Memory, SearchValues ​​separators)` method, which divides the memory using separators.\r\n\r\n```csharp\r\nWords(ReadOnlyMemory memory, char[] wordChars)\r\n{\r\n    var wordSV = SearchValues.Create(wordChars);\r\n    var separatorsSV = CreateOppositeSearchValues(wordSV);\r\n    return Split(memory, separatorsSV};\r\n}\r\n```\r\n\r\nUnfortunately, to call the Split method I need to create opposite SearchValues, and no method does this, so I was forced to implement this method using a loop:\r\n\r\n```csharp\r\n    public static SearchValues\u003cchar\u003e CreateOpposite(SearchValues\u003cchar\u003e searchValues)\r\n    {\r\n        List\u003cchar\u003e oppositeChars = [];\r\n        for (int c = char.MinValue; c \u003c= char.MaxValue; c++)\r\n        {\r\n            if (!searchValues.Contains((char)c))\r\n                oppositeChars.Add((char)c);\r\n        }\r\n        return SearchValues.Create(CollectionsMarshal.AsSpan(oppositeChars));\r\n    }\r\n```\r\nI suggest adding the ability to create Opposite SearchValues ​​in .NET.\r\n\r\n### API Proposal\r\n\r\n```diff\r\nnamespace System.Buffers\r\n\r\npublic static class SearchValues\r\n{\r\n+    public static SearchValues\u003cbyte\u003e CreateOpposite(ReadOnlySpan\u003cbyte\u003e values);\r\n+    public static SearchValues\u003cchar\u003e CreateOpposite(ReadOnlySpan\u003cchar\u003e values);\r\n+    public static SearchValues\u003cT\u003e CreateOpposite\u003cT\u003e(SearchValues\u003cT\u003e values);\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\nwords = Split(memory, SearchValues.CreateOpposite(wordSearchValues));\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOcIHDZw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5wfwtl",
                                           "createdAt":  "2024-01-11T15:05:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nI need to find all the words in the buffer. `WordChars` are the characters that make up words.\r\n\r\nI implemented this `Words(ReadOnlyMemory Memory, char[] WordChars)` method through the `Split(ReadOnlyMemory Memory, SearchValues ​​separators)` method, which divides the memory using separators.\r\n\r\n```csharp\r\nWords(ReadOnlyMemory memory, char[] wordChars)\r\n{\r\n    var wordSV = SearchValues.Create(wordChars);\r\n    var separatorsSV = CreateOppositeSearchValues(wordSV);\r\n    return Split(memory, separatorsSV};\r\n}\r\n```\r\n\r\nUnfortunately, to call the Split method I need to create opposite SearchValues, and no method does this, so I was forced to implement this method using a loop:\r\n\r\n```csharp\r\n    public static SearchValues\u003cchar\u003e CreateOpposite(SearchValues\u003cchar\u003e searchValues)\r\n    {\r\n        List\u003cchar\u003e oppositeChars = [];\r\n        for (int c = char.MinValue; c \u003c= char.MaxValue; c++)\r\n        {\r\n            if (!searchValues.Contains((char)c))\r\n                oppositeChars.Add((char)c);\r\n        }\r\n        return SearchValues.Create(CollectionsMarshal.AsSpan(oppositeChars));\r\n    }\r\n```\r\nI suggest adding the ability to create Opposite SearchValues ​​in .NET.makeup\n\n### API Proposal\n\n```diff\r\nnamespace System.Buffers\r\n\r\npublic static class SearchValues\r\n{\r\n+    public static SearchValues\u003cbyte\u003e CreateOpposite(ReadOnlySpan\u003cbyte\u003e values);\r\n+    public static SearchValues\u003cchar\u003e CreateOpposite(ReadOnlySpan\u003cchar\u003e values);\r\n+    public static SearchValues\u003cT\u003e CreateOpposite\u003cT\u003e(SearchValues\u003cT\u003e values);\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nwords = Split(memory, SearchValues.CreateOpposite(wordSearchValues));\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eAlexRadch\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Memory`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-01-11T15:05:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wf-in",
                                           "createdAt":  "2024-01-11T15:35:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "cc @MihaZupan ",
                                           "updatedAt":  "2024-01-11T15:35:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wgYtD",
                                           "createdAt":  "2024-01-11T16:34:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e through the Split(ReadOnlyMemory Memory, SearchValues ​​separators) method\r\n\r\nIs that your own method? Can you just use IndexOfAnyExcept instead of IndexOfAny?",
                                           "updatedAt":  "2024-01-11T16:34:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wgcNn",
                                           "createdAt":  "2024-01-11T16:42:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AlexRadch",
                                           "body":  "\u003e Is that your own method? Can you just use IndexOfAnyExcept instead of IndexOfAny?\r\n\r\nYes, this is my method and I can copy it into the `Words(ReadOnlyMemory Memory, char[] WordChars)` method and rewrite it with `IndexOfAnyExcept`. However, it is more convenient to simply create opposite search values ​​and use the old method implemented once.",
                                           "updatedAt":  "2024-01-11T16:43:23Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "[API Proposal]: Creating Opposite SearchValues",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/97194",
        "createdAt":  "2024-01-19T05:33:32Z",
        "number":  97194,
        "author":  "MineCake147E",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC1TkfA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "HighPerfDotNet",
                                            "createdAt":  "2024-01-19T14:42:31Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "omariom",
                                            "createdAt":  "2024-01-19T17:22:19Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-01-20T16:40:24Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2024-07-19T16:15:15Z",
        "body":  "### Background and motivation\n\n`memmove` and `memset` are the most common operations from the earliest days of computing to today.\r\nThey are included in most practical programming languages, except assembly, and have been optimized incrementally for a long, long time.\r\nHowever, these two functions are reaching their limits of optimization, especially in terms of power consumption and CPU utilization.\r\nWhile simultaneous multithreading has slightly improved CPU utilization, it doesn\u0027t solve the fundamental problem underlying these two functions: during operation, a CPU core running `memmove` or `memset` is only copying memory to and from CPU registers, and not performing any actual operations that alters the data.\r\n\r\nTo solve this fundamental problem, Intel started to include one or more accelerators called `Data Streaming Accelerator`(DSA for short) in most of its Xeon CPUs since the `Sapphire Rapids`.\r\nDSA can only perform a limited number of memory operations, including `memmove` and a limited subset of `memset` (the pattern size of `memset` in bits must be a power of 2, 16 bytes (128 bits) or fewer).\r\nBut DSA performs these operations asynchronously, independent of the CPU.\r\nAnd in most cases, it\u0027s much faster than a CPU core doing the same thing.\r\n\r\nTheoretically, We can use DSA to perform `memmove` and `memset` asynchronously, by either returning a `ValueTask` that waits until the DSA finishes processing, or returning the `ValueTask.CompletedTask` if the DSA is not available or the task is performed synchronously for some reason.\r\nThe same principle could be applied if competitors, especially AMD and ARM, begin to incorporate similar hardware accelerators in their CPUs, SoCs, etc. in the future. And in my humble opinion, it\u0027s likely to happen.\r\nThis is why I propose these APIs as a cross-platform thing.\r\n\r\nAlthough implementing the actual hardware acceleration support could be hard, the APIs below can trivially be implemented by just assuming no hardware accelerators are available, as a first step.\r\nThe only exception is `Buffer.MemoryFillAsync` which needs to be implemented by software as well, but it can be implemented by slightly modifying the code from `Span\u003cT\u003e.Fill`.\r\nThe actual hardware acceleration support could be implemented in the near future.\r\n\r\nAs a side note, I have a PC with a Xeon w5-2455X with one DSA included, so I would be happy to help with debugging.\n\n### API Proposal\n\n```csharp\r\nnamespace System\r\n{\r\n    public readonly struct Memory\u003cT\u003e : IEquatable\u003cMemory\u003cT\u003e\u003e\r\n    {\r\n        public ValueTask CopyToAsync(Memory\u003cT\u003e destination);\r\n\r\n        public ValueTask\u003cbool\u003e TryCopyToAsync(Memory\u003cT\u003e destination);\r\n\r\n        public ValueTask FillAsync(T value);\r\n\r\n        public ValueTask ClearAsync();\r\n    }\r\n\r\n    public readonly struct ReadOnlyMemory\u003cT\u003e : IEquatable\u003cReadOnlyMemory\u003cT\u003e\u003e\r\n    {\r\n        public ValueTask CopyToAsync(Memory\u003cT\u003e destination);\r\n\r\n        public ValueTask\u003cbool\u003e TryCopyToAsync(Memory\u003cT\u003e destination);\r\n    }\r\n\r\n    public static partial class Buffer\r\n    {\r\n        public static unsafe ValueTask MemoryCopyAsync(void* source, void* destination, ulong destinationSizeInBytes, ulong sourceBytesToCopy);\r\n        public static unsafe ValueTask MemoryFillAsync(void* source, void* destination, ulong destinationSizeInBytes, ulong sourcePatternBytesToFill);\r\n    }\r\n}\r\n```\n\n### API Usage\n\n```csharp\r\n// The `source` and `destination` point to some mebibytes of memory region\r\n// Let DSA copy the `source` to the `destination` asynchronously if it\u0027s available\r\nvar task = source.CopyToAsync(destination);\r\n// Some operations can be executed while copying\r\nawait task;\r\n```\n\n### Alternative Designs\n\n* There may be better names for each identifier.\r\n* The synchronous variant of the `Buffer.MemoryFillAsync` could also be included as well, as there is no such thing currently.\r\n* Many other operations, like comparison, could also be offloaded to DSA.\n\n### Risks\n\n* There are no benefits at all for environments without any hardware accelerators available anyway.\r\n  * Or should these operations be offloaded to another CPU core? Does it worth doing?\r\n* For Intel DSA, only a few CPUs can benefit from these features today.\r\n  * This means that debugging these features is really hard today.\r\n  * And either Intel, operating system vendors like Microsoft, or third parties, should provide some drivers, either kernel mode or user mode, or both.\r\n    * For example, the Intel DSA Driver (IDXD) was introduced in the Linux kernel version 5.6.\r\n    * Will Microsoft have one for `Windows 11 Home` someday?\r\n  * And .NET should be able to detect the DSA availability, in order to utilize them.\r\n* Some users may abuse the asynchronous variant without considering the benefits or drawbacks, regardless of hardware acceleration availability.\r\n  * But it can be mitigated by automatically switching to synchronous variant depending on the hardware acceleration availability and the size of data to process.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOcT2hDg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5xPNMq",
                                           "createdAt":  "2024-01-19T05:52:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\n`memmove` and `memset` are the most common operations from the earliest days of computing to today.\r\nThey are included in most practical programming languages, except assembly, and have been optimized incrementally for a long, long time.\r\nHowever, these two functions are reaching their limits of optimization, especially in terms of power consumption and CPU utilization.\r\nWhile simultaneous multithreading has slightly improved CPU utilization, it doesn\u0027t solve the fundamental problem underlying these two functions: during operation, a CPU core running `memmove` or `memset` is only copying memory to and from CPU registers, and not performing any actual operations that alters the data.\r\n\r\nTo solve this fundamental problem, Intel started to include one or more accelerators called `Data Streaming Accelerator`(DSA for short) in most of its Xeon CPUs since the `Sapphire Rapids`.\r\nDSA can only perform a limited number of memory operations, including `memmove` and a limited subset of `memset` (the pattern size of `memset` in bits must be a power of 2, 16 bytes (128 bits) or fewer).\r\nBut DSA performs these operations asynchronously, independent of the CPU.\r\nAnd in most cases, it\u0027s much faster than a CPU core doing the same thing.\r\n\r\nTheoretically, We can use DSA to perform `memmove` and `memset` asynchronously, by either returning a `ValueTask` that waits until the DSA finishes processing, or returning the `ValueTask.CompletedTask` if the DSA is not available or the task is performed synchronously for some reason.\r\nThe same principle could be applied if competitors, especially AMD and ARM, begin to incorporate similar hardware accelerators in their CPUs, SoCs, etc. in the future. And in my humble opinion, it\u0027s likely to happen.\r\nThis is why I propose these APIs as a cross-platform thing.\r\n\r\nAlthough implementing the actual hardware acceleration support could be hard, the APIs below can trivially be implemented by just assuming no hardware accelerators are available, as a first step.\r\nThe only exception is `Buffer.MemoryFillAsync` which needs to be implemented by software as well, but it can be implemented by slightly modifying the code from `Span\u003cT\u003e.Fill`.\r\nThe actual hardware acceleration support could be implemented in the near future.\r\n\r\nAs a side note, I have a PC with a Xeon w5-2455X with one DSA included, so I would be happy to help with debugging.\n\n### API Proposal\n\n```csharp\r\nnamespace System\r\n{\r\n    public readonly struct Memory\u003cT\u003e : IEquatable\u003cMemory\u003cT\u003e\u003e\r\n    {\r\n        public ValueTask CopyToAsync(Memory\u003cT\u003e destination);\r\n\r\n        public ValueTask\u003cbool\u003e TryCopyToAsync(Memory\u003cT\u003e destination);\r\n\r\n        public ValueTask FillAsync(T value);\r\n\r\n        public ValueTask ClearAsync();\r\n    }\r\n\r\n    public readonly struct ReadOnlyMemory\u003cT\u003e : IEquatable\u003cReadOnlyMemory\u003cT\u003e\u003e\r\n    {\r\n        public ValueTask CopyToAsync(Memory\u003cT\u003e destination);\r\n\r\n        public ValueTask\u003cbool\u003e TryCopyToAsync(Memory\u003cT\u003e destination);\r\n    }\r\n\r\n    public static partial class Buffer\r\n    {\r\n        public static unsafe ValueTask MemoryCopyAsync(void* source, void* destination, ulong destinationSizeInBytes, ulong sourceBytesToCopy);\r\n        public static unsafe ValueTask MemoryFillAsync(void* source, void* destination, ulong destinationSizeInBytes, ulong sourcePatternBytesToFill);\r\n    }\r\n}\r\n```\n\n### API Usage\n\n```csharp\r\n// The `source` and `destination` point to some mebibytes of memory region\r\n// Let DSA copy the `source` to the `destination` asynchronously if it\u0027s available\r\nvar task = source.CopyToAsync(destination);\r\n// Some operations can be executed while copying\r\nawait task;\r\n```\n\n### Alternative Designs\n\n* There may be better names for each identifier.\r\n* The synchronous variant of the `Buffer.MemoryFillAsync` could also be included as well, as there is no such thing currently.\r\n* Many other operations, like comparison, could also be offloaded to DSA.\n\n### Risks\n\n* There are no benefits at all for environments without any hardware accelerators available anyway.\r\n  * Or should these operations be offloaded to another CPU core? Does it worth doing?\r\n* For Intel DSA, only a few CPUs can benefit from these features today.\r\n  * This means that debugging these features is really hard today.\r\n  * And either Intel, operating system vendors like Microsoft, or third parties, should provide some drivers, either kernel mode or user mode, or both.\r\n    * For example, the Intel DSA Driver (IDXD) was introduced in the Linux kernel version 5.6.\r\n    * Will Microsoft have one for `Windows 11 Home` someday?\r\n  * And .NET should be able to detect the DSA availability, in order to utilize them.\r\n* Some users may abuse the asynchronous variant without considering the benefits or drawbacks, regardless of hardware acceleration availability.\r\n  * But it can be mitigated by automatically switching to synchronous variant depending on the hardware acceleration availability and the size of data to process.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eMineCake147E\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Memory`, `untriaged`, `needs-area-label`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-01-19T05:52:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5xPNcO",
                                           "createdAt":  "2024-01-19T05:54:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODTUVng==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "MineCake147E",
                                                                               "createdAt":  "2024-01-19T05:54:55Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Symbai",
                                                                               "createdAt":  "2024-01-19T06:18:28Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "HighPerfDotNet",
                                                                               "createdAt":  "2024-01-19T14:43:00Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "neon-sunset",
                                                                               "createdAt":  "2024-01-19T17:29:59Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Alternative Designs\r\n\r\nThese APIs can start as an independent 3rd party package.",
                                           "updatedAt":  "2024-01-19T05:54:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5xPaEO",
                                           "createdAt":  "2024-01-19T06:54:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MineCake147E",
                                           "body":  "\u003e These APIs can start as an independent 3rd party package.\r\n\r\nThat would be a good first step as well.\r\nHowever, I came up with another use case of async `memmove` without DSA: copying multiple blocks of large data simultaneously while managing each task in a simple way.\r\n```csharp\r\nvar t0 = src0.CopyToAsync(dst0);\r\nvar t1 = src1.CopyToAsync(dst1);\r\n// ...\r\nawait t0;\r\nawait t1;\r\n// ...\r\n```\r\nIn this case, APIs like `CopyToAsync` could need another argument to specify not to execute it synchronously even though no hardware accelerator is available.",
                                           "updatedAt":  "2024-01-19T06:54:29Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "[API Proposal]: Asynchronous memory operation APIs for future hardware offloading and acceleration",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/97230",
        "createdAt":  "2024-01-19T18:41:10Z",
        "number":  97230,
        "author":  "AlexRadch",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC5qMEg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-02-06T01:51:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "StDymphna",
                                            "createdAt":  "2024-07-24T15:18:48Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2024-07-19T16:15:16Z",
        "body":  "### Background and motivation\r\n\r\nI can\u0027t cast a Span with a nullable type to another Span. Nullable types must be supported.\r\n\r\n`MemoryMarshal.Cast\u003cint?, Equitable\u003cint?\u003e\u003e(span);` generates next error `CS0453\tThe type \u0027int?\u0027 must be a non-nullable value type in order to use it as parameter \u0027TFrom\u0027 in the generic type or method \u0027MemoryMarshal.Cast\u003cTFrom, TTo\u003e(ReadOnlySpan\u003cTFrom\u003e)\u0027\r\n\r\nWe can add new methods or change existing ones.\r\n\r\n### API Proposal\r\n\r\n```diff\r\nnamespace System.Runtime.InteropServices;\r\n\r\npublic static class MemoryMarshal\r\n{\r\n+        public static ReadOnlySpan\u003cTTo?\u003e Cast\u003cTFrom, TTo\u003e(ReadOnlySpan\u003cTFrom?\u003e span)\r\n+            where TFrom : struct\r\n+            where TTo : struct\r\n\r\n+        public static Span\u003cTTo?\u003e Cast\u003cTFrom, TTo\u003e(Span\u003cTFrom?\u003e span)\r\n+            where TFrom : struct\r\n+            where TTo : struct\r\n}\r\n```\r\n\r\n### API Usage\r\n\r\n```csharp\r\nint?[] array = [9, 1, null, 3, null, 5, null, 7, null];\r\nvar span = array.AsSpan();\r\n\r\n// The next code line does not work because `int?` is not IEquatable\u003cint?\u003e\r\n//var i = span.IndexOf(5); \r\n\r\n// The following casting is not supported!!!\r\nvar equatableSpan = MemoryMarshal.Cast\u003cint?, Equitable\u003cint?\u003e\u003e(span); \r\n\r\n// So I use workaround\r\nvar equatableSpan = MemoryMarshal.CreateSpan(ref Unsafe.As\u003cint?, Equitable\u003cint?\u003e\u003e(\r\n    ref MemoryMarshal.GetReference(span)), span.Length);\r\n\r\n// The next code line work because `Equitable\u003cint?\u003e` is IEquatable\u003cEquitable\u003cint?\u003e\u003e\r\nvar i = equatableSpan.IndexOf(new Equitable\u003cint?\u003e(5)); // Same as span.IndexOf(5); \r\n\r\npublic struct Equitable\u003cT\u003e : IEquatable\u003cEquitable\u003cT\u003e\u003e\r\n{\r\n    public T Value;\r\n    public Equitable(T value) =\u003e Value = value;\r\n    public bool Equals(Equitable\u003cT\u003e value) =\u003e EqualityComparer\u003cT\u003e.Default.Equals(this.Value, value.Value);\r\n}\r\n```\r\n\r\n### Alternative Designs\r\n\r\nUse workaround\r\n\r\n```cs\r\nvar equatableSpan = MemoryMarshal.CreateSpan(ref Unsafe.As\u003cint?, Equitable\u003cint?\u003e\u003e(\r\n    ref MemoryMarshal.GetReference(span)), span.Length);\r\n```\r\n\r\n### Risks\r\n\r\nNo",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOcgFUjg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5xTcSc",
                                           "createdAt":  "2024-01-19T18:41:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nI can\u0027t cast a Span with a nullable type to another Span. Nullable types must be supported.\r\n\r\n`MemoryMarshal.Cast\u003cint?, ClassT\u003cint?\u003e\u003e(nIntsSpan);` generates next error `CS0453\tThe type \u0027int?\u0027 must be a non-nullable value type in order to use it as parameter \u0027TFrom\u0027 in the generic type or method \u0027MemoryMarshal.Cast\u003cTFrom, TTo\u003e(ReadOnlySpan\u003cTFrom\u003e)\u0027\r\n\r\nWe can add new methods or change existing ones.\n\n### API Proposal\n\n```diff\r\nnamespace System.Runtime.InteropServices;\r\n\r\npublic static class MemoryMarshal\r\n{\r\n+        public static ReadOnlySpan\u003cTTo?\u003e Cast\u003cTFrom, TTo\u003e(ReadOnlySpan\u003cTFrom?\u003e span)\r\n+            where TFrom : struct\r\n+            where TTo : struct\r\n\r\n+        public static Span\u003cTTo?\u003e Cast\u003cTFrom, TTo\u003e(Span\u003cTFrom?\u003e span)\r\n+            where TFrom : struct\r\n+            where TTo : struct\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nint?[] array = [9, 1, null, 3, null, 5, null, 7, null];\r\nvar span = array.AsSpan();\r\n\r\n// The next code line does not work because `int?` is not IEquatable\u003cint?\u003e\r\n//var i = span.IndexOf(5); \r\n\r\n// The following casting is not supported!!!\r\nvar equatableSpan = MemoryMarshal.Cast\u003cint?, Equitable\u003cint?\u003e\u003e(span); \r\n\r\n// So I use workaround\r\nvar equatableSpan = MemoryMarshal.CreateSpan(ref Unsafe.As\u003cint?, Equitable\u003cint?\u003e\u003e(\r\n    ref MemoryMarshal.GetReference(span)), span.Length);\r\n\r\n// The next code line work because `Equitable\u003cint?\u003e` is IEquatable\u003cEquitable\u003cint?\u003e\u003e\r\nvar i = span.IndexOf(new StructT\u003cint?\u003e(5)); \r\n\r\npublic struct Equitable\u003cT\u003e : IEquatable\u003cEquitable\u003cT\u003e\u003e\r\n{\r\n    public T Value;\r\n    public Equitable(T value) =\u003e Value = value;\r\n    public bool Equals(Equitable\u003cT\u003e value) =\u003e EqualityComparer\u003cT\u003e.Default.Equals(this.Value, value.Value);\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n// Use workaround\r\nvar equatableSpan = MemoryMarshal.CreateSpan(ref Unsafe.As\u003cint?, Equitable\u003cint?\u003e\u003e(\r\n    ref MemoryMarshal.GetReference(span)), span.Length);\r\n\n\n### Risks\n\nNo\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eAlexRadch\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Memory`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-01-19T18:41:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5yAVSO",
                                           "createdAt":  "2024-01-26T21:00:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AlexRadch",
                                           "body":  "I created a language proposal to implement this without copying and pasting.  [Add `where T : struct?` generic type constraint](https://github.com/dotnet/csharplang/discussions/7878).",
                                           "updatedAt":  "2024-01-26T21:00:34Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[API Proposal]: The MemoryMarshal cast must support nullable types",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/99121",
        "createdAt":  "2024-02-29T07:50:47Z",
        "number":  99121,
        "author":  "performanceautofiler",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-05-30T15:25:32Z",
        "body":  "\u003c!-- DATA: {\"RunType\":{\"Repo\":\"dotnetruntime\",\"Branch\":\"refs/heads/main\",\"Arch\":\"ARM64\",\"Os\":\"Ubuntu2204\",\"Queue\":\"AmpereUbuntu\",\"Frequency\":\"Weekly\",\"CoreClr\":true,\"Mono\":false,\"Wasm\":false,\"Maui\":false,\"Configs\":[\"CompilationMode:tiered\",\"RunKind:micro\"]},\"RegressionDate\":\"2024-02-23T22:12:07\",\"IsRegression\":true} --\u003e\r\n\n### Run Information\n\nName | Value\n-- | --\nArchitecture | arm64\nOS | ubuntu 22.04\nQueue | AmpereUbuntu\nBaseline | [d98af689a245bbc983ea71c52e15ff9cdf376ec7](https://github.com/dotnet/runtime/commit/d98af689a245bbc983ea71c52e15ff9cdf376ec7)\nCompare | [7b54246a7bd6b4ea09895b22ba30e45059fbedb4](https://github.com/dotnet/runtime/commit/7b54246a7bd6b4ea09895b22ba30e45059fbedb4)\nDiff | [Diff](https://github.com/dotnet/runtime/compare/d98af689a245bbc983ea71c52e15ff9cdf376ec7...7b54246a7bd6b4ea09895b22ba30e45059fbedb4)\nConfigs | CompilationMode:tiered, RunKind:micro\n\n\n### Regressions in System.Memory.Span\u0026lt;Char\u0026gt;\n\nBenchmark | Baseline | Test | Test/Base | Test Quality | Edge Detector | Baseline IR | Compare IR | IR Ratio\n-- | -- | -- | -- | -- | -- | -- | -- | --\n|\u003cul\u003e\u003cli\u003e[SequenceEqual - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_arm64_ubuntu 22.04/System.Memory.Span(Char).SequenceEqual(Size%3a%20512).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Memory/Span.cs#L52-#L53\u003e)\u003c/li\u003e\u003cli\u003e[📈 - ADX Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACo1UXW/TQBB8R+I/3JttcBPHoZREuCINKbQQFJK8IYQu9jY+dB/u3l0bVxW/nTsnCk0qIb9YvvHM7Nxq11Og2iIIkEa/eCT3JSCQC8t4MYdKkSwjQaGMBNNFKw0TEByyLpDKvGx4CDe6WwItdFdQJo+II8xLZiA3rhphkoTB5u2bICYBReFeoj17Cdp8owK854dgUWsDojMFobDuLCoq349LiuedBdxakDlMbi3l4YI9wJCc9tLoX9m5lWMlb9jaIjVMSf0jGCtRMd6cpqqA4CfJ/pDAMEcvgpf/UzroC5PFTiFYjuqJgGkQlanDZ8KRMlEL2pXSX/mdaBrVhn+tJ3LNJLTheuM2vKmSqmVcT72SBrBCcM82ktlaLeuqVeBZWWuWUz5DJZRH2go/1ytkxSeuVpSzhwZrI5un87YVJpsK0C2BbCb0cGbHyi0I4FJVu7fD+V862cJQUZFzUlADfpfCNEn7J73eSTpYJmfD02TYSzr99N0gORu8TpJhkvgS2gpB0Q04obj+JegmbAx9gpi8isiqPqoQ73co9qP83YIF51Oh+u327xl5Dtpyk6FLXYRPbrLFR3eAdO2c+lFMGitvnF0iA1nweo/4ZjUHHxndN0Di75i7bTXknpmShNo1D3S218RkkytuhcyOM9VbXGfbEI5omOGQBR9d69xfo94dvYSEUkce0xVnJqMb0NFf0MjDO9cEAAA=\u003e)\u003c/li\u003e\u003c/ul\u003e | 58.63 ns | 66.41 ns | 1.13 | 0.01 | True | | |\r\n|\u003cul\u003e\u003cli\u003e[EndsWith - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_arm64_ubuntu 22.04/System.Memory.Span(Char).EndsWith(Size%3a%204).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Memory/Span.cs#L64-#L65\u003e)\u003c/li\u003e\u003cli\u003e[📈 - ADX Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACo1UXW/TMBR9R+I/+M0JZG36AWMVmehKgQFFpa3EA0LIje8ao/hD187WTIjfjp1WZe0klJcoPjnn3OOrezMDZisECcrZJ7/JXQEI5KoSJV+A0STLCOXaKXBdrJQTEugx6wqZyouGh3BjuwUwbruSCXVCHGNeCAe589WIUCSi25dDmhDKUPqX+MBegXVfmITg+YYua+tAdmYgNdadpWHq9aRgeNmZKm6/CVdES3EPIzKM/9VbVGqi1Y3YVMic0Mp+pxMtjSib00xzoD9I9odQJzyd06f/U3rok1B8r5AiR/1AICxI4+rokXCsXdyCdq3t5/JWNh1qw/9op2ojFLThBuM2vJlWumXcQL1WDtAg+GcbyXyjV7VpFXhe1FbkrJyjljogbYUf6jUK/r7Ua1aK+wZrI1v0F20rTLcG0E+/akbzeFgn2m8G4Eqb/dvx4K+8bOmYNOSScOYgLFHUT/uDs17vrH+xSs9HL9JRL+0MBxfnvd6r52k6StNQwlZSMvTjTRhufkq2jRrDkCAhz2Kyrk8qJIflScIof62gAu9jUP/yi/eIvABblS5Dn5pHD26yw8e3gGzjnQZxQhqrYJy9QwGKl/UBCc1qDiEy+m+AJNwx92vqyJ1fURJZ3zyw2UGTkG2uy0qq7DRTvcNttgvhiU64EjL61rfO/y7q/TFISKRsHDBrSuEytgUb/wU0WnkW0AQAAA==\u003e)\u003c/li\u003e\u003c/ul\u003e | 3.42 ns | 5.25 ns | 1.53 | 0.57 | True | | |\r\n|\u003cul\u003e\u003cli\u003e[EndsWith - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_arm64_ubuntu 22.04/System.Memory.Span(Char).EndsWith(Size%3a%20512).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Memory/Span.cs#L64-#L65\u003e)\u003c/li\u003e\u003cli\u003e[📈 - ADX Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACo1UXW/TQBB8R+I/3NvZ4CZO2oAa4Yo0pFAgKCSReEAIXextfOi+tHdu46rqb+fOiUKTSsgvlm88Mzu32vUUmK0QJChnXzyQuxIQyGXFRTEHo0mWEVpop8B1sVKOS6CHrEtkKi8bHsKN7ZbACtuVjKsj4gjzkjvIna9GuCIR3bw5owmhDKV/iffsJVj3jUkInu/porYOZGcKUmPdWRim3o1LhhediSrsD+7KaMHvYUgGvX78r+K8UmOtbvi6Qua4VvYnHWtpuGhOU10A/UWyR0Id9/SCvvyf0kNfuCp2Cslz1E8E3II0ro6eCUfaxS1o19p+Fbey6VEb/mc7UWuuoA03GLfhTbXSLeMG6rVygAbBP9tIZmu9rE2rwLOytjxnYoZa6oC0FX6qV8iLj0KvmOD3DdZGNu/P21aYbAygn3/VDOfhuI613w3ApTa7t8PRX3rZwjFpyAUpmIOwRlE/7Z+e9Hon/fNl+nY4SIe9tDM4S8/TtPc6TYdpGkrYSkqGfsAJw/VvyTZRYxgSJORVTFb1UYVkvz5JGOXvFVTgfQzqP371npHnYCvhMvSpi+jJTbb46BaQrb3TaZyQxioYZ1fIQRWi3iOhWc0hREb/DZCEO+Z+UR2580tKIuubBzbbaxKyybWopMqOM9Vb3GbbEJ7ouBOQ0Q++df6HUe+OQUIiZeOAWSO4y9gGbPwXX9NkbtIEAAA=\u003e)\u003c/li\u003e\u003c/ul\u003e | 31.62 ns | 34.48 ns | 1.09 | 0.16 | False | | |\r\n\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/02_29_2024/refs/heads/main_arm64_ubuntu%2022.04_Regression/System.Memory.Span%28Char%29_1.png\u003e)\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/02_29_2024/refs/heads/main_arm64_ubuntu%2022.04_Regression/System.Memory.Span%28Char%29_2.png\u003e)\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/02_29_2024/refs/heads/main_arm64_ubuntu%2022.04_Regression/System.Memory.Span%28Char%29_3.png\u003e)\n[Test Report](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/02_29_2024/refs/heads/main_arm64_ubuntu%2022.04_Regression/System.Memory.Span%28Char%29.html\u003e)\n\n### Repro\nGeneral Docs link: https://github.com/dotnet/performance/blob/main/docs/benchmarking-workflow-dotnet-runtime.md\n\n```cmd\ngit clone https://github.com/dotnet/performance.git\npython3 .\\performance\\scripts\\benchmarks_ci.py -f net8.0 --filter \u0027System.Memory.Span\u0026lt;Char\u0026gt;*\u0027\n```\n\n\u003cdetails\u003e\n\n\n### Payloads\n\n[Baseline](\u003chttps://helixdi107v0xdeko0k025g8.blob.core.windows.net/helix-job-2115f044-21db-4480-a784-43dc35f3fb54f504aa7f68c4af3b6/a8a9ede1-d462-4eec-8fdb-48de6832be89.zip?sv=2021-08-06\u0026se=2024-03-24T07%3A37%3A42Z\u0026sr=c\u0026sp=rl\u0026sig=bmNvnVKmZVZWpUgC88Jay5cQTEnzF%2BFgfcmBa7BHLto%3D\u003e)\n[Compare](\u003chttps://helixdi107v0xdeko0k025g8.blob.core.windows.net/helix-job-a74ec1d7-d175-4f65-9922-430c7a9a0f3dc7f0e6147ce44c3ad/ebdc95c9-c0d0-403c-a998-2ca32eeba0cb.zip?sv=2021-08-06\u0026se=2024-03-25T08%3A19%3A11Z\u0026sr=c\u0026sp=rl\u0026sig=C0a%2Fb2YqgSKzmJxEHdM6cj7jklPWJSo3uT8SmPzu%2FJ0%3D\u003e)\n### System.Memory.Span\u0026lt;Char\u0026gt;.SequenceEqual(Size: 512)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Memory.Span\u0026lt;Char\u0026gt;.EndsWith(Size: 4)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Memory.Span\u0026lt;Char\u0026gt;.EndsWith(Size: 512)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n\n\n### Docs\n\n[Profiling workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/profiling-workflow-dotnet-runtime.md)\n[Benchmarking workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/benchmarking-workflow-dotnet-runtime.md)\n\n\u003c/details\u003e\n\r\n\r\n---\r\n\r\n\n### Run Information\n\nName | Value\n-- | --\nArchitecture | arm64\nOS | ubuntu 22.04\nQueue | AmpereUbuntu\nBaseline | [d98af689a245bbc983ea71c52e15ff9cdf376ec7](https://github.com/dotnet/runtime/commit/d98af689a245bbc983ea71c52e15ff9cdf376ec7)\nCompare | [7b54246a7bd6b4ea09895b22ba30e45059fbedb4](https://github.com/dotnet/runtime/commit/7b54246a7bd6b4ea09895b22ba30e45059fbedb4)\nDiff | [Diff](https://github.com/dotnet/runtime/compare/d98af689a245bbc983ea71c52e15ff9cdf376ec7...7b54246a7bd6b4ea09895b22ba30e45059fbedb4)\nConfigs | CompilationMode:tiered, RunKind:micro\n\n\n### Regressions in System.Memory.Span\u0026lt;Int32\u0026gt;\n\nBenchmark | Baseline | Test | Test/Base | Test Quality | Edge Detector | Baseline IR | Compare IR | IR Ratio\n-- | -- | -- | -- | -- | -- | -- | -- | --\n|\u003cul\u003e\u003cli\u003e[EndsWith - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_arm64_ubuntu 22.04/System.Memory.Span(Int32).EndsWith(Size%3a%20512).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Memory/Span.cs#L64-#L65\u003e)\u003c/li\u003e\u003cli\u003e[📈 - ADX Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACo1U227TQBB9R+If9m1tcBPHoRciXJGGFAoEhSQSDwihjT2NF+3Fml23doX4dnadKDSphPxi7RyfM3N2POMZMFMhSFDWPPtN7gtAIFcVF/kCSk3SlNBcWwW2j5WyXAI9ZF0hU1nR8hBuTb8Alpu+ZFwdEceYFdxCZl01whUJaH32ikaEMpTuEO7ZKzD2C5Pgc76ly8ZYkL0ZSI1Nb1ky9eZG2WFy2Zuq3HzjtgiW/AFG5HSQhP9KLio10eqWbypklmtlvtOJliUXbTTTOdAfJP1DqOWOntPn/1M66BNX+U4heYb6kYAbkKVtgifCsbZhB9qNNp/FnWyb1IX/0UzVhivowvWJu/BmWumOdj3VfQHAEsE9u0jmG71qyk6G50VjeMbEHLXUHukq/NCskefvhV4zwR9arItskSy6VpjWJaBbANVO5+G8TrRbDsCVLnenw9lfOdnSMlmSS5IzC36PgiROhieDwUnyehWfj07j0TDuJefxRXxx9jKOR3HsS5hKSoZuwAnDzU/J6qBN6B1E5EVI1s1RhWi/P5Ef5a8VVODylKh/ud17Ql6AqYRN0bnOg0c32eLjO0C2cZmGYUTaVD5xeo0cVC6aPeKb1QbeMrp3gMTfMSsYWnLvlpQExjUPTLrXRKTOtKikSo89NVvcpFsTjmi5FZDSd6517o/R7EIvIYEyocdMKbhNWQ0m/Avr8Wbo0wQAAA==\u003e)\u003c/li\u003e\u003c/ul\u003e | 57.88 ns | 64.75 ns | 1.12 | 0.03 | True | | |\r\n|\u003cul\u003e\u003cli\u003e[StartsWith - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_arm64_ubuntu 22.04/System.Memory.Span(Int32).StartsWith(Size%3a%20512).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Memory/Span.cs#L61-#L62\u003e)\u003c/li\u003e\u003cli\u003e[📈 - ADX Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACo1UXW/TQBB8R+I/3JttcBPHSQqNcEUaWmghKCSReEAIXextfOi+tHdu4wr1t3PnRKFJJeQX63Y9M7u33vEUqKkQBEhrXvwh9yUgkIuK8WIOWpEsI0GhrATbxUpaJiA4RF0glXnZ4BBuTbcEWpiuoEweAceYl8xCbl01wiQJg83pIIhJQFG4Q7RHL8HYr1SA13wfLGpjQXSmIBTWnYWm8t21tP30vLOwFK35zmwZLtgDjMiwl0b/is4rOVHylq0rpJYpaX4EEyU04000VQUEP0n2SALLHLwIXv6P6VKfmSx2DMFyVE8IzIDQtg6fEcfKRi1g18p84XeiGVMb/I25lGsmoQ3WC7fBTZVULdv1UPcNADWCe7ahzNZqWetWDc/K2rCc8hkqoXymLfFTvUJWfORqRTl7aHJtaPN03rbC5UYDOgvIZj8PN3ainD0Al0rvTofbv3Q0t7BCk3NSUAveSWGapP2TXu8kPVsmb0bDZNRPOoNhb/D29Ox1koySxJcwlRAU3YITiutfgm7CRtB3EJNXEVnVRxXivYNiv8rfKqjA6WhUv537noHnYCpuM3RdF+GTm2zz4ztAunZK/SgmjZQXzq6QgSx4vc/4YTWBbxndO0Di75iXzqTk3pmUhMYND0y258RkkyteCZkd91Rv8ybbNuGAllkOWfDBjc79M+pd6CkklCbyOaM5sxndgIn+AsndiGjVBAAA\u003e)\u003c/li\u003e\u003c/ul\u003e | 56.57 ns | 64.96 ns | 1.15 | 0.01 | True | | |\r\n|\u003cul\u003e\u003cli\u003e[SequenceEqual - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_arm64_ubuntu 22.04/System.Memory.Span(Int32).SequenceEqual(Size%3a%20512).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Memory/Span.cs#L52-#L53\u003e)\u003c/li\u003e\u003cli\u003e[📈 - ADX Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACo1UXW/aQBB8r9T/cG+2WweMCYmK6qiEkjZtqSjwVlXVYW/wVffh7N0lOIry23tnEA1Eqvxi3Y5ndufWu54C1RZBgDT61SO5LwGBXFrGizlUimQZCQplJJguWmmYgOCQdYlU5mXDQ7jR3RJoobuCMnlEHGFeMgO5cdUIkyQMNmenQUwCisIdoj17Cdp8pwJ8zg/BotYGRGcKQmHdWVRUvr+Wpp9edBZwa0HmMLm1lIcL9gBDMuil0b+6cyvHSt6wtUVqmJL6ZzBWomK8iaaqgOAXyZ5IYJijF8Hr/ykd9JXJYqcQLEf1TMA0iMrU4QvhSJmoBe1a6W/8TjSdasP/oidyzSS04frEbXhTJVVLu57qPgNgheCebSSztVrWVSvDs7LWLKd8hkooj7QVfq5XyIpPXK0oZw8N1kY2T+dtK0w2FaDbAtmM6OHQjpXbEMClqnanwwVYOtnCUFGRC1JQA36ZwjRJ+ye93kn6bpmcDwfJsJ90BmeD0/Q8fZskwyTxJbQVgqIbcEJx/VvQTdgk9A5i8iYiq/qoQrxfotiP8g8LFlyeCtUft4AvyHPQlpsMnesifHaTLT66A6Rrl6kfxaRJ5RNnV8hAFrzeI75ZTeAto3sHSPwd85KiIffMlCTUrnmgs70mJptccStkduyp3uI625pwRMMMhyz46Frnfhv1LvQSEkodeUxXnJmMbkBHfwFt4agq2AQAAA==\u003e)\u003c/li\u003e\u003c/ul\u003e | 108.09 ns | 127.47 ns | 1.18 | 0.01 | True | | |\r\n|\u003cul\u003e\u003cli\u003e[EndsWith - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_arm64_ubuntu 22.04/System.Memory.Span(Int32).EndsWith(Size%3a%204).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Memory/Span.cs#L64-#L65\u003e)\u003c/li\u003e\u003cli\u003e[📈 - ADX Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACo1UXW/TQBB8R+I/3JttcBM3aVo1whVpSKFAUEgi8YAQuvi28aH70t65jSvEb+fOiUKTSsgvlm88Mzu32vUUqK0QJChnX/wmDyUgkOuKCzYHo0mek4hpp8B1sVKOS4gOWddIVVE2PIQ72y2BMtuVlKsj4giLkjsonK9GuCJxtDk/i1ISUZT+Jdmzl2DdFyoheL6NFrV1IDtTkBrrzsJQ9eZWuX7vqjNRzH7jrowX/BGG5Cz5V3BeqbFWd3xdIXVcK/s9GmtpuGhOU80g+kHyPyRy3NNZ9PJ/Sg994ortFJIXqJ8IuAVpXB0/E460S1rQbrX9LO5l06I2/I92otZcQRtuMG7Dm2qlW8YNVN9/QIPgn20ks7Ve1qZV4FlZW15QMUMtdUDaCj/UK+TsvdArKvhjg7WRzXvzthUmGwPox181s3k4rWPtVwNwqc3u7XDyl162cFQackUYdRC2KO5lvf7J6elJ73KZXQwH2bCfdc4vBpdZNnidZcMsCyVsJSVFP96E4vqnpJu4MQwJUvIqIav6qEK63540jPLXCirwPgb1L795z8hzsJVwOfrULH5yky0+ugeka+/UT1LSWAXj/AY5KCbqPRKa1RxCZPTfAEm4Y1FSdOTBryiJrW8e2HyvScmm0KKSKj/OVG9xm29DeKLjTkAevfOt8/+LencMEhIrmwTMGsFdTjdgk7+O2MM30QQAAA==\u003e)\u003c/li\u003e\u003c/ul\u003e | 3.62 ns | 5.11 ns | 1.41 | 0.55 | True | | |\r\n\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/02_29_2024/refs/heads/main_arm64_ubuntu%2022.04_Regression/System.Memory.Span%28Int32%29_1.png\u003e)\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/02_29_2024/refs/heads/main_arm64_ubuntu%2022.04_Regression/System.Memory.Span%28Int32%29_2.png\u003e)\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/02_29_2024/refs/heads/main_arm64_ubuntu%2022.04_Regression/System.Memory.Span%28Int32%29_3.png\u003e)\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/02_29_2024/refs/heads/main_arm64_ubuntu%2022.04_Regression/System.Memory.Span%28Int32%29_4.png\u003e)\n[Test Report](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/02_29_2024/refs/heads/main_arm64_ubuntu%2022.04_Regression/System.Memory.Span%28Int32%29.html\u003e)\n\n### Repro\nGeneral Docs link: https://github.com/dotnet/performance/blob/main/docs/benchmarking-workflow-dotnet-runtime.md\n\n```cmd\ngit clone https://github.com/dotnet/performance.git\npython3 .\\performance\\scripts\\benchmarks_ci.py -f net8.0 --filter \u0027System.Memory.Span\u0026lt;Int32\u0026gt;*\u0027\n```\n\n\u003cdetails\u003e\n\n\n### Payloads\n\n[Baseline](\u003chttps://helixdi107v0xdeko0k025g8.blob.core.windows.net/helix-job-2115f044-21db-4480-a784-43dc35f3fb54f504aa7f68c4af3b6/a8a9ede1-d462-4eec-8fdb-48de6832be89.zip?sv=2021-08-06\u0026se=2024-03-24T07%3A37%3A42Z\u0026sr=c\u0026sp=rl\u0026sig=bmNvnVKmZVZWpUgC88Jay5cQTEnzF%2BFgfcmBa7BHLto%3D\u003e)\n[Compare](\u003chttps://helixdi107v0xdeko0k025g8.blob.core.windows.net/helix-job-a74ec1d7-d175-4f65-9922-430c7a9a0f3dc7f0e6147ce44c3ad/ebdc95c9-c0d0-403c-a998-2ca32eeba0cb.zip?sv=2021-08-06\u0026se=2024-03-25T08%3A19%3A11Z\u0026sr=c\u0026sp=rl\u0026sig=C0a%2Fb2YqgSKzmJxEHdM6cj7jklPWJSo3uT8SmPzu%2FJ0%3D\u003e)\n### System.Memory.Span\u0026lt;Int32\u0026gt;.EndsWith(Size: 512)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Memory.Span\u0026lt;Int32\u0026gt;.StartsWith(Size: 512)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Memory.Span\u0026lt;Int32\u0026gt;.SequenceEqual(Size: 512)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Memory.Span\u0026lt;Int32\u0026gt;.EndsWith(Size: 4)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n\n\n### Docs\n\n[Profiling workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/profiling-workflow-dotnet-runtime.md)\n[Benchmarking workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/benchmarking-workflow-dotnet-runtime.md)\n\n\u003c/details\u003e\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOrjTZdg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc51hJlC",
                                           "createdAt":  "2024-02-29T17:31:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n\u003c!-- DATA: {\"RunType\":{\"Repo\":\"dotnetruntime\",\"Branch\":\"refs/heads/main\",\"Arch\":\"ARM64\",\"Os\":\"Ubuntu2204\",\"Queue\":\"AmpereUbuntu\",\"Frequency\":\"Weekly\",\"CoreClr\":true,\"Mono\":false,\"Wasm\":false,\"Maui\":false,\"Configs\":[\"CompilationMode:tiered\",\"RunKind:micro\"]},\"RegressionDate\":\"2024-02-23T22:12:07\",\"IsRegression\":true} --\u003e\r\n\n### Run Information\n\nName | Value\n-- | --\nArchitecture | arm64\nOS | ubuntu 22.04\nQueue | AmpereUbuntu\nBaseline | [d98af689a245bbc983ea71c52e15ff9cdf376ec7](https://github.com/dotnet/runtime/commit/d98af689a245bbc983ea71c52e15ff9cdf376ec7)\nCompare | [7b54246a7bd6b4ea09895b22ba30e45059fbedb4](https://github.com/dotnet/runtime/commit/7b54246a7bd6b4ea09895b22ba30e45059fbedb4)\nDiff | [Diff](https://github.com/dotnet/runtime/compare/d98af689a245bbc983ea71c52e15ff9cdf376ec7...7b54246a7bd6b4ea09895b22ba30e45059fbedb4)\nConfigs | CompilationMode:tiered, RunKind:micro\n\n\n### Regressions in System.Memory.Span\u0026lt;Char\u0026gt;\n\nBenchmark | Baseline | Test | Test/Base | Test Quality | Edge Detector | Baseline IR | Compare IR | IR Ratio\n-- | -- | -- | -- | -- | -- | -- | -- | --\n|\u003cul\u003e\u003cli\u003e[SequenceEqual - Duration of single invocation](\u003chttps://pvscmdupload.blob.core.windows.net/reports/allTestHistory/refs/heads/main_arm64_ubuntu 22.04/System.Memory.Span(Char).SequenceEqual(Size%3a%20512).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Memory/Span.cs#L52-#L53\u003e)\u003c/li\u003e\u003cli\u003e[📈 - ADX Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACo1UXW/TQBB8R+I/3JttcBPHoZREuCINKbQQFJK8IYQu9jY+dB/u3l0bVxW/nTsnCk0qIb9YvvHM7Nxq11Og2iIIkEa/eCT3JSCQC8t4MYdKkSwjQaGMBNNFKw0TEByyLpDKvGx4CDe6WwItdFdQJo+II8xLZiA3rhphkoTB5u2bICYBReFeoj17Cdp8owK854dgUWsDojMFobDuLCoq349LiuedBdxakDlMbi3l4YI9wJCc9tLoX9m5lWMlb9jaIjVMSf0jGCtRMd6cpqqA4CfJ/pDAMEcvgpf/UzroC5PFTiFYjuqJgGkQlanDZ8KRMlEL2pXSX/mdaBrVhn+tJ3LNJLTheuM2vKmSqmVcT72SBrBCcM82ktlaLeuqVeBZWWuWUz5DJZRH2go/1ytkxSeuVpSzhwZrI5un87YVJpsK0C2BbCb0cGbHyi0I4FJVu7fD+V862cJQUZFzUlADfpfCNEn7J73eSTpYJmfD02TYSzr99N0gORu8TpJhkvgS2gpB0Q04obj+JegmbAx9gpi8isiqPqoQ73co9qP83YIF51Oh+u327xl5Dtpyk6FLXYRPbrLFR3eAdO2c+lFMGitvnF0iA1nweo/4ZjUHHxndN0Di75i7bTXknpmShNo1D3S218RkkytuhcyOM9VbXGfbEI5omOGQBR9d69xfo94dvYSEUkce0xVnJqMb0NFf0MjDO9cEAAA=\u003e)\u003c/li\u003e\u003c/ul\u003e | 58.63 ns | 66.41 ns | 1.13 | 0.01 | True | | |\r\n|\u003cul\u003e\u003cli\u003e[EndsWith - Duration of single invocation](\u003chttps://pvscmdupload.blob.core.windows.net/reports/allTestHistory/refs/heads/main_arm64_ubuntu 22.04/System.Memory.Span(Char).EndsWith(Size%3a%204).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Memory/Span.cs#L64-#L65\u003e)\u003c/li\u003e\u003cli\u003e[📈 - ADX Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACo1UXW/TMBR9R+I/+M0JZG36AWMVmehKgQFFpa3EA0LIje8ao/hD187WTIjfjp1WZe0klJcoPjnn3OOrezMDZisECcrZJ7/JXQEI5KoSJV+A0STLCOXaKXBdrJQTEugx6wqZyouGh3BjuwUwbruSCXVCHGNeCAe589WIUCSi25dDmhDKUPqX+MBegXVfmITg+YYua+tAdmYgNdadpWHq9aRgeNmZKm6/CVdES3EPIzKM/9VbVGqi1Y3YVMic0Mp+pxMtjSib00xzoD9I9odQJzyd06f/U3rok1B8r5AiR/1AICxI4+rokXCsXdyCdq3t5/JWNh1qw/9op2ojFLThBuM2vJlWumXcQL1WDtAg+GcbyXyjV7VpFXhe1FbkrJyjljogbYUf6jUK/r7Ua1aK+wZrI1v0F20rTLcG0E+/akbzeFgn2m8G4Eqb/dvx4K+8bOmYNOSScOYgLFHUT/uDs17vrH+xSs9HL9JRL+0MBxfnvd6r52k6StNQwlZSMvTjTRhufkq2jRrDkCAhz2Kyrk8qJIflScIof62gAu9jUP/yi/eIvABblS5Dn5pHD26yw8e3gGzjnQZxQhqrYJy9QwGKl/UBCc1qDiEy+m+AJNwx92vqyJ1fURJZ3zyw2UGTkG2uy0qq7DRTvcNttgvhiU64EjL61rfO/y7q/TFISKRsHDBrSuEytgUb/wU0WnkW0AQAAA==\u003e)\u003c/li\u003e\u003c/ul\u003e | 3.42 ns | 5.25 ns | 1.53 | 0.57 | True | | |\r\n|\u003cul\u003e\u003cli\u003e[EndsWith - Duration of single invocation](\u003chttps://pvscmdupload.blob.core.windows.net/reports/allTestHistory/refs/heads/main_arm64_ubuntu 22.04/System.Memory.Span(Char).EndsWith(Size%3a%20512).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Memory/Span.cs#L64-#L65\u003e)\u003c/li\u003e\u003cli\u003e[📈 - ADX Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACo1UXW/TQBB8R+I/3NvZ4CZO2oAa4Yo0pFAgKCSReEAIXextfOi+tHdu46rqb+fOiUKTSsgvlm88Mzu32vUUmK0QJChnXzyQuxIQyGXFRTEHo0mWEVpop8B1sVKOS6CHrEtkKi8bHsKN7ZbACtuVjKsj4gjzkjvIna9GuCIR3bw5owmhDKV/iffsJVj3jUkInu/porYOZGcKUmPdWRim3o1LhhediSrsD+7KaMHvYUgGvX78r+K8UmOtbvi6Qua4VvYnHWtpuGhOU10A/UWyR0Id9/SCvvyf0kNfuCp2Cslz1E8E3II0ro6eCUfaxS1o19p+Fbey6VEb/mc7UWuuoA03GLfhTbXSLeMG6rVygAbBP9tIZmu9rE2rwLOytjxnYoZa6oC0FX6qV8iLj0KvmOD3DdZGNu/P21aYbAygn3/VDOfhuI613w3ApTa7t8PRX3rZwjFpyAUpmIOwRlE/7Z+e9Hon/fNl+nY4SIe9tDM4S8/TtPc6TYdpGkrYSkqGfsAJw/VvyTZRYxgSJORVTFb1UYVkvz5JGOXvFVTgfQzqP371npHnYCvhMvSpi+jJTbb46BaQrb3TaZyQxioYZ1fIQRWi3iOhWc0hREb/DZCEO+Z+UR2580tKIuubBzbbaxKyybWopMqOM9Vb3GbbEJ7ouBOQ0Q++df6HUe+OQUIiZeOAWSO4y9gGbPwXX9NkbtIEAAA=\u003e)\u003c/li\u003e\u003c/ul\u003e | 31.62 ns | 34.48 ns | 1.09 | 0.16 | False | | |\r\n\n![graph](\u003chttps://pvscmdupload.blob.core.windows.net/autofilereport/autofilereports/02_29_2024/refs/heads/main_arm64_ubuntu%2022.04_Regression/System.Memory.Span%28Char%29_1.png\u003e)\n![graph](\u003chttps://pvscmdupload.blob.core.windows.net/autofilereport/autofilereports/02_29_2024/refs/heads/main_arm64_ubuntu%2022.04_Regression/System.Memory.Span%28Char%29_2.png\u003e)\n![graph](\u003chttps://pvscmdupload.blob.core.windows.net/autofilereport/autofilereports/02_29_2024/refs/heads/main_arm64_ubuntu%2022.04_Regression/System.Memory.Span%28Char%29_3.png\u003e)\n[Test Report](\u003chttps://pvscmdupload.blob.core.windows.net/autofilereport/autofilereports/02_29_2024/refs/heads/main_arm64_ubuntu%2022.04_Regression/System.Memory.Span%28Char%29.html\u003e)\n\n### Repro\nGeneral Docs link: https://github.com/dotnet/performance/blob/main/docs/benchmarking-workflow-dotnet-runtime.md\n\n```cmd\ngit clone https://github.com/dotnet/performance.git\npython3 .\\performance\\scripts\\benchmarks_ci.py -f net8.0 --filter \u0027System.Memory.Span\u0026lt;Char\u0026gt;*\u0027\n```\n\n\u003cdetails\u003e\n\n\n### Payloads\n\n[Baseline](\u003chttps://helixdi107v0xdeko0k025g8.blob.core.windows.net/helix-job-2115f044-21db-4480-a784-43dc35f3fb54f504aa7f68c4af3b6/a8a9ede1-d462-4eec-8fdb-48de6832be89.zip?sv=2021-08-06\u0026se=2024-03-24T07%3A37%3A42Z\u0026sr=c\u0026sp=rl\u0026sig=bmNvnVKmZVZWpUgC88Jay5cQTEnzF%2BFgfcmBa7BHLto%3D\u003e)\n[Compare](\u003chttps://helixdi107v0xdeko0k025g8.blob.core.windows.net/helix-job-a74ec1d7-d175-4f65-9922-430c7a9a0f3dc7f0e6147ce44c3ad/ebdc95c9-c0d0-403c-a998-2ca32eeba0cb.zip?sv=2021-08-06\u0026se=2024-03-25T08%3A19%3A11Z\u0026sr=c\u0026sp=rl\u0026sig=C0a%2Fb2YqgSKzmJxEHdM6cj7jklPWJSo3uT8SmPzu%2FJ0%3D\u003e)\n### System.Memory.Span\u0026lt;Char\u0026gt;.SequenceEqual(Size: 512)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Memory.Span\u0026lt;Char\u0026gt;.EndsWith(Size: 4)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Memory.Span\u0026lt;Char\u0026gt;.EndsWith(Size: 512)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n\n\n### Docs\n\n[Profiling workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/profiling-workflow-dotnet-runtime.md)\n[Benchmarking workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/benchmarking-workflow-dotnet-runtime.md)\n\n\u003c/details\u003e\n\r\n\r\n---\r\n\r\n\n### Run Information\n\nName | Value\n-- | --\nArchitecture | arm64\nOS | ubuntu 22.04\nQueue | AmpereUbuntu\nBaseline | [d98af689a245bbc983ea71c52e15ff9cdf376ec7](https://github.com/dotnet/runtime/commit/d98af689a245bbc983ea71c52e15ff9cdf376ec7)\nCompare | [7b54246a7bd6b4ea09895b22ba30e45059fbedb4](https://github.com/dotnet/runtime/commit/7b54246a7bd6b4ea09895b22ba30e45059fbedb4)\nDiff | [Diff](https://github.com/dotnet/runtime/compare/d98af689a245bbc983ea71c52e15ff9cdf376ec7...7b54246a7bd6b4ea09895b22ba30e45059fbedb4)\nConfigs | CompilationMode:tiered, RunKind:micro\n\n\n### Regressions in System.Memory.Span\u0026lt;Int32\u0026gt;\n\nBenchmark | Baseline | Test | Test/Base | Test Quality | Edge Detector | Baseline IR | Compare IR | IR Ratio\n-- | -- | -- | -- | -- | -- | -- | -- | --\n|\u003cul\u003e\u003cli\u003e[EndsWith - Duration of single invocation](\u003chttps://pvscmdupload.blob.core.windows.net/reports/allTestHistory/refs/heads/main_arm64_ubuntu 22.04/System.Memory.Span(Int32).EndsWith(Size%3a%20512).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Memory/Span.cs#L64-#L65\u003e)\u003c/li\u003e\u003cli\u003e[📈 - ADX Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACo1U227TQBB9R+If9m1tcBPHoRciXJGGFAoEhSQSDwihjT2NF+3Fml23doX4dnadKDSphPxi7RyfM3N2POMZMFMhSFDWPPtN7gtAIFcVF/kCSk3SlNBcWwW2j5WyXAI9ZF0hU1nR8hBuTb8Alpu+ZFwdEceYFdxCZl01whUJaH32ikaEMpTuEO7ZKzD2C5Pgc76ly8ZYkL0ZSI1Nb1ky9eZG2WFy2Zuq3HzjtgiW/AFG5HSQhP9KLio10eqWbypklmtlvtOJliUXbTTTOdAfJP1DqOWOntPn/1M66BNX+U4heYb6kYAbkKVtgifCsbZhB9qNNp/FnWyb1IX/0UzVhivowvWJu/BmWumOdj3VfQHAEsE9u0jmG71qyk6G50VjeMbEHLXUHukq/NCskefvhV4zwR9arItskSy6VpjWJaBbANVO5+G8TrRbDsCVLnenw9lfOdnSMlmSS5IzC36PgiROhieDwUnyehWfj07j0TDuJefxRXxx9jKOR3HsS5hKSoZuwAnDzU/J6qBN6B1E5EVI1s1RhWi/P5Ef5a8VVODylKh/ud17Ql6AqYRN0bnOg0c32eLjO0C2cZmGYUTaVD5xeo0cVC6aPeKb1QbeMrp3gMTfMSsYWnLvlpQExjUPTLrXRKTOtKikSo89NVvcpFsTjmi5FZDSd6517o/R7EIvIYEyocdMKbhNWQ0m/Avr8Wbo0wQAAA==\u003e)\u003c/li\u003e\u003c/ul\u003e | 57.88 ns | 64.75 ns | 1.12 | 0.03 | True | | |\r\n|\u003cul\u003e\u003cli\u003e[StartsWith - Duration of single invocation](\u003chttps://pvscmdupload.blob.core.windows.net/reports/allTestHistory/refs/heads/main_arm64_ubuntu 22.04/System.Memory.Span(Int32).StartsWith(Size%3a%20512).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Memory/Span.cs#L61-#L62\u003e)\u003c/li\u003e\u003cli\u003e[📈 - ADX Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACo1UXW/TQBB8R+I/3JttcBPHSQqNcEUaWmghKCSReEAIXextfOi+tHdu4wr1t3PnRKFJJeQX63Y9M7u33vEUqKkQBEhrXvwh9yUgkIuK8WIOWpEsI0GhrATbxUpaJiA4RF0glXnZ4BBuTbcEWpiuoEweAceYl8xCbl01wiQJg83pIIhJQFG4Q7RHL8HYr1SA13wfLGpjQXSmIBTWnYWm8t21tP30vLOwFK35zmwZLtgDjMiwl0b/is4rOVHylq0rpJYpaX4EEyU04000VQUEP0n2SALLHLwIXv6P6VKfmSx2DMFyVE8IzIDQtg6fEcfKRi1g18p84XeiGVMb/I25lGsmoQ3WC7fBTZVULdv1UPcNADWCe7ahzNZqWetWDc/K2rCc8hkqoXymLfFTvUJWfORqRTl7aHJtaPN03rbC5UYDOgvIZj8PN3ainD0Al0rvTofbv3Q0t7BCk3NSUAveSWGapP2TXu8kPVsmb0bDZNRPOoNhb/D29Ox1koySxJcwlRAU3YITiutfgm7CRtB3EJNXEVnVRxXivYNiv8rfKqjA6WhUv537noHnYCpuM3RdF+GTm2zz4ztAunZK/SgmjZQXzq6QgSx4vc/4YTWBbxndO0Di75iXzqTk3pmUhMYND0y258RkkyteCZkd91Rv8ybbNuGAllkOWfDBjc79M+pd6CkklCbyOaM5sxndgIn+AsndiGjVBAAA\u003e)\u003c/li\u003e\u003c/ul\u003e | 56.57 ns | 64.96 ns | 1.15 | 0.01 | True | | |\r\n|\u003cul\u003e\u003cli\u003e[SequenceEqual - Duration of single invocation](\u003chttps://pvscmdupload.blob.core.windows.net/reports/allTestHistory/refs/heads/main_arm64_ubuntu 22.04/System.Memory.Span(Int32).SequenceEqual(Size%3a%20512).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Memory/Span.cs#L52-#L53\u003e)\u003c/li\u003e\u003cli\u003e[📈 - ADX Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACo1UXW/aQBB8r9T/cG+2WweMCYmK6qiEkjZtqSjwVlXVYW/wVffh7N0lOIry23tnEA1Eqvxi3Y5ndufWu54C1RZBgDT61SO5LwGBXFrGizlUimQZCQplJJguWmmYgOCQdYlU5mXDQ7jR3RJoobuCMnlEHGFeMgO5cdUIkyQMNmenQUwCisIdoj17Cdp8pwJ8zg/BotYGRGcKQmHdWVRUvr+Wpp9edBZwa0HmMLm1lIcL9gBDMuil0b+6cyvHSt6wtUVqmJL6ZzBWomK8iaaqgOAXyZ5IYJijF8Hr/ykd9JXJYqcQLEf1TMA0iMrU4QvhSJmoBe1a6W/8TjSdasP/oidyzSS04frEbXhTJVVLu57qPgNgheCebSSztVrWVSvDs7LWLKd8hkooj7QVfq5XyIpPXK0oZw8N1kY2T+dtK0w2FaDbAtmM6OHQjpXbEMClqnanwwVYOtnCUFGRC1JQA36ZwjRJ+ye93kn6bpmcDwfJsJ90BmeD0/Q8fZskwyTxJbQVgqIbcEJx/VvQTdgk9A5i8iYiq/qoQrxfotiP8g8LFlyeCtUft4AvyHPQlpsMnesifHaTLT66A6Rrl6kfxaRJ5RNnV8hAFrzeI75ZTeAto3sHSPwd85KiIffMlCTUrnmgs70mJptccStkduyp3uI625pwRMMMhyz46Frnfhv1LvQSEkodeUxXnJmMbkBHfwFt4agq2AQAAA==\u003e)\u003c/li\u003e\u003c/ul\u003e | 108.09 ns | 127.47 ns | 1.18 | 0.01 | True | | |\r\n|\u003cul\u003e\u003cli\u003e[EndsWith - Duration of single invocation](\u003chttps://pvscmdupload.blob.core.windows.net/reports/allTestHistory/refs/heads/main_arm64_ubuntu 22.04/System.Memory.Span(Int32).EndsWith(Size%3a%204).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Memory/Span.cs#L64-#L65\u003e)\u003c/li\u003e\u003cli\u003e[📈 - ADX Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACo1UXW/TQBB8R+I/3JttcBM3aVo1whVpSKFAUEgi8YAQuvi28aH70t65jSvEb+fOiUKTSsgvlm88Mzu32vUUqK0QJChnX/wmDyUgkOuKCzYHo0mek4hpp8B1sVKOS4gOWddIVVE2PIQ72y2BMtuVlKsj4giLkjsonK9GuCJxtDk/i1ISUZT+Jdmzl2DdFyoheL6NFrV1IDtTkBrrzsJQ9eZWuX7vqjNRzH7jrowX/BGG5Cz5V3BeqbFWd3xdIXVcK/s9GmtpuGhOU80g+kHyPyRy3NNZ9PJ/Sg994ortFJIXqJ8IuAVpXB0/E460S1rQbrX9LO5l06I2/I92otZcQRtuMG7Dm2qlW8YNVN9/QIPgn20ks7Ve1qZV4FlZW15QMUMtdUDaCj/UK+TsvdArKvhjg7WRzXvzthUmGwPox181s3k4rWPtVwNwqc3u7XDyl162cFQackUYdRC2KO5lvf7J6elJ73KZXQwH2bCfdc4vBpdZNnidZcMsCyVsJSVFP96E4vqnpJu4MQwJUvIqIav6qEK63540jPLXCirwPgb1L795z8hzsJVwOfrULH5yky0+ugeka+/UT1LSWAXj/AY5KCbqPRKa1RxCZPTfAEm4Y1FSdOTBryiJrW8e2HyvScmm0KKSKj/OVG9xm29DeKLjTkAevfOt8/+LencMEhIrmwTMGsFdTjdgk7+O2MM30QQAAA==\u003e)\u003c/li\u003e\u003c/ul\u003e | 3.62 ns | 5.11 ns | 1.41 | 0.55 | True | | |\r\n\n![graph](\u003chttps://pvscmdupload.blob.core.windows.net/autofilereport/autofilereports/02_29_2024/refs/heads/main_arm64_ubuntu%2022.04_Regression/System.Memory.Span%28Int32%29_1.png\u003e)\n![graph](\u003chttps://pvscmdupload.blob.core.windows.net/autofilereport/autofilereports/02_29_2024/refs/heads/main_arm64_ubuntu%2022.04_Regression/System.Memory.Span%28Int32%29_2.png\u003e)\n![graph](\u003chttps://pvscmdupload.blob.core.windows.net/autofilereport/autofilereports/02_29_2024/refs/heads/main_arm64_ubuntu%2022.04_Regression/System.Memory.Span%28Int32%29_3.png\u003e)\n![graph](\u003chttps://pvscmdupload.blob.core.windows.net/autofilereport/autofilereports/02_29_2024/refs/heads/main_arm64_ubuntu%2022.04_Regression/System.Memory.Span%28Int32%29_4.png\u003e)\n[Test Report](\u003chttps://pvscmdupload.blob.core.windows.net/autofilereport/autofilereports/02_29_2024/refs/heads/main_arm64_ubuntu%2022.04_Regression/System.Memory.Span%28Int32%29.html\u003e)\n\n### Repro\nGeneral Docs link: https://github.com/dotnet/performance/blob/main/docs/benchmarking-workflow-dotnet-runtime.md\n\n```cmd\ngit clone https://github.com/dotnet/performance.git\npython3 .\\performance\\scripts\\benchmarks_ci.py -f net8.0 --filter \u0027System.Memory.Span\u0026lt;Int32\u0026gt;*\u0027\n```\n\n\u003cdetails\u003e\n\n\n### Payloads\n\n[Baseline](\u003chttps://helixdi107v0xdeko0k025g8.blob.core.windows.net/helix-job-2115f044-21db-4480-a784-43dc35f3fb54f504aa7f68c4af3b6/a8a9ede1-d462-4eec-8fdb-48de6832be89.zip?sv=2021-08-06\u0026se=2024-03-24T07%3A37%3A42Z\u0026sr=c\u0026sp=rl\u0026sig=bmNvnVKmZVZWpUgC88Jay5cQTEnzF%2BFgfcmBa7BHLto%3D\u003e)\n[Compare](\u003chttps://helixdi107v0xdeko0k025g8.blob.core.windows.net/helix-job-a74ec1d7-d175-4f65-9922-430c7a9a0f3dc7f0e6147ce44c3ad/ebdc95c9-c0d0-403c-a998-2ca32eeba0cb.zip?sv=2021-08-06\u0026se=2024-03-25T08%3A19%3A11Z\u0026sr=c\u0026sp=rl\u0026sig=C0a%2Fb2YqgSKzmJxEHdM6cj7jklPWJSo3uT8SmPzu%2FJ0%3D\u003e)\n### System.Memory.Span\u0026lt;Int32\u0026gt;.EndsWith(Size: 512)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Memory.Span\u0026lt;Int32\u0026gt;.StartsWith(Size: 512)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Memory.Span\u0026lt;Int32\u0026gt;.SequenceEqual(Size: 512)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Memory.Span\u0026lt;Int32\u0026gt;.EndsWith(Size: 4)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n\n\n### Docs\n\n[Profiling workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/profiling-workflow-dotnet-runtime.md)\n[Benchmarking workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/benchmarking-workflow-dotnet-runtime.md)\n\n\u003c/details\u003e\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eperformanceautofiler[bot]\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`arch-arm64`, `area-System.Memory`, `os-linux`, `untriaged`, `runtime-coreclr`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-02-29T17:31:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51hJ6Q",
                                           "createdAt":  "2024-02-29T17:31:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "Looks to be https://github.com/dotnet/runtime/pull/98700 ",
                                           "updatedAt":  "2024-02-29T17:31:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GRiht",
                                           "createdAt":  "2024-07-26T13:15:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODrsx1A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "EgorBot",
                                                                               "createdAt":  "2024-07-26T13:16:28Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "@EgorBot -arm64 -commit 973ceee vs previous --disasm\r\n```cs\r\nusing BenchmarkDotNet.Attributes;\r\n\r\n[GenericTypeArguments(typeof(int))]\r\npublic class Span\u003cT\u003e\r\n    where T : struct, IComparable\u003cT\u003e, IEquatable\u003cT\u003e\r\n{\r\n    [Params(4,512)]\r\n    public int Size;\r\n\r\n    private T[] _array, _same, _emptyWithSingleValue;\r\n    private T[] _fourValues, _fiveValues;\r\n    private T _notDefaultValue;\r\n\r\n    [GlobalSetup]\r\n    public void Setup()\r\n    {\r\n        T[] array = new T[Size * 2];\r\n        _array = array.Take(Size).ToArray();\r\n        _same = _array.ToArray();\r\n    }\r\n\r\n    [Benchmark]\r\n    public bool SequenceEqual() =\u003e new System.Span\u003cT\u003e(_array)\r\n        .SequenceEqual(new ReadOnlySpan\u003cT\u003e(_same));\r\n\r\n    [Benchmark]\r\n    public bool StartsWith() =\u003e new System.Span\u003cT\u003e(_array)\r\n        .StartsWith(new ReadOnlySpan\u003cT\u003e(_same).Slice(start: 0, length: Size / 2));\r\n\r\n    [Benchmark]\r\n    public bool EndsWith() =\u003e new System.Span\u003cT\u003e(_array)\r\n        .EndsWith(new ReadOnlySpan\u003cT\u003e(_same).Slice(start: Size / 2));\r\n}\r\n\r\n```",
                                           "updatedAt":  "2024-07-26T14:22:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GRx6M",
                                           "createdAt":  "2024-07-26T13:48:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBot",
                                           "body":  "\u003cdetails\u003e\u003csummary\u003eBenchmark results on Arm64\u003c/summary\u003e\n\n```\nBenchmarkDotNet v0.13.12, Ubuntu 22.04.4 LTS (Jammy Jellyfish)\nUnknown processor\n  Job-VJRAQH : .NET 9.0.0 (42.42.42.42424), Arm64 RyuJIT AdvSIMD\n  Job-EZBVNO : .NET 9.0.0 (42.42.42.42424), Arm64 RyuJIT AdvSIMD\n```\n| Method        | Toolchain               | Size | Mean       | Error     | Ratio | Code Size |\n|-------------- |------------------------ |----- |-----------:|----------:|------:|----------:|\n| **SequenceEqual** | **Main** | **4**    |   **3.516 ns** | **0.0007 ns** |  **1.00** |         **-** |\n| SequenceEqual | PR | 4    |   3.547 ns | 0.0008 ns |  1.01 |     484 B |\n|               |                         |      |            |           |       |           |\n| StartsWith    | Main | 4    |   3.536 ns | 0.0003 ns |  1.00 |     512 B |\n| StartsWith    | PR | 4    |   3.436 ns | 0.0006 ns |  0.97 |     512 B |\n|               |                         |      |            |           |       |           |\n| EndsWith      | Main | 4    |   5.264 ns | 0.0009 ns |  1.00 |     512 B |\n| EndsWith      | PR | 4    |   5.370 ns | 0.0032 ns |  1.02 |     512 B |\n|               |                         |      |            |           |       |           |\n| **SequenceEqual** | **Main** | **512**  | **127.736 ns** | **0.0428 ns** |  **1.00** |     **432 B** |\n| SequenceEqual | PR | 512  | 109.769 ns | 0.0121 ns |  0.86 |     444 B |\n|               |                         |      |            |           |       |           |\n| StartsWith    | Main | 512  |  66.018 ns | 0.0099 ns |  1.00 |     472 B |\n| StartsWith    | PR | 512  |  56.800 ns | 0.0048 ns |  0.86 |     484 B |\n|               |                         |      |            |           |       |           |\n| EndsWith      | Main | 512  |  67.015 ns | 0.0287 ns |  1.00 |     500 B |\n| EndsWith      | PR | 512  |  58.790 ns | 0.0198 ns |  0.88 |     512 B |\n\n\n[BDN_Artifacts.zip](https://telegafiles.blob.core.windows.net/telega/BDN_Artifacts_b0e01449.zip)\n\n\u003c/details\u003e\n",
                                           "updatedAt":  "2024-07-26T14:22:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GRzKN",
                                           "createdAt":  "2024-07-26T13:50:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODrtEEg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "EgorBot",
                                                                               "createdAt":  "2024-07-26T13:50:28Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "@EgorBot -arm64 -commit 973ceee vs previous --disasm --envars \"DOTNET_JitDisasm:SequenceEqual\"\r\n```cs\r\nusing BenchmarkDotNet.Attributes;\r\n\r\n[GenericTypeArguments(typeof(int))]\r\npublic class Span\u003cT\u003e\r\n    where T : struct, IComparable\u003cT\u003e, IEquatable\u003cT\u003e\r\n{\r\n    [Params(512)]\r\n    public int Size;\r\n\r\n    private T[] _array, _same, _emptyWithSingleValue;\r\n    private T[] _fourValues, _fiveValues;\r\n    private T _notDefaultValue;\r\n\r\n    [GlobalSetup]\r\n    public void Setup()\r\n    {\r\n        T[] array = new T[Size * 2];\r\n        _array = array.Take(Size).ToArray();\r\n        _same = _array.ToArray();\r\n    }\r\n\r\n    [Benchmark]\r\n    public bool SequenceEqual() =\u003e new System.Span\u003cT\u003e(_array)\r\n        .SequenceEqual(new ReadOnlySpan\u003cT\u003e(_same));\r\n}\r\n\r\n```",
                                           "updatedAt":  "2024-07-26T14:22:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GSDJp",
                                           "createdAt":  "2024-07-26T14:21:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBot",
                                           "body":  "\u003cdetails\u003e\u003csummary\u003e❌ Benchmark failed on Arm64\u003c/summary\u003e\n\n```\npublishing results failed\n\n```\n\n\u003c/details\u003e",
                                           "updatedAt":  "2024-07-26T14:22:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GSDr2",
                                           "createdAt":  "2024-07-26T14:22:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODrtUrw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "EgorBot",
                                                                               "createdAt":  "2024-07-26T14:22:28Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "@EgorBot -arm64 -commit 973ceee vs previous --disasm --envvars \"DOTNET_JitDisasm:SequenceEqual\"\r\n```cs\r\nusing BenchmarkDotNet.Attributes;\r\n\r\n[GenericTypeArguments(typeof(int))]\r\npublic class Span\u003cT\u003e\r\n    where T : struct, IComparable\u003cT\u003e, IEquatable\u003cT\u003e\r\n{\r\n    [Params(512)]\r\n    public int Size;\r\n\r\n    private T[] _array, _same, _emptyWithSingleValue;\r\n    private T[] _fourValues, _fiveValues;\r\n    private T _notDefaultValue;\r\n\r\n    [GlobalSetup]\r\n    public void Setup()\r\n    {\r\n        T[] array = new T[Size * 2];\r\n        _array = array.Take(Size).ToArray();\r\n        _same = _array.ToArray();\r\n    }\r\n\r\n    [Benchmark]\r\n    public bool SequenceEqual() =\u003e new System.Span\u003cT\u003e(_array)\r\n        .SequenceEqual(new ReadOnlySpan\u003cT\u003e(_same));\r\n}\r\n\r\n```",
                                           "updatedAt":  "2024-07-26T14:22:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GSQr2",
                                           "createdAt":  "2024-07-26T14:50:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBot",
                                           "body":  "\u003cdetails\u003e\u003csummary\u003eBenchmark results on Arm64\u003c/summary\u003e\n\n```\nBenchmarkDotNet v0.13.12, Ubuntu 22.04.4 LTS (Jammy Jellyfish)\nUnknown processor\n  Job-HMJFUN : .NET 9.0.0 (42.42.42.42424), Arm64 RyuJIT AdvSIMD\n  Job-IWZNQY : .NET 9.0.0 (42.42.42.42424), Arm64 RyuJIT AdvSIMD\nEnvironmentVariables=DOTNET_JitDisasm=SequenceEqual\n```\n| Method        | Toolchain               | Size | Mean     | Error   | Ratio | Code Size |\n|-------------- |------------------------ |----- |---------:|--------:|------:|----------:|\n| SequenceEqual | Main | 512  | 127.5 ns | 0.02 ns |  1.00 |      72 B |\n| SequenceEqual | PR | 512  | 109.2 ns | 0.00 ns |  0.86 |     444 B |\n\n\n[BDN_Artifacts.zip](https://telegafiles.blob.core.windows.net/telega/BDN_Artifacts_8c83f45f.zip)\n\n\u003c/details\u003e\n",
                                           "updatedAt":  "2024-07-26T14:50:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6G656J",
                                           "createdAt":  "2024-08-01T17:27:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "It turns out to be tail-call + special intrinsic problem, we have an issue for it somewhere, I\u0027ll take a look in 10.0",
                                           "updatedAt":  "2024-08-01T17:27:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6uNNl2",
                                           "createdAt":  "2025-05-30T15:25:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "Moving to future, the change requires a bit of efforts",
                                           "updatedAt":  "2025-05-30T15:25:30Z"
                                       }
                                   ],
                         "totalCount":  10
                     },
        "title":  "[Perf] Linux/arm64: 7 Regressions on 2/23/2024 10:12:07 PM",
        "labels":  [
                       "arch-arm64",
                       "area-System.Memory",
                       "os-linux",
                       "tenet-performance",
                       "tenet-performance-benchmarks",
                       "runtime-coreclr",
                       "Priority:2"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/99186",
        "createdAt":  "2024-03-02T08:58:25Z",
        "number":  99186,
        "author":  "neon-sunset",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-19T09:06:56Z",
        "body":  "### Background and motivation\r\n\r\nGiven copy unrolling improvements, using `span.CopyTo(dest)` should outperform manual copy with a loop in almost every situation. It may be desirable to have a performance analyzer rule to flag such use cases and suggest an auto-fixer to address them.\r\n\r\nExample pattern spotted in https://github.com/dotnet/runtime/blob/2ab51c6ef3fb24a625c1f4729f9b2e626a0f141b/src/libraries/System.Private.CoreLib/src/System/IO/StreamWriter.cs#L405-L413\r\n\r\n### API Usage\r\n\r\n```csharp\r\nvar src = Enumerable\r\n    .Range(0, 16)\r\n    .Select(num =\u003e num.ToString())\r\n    .ToArray()\r\n    .AsSpan()\r\nvar dst = new string[16];\r\n\r\n// Flagged with a rule \"use span.CopyTo for copying elements\"\r\nfor (var i = 0; i \u003c src.Length; i++)\r\n{\r\n    dst[i] = src[i];\r\n}\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nN/A\r\n\r\n### Risks\r\n\r\nShould be none (right? :) )",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOe0X1BQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc51tThj",
                                           "createdAt":  "2024-03-02T14:31:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "The only potential problem here that `CopyTo` relaxes atomicity guarantees, so you wrote a code that atomically (per our memory model) writes/copies 2-byte elements, now you\u0027re suggesting to replace it with CopyTo that might produce torn values in a multi-thread environment. \r\n\r\nThis problem is one of the reason we don\u0027t invest a lot into loop autovectorization in JIT",
                                           "updatedAt":  "2024-03-02T14:32:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51tTpO",
                                           "createdAt":  "2024-03-02T14:33:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "neon-sunset",
                                           "body":  "This could possibly have heuristics like copying elements below or equal to pointer size will appear with greater or the same degree of atomicity. So no kicking in for structs that could be torn - it will cover most common case like assigning object references, integers, etc. (yes, 32bit systems, but there are tons of bespoke copy loops for integers, chars as linked, and more)",
                                           "updatedAt":  "2024-03-02T14:34:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51tV6_",
                                           "createdAt":  "2024-03-02T14:49:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "\u003e This could possibly have heuristics like copying elements below or equal to pointer size will appear with greater or the same degree of atomicity. So no kicking in for structs that could be torn - it will cover most common case like assigning object references, integers, etc. (yes, 32bit systems, but there are tons of bespoke copy loops for integers, chars as linked, and more)\r\n\r\n`CopyTo` doesn\u0027t provide any atomicity guarantees, on ARM64 it should be atomic for pointer accesses at pointer aligned locations but on X64 it\u0027s not guaranteed.",
                                           "updatedAt":  "2024-03-02T14:49:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51tWNd",
                                           "createdAt":  "2024-03-02T14:54:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "neon-sunset",
                                           "body":  "\u003e`CopyTo` doesn\u0027t provide any atomicity guarantees, on ARM64 it should be atomic for pointer accesses at pointer aligned locations but on X64 it\u0027s not guaranteed.\r\n\r\nRight, and spans don\u0027t provide alignment guarantees for these either (if they did, then there would be atomicity guarantees).\r\n\r\nSo, the only element types left are `byte` and `object`.",
                                           "updatedAt":  "2024-03-02T14:54:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51tgUs",
                                           "createdAt":  "2024-03-02T17:48:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "I\u0027m now curious that: does Span.CopyTo guarantee proper element-wise access for properly aligned spans?",
                                           "updatedAt":  "2024-03-02T17:48:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51tgeL",
                                           "createdAt":  "2024-03-02T17:51:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\r\n\r\nGiven copy unrolling improvements, using `span.CopyTo(dest)` should outperform manual copy with a loop in almost every situation. It may be desirable to have a performance analyzer rule to flag such use cases and suggest an auto-fixer to address them.\r\n\r\nExample pattern spotted in https://github.com/dotnet/runtime/blob/2ab51c6ef3fb24a625c1f4729f9b2e626a0f141b/src/libraries/System.Private.CoreLib/src/System/IO/StreamWriter.cs#L405-L413\r\n\r\n### API Usage\r\n\r\n```csharp\r\nvar src = Enumerable\r\n    .Range(0, 16)\r\n    .Select(num =\u003e num.ToString())\r\n    .ToArray()\r\n    .AsSpan()\r\nvar dst = new string[16];\r\n\r\n// Flagged with a rule \"use span.CopyTo for copying elements\"\r\nfor (var i = 0; i \u003c src.Length; i++)\r\n{\r\n    dst[i] = src[i];\r\n}\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nN/A\r\n\r\n### Risks\r\n\r\nShould be none (right? :) )\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eneon-sunset\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Memory`, `untriaged`, `code-analyzer`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-03-02T17:51:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51tgu7",
                                           "createdAt":  "2024-03-02T17:56:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "\u003e I\u0027m now curious that: does Span.CopyTo guarantee proper element-wise access for properly aligned spans?\r\n\r\nWith the current implementation it does not",
                                           "updatedAt":  "2024-03-02T17:56:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51tg5W",
                                           "createdAt":  "2024-03-02T17:59:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "So overall suggestions like these are probably nice to have! (poor man\u0027s loop-auto-vectorization) but the user should be aware of risks ",
                                           "updatedAt":  "2024-03-02T17:59:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57RfUF",
                                           "createdAt":  "2024-04-21T20:02:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "neon-sunset",
                                           "body":  "Thanks for the feedback.\r\n\r\nPerhaps this could be a warning for loops where the analyzer sees that atomicity is preserved (bytes and objects) while for other cases it might be a suggestion, further relying on whether the buffer is declared locally and is not observed before the copy is done?\r\n\r\nThis seems like a fairly widespread mistake to copy the elements manually, and if the users case about atomicity, it is likely they already know which option to go with.",
                                           "updatedAt":  "2024-04-21T20:02:30Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "[API Proposal]: Analyzer - replace copy loop with span.CopyTo(destination)",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory",
                       "code-analyzer"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/101309",
        "createdAt":  "2024-04-19T19:52:29Z",
        "number":  101309,
        "author":  "kwi-dk",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-19T16:14:13Z",
        "body":  "### Background and motivation\n\n`ArrayBufferWriter` is a handy way to build up a `Span`, except `WrittenSpan` returns `ReadOnlySpan` for no obvious reason.\r\n\r\n```csharp\r\nvar abw = new ArrayBufferWriter\u003cint\u003e();\r\n\r\n// Write 4 items into the ArrayBufferWriter.\r\nvar span = abw.GetSpan(4)[..4];\r\nnew[] { 7, 4, 2, 1 }.CopyTo(span);\r\nabw.Advance(4);\r\n\r\nvar writtenSpan = abw.WrittenSpan;\r\n//writtenSpan.Sort(); // not allowed\r\nspan.Sort(); // allowed and equivalent\r\nAssert.That(span == writtenSpan);\r\nAssert.That(writtenSpan.SequenceEqual(new[] { 1, 2, 4, 7 }));\r\n```\r\n\r\nIn practice, a `Span` version of `WrittenSpan` can still be obtained, it\u0027s just awkward and relies on implementation details:\r\n\r\n```csharp\r\nstatic Span\u003cT\u003e GetWrittenSpan\u003cT\u003e(ArrayBufferWriter\u003cT\u003e abw)\r\n{\r\n    var nBytes = abw.WrittenCount;\r\n    abw.ResetWrittenCount();\r\n    var writtenSpan = abw.GetSpan(nBytes)[..nBytes];\r\n    abw.Advance(nBytes);\r\n    return writtenSpan;\r\n}\r\n```\r\n\r\nThis issue applies equally to the `WrittenMemory` property, which also returns `ReadOnlyMemory`.\n\n### API Proposal\n\nSince changing the declared type of `WrittenSpan` would break compatibility, a new member would presumably have to be added. Not sure if there\u0027s a naming convention for such a member.\r\n\r\n```csharp\r\nnamespace System.Buffers\r\n\r\npublic sealed class ArrayBufferWriter\u003cT\u003e : IBufferWriter\u003cT\u003e\r\n{\r\n    ...\r\n    /// \u003csummary\u003eGets a \u003csee cref=\"T:System.Span`1\" /\u003e that contains the data written to the underlying buffer so far, as a mutable span.\u003c/summary\u003e\r\n    /// \u003creturns\u003eThe data written to the underlying buffer.\u003c/returns\u003e\r\n    public Span\u003cT\u003e WrittenSpanMutable =\u003e this._buffer.AsSpan\u003cT\u003e(0, this._index);\r\n}\r\n```\n\n### API Usage\n\n```csharp\r\nvar abw = new ArrayBufferWriter\u003cbyte\u003e();\r\nabw.Write(\"hello321\"u8);\r\nvar span = abw.WrittenSpanMutable;\r\nspan.Sort();\r\n\r\n// Write the string \"123ehllo\" to a file.\r\nusing var fs = new FileStream(\"foo\", FileMode.Create);\r\nfs.Write(span);\r\n```\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\nI realize that someone wrote that `(ReadOnlySpan\u003cT\u003e)` cast in the `WrittenSpan` implementation, possibly for some good reason. But if so, that reason is not evident from either documentation or implementation. ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOez07cQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc57NvAv",
                                           "createdAt":  "2024-04-19T19:52:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-04-19T19:52:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57PTtx",
                                           "createdAt":  "2024-04-20T09:04:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "DaZombieKiller",
                                           "body":  "\u003e In practice, a `Span` version of `WrittenSpan` can still be obtained, it\u0027s just awkward and relies on implementation details:\r\n\r\nI would not recommend that approach, a much safer alternative would be:\r\n```cs\r\npublic static ArraySegment\u003cT\u003e UnsafeGetArray\u003cT\u003e(this ArrayBufferWriter\u003cT\u003e writer)\r\n{\r\n    ArgumentNullException.ThrowIfNull(writer);\r\n    MemoryMarshal.TryGetArray(writer.WrittenMemory, out ArraySegment\u003cT\u003e segment);\r\n    return segment;\r\n}\r\n```",
                                           "updatedAt":  "2024-04-20T09:04:28Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[API Proposal]: add ArrayBufferWriter\u003cT\u003e.WrittenSpan alternative that returns Span instead of ReadOnlySpan",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/103653",
        "createdAt":  "2024-06-18T08:34:57Z",
        "number":  103653,
        "author":  "performanceautofiler",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-14T18:19:49Z",
        "body":  "\u003c!-- DATA: {\"RunType\":{\"Repo\":\"dotnetruntime\",\"Branch\":\"refs/heads/main\",\"Arch\":\"x64\",\"Os\":\"Ubuntu2204\",\"Queue\":\"TigerUbuntu\",\"Frequency\":\"Weekly\",\"CoreClr\":false,\"Mono\":true,\"Wasm\":false,\"Maui\":false,\"Configs\":[\"CompilationMode:tiered\",\"LLVM:true\",\"MonoAOT:true\",\"MonoInterpreter:false\",\"RunKind:micro_mono\"]},\"RegressionDate\":\"2024-06-14T03:42:32\",\"IsRegression\":true} --\u003e\r\n\n### Run Information\n\nName | Value\n-- | --\nArchitecture | x64\nOS | ubuntu 22.04\nQueue | TigerUbuntu\nBaseline | [6927fea7b4bca1dc2cea7a0afba0373c1303cedc](https://github.com/dotnet/runtime/commit/6927fea7b4bca1dc2cea7a0afba0373c1303cedc)\nCompare | [d901213ed6076c0989a2de2626b99c9711442543](https://github.com/dotnet/runtime/commit/d901213ed6076c0989a2de2626b99c9711442543)\nDiff | [Diff](https://github.com/dotnet/runtime/compare/6927fea7b4bca1dc2cea7a0afba0373c1303cedc...d901213ed6076c0989a2de2626b99c9711442543)\nConfigs | CompilationMode:tiered, LLVM:true, MonoAOT:true, MonoInterpreter:false, RunKind:micro_mono\n\n\n### Regressions in System.Text.Json.Tests.Perf_Base64\n\nBenchmark | Baseline | Test | Test/Base | Test Quality | Edge Detector | Baseline IR | Compare IR | IR Ratio\n-- | -- | -- | -- | -- | -- | -- | -- | --\n|\u003cul\u003e\u003cli\u003e[WriteByteArrayAsBase64_HeavyEscaping - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_ubuntu 22.04_LLVM=true_MonoAOT=true_MonoInterpreter=false_RunKind=micro_mono/System.Text.Json.Tests.Perf_Base64.WriteByteArrayAsBase64_HeavyEscaping(NumberOfBytes%3a%20100).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Text.Json/Utf8JsonWriter/Perf.Base64.cs#L40-#L41\u003e)\u003c/li\u003e\u003cli\u003e[ADX - Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACpWUX2/aMBTF3yftO/gtyUYhBVYxpEwD1vXPoGU02h6mCZnkQjzFdnSvQ0k17bPPCYwVKnXZS2Sf/M7xteObCXDKESQoQy9+svsEENgwF2k8g0yzIGBOrI0C08JcGSHBOaSGyFWUVBzCkloJ8Jhakgt1BA4wSoSByNjVmFDMdTZnXafBHI7SDrw9HQKZGy6hzHzv3BVkQDZD2JjmNWllR2SoOQVczoec4Kzb/Io2d1gYGCDyYkBbeX4JfF2cU8QzoVbuTS4XgLfLkqM+O/V972+Bs1yNtFqKVY7cCK3omzPSMhNpNZvoGJzvLPjFHCMsHjsvn3OOx18mf3DM4Xl4opUe3Ib/xV8pA5gh2OfOt+Qp/cNopU9CxTuDFBHqubRhj1yCQGamcJ+4B9p4NbArTeN0LauvXYe/pnO1EgrqsNOVDousHpoUJCKeTlFLXSp1jZfFAkV8keoFT8VDpdWxzdqzuiucbzJA20OquuCHV36kbX8BhjrbjQ7bJ7S2O8Nlxt6xmBsoW9Ft++3uid89Oe2Ffq/f6fQ7frP7tt3uvem99v2+veM2hHIpOYoHYBxXc8k3bhVYVtBgrzy2KI5WaOxbsFHepM855GBzMtQ/bPs+gWdAeWoCtFXH7qOdbPXBGpCvbFLHa7AqqgwOPqIAFafFXikPq5qUJaN9B8jKPUYJR8PuhUmYS/bwgIK9p8E2kU5zqYLjmoqtTsG2CAsaYVIInA/26OxPp9hNSwtzFXmlRlkqTMA3QN5vOGvysRYFAAA=\u003e)\u003c/li\u003e\u003c/ul\u003e | 101.02 ns | 211.33 ns | 2.09 | 0.04 | True | | |\r\n|\u003cul\u003e\u003cli\u003e[WriteByteArrayAsBase64_NoEscaping - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_ubuntu 22.04_LLVM=true_MonoAOT=true_MonoInterpreter=false_RunKind=micro_mono/System.Text.Json.Tests.Perf_Base64.WriteByteArrayAsBase64_NoEscaping(NumberOfBytes%3a%201000).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Text.Json/Utf8JsonWriter/Perf.Base64.cs#L37-#L38\u003e)\u003c/li\u003e\u003cli\u003e[ADX - Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACpWUX2/aMBTF3yftO/gtyUYh/FFVkDINWLe1A8potD1MEzLJhXiK7ehepyXVtM8+JzBWqNRlL5F98jvH145vpsApR5CgDL34ye4TQGCjXKTxAjLNgoA5sTYKTAtzZYQE55gaIVdRUnEIa2olwGNqSS7UCTjEKBEGImNXY0Ix19me95wGczhKO/AOdAhkZlxCmfnWuS3IgGyGsDXNa9LKjshQcw64Xo44wXmv+RVt7qgwMETkxZB28nKmLynimVAbd5bLFeDNuoRowNq+73t/y1vkaqzVWmxy5EZoRd+csZaZSKvZVMfgfGfBL+YYYfHYefmcczL5Mv2DYw7Pw1Ot9PAm/C/+ShnADME+9741T+kfRit9EireG6SIUC+lDXvkEgQyM4X7xD3UxquBXWmapHey+tZ1+Gu6VBuhoA473+iwyOqhSUEi4ukctdSlUtf4sVihiD+kesVT8VBpdWyLzqLuCpfbDNB2kKqu9/GFH2vbXYChzvaj4+YJre3WcJmxNyzmBspGdDt+p3fm987aF6F/Meh2B912s9/vd/x2+7XvD+wdtyGUS8lRPADjuFlKvnWrwLKCBnvlsVVxskLj0ICN8iZ9ziEHm5Oh/mGb9wm8AMpTE6CtOnYf7WSnD+8A+cYmdb0Gq6LK4OA9ClBxWhyU8rCqSVky2neArNxjlHA07F6YhLlkDw8oOHgabBvpNJcqOK2p2OkU7IqwoBEmhcB5Z4/O/nKK/bS0MFeRV2qUpcIEfAvk/QbL/ojcFAUAAA==\u003e)\u003c/li\u003e\u003c/ul\u003e | 217.58 ns | 1.13 μs | 5.20 | 0.03 | True | | |\r\n|\u003cul\u003e\u003cli\u003e[WriteByteArrayAsBase64_NoEscaping - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_ubuntu 22.04_LLVM=true_MonoAOT=true_MonoInterpreter=false_RunKind=micro_mono/System.Text.Json.Tests.Perf_Base64.WriteByteArrayAsBase64_NoEscaping(NumberOfBytes%3a%20100).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Text.Json/Utf8JsonWriter/Perf.Base64.cs#L37-#L38\u003e)\u003c/li\u003e\u003cli\u003e[ADX - Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACpWUUW/TMBSF35H4D35LAl2XtV01KgWRjjE21m50ETwgVLnJbWMU29G9zpZMiN+Ok5aydtIIL5F98p3ja8c3E+BUIEhQhl78ZPcpILBxIbJkBrlmQcCcRBsF5hALZYQEZ5caI1dx2nAISzpMgSd0KLlQe2CIcSoMxMauxoRirlMOB06HORylHXhbOgIyUy6hznzn3FZkQHYjKE33krSyIzLUvQFczsecYDjofkWbO64MhIi8Cmktz6f6jGKeC7Vyp4VcAF4va4hG7Mj3vb/VzQp1qtVSrArkRmhF35xTLXORNbOJTsD5zoJfzDHC4onz8jnn1dWXyR8cC3genmilw+vov/gLZQBzBPvc+JY8o38YrfRJqGRjkCJGPZc27JFLEMjcVO4Td6iN1wK70HSV3cnmU7fhL+lMrYSCNuzNSkdV3g5NKxIxz25QS10rbY0fqwWK5DzTC56Jh0ZrY5v1Zm1XOCtzQNtAqrndu/f9VNvmAox0vhnt9k5kbbeGy5y9ZQk3UPeh2/N7gwN/cHB0Evkno35/1O91jwb94+Hxm9e+P7J33IZQISVH8QCM42oueek2gXUFHfbKY4tqb4XOtv869U36XEABNidH/cP27hN4BlRkJkBbdeI+2slaD+8A+com9b0Oa6Lq4OADClBJVm2V+rCaSV0y2neArN5jnHI07F6YlLlkDw8o2Ho6rIx1VkgV7NdUrXUK1kVY0AiTQeC8t0dn/zjVZlpbmKvIqzXKM2ECXgJ5vwHOfFdPEwUAAA==\u003e)\u003c/li\u003e\u003c/ul\u003e | 102.64 ns | 214.80 ns | 2.09 | 0.05 | False | | |\r\n|\u003cul\u003e\u003cli\u003e[WriteByteArrayAsBase64_HeavyEscaping - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_ubuntu 22.04_LLVM=true_MonoAOT=true_MonoInterpreter=false_RunKind=micro_mono/System.Text.Json.Tests.Perf_Base64.WriteByteArrayAsBase64_HeavyEscaping(NumberOfBytes%3a%201000).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Text.Json/Utf8JsonWriter/Perf.Base64.cs#L40-#L41\u003e)\u003c/li\u003e\u003cli\u003e[ADX - Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACpWUX2/aMBTF3yftO/gtyUYhBdQxpEwD1vXPoGU02h6mCZnkQjzFdnSvQ0k17bPPCYwVKnXZS2Sf/M7xteObCXDKESQoQy9+svsEENgwF2k8g0yzIGBOrI0C08JcGSHBOaSGyFWUVBzCkloJ8Jhakgt1BA4wSoSByNjVmFDMdTZnXafBHI7SDrw9HQKZGy6hzHzv3BVkQDZD2JjmNWllR2SoOQVczoec4Kzb/Io2d1gYGCDyYkBbeX4JfF2cU8QzoVbuTS4XgLfLkqM+O/V93/tb4SxXI62WYpUjN0Ir+uaMtMxEWs0mOgbnOwt+MccIi8fOy+ec4/GXyR8cc3genmilB7fhf/FXygBmCPa58y15Sv8wWumTUPHOIEWEei5t2COXIJCZKdwn7oE2Xg3sStM4Xcvqc9fhr+lcrYSCOux0pcMiq4cmBYmIp1PUUpdKXeNlsUARX6R6wVPxUGl1bLP2rO4K55sM0DaRqm744Z0fadtggKHOdqPD/gmt7c5wmbF3LOYGyl502367e+J3T057od/rdzr9TrvZ7r3xe2/br32/b++4DaFcSo7iARjH1VzyjVsFlhU02CuPLYqjFRr7HmyUN+lzDjnYnAz1D9u/T+AZUJ6aAG3VsftoJ1t9sAbkK5vU8RqsiiqDg48oQMVpsVfKw6omZclo3wGyco9RwtGwe2ES5pI9PKBg72mwTaTTXKrguKZiq1OwLcKCRpgUAueDPTr71yl209LCXEVeqVGWChPwDZD3G7oDmoUXBQAA\u003e)\u003c/li\u003e\u003c/ul\u003e | 213.52 ns | 1.13 μs | 5.31 | 0.05 | True | | |\r\n\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Text.Json.Tests.Perf_Base64_1.png\u003e)\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Text.Json.Tests.Perf_Base64_2.png\u003e)\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Text.Json.Tests.Perf_Base64_3.png\u003e)\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Text.Json.Tests.Perf_Base64_4.png\u003e)\n[Test Report](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Text.Json.Tests.Perf_Base64.html\u003e)\n\n### Repro\nGeneral Docs link: https://github.com/dotnet/performance/blob/main/docs/benchmarking-workflow-dotnet-runtime.md\n\n\u003cdetails\u003e\n   \u003csummary\u003eRepro Steps\u003c/summary\u003e\n\n\n#### Prerequisites (Files either built locally (with build.(sh/cmd) or downloaded from payload above (if same system setup) (in this order))\n- Libraries build extracted to `runtime/artifacts` or build instructions: [Libraries README](https://github.com/dotnet/runtime/blob/main/docs/workflow/building/libraries/README.md) args: `-subset libs+libs.tests -rc release -configuration Release -arch $RunArch -framework net8.0`\n- CoreCLR product build extracted to `runtime/artifacts/bin/coreclr/$RunOS.$RunArch.Release`, build instructions: [CoreCLR README](https://github.com/dotnet/runtime/blob/main/docs/workflow/building/coreclr/README.md) args: `-subset clr+libs -rc release -configuration Release -arch $RunArch -framework net8.0`\n- AOT MONO build extracted to `runtime/artifacts/bin/mono/$RunOS.$RunArch.Release`, build instructions: [MONO README](https://github.com/dotnet/runtime/blob/main/docs/workflow/building/mono/README.md) args: `-arch $RunArch -os $RunOS -s mono+libs+host+packs -c Release /p:CrossBuild=false /p:MonoLLVMUseCxx11Abi=false`\n- Dotnet SDK installed for dotnet commands\n- Running commands from the runtime folder\n\nLinux\n```cmd\n# Set $RunDir to the runtime directory\nRunDir=`pwd`\n\n# Set the OS, arch, and OSId\nRunOS=\u0027linux\u0027\nRunOSId=\u0027linux\u0027\nRunArch=\u0027x64\u0027\n\n# Create aot directory \nmkdir -p $RunDir/artifacts/bin/aot/sgen\nmkdir -p $RunDir/artifacts/bin/aot/pack\ncp -r $RunDir/artifacts/obj/mono/$RunOS.$RunArch.Release/mono/* $RunDir/artifacts/bin/aot/sgen\ncp -r $RunDir/artifacts/bin/microsoft.netcore.app.runtime.$RunOS-$RunArch/Release/* $RunDir/artifacts/bin/aot/pack\n\n# Create Core Root\n$RunDir/src/tests/build.sh release $RunArch generatelayoutonly /p:LibrariesConfiguration=Release\n\n# Clone performance \ngit clone --branch main --depth 1 --quiet https://github.com/dotnet/performance.git $RunDir/performance\n\n# One line run:\npython3 $RunDir/performance/scripts/benchmarks_ci.py --csproj $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --incremental no --architecture $RunArch -f net8.0 --filter \u0027System.Text.Json.Tests.Perf_Base64*\u0027 --bdn-artifacts $RunDir/artifacts/BenchmarkDotNet.Artifacts --bdn-arguments=\"--anyCategories Libraries Runtime  --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir/artifacts/bin/aot/sgen/mini/mono-sgen --customruntimepack $RunDir/artifacts/bin/aot/pack --aotcompilermode llvm --logBuildOutput --generateBinLog\"\n\n# Individual Commands:\n# Restore \ndotnet restore $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --packages $RunDir/performance/artifacts/packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Build\ndotnet build $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore /p:NuGetPackageRoot=$RunDir/performance/artifacts/packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Run\ndotnet run --project $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore --no-build -- --filter System.Text.Json.Tests.Perf_Base64* --anyCategories Libraries Runtime \" --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir/artifacts/bin/aot/sgen/mini/mono-sgen --customruntimepack $RunDir/artifacts/bin/aot/pack --aotcompilermode llvm --logBuildOutput --generateBinLog \" --artifacts $RunDir/artifacts/BenchmarkDotNet.Artifacts --packages $RunDir/performance/artifacts/packages --buildTimeout 1200\n```\n\nWindows\n```cmd\n# Set $RunDir to the runtime directory\n$RunDir=\"FullPathHere\"\n\n# Set the OS, arch, and OSId\nRunOS=\u0027windows\u0027\nRunOSId=\u0027win\u0027\nRunArch=\u0027x64\u0027\n\n# Create aot directory\nmkdir $RunDir\\artifacts\\bin\\aot\\sgen\nmkdir $RunDir\\artifacts\\bin\\aot\\pack\nxcopy $RunDir\\artifacts\\obj\\mono\\$RunOS.$RunArch.Release\\mono $RunDir\\artifacts\\bin\\aot\\sgen\\ /e /y\nxcopy $RunDir\\artifacts\\bin\\microsoft.netcore.app.runtime.$RunOSId-$RunArch\\Release $RunDir\\artifacts\\bin\\aot\\pack\\ /e /y\n\n# Create Core Root\n$RunDir\\src\\tests\\build.cmd release $RunArch generatelayoutonly /p:LibrariesConfiguration=Release\n\n# Clone performance \ngit clone --branch main --depth 1 --quiet https://github.com/dotnet/performance.git $RunDir\\performance\n\n# One line run:\npython3 $RunDir\\performance\\scripts\\benchmarks_ci.py --csproj $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --incremental no --architecture $RunArch -f net8.0 --filter \u0027System.Text.Json.Tests.Perf_Base64*\u0027 --bdn-artifacts $RunDir\\artifacts\\BenchmarkDotNet.Artifacts --bdn-arguments=\"--anyCategories Libraries Runtime  --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir\\artifacts\\bin\\aot\\sgen\\mini\\mono-sgen.exe --customruntimepack $RunDir\\artifacts\\bin\\aot\\pack --aotcompilermode llvm --logBuildOutput --generateBinLog\"\n\n# Individual Commands:\n# Restore \ndotnet restore $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --packages $RunDir\\performance\\artifacts\\packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Build\ndotnet build $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore /p:NuGetPackageRoot=$RunDir\\performance\\artifacts\\packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Run\ndotnet run --project $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore --no-build -- --filter System.Text.Json.Tests.Perf_Base64* --anyCategories Libraries Runtime \" --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir\\artifacts\\bin\\aot\\sgen\\mini\\mono-sgen.exe --customruntimepack $RunDir\\artifacts\\bin\\aot\\pack -aotcompilermode llvm --logBuildOutput --generateBinLog \" --artifacts $RunDir\\artifacts\\BenchmarkDotNet.Artifacts --packages $RunDir\\performance\\artifacts\\packages --buildTimeout 1200\n```\n\n\u003c/details\u003e\n\n\u003cdetails\u003e\n\n### System.Text.Json.Tests.Perf_Base64.WriteByteArrayAsBase64_HeavyEscaping(NumberOfBytes: 100)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Text.Json.Tests.Perf_Base64.WriteByteArrayAsBase64_NoEscaping(NumberOfBytes: 1000)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Text.Json.Tests.Perf_Base64.WriteByteArrayAsBase64_NoEscaping(NumberOfBytes: 100)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Text.Json.Tests.Perf_Base64.WriteByteArrayAsBase64_HeavyEscaping(NumberOfBytes: 1000)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n\n\n### Docs\n\n[Profiling workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/profiling-workflow-dotnet-runtime.md)\n[Benchmarking workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/benchmarking-workflow-dotnet-runtime.md)\n\n\u003c/details\u003e\n\r\n\r\n---\r\n\r\n\n### Run Information\n\nName | Value\n-- | --\nArchitecture | x64\nOS | ubuntu 22.04\nQueue | TigerUbuntu\nBaseline | [6927fea7b4bca1dc2cea7a0afba0373c1303cedc](https://github.com/dotnet/runtime/commit/6927fea7b4bca1dc2cea7a0afba0373c1303cedc)\nCompare | [d901213ed6076c0989a2de2626b99c9711442543](https://github.com/dotnet/runtime/commit/d901213ed6076c0989a2de2626b99c9711442543)\nDiff | [Diff](https://github.com/dotnet/runtime/compare/6927fea7b4bca1dc2cea7a0afba0373c1303cedc...d901213ed6076c0989a2de2626b99c9711442543)\nConfigs | CompilationMode:tiered, LLVM:true, MonoAOT:true, MonoInterpreter:false, RunKind:micro_mono\n\n\n### Regressions in System.Text.Json.Reader.Tests.Perf_Base64\n\nBenchmark | Baseline | Test | Test/Base | Test Quality | Edge Detector | Baseline IR | Compare IR | IR Ratio\n-- | -- | -- | -- | -- | -- | -- | -- | --\n|\u003cul\u003e\u003cli\u003e[ReadBase64EncodedByteArray_HeavyEscaping - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_ubuntu 22.04_LLVM=true_MonoAOT=true_MonoInterpreter=false_RunKind=micro_mono/System.Text.Json.Reader.Tests.Perf_Base64.ReadBase64EncodedByteArray_HeavyEscaping(NumberOfBytes%3a%201000).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Text.Json/Utf8JsonReader/Perf.Base64.cs#L52-#L53\u003e)\u003c/li\u003e\u003cli\u003e[ADX - Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACpVU72/aMBD9Pmn/g78l2SikgFCHlGnA2PoDWkajfZkmZJKDeIrt6M6hpJr2t88JjBUqddmX6Pz83ruzc+cpcMoRJChDr36yhwQQ2DAXaTyHTLMgYE6sjQLTwlwZIcE5Zg2RqyipeAgraiXAY2pJLtQJcYBRIgxExmZjQjHX2fa6ToM5HKUNvAM7BDK3XELp+cG5L8iAbIawNc1r0qo5twkALUCGmjPA1WLICXrdamMXjlWkY4iHhYEBIi8Wl8A3xZgingm1dm9zuQS8W5X71Gfnvu97f4ud52qk1Uqsc+RGaEXfnJGWmUir1dQaO99Z8Is5Rlh67Lx+STmZfJ3+oWMOL5OnWunBXfhf/CtlADME+93rVjylfwgtdCNUvBdIEaFeSGv2RCUIZGYK95l6oI1Xg3alaZJuZPXn6/CvaazWQkEd7mytwyKrR00KEhFPZ6ilLpG6wstiiSL+nOolT8VjhdWRzdvzuhnG2wzQzpOqmv24/UfazhpgqLN9dDxKoZXdGy4z9p7F3EA5lm7bb3fP/O7Z+UXoX/Q7nX7nXbPX8zu9bvet7/dtj1sTyqXkKB6BcVwvJN+6lWFZQYO98diyOMnQOIxjo+ykLznkYH0y1D/sKD8jz4Hy1ARoq47dJyfZ4YMNIF9bp47XYJVVaRx8QgEqTosDUl5WtShLRrsHyMozRglHwx6ESZhL9vKAgoOmwbaRTnOpgtOaih1Owa4ISzTCpBA4H+3V2Qeo2C9LCXMVeSVGWSpMwLdA3m89bujcIgUAAA==\u003e)\u003c/li\u003e\u003c/ul\u003e | 6.46 μs | 7.24 μs | 1.12 | 0.03 | False | | |\r\n|\u003cul\u003e\u003cli\u003e[ReadBase64EncodedByteArray_NoEscaping - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_ubuntu 22.04_LLVM=true_MonoAOT=true_MonoInterpreter=false_RunKind=micro_mono/System.Text.Json.Reader.Tests.Perf_Base64.ReadBase64EncodedByteArray_NoEscaping(NumberOfBytes%3a%201000).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Text.Json/Utf8JsonReader/Perf.Base64.cs#L49-#L50\u003e)\u003c/li\u003e\u003cli\u003e[ADX - Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACpVUUW/aMBB+n7T/4LckG4UUEKJImQaMre0KZTTayzQhkxzEU2xHd05Lqmm/fU5grFCpy16i8+fv++7s3HkKnHIECcrQq5/sIQEENspFGi8g0ywImBNro8C0MFdGSHCOWSPkKkoqHsKaWgnwmFqSC3VCHGKUCAORsdmYUMx1tr2u02AOR2kD78AOgcyMSyg93zt3BRmQzRC2pnlNWjUXNgGgBchQcw64Xo44Qa9bbezCiYp0DPGoMDBE5MVypicU8UyojTvL5Qrwdl1u0oCd+77v/a10kauxVmuxyZEboRV9c8ZaZiKtVlPr6nxnwS/mGGHpsfP6JeXNzdfpHzrm8DJ5qpUe3ob/xb9SBjBDsN+9bs1T+ofQQp+FivcCKSLUS2nNnqgEgcxM4T5TD7XxatCuNN2k97L67XX41zRRG6GgDne+0WGR1aMmBYmIp3PUUpdIXeFlsUIRf0r1iqfiscLqyBbtRd0Mk20GaIdJVZ1+3PtjbQcNMNTZPjqeo9DK7gyXGXvHYm6gnEm37be7Z3737Lwf+v1BpzPoXDT7fu+837546/sD2+PWhHIpOYpHYBw3S8m3bmVYVtBgbzy2Kk4yNA6z2Cg76UsOOVifDPUPO8fPyAugPDUB2qpj98lJdvjwHpBvrFPHa7DKqjQOPqIAFafFASkvq1qUJaPdA2TlGaOEo2EPwiTMJXt5QMFB02DbSKe5VMFpTcUOp2BXhCUaYVIInA/26uzrU+yXpYS5irwSoywVJuBbIO83/k6AYB8FAAA=\u003e)\u003c/li\u003e\u003c/ul\u003e | 6.48 μs | 7.20 μs | 1.11 | 0.02 | False | | |\r\n|\u003cul\u003e\u003cli\u003e[ReadBase64EncodedByteArray_HeavyEscaping - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_ubuntu 22.04_LLVM=true_MonoAOT=true_MonoInterpreter=false_RunKind=micro_mono/System.Text.Json.Reader.Tests.Perf_Base64.ReadBase64EncodedByteArray_HeavyEscaping(NumberOfBytes%3a%20100).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Text.Json/Utf8JsonReader/Perf.Base64.cs#L52-#L53\u003e)\u003c/li\u003e\u003cli\u003e[ADX - Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACpVUUW/aMBB+n7T/4LckG4W0sA6QMg06traDltFoL9OETHIQT7Ed3TmUVNN++5zAWKFSl71E58/f993ZufMEOOUIEpShFz/ZfQIIbJiLNJ5BplkQMCfWRoFpYa6MkOAcsobIVZRUPIQltRLgMbUkF+qIOMAoEQYiY7MxoZjrbM47ToM5HKUNvD07BDI3XELp+d65K8iAbIawMc1r0qo5swkALUCGmlPA5XzICc471cY2HKlIxxAPCwMDRF7ML4GvixFFPBNq5d7kcgF4uyz3qc9Ofd/7W+ssVxdaLcUqR26EVvTNudAyE2m1mlhf5zsLfjHHCEuPnZfPKcfjr5M/dMzhefJEKz24Df+Lf6UMYIZgvzvdkqf0D6GFPgsV7wRSRKjn0po9UgkCmZnCfaIeaOPVoF1pGqdrWf34OvxrGqmVUFCHO13psMjqUZOCRMTTKWqpS6Su8LJYoIg/pXrBU/FQYXVks7NZ3QyjTQZox0lVvX7Y/RfajhpgqLNddDhJoZXdGS4z9o7F3EA5le6Zf9Y58Tsnp93Q7/bb7X671+y96XVPu29f+37f9rg1oVxKjuIBGMfVXPKNWxmWFTTYK48tiqMMjf00NspO+pJDDtYnQ/3DTvIT8gwoT02AturYfXSSLT5YA/KVdWp7DVZZlcbBRxSg4rTYI+VlVYuyZLR7gKw8Y5RwNOxemIS5ZC8PKNhrGmwT6TSXKjiuqdjiFGyLsEQjTAqB88FenX1/it2ylDBXkVdilKXCBHwD5P0Gtv+dfCEFAAA=\u003e)\u003c/li\u003e\u003c/ul\u003e | 784.56 ns | 855.26 ns | 1.09 | 0.02 | False | | |\r\n|\u003cul\u003e\u003cli\u003e[ReadBase64EncodedByteArray_NoEscaping - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_ubuntu 22.04_LLVM=true_MonoAOT=true_MonoInterpreter=false_RunKind=micro_mono/System.Text.Json.Reader.Tests.Perf_Base64.ReadBase64EncodedByteArray_NoEscaping(NumberOfBytes%3a%20100).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Text.Json/Utf8JsonReader/Perf.Base64.cs#L49-#L50\u003e)\u003c/li\u003e\u003cli\u003e[ADX - Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACpVU72/aMBD9Pmn/g78l2SiEH6oQUqYBY1tboIxG+zJNyCQH8RTb0Z3Tkmra3z4nMFao1GVfovPze+/Ozp1nwClHkKAMvfrJHhJAYKNcpPESMs2CgDmxNgpMC3NlhATnlDVCrqKk4iFsqJUAj6kluVBnxCFGiTAQGZuNCcVcZ3fZcxrM4Sht4B3ZIZCZcwml53vnriADshnCzjSvSavm0iYAtAAZai4AN6sRJ7jsVRv7cKIiHUM8KgwMEXmxmusJRTwTauvOc7kGvN2UmzRgbd/3/ha6zNVYq43Y5siN0Iq+OWMtM5FWq5k1db6z4BdzjLD02Hn9knI6/Tr7Q8ccXibPtNLD2/C/+FfKAGYI9nvQbXhK/xBa6Eao+CCQIkK9ktbsiUoQyMwU7jP1UBuvBu1K0zS9l9Vfr8O/ponaCgV1uIutDousHjUpSEQ8XaCWukTqCj8XaxTxp1SveSoeK6yObNlZ1s0w2WWAdpZU1einrT/Wds4AQ50dotMxCq3sznCZsXcs5gbKkXQ7fqd34fcu2v3Q7w+63UHPb7bbnW6/3X7r+wPb49aEcik5ikdgHLcryXduZVhW0GBvPLYuzjI0jqPYKDvpSw45WJ8M9Q87xs/IS6A8NQHaqmP3yUn2+PAekG+tU9drsMqqNA4+ogAVp8URKS+rWpQlo90DZOUZo4SjYQ/CJMwle3lAwVHTYLtIp7lUwXlNxR6nYF+EJRphUgicD/bq7ONTHJalhLmKvBKjLBUm4Dsg7zfTzuCNHgUAAA==\u003e)\u003c/li\u003e\u003c/ul\u003e | 787.38 ns | 858.71 ns | 1.09 | 0.03 | False | | |\r\n\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Text.Json.Reader.Tests.Perf_Base64_1.png\u003e)\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Text.Json.Reader.Tests.Perf_Base64_2.png\u003e)\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Text.Json.Reader.Tests.Perf_Base64_3.png\u003e)\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Text.Json.Reader.Tests.Perf_Base64_4.png\u003e)\n[Test Report](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Text.Json.Reader.Tests.Perf_Base64.html\u003e)\n\n### Repro\nGeneral Docs link: https://github.com/dotnet/performance/blob/main/docs/benchmarking-workflow-dotnet-runtime.md\n\n\u003cdetails\u003e\n   \u003csummary\u003eRepro Steps\u003c/summary\u003e\n\n\n#### Prerequisites (Files either built locally (with build.(sh/cmd) or downloaded from payload above (if same system setup) (in this order))\n- Libraries build extracted to `runtime/artifacts` or build instructions: [Libraries README](https://github.com/dotnet/runtime/blob/main/docs/workflow/building/libraries/README.md) args: `-subset libs+libs.tests -rc release -configuration Release -arch $RunArch -framework net8.0`\n- CoreCLR product build extracted to `runtime/artifacts/bin/coreclr/$RunOS.$RunArch.Release`, build instructions: [CoreCLR README](https://github.com/dotnet/runtime/blob/main/docs/workflow/building/coreclr/README.md) args: `-subset clr+libs -rc release -configuration Release -arch $RunArch -framework net8.0`\n- AOT MONO build extracted to `runtime/artifacts/bin/mono/$RunOS.$RunArch.Release`, build instructions: [MONO README](https://github.com/dotnet/runtime/blob/main/docs/workflow/building/mono/README.md) args: `-arch $RunArch -os $RunOS -s mono+libs+host+packs -c Release /p:CrossBuild=false /p:MonoLLVMUseCxx11Abi=false`\n- Dotnet SDK installed for dotnet commands\n- Running commands from the runtime folder\n\nLinux\n```cmd\n# Set $RunDir to the runtime directory\nRunDir=`pwd`\n\n# Set the OS, arch, and OSId\nRunOS=\u0027linux\u0027\nRunOSId=\u0027linux\u0027\nRunArch=\u0027x64\u0027\n\n# Create aot directory \nmkdir -p $RunDir/artifacts/bin/aot/sgen\nmkdir -p $RunDir/artifacts/bin/aot/pack\ncp -r $RunDir/artifacts/obj/mono/$RunOS.$RunArch.Release/mono/* $RunDir/artifacts/bin/aot/sgen\ncp -r $RunDir/artifacts/bin/microsoft.netcore.app.runtime.$RunOS-$RunArch/Release/* $RunDir/artifacts/bin/aot/pack\n\n# Create Core Root\n$RunDir/src/tests/build.sh release $RunArch generatelayoutonly /p:LibrariesConfiguration=Release\n\n# Clone performance \ngit clone --branch main --depth 1 --quiet https://github.com/dotnet/performance.git $RunDir/performance\n\n# One line run:\npython3 $RunDir/performance/scripts/benchmarks_ci.py --csproj $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --incremental no --architecture $RunArch -f net8.0 --filter \u0027System.Text.Json.Reader.Tests.Perf_Base64*\u0027 --bdn-artifacts $RunDir/artifacts/BenchmarkDotNet.Artifacts --bdn-arguments=\"--anyCategories Libraries Runtime  --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir/artifacts/bin/aot/sgen/mini/mono-sgen --customruntimepack $RunDir/artifacts/bin/aot/pack --aotcompilermode llvm --logBuildOutput --generateBinLog\"\n\n# Individual Commands:\n# Restore \ndotnet restore $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --packages $RunDir/performance/artifacts/packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Build\ndotnet build $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore /p:NuGetPackageRoot=$RunDir/performance/artifacts/packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Run\ndotnet run --project $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore --no-build -- --filter System.Text.Json.Reader.Tests.Perf_Base64* --anyCategories Libraries Runtime \" --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir/artifacts/bin/aot/sgen/mini/mono-sgen --customruntimepack $RunDir/artifacts/bin/aot/pack --aotcompilermode llvm --logBuildOutput --generateBinLog \" --artifacts $RunDir/artifacts/BenchmarkDotNet.Artifacts --packages $RunDir/performance/artifacts/packages --buildTimeout 1200\n```\n\nWindows\n```cmd\n# Set $RunDir to the runtime directory\n$RunDir=\"FullPathHere\"\n\n# Set the OS, arch, and OSId\nRunOS=\u0027windows\u0027\nRunOSId=\u0027win\u0027\nRunArch=\u0027x64\u0027\n\n# Create aot directory\nmkdir $RunDir\\artifacts\\bin\\aot\\sgen\nmkdir $RunDir\\artifacts\\bin\\aot\\pack\nxcopy $RunDir\\artifacts\\obj\\mono\\$RunOS.$RunArch.Release\\mono $RunDir\\artifacts\\bin\\aot\\sgen\\ /e /y\nxcopy $RunDir\\artifacts\\bin\\microsoft.netcore.app.runtime.$RunOSId-$RunArch\\Release $RunDir\\artifacts\\bin\\aot\\pack\\ /e /y\n\n# Create Core Root\n$RunDir\\src\\tests\\build.cmd release $RunArch generatelayoutonly /p:LibrariesConfiguration=Release\n\n# Clone performance \ngit clone --branch main --depth 1 --quiet https://github.com/dotnet/performance.git $RunDir\\performance\n\n# One line run:\npython3 $RunDir\\performance\\scripts\\benchmarks_ci.py --csproj $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --incremental no --architecture $RunArch -f net8.0 --filter \u0027System.Text.Json.Reader.Tests.Perf_Base64*\u0027 --bdn-artifacts $RunDir\\artifacts\\BenchmarkDotNet.Artifacts --bdn-arguments=\"--anyCategories Libraries Runtime  --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir\\artifacts\\bin\\aot\\sgen\\mini\\mono-sgen.exe --customruntimepack $RunDir\\artifacts\\bin\\aot\\pack --aotcompilermode llvm --logBuildOutput --generateBinLog\"\n\n# Individual Commands:\n# Restore \ndotnet restore $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --packages $RunDir\\performance\\artifacts\\packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Build\ndotnet build $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore /p:NuGetPackageRoot=$RunDir\\performance\\artifacts\\packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Run\ndotnet run --project $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore --no-build -- --filter System.Text.Json.Reader.Tests.Perf_Base64* --anyCategories Libraries Runtime \" --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir\\artifacts\\bin\\aot\\sgen\\mini\\mono-sgen.exe --customruntimepack $RunDir\\artifacts\\bin\\aot\\pack -aotcompilermode llvm --logBuildOutput --generateBinLog \" --artifacts $RunDir\\artifacts\\BenchmarkDotNet.Artifacts --packages $RunDir\\performance\\artifacts\\packages --buildTimeout 1200\n```\n\n\u003c/details\u003e\n\n\u003cdetails\u003e\n\n### System.Text.Json.Reader.Tests.Perf_Base64.ReadBase64EncodedByteArray_HeavyEscaping(NumberOfBytes: 1000)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Text.Json.Reader.Tests.Perf_Base64.ReadBase64EncodedByteArray_NoEscaping(NumberOfBytes: 1000)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Text.Json.Reader.Tests.Perf_Base64.ReadBase64EncodedByteArray_HeavyEscaping(NumberOfBytes: 100)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Text.Json.Reader.Tests.Perf_Base64.ReadBase64EncodedByteArray_NoEscaping(NumberOfBytes: 100)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n\n\n### Docs\n\n[Profiling workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/profiling-workflow-dotnet-runtime.md)\n[Benchmarking workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/benchmarking-workflow-dotnet-runtime.md)\n\n\u003c/details\u003e\n\r\n\r\n---\r\n\r\n\n### Run Information\n\nName | Value\n-- | --\nArchitecture | x64\nOS | ubuntu 22.04\nQueue | TigerUbuntu\nBaseline | [6927fea7b4bca1dc2cea7a0afba0373c1303cedc](https://github.com/dotnet/runtime/commit/6927fea7b4bca1dc2cea7a0afba0373c1303cedc)\nCompare | [d901213ed6076c0989a2de2626b99c9711442543](https://github.com/dotnet/runtime/commit/d901213ed6076c0989a2de2626b99c9711442543)\nDiff | [Diff](https://github.com/dotnet/runtime/compare/6927fea7b4bca1dc2cea7a0afba0373c1303cedc...d901213ed6076c0989a2de2626b99c9711442543)\nConfigs | CompilationMode:tiered, LLVM:true, MonoAOT:true, MonoInterpreter:false, RunKind:micro_mono\n\n\n### Regressions in System.Collections.CopyTo\u0026lt;String\u0026gt;\n\nBenchmark | Baseline | Test | Test/Base | Test Quality | Edge Detector | Baseline IR | Compare IR | IR Ratio\n-- | -- | -- | -- | -- | -- | -- | -- | --\n|\u003cul\u003e\u003cli\u003e[Array - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_ubuntu 22.04_LLVM=true_MonoAOT=true_MonoInterpreter=false_RunKind=micro_mono/System.Collections.CopyTo(String).Array(Size%3a%202048).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Collections/CopyTo.cs#L33-#L34\u003e)\u003c/li\u003e\u003cli\u003e[ADX - Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACpWUb2/TMBDG3yPxHfwuCWRtaLupVGSiKwM2WhhtxBuEJje5Jkb+E52drZkmPjt2WsraSSO8iewnv+fu7NxlBlRXCAKk0c/uyW0BCOSsYjybQ6lIHBMvU0aC6WIlDRPg7VNnSGVaNBzCSncLoJnuCsrkATjGtGAGUmOzESaJ761PBl5IPIrCLoIdnYA2n6kAF/Ott6i1AdGZKM6tlymp7bqsE/VmYZDJ/LQzRqS1v2B3MCK9aDAM/iaeV3Ki5IrlFdLG+92bKFEy3uxmKgPvB4l/Ec8wi2fe86ec0+m32R8cK3ganimpxl+S/+IvpAEsEexz61tRrv9htNInJrOtQbAU1bWwwR64mAZRmtp/5B4rE7TALpSe8hvRfMU2/KU+lzmT0Ia9ylVSl+3QotYspfwKlVBOaWv8WC+RZR+4WlLO7hqtjW3em7fNcL4uAe1syKZx91t5ouzcACaq3K72xyKxtoWhoiSnJKMG3Ij5vag3OIoGR6+GSTQc9fuj46jzenjcj/onL6NoFEUuha6EoGjbnlDMrwVd+01AV0FIXgRkWR9kCHejFbpO+lpBBTZOieqnHa1H8Bx0xU2MturMf3CSjT6+AaS5jdQPQtKEcoHj98hAZrzeKe6ymo0rGe07QOLOmBYUDbllpiC+tpcHOt55QrJOFa+EjA9rqje6jjdFWNAwwyH23tmrsz+Tert1FuJLHThNl5yZmK5BB78B6PXPju4EAAA=\u003e)\u003c/li\u003e\u003c/ul\u003e | 1.53 μs | 1.87 μs | 1.22 | 0.11 | False | | |\r\n|\u003cul\u003e\u003cli\u003e[Memory - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_ubuntu 22.04_LLVM=true_MonoAOT=true_MonoInterpreter=false_RunKind=micro_mono/System.Collections.CopyTo(String).Memory(Size%3a%202048).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Collections/CopyTo.cs#L44-#L46\u003e)\u003c/li\u003e\u003cli\u003e[ADX - Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACpWUXW/TMBSG75H4D75LAlmbfjCVikx0ZcCghdFG3CA0uclpYuSP6NjZmgnx27HTUtZOGuEmst887znHzjmZA9UVggBp9JOf5LYABHJeMZ4toFQkjomXKSPBdLGShgnwDqlzpDItGg5hrbsF0Ex3BWXyCJxgWjADqbHZCJPE9zanQy8kHkVhF8GeTkCbT1SAi/naW9bagOhMFefWy5TUdl3WiXq1NMhkftaZg1BY+0t2B2PSj4aj4G/mRSWnSq5ZXiFtzN+8qRIl481urjLwvpP4F/EMs3jmPX3MOZt9nf/BsYLH4bmSavI5+S/+UhrAEsE+d7415fofRit9ZDLbGQRLUV0LG+yei2kQpan9B+6JMkEL7FLpGb8RzWdsw3/QFzJnEtqwV7lK6rIdWtSapZRfoRLKKW2N7+sVsuwdVyvK2V2jtbEt+ou2GS42JaAdDtl07mEvT5UdHMBElbvV4Vwk1rY0VJTkjGTUgJsxvx/1hyfR8KQ3SqLReDAYv+h1er2Xp6Nh/3kUjaPIpdCVEBRt2xOK+bWgG78J6CoIybOArOqjDOF+tkLXSV8qqMDGKVH9sLP1AF6ArriJ0Vad+fdOstUnN4A0t5EGQUiaUC5w/BYZyIzXe8VdVrNxJaN9B0jcGdOCoiG3zBTE1/byQMd7T0g2qeKVkPFxTfVW1/G2CAsaZjjE3ht7dfZvUu+2zkJ8qQOn6ZIzE9MN6OA3bu/em+8EAAA=\u003e)\u003c/li\u003e\u003c/ul\u003e | 1.52 μs | 1.85 μs | 1.22 | 0.11 | False | | |\r\n|\u003cul\u003e\u003cli\u003e[Span - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_ubuntu 22.04_LLVM=true_MonoAOT=true_MonoInterpreter=false_RunKind=micro_mono/System.Collections.CopyTo(String).Span(Size%3a%202048).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Collections/CopyTo.cs#L36-#L38\u003e)\u003c/li\u003e\u003cli\u003e[ADX - Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACpWU227TQBCG75F4h72zDW7iHIpChCvSUKCQQEksbhCqNvbEXrQnza7buEI8O2snhCaVirmxdn9//8zsesZzoKZEECCtefKT3BaAQM5LxrMFaEXimHiZshJsF0tpmQDvkDpHKtOi4RDWplsAzUxXUCaPwAmmBbOQWpeNMEl8b/Ni6IXEoyjcItjTCRj7iQqoY772lpWxIDpTxbnzMiWNW+sqUa+WFpnMzzpLTaW/ZHcwJv1oOAr+5l2UcqrkmuUl0sb6zZsqoRlvdnOVgfedxL+IZ5nDM+/pY87Z7Ov8D44lPA7PlVSTz8l/8ZfSAmoE99z51pSbfxid9JHJbGcQLEV1LVywey5mQGhb+Q/cE2WDFtilMjN+I5qP2Ib/YC5kziS0Ya9ylVS6HVpUhqWUX6ESqlbaGt9XK2TZO65WlLO7RmtjW/QXbTNcbDSgGw3Z9O1hJ0+VGxvAROnd6nAqEmdbWio0OSMZtVBPmN+P+sOTaHjSGyXRaDwYjE97nf5p9HLU6z2PonEU1SlMKQRF1/aEYn4t6MZvAtYVhORZQFbVUYZwP1lh3UlfSijBxdGofrjJegAvwJTcxuiqzvx7J9nqkxtAmrtIgyAkTag6cPwWGciMV3ulvqxmU5eM7h0gqc+YFhQtuWW2IL5xlwcm3ntCskkVL4WMj2uqtrqJt0U40DLLIfbeuKtz/5Jqt60txJcmqDWjObMx3YAJfgP1TaBE7QQAAA==\u003e)\u003c/li\u003e\u003c/ul\u003e | 1.51 μs | 1.83 μs | 1.22 | 0.11 | False | | |\r\n|\u003cul\u003e\u003cli\u003e[ReadOnlySpan - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_ubuntu 22.04_LLVM=true_MonoAOT=true_MonoInterpreter=false_RunKind=micro_mono/System.Collections.CopyTo(String).ReadOnlySpan(Size%3a%202048).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Collections/CopyTo.cs#L40-#L42\u003e)\u003c/li\u003e\u003cli\u003e[ADX - Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACpWUb2/TMBDG3yPxHfwuCWRt1gZWKjLRlQGDlo004g1Ck5tcEyP/ic7O1kyIz46TlrJ20ghvIvvye547O3eZA9UVggBp9JOf5LYABHJWMZ7FUCoSRcTJlJFg+lhJwwQ4+9QZUpkWLYew0v0CaKb7gjJ5AE4wLZiB1NhshEniOuuXoeMTh6KwC29HJ6DNZyqg8XzjLGptQPSminOrZUpquy7rRL1eGGQyP+3FNuOl5PWipNJdsDsYk0EQjry/+eNKTpVcsbxC2lp8c6ZKlIy3u7nKwPlOol/EMczimfP0MeVs9nX+B8cKHofnSqrJZfJf/IU0gCWCfW51K8r1P4Q29InJbCsQLEV1LazZPRXTIEpTuw/UE2W8DtiF0jN+I9qP2YX/qM9lziR0Ya9yldRlN7SoNUspv0IlVBPpKvxQL5Fl77laUs7u2lgXWTyIu2Y4X5eAdkRk27/7HT1VdnwAE1VuV/vTkVjZwlBRklOSUQPNpLmDYBAeBeHR8SgJRuPhcPziuDc8eRWGJ8PnQTAOgiaFroSgaNueUMyvBV27rWFTgU+eeWRZH2TwdxPmN530pYIKrE+J6oedsAdwDLriJkJbdebeO8kmPrkBpLl1Gno+aa0a4+gdMpAZr3eR5rLaTVMy2neApDljWlA05JaZgrjaXh7oaKfxyTpVvBIyOqyp3sR1tCnCgoYZDpHz1l6d/afU220jIa7UXhPTJWcmomvQ3m98S79A9QQAAA==\u003e)\u003c/li\u003e\u003c/ul\u003e | 1.50 μs | 1.84 μs | 1.22 | 0.11 | False | | |\r\n|\u003cul\u003e\u003cli\u003e[List - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_ubuntu 22.04_LLVM=true_MonoAOT=true_MonoInterpreter=false_RunKind=micro_mono/System.Collections.CopyTo(String).List(Size%3a%202048).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Collections/CopyTo.cs#L59-#L60\u003e)\u003c/li\u003e\u003cli\u003e[ADX - Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACpWUXW/TMBSG75H4D75LAlmbfgxFFZnoyhiDFkYbcYPQ5CanjZE/omNnaybEb8dOS1k7aYSbyH7zvOccO+dkBlRXCAKk0c9+krsCEMh5xXg+h1KRJCFerowE08VKGibAO6TOkcqsaDiEle4WQHPdFZTJI3CMWcEMZMZmI0wS39u8Gnoh8SgKuwj2dArafKICXMw33qLWBkRnoji3XqaktuuyTtXrhUEm12edKdPGX7B7GJF+NIyDv3nnlZwouWLrCmlj/eZNlCgZb3YzlYP3nSS/iGeYxXPv+VPO6fTr7A+OFTwNz5RU48/pf/FX0gCWCPa5860o1/8wWukjk/nOIFiG6kbYYA9cTIMoTe0/co+VCVpgV0pP+a1oPmIb/oO+kGsmoQ17vVZpXbZDi1qzjPJrVEI5pa3xfb1Ell9ytaSc3TdaG9u8P2+b4WJTAtrRkE3fHnbyRNmxAUxVuVsdTkVqbQtDRUnOSE4NuAnz+1F/eBINT3pxGsWjwWB02uuc9nqDOI5fRtEoilwKXQlB0bY9obi+EXTjNwFdBSF5EZBlfZQh3E9W6DrpSwUV2Dglqh92sh7Bc9AVNwnaqnP/wUm2+vgWkK5tpEEQkiaUC5y8QwYy5/VecZfVbFzJaN8BEnfGrKBoyB0zBfG1vTzQyd4Tkk2meCVkclxTvdV1si3CgoYZDon31l6d/ZfUu62zEF/qwGm65MwkdAM6+A1efxaU7QQAAA==\u003e)\u003c/li\u003e\u003c/ul\u003e | 1.53 μs | 1.83 μs | 1.19 | 0.12 | False | | |\r\n|\u003cul\u003e\u003cli\u003e[ImmutableArray - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_ubuntu 22.04_LLVM=true_MonoAOT=true_MonoInterpreter=false_RunKind=micro_mono/System.Collections.CopyTo(String).ImmutableArray(Size%3a%202048).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Collections/CopyTo.cs#L69-#L70\u003e)\u003c/li\u003e\u003cli\u003e[ADX - Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACpWUXW/TMBSG75H4D75LAlmbflCVikx0ZUChhdFG3CA0uclpY+SP6Njemgnx23HSUtZOGuEmsk+e9z3HzjmZA9UWQYA0+slPcpsDArmwjGcLKBSJY+JlykgwbbTSMAHeMXWBVKZ5zSGsdTsHmum2oEyegGNMc2YgNS4bYZL43nbQ90LiURRuERzoBLT5RAVUnq+9ZakNiNZEce60TEnt1kWZqFdLg0xuzltTIayhKw5jRFr6S3YHI9KN+sPgbwULKydKrtnGIq1NvnkTJQrG691cZeB9J/Ev4hnm8Mx7+phyNvs6/4OjhcfhuZJq/Dn5L34qDWCB4J573Zpy/Q+hC31kMtsLBEtRXQtndk/FNIjClP4D9ViZoAE2VXrGb0T9OZvwH/Sl3DAJTdirjUrKohmal5qllF+hEqqKNBW+L1fIsndcrShnd3WsiWzRXTTNcLktAN2QyLqDj3t6otwAASaq2K+O5yNxsqWhoiDnJKMGqlnzu1G3fxb1zzrDJBqOer3Ri05r0H856Ax6z6NoFEVVCm2FoOjanlDcXAu69WvDqoKQPAvIqjzJEB5mLKw66YsFC86nQPXDzdgDeAHachOjqzrz751kFx/fANKNc+oFIamtKuP4LTKQGS8Pkeqy6k1VMrp3gKQ6Y5pTNOSWmZz42l0e6PigCck2VdwKGZ/WVO7iOt4V4UDDDIfYe+Ouzv1Vyv22khBf6qCK6YIzE9Mt6OA3j2fPgPcEAAA=\u003e)\u003c/li\u003e\u003c/ul\u003e | 1.56 μs | 1.86 μs | 1.20 | 0.13 | False | | |\r\n|\u003cul\u003e\u003cli\u003e[ReadOnlyMemory - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_ubuntu 22.04_LLVM=true_MonoAOT=true_MonoInterpreter=false_RunKind=micro_mono/System.Collections.CopyTo(String).ReadOnlyMemory(Size%3a%202048).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Collections/CopyTo.cs#L48-#L50\u003e)\u003c/li\u003e\u003cli\u003e[ADX - Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACpWUb2/TMBDG3yPxHfwuCWRt1nZQKjLRlQGDlo004g1Ck5tcGyP/ic7OVk+Iz46TlrJ20ghvIvvye547O3eZAdUVggBp9JOf5LYABHJWMZ4nUCoSx8TLlZFgulhJwwR4+9QZUpkVDYew1N0CaK67gjJ5AI4xK5iBzLhshEnie+sXAy8kHkXhFsGOTkGbz1RA7fnGm1ttQHQminOnZUpqty5tql7PDTK5Ou0kLuOl5HYGQqH15+wORqQXDYbB3wqSSk6UXLJVhbQx+eZNlCgZb3YzlYP3ncS/iGeYw3Pv6WPK6fTr7A+OFTwOz5RU48v0v/gLaQBLBPfc6paU638IXegTk/lWIFiG6lo4s3sqpkGUxvoP1GNlghbYhdJTfiOaz9mG/6jP5YpJaMNerVRqy3ZoYTXLKL9CJVQdaSv8YBfI8vdcLShnd02sjSzpJW0znK9LQDcksung/Z6eKDdAgKkqt6v9+UidbG6oKMkpyamBetb8XtQbHEWDo+NhGg1H/f7o5LjzctgfngxePY+iURTVKXQlBEXX9oTi6lrQtd8Y1hWE5FlAFvYgQ7ibsbDupC8VVOB8SlQ/3Iw9gBPQFTcxuqpz/95JNvHxDSBdOad+EJLGqjaO3yEDmXO7i9SX1WzqktG9AyT1GbOCoiG3zBTE1+7yQMc7TUjWmeKVkPFhTXYT1/GmCAcaZjjE3lt3de6vYrfbWkJ8qYM6pkvOTEzXoIPfqCDEzfcEAAA=\u003e)\u003c/li\u003e\u003c/ul\u003e | 1.50 μs | 1.84 μs | 1.22 | 0.11 | False | | |\r\n\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Collections.CopyTo%28String%29_1.png\u003e)\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Collections.CopyTo%28String%29_2.png\u003e)\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Collections.CopyTo%28String%29_3.png\u003e)\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Collections.CopyTo%28String%29_4.png\u003e)\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Collections.CopyTo%28String%29_5.png\u003e)\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Collections.CopyTo%28String%29_6.png\u003e)\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Collections.CopyTo%28String%29_7.png\u003e)\n[Test Report](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Collections.CopyTo%28String%29.html\u003e)\n\n### Repro\nGeneral Docs link: https://github.com/dotnet/performance/blob/main/docs/benchmarking-workflow-dotnet-runtime.md\n\n\u003cdetails\u003e\n   \u003csummary\u003eRepro Steps\u003c/summary\u003e\n\n\n#### Prerequisites (Files either built locally (with build.(sh/cmd) or downloaded from payload above (if same system setup) (in this order))\n- Libraries build extracted to `runtime/artifacts` or build instructions: [Libraries README](https://github.com/dotnet/runtime/blob/main/docs/workflow/building/libraries/README.md) args: `-subset libs+libs.tests -rc release -configuration Release -arch $RunArch -framework net8.0`\n- CoreCLR product build extracted to `runtime/artifacts/bin/coreclr/$RunOS.$RunArch.Release`, build instructions: [CoreCLR README](https://github.com/dotnet/runtime/blob/main/docs/workflow/building/coreclr/README.md) args: `-subset clr+libs -rc release -configuration Release -arch $RunArch -framework net8.0`\n- AOT MONO build extracted to `runtime/artifacts/bin/mono/$RunOS.$RunArch.Release`, build instructions: [MONO README](https://github.com/dotnet/runtime/blob/main/docs/workflow/building/mono/README.md) args: `-arch $RunArch -os $RunOS -s mono+libs+host+packs -c Release /p:CrossBuild=false /p:MonoLLVMUseCxx11Abi=false`\n- Dotnet SDK installed for dotnet commands\n- Running commands from the runtime folder\n\nLinux\n```cmd\n# Set $RunDir to the runtime directory\nRunDir=`pwd`\n\n# Set the OS, arch, and OSId\nRunOS=\u0027linux\u0027\nRunOSId=\u0027linux\u0027\nRunArch=\u0027x64\u0027\n\n# Create aot directory \nmkdir -p $RunDir/artifacts/bin/aot/sgen\nmkdir -p $RunDir/artifacts/bin/aot/pack\ncp -r $RunDir/artifacts/obj/mono/$RunOS.$RunArch.Release/mono/* $RunDir/artifacts/bin/aot/sgen\ncp -r $RunDir/artifacts/bin/microsoft.netcore.app.runtime.$RunOS-$RunArch/Release/* $RunDir/artifacts/bin/aot/pack\n\n# Create Core Root\n$RunDir/src/tests/build.sh release $RunArch generatelayoutonly /p:LibrariesConfiguration=Release\n\n# Clone performance \ngit clone --branch main --depth 1 --quiet https://github.com/dotnet/performance.git $RunDir/performance\n\n# One line run:\npython3 $RunDir/performance/scripts/benchmarks_ci.py --csproj $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --incremental no --architecture $RunArch -f net8.0 --filter \u0027System.Collections.CopyTo\u0026lt;String\u0026gt;*\u0027 --bdn-artifacts $RunDir/artifacts/BenchmarkDotNet.Artifacts --bdn-arguments=\"--anyCategories Libraries Runtime  --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir/artifacts/bin/aot/sgen/mini/mono-sgen --customruntimepack $RunDir/artifacts/bin/aot/pack --aotcompilermode llvm --logBuildOutput --generateBinLog\"\n\n# Individual Commands:\n# Restore \ndotnet restore $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --packages $RunDir/performance/artifacts/packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Build\ndotnet build $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore /p:NuGetPackageRoot=$RunDir/performance/artifacts/packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Run\ndotnet run --project $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore --no-build -- --filter System.Collections.CopyTo\u0026lt;String\u0026gt;* --anyCategories Libraries Runtime \" --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir/artifacts/bin/aot/sgen/mini/mono-sgen --customruntimepack $RunDir/artifacts/bin/aot/pack --aotcompilermode llvm --logBuildOutput --generateBinLog \" --artifacts $RunDir/artifacts/BenchmarkDotNet.Artifacts --packages $RunDir/performance/artifacts/packages --buildTimeout 1200\n```\n\nWindows\n```cmd\n# Set $RunDir to the runtime directory\n$RunDir=\"FullPathHere\"\n\n# Set the OS, arch, and OSId\nRunOS=\u0027windows\u0027\nRunOSId=\u0027win\u0027\nRunArch=\u0027x64\u0027\n\n# Create aot directory\nmkdir $RunDir\\artifacts\\bin\\aot\\sgen\nmkdir $RunDir\\artifacts\\bin\\aot\\pack\nxcopy $RunDir\\artifacts\\obj\\mono\\$RunOS.$RunArch.Release\\mono $RunDir\\artifacts\\bin\\aot\\sgen\\ /e /y\nxcopy $RunDir\\artifacts\\bin\\microsoft.netcore.app.runtime.$RunOSId-$RunArch\\Release $RunDir\\artifacts\\bin\\aot\\pack\\ /e /y\n\n# Create Core Root\n$RunDir\\src\\tests\\build.cmd release $RunArch generatelayoutonly /p:LibrariesConfiguration=Release\n\n# Clone performance \ngit clone --branch main --depth 1 --quiet https://github.com/dotnet/performance.git $RunDir\\performance\n\n# One line run:\npython3 $RunDir\\performance\\scripts\\benchmarks_ci.py --csproj $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --incremental no --architecture $RunArch -f net8.0 --filter \u0027System.Collections.CopyTo\u0026lt;String\u0026gt;*\u0027 --bdn-artifacts $RunDir\\artifacts\\BenchmarkDotNet.Artifacts --bdn-arguments=\"--anyCategories Libraries Runtime  --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir\\artifacts\\bin\\aot\\sgen\\mini\\mono-sgen.exe --customruntimepack $RunDir\\artifacts\\bin\\aot\\pack --aotcompilermode llvm --logBuildOutput --generateBinLog\"\n\n# Individual Commands:\n# Restore \ndotnet restore $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --packages $RunDir\\performance\\artifacts\\packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Build\ndotnet build $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore /p:NuGetPackageRoot=$RunDir\\performance\\artifacts\\packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Run\ndotnet run --project $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore --no-build -- --filter System.Collections.CopyTo\u0026lt;String\u0026gt;* --anyCategories Libraries Runtime \" --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir\\artifacts\\bin\\aot\\sgen\\mini\\mono-sgen.exe --customruntimepack $RunDir\\artifacts\\bin\\aot\\pack -aotcompilermode llvm --logBuildOutput --generateBinLog \" --artifacts $RunDir\\artifacts\\BenchmarkDotNet.Artifacts --packages $RunDir\\performance\\artifacts\\packages --buildTimeout 1200\n```\n\n\u003c/details\u003e\n\n\u003cdetails\u003e\n\n### System.Collections.CopyTo\u0026lt;String\u0026gt;.Array(Size: 2048)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Collections.CopyTo\u0026lt;String\u0026gt;.Memory(Size: 2048)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Collections.CopyTo\u0026lt;String\u0026gt;.Span(Size: 2048)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Collections.CopyTo\u0026lt;String\u0026gt;.ReadOnlySpan(Size: 2048)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Collections.CopyTo\u0026lt;String\u0026gt;.List(Size: 2048)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Collections.CopyTo\u0026lt;String\u0026gt;.ImmutableArray(Size: 2048)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Collections.CopyTo\u0026lt;String\u0026gt;.ReadOnlyMemory(Size: 2048)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n\n\n### Docs\n\n[Profiling workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/profiling-workflow-dotnet-runtime.md)\n[Benchmarking workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/benchmarking-workflow-dotnet-runtime.md)\n\n\u003c/details\u003e\n\r\n\r\n---\r\n\r\n\n### Run Information\n\nName | Value\n-- | --\nArchitecture | x64\nOS | ubuntu 22.04\nQueue | TigerUbuntu\nBaseline | [6927fea7b4bca1dc2cea7a0afba0373c1303cedc](https://github.com/dotnet/runtime/commit/6927fea7b4bca1dc2cea7a0afba0373c1303cedc)\nCompare | [d901213ed6076c0989a2de2626b99c9711442543](https://github.com/dotnet/runtime/commit/d901213ed6076c0989a2de2626b99c9711442543)\nDiff | [Diff](https://github.com/dotnet/runtime/compare/6927fea7b4bca1dc2cea7a0afba0373c1303cedc...d901213ed6076c0989a2de2626b99c9711442543)\nConfigs | CompilationMode:tiered, LLVM:true, MonoAOT:true, MonoInterpreter:false, RunKind:micro_mono\n\n\n### Regressions in System.Numerics.Tests.Perf_BitOperations\n\nBenchmark | Baseline | Test | Test/Base | Test Quality | Edge Detector | Baseline IR | Compare IR | IR Ratio\n-- | -- | -- | -- | -- | -- | -- | -- | --\n|\u003cul\u003e\u003cli\u003e[Log2_uint - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_ubuntu 22.04_LLVM=true_MonoAOT=true_MonoInterpreter=false_RunKind=micro_mono/System.Numerics.Tests.Perf_BitOperations.Log2_uint.html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Numerics.BitOperations/Perf_BitOperations.cs#L43-#L53\u003e)\u003c/li\u003e\u003cli\u003e[ADX - Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACpWUUW/TMBDH35H4Dn5LAlkb2gKlUhDt2GDQbqWLeEGocpNrYhTb0dnemgnx2bHTUtZOGuElsv/5/e/Ozl1mQJVB4CC0evKT3BaAQCaGldkCKknimHiZ1AJ0F43QjIN3SE2QirRoOIS16hZAM9XllIkjcIxpwTSk2mYjTBDf27waeCHxKHK7CPZ0AkpfUg4u5jvvulYaeOfScECWqo57qzpzwPVywvRVBUg1k0J1pjLvLQ0T+m/ehRGnUqxZbnbQN+9U8oqVzW4mM/C+k/gX8TSzeOY9fcw5nX6d/cHRwOPwTAo5vkr+i78QGrBCsM+db01L9Q+jlT4zke0MnKUol9wGu+diCnila/+Beyx10AK7kGpa3vDmI7bhP6kzkTMBbdh5LpO6aocWtWIpLecouXRKW+PHeoUs+1DKFS3ZXaO1sS16i7YZzja2De1oiKZvDzv5VNqxAUxktVsdTkVibdea8oq8JRnV4CbM70W9wUk0OHkxTKLhqN8fvRx0ov6b18Ph8HkUjaLIpVCGc4rsDgjFfMnpxm8CugpC8iwgq/ooQ7ifrNB10hcDBmycCuUPO5UP4AUoU+oYbdWZf+8kW318Ywcvt5H6QUiaUC5wfI4MRFbWe8VdVrNxJaN9B0jcGdOCoia3TBfEV/byQMV7T0g2qSwNF/FxTfVWV/G2CAtqpkuIvff26uy/pN5tnYX4QgVOU1XJdEw3oILf9XpJpe0EAAA=\u003e)\u003c/li\u003e\u003c/ul\u003e | 560.67 ns | 672.56 ns | 1.20 | 0.03 | False | | |\r\n\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Numerics.Tests.Perf_BitOperations_1.png\u003e)\n[Test Report](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Numerics.Tests.Perf_BitOperations.html\u003e)\n\n### Repro\nGeneral Docs link: https://github.com/dotnet/performance/blob/main/docs/benchmarking-workflow-dotnet-runtime.md\n\n\u003cdetails\u003e\n   \u003csummary\u003eRepro Steps\u003c/summary\u003e\n\n\n#### Prerequisites (Files either built locally (with build.(sh/cmd) or downloaded from payload above (if same system setup) (in this order))\n- Libraries build extracted to `runtime/artifacts` or build instructions: [Libraries README](https://github.com/dotnet/runtime/blob/main/docs/workflow/building/libraries/README.md) args: `-subset libs+libs.tests -rc release -configuration Release -arch $RunArch -framework net8.0`\n- CoreCLR product build extracted to `runtime/artifacts/bin/coreclr/$RunOS.$RunArch.Release`, build instructions: [CoreCLR README](https://github.com/dotnet/runtime/blob/main/docs/workflow/building/coreclr/README.md) args: `-subset clr+libs -rc release -configuration Release -arch $RunArch -framework net8.0`\n- AOT MONO build extracted to `runtime/artifacts/bin/mono/$RunOS.$RunArch.Release`, build instructions: [MONO README](https://github.com/dotnet/runtime/blob/main/docs/workflow/building/mono/README.md) args: `-arch $RunArch -os $RunOS -s mono+libs+host+packs -c Release /p:CrossBuild=false /p:MonoLLVMUseCxx11Abi=false`\n- Dotnet SDK installed for dotnet commands\n- Running commands from the runtime folder\n\nLinux\n```cmd\n# Set $RunDir to the runtime directory\nRunDir=`pwd`\n\n# Set the OS, arch, and OSId\nRunOS=\u0027linux\u0027\nRunOSId=\u0027linux\u0027\nRunArch=\u0027x64\u0027\n\n# Create aot directory \nmkdir -p $RunDir/artifacts/bin/aot/sgen\nmkdir -p $RunDir/artifacts/bin/aot/pack\ncp -r $RunDir/artifacts/obj/mono/$RunOS.$RunArch.Release/mono/* $RunDir/artifacts/bin/aot/sgen\ncp -r $RunDir/artifacts/bin/microsoft.netcore.app.runtime.$RunOS-$RunArch/Release/* $RunDir/artifacts/bin/aot/pack\n\n# Create Core Root\n$RunDir/src/tests/build.sh release $RunArch generatelayoutonly /p:LibrariesConfiguration=Release\n\n# Clone performance \ngit clone --branch main --depth 1 --quiet https://github.com/dotnet/performance.git $RunDir/performance\n\n# One line run:\npython3 $RunDir/performance/scripts/benchmarks_ci.py --csproj $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --incremental no --architecture $RunArch -f net8.0 --filter \u0027System.Numerics.Tests.Perf_BitOperations*\u0027 --bdn-artifacts $RunDir/artifacts/BenchmarkDotNet.Artifacts --bdn-arguments=\"--anyCategories Libraries Runtime  --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir/artifacts/bin/aot/sgen/mini/mono-sgen --customruntimepack $RunDir/artifacts/bin/aot/pack --aotcompilermode llvm --logBuildOutput --generateBinLog\"\n\n# Individual Commands:\n# Restore \ndotnet restore $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --packages $RunDir/performance/artifacts/packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Build\ndotnet build $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore /p:NuGetPackageRoot=$RunDir/performance/artifacts/packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Run\ndotnet run --project $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore --no-build -- --filter System.Numerics.Tests.Perf_BitOperations* --anyCategories Libraries Runtime \" --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir/artifacts/bin/aot/sgen/mini/mono-sgen --customruntimepack $RunDir/artifacts/bin/aot/pack --aotcompilermode llvm --logBuildOutput --generateBinLog \" --artifacts $RunDir/artifacts/BenchmarkDotNet.Artifacts --packages $RunDir/performance/artifacts/packages --buildTimeout 1200\n```\n\nWindows\n```cmd\n# Set $RunDir to the runtime directory\n$RunDir=\"FullPathHere\"\n\n# Set the OS, arch, and OSId\nRunOS=\u0027windows\u0027\nRunOSId=\u0027win\u0027\nRunArch=\u0027x64\u0027\n\n# Create aot directory\nmkdir $RunDir\\artifacts\\bin\\aot\\sgen\nmkdir $RunDir\\artifacts\\bin\\aot\\pack\nxcopy $RunDir\\artifacts\\obj\\mono\\$RunOS.$RunArch.Release\\mono $RunDir\\artifacts\\bin\\aot\\sgen\\ /e /y\nxcopy $RunDir\\artifacts\\bin\\microsoft.netcore.app.runtime.$RunOSId-$RunArch\\Release $RunDir\\artifacts\\bin\\aot\\pack\\ /e /y\n\n# Create Core Root\n$RunDir\\src\\tests\\build.cmd release $RunArch generatelayoutonly /p:LibrariesConfiguration=Release\n\n# Clone performance \ngit clone --branch main --depth 1 --quiet https://github.com/dotnet/performance.git $RunDir\\performance\n\n# One line run:\npython3 $RunDir\\performance\\scripts\\benchmarks_ci.py --csproj $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --incremental no --architecture $RunArch -f net8.0 --filter \u0027System.Numerics.Tests.Perf_BitOperations*\u0027 --bdn-artifacts $RunDir\\artifacts\\BenchmarkDotNet.Artifacts --bdn-arguments=\"--anyCategories Libraries Runtime  --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir\\artifacts\\bin\\aot\\sgen\\mini\\mono-sgen.exe --customruntimepack $RunDir\\artifacts\\bin\\aot\\pack --aotcompilermode llvm --logBuildOutput --generateBinLog\"\n\n# Individual Commands:\n# Restore \ndotnet restore $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --packages $RunDir\\performance\\artifacts\\packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Build\ndotnet build $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore /p:NuGetPackageRoot=$RunDir\\performance\\artifacts\\packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Run\ndotnet run --project $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore --no-build -- --filter System.Numerics.Tests.Perf_BitOperations* --anyCategories Libraries Runtime \" --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir\\artifacts\\bin\\aot\\sgen\\mini\\mono-sgen.exe --customruntimepack $RunDir\\artifacts\\bin\\aot\\pack -aotcompilermode llvm --logBuildOutput --generateBinLog \" --artifacts $RunDir\\artifacts\\BenchmarkDotNet.Artifacts --packages $RunDir\\performance\\artifacts\\packages --buildTimeout 1200\n```\n\n\u003c/details\u003e\n\n\u003cdetails\u003e\n\n### System.Numerics.Tests.Perf_BitOperations.Log2_uint\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n\n\n### Docs\n\n[Profiling workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/profiling-workflow-dotnet-runtime.md)\n[Benchmarking workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/benchmarking-workflow-dotnet-runtime.md)\n\n\u003c/details\u003e\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOiEBqQA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6BuyAv",
                                           "createdAt":  "2024-06-18T08:34:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "performanceautofiler",
                                           "body":  "\n### Run Information\n\nName | Value\n-- | --\nArchitecture | x64\nOS | ubuntu 22.04\nQueue | TigerUbuntu\nBaseline | [6927fea7b4bca1dc2cea7a0afba0373c1303cedc](https://github.com/dotnet/runtime/commit/6927fea7b4bca1dc2cea7a0afba0373c1303cedc)\nCompare | [d901213ed6076c0989a2de2626b99c9711442543](https://github.com/dotnet/runtime/commit/d901213ed6076c0989a2de2626b99c9711442543)\nDiff | [Diff](https://github.com/dotnet/runtime/compare/6927fea7b4bca1dc2cea7a0afba0373c1303cedc...d901213ed6076c0989a2de2626b99c9711442543)\nConfigs | CompilationMode:tiered, LLVM:true, MonoAOT:true, MonoInterpreter:false, RunKind:micro_mono\n\n\n### Regressions in System.Perf_Convert\n\nBenchmark | Baseline | Test | Test/Base | Test Quality | Edge Detector | Baseline IR | Compare IR | IR Ratio\n-- | -- | -- | -- | -- | -- | -- | -- | --\n|\u003cul\u003e\u003cli\u003e[ToBase64CharArray - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_ubuntu 22.04_LLVM=true_MonoAOT=true_MonoInterpreter=false_RunKind=micro_mono/System.Perf_Convert.ToBase64CharArray(binaryDataSize%3a%201024%2c%20formattingOptions%3a%20None).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Runtime.Extensions/Perf.Convert.cs#L48-#L53\u003e)\u003c/li\u003e\u003cli\u003e[ADX - Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACpVUUW/aMBB+n7T/4LckW0pTYBQhZRplXdcNWgbRXqYJmeQgnmI7Ol9aUk377XMCY4VKXfYS+S7f993Zvs8T4KZAkKDIvPjJ7lNAYBeFyJIZ5JqFIXMSTQroFAtFQoJziLpAruK0xiGszGkKPDGnkgt1BBxinAqCmGw1JhRznU2v6/jM4SjtwtujIzB0wyVUmu+ceWkIZGsKuFqMtLoDpFakL7iBXneUchwi8tJdCsWxfM+Jz8UDDNhZ0O76bKVRciKh1rc5Ca3MgN1oBd7fzmaFsqIrsS6Q14hvzkjLXGR1NNEJON9Z+Is5JCw8cV4+xxyPv07+wLGA58ETrfTwNvov/LUiwBzBfne8Fc/MP4g29VmoZEeQIka9kFbsEUsYkDmV7hP2UJPXAHatzTi7k/U1N8F/MpdqLexFNMBO1zoq82bQtDQi5tkUtdRVpinxY7lEkVxleskz8VDnmtBm7VnTCpebHNCaR9WTfTjrI22NBRjpfLc69E1kaXPiMmdvWcIJKg+6bTvfJ0H35KwfBf1BpzN4c97q93rn7V7/dRAMgqAqYQopOVo/MI7rheQbtxasOvDZK48ty6MK/t57fjVJXwoowOrkqH9Y3z4Bz8AUGYVou07cRzvZ5ofWqnxtlTqez2qpSjj8gAJUkpX7THVYdVC1jPYfIKv2GFtzE7sXlDLX2MMDE+45PtvEOiukCo97Krd5E26bsEASlEHo2LcB7GtT7sKKwlxlvCpn8kxQyDdgvN/rD90hDwUAAA==\u003e)\u003c/li\u003e\u003c/ul\u003e | 311.15 ns | 1.25 μs | 4.01 | 0.02 | True | | |\r\n|\u003cul\u003e\u003cli\u003e[ToBase64String - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_ubuntu 22.04_LLVM=true_MonoAOT=true_MonoInterpreter=false_RunKind=micro_mono/System.Perf_Convert.ToBase64String(formattingOptions%3a%20None).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Runtime.Extensions/Perf.Convert.cs#L58-#L63\u003e)\u003c/li\u003e\u003cli\u003e[ADX - Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACpWUb4/SQBDG35v4HfZdW+WgAuJBUiPgnZ7CHULjG2PI0g50TXe3mZ3e0Yvxs7stiAeXnPVNs/v098zM/pmdAjc5ggRF5tlPdpcAAhvlIo3nkGkWBMyJNSmgFuaKhATnmBohV1FScQhr00qAx6YluVAn4BCjRBBEZLMxoZjrbHtdp8EcjtIOvAMdgqFrLqGM+c5ZFIZANmeA6+VYq1tAaoZ6xA30ugtCoTbuWqPkRHZ4k5HQygzYtVbg/S1gnivrXYtNjrwivjljLTORVrOpjsH5zoJfzCFh8dh5/pRzMvk6/YNjDk/DU6308Cb8L/5KEWCGYL9735qn5h9GK30WKt4bpIhQL6UN9sAlDMiMCveRe6jJq4FdaTNJb2V1mnX4T+ZCbYQ9iBrsbKPDIquHJoUREU9nqKUulbrGj8UKRfwh1SueivtKq2Obt+d1M1xsM0DbI6q6wMdXeqxt/wCGOtuPjtsjtLYFcZmxtyzmBGWruW2/3T3zu2evzkP/fNDpDF6/afb7vV6n33vp+wPfL1OYXEqO4h4Yx81S8q1bBSwraLAXHlsVJxkahxZrlDfpSw452DgZ6h+2PR/BczB5SgHaqmP3wUp2+tB2JN/YSB2vwapQZeDgEgWoOC0OSrlZ1aQsGe0/QFauMUo4ErsTlDDX2M0DExw8DbaNdJpLFZzWVOx0E+yKsCAJSiFw3tuts49KsZ+WFuYq45WayVJBAd+C8X4DlDEbsPYEAAA=\u003e)\u003c/li\u003e\u003c/ul\u003e | 597.60 ns | 1.59 μs | 2.66 | 0.03 | False | | |\r\n\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Perf_Convert_1.png\u003e)\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Perf_Convert_2.png\u003e)\n[Test Report](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Perf_Convert.html\u003e)\n\n### Repro\nGeneral Docs link: https://github.com/dotnet/performance/blob/main/docs/benchmarking-workflow-dotnet-runtime.md\n\n\u003cdetails\u003e\n   \u003csummary\u003eRepro Steps\u003c/summary\u003e\n\n\n#### Prerequisites (Files either built locally (with build.(sh/cmd) or downloaded from payload above (if same system setup) (in this order))\n- Libraries build extracted to `runtime/artifacts` or build instructions: [Libraries README](https://github.com/dotnet/runtime/blob/main/docs/workflow/building/libraries/README.md) args: `-subset libs+libs.tests -rc release -configuration Release -arch $RunArch -framework net8.0`\n- CoreCLR product build extracted to `runtime/artifacts/bin/coreclr/$RunOS.$RunArch.Release`, build instructions: [CoreCLR README](https://github.com/dotnet/runtime/blob/main/docs/workflow/building/coreclr/README.md) args: `-subset clr+libs -rc release -configuration Release -arch $RunArch -framework net8.0`\n- AOT MONO build extracted to `runtime/artifacts/bin/mono/$RunOS.$RunArch.Release`, build instructions: [MONO README](https://github.com/dotnet/runtime/blob/main/docs/workflow/building/mono/README.md) args: `-arch $RunArch -os $RunOS -s mono+libs+host+packs -c Release /p:CrossBuild=false /p:MonoLLVMUseCxx11Abi=false`\n- Dotnet SDK installed for dotnet commands\n- Running commands from the runtime folder\n\nLinux\n```cmd\n# Set $RunDir to the runtime directory\nRunDir=`pwd`\n\n# Set the OS, arch, and OSId\nRunOS=\u0027linux\u0027\nRunOSId=\u0027linux\u0027\nRunArch=\u0027x64\u0027\n\n# Create aot directory \nmkdir -p $RunDir/artifacts/bin/aot/sgen\nmkdir -p $RunDir/artifacts/bin/aot/pack\ncp -r $RunDir/artifacts/obj/mono/$RunOS.$RunArch.Release/mono/* $RunDir/artifacts/bin/aot/sgen\ncp -r $RunDir/artifacts/bin/microsoft.netcore.app.runtime.$RunOS-$RunArch/Release/* $RunDir/artifacts/bin/aot/pack\n\n# Create Core Root\n$RunDir/src/tests/build.sh release $RunArch generatelayoutonly /p:LibrariesConfiguration=Release\n\n# Clone performance \ngit clone --branch main --depth 1 --quiet https://github.com/dotnet/performance.git $RunDir/performance\n\n# One line run:\npython3 $RunDir/performance/scripts/benchmarks_ci.py --csproj $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --incremental no --architecture $RunArch -f net8.0 --filter \u0027System.Perf_Convert*\u0027 --bdn-artifacts $RunDir/artifacts/BenchmarkDotNet.Artifacts --bdn-arguments=\"--anyCategories Libraries Runtime  --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir/artifacts/bin/aot/sgen/mini/mono-sgen --customruntimepack $RunDir/artifacts/bin/aot/pack --aotcompilermode llvm --logBuildOutput --generateBinLog\"\n\n# Individual Commands:\n# Restore \ndotnet restore $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --packages $RunDir/performance/artifacts/packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Build\ndotnet build $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore /p:NuGetPackageRoot=$RunDir/performance/artifacts/packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Run\ndotnet run --project $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore --no-build -- --filter System.Perf_Convert* --anyCategories Libraries Runtime \" --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir/artifacts/bin/aot/sgen/mini/mono-sgen --customruntimepack $RunDir/artifacts/bin/aot/pack --aotcompilermode llvm --logBuildOutput --generateBinLog \" --artifacts $RunDir/artifacts/BenchmarkDotNet.Artifacts --packages $RunDir/performance/artifacts/packages --buildTimeout 1200\n```\n\nWindows\n```cmd\n# Set $RunDir to the runtime directory\n$RunDir=\"FullPathHere\"\n\n# Set the OS, arch, and OSId\nRunOS=\u0027windows\u0027\nRunOSId=\u0027win\u0027\nRunArch=\u0027x64\u0027\n\n# Create aot directory\nmkdir $RunDir\\artifacts\\bin\\aot\\sgen\nmkdir $RunDir\\artifacts\\bin\\aot\\pack\nxcopy $RunDir\\artifacts\\obj\\mono\\$RunOS.$RunArch.Release\\mono $RunDir\\artifacts\\bin\\aot\\sgen\\ /e /y\nxcopy $RunDir\\artifacts\\bin\\microsoft.netcore.app.runtime.$RunOSId-$RunArch\\Release $RunDir\\artifacts\\bin\\aot\\pack\\ /e /y\n\n# Create Core Root\n$RunDir\\src\\tests\\build.cmd release $RunArch generatelayoutonly /p:LibrariesConfiguration=Release\n\n# Clone performance \ngit clone --branch main --depth 1 --quiet https://github.com/dotnet/performance.git $RunDir\\performance\n\n# One line run:\npython3 $RunDir\\performance\\scripts\\benchmarks_ci.py --csproj $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --incremental no --architecture $RunArch -f net8.0 --filter \u0027System.Perf_Convert*\u0027 --bdn-artifacts $RunDir\\artifacts\\BenchmarkDotNet.Artifacts --bdn-arguments=\"--anyCategories Libraries Runtime  --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir\\artifacts\\bin\\aot\\sgen\\mini\\mono-sgen.exe --customruntimepack $RunDir\\artifacts\\bin\\aot\\pack --aotcompilermode llvm --logBuildOutput --generateBinLog\"\n\n# Individual Commands:\n# Restore \ndotnet restore $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --packages $RunDir\\performance\\artifacts\\packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Build\ndotnet build $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore /p:NuGetPackageRoot=$RunDir\\performance\\artifacts\\packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Run\ndotnet run --project $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore --no-build -- --filter System.Perf_Convert* --anyCategories Libraries Runtime \" --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir\\artifacts\\bin\\aot\\sgen\\mini\\mono-sgen.exe --customruntimepack $RunDir\\artifacts\\bin\\aot\\pack -aotcompilermode llvm --logBuildOutput --generateBinLog \" --artifacts $RunDir\\artifacts\\BenchmarkDotNet.Artifacts --packages $RunDir\\performance\\artifacts\\packages --buildTimeout 1200\n```\n\n\u003c/details\u003e\n\n\u003cdetails\u003e\n\n### System.Perf_Convert.ToBase64CharArray(binaryDataSize: 1024, formattingOptions: None)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Perf_Convert.ToBase64String(formattingOptions: None)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n\n\n### Docs\n\n[Profiling workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/profiling-workflow-dotnet-runtime.md)\n[Benchmarking workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/benchmarking-workflow-dotnet-runtime.md)\n\n\u003c/details\u003e\n\r\n\r\n---\r\n\r\n\n### Run Information\n\nName | Value\n-- | --\nArchitecture | x64\nOS | ubuntu 22.04\nQueue | TigerUbuntu\nBaseline | [6927fea7b4bca1dc2cea7a0afba0373c1303cedc](https://github.com/dotnet/runtime/commit/6927fea7b4bca1dc2cea7a0afba0373c1303cedc)\nCompare | [d901213ed6076c0989a2de2626b99c9711442543](https://github.com/dotnet/runtime/commit/d901213ed6076c0989a2de2626b99c9711442543)\nDiff | [Diff](https://github.com/dotnet/runtime/compare/6927fea7b4bca1dc2cea7a0afba0373c1303cedc...d901213ed6076c0989a2de2626b99c9711442543)\nConfigs | CompilationMode:tiered, LLVM:true, MonoAOT:true, MonoInterpreter:false, RunKind:micro_mono\n\n\n### Regressions in System.Buffers.Text.Tests.Base64Tests\n\nBenchmark | Baseline | Test | Test/Base | Test Quality | Edge Detector | Baseline IR | Compare IR | IR Ratio\n-- | -- | -- | -- | -- | -- | -- | -- | --\n|\u003cul\u003e\u003cli\u003e[Base64Decode - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_ubuntu 22.04_LLVM=true_MonoAOT=true_MonoInterpreter=false_RunKind=micro_mono/System.Buffers.Text.Tests.Base64Tests.Base64Decode(NumberOfBytes%3a%201000).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Buffers/Base64Tests.cs#L59-#L60\u003e)\u003c/li\u003e\u003cli\u003e[ADX - Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACpWUUW/TMBDH35H4Dn5LAl2bblVVKgXRdgMG7Ta6iBeEJje5NkaxHd3ZWzMhPjtOWkrbSSO8WPbl9//77Nx5BpwsggRl6MVP9pABAhtbkadzKDSLIual2igwHbTKCAneITVGrpKs5hCW1MmAp9SRXKgjcIRJJgwkxu3GhGK+t+73vBbzOEo3CXZ0DGSuuITK8513W5IB2R7b5RKQ2jGsjRvIUHvMCfq9/fk5JDoF/8rKBeD1clwaoCHrhmEY/E1mbtVEq6VYWeRGaEXfvImWhcjr1cwZeN9Z9It5Rjg89V4+p5xOv87+4GjheXimlR5dx//FXyoDWCC4catb8pz+IXShz0KlW4EUCeo76cz2VIJAFqb0n6hH2gQNsEtN0/xe1n+2Cf+JLtRKKGjC3qx0XBbN0KwkkfD8BrXUVaSp8GO5QJF+yPWC5+KxjjWRzU/nTXe4WBeArl9UXcyH5T3RrpcAY11sZ4etEjvZreGyYG9Zyg1Ubeefhqe9k7B30h3E4WB41ht2B+3Bm16/O+i+DsOhq3FnQlZKjuIRGMfVneRrvzasMmixVwFblEc7tHbt1qoq6YsFC86nQP3DteoTeA5kcxOhyzr1906yiY/uAfnKOZ0FLVZbVcbRexSg0rzcRarLqhdVyui+AbLqjEnG0bAHYTLmk7s8oGinabF1onMrVXScU7mJU7RJwoFGmBwi79xdnXtgyu2ykjBfUVDFqMiFifgaKPgNO/JUgQIFAAA=\u003e)\u003c/li\u003e\u003c/ul\u003e | 188.52 ns | 648.04 ns | 3.44 | 0.01 | True | | |\r\n|\u003cul\u003e\u003cli\u003e[ConvertToBase64CharArray - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_ubuntu 22.04_LLVM=true_MonoAOT=true_MonoInterpreter=false_RunKind=micro_mono/System.Buffers.Text.Tests.Base64Tests.ConvertToBase64CharArray(NumberOfBytes%3a%201000).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Buffers/Base64Tests.cs#L49-#L50\u003e)\u003c/li\u003e\u003cli\u003e[ADX - Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACpVUXW/TMBR9R+I/+C0JdG36wRiVgmjLBoN2G13EC0KTm9w2RrEdXV9vzYT47ThpKWsnjfBi2SfnHF8793gG3FgECYrMs5/sLgMENrYiT+dQaBZFzEs1KaAOWkVCgrfPGiNXSVbzEJamkwFPTUdyoQ6II0wyQZCQ240JxXxvfTzwWszjKN0k2LFjMHTBJVSe77zr0hDI9tgul4CmHcOa3GDItMfcwPFgM59odQtIsd6Ak4zjCJGX/oWVC8DL5bgkMEPWDcMw+FvY3CqnXIqVRU5CK/PNm2hZiLxezXQK3ncW/WIeCUdPvedPKafTr7M/dLTwNHmmlR5dxv/FP1cEWCC4catb8tz8Q+igz0KlW4EUCeob6cweqIQBWVDpP1KPNAUNaOfaTPNbWf/lJvxP5lSthIIm3KuVjsuiGTUrjUh4foVa6gppKvxYLlCkH3K94Lm4r7Emsnlv3nSH03UB6LKj6sbeb/WJdrkCjHWxne3HJnaya+KyYG9ZygmqCPq9sDc4CgdH3ZM4PBn2B8Pum3b4Kuy/Dvsvw3DoetyZGCslR3EPjOPqRvK1XxtWFbTYi4AtyoMdWrvotapO+mLBgvMpUP9wsX1EnoOxOUXoqk79ByfZ4COXR75yTv2gxWqryjg6QwEqzcsdUl1WvahKRvcNkFVnTFyEid0Jyphv3OWBiXaaFlsnOrdSRYc1lRvcRJsiHJEE5RB5793Vucem3C4rCfOVCSrMFLmgiK/BBL8BYBDefA4FAAA=\u003e)\u003c/li\u003e\u003c/ul\u003e | 314.35 ns | 1.22 μs | 3.87 | 0.02 | True | | |\r\n|\u003cul\u003e\u003cli\u003e[Base64Encode - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_ubuntu 22.04_LLVM=true_MonoAOT=true_MonoInterpreter=false_RunKind=micro_mono/System.Buffers.Text.Tests.Base64Tests.Base64Encode(NumberOfBytes%3a%201000).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Buffers/Base64Tests.cs#L29-#L30\u003e)\u003c/li\u003e\u003cli\u003e[ADX - Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACpWUUW/TMBDH35H4Dn5LAl2XdqXaKgXRjjIG7Ta6iBeEJje5NkaxHd3ZWzMhPjtOWkrbSSO8WPbl9//77Nx5CpwsggRl6MVP9pABAhtZkaczKDSLIual2igwx2iVERK8fWqEXCVZzSEs6DgDntKx5EIdgENMMmEgMW43JhTzvVW/57WYx1G6SbClYyBzxSVUnu+825IMyPbILhaA1I5hZdxAhtojTtDv7c7HKtEp+FdWzgGvF6PSAA1YJwzD4G8yM6vOtVqIpUVuhFb0zTvXshB5vZo6A+87i34xzwiHp97L55STydfpHxwtPA9PtdLD6/i/+EtlAAsEN250C57TP4Qu9FmodCOQIkF9J53ZjkoQyMKU/hP1UJugAXapaZLfy/rPNuE/0VgthYIm7M1Sx2XRDM1KEgnPb1BLXUWaCj+WcxTpRa7nPBePdayJbNadNd1hvCoAXb+oupj3y/tcu14CjHWxme23Suxkt4bLgr1lKTdQtZ3fDbu9o7B31DmNw9PBSW/QOWt3zk77J703r8Nw4GrcmZCVkqN4BMZxeSf5yq8Nqwxa7FXA5uXBDq1tu7WqSvpiwYLzKVD/cK36BJ4B2dxE6LJO/Z2TrOPDe0C+dE4nQYvVVpVx9AEFqDQvt5HqsupFlTK6b4CsOmOScTTsQZiM+eQuDyjaalpslejcShUd5lSu4xStk3CgESaHyHvvrs49MOVmWUmYryioYlTkwkR8BRT8Bo1t7q0CBQAA\u003e)\u003c/li\u003e\u003c/ul\u003e | 136.38 ns | 1.04 μs | 7.65 | 0.01 | True | | |\r\n|\u003cul\u003e\u003cli\u003e[Base64EncodeDestinationTooSmall - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_ubuntu 22.04_LLVM=true_MonoAOT=true_MonoInterpreter=false_RunKind=micro_mono/System.Buffers.Text.Tests.Base64Tests.Base64EncodeDestinationTooSmall(NumberOfBytes%3a%201000).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Buffers/Base64Tests.cs#L39-#L40\u003e)\u003c/li\u003e\u003cli\u003e[ADX - Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACpWUb2/TMBDG3yPxHfwuCXRdupapVAqi3cYYrNvoIt4gNLnJtTHyn+jO3poJ8dlxslLWThrhjWVffs/js3PnKXByCAq0pRc/2V0BCGzihMxnUBqWJCzIjdVg99FpKxQE29QEuc6KhkNY0H4BPKd9xYXeAceYFcJCZv1uTGgWBqvDQdBhAUflJ9GGToHsBVdQe74PriuyoLoTt1gAUjeFlfUDWepOOMHh4PH8RGcmh2MfEZpbYXRqzLXiUoYXTs0BLxeTygKNWC+O4+hvfjOnj4xeiKXDRkbfgiOjSiGb1dR7Bt9Z8osFVng8D14+pzw//zr9g6OD5+Gp0WZ8mf4Xf6YtYIngx7VuwSX9Q+hDn4XO1wIlMjQ3yps9UgkCVdoqfKIeGxu1wM4Mnctb1fzsNvwnOtFLoaENe7U0aVW2Q4uKRMblFRplmiJoKfxYzVHkp9LMuRT3TayNbHYwa7vDyaoE9C2km/rervgj49sLMDXlerbdPamXXVuuSvaO5dxC3YnhQXww2IsHe71hGg9H/cGo97bb78e9ePjmdRyPfI17E3JKcRT3wDgubxRfhY1hnUGHvYrYvNrZobPpwE5dSV8cOPA+JZofvnufwDMgJ22CPus8fHSSh/j4FpAvvVM/6rDGqjZOPqAAnctqE6kvq1nUKaP/BsjqM2YFR8vuhC1YSP7ygJKNpsNWmZFO6WQ3p+ohTslDEh60wkpIgmN/df7NqdbLWsJCTVEdo1IKm/AVUPQbTPo52RUFAAA=\u003e)\u003c/li\u003e\u003c/ul\u003e | 145.10 ns | 1.04 μs | 7.15 | 0.02 | True | | |\r\n|\u003cul\u003e\u003cli\u003e[Base64DecodeDestinationTooSmall - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_ubuntu 22.04_LLVM=true_MonoAOT=true_MonoInterpreter=false_RunKind=micro_mono/System.Buffers.Text.Tests.Base64Tests.Base64DecodeDestinationTooSmall(NumberOfBytes%3a%201000).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Buffers/Base64Tests.cs#L69-#L71\u003e)\u003c/li\u003e\u003cli\u003e[ADX - Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACpWUb2/TMBDG3yPxHfwuCXRdupZqVAqi3cYYrNvoIt4gNLnJtTHyn+jO3poJ8dlxslLWThrhjWVffs/js3PnKXByCAq0pRc/2V0BCGzihMxnUBqWJCzIjdVg99FpKxQE29QEuc6KhkNY0H4BPKd9xYXeAceYFcJCZv1uTGgWBqvhIOiwgKPyk2hDp0D2giuoPd8H1xVZUN2JWywAqZvCyvqBLHUnnGA4eDw/hszkcOwjQnMrjE6NuVZcyvDCqTng5WJSWaAR68VxHP3Nb+b0kdELsXTYyOhbcGRUKWSzmnrP4DtLfrHACo/nwcvnlOfnX6d/cHTwPDw12owv0//iz7QFLBH8uNYtuKR/CH3os9D5WqBEhuZGebNHKkGgSluFT9RjY6MW2Jmhc3mrmp/dhv9EJ3opNLRhr5Ymrcp2aFGRyLi8QqNMUwQthR+rOYr8VJo5l+K+ibWRzQ5mbXc4WZWAvoV0U9/bFX9kfHsBpqZcz7a7J/Wya8tVyd6xnFuoOzE8iA8Ge/Fgr3eYxoej/mDUe9sdvBkOe73+6zge+Rr3JuSU4ijugXFc3ii+ChvDOoMOexWxebWzQ2fTgZ26kr44cOB9SjQ/fPc+gWdATtoEfdZ5+OgkD/HxLSBfeqd+1GGNVW2cfEABOpfVJlJfVrOoU0b/DZDVZ8wKjpbdCVuwkPzlASUbTYetMiOd0sluTtVDnJKHJDxohZWQBMf+6vybU62XtYSFmqI6RqUUNuEroOg38lev6RUFAAA=\u003e)\u003c/li\u003e\u003c/ul\u003e | 185.81 ns | 656.56 ns | 3.53 | 0.01 | True | | |\r\n\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Buffers.Text.Tests.Base64Tests_1.png\u003e)\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Buffers.Text.Tests.Base64Tests_2.png\u003e)\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Buffers.Text.Tests.Base64Tests_3.png\u003e)\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Buffers.Text.Tests.Base64Tests_4.png\u003e)\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Buffers.Text.Tests.Base64Tests_5.png\u003e)\n[Test Report](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Buffers.Text.Tests.Base64Tests.html\u003e)\n\n### Repro\nGeneral Docs link: https://github.com/dotnet/performance/blob/main/docs/benchmarking-workflow-dotnet-runtime.md\n\n\u003cdetails\u003e\n   \u003csummary\u003eRepro Steps\u003c/summary\u003e\n\n\n#### Prerequisites (Files either built locally (with build.(sh/cmd) or downloaded from payload above (if same system setup) (in this order))\n- Libraries build extracted to `runtime/artifacts` or build instructions: [Libraries README](https://github.com/dotnet/runtime/blob/main/docs/workflow/building/libraries/README.md) args: `-subset libs+libs.tests -rc release -configuration Release -arch $RunArch -framework net8.0`\n- CoreCLR product build extracted to `runtime/artifacts/bin/coreclr/$RunOS.$RunArch.Release`, build instructions: [CoreCLR README](https://github.com/dotnet/runtime/blob/main/docs/workflow/building/coreclr/README.md) args: `-subset clr+libs -rc release -configuration Release -arch $RunArch -framework net8.0`\n- AOT MONO build extracted to `runtime/artifacts/bin/mono/$RunOS.$RunArch.Release`, build instructions: [MONO README](https://github.com/dotnet/runtime/blob/main/docs/workflow/building/mono/README.md) args: `-arch $RunArch -os $RunOS -s mono+libs+host+packs -c Release /p:CrossBuild=false /p:MonoLLVMUseCxx11Abi=false`\n- Dotnet SDK installed for dotnet commands\n- Running commands from the runtime folder\n\nLinux\n```cmd\n# Set $RunDir to the runtime directory\nRunDir=`pwd`\n\n# Set the OS, arch, and OSId\nRunOS=\u0027linux\u0027\nRunOSId=\u0027linux\u0027\nRunArch=\u0027x64\u0027\n\n# Create aot directory \nmkdir -p $RunDir/artifacts/bin/aot/sgen\nmkdir -p $RunDir/artifacts/bin/aot/pack\ncp -r $RunDir/artifacts/obj/mono/$RunOS.$RunArch.Release/mono/* $RunDir/artifacts/bin/aot/sgen\ncp -r $RunDir/artifacts/bin/microsoft.netcore.app.runtime.$RunOS-$RunArch/Release/* $RunDir/artifacts/bin/aot/pack\n\n# Create Core Root\n$RunDir/src/tests/build.sh release $RunArch generatelayoutonly /p:LibrariesConfiguration=Release\n\n# Clone performance \ngit clone --branch main --depth 1 --quiet https://github.com/dotnet/performance.git $RunDir/performance\n\n# One line run:\npython3 $RunDir/performance/scripts/benchmarks_ci.py --csproj $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --incremental no --architecture $RunArch -f net8.0 --filter \u0027System.Buffers.Text.Tests.Base64Tests*\u0027 --bdn-artifacts $RunDir/artifacts/BenchmarkDotNet.Artifacts --bdn-arguments=\"--anyCategories Libraries Runtime  --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir/artifacts/bin/aot/sgen/mini/mono-sgen --customruntimepack $RunDir/artifacts/bin/aot/pack --aotcompilermode llvm --logBuildOutput --generateBinLog\"\n\n# Individual Commands:\n# Restore \ndotnet restore $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --packages $RunDir/performance/artifacts/packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Build\ndotnet build $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore /p:NuGetPackageRoot=$RunDir/performance/artifacts/packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Run\ndotnet run --project $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore --no-build -- --filter System.Buffers.Text.Tests.Base64Tests* --anyCategories Libraries Runtime \" --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir/artifacts/bin/aot/sgen/mini/mono-sgen --customruntimepack $RunDir/artifacts/bin/aot/pack --aotcompilermode llvm --logBuildOutput --generateBinLog \" --artifacts $RunDir/artifacts/BenchmarkDotNet.Artifacts --packages $RunDir/performance/artifacts/packages --buildTimeout 1200\n```\n\nWindows\n```cmd\n# Set $RunDir to the runtime directory\n$RunDir=\"FullPathHere\"\n\n# Set the OS, arch, and OSId\nRunOS=\u0027windows\u0027\nRunOSId=\u0027win\u0027\nRunArch=\u0027x64\u0027\n\n# Create aot directory\nmkdir $RunDir\\artifacts\\bin\\aot\\sgen\nmkdir $RunDir\\artifacts\\bin\\aot\\pack\nxcopy $RunDir\\artifacts\\obj\\mono\\$RunOS.$RunArch.Release\\mono $RunDir\\artifacts\\bin\\aot\\sgen\\ /e /y\nxcopy $RunDir\\artifacts\\bin\\microsoft.netcore.app.runtime.$RunOSId-$RunArch\\Release $RunDir\\artifacts\\bin\\aot\\pack\\ /e /y\n\n# Create Core Root\n$RunDir\\src\\tests\\build.cmd release $RunArch generatelayoutonly /p:LibrariesConfiguration=Release\n\n# Clone performance \ngit clone --branch main --depth 1 --quiet https://github.com/dotnet/performance.git $RunDir\\performance\n\n# One line run:\npython3 $RunDir\\performance\\scripts\\benchmarks_ci.py --csproj $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --incremental no --architecture $RunArch -f net8.0 --filter \u0027System.Buffers.Text.Tests.Base64Tests*\u0027 --bdn-artifacts $RunDir\\artifacts\\BenchmarkDotNet.Artifacts --bdn-arguments=\"--anyCategories Libraries Runtime  --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir\\artifacts\\bin\\aot\\sgen\\mini\\mono-sgen.exe --customruntimepack $RunDir\\artifacts\\bin\\aot\\pack --aotcompilermode llvm --logBuildOutput --generateBinLog\"\n\n# Individual Commands:\n# Restore \ndotnet restore $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --packages $RunDir\\performance\\artifacts\\packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Build\ndotnet build $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore /p:NuGetPackageRoot=$RunDir\\performance\\artifacts\\packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Run\ndotnet run --project $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore --no-build -- --filter System.Buffers.Text.Tests.Base64Tests* --anyCategories Libraries Runtime \" --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir\\artifacts\\bin\\aot\\sgen\\mini\\mono-sgen.exe --customruntimepack $RunDir\\artifacts\\bin\\aot\\pack -aotcompilermode llvm --logBuildOutput --generateBinLog \" --artifacts $RunDir\\artifacts\\BenchmarkDotNet.Artifacts --packages $RunDir\\performance\\artifacts\\packages --buildTimeout 1200\n```\n\n\u003c/details\u003e\n\n\u003cdetails\u003e\n\n### System.Buffers.Text.Tests.Base64Tests.Base64Decode(NumberOfBytes: 1000)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Buffers.Text.Tests.Base64Tests.ConvertToBase64CharArray(NumberOfBytes: 1000)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Buffers.Text.Tests.Base64Tests.Base64Encode(NumberOfBytes: 1000)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Buffers.Text.Tests.Base64Tests.Base64EncodeDestinationTooSmall(NumberOfBytes: 1000)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Buffers.Text.Tests.Base64Tests.Base64DecodeDestinationTooSmall(NumberOfBytes: 1000)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n\n\n### Docs\n\n[Profiling workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/profiling-workflow-dotnet-runtime.md)\n[Benchmarking workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/benchmarking-workflow-dotnet-runtime.md)\n\n\u003c/details\u003e\n\r\n\r\n---\r\n\r\n\n### Run Information\n\nName | Value\n-- | --\nArchitecture | x64\nOS | ubuntu 22.04\nQueue | TigerUbuntu\nBaseline | [6927fea7b4bca1dc2cea7a0afba0373c1303cedc](https://github.com/dotnet/runtime/commit/6927fea7b4bca1dc2cea7a0afba0373c1303cedc)\nCompare | [d901213ed6076c0989a2de2626b99c9711442543](https://github.com/dotnet/runtime/commit/d901213ed6076c0989a2de2626b99c9711442543)\nDiff | [Diff](https://github.com/dotnet/runtime/compare/6927fea7b4bca1dc2cea7a0afba0373c1303cedc...d901213ed6076c0989a2de2626b99c9711442543)\nConfigs | CompilationMode:tiered, LLVM:true, MonoAOT:true, MonoInterpreter:false, RunKind:micro_mono\n\n\n### Regressions in System.Memory.Span\u0026lt;Char\u0026gt;\n\nBenchmark | Baseline | Test | Test/Base | Test Quality | Edge Detector | Baseline IR | Compare IR | IR Ratio\n-- | -- | -- | -- | -- | -- | -- | -- | --\n|\u003cul\u003e\u003cli\u003e[LastIndexOfAnyValues - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_ubuntu 22.04_LLVM=true_MonoAOT=true_MonoInterpreter=false_RunKind=micro_mono/System.Memory.Span(Char).LastIndexOfAnyValues(Size%3a%20512).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Memory/Span.cs#L96-#L97\u003e)\u003c/li\u003e\u003cli\u003e[ADX - Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACpVUXW/TMBR9R+I/+C0JZG36samqyERXBhRaNtpoLwhNbnLbGPkjura3ZkL8dpy0lLWTRniJ7JNzzr127skMqLYIAqTRL36S+xwQyIVlPJtDoUgcEy9TRoJpo5WGCfAOWRdIZZrXPISVbudAM90WlMkj4gjTnBlIjatGmCS+tznreyHxKAq3CPbsBLT5QgVUnm+9RakNiNYMhMKytSiofDPOKZ63plSbicxgc7UayfKGcgvaX7AHGJLTTjf4W31u5VjJFVtbpIYpqb95YyUKxuvdTGXgfSfxL+IZ5uiZ9/I55XR6M/tDRwvPk2dKqtFV8l/8iTSABYJ77nQryvU/hA76zGS2EwiWoroVzuyRimkQhSn9J+qRMkED2kTpKb8T9adswv+kL+WaSWjCvV6rpCyaUfNSs5Tya1RCVUhT4cdyiSz7wNWScvZQY01k8+68aYXLTQHoAiLr6T2c57Fy4QFMVLFbHWYjcbKFoaIg5ySjBqqc+d2o2z+J+iedQRINhr3+sNdpDXq97unZ4HUUDaOoKqGtEBTd1BOK61tBN35tWHUQklcBWZZHFcJ9vsJqkr5asOB8ClQ/XDafkOegLTcxuq4z/9FJtvjoDpCunVMvCEltVRnH75GBzHi5R6rLqjdVy+jeAZLqjKlLsiH3zOTE1+7yQMd7TUg2qeJWyPi4p3KL63jbhCMaZjjE3jt3de6PUu62lYT4UgcVpgvOTEw3oIPfmJ+akvMEAAA=\u003e)\u003c/li\u003e\u003c/ul\u003e | 82.27 ns | 89.85 ns | 1.09 | 0.06 | False | | |\r\n\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Memory.Span%28Char%29_1.png\u003e)\n[Test Report](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Memory.Span%28Char%29.html\u003e)\n\n### Repro\nGeneral Docs link: https://github.com/dotnet/performance/blob/main/docs/benchmarking-workflow-dotnet-runtime.md\n\n\u003cdetails\u003e\n   \u003csummary\u003eRepro Steps\u003c/summary\u003e\n\n\n#### Prerequisites (Files either built locally (with build.(sh/cmd) or downloaded from payload above (if same system setup) (in this order))\n- Libraries build extracted to `runtime/artifacts` or build instructions: [Libraries README](https://github.com/dotnet/runtime/blob/main/docs/workflow/building/libraries/README.md) args: `-subset libs+libs.tests -rc release -configuration Release -arch $RunArch -framework net8.0`\n- CoreCLR product build extracted to `runtime/artifacts/bin/coreclr/$RunOS.$RunArch.Release`, build instructions: [CoreCLR README](https://github.com/dotnet/runtime/blob/main/docs/workflow/building/coreclr/README.md) args: `-subset clr+libs -rc release -configuration Release -arch $RunArch -framework net8.0`\n- AOT MONO build extracted to `runtime/artifacts/bin/mono/$RunOS.$RunArch.Release`, build instructions: [MONO README](https://github.com/dotnet/runtime/blob/main/docs/workflow/building/mono/README.md) args: `-arch $RunArch -os $RunOS -s mono+libs+host+packs -c Release /p:CrossBuild=false /p:MonoLLVMUseCxx11Abi=false`\n- Dotnet SDK installed for dotnet commands\n- Running commands from the runtime folder\n\nLinux\n```cmd\n# Set $RunDir to the runtime directory\nRunDir=`pwd`\n\n# Set the OS, arch, and OSId\nRunOS=\u0027linux\u0027\nRunOSId=\u0027linux\u0027\nRunArch=\u0027x64\u0027\n\n# Create aot directory \nmkdir -p $RunDir/artifacts/bin/aot/sgen\nmkdir -p $RunDir/artifacts/bin/aot/pack\ncp -r $RunDir/artifacts/obj/mono/$RunOS.$RunArch.Release/mono/* $RunDir/artifacts/bin/aot/sgen\ncp -r $RunDir/artifacts/bin/microsoft.netcore.app.runtime.$RunOS-$RunArch/Release/* $RunDir/artifacts/bin/aot/pack\n\n# Create Core Root\n$RunDir/src/tests/build.sh release $RunArch generatelayoutonly /p:LibrariesConfiguration=Release\n\n# Clone performance \ngit clone --branch main --depth 1 --quiet https://github.com/dotnet/performance.git $RunDir/performance\n\n# One line run:\npython3 $RunDir/performance/scripts/benchmarks_ci.py --csproj $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --incremental no --architecture $RunArch -f net8.0 --filter \u0027System.Memory.Span\u0026lt;Char\u0026gt;*\u0027 --bdn-artifacts $RunDir/artifacts/BenchmarkDotNet.Artifacts --bdn-arguments=\"--anyCategories Libraries Runtime  --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir/artifacts/bin/aot/sgen/mini/mono-sgen --customruntimepack $RunDir/artifacts/bin/aot/pack --aotcompilermode llvm --logBuildOutput --generateBinLog\"\n\n# Individual Commands:\n# Restore \ndotnet restore $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --packages $RunDir/performance/artifacts/packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Build\ndotnet build $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore /p:NuGetPackageRoot=$RunDir/performance/artifacts/packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Run\ndotnet run --project $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore --no-build -- --filter System.Memory.Span\u0026lt;Char\u0026gt;* --anyCategories Libraries Runtime \" --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir/artifacts/bin/aot/sgen/mini/mono-sgen --customruntimepack $RunDir/artifacts/bin/aot/pack --aotcompilermode llvm --logBuildOutput --generateBinLog \" --artifacts $RunDir/artifacts/BenchmarkDotNet.Artifacts --packages $RunDir/performance/artifacts/packages --buildTimeout 1200\n```\n\nWindows\n```cmd\n# Set $RunDir to the runtime directory\n$RunDir=\"FullPathHere\"\n\n# Set the OS, arch, and OSId\nRunOS=\u0027windows\u0027\nRunOSId=\u0027win\u0027\nRunArch=\u0027x64\u0027\n\n# Create aot directory\nmkdir $RunDir\\artifacts\\bin\\aot\\sgen\nmkdir $RunDir\\artifacts\\bin\\aot\\pack\nxcopy $RunDir\\artifacts\\obj\\mono\\$RunOS.$RunArch.Release\\mono $RunDir\\artifacts\\bin\\aot\\sgen\\ /e /y\nxcopy $RunDir\\artifacts\\bin\\microsoft.netcore.app.runtime.$RunOSId-$RunArch\\Release $RunDir\\artifacts\\bin\\aot\\pack\\ /e /y\n\n# Create Core Root\n$RunDir\\src\\tests\\build.cmd release $RunArch generatelayoutonly /p:LibrariesConfiguration=Release\n\n# Clone performance \ngit clone --branch main --depth 1 --quiet https://github.com/dotnet/performance.git $RunDir\\performance\n\n# One line run:\npython3 $RunDir\\performance\\scripts\\benchmarks_ci.py --csproj $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --incremental no --architecture $RunArch -f net8.0 --filter \u0027System.Memory.Span\u0026lt;Char\u0026gt;*\u0027 --bdn-artifacts $RunDir\\artifacts\\BenchmarkDotNet.Artifacts --bdn-arguments=\"--anyCategories Libraries Runtime  --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir\\artifacts\\bin\\aot\\sgen\\mini\\mono-sgen.exe --customruntimepack $RunDir\\artifacts\\bin\\aot\\pack --aotcompilermode llvm --logBuildOutput --generateBinLog\"\n\n# Individual Commands:\n# Restore \ndotnet restore $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --packages $RunDir\\performance\\artifacts\\packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Build\ndotnet build $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore /p:NuGetPackageRoot=$RunDir\\performance\\artifacts\\packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Run\ndotnet run --project $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore --no-build -- --filter System.Memory.Span\u0026lt;Char\u0026gt;* --anyCategories Libraries Runtime \" --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir\\artifacts\\bin\\aot\\sgen\\mini\\mono-sgen.exe --customruntimepack $RunDir\\artifacts\\bin\\aot\\pack -aotcompilermode llvm --logBuildOutput --generateBinLog \" --artifacts $RunDir\\artifacts\\BenchmarkDotNet.Artifacts --packages $RunDir\\performance\\artifacts\\packages --buildTimeout 1200\n```\n\n\u003c/details\u003e\n\n\u003cdetails\u003e\n\n### System.Memory.Span\u0026lt;Char\u0026gt;.LastIndexOfAnyValues(Size: 512)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n\n\n### Docs\n\n[Profiling workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/profiling-workflow-dotnet-runtime.md)\n[Benchmarking workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/benchmarking-workflow-dotnet-runtime.md)\n\n\u003c/details\u003e\n\r\n\r\n---\r\n\r\n\n### Run Information\n\nName | Value\n-- | --\nArchitecture | x64\nOS | ubuntu 22.04\nQueue | TigerUbuntu\nBaseline | [6927fea7b4bca1dc2cea7a0afba0373c1303cedc](https://github.com/dotnet/runtime/commit/6927fea7b4bca1dc2cea7a0afba0373c1303cedc)\nCompare | [d901213ed6076c0989a2de2626b99c9711442543](https://github.com/dotnet/runtime/commit/d901213ed6076c0989a2de2626b99c9711442543)\nDiff | [Diff](https://github.com/dotnet/runtime/compare/6927fea7b4bca1dc2cea7a0afba0373c1303cedc...d901213ed6076c0989a2de2626b99c9711442543)\nConfigs | CompilationMode:tiered, LLVM:true, MonoAOT:true, MonoInterpreter:false, RunKind:micro_mono\n\n\n### Regressions in System.Collections.ContainsKeyTrue\u0026lt;Int32, Int32\u0026gt;\n\nBenchmark | Baseline | Test | Test/Base | Test Quality | Edge Detector | Baseline IR | Compare IR | IR Ratio\n-- | -- | -- | -- | -- | -- | -- | -- | --\n|\u003cul\u003e\u003cli\u003e[IDictionary - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_ubuntu 22.04_LLVM=true_MonoAOT=true_MonoInterpreter=false_RunKind=micro_mono/System.Collections.ContainsKeyTrue(Int32%2c%20Int32).IDictionary(Size%3a%20512).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Collections/Contains/ContainsKeyTrue.cs#L61-#L63\u003e)\u003c/li\u003e\u003cli\u003e[ADX - Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACpWU3W7TQBCF75F4h72zDW7iJqFqI1yRpi2EJlBSixuEqq09jRftjzW7buMK8eyMnRCaVCrmJt4df+fM7GbGM+C2RFCgnX3xk93ngMBOSiGzORSGxTHzMuM0uC6W2gkF3jZ1glynecMh3NpuDjyzXcWF3gFHmObCQeooGxOa+d7yYOCFzOOoaBFs6ASs+8QV1J7vvKvKOlCdsZGStMJoS2vtyN9eQJVgCW8n2vV7IWsex53JqWg4jpV/JR5gyN7s94K/xcxLTQa3YlEib/y+eWOjCiGb3cxk4H1n8S/mOUF45r18Tjmdfp39wamU5+GZ0Wb0Ofkvng4FWCDQ71p3y6X9h5BCF0Jna4ESKZprRWaPVMKCKlzlP1GPjAtaYBNjp/JONf9sG/6jPdMLoaENe7kwSVW0Q/PKipTLSzTK1JG2wg/VDYrsvTQ3XIqHJtZGNu/N22Y4WxaANC+6aebt9h4bmiXAxBTr1faoJCS7clwV7Jhl3EE9dn4v6g32osHe/mESHQ77g2H/qHM0OOhFg/7rKBpGUZ3ClkpxpK5nHBfXii/9xrCuIGSvAnZT7WQIN+MW1p30pYQSyKdA84PG7Qk8B1tKFyNVnfmPTrKKj+4A+YKc+kHIGqvaOD5HATqT1SZSX1azqUtGegfI6jOmOUfH7oXLmW/p8sDGG03IlqmRpdLxbk3VKm7jVREEOuEkxN4pXR19YKr1tpYwX9ugjtlCChfzJdjgN9GTfIECBQAA\u003e)\u003c/li\u003e\u003c/ul\u003e | 7.53 μs | 8.46 μs | 1.12 | 0.10 | False | | |\r\n\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Collections.ContainsKeyTrue%28Int32%2C%20Int32%29_1.png\u003e)\n[Test Report](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Collections.ContainsKeyTrue%28Int32%2C%20Int32%29.html\u003e)\n\n### Repro\nGeneral Docs link: https://github.com/dotnet/performance/blob/main/docs/benchmarking-workflow-dotnet-runtime.md\n\n\u003cdetails\u003e\n   \u003csummary\u003eRepro Steps\u003c/summary\u003e\n\n\n#### Prerequisites (Files either built locally (with build.(sh/cmd) or downloaded from payload above (if same system setup) (in this order))\n- Libraries build extracted to `runtime/artifacts` or build instructions: [Libraries README](https://github.com/dotnet/runtime/blob/main/docs/workflow/building/libraries/README.md) args: `-subset libs+libs.tests -rc release -configuration Release -arch $RunArch -framework net8.0`\n- CoreCLR product build extracted to `runtime/artifacts/bin/coreclr/$RunOS.$RunArch.Release`, build instructions: [CoreCLR README](https://github.com/dotnet/runtime/blob/main/docs/workflow/building/coreclr/README.md) args: `-subset clr+libs -rc release -configuration Release -arch $RunArch -framework net8.0`\n- AOT MONO build extracted to `runtime/artifacts/bin/mono/$RunOS.$RunArch.Release`, build instructions: [MONO README](https://github.com/dotnet/runtime/blob/main/docs/workflow/building/mono/README.md) args: `-arch $RunArch -os $RunOS -s mono+libs+host+packs -c Release /p:CrossBuild=false /p:MonoLLVMUseCxx11Abi=false`\n- Dotnet SDK installed for dotnet commands\n- Running commands from the runtime folder\n\nLinux\n```cmd\n# Set $RunDir to the runtime directory\nRunDir=`pwd`\n\n# Set the OS, arch, and OSId\nRunOS=\u0027linux\u0027\nRunOSId=\u0027linux\u0027\nRunArch=\u0027x64\u0027\n\n# Create aot directory \nmkdir -p $RunDir/artifacts/bin/aot/sgen\nmkdir -p $RunDir/artifacts/bin/aot/pack\ncp -r $RunDir/artifacts/obj/mono/$RunOS.$RunArch.Release/mono/* $RunDir/artifacts/bin/aot/sgen\ncp -r $RunDir/artifacts/bin/microsoft.netcore.app.runtime.$RunOS-$RunArch/Release/* $RunDir/artifacts/bin/aot/pack\n\n# Create Core Root\n$RunDir/src/tests/build.sh release $RunArch generatelayoutonly /p:LibrariesConfiguration=Release\n\n# Clone performance \ngit clone --branch main --depth 1 --quiet https://github.com/dotnet/performance.git $RunDir/performance\n\n# One line run:\npython3 $RunDir/performance/scripts/benchmarks_ci.py --csproj $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --incremental no --architecture $RunArch -f net8.0 --filter \u0027System.Collections.ContainsKeyTrue\u0026lt;Int32, Int32\u0026gt;*\u0027 --bdn-artifacts $RunDir/artifacts/BenchmarkDotNet.Artifacts --bdn-arguments=\"--anyCategories Libraries Runtime  --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir/artifacts/bin/aot/sgen/mini/mono-sgen --customruntimepack $RunDir/artifacts/bin/aot/pack --aotcompilermode llvm --logBuildOutput --generateBinLog\"\n\n# Individual Commands:\n# Restore \ndotnet restore $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --packages $RunDir/performance/artifacts/packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Build\ndotnet build $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore /p:NuGetPackageRoot=$RunDir/performance/artifacts/packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Run\ndotnet run --project $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore --no-build -- --filter System.Collections.ContainsKeyTrue\u0026lt;Int32, Int32\u0026gt;* --anyCategories Libraries Runtime \" --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir/artifacts/bin/aot/sgen/mini/mono-sgen --customruntimepack $RunDir/artifacts/bin/aot/pack --aotcompilermode llvm --logBuildOutput --generateBinLog \" --artifacts $RunDir/artifacts/BenchmarkDotNet.Artifacts --packages $RunDir/performance/artifacts/packages --buildTimeout 1200\n```\n\nWindows\n```cmd\n# Set $RunDir to the runtime directory\n$RunDir=\"FullPathHere\"\n\n# Set the OS, arch, and OSId\nRunOS=\u0027windows\u0027\nRunOSId=\u0027win\u0027\nRunArch=\u0027x64\u0027\n\n# Create aot directory\nmkdir $RunDir\\artifacts\\bin\\aot\\sgen\nmkdir $RunDir\\artifacts\\bin\\aot\\pack\nxcopy $RunDir\\artifacts\\obj\\mono\\$RunOS.$RunArch.Release\\mono $RunDir\\artifacts\\bin\\aot\\sgen\\ /e /y\nxcopy $RunDir\\artifacts\\bin\\microsoft.netcore.app.runtime.$RunOSId-$RunArch\\Release $RunDir\\artifacts\\bin\\aot\\pack\\ /e /y\n\n# Create Core Root\n$RunDir\\src\\tests\\build.cmd release $RunArch generatelayoutonly /p:LibrariesConfiguration=Release\n\n# Clone performance \ngit clone --branch main --depth 1 --quiet https://github.com/dotnet/performance.git $RunDir\\performance\n\n# One line run:\npython3 $RunDir\\performance\\scripts\\benchmarks_ci.py --csproj $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --incremental no --architecture $RunArch -f net8.0 --filter \u0027System.Collections.ContainsKeyTrue\u0026lt;Int32, Int32\u0026gt;*\u0027 --bdn-artifacts $RunDir\\artifacts\\BenchmarkDotNet.Artifacts --bdn-arguments=\"--anyCategories Libraries Runtime  --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir\\artifacts\\bin\\aot\\sgen\\mini\\mono-sgen.exe --customruntimepack $RunDir\\artifacts\\bin\\aot\\pack --aotcompilermode llvm --logBuildOutput --generateBinLog\"\n\n# Individual Commands:\n# Restore \ndotnet restore $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --packages $RunDir\\performance\\artifacts\\packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Build\ndotnet build $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore /p:NuGetPackageRoot=$RunDir\\performance\\artifacts\\packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Run\ndotnet run --project $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore --no-build -- --filter System.Collections.ContainsKeyTrue\u0026lt;Int32, Int32\u0026gt;* --anyCategories Libraries Runtime \" --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir\\artifacts\\bin\\aot\\sgen\\mini\\mono-sgen.exe --customruntimepack $RunDir\\artifacts\\bin\\aot\\pack -aotcompilermode llvm --logBuildOutput --generateBinLog \" --artifacts $RunDir\\artifacts\\BenchmarkDotNet.Artifacts --packages $RunDir\\performance\\artifacts\\packages --buildTimeout 1200\n```\n\n\u003c/details\u003e\n\n\u003cdetails\u003e\n\n### System.Collections.ContainsKeyTrue\u0026lt;Int32, Int32\u0026gt;.IDictionary(Size: 512)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n\n\n### Docs\n\n[Profiling workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/profiling-workflow-dotnet-runtime.md)\n[Benchmarking workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/benchmarking-workflow-dotnet-runtime.md)\n\n\u003c/details\u003e\n\r\n\r\n---\r\n\r\n\n### Run Information\n\nName | Value\n-- | --\nArchitecture | x64\nOS | ubuntu 22.04\nQueue | TigerUbuntu\nBaseline | [6927fea7b4bca1dc2cea7a0afba0373c1303cedc](https://github.com/dotnet/runtime/commit/6927fea7b4bca1dc2cea7a0afba0373c1303cedc)\nCompare | [d901213ed6076c0989a2de2626b99c9711442543](https://github.com/dotnet/runtime/commit/d901213ed6076c0989a2de2626b99c9711442543)\nDiff | [Diff](https://github.com/dotnet/runtime/compare/6927fea7b4bca1dc2cea7a0afba0373c1303cedc...d901213ed6076c0989a2de2626b99c9711442543)\nConfigs | CompilationMode:tiered, LLVM:true, MonoAOT:true, MonoInterpreter:false, RunKind:micro_mono\n\n\n### Regressions in System.Collections.ContainsKeyFalse\u0026lt;Int32, Int32\u0026gt;\n\nBenchmark | Baseline | Test | Test/Base | Test Quality | Edge Detector | Baseline IR | Compare IR | IR Ratio\n-- | -- | -- | -- | -- | -- | -- | -- | --\n|\u003cul\u003e\u003cli\u003e[IDictionary - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_ubuntu 22.04_LLVM=true_MonoAOT=true_MonoInterpreter=false_RunKind=micro_mono/System.Collections.ContainsKeyFalse(Int32%2c%20Int32).IDictionary(Size%3a%20512).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Collections/Contains/ContainsKeyFalse.cs#L63-#L65\u003e)\u003c/li\u003e\u003cli\u003e[ADX - Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACpWUb2/aMBDG30/ad/C7JFsKIbCWoaUape3GClsHaG+mqXKTK/HkP9HZaUk17bPPDowVKqHsDbEvv+e5O+PLFKguEQRIo1/8Ig85IJCzkvFsBoUiSUK8TBkJpo2lNEyAt0udIZVpXnMId7qdA810W1Am98AhpjkzkBqbjTBJfG913PNC4lEUdhFs6QVo85kKcJ7vvXmlDYjWSHFutUxJbdfSWH99BdUl5RrejaXpxiGpH6et8TmrQYqVP2ePMCBvOnHwr5pZKa3DHVuWSGvD795IiYLxejdVGXg/SPKbeIZZPPNeHlJOJt+mf3Es4TA8VVINvyz+i7dNARYI9neju3M9Hxba0BWT2UYgWIrqRlizJyqmQRSm8p+ph8oEDbCx0hN+L+q/tgn/SV/IJZPQhL1eqkVVNEPzSrOU8mtUQrlIU+HH6hZZ9oGrW8rZYx1rIpvFs6YZLlYFoB0YWd/m3fs9UnaYABeq2Kx2Z2VhZXNDRUFOSUYNuLnz4yjuHUW9o05/EfUH3d6gF7c6J/2Tt8fx6ygaRJFLoUshKNpbTygubwRd+bWhqyAkrwJyW+1lCLfzFrqb9LWEEqxPgeqnnbdn8Ax0yU2CturMf9LJOj68B6RL69QNQlJbOePkEhnIjFfbiDuseuNKRvsOkLge05yiIQ/M5MTX9vBAJ1tNSFap4qWQyX5N1Tquk3URFjTMcEi8c3t09gtTbbZOQnypAxfTBWcmoSvQwR+P9a3iAwUAAA==\u003e)\u003c/li\u003e\u003c/ul\u003e | 6.77 μs | 8.06 μs | 1.19 | 0.25 | False | | |\r\n\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Collections.ContainsKeyFalse%28Int32%2C%20Int32%29_1.png\u003e)\n[Test Report](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/06_18_2024/refs/heads/main_x64_ubuntu%2022.04_LLVM%3Dtrue_MonoAOT%3Dtrue_MonoInterpreter%3Dfalse_RunKind%3Dmicro_mono_Regression/System.Collections.ContainsKeyFalse%28Int32%2C%20Int32%29.html\u003e)\n\n### Repro\nGeneral Docs link: https://github.com/dotnet/performance/blob/main/docs/benchmarking-workflow-dotnet-runtime.md\n\n\u003cdetails\u003e\n   \u003csummary\u003eRepro Steps\u003c/summary\u003e\n\n\n#### Prerequisites (Files either built locally (with build.(sh/cmd) or downloaded from payload above (if same system setup) (in this order))\n- Libraries build extracted to `runtime/artifacts` or build instructions: [Libraries README](https://github.com/dotnet/runtime/blob/main/docs/workflow/building/libraries/README.md) args: `-subset libs+libs.tests -rc release -configuration Release -arch $RunArch -framework net8.0`\n- CoreCLR product build extracted to `runtime/artifacts/bin/coreclr/$RunOS.$RunArch.Release`, build instructions: [CoreCLR README](https://github.com/dotnet/runtime/blob/main/docs/workflow/building/coreclr/README.md) args: `-subset clr+libs -rc release -configuration Release -arch $RunArch -framework net8.0`\n- AOT MONO build extracted to `runtime/artifacts/bin/mono/$RunOS.$RunArch.Release`, build instructions: [MONO README](https://github.com/dotnet/runtime/blob/main/docs/workflow/building/mono/README.md) args: `-arch $RunArch -os $RunOS -s mono+libs+host+packs -c Release /p:CrossBuild=false /p:MonoLLVMUseCxx11Abi=false`\n- Dotnet SDK installed for dotnet commands\n- Running commands from the runtime folder\n\nLinux\n```cmd\n# Set $RunDir to the runtime directory\nRunDir=`pwd`\n\n# Set the OS, arch, and OSId\nRunOS=\u0027linux\u0027\nRunOSId=\u0027linux\u0027\nRunArch=\u0027x64\u0027\n\n# Create aot directory \nmkdir -p $RunDir/artifacts/bin/aot/sgen\nmkdir -p $RunDir/artifacts/bin/aot/pack\ncp -r $RunDir/artifacts/obj/mono/$RunOS.$RunArch.Release/mono/* $RunDir/artifacts/bin/aot/sgen\ncp -r $RunDir/artifacts/bin/microsoft.netcore.app.runtime.$RunOS-$RunArch/Release/* $RunDir/artifacts/bin/aot/pack\n\n# Create Core Root\n$RunDir/src/tests/build.sh release $RunArch generatelayoutonly /p:LibrariesConfiguration=Release\n\n# Clone performance \ngit clone --branch main --depth 1 --quiet https://github.com/dotnet/performance.git $RunDir/performance\n\n# One line run:\npython3 $RunDir/performance/scripts/benchmarks_ci.py --csproj $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --incremental no --architecture $RunArch -f net8.0 --filter \u0027System.Collections.ContainsKeyFalse\u0026lt;Int32, Int32\u0026gt;*\u0027 --bdn-artifacts $RunDir/artifacts/BenchmarkDotNet.Artifacts --bdn-arguments=\"--anyCategories Libraries Runtime  --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir/artifacts/bin/aot/sgen/mini/mono-sgen --customruntimepack $RunDir/artifacts/bin/aot/pack --aotcompilermode llvm --logBuildOutput --generateBinLog\"\n\n# Individual Commands:\n# Restore \ndotnet restore $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --packages $RunDir/performance/artifacts/packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Build\ndotnet build $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore /p:NuGetPackageRoot=$RunDir/performance/artifacts/packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Run\ndotnet run --project $RunDir/performance/src/benchmarks/micro/MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore --no-build -- --filter System.Collections.ContainsKeyFalse\u0026lt;Int32, Int32\u0026gt;* --anyCategories Libraries Runtime \" --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir/artifacts/bin/aot/sgen/mini/mono-sgen --customruntimepack $RunDir/artifacts/bin/aot/pack --aotcompilermode llvm --logBuildOutput --generateBinLog \" --artifacts $RunDir/artifacts/BenchmarkDotNet.Artifacts --packages $RunDir/performance/artifacts/packages --buildTimeout 1200\n```\n\nWindows\n```cmd\n# Set $RunDir to the runtime directory\n$RunDir=\"FullPathHere\"\n\n# Set the OS, arch, and OSId\nRunOS=\u0027windows\u0027\nRunOSId=\u0027win\u0027\nRunArch=\u0027x64\u0027\n\n# Create aot directory\nmkdir $RunDir\\artifacts\\bin\\aot\\sgen\nmkdir $RunDir\\artifacts\\bin\\aot\\pack\nxcopy $RunDir\\artifacts\\obj\\mono\\$RunOS.$RunArch.Release\\mono $RunDir\\artifacts\\bin\\aot\\sgen\\ /e /y\nxcopy $RunDir\\artifacts\\bin\\microsoft.netcore.app.runtime.$RunOSId-$RunArch\\Release $RunDir\\artifacts\\bin\\aot\\pack\\ /e /y\n\n# Create Core Root\n$RunDir\\src\\tests\\build.cmd release $RunArch generatelayoutonly /p:LibrariesConfiguration=Release\n\n# Clone performance \ngit clone --branch main --depth 1 --quiet https://github.com/dotnet/performance.git $RunDir\\performance\n\n# One line run:\npython3 $RunDir\\performance\\scripts\\benchmarks_ci.py --csproj $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --incremental no --architecture $RunArch -f net8.0 --filter \u0027System.Collections.ContainsKeyFalse\u0026lt;Int32, Int32\u0026gt;*\u0027 --bdn-artifacts $RunDir\\artifacts\\BenchmarkDotNet.Artifacts --bdn-arguments=\"--anyCategories Libraries Runtime  --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir\\artifacts\\bin\\aot\\sgen\\mini\\mono-sgen.exe --customruntimepack $RunDir\\artifacts\\bin\\aot\\pack --aotcompilermode llvm --logBuildOutput --generateBinLog\"\n\n# Individual Commands:\n# Restore \ndotnet restore $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --packages $RunDir\\performance\\artifacts\\packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Build\ndotnet build $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore /p:NuGetPackageRoot=$RunDir\\performance\\artifacts\\packages /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1\n\n# Run\ndotnet run --project $RunDir\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj --configuration Release --framework net8.0 --no-restore --no-build -- --filter System.Collections.ContainsKeyFalse\u0026lt;Int32, Int32\u0026gt;* --anyCategories Libraries Runtime \" --category-exclusion-filter NoAOT NoWASM --runtimes monoaotllvm --aotcompilerpath $RunDir\\artifacts\\bin\\aot\\sgen\\mini\\mono-sgen.exe --customruntimepack $RunDir\\artifacts\\bin\\aot\\pack -aotcompilermode llvm --logBuildOutput --generateBinLog \" --artifacts $RunDir\\artifacts\\BenchmarkDotNet.Artifacts --packages $RunDir\\performance\\artifacts\\packages --buildTimeout 1200\n```\n\n\u003c/details\u003e\n\n\u003cdetails\u003e\n\n### System.Collections.ContainsKeyFalse\u0026lt;Int32, Int32\u0026gt;.IDictionary(Size: 512)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n\n\n### Docs\n\n[Profiling workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/profiling-workflow-dotnet-runtime.md)\n[Benchmarking workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/benchmarking-workflow-dotnet-runtime.md)\n\n\u003c/details\u003e\n",
                                           "updatedAt":  "2024-06-18T08:34:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6BuyLT",
                                           "createdAt":  "2024-06-18T16:34:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @directhex, @matouskozak\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-06-18T16:34:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6BuyY2",
                                           "createdAt":  "2024-06-18T16:35:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-06-18T16:35:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6BuzE5",
                                           "createdAt":  "2024-06-18T16:36:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "matouskozak",
                                           "body":  "Could the `Perf_Base64` regressions be related to https://github.com/dotnet/runtime/pull/102364 @buyaa-n @stephentoub @MihaZupan ?\r\n\r\nx64 AOT-llvm improvements: https://github.com/dotnet/perf-autofiling-issues/issues/36458\r\narm64 AOT-llvm regressions: https://github.com/dotnet/perf-autofiling-issues/issues/36499\r\narm64 AOT-llvm improvements: https://github.com/dotnet/perf-autofiling-issues/issues/36501",
                                           "updatedAt":  "2024-06-18T17:02:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6BvOV-",
                                           "createdAt":  "2024-06-18T17:41:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODmJUXA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "matouskozak",
                                                                               "createdAt":  "2024-06-18T20:08:05Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Could the Perf_Base64 regressions be related to https://github.com/dotnet/runtime/pull/102364 @buyaa-n @stephentoub @MihaZupan ?\n\nDefinitely",
                                           "updatedAt":  "2024-06-18T17:41:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6BvYsk",
                                           "createdAt":  "2024-06-18T18:07:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "buyaa-n",
                                           "body":  "@matouskozak just curious the bot added many unrelated API\u0027s and type\u0027s regressions in the comments like `ConvertToBase64CharArray`, `System.Numerics.Tests.Perf_BitOperations`, `System.Collections.CopyTo\u003cString\u003e`, `System.Collections.ContainsKeyFalse\u003cInt32, Int32\u003e`, `System.Memory.Span\u003cChar\u003e` etc is there any reason why they are included? Could just ignore those? \r\n\r\n\r\n\u003e [Perf] Linux/x64:\r\n\r\nIs this mean there were no regression on Windows and other platforms? ",
                                           "updatedAt":  "2024-06-18T18:10:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6BwIh5",
                                           "createdAt":  "2024-06-18T20:08:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "matouskozak",
                                           "body":  "\u003e @matouskozak just curious the bot added many unrelated API\u0027s and type\u0027s regressions in the comments like `ConvertToBase64CharArray`, `System.Numerics.Tests.Perf_BitOperations`, `System.Collections.CopyTo\u003cString\u003e`, `System.Collections.ContainsKeyFalse\u003cInt32, Int32\u003e`, `System.Memory.Span\u003cChar\u003e` etc is there any reason why they are included? Could just ignore those?\r\n\r\nI think that `ConvertToBase64CharArray` could be related to https://github.com/dotnet/runtime/pull/102364. The rest of the APIs you listed looks to be just noisy benchmarks, not related.\r\n\r\n\r\n\u003e \r\n\u003e \u003e [Perf] Linux/x64:\r\n\u003e \r\n\u003e Is this mean there were no regression on Windows and other platforms?\r\n\r\nFor Mono, we only run microbenchmarks on Linux. It is possible that more improvements/regressions on Windows or other platforms might appear from CoreCLR.\r\n\r\n\r\n",
                                           "updatedAt":  "2024-06-18T20:08:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6BwT_6",
                                           "createdAt":  "2024-06-18T20:35:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "buyaa-n",
                                           "body":  "I see, thanks for the response. \r\n\r\nFWIW: `ConvertToBase64CharArray` is not related as https://github.com/dotnet/runtime/pull/102364 did not touch `Convert` APIs at all\r\n```cs\r\n[Benchmark]\r\npublic int ConvertToBase64CharArray() =\u003e Convert.ToBase64CharArray(_decodedBytes, 0, _decodedBytes.Length, _encodedChars, 0);\r\n```",
                                           "updatedAt":  "2024-06-18T20:35:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6BwWF2",
                                           "createdAt":  "2024-06-18T20:40:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODmNIMA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "buyaa-n",
                                                                               "createdAt":  "2024-06-18T20:54:34Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "matouskozak",
                                                                               "createdAt":  "2024-06-19T08:00:35Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e FWIW: ConvertToBase64CharArray is not related as https://github.com/dotnet/runtime/pull/102364 did not touch Convert APIs at all\n\nConvertToBase64CharArray uses Base64.EncodeToUtf8. Your PR touched that, no?\nhttps://github.com/dotnet/runtime/blob/26567303fc4cb7068de49f78e36a17b53c548275/src/libraries/System.Private.CoreLib/src/System/Convert.cs#L2482",
                                           "updatedAt":  "2024-06-18T20:40:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6BwcvW",
                                           "createdAt":  "2024-06-18T20:58:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "buyaa-n",
                                           "body":  "\u003e ConvertToBase64CharArray uses Base64.EncodeToUtf8. Your PR touched that, no?\r\n\r\nAh yes, it did.",
                                           "updatedAt":  "2024-06-18T20:58:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6DUYzp",
                                           "createdAt":  "2024-07-02T13:26:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "matouskozak",
                                           "body":  "@buyaa-n are you planning to look into fixing the Mono regression?\r\n",
                                           "updatedAt":  "2024-07-02T13:26:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EOw0P",
                                           "createdAt":  "2024-07-09T19:17:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "fanyang-mono",
                                           "body":  "In @buyaa-n\u0027s PR, quite a few regular methods were converted into generic ones. That\u0027s probably the main cause of this perf regression. There isn\u0027t much we could do on Mono side.",
                                           "updatedAt":  "2024-07-10T14:29:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EPpOM",
                                           "createdAt":  "2024-07-09T20:40:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "buyaa-n",
                                           "body":  "\u003e In @buyaa-n\u0027s PR, quite a few regular methods weren\u0027t converted into generic ones. That\u0027s probably the main cause of this perf regression. There isn\u0027t much we could do on Mono side.\r\n\r\n@fanyang-mono could you be more specific about which methods you are talking about? I believe the methods need to be generalized are generalized, basically for code sharing/polymorphism between Base64 and Base64Url not sure how/why they would affect in perf. If there is anything that could help with this perf regression I can make that happen.\r\n\r\nAlso, my [last PR](https://github.com/dotnet/runtime/pull/104332) might improve this perf for some level (local perf test showed bit improvements)\r\n\r\n\u003e @buyaa-n are you planning to look into fixing the Mono regression?\r\n\r\nI haven\u0027t looked into this regression yet, I will try repro when I got more time but doesn\u0027t really feel I would find anything to fix. Because in general, my PR has nothing Mono or Linux specific. I did perf test on my machine (windows) before merge and there was no regression (mainly same result or diff within 2%, that diff probably covered by my last PR).",
                                           "updatedAt":  "2024-07-09T20:40:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EZMkL",
                                           "createdAt":  "2024-07-10T18:43:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODpMRbQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "buyaa-n",
                                                                               "createdAt":  "2024-07-10T18:52:35Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "This is a similar issue to https://github.com/dotnet/runtime/issues/101127.\r\n\r\nThe libraries moved to use more generics and features like static virtuals in interfaces/generic math to significantly reduce the amount of code needed and improve long term maintainability. This pattern ends up hurting perf for Mono primarily due to a lack of generic specialization support.\r\n\r\nCC. @stephentoub as an FYI on this as well. -- I don\u0027t think there\u0027s much we can do here, we\u0027re having to make judgement calls for each of these types of PR around the long term maintainability of the code in contrast to how the use of generics negatively impact the performance of some runtimes. There\u0027s many places we can avoid such use of generics, especially for existing code, but when substantial new features (like UTF-8 parsing/formatting, Generic Math, or Tensors) come online it becomes much harder to justify the hundreds to thousands of lines of additional code that would be required to avoid regressing those runtimes (as we often have to duplicate all the logic for each `T` that needs to be supported).",
                                           "updatedAt":  "2024-07-10T18:43:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EZUWY",
                                           "createdAt":  "2024-07-10T19:02:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "buyaa-n",
                                           "body":  "\u003e The libraries moved to use more generics and features like static virtuals in interfaces/generic math to significantly reduce the amount of code needed and improve long term maintainability. This pattern ends up hurting perf for Mono primarily due to a lack of generic specialization support.\r\n\r\nInteresting, in order to [add Base64Url support for netstandard 2.0](https://github.com/dotnet/runtime/pull/103617) those static abstract methods changed to instance methods, and passing in a default instance of the struct as an argument. Would that change improve this on Mono? Perf test done locally (windows) showed around the same perf result",
                                           "updatedAt":  "2024-07-10T19:04:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EZW3r",
                                           "createdAt":  "2024-07-10T19:09:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODpMarw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "buyaa-n",
                                                                               "createdAt":  "2024-07-10T19:13:30Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Would that change improve this on Mono?\n\nNo. It\u0027s the generic aspect and parameterizing generics with structs as a way to avoid code duplication while still getting optimal code generation that\u0027s the key here. Whether the methods are static or instance doesn\u0027t really matter. But the existence of static virtuals has made it easier for us to employ this approach in more places.",
                                           "updatedAt":  "2024-07-10T19:09:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6IKl5b",
                                           "createdAt":  "2024-08-12T16:43:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "buyaa-n",
                                           "body":  "As per @tannergooding [comment](https://github.com/dotnet/runtime/issues/103653#issuecomment-2221197579n) moving to future and unassigning myself",
                                           "updatedAt":  "2024-08-12T16:43:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6IQGpA",
                                           "createdAt":  "2024-08-13T10:33:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "matouskozak",
                                           "body":  "\u003e As per @tannergooding [comment](https://github.com/dotnet/runtime/issues/103653#issuecomment-2221197579n) moving to future and unassigning myself\r\n\r\nI would prefer to keep it in .NET 10 since the introduction of generics in BCL is quite common pattern lately and should be address in Mono runtime. I\u0027ll try to group the related issues together to have a common tracking issue for this.",
                                           "updatedAt":  "2024-08-13T10:33:52Z"
                                       }
                                   ],
                         "totalCount":  18
                     },
        "title":  "[mono][Perf] `Perf_Base64` Regressions on 6/14/2024 3:42:32 AM",
        "labels":  [
                       "arch-arm64",
                       "area-System.Memory",
                       "os-linux",
                       "tenet-performance",
                       "tenet-performance-benchmarks",
                       "arch-x64",
                       "runtime-mono"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/103886",
        "createdAt":  "2024-06-24T09:16:58Z",
        "number":  103886,
        "author":  "Rekkonnect",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-19T16:14:17Z",
        "body":  "### Background and motivation\n\nIt\u0027s currently impossible to evaluate whether the enumerator is currently active or not. There is a private field named `_isEnumeratorActive` which is not exposed. The only way to get that information is by calling `MoveNext` which will also move the enumerator forward if it\u0027s active, which is not intended in some cases. `Current` will also return the last captured span regardless of the activity of the enumerator (which is a fine state as it is), so we cannot extract information out of the behavior of that property.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Text;\r\n\r\npublic ref struct SpanLineEnumerator\r\n{\r\n    public bool IsEnumeratorActive { get; }\r\n}\r\n```\r\n\n\n### API Usage\n\nAssume a piece of code is using an enumerator instance that is consuming text in other places, and evaluating its activity in others.\r\n\r\n```csharp\r\npublic void Consume(ref SpanLineEnumerator enumerator)\r\n{\r\n    // ...\r\n    enumerator.MoveNext();\r\n}\r\n\r\npublc void Evaluate(ref SpanLineEnumerator enumerator)\r\n{\r\n    var current = enumerator.Current;\r\n    // use current, but we must know whether the enumerator has stopped\r\n}\r\n```\n\n### Alternative Designs\n\nCurrently this can be mitigated by wrapping the enumerator in another enumerator instance which is tracking the activity of the enumerator and can then expose it manually.\n\n### Risks\n\nNone.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOglYHMg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6CTPA2",
                                           "createdAt":  "2024-06-24T09:48:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODm4sEg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-06-24T10:37:38Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "neon-sunset",
                                                                               "createdAt":  "2024-06-24T12:40:55Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "It\u0027s not limited to this enumerator. The validity of enumerators is clearly determined by the return value of `MoveNext`.\r\n\r\n\u003e Assume a piece of code is using an enumerator instance that is consuming text in other places, and evaluating its activity in others.\r\n\r\nI don\u0027t understand the use case. The return value of `MoveNext` must be checked to correctly use an enumerator.",
                                           "updatedAt":  "2024-06-24T09:48:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6CTSkR",
                                           "createdAt":  "2024-06-24T09:55:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "\u003e `Current` will also return the last captured span regardless of the activity of the enumerator (which is a fine state as it is)\r\n\r\nAlso note that touching `Current` is undefined behavior when an enumerator is invalid. It can throw and should throw.",
                                           "updatedAt":  "2024-06-24T09:55:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6CUNuf",
                                           "createdAt":  "2024-06-24T11:20:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "You can restructure your code to enumerate the enumerator in one place, and update `Evaluate` to accept a `ReadOnlySpan\u003cchar\u003e`. But it might be tricky to do if `Evaluate` also moves the enumerator forward.",
                                           "updatedAt":  "2024-06-24T11:20:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6CUOOy",
                                           "createdAt":  "2024-06-24T11:21:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-06-24T11:21:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6CU08U",
                                           "createdAt":  "2024-06-24T12:46:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "neon-sunset",
                                           "body":  "You may also want to just implement your own line enumerator. Currently, `SpanLineEnumerator` splits on all \"newline\" ASCII characters rather than the expected LF/CRLF and does not manually elide bound checks, which makes it quite a bit slower than it could have been, making custom impl. profitable.",
                                           "updatedAt":  "2024-06-24T12:46:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6CVgcy",
                                           "createdAt":  "2024-06-24T14:09:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "\u003e You can restructure your code to enumerate the enumerator in one place, and update `Evaluate` to accept a `ReadOnlySpan\u003cchar\u003e`. But it might be tricky to do if `Evaluate` also moves the enumerator forward.\r\n\r\n.... Which they should probably do anyways, because using `Enumerator.Current` any significant distance from advancement is asking for trouble.\r\n",
                                           "updatedAt":  "2024-06-24T14:09:57Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "[API Proposal]: Expose `IsEnumeratorActive` in `System.Text.SpanLineEnumerator`",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/104977",
        "createdAt":  "2024-07-16T16:21:46Z",
        "number":  104977,
        "author":  "epeshk",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-08-05T20:47:27Z",
        "body":  "### Background and motivation\r\n\r\nThe current `SearchValues\u003cstring\u003e.Contains(string)` method forces an user to allocate and copy the `string` from `ReadOnlySpan\u003cchar\u003e` to perform the search.\r\n\r\n`StringSearchValuesAhoCorasick` and `AsciiStringSearchValuesTeddy...` already accept `ReadOnlySpan\u003cchar\u003e` as a search argument, but it is not a public API.\r\n\r\n`StringSearchValuesBase` uses `HashSet\u003cstring\u003e`, but can search for `ReadOnlySpan\u003cchar\u003e using `AlternateLookup` feature.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Buffers;\r\n\r\npublic static class SearchValuesExtensions\r\n{\r\n  public static bool Contains(this SearchValues\u003cstring\u003e searchValues, ReadOnlySpan\u003cchar\u003e span);\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\nReadOnlySpan\u003cchar\u003e word = ...;\r\nSearchValues s = SearchValues.Create(words);\r\n\r\nbool found = s.Contains(word);\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\n```csharp\r\nnamespace System.Buffers;\r\n\r\npublic class SearchValues\u003cT\u003e where T : IEquatable\u003cT\u003e?, allows ref struct;\r\n\r\npublic static class SearchValues {\r\n  public static SearchValues\u003cReadOnlySpan\u003cchar\u003e\u003e CreateSpanLookup(ReadOnlySpan\u003cstring\u003e values, StringComparison comparisonType);\r\n}\r\n```\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOh0ut3A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6FALO0",
                                           "createdAt":  "2024-07-16T17:05:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Can you share more information about where / how you want to use this? e.g. a more complete code example?",
                                           "updatedAt":  "2024-07-16T17:05:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6HSUEe",
                                           "createdAt":  "2024-08-05T19:05:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jilles-sg",
                                           "body":  "Is this a documentation issue? The original poster may actually want `FrozenSet` which supports `GetAlternateLookup`. On the other hand, the reference page for `SearchValues\u003cT\u003e` at https://learn.microsoft.com/en-us/dotnet/api/system.buffers.searchvalues-1?view=net-9.0 does not clarify that the main use case of this type is with `IndexOfAny` and similar methods of `MemoryExtensions`, not the `Contains` instance method.\r\n\r\nAlternatively, if the original poster has a set of strings and needs both searches for exact matches and entries of the set as substrings of the input string, the new API would make sense.",
                                           "updatedAt":  "2024-08-05T19:05:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6HS63c",
                                           "createdAt":  "2024-08-05T20:43:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "epeshk",
                                           "body":  "@jilles-sg Yes, I\u0027m definitely looking for the `MemoryExtensions.IndexOfAny(ReadOnlySpan\u003cchar\u003e, SearchValues\u003cstring\u003e)` method. I mistakenly confused it with the `Contains`. Thank you for pointing to it!\r\n\r\nFor `Contains`, it\u0027s probably better to use hash set. To get benefits from `SearchValues`, it should be a very specific use case where it\u0027s worth avoiding hash code computation.\r\n\r\nIMHO, it would be worth mentioning somewhere in the `SearchValues\u003cstring\u003e` docs that it is intended to be used with the `MemoryExtensions` class.",
                                           "updatedAt":  "2024-08-05T20:47:27Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "[API Proposal]: SearchValues\u003cstring\u003e.Contains(ReadOnlySpan\u003cchar\u003e span)",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/105088",
        "createdAt":  "2024-07-18T14:21:05Z",
        "number":  105088,
        "author":  "xtqqczze",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-23T11:09:21Z",
        "body":  "cc: @MihaZupan\r\n\r\nhttps://github.com/dotnet/runtime/blob/c4e32db9042baba51b7d1125616e6b686544fec6/src/libraries/System.Private.CoreLib/src/System/SpanHelpers.Packed.cs#L156-L159\r\n\r\nshould probably read \"don\u0027t consume the last 64 characters\"\r\n\r\nsee: https://github.com/dotnet/runtime/commit/2b7caa854111fee5daeeaad9be22b594acae9bea",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOhc8jNw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6FUNDf",
                                           "createdAt":  "2024-07-18T14:21:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-07-18T14:21:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6FUexB",
                                           "createdAt":  "2024-07-18T14:34:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xtqqczze",
                                           "body":  "more probable typos: https://github.com/dotnet/runtime/commit/45bdfb4f96a5d863e7b4026cb922096db7018ea6",
                                           "updatedAt":  "2024-07-18T14:34:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6FUrQn",
                                           "createdAt":  "2024-07-18T14:56:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "Yeah they\u0027re just copy-paste errors. I have a fix for it somewhere I can put up when I get to a PC.",
                                           "updatedAt":  "2024-07-18T14:56:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6FUuFG",
                                           "createdAt":  "2024-07-18T15:00:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xtqqczze",
                                           "body":  "@MihaZupan I have a branch with fixes: https://github.com/dotnet/runtime/compare/main...xtqqczze:dotnet-runtime:SpanHelpersPackedComment.",
                                           "updatedAt":  "2024-07-18T15:00:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6FzyM3",
                                           "createdAt":  "2024-07-23T11:09:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xtqqczze",
                                           "body":  "@MihaZupan I could create a PR for this from https://github.com/dotnet/runtime/compare/main...xtqqczze:dotnet-runtime:SpanHelpersPackedComment?",
                                           "updatedAt":  "2024-07-23T11:09:19Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "Possible typos in `PackedSpanHelpers`",
        "labels":  [
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/105707",
        "createdAt":  "2024-07-30T10:01:21Z",
        "number":  105707,
        "author":  "performanceautofiler",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-01T18:16:02Z",
        "body":  "\u003c!-- DATA: {\"RunType\":{\"Repo\":\"dotnetruntime\",\"Branch\":\"refs/heads/main\",\"Arch\":\"x64\",\"Os\":\"Windows1022621\",\"Queue\":\"TigerWindows\",\"Frequency\":\"Weekly\",\"CoreClr\":true,\"Mono\":false,\"Wasm\":false,\"Maui\":false,\"Configs\":[\"CompilationMode:tiered\",\"RunKind:micro\"]},\"RegressionDate\":\"2024-07-26T17:51:02\",\"IsRegression\":true} --\u003e\r\n\n### Run Information\n\nName | Value\n-- | --\nArchitecture | x64\nOS | Windows 10.0.22621\nQueue | TigerWindows\nBaseline | [6af853d7757e55a09fd9bc6dc1d6aa12c0b454f2](https://github.com/dotnet/runtime/commit/6af853d7757e55a09fd9bc6dc1d6aa12c0b454f2)\nCompare | [b2b0db0c470eba512d358dcf3d359488083e82a8](https://github.com/dotnet/runtime/commit/b2b0db0c470eba512d358dcf3d359488083e82a8)\nDiff | [Diff](https://github.com/dotnet/runtime/compare/6af853d7757e55a09fd9bc6dc1d6aa12c0b454f2...b2b0db0c470eba512d358dcf3d359488083e82a8)\nConfigs | CompilationMode:tiered, RunKind:micro\n\n\n### Regressions in System.Buffers.Text.Tests.Base64EncodeDecodeInPlaceTests\n\nBenchmark | Baseline | Test | Test/Base | Test Quality | Edge Detector | Baseline IR | Compare IR | IR Ratio\n-- | -- | -- | -- | -- | -- | -- | -- | --\n|\u003cul\u003e\u003cli\u003e[Base64DecodeInPlace - Duration of single invocation](\u003chttps://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_Windows 10.0.22621/System.Buffers.Text.Tests.Base64EncodeDecodeInPlaceTests.Base64DecodeInPlace(NumberOfBytes%3a%20200000000).html\u003e)\u003c/li\u003e\u003cli\u003e📝 - [Benchmark Source](\u003chttps://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Buffers/Base64Tests.cs#L128-#L130\u003e)\u003c/li\u003e\u003cli\u003e[ADX - Test Multi Config Graph](\u003chttps://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACo1UXY/aMBB8r9T/4LckbQ5SDpBASlXgri1tuVKOt6qqTLIQV/6I1vZdcqr622sHRIGTquTB8q5nZscrbxZAtUUQII1+8Zs8FoBAppbxfAWlImlKglwZCaaLVhomIDhHTZHKrGhwCFvdLYDmuisokxfACWYFM5AZV40wScKgGvaDmAQUhdtER/QatLmjArzmu+C+1gZEZ2q3W0DdWUNl3KKN7kyphmH/VmYqhxvw61wuOc3g9PjsILyzYgP4dTutDegx6SWHL/rndWXlTMkt21mkhimpvwczJUrGm2jhxIIfJP1DAsMcPA9e/o/pUp+ZzA8MwTJUJwSmQZSmDp8RJ8pELWBzpb/wB9F0tw3+k76VOyahDdYLt8EtlFQt7XroXBrAEsGtbSjLnVrXZSvDy6LWLKN8iUoon2lL/FhvkOUfuNpQzp6aXBvaqrdqW+G2KgHd5MjmWZ8/9JlyUwW4VuVhdz40a0e7N1SU5C3JqQE/gGEv6fWvksHVdbJORuNBMk5GnVFv0B+8Gb5OXJT4EtoKQZE9AaG4+yloFTaC3kFMXkVkU19UiI+DF/un/M2CBadTovrlhvYZeAXacpOic52HJzfZ5ycPgHTnlK6jmDRSXjh9jwxkzutjxjerCbxldGeAxN8xKyga8shMQULtmgc6PXJiUmWKWyHTS0/1Pq/TvQkHNMxwSIMb1zr3q6kPoaeQUOrI53TJmUlpBTr6CxNDzhQMBQAA\u003e)\u003c/li\u003e\u003c/ul\u003e | 395.24 ms | 442.64 ms | 1.12 | 0.01 | False | | |\r\n\n![graph](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/07_30_2024/refs/heads/main_x64_Windows%2010.0.22621_Regression/System.Buffers.Text.Tests.Base64EncodeDecodeInPlaceTests_1.png\u003e)\n[Test Report](\u003chttps://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/07_30_2024/refs/heads/main_x64_Windows%2010.0.22621_Regression/System.Buffers.Text.Tests.Base64EncodeDecodeInPlaceTests.html\u003e)\n\n### Repro\nGeneral Docs link: https://github.com/dotnet/performance/blob/main/docs/benchmarking-workflow-dotnet-runtime.md\n\n```cmd\ngit clone https://github.com/dotnet/performance.git\npy .\\performance\\scripts\\benchmarks_ci.py -f net8.0 --filter \u0027System.Buffers.Text.Tests.Base64EncodeDecodeInPlaceTests*\u0027\n```\n\n\u003cdetails\u003e\n\n### System.Buffers.Text.Tests.Base64EncodeDecodeInPlaceTests.Base64DecodeInPlace(NumberOfBytes: 200000000)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n\n\n### Docs\n\n[Profiling workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/profiling-workflow-dotnet-runtime.md)\n[Benchmarking workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/benchmarking-workflow-dotnet-runtime.md)\n\n\u003c/details\u003e\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOiHbyAA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6GoYtu",
                                           "createdAt":  "2024-07-30T16:20:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "LoopedBard3",
                                           "body":  "Comparison range: https://github.com/dotnet/runtime/compare/efebf202a4a9bd78702bf4bf28a027f093e15d89...eb765b71a4a93e4157cd7e1eaf33995ffc80285c",
                                           "updatedAt":  "2024-07-30T16:20:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GoY8Z",
                                           "createdAt":  "2024-07-30T16:21:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "LoopedBard3",
                                           "body":  "Likely: https://github.com/dotnet/runtime/pull/105262 @buyaa-n ",
                                           "updatedAt":  "2024-07-30T16:21:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GxFFP",
                                           "createdAt":  "2024-07-31T17:28:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-07-31T17:28:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6HEf3_",
                                           "createdAt":  "2024-08-02T20:28:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "buyaa-n",
                                           "body":  "\u003e Likely: #105262 @buyaa-n\r\n\r\n#105262 should not really impact this much, I will try to repro when I got time",
                                           "updatedAt":  "2024-08-02T20:28:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6IdvIA",
                                           "createdAt":  "2024-08-14T18:04:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "buyaa-n",
                                           "body":  "\u003e #105262 should not really impact this much, I will try to repro when I got time\r\n\r\nSurprisingly it was repro-ed locally, though there is nothing we can do for improving the changes made with https://github.com/dotnet/runtime/pull/105262, the only change made for `Base64.EncodeDecodeInPlace` with the PR is \r\n\u003cimg width=\"338\" alt=\"image\" src=\"https://github.com/user-attachments/assets/d57280b8-9eed-492d-9b32-54f71aa8cd2d\"\u003e\r\nwhich should not impact the perf much.\r\n\r\nOnly thing I could try is review `Base64.EncodeDecodeInPlace` code entirely and try to improve the perf. So, I am gonna move this issue to v10\r\n",
                                           "updatedAt":  "2024-08-14T18:04:56Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "[Perf] Windows/x64: Regression in System.Buffers.Text.Tests.Base64EncodeDecodeInPlaceTests",
        "labels":  [
                       "area-System.Memory",
                       "os-windows",
                       "arch-x64",
                       "runtime-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/106121",
        "createdAt":  "2024-08-08T10:44:14Z",
        "number":  106121,
        "author":  "HurricanKai",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC7W-Lg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "verdie-g",
                                            "createdAt":  "2024-09-26T23:08:57Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-08-08T17:33:50Z",
        "body":  "Not sure if a proposal is required, as it doesn\u0027t technically add new API surface, just enables a combination of generic arguments.\n\nLooks like right now string is special cased to only work with ROSpan\u003cchar\u003e so I want to suggest additionally allowing it to work with ROSequence\u003cchar\u003e. The length can also be checked (which appears to be the reason it\u0027s special cased) and otherwise equality should be straightforward to implement.\nThe upside would be that if memory is fragmented into multiple buffers, as may happen from buffered file or network reads, ROSequence can be used to make a zero-copy zero-alloc lookup.\nFor small strings this likely doesn\u0027t matter, but for large strings this could mean significant performance improvements.\n\nI believe the implementation would be fairly straightforward, just follow the original implementation for ROSpan, and once it comes to comparing, loop over the ROSequence slices, comparing with the string.AsSpan() sub-slices.\nI\u0027d be happy to contribute this.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOh6Xydg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6HoY4T",
                                           "createdAt":  "2024-08-08T10:44:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-08-08T10:44:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6HpGpP",
                                           "createdAt":  "2024-08-08T12:27:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "Would this mean implementing `IAlternateEqualityComparer\u003cReadOnlySequence\u003cchar\u003e, string?\u003e` in the StringComparer subclasses ([source](https://github.com/dotnet/runtime/blob/b252fa50adc02fb59e2cb4f821b8efcc06963e66/src/libraries/System.Private.CoreLib/src/System/StringComparer.cs)) that currently implement `IAlternateEqualityComparer\u003cReadOnlySpan\u003cchar\u003e, string?\u003e`?  If so, I think there are two difficulties:\r\n\r\n* ReadOnlySequence\\\u003cT\\\u003e is currently defined in System.Memory, which references System.Private.CoreLib, where the string comparers are defined.  Implementing the interface would turn this into a circular reference, unless types were moved.\r\n* In CultureAwareComparer, GetHashCode(ReadOnlySpan\\\u003cchar\\\u003e) passes the span to CompareInfo.GetHashCode(ReadOnlySpan\\\u003cchar\\\u003e, CompareOptions), which in turn calls either ICU or Windows NLS functions.  The ReadOnlySequence\\\u003cchar\\\u003e could perhaps be passed to ICU using iterators ([Obtaining Partial Sort Keys](https://unicode-org.github.io/icu/userguide/collation/api.html#obtaining-partial-sort-keys)) but the performance might be worse than with ReadOnlySpan\\\u003cchar\\\u003e.  On Windows, CompareInfo uses LCMapStringEx, which doesn\u0027t seem to support a similar feature.  It would be easiest to omit ReadOnlySequence\\\u003cchar\\\u003e support from CultureAwareComparer and implement it for ordinal comparison only.",
                                           "updatedAt":  "2024-08-08T12:27:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6HpfJ2",
                                           "createdAt":  "2024-08-08T13:15:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Looks like right now string is special cased to only work with ROSpan so I want to suggest additionally allowing it to work with ROSequence.\n\nSpan is special-cased by the comparers, not by `Dictionary\u003c\u003e`. You can implement your own comparer that supports `ReadOnlySequence\u003c\u003e`, and it\u0027ll \"just work\" with `Dictionary\u003c\u003e`.",
                                           "updatedAt":  "2024-08-08T13:15:38Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Support ReadOnlySequence\u003cchar\u003e as AlternateLookup",
        "labels":  [
                       "area-System.Memory",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/106247",
        "createdAt":  "2024-08-12T05:39:15Z",
        "number":  106247,
        "author":  "LeaFrock",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-09-18T09:45:39Z",
        "body":  "### Background and motivation\r\n\r\n`BinaryPrimitives` provides APIs like `WriteInt32LittleEndian` which are indeed flexible. But I still want to suggest an out-of-box group of APIs called `GetLittleEndianBytes` and `GetBigEndianBytes`.\r\n\r\n## My Reasons\r\n\r\n### R1\r\n\r\n#### 1.1\r\nFor most cases, especially in the runtime itself, `WriteInt32LittleEndian` is enough. But under some scenarios, the developer will be limited to use a simple `byte[]`. \r\nFor example, I just want to store a binary format of Int32 into Redis, and the client library requires a `byte[]` input. So I have to write codes like,\r\n\r\n```csharp\r\n        var bytes = new byte[sizeof(int)];\r\n        BinaryPrimitives.WriteInt32LittleEndian(bytes, value);\r\n```\r\n\r\nI\u0027ve searched on Github and found some similar user cases:\r\nhttps://github.com/soupstream/InfiniteVariantTool/blob/17e407f6939e875a0dd0a6c182eef542f4079012/Core/UrlHasher.cs#L81\r\nhttps://github.com/iggy-rs/iggy-dotnet-client/blob/a881538b19acd012f00a9f6cc405000740e0cfed/Iggy_SDK/Identifier.cs#L14\r\n\r\nSo for these cases, writing a byte array manually is unnecessary and error-prone. \r\n\r\n#### 1.2\r\n\r\nA similar case is [RandomNumberGenerator.GetBytes](https://github.com/dotnet/runtime/issues/42769).\r\n\r\n#### 1.3\r\n\r\nIt will be a better replace for `BitConverter.GetBytes` which a developer has to deal with endianness check\u0026reverse by himself.\r\n\r\n### R2\r\nIt\u0027s not just a simple wrapper of `WriteInt32LittleEndian` APIs. We can still gain a little bit perf improvement as the byte array size is expectable, so that a size check of `Marshal.Write` is avoidable.\r\n\r\n```csharp\r\n            if ((uint)sizeof(T) \u003e (uint)destination.Length)\r\n            {\r\n                ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.length);\r\n            }\r\n```\r\n### API Proposal\r\n\r\n```csharp\r\nusing System.Buffers.Binary;\r\n\r\npublic partial class BinaryPrimitives\r\n{\r\n    // Not write but include the rest overloads of other primitive number types.\r\n    // I\u0027ll make up it as long as you show interests in this suggestion.\r\n\r\n    public static byte[] GetLittleEndianBytes(int value);\r\n    public static byte[] GetLittleEndianBytes(long value);\r\n\r\n    public static byte[] GetBigEndianBytes(int value);\r\n    public static byte[] GetBigEndianBytes(long value);\r\n}\r\n```\r\n\r\n### API Usage\r\n\r\n```csharp\r\nvar bytes = BinaryPrimitives.GetLittleEndianBytes(123456789);\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nNone.\r\n\r\n### Risks\r\n\r\nNone.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOjIw5wA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6IFi3E",
                                           "createdAt":  "2024-08-12T05:49:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "It may fit better for `BitConverter`. There are already `BitConverter.GetBytes` overloads for byte in current endianness.",
                                           "updatedAt":  "2024-08-12T05:49:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6IFtMR",
                                           "createdAt":  "2024-08-12T06:29:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "LeaFrock",
                                           "body":  "\u003e It may fit better for `BitConverter`. There are already `BitConverter.GetBytes` overloads for byte in current endianness.\r\n\r\nI think, to some extent, `BitConverter` is kind of legacy from NFX time. A developer has to deal with endianness check and reverse manually, which `BinaryPrimitives` already does (normally with higher perf).",
                                           "updatedAt":  "2024-08-12T06:29:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6IIhNY",
                                           "createdAt":  "2024-08-12T13:05:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-08-12T13:05:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6MjDnA",
                                           "createdAt":  "2024-09-18T09:45:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jilles-sg",
                                           "body":  "I don\u0027t think https://github.com/soupstream/InfiniteVariantTool/blob/17e407f6939e875a0dd0a6c182eef542f4079012/Core/UrlHasher.cs#L81 is that good an example since the intermediate `List\u003cbyte[]\u003e` is a waste. If the code were to be changed to hash spans directly, using a temporary `stackalloc byte[]` with the existing `BinaryPrimitives` API would be clearly better.",
                                           "updatedAt":  "2024-09-18T09:45:38Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "[API Proposal]: Add `GetLittleEndianBytes/GetBigEndianBytes` overloads in `BinaryPrimitives`",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/106611",
        "createdAt":  "2024-08-19T07:41:33Z",
        "number":  106611,
        "author":  "sirinath",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-08-23T02:04:23Z",
        "body":  "Is it possible to add minimum allocation and low overhead direct support for Linq on Memory and Span please.\r\n\r\nThere is this project but it does not seam to that well maintained: https://github.com/VictorNicollet/NoAlloq\r\n\r\nDirect support as part of the standard library would much welcome.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOiNirAA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6I2E8q",
                                           "createdAt":  "2024-08-19T07:42:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-08-19T07:42:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6I2KsA",
                                           "createdAt":  "2024-08-19T07:54:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sirinath",
                                           "body":  "@dotnet/area-system-linq\r\n@dotnet/area-system-runtime\r\n@dotnet/area-system-memory",
                                           "updatedAt":  "2024-08-19T07:54:08Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[Feature Request] Direct Linq support for Memory and Span",
        "labels":  [
                       "area-System.Memory",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/107148",
        "createdAt":  "2024-08-29T17:57:19Z",
        "number":  107148,
        "author":  "masonwheeler",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODJjwvg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "grbell-ms",
                                            "createdAt":  "2025-07-25T22:02:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lostromb",
                                            "createdAt":  "2025-08-01T18:46:22Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2025-08-17T12:34:06Z",
        "body":  "### Background and motivation\n\nhttps://github.com/dotnet/runtime/issues/27831 added `ReadSpan\u003cT\u003e` and `WriteSpan\u003cT\u003e` methods to `SafeBuffer`, with the explicit intent of surfacing them in `UnmanagedMemoryAccessor` in a later PR:\r\n\r\n\u003e The motivation for this is for a later API proposal to add the same methods to `UnmanagedMemoryAccessor` which will work for memory mapped views.\r\n\r\nThis was merged 4 years ago, but the later PR appears to have never happened.\n\n### API Proposal\n\nAdd the following methods to `UnmanagedMemoryAccessor`:\r\n\r\n```\r\n+        public void ReadSpan\u003cT\u003e(ulong byteOffset, Span\u003cT\u003e buffer) where T : struct\r\n+        public void WriteSpan\u003cT\u003e(ulong byteOffset, ReadOnlySpan\u003cT\u003e data) where T : struct\r\n```\r\n\r\nTheir implementations would be similar to the existing `ReadArray\u003cT\u003e` and `WriteArray\u003cT\u003e` methods, doing verification and then calling the corresponding methods on `_buffer`.\n\n### API Usage\n\n```csharp\r\n\r\nstring text = \"Hello, World!\";\r\nmyMemoryMappedViewAccessor.WriteSpan(MY_OFFSET, text.AsSpan());\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\nNone that I can see; the underlying APIs were developed specifically for this purpose.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOvmYJGQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6KMaPo",
                                           "createdAt":  "2024-08-29T17:57:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-08-29T17:57:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc67fGAA",
                                           "createdAt":  "2025-08-01T18:59:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lostromb",
                                           "body":  "I came here to post this. This seems like an almost trivially simple use case to implement that I\u0027m surprised it hasn\u0027t been done yet, even with pre-span `byte[] array, int offset, int count` style function signatures.\n\nThe current runtime `ReadArray\u003cT\u003e` and `WriteArray\u003cT\u003e` internally run a struct marshaller iterating over every single array index, which for the case of `byte`, the marshaller does nothing except prevent the use of CPU-optimized mem copies using SIMD or equivalent., making the copies run (by my measurement) about 30x slower than they should be.\n\nWorking around this currently requires code similar to:\n\n```csharp\nunsafe\n{\n    byte* ptr = null;\n    fileAccessor.SafeMemoryMappedViewHandle.AcquirePointer(ref ptr);\n    new Span\u003cbyte\u003e(ptr + readOffset, length).CopyTo(buf.AsSpan(writeOffset, length));\n    fileAccessor.SafeMemoryMappedViewHandle.ReleasePointer();\n}\n```\n\nHeck, I might just create the pull request myself.....",
                                           "updatedAt":  "2025-08-01T18:59:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6-Yu0F",
                                           "createdAt":  "2025-08-17T05:58:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "aka-nse",
                                           "body":  "@masonwheeler \nWhy did you choice `ulong` for byte offset parameter in your proposal?\nOther APIs in `UnmanagedMemoryAccessor` employs `long` type to specify position, and `ulong` is CLS incompliant.",
                                           "updatedAt":  "2025-08-17T05:58:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6-ZgkZ",
                                           "createdAt":  "2025-08-17T12:34:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "masonwheeler",
                                           "body":  "@aka-nse It\u0027s been long enough now that I don\u0027t remember.  `long` works just fine too.",
                                           "updatedAt":  "2025-08-17T12:34:06Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "[API Proposal]: Add read/write span methods to UnmanagedMemoryAccessor ",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/110115",
        "createdAt":  "2024-11-24T12:55:30Z",
        "number":  110115,
        "author":  "silkfire",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODRO2XA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rampaa",
                                            "createdAt":  "2025-02-11T19:25:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pawchen",
                                            "createdAt":  "2025-04-15T09:28:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rainersigwald",
                                            "createdAt":  "2025-04-16T20:12:50Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Klotzi111",
                                            "createdAt":  "2025-06-01T15:12:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "frasten",
                                            "createdAt":  "2025-09-17T11:02:46Z"
                                        }
                                    ],
                          "totalCount":  5
                      },
        "updatedAt":  "2025-06-10T17:42:53Z",
        "body":  "### Background and motivation\n\nThere currently doesn\u0027t seem to be a means of checking whether the beginning or the end of a string equals to any of the values contained in a specified  set of values in an optimized way using `SearchValues\u003cstring\u003e` that was introduced in .NET 9. There are other specialized extension APIs involving `ReadOnlySpan\u003cchar\u003e` and `SearchValues\u003cstring\u003e` that were recently added (e.g. `IndexOfAny\u003cT\u003e(ReadOnlySpan\u003cchar\u003e, SearchValues\u003cstring\u003e)`, `ContainsAny(ReadOnlySpan\u003cchar\u003e, SearchValues\u003cstring\u003e)` et al.) but this particular API seems to be missing.\n\nOne use case could be if you need to efficiently check whether a string starts with any one of a particular set of prefixes in order to determine whether your application code supports or handles that particular item.\n\nSee also #94155.\n\n### API Proposal\n\n```csharp\nnamespace System;\n\npublic static class MemoryExtensions\n{\n    // Proposed\n    public static bool StartsWithAny(this System.ReadOnlySpan\u003cchar\u003e span, System.Buffers.SearchValues\u003cstring\u003e values);\n    public static bool EndsWithAny(this System.ReadOnlySpan\u003cchar\u003e span, System.Buffers.SearchValues\u003cstring\u003e values);\n}\n```\n\n\n### API Usage\n\n```csharp\nvar searchValues = SearchValues.Create(new[] { \"P1\", A99\", \"B44\" }.AsSpan(), StringComparison.Ordinal);\n\nvar isSupported = \"testValue\".StartsWithAny(searchValues);\nvar isSupported2 = \"testValue\".EndsWithAny(searchValues);\n```\n\n\n### Alternative Designs\n\nN/A\n\n### Risks\n\nN/A",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOsG_Xog==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6Uxcmz",
                                           "createdAt":  "2024-11-24T13:07:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-11-24T13:07:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6UySDY",
                                           "createdAt":  "2024-11-24T20:13:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD8Slwg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "silkfire",
                                                                               "createdAt":  "2024-11-24T20:52:23Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "What sort of use cases do you have for `EndsWithAny` (note that we also didn\u0027t expose a `LastIndexOfAny` for `SearchValues\u003cstring\u003e`)?",
                                           "updatedAt":  "2024-11-24T20:13:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6UySzo",
                                           "createdAt":  "2024-11-24T20:18:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "silkfire",
                                           "body":  "Good question; I actually wasn\u0027t aware of that. I assume `StartsWithAny` would be more common (and therefore more useful) than `EndsWithAny` so including the latter one would only be to make the API complete.",
                                           "updatedAt":  "2024-11-24T20:18:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6VoBiG",
                                           "createdAt":  "2024-12-01T23:16:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "Re `StartsWithAny`, I have a use case in #104999 where I\u0027d love to use it.\n\nI don\u0027t currently have a use case for `EndsWithAny` though.",
                                           "updatedAt":  "2024-12-01T23:16:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6VoCsd",
                                           "createdAt":  "2024-12-01T23:29:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "As a workaround, you can use `text.IndexOfAny(values) == 0`, which would give you the same answer.\nDepending on your inputs, that could be more expensive than intended though (long haystack with no matches).",
                                           "updatedAt":  "2024-12-01T23:29:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6apD9B",
                                           "createdAt":  "2025-01-16T04:30:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "Assigned to @krwq for triage and consultation with @MihaZupan and @stephentoub.",
                                           "updatedAt":  "2025-01-16T04:30:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6nJ9H4",
                                           "createdAt":  "2025-04-15T09:22:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEUuvYw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Klotzi111",
                                                                               "createdAt":  "2025-06-01T15:14:19Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "pawchen",
                                           "body":  "An example for `LastIndexOfAny`: When generating API names from Vulkan [vk.xml](https://github.com/KhronosGroup/Vulkan-Docs/blob/main/xml/vk.xml), a lot of names contain the suffix defined in the `\u003ctags\u003e` and somehow want to strip those.",
                                           "updatedAt":  "2025-04-15T09:22:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6wb9ei",
                                           "createdAt":  "2025-06-10T17:42:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEioNHQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pawchen",
                                                                               "createdAt":  "2025-06-11T05:00:54Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "frasten",
                                                                               "createdAt":  "2025-09-17T11:04:53Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "xeromorph",
                                           "body":  "another use case for `LastIndexOfAny` for us would be checking Uri.Host ends with specific allowed domains, e.g.\n```cs\nstatic readonly SearchValues\u003cstring\u003e AllowList = SearchValues.Create(\n    [\".subdomain1.org\", \".subdomain2.org\"],\n    StringComparison.OrdinalIgnoreCase);\n\nbool IsAllowed(Uri uri) =\u003e uri.Host.AsSpan().EndsWithAny(AllowList);\n```\n    ",
                                           "updatedAt":  "2025-06-10T17:42:53Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "[API Proposal]: ReadOnlySpan\u003cchar\u003e.StartsWithAny(SearchValues\u003cstring\u003e) and ReadOnlySpan\u003cchar\u003e.EndsWithAny(SearchValues\u003cstring\u003e)",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/110670",
        "createdAt":  "2024-12-12T21:12:20Z",
        "number":  110670,
        "author":  "MihaZupan",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODDGDRQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sunkin351",
                                            "createdAt":  "2024-12-12T21:39:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-12-12T21:56:52Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pinkfloydx33",
                                            "createdAt":  "2024-12-13T00:14:03Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dariusclay",
                                            "createdAt":  "2025-03-19T11:29:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "eduherminio",
                                            "createdAt":  "2025-03-19T11:34:09Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Serdar-Ozcan",
                                            "createdAt":  "2025-03-20T13:09:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "RobinsonWM",
                                            "createdAt":  "2025-04-13T22:32:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Klotzi111",
                                            "createdAt":  "2025-06-01T15:08:50Z"
                                        }
                                    ],
                          "totalCount":  8
                      },
        "updatedAt":  "2025-03-19T11:28:33Z",
        "body":  "\n### Discussed in https://github.com/dotnet/runtime/discussions/110663\n\n\u003cdiv type=\u0027discussions-op-text\u0027\u003e\n\n\u003csup\u003eOriginally posted by **f2bo** December 12, 2024\u003c/sup\u003e\n.NET 9 introduced multi-string search with `IndexOfAny(this ReadOnlySpan\u003cchar\u003e span, SearchValues\u003cstring\u003e values)`, which is great if you need to find a set of matching strings. However, and I would say more often than not, in addition to the location, you also need to know which of the search values was found, for example, to count instances for each of the search values or even just to advance a pointer past the match and continue processing.\r\n\r\nUntil now, when searching for single characters, this was trivial since the matching search value had length 1 and could be directly retrieved from the location returned by `IndexOfAny`. When searching for strings, however, it now becomes necessary to execute an additional comparison at the match location to determine which of the search values was found. \r\n\r\nI\u0027m aware that you could get this information by using a `Regex` instead, but it seems odd given that `IndexOfAny` has already determined the matching search value. Wouldn\u0027t it be possible to also return it, even if it\u0027s in the form of an index into the `ReadOnlySpan\u003cstring\u003e` that was originally used to create the `SearchValues` instance. This could be provided either as an additional output parameter or by returning a tuple that also includes the location.\r\n\r\n\r\n\r\n\u003c/div\u003e",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOoxiFeg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6XZbKe",
                                           "createdAt":  "2024-12-12T21:13:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-12-12T21:13:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6XZcdC",
                                           "createdAt":  "2024-12-12T21:16:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "This question came up a few times, including on the initial API proposal #85573 ([Alternative Designs](https://github.com/dotnet/runtime/issues/85573#:~:text=count%3B%0A%7D-,Alternative%20Designs,-Emphasize%20that%20only)) and during API reiview.\n\nThe reason why we chose not to expose the length/value that matched is that doing so means we have to choose a policy for which values we consider while matching.\nE.g. for `\"foobar\".IndexOfAny([\"foo\", \"foobar\"])`, do we return the shortest vs longest match.\nRegex was also the main expected use case for the API at the time, and it can\u0027t currently take advantage of the extra information.\n\nIf there\u0027s enough demand for the functionality, I think it\u0027d make sense to add (e.g. as an `out` param as you mention).",
                                           "updatedAt":  "2024-12-12T21:33:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6XZ8Rj",
                                           "createdAt":  "2024-12-12T22:45:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEXaWgw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "sunkin351",
                                                                               "createdAt":  "2024-12-13T00:19:52Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "dariusclay",
                                                                               "createdAt":  "2025-03-19T11:22:38Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2025-06-20T16:01:28Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "f2bo",
                                           "body":  "@MihaZupan Thanks for replying.\n\nRegarding `\"foobar\".IndexOfAny([\"foo\", \"foobar\"])`, my thinking is that if you include both in your search values, then it\u0027s because you consider them to be different and need to handle them separately, so it should return the longer match \"foobar\". If you wanted the other behavior, you would only include \"foo\" in your `SearchValues` and then disambiguate in your code.\n\n",
                                           "updatedAt":  "2024-12-13T00:38:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Xc4BZ",
                                           "createdAt":  "2024-12-13T09:03:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bencyoung-Fignum",
                                           "body":  "How about a seperate method to call with different approaches for longest/shortest once the index is returned?",
                                           "updatedAt":  "2024-12-13T09:03:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6XfktX",
                                           "createdAt":  "2024-12-13T14:55:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "f2bo",
                                           "body":  "@bencyoung-Fignum \n\n\u003e How about a seperate method to call with different approaches for longest/shortest once the index is returned?\n\nI believe a separate method would have to involve a new comparison. It would have the starting location so it would be more efficient, and probably more optimized than the code one could quickly write, but it\u0027s not taking advantage of the fact that `IndexOfAny` already determined the matching value.\n\n",
                                           "updatedAt":  "2024-12-13T14:55:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6jGDSk",
                                           "createdAt":  "2025-03-19T11:20:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEXaWhw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Demo30",
                                                                               "createdAt":  "2025-03-19T11:25:27Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "sunkin351",
                                                                               "createdAt":  "2025-04-22T20:45:44Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Klotzi111",
                                                                               "createdAt":  "2025-06-01T15:11:30Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2025-06-20T16:01:31Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "dariusclay",
                                           "body":  "This would be extremely useful to know which value, or possible values, were matched. ",
                                           "updatedAt":  "2025-03-19T11:20:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6jGIV6",
                                           "createdAt":  "2025-03-19T11:28:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEUutBA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Klotzi111",
                                                                               "createdAt":  "2025-06-01T15:11:44Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "dariusclay",
                                           "body":  "Providing SearchValues.Create overload to indicate match behavior could also be considered, eg:\n\n```cs\nvar searchValues = SearchValues.Create(values, stringComparison, matchBehavior);\n```",
                                           "updatedAt":  "2025-03-19T11:28:32Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "Return the matching search value in a multi-string search (i.e. IndexOfAny with SearchValues\u003cstring\u003e)",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/111301",
        "createdAt":  "2025-01-11T09:52:29Z",
        "number":  111301,
        "author":  "MihaZupan",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC-FnAQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pinkfloydx33",
                                            "createdAt":  "2025-01-11T11:51:04Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ovska",
                                            "createdAt":  "2025-01-11T13:40:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2025-01-11T16:06:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Sergio0694",
                                            "createdAt":  "2025-01-13T11:55:34Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2025-01-23T17:29:13Z",
        "body":  "### Background and motivation\n\nWith more and more methods having the signature of `bool TryFoo(..., out int charsWritten)`, you run into situations where you\u0027re copying things from a span, but then have to manually deal with the `out` parameter.\nHaving overloads that out the number of elements written can help avoid the boilerplate.\n\n### API Proposal\n\n```diff\nnamespace System;\n\npublic sealed class String\n{\n    public bool TryCopyTo(Span\u003cchar\u003e destination);\n+   public bool TryCopyTo(Span\u003cchar\u003e destination, out int charsWritten);\n}\n\npublic readonly struct ReadOnlySpan\u003cT\u003e\n{\n    public bool TryCopyTo(Span\u003cT\u003e destination);\n+   public bool TryCopyTo(Span\u003cT\u003e destination, out int elementsWritten);\n}\n\npublic readonly struct Span\u003cT\u003e\n{\n    public bool TryCopyTo(Span\u003cT\u003e destination);\n+   public bool TryCopyTo(Span\u003cT\u003e destination, out int elementsWritten);\n}\n```\n\n### API Usage\n\n```diff\n-if (result.TryCopyTo(destination))\n-{\n-    charsWritten = result.Length;\n-    return true;\n-}\n-\n-charsWritten = 0;\n-return false;\n+return result.TryCopyTo(destination, out charsWritten);\n```\n\nA couple examples from this repo:\nhttps://github.com/dotnet/runtime/blob/b35e96be62c0164a70eb3e8295b6241116be3976/src/libraries/System.Private.Uri/src/System/UriExt.cs#L631-L638\nhttps://github.com/dotnet/runtime/blob/b35e96be62c0164a70eb3e8295b6241116be3976/src/libraries/System.Private.Uri/src/System/Uri.cs#L1630-L1637\nhttps://github.com/dotnet/runtime/blob/b35e96be62c0164a70eb3e8295b6241116be3976/src/libraries/Common/src/System/Security/Cryptography/Helpers.cs#L89-L99\nhttps://github.com/dotnet/runtime/blob/b35e96be62c0164a70eb3e8295b6241116be3976/src/libraries/System.Private.CoreLib/src/System/Globalization/Normalization.cs#L51-L58\nhttps://github.com/dotnet/runtime/blob/b35e96be62c0164a70eb3e8295b6241116be3976/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/ValueListBuilder.cs#L149-L159\n\n### Alternative Designs\n\n- More types?\n- `elementsWritten` vs `itemsWritten`?\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOm484Nw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6aFtVk",
                                           "createdAt":  "2025-01-11T09:52:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-01-11T09:52:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6aGKr_",
                                           "createdAt":  "2025-01-11T15:46:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEDv6Ng==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MichalPetryka",
                                                                               "createdAt":  "2025-01-11T17:31:23Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Peter-Juhasz",
                                                                               "createdAt":  "2025-01-11T18:34:17Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "DrkWzrd",
                                                                               "createdAt":  "2025-01-12T00:40:59Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "omariom",
                                                                               "createdAt":  "2025-01-12T12:33:15Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "PaulusParssinen",
                                                                               "createdAt":  "2025-01-13T12:20:16Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "gfoidl",
                                                                               "createdAt":  "2025-01-13T19:19:28Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "krwq",
                                                                               "createdAt":  "2025-01-23T13:38:19Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  7
                                                         },
                                           "author":  "NinoFloris",
                                           "body":  "One downside is that it might give users the idea a buffer saturating copy is done for these overloads. Instead it\u0027s just the normal binary outcome of TryCopyTo, either everything was copied or nothing was. I\u0027m not sure that creating this potential for confusion is worth it on the api surface. They also seem like easy extension methods to define internally.",
                                           "updatedAt":  "2025-01-11T15:46:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6aJub3",
                                           "createdAt":  "2025-01-13T06:13:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "As far as I\u0027m aware, none of the `Try*` APIs in the base libraries that only return an `out int written` support partial operations.\nThose that do also return the number of consumed elements, or use the `OperationStatus` pattern.\n\nI agree that `Copy-` is a bit special because it\u0027s obvious that `elementsRead == elementsWritten`, though I think that a method with the alternative behavior you described would/should be called something along the lines of `Read` or `Consume` instead.\n\n\u003e They also seem like easy extension methods to define internally.\n\nThey are simple, but it\u0027s unfortunate if they\u0027re something that many projects would have to implement.\nFor example when looking through runtime, I see usages in these: https://github.com/MihaZupan/runtime/commit/bf0d67a3c0536049707081be07288e1bc8bda311.",
                                           "updatedAt":  "2025-01-13T06:13:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6apDp4",
                                           "createdAt":  "2025-01-16T04:28:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "Assigned to @krwq for triage.",
                                           "updatedAt":  "2025-01-16T04:28:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6bjzg3",
                                           "createdAt":  "2025-01-23T13:47:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "krwq",
                                           "body":  "@MihaZupan after looking at your example I see this as useful utility but without reading anything I thought the bool flag was to tell if it copied partial or entire input so I 100% agree with @NinoFloris on this. If we\u0027re going to consider this it needs better name for what it does so it is not confusing but the fact I cannot come up with any name is usually a first sign for me that there is something wrong with the abstraction. Perhaps there is some better way to solve this than creating this API (i.e. syntax sugar or something to make this easier but I can\u0027t come up with anything at the moment).\n\nSince this is not necessarily needed for .NET 10 I\u0027ll mark it as Future for now but I do agree that lack of it adds lots of boilerplate in the code so I\u0027ll leave it open so we can keep discussing possible approach to address the boilerplate.",
                                           "updatedAt":  "2025-01-23T13:47:32Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "[API Proposal]: `TryCopyTo(destination, out int elementsWritten)`",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/111500",
        "createdAt":  "2025-01-16T16:31:57Z",
        "number":  111500,
        "author":  "epeshk",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC-Yo0w==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kronic",
                                            "createdAt":  "2025-01-16T20:41:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "vladd",
                                            "createdAt":  "2025-01-17T09:40:58Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2025-01-17T13:35:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MineCake147E",
                                            "createdAt":  "2025-01-23T03:25:04Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2025-07-14T19:29:43Z",
        "body":  "### Background and motivation\n\nCustom binary search algorithm implementations are error-prone. Developers must deal with integer overflow, off-by-one bugs, empty arrays, and should decide which variable to return: Left or Right. It is hard to remember (maybe just for me) how to write a proper binary search implementation. I always forget it in within an hour after learning it again.\n\nBuilt-in .NET implementations like `Array.BinarySearch` and `Span.BinarySearch` return the index of the first matching element found. This is sufficient to check if an element is present in a Span, but this approach cannot help, for example, to count elements less than or greater than a given x when the Span contains duplicates of x.\n\nSpecial API to find boundaries of duplicating elements in `Span` may help for this cases.\n\nOriginally I tried to solve a Leetcode problem, and ended up writing custom binary search. Custom binary search or loop [wrapper](https://github.com/dotnet/coreclr/pull/2447#issuecomment-166741996) over `Span.BinarySearch` is 33% of solution code (20 lines for custom binary search in Span, 40 lines for other logic)\n\nC++ has `std::lower_bound/upper_bound` and Python has `bisect.bisect_left/bisect_right` for this purpose.\n\n### API Proposal\n\n```csharp\nnamespace System;\n\npublic class MemoryExtensions\n{\n  public static int BinarySearch\u003cT\u003e(this Span\u003cT\u003e span, IComparable\u003cT\u003e comparable, BinarySearchKind kind);\n  public static int BinarySearch\u003cT, TComparable\u003e(this Span\u003cT\u003e span, TComparable comparable, BinarySearchKind kind) where TComparable : IComparable\u003cT\u003e;\n  public static int BinarySearch\u003cT, TComparer\u003e(this Span\u003cT\u003e span, T value, TComparer comparer, BinarySearchKind kind) where TComparer : IComparer\u003cT\u003e;\n  public static int BinarySearch\u003cT\u003e(this ReadOnlySpan\u003cT\u003e span, IComparable\u003cT\u003e comparable, BinarySearchKind kind);\n  public static int BinarySearch\u003cT, TComparable\u003e(this ReadOnlySpan\u003cT\u003e span, TComparable comparable, BinarySearchKind kind) where TComparable : IComparable\u003cT\u003e;\n  public static int BinarySearch\u003cT, TComparer\u003e(this ReadOnlySpan\u003cT\u003e span, T value, TComparer comparer, BinarySearchKind kind) where TComparer : IComparer\u003cT\u003e\n}\n\npublic enum BinarySearchKind {\n  FirstMatchingElement = 0,\n  LowerBound = 2,\n  UpperBound = 3\n}\n```\n\n### API Usage\n\n\n```csharp\nint CountElementsLessThan(Span\u003cint\u003e span, int value)\n{\n  var lowerBound = span.BinarySearch(value, BinarySearchStrategy.LowerBound);\n  return lowerBound \u003c 0 ? ~lowerBound : lowerBound;\n}\n```\n\nAlternative design:\n```csharp\nint CountElementsLessThan(Span\u003cint\u003e span, int value)\n{\n  var lowerBound = span.LowerBound(value);\n  return lowerBound \u003c 0 ? ~lowerBound : lowerBound;\n}\n```\n\nWorkaround with [existing](https://github.com/dotnet/coreclr/pull/2447#issuecomment-166741996) API:\n```csharp\n\npublic int LowerBound(Span\u003cint\u003e span, int value)\n{\n  int first = span.BinarySearch(value);\n  int high = first;\n  while (high \u003e= 0)\n  {\n    first = high;\n    high = span[..high].BinarySearch(value);\n   }\n  return first;\n}\n\npublic int CountElementsLessThan(Span\u003cint\u003e span, int value)\n{\n  int lowerBound = LowerBound(span, value);\n  return first \u003c 0 ? ~first : first;\n}\n```\n\n### Alternative Designs\n\n`BinarySearchStrategy strategy` instead of `BinarySearchKind kind`\n\n====\n\nSeparate methods in `MemoryExtensions` class for lower/upper bound and range\n\n```csharp\nnamespace System;\n\npublic class MemoryExtensions\n{\n  /// \u003csummary\u003e\n  /// Searches an entire sorted \u003csee cref=\"Span{T}\"/\u003e for a first element which is not ordered before value\n  /// using the specified \u003csee cref=\"IComparable{T}\"/\u003e generic interface.\n  /// \u003c/summary\u003e\n  /// \u003ctypeparam name=\"T\"\u003eThe element type of the span.\u003c/typeparam\u003e\n  /// \u003cparam name=\"span\"\u003eThe sorted \u003csee cref=\"Span{T}\"/\u003e to search.\u003c/param\u003e\n  /// \u003cparam name=\"comparable\"\u003eThe \u003csee cref=\"IComparable{T}\"/\u003e to use when comparing.\u003c/param\u003e\n  /// \u003creturns\u003e\n  /// The zero-based index of first \u003cparamref name=\"comparable\"/\u003e occurrence in the sorted \u003cparamref name=\"span\"/\u003e,\n  /// if \u003cparamref name=\"comparable\"/\u003e is found; otherwise, a negative number that is the bitwise complement\n  /// of the index of the next element that is larger than \u003cparamref name=\"comparable\"/\u003e or, if there is\n  /// no larger element, the bitwise complement of \u003csee cref=\"Span{T}.Length\"/\u003e.\n  /// \u003c/returns\u003e\n  /// \u003cexception cref=\"ArgumentNullException\"\u003e\n  /// \u003cparamref name = \"comparable\" /\u003e is \u003csee langword=\"null\"/\u003e .\n  /// \u003c/exception\u003e\n  public static int LowerBound\u003cT\u003e(this Span\u003cT\u003e span, IComparable\u003cT\u003e comparable);\n  public static int LowerBound\u003cT, TComparable\u003e(this Span\u003cT\u003e span, TComparable comparable) where TComparable : IComparable\u003cT\u003e;\n  public static int LowerBound\u003cT, TComparer\u003e(this Span\u003cT\u003e span, T value, TComparer comparer) where TComparer : IComparer\u003cT\u003e;\n  public static int LowerBound\u003cT\u003e(this ReadOnlySpan\u003cT\u003e span, IComparable\u003cT\u003e comparable);\n  public static int LowerBound\u003cT, TComparable\u003e(this ReadOnlySpan\u003cT\u003e span, TComparable comparable) where TComparable : IComparable\u003cT\u003e;\n  public static int LowerBound\u003cT, TComparer\u003e(this ReadOnlySpan\u003cT\u003e span, T value, TComparer comparer) where TComparer : IComparer\u003cT\u003e\n\n\n  /// \u003csummary\u003e\n  /// Searches an entire sorted \u003csee cref=\"Span{T}\"/\u003e for a first element which is ordered after value\n  /// using the specified \u003csee cref=\"IComparable{T}\"/\u003e generic interface.\n  /// \u003c/summary\u003e\n  /// \u003ctypeparam name=\"T\"\u003eThe element type of the span.\u003c/typeparam\u003e\n  /// \u003cparam name=\"span\"\u003eThe sorted \u003csee cref=\"Span{T}\"/\u003e to search.\u003c/param\u003e\n  /// \u003cparam name=\"comparable\"\u003eThe \u003csee cref=\"IComparable{T}\"/\u003e to use when comparing.\u003c/param\u003e\n  /// \u003creturns\u003e\n  /// The zero-based index of first element which is ordered after \u003cparamref name=\"comparable\"/\u003e in the sorted \u003cparamref name=\"span\"/\u003e,\n  /// if \u003cparamref name=\"comparable\"/\u003e is found; otherwise, a negative number that is the bitwise complement\n  /// of the index of the next element that is larger than \u003cparamref name=\"comparable\"/\u003e or, if there is\n  /// no larger element, the bitwise complement of \u003csee cref=\"Span{T}.Length\"/\u003e.\n  /// \u003c/returns\u003e\n  /// \u003cexception cref=\"ArgumentNullException\"\u003e\n  /// \u003cparamref name = \"comparable\" /\u003e is \u003csee langword=\"null\"/\u003e .\n  /// \u003c/exception\u003e\n  public static int UpperBound\u003cT\u003e(this Span\u003cT\u003e span, IComparable\u003cT\u003e comparable);\n  public static int UpperBound\u003cT, TComparable\u003e(this Span\u003cT\u003e span, TComparable comparable) where TComparable : IComparable\u003cT\u003e;\n  public static int UpperBound\u003cT, TComparer\u003e(this Span\u003cT\u003e span, T value, TComparer comparer) where TComparer : IComparer\u003cT\u003e;\n  public static int UpperBound\u003cT\u003e(this ReadOnlySpan\u003cT\u003e span, IComparable\u003cT\u003e comparable);\n  public static int UpperBound\u003cT, TComparable\u003e(this ReadOnlySpan\u003cT\u003e span, TComparable comparable) where TComparable : IComparable\u003cT\u003e;\n  public static int UpperBound\u003cT, TComparer\u003e(this ReadOnlySpan\u003cT\u003e span, T value, TComparer comparer) where TComparer : IComparer\u003cT\u003e\n\n  // [lowerBound; upperBound), or (upperBound, upperBound) if element is not found\n  public static Range BinarySearchRange\u003cT\u003e(this Span\u003cT\u003e span, IComparable\u003cT\u003e comparable);\n  public static Range BinarySearchRange\u003cT, TComparable\u003e(this Span\u003cT\u003e span, TComparable comparable) where TComparable : IComparable\u003cT\u003e;\n  public static Range BinarySearchRange\u003cT, TComparer\u003e(this Span\u003cT\u003e span, T value, TComparer comparer) where TComparer : IComparer\u003cT\u003e;\n  public static Range BinarySearchRange\u003cT\u003e(this ReadOnlySpan\u003cT\u003e span, IComparable\u003cT\u003e comparable);\n  public static Range BinarySearchRange\u003cT, TComparable\u003e(this ReadOnlySpan\u003cT\u003e span, TComparable comparable) where TComparable : IComparable\u003cT\u003e;\n  public static Range BinarySearchRange\u003cT, TComparer\u003e(this ReadOnlySpan\u003cT\u003e span, T value, TComparer comparer) where TComparer : IComparer\u003cT\u003e\n}\n```\n\n\n### Risks\n\nNo breaking changes, as existing APIs is not modified\n \n- Should `LowerBound/UpperBound` return bitwise complement when value is not present for consistency with `BinarySearch`, or it is better to just return a non-negative index?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOtwdlnQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6avqcX",
                                           "createdAt":  "2025-01-16T16:32:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-01-16T16:32:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6awE7H",
                                           "createdAt":  "2025-01-16T17:21:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "The proposed use of Range in the alternative design looks surprising to me (can callers assume that `range.End.IsFromEnd` is always false?) but the [System.Text.Ascii.Trim](https://learn.microsoft.com/dotnet/api/system.text.ascii.trim?view=net-8.0) methods already return Range in a similar way; that was requested in \u003chttps://github.com/dotnet/runtime/issues/28230#issuecomment-603439786\u003e.",
                                           "updatedAt":  "2025-01-16T17:21:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6duI6O",
                                           "createdAt":  "2025-02-09T08:08:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "Assigned to @tannergooding for triage.",
                                           "updatedAt":  "2025-02-09T08:08:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc63B2Wd",
                                           "createdAt":  "2025-07-14T19:29:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "CC. @stephentoub for input.\n\nYou can mostly achieve this today with `BinarySearch` or `IndexOf` and slicing. But we could definitely optimize it and it is something several other ecosystems provide as a common operation.",
                                           "updatedAt":  "2025-07-14T19:29:29Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "[API Proposal]: Span\u003cT\u003e.LowerBound, UpperBound binary search",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/111570",
        "createdAt":  "2025-01-18T13:09:04Z",
        "number":  111570,
        "author":  "paulomorgado",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-26T09:50:52Z",
        "body":  "### Background and motivation\n\n`ReadOnlySequence\u003cT\u003e` has APIs to create empty or single-segment instances, but there\u0027s no on-the-box help for creating multiple-segment instances.\n\nThe first thing a user needs to do is create a `ReadOnlySequenceSegment\u003cT\u003e` derived class.\n\n### API Proposal\n\nASP.NET Core has a few implementations of this:\n\n```csharp\ninternal sealed class BufferSegment : ReadOnlySequenceSegment\u003cbyte\u003e\n{\n    public BufferSegment(Memory\u003cbyte\u003e memory)\n    {\n        Memory = memory;\n    }\n \n    public BufferSegment Append(ReadOnlyMemory\u003cbyte\u003e memory)\n    {\n        var segment = new BufferSegment(memory)\n        {\n            RunningIndex = RunningIndex + Memory.Length\n        };\n        Next = segment;\n        return segment;\n    }\n}\n```\n\nJust having a public implementation would go a long way helping users.\n\nI know there are a few more elaborated implementations, but just having this would help a lot.\n\nAdding to that, simple APIs to create from `IEnumerable\u003cIEnumerable\u003cT\u003e\u003e`\n\n```csharp\nnew ReadOnlySequence\u003cT\u003e(IEnumerable\u003cIEnumerable\u003cT\u003e\u003e source);\nnew ReadOnlySequence\u003cT,U\u003e(U source, Func\u003cU, IEnumerable\u003cIEnumerable\u003cT\u003e\u003e sourceSelector, Func\u003cIEnumerable\u003cT\u003e,ReadOnlyMemory\u003cT\u003e\u003e segmentSelector);\n\n```\n\n\n### API Usage\n\n```csharp\nReadOnlySequence\u003cbyte\u003e Transform(ReadOnlySequence\u003cbyte\u003e source, Func\u003cReadOnlyMemory\u003cbyte\u003e, ReadOnlyMemory\u003cbyte\u003e\u003e transform)\n{\n    var e = source.GetEnumerable();\n\n    if (!e.MoveNext())\n    {\n        return ReadOnlySequence\u003cbyte\u003e.Empty;\n    }\n\n    ReadOnlySequenceSegment\u003cT\u003e? first = null;\n    ReadOnlySequenceSegment\u003cT\u003e last;\n\n    do\n    {\n        if (first is null)\n        {\n            last = first = new BufferSegment(transform(e.Current));\n        }\n        else\n        {\n            last = last.Append(transform(e.Current));\n        }\n    }\n    while (e.MoveNext());\n\n    return new ReadOnlySequence\u003cbyte\u003e(first, 0, last, last.Memory.Length);\n}\n```\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOmvWYgA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6a9HXS",
                                           "createdAt":  "2025-01-18T13:09:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-01-18T13:09:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6a9JKT",
                                           "createdAt":  "2025-01-18T13:31:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "I think you\u0027re missing the proposed API part :)",
                                           "updatedAt":  "2025-01-18T13:31:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6a9L3D",
                                           "createdAt":  "2025-01-18T14:06:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "paulomorgado",
                                           "body":  "\u003e I think you\u0027re missing the proposed API part :)\n\nAm I?\n\nI didn\u0027t provide an implementation, but I did provide a sample API.\n\nThis needs to be triaged first. If accepted, I can bootstrap an implementation. ",
                                           "updatedAt":  "2025-01-18T14:06:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6a9MO6",
                                           "createdAt":  "2025-01-18T14:11:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "![Image](https://github.com/user-attachments/assets/83a0afcf-95b7-41d7-9c50-dc8d5125577f)",
                                           "updatedAt":  "2025-01-18T14:11:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6a9ZiA",
                                           "createdAt":  "2025-01-18T16:54:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "`ReadOnlySequence\u003cT\u003e` is a high-performance and advanced API, and in order to fully take advantage of its capabilities and reduce memory allocations, you need a mechanism of reusing the sequence segment objects and maybe storing additional information, which will require subclassing `ReadOnlySequenceSegment\u003cT\u003e`.\n\n\u003e create from `IEnumerable\u003cIEnumerable\u003cT\u003e\u003e`\n\nIf we decide to add a convenience API to create `ROS`, it should accept `IEnumerable\u003cReadOnlyMemory\u003cT\u003e\u003e`, making the second of proposed overload unnecessary. I\u0027m not sure if it is a good idea though, as it will lead people into a performance pit of failure.",
                                           "updatedAt":  "2025-01-18T16:54:16Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "[API Proposal]: Add possibility to create ReadOnlySequence\u003cT\u003e with multiple segments.",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/111583",
        "createdAt":  "2025-01-19T03:14:21Z",
        "number":  111583,
        "author":  "DaZombieKiller",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-26T09:49:28Z",
        "body":  "### Background and motivation\n\n`IPinnable` and `MemoryHandle` provide a nice abstraction for pinning memory in a safe(r) manner. Unfortunately, core types like `SafeBuffer` do not implement it, necessitating additional allocations to use them with `MemoryHandle` (as it requires an `IPinnable` instance).\n\nI am proposing to implement `IPinnable` on these types (among others) to allow `MemoryHandle` to be used in more scenarios. In the case of `UnmanagedMemoryStream`, it would allow a developer to safely obtain a pointer to the memory even if the stream is backed by a `SafeBuffer` (accessing `UnmanagedMemoryStream.PositionPointer` throws for that case today, and there is no way to obtain the underlying `SafeBuffer`).\n\n### API Proposal\n\n```cs\nnamespace System.IO\n{\n    public partial class UnmanagedMemoryStream : System.Buffers.IPinnable\n    {\n        public System.Buffers.MemoryHandle Pin(int elementIndex = 0);\n        public void Unpin();\n    }\n\n    public partial class UnmanagedMemoryAccessor : System.Buffers.IPinnable\n    {\n        public System.Buffers.MemoryHandle Pin(int elementIndex = 0);\n        public void Unpin();\n    }\n}\n\nnamespace System.Runtime.InteropServices\n{\n    public partial class SafeBuffer : System.Buffers.IPinnable\n    {\n        public System.Buffers.MemoryHandle Pin(int elementIndex = 0);\n        public void Unpin();\n    }\n}\n```\nThe memory managed by the above types is already pinned, so the purpose largely served by `MemoryHandle` is to prevent finalization of the underlying buffer. It may make sense to expose `IPinnable` on types like `MemoryStream` as well, which would produce a `GCHandle`-backed `MemoryHandle`:\n```cs\nnamespace System.IO\n{\n    public partial class MemoryStream : System.Buffers.IPinnable\n    {\n        public System.Buffers.MemoryHandle Pin(int elementIndex = 0);\n        public void Unpin();\n        // Maybe also GetPinnableReference?\n    }\n}\n```\n\n### API Usage\n\n`UnmanagedMemoryStream.PositionPointer` will throw today if the `UnmanagedMemoryStream` is backed by a `SafeBuffer`. If it didn\u0027t do this, using it would require a `GC.KeepAlive`:\n```cs\nbyte* pointer = stream.PositionPointer;\nNativeMethod(pointer, stream.Length);\nGC.KeepAlive(stream);\n```\nWhich is presumably why `SafeBuffer`-backed streams do not allow accessing `PositionPointer` today. With `IPinnable` the `SafeBuffer` can be tracked, and usage becomes:\n```cs\nusing MemoryHandle handle = stream.Pin();\nNativeMethod(handle.Pointer, stream.Length);\n```\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n`MemoryHandle` exposes a raw pointer to the consumer. This could enable mutation of buffers that otherwise would not be possible (i.e. a read-only `UnmanagedMemoryAccessor` over mutable memory, or a read-only `MemoryStream` that does not expose its buffer). However, `MemoryHandle` is an `unsafe`-equivalent type and this risk already exists elsewhere (`GetPinnableReference`, `fixed`, etc.).",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOmwHx1g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6bAeFn",
                                           "createdAt":  "2025-01-19T04:38:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEDOZaw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "adamsitnik",
                                                                               "createdAt":  "2025-01-20T08:56:44Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "Pinning is only a concept for managed heap. Both `UnmanagedMemoryStream` and `SafeBuffer` point to unmanaged heap that\u0027s not movable. It sounds like a gap of `UnmanagedMemoryStream`, since `SafeBuffer` allows acquiring pointer (with manual reference counting).",
                                           "updatedAt":  "2025-01-19T04:38:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6bAfHW",
                                           "createdAt":  "2025-01-19T04:59:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "DaZombieKiller",
                                           "body":  "\u003e Pinning is only a concept for managed heap. Both `UnmanagedMemoryStream` and `SafeBuffer` point to unmanaged heap that\u0027s not movable.\n\nYep, I acknowledged this in the API Proposal section. Technically the implementation of `Pin` on those types would not be \"pinning\" the memory (but if this were implemented on `MemoryStream` it would), but the same goes for a `MemoryManager\u003cT\u003e` backed by a `SafeBuffer` or raw pointer.\n\nYou could think of `Pin` on `IPinnable` as \"give me a fixed pointer to the memory\" rather than \"pin this buffer\". Pinning is just something that the implementation might need to do to satisfy that request. The main benefit is that `MemoryHandle` can also store the `SafeBuffer` to prevent it from being finalized early.\n\nProviding an accessor for the `SafeBuffer` on `UnmanagedMemoryStream`/`UnmanagedMemoryAccessor` would be a potential alternative for those types and would at least allow you to access the memory, but it would not serve the main purpose of this proposal: allowing you to treat `MemoryHandle` like a \"general\" handle-to-buffer type without allocating `IPinnable` wrappers.",
                                           "updatedAt":  "2025-01-19T05:02:03Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[API Proposal]: Implement `IPinnable` on more types",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/113477",
        "createdAt":  "2025-03-13T16:04:04Z",
        "number":  113477,
        "author":  "JoshLove-msft",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-03-14T01:19:22Z",
        "body":  "There are cases where you are dealing with a BinaryData instance which contains some data following a known JSON schema under a given property, e.g.\n\n```json\n{\n  \"pets\": [\n    {\n      \"id\": 1,\n      \"name\": \"Buddy\",\n      \"type\": \"Dog\",\n      \"age\": 5\n    },\n    {\n      \"id\": 2,\n      \"name\": \"Mittens\",\n      \"type\": \"Cat\",\n      \"age\": 3\n    }\n  ],\n  \"next\": \"https://api.example.com/pets?page=2\"\n}\n```\n\nI want to deserialize everything under \"pets\" into a `List\u003cPet\u003e`. There isn\u0027t a simple way to do this with the BinaryData API. In Azure, there is an [extension method](https://learn.microsoft.com/en-us/dotnet/api/azure.azurecoreextensions.todynamicfromjson?view=azure-dotnet#azure-azurecoreextensions-todynamicfromjson(system-binarydata)) that allows you converting BinaryData to a dynamic type. There is also another extension method that allows converting to a dictionary of string, object [here](https://github.com/Azure/azure-sdk-for-net/blob/015c8abd1090b141389beb9e151971e1ed63c363/sdk/core/Azure.Core/src/Serialization/AzureCoreExtensions.cs#L59). Having this ability outside of Azure would be helpful. \nUltimately, I\u0027d like to be able to do this:\n\n```c#\nList\u003cPet\u003e pets = binaryData[\"pets\"].ToObjectFromJson\u003cList\u003cPet\u003e\u003e();\n```\n\nor how it would look with the Azure extension method:\n\n```c#\nList\u003cPet\u003e pets = binaryData.ToDynamicFromJson().Pets.ToObjectFromJson\u003cList\u003cPet\u003e\u003e();\n```\n\nAs a workaround, I was able to use `JsonNode`, but it feels like there is something missing from the BinaryData API:\n```c#\nvar node = JsonNode.Parse(page.GetRawResponse().Content.ToString())!;\nList\u003cPet\u003e pets = node[\"pets\"].ToObjectFromJson\u003cList\u003cPet\u003e\u003e();\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOok8Now==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6iO02k",
                                           "createdAt":  "2025-03-13T16:04:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-03-13T16:04:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6iQ9h6",
                                           "createdAt":  "2025-03-13T18:35:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-03-13T18:35:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6iTw2j",
                                           "createdAt":  "2025-03-14T01:19:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "am11",
                                           "body":  "One option is to access content directly from JsonNode without making content copies, another option is to deserialize the JsonNode:\n\n```c#\nusing System;\nusing System.Text.Json;\nusing System.Text.Json.Nodes;\n\n// \u003cPackageReference Include=\"System.Memory.Data\" Version=\"9.0.3\" /\u003e\n\nReadOnlySpan\u003cbyte\u003e json = \"\"\"\n  {\n    \"pets\": [\n      {\n        \"id\": 1,\n        \"name\": \"Buddy\",\n        \"type\": \"Dog\",\n        \"age\": 5\n      },\n      {\n        \"id\": 2,\n        \"name\": \"Mittens\",\n        \"type\": \"Cat\",\n        \"age\": 3\n      }\n    ],\n    \"next\": \"https://api.example.com/pets?page=2\"\n  }\n\"\"\"u8;\n\nBinaryData binaryData = new BinaryData(json.ToArray());\n\nJsonNode? rootNode = JsonNode.Parse(binaryData.ToMemory().Span);\n\n// optin 1: access JSON array via node\nJsonArray? petsArray = rootNode?[\"pets\"]?.AsArray();\nif (petsArray is not null)\n{\n    foreach (JsonNode? petNode in petsArray) Console.WriteLine(petNode);\n}\n\n// option 2: deserialize to concrete type\nList\u003cPet\u003e? pets = JsonSerializer.Deserialize\u003cList\u003cPet\u003e\u003e(rootNode?[\"pets\"]);\nif (pets is not null)\n{\n    foreach (var pet in pets) Console.WriteLine(pet);\n}\n\nfile record Pet(int Id, string Name, string Type, int Age);\n```",
                                           "updatedAt":  "2025-03-14T01:19:21Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Add ability to convert BinaryData into a dictionary or a dynamic type",
        "labels":  [
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/113644",
        "createdAt":  "2025-03-18T12:08:29Z",
        "number":  113644,
        "author":  "paulomorgado",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-26T02:21:22Z",
        "body":  "### Background and motivation\n\nSometimes it\u0027s useful to pass along rented memory (from `MemoryPool`, for example) but a specific size is needed and not the size returned from the pool.\n\nAnd sometimes, it\u0027s required that the one that gets the IMemoryOnwer dispose of it, but not change the data.\n\n### API Proposal\n\n```csharp\ninternal sealed class MemoryOwnerSlice\u003cT\u003e(IMemoryOwner\u003cT\u003e source, Range slice) : IMemoryOwner\u003cT\u003e\n{\n    public Memory\u003cT\u003e Memory =\u003e source.Memory[slice];\n    public void Dispose() =\u003e source.Dispose();\n}\npublic interface IMemoryOwner\u003cT\u003e : IDisposable\n{\n    ReadOnlyMemory\u003cT\u003e Memory { get; }\n}\ninternal sealed class ReadOnlyMemoryOwnerSlice\u003cT\u003e(IMemoryOwner\u003cT\u003e source, Range slice) : IReadOnlyMemoryOwner\u003cT\u003e\n{\n    public ReadOnlyMemory\u003cT\u003e Memory =\u003e source.Memory[slice];\n    public void Dispose() =\u003e source.Dispose();\n}\n```\n\n\n### API Usage\n\n```csharp\nvar memoryOwner = MemoryPool\u003cbyte\u003e.Shared.Rent(10);\nvar readOnlyMemoryOwner = memoryOwner.Slice(0, 10).AsReadOnly();\n```\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOp5lIkQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6i58F-",
                                           "createdAt":  "2025-03-18T12:45:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEKnRyA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "DL444",
                                                                               "createdAt":  "2025-03-18T13:45:47Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "PaulusParssinen",
                                                                               "createdAt":  "2025-03-18T16:22:24Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "DrkWzrd",
                                                                               "createdAt":  "2025-03-19T22:00:36Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "I don\u0027t see any Slice and AsReadOnly methods in the \"API Proposal\" section.  Did you intend something like:\n\n```patch\n namespace System\n {\n     public static partial class MemoryExtensions\n     {\n+        public static IMemoryOwner\u003cT\u003e Slice\u003cT\u003e(this IMemoryOwner\u003cT\u003e owner, int start);\n+        public static IMemoryOwner\u003cT\u003e Slice\u003cT\u003e(this IMemoryOwner\u003cT\u003e owner, int start, int length);\n+        public static IReadOnlyMemoryOwner\u003cT\u003e Slice\u003cT\u003e(this IReadOnlyMemoryOwner\u003cT\u003e owner, int start);\n+        public static IReadOnlyMemoryOwner\u003cT\u003e Slice\u003cT\u003e(this IReadOnlyMemoryOwner\u003cT\u003e owner, int start, int length);\n+        public static IReadOnlyMemoryOwner\u003cT\u003e AsReadOnly\u003cT\u003e(this IMemoryOwner\u003cT\u003e owner);\n     }\n }\n\n namespace System.Buffers\n {\n+    public interface IReadOnlyMemoryOwner\u003cT\u003e : IDisposable\n+    {\n+        public ReadOnlyMemory\u003cT\u003e ReadOnlyMemory { get; }\n+    }\n }\n```\n\nIt seems `memoryOwner.Slice(range1).Slice(range2).Slice(range3)` would have to allocate a new wrapper on each call, making it more expensive than Memory\\\u003cT\\\u003e.Slice.  And the IDisposable.Dispose() methods of those wrappers seem like they could easily become a source of bugs.\n\n\u003e Sometimes it\u0027s useful to pass along rented memory (from `MemoryPool`, for example) but a specific size is needed and not the size returned from the pool.\n\nI think it would be better to keep IMemoryOwner\\\u003cT\\\u003e owning the whole array and do the slicing at the Memory\\\u003cT\\\u003e side, where it is cheaper.",
                                           "updatedAt":  "2025-03-18T12:49:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6i-rKT",
                                           "createdAt":  "2025-03-18T18:30:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "paulomorgado",
                                           "body":  "Yes, @KalleOlaviNiemitalo. Something like that. I\u0027m not that worried about implementation details at the moment.\n\n\u003e I think it would be better to keep IMemoryOwner\u003cT\u003e owning the whole array and do the slicing at the Memory\u003cT\u003e side, where it is cheaper.\n\nThe whole point of this proposal is to abstract the consumer of the size of the buffer and focus on the data.\n\nI\u0027ve been using this and think this is useful for others.",
                                           "updatedAt":  "2025-03-18T18:30:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6nmUiR",
                                           "createdAt":  "2025-04-17T05:53:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "I remembered this issue when looking at the [MemoryOwner\\\u003cT\\\u003e](https://learn.microsoft.com/dotnet/communitytoolkit/high-performance/memoryowner) documentation in `CommunityToolkit.HighPerformance`.  That provides pre-sliced Memory\\\u003cT\\\u003e and Span\\\u003cT\\\u003e instances from an ArrayPool\\\u003cT\\\u003e.  But if you want to get the memory from a MemoryPool\\\u003cT\\\u003e instead, then I don\u0027t think that implementation can help.",
                                           "updatedAt":  "2025-04-17T05:53:46Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "[API Proposal]: Consider adding IMemoryOwner\u003cT\u003e.Slice and IMemoryOwner\u003cT\u003e.AsReadOnly",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/117647",
        "createdAt":  "2025-07-15T07:07:29Z",
        "number":  117647,
        "author":  "Frulfump",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODNjFiA==",
                          "nodes":  [
                                        {
                                            "content":  "EYES",
                                            "user":  "Copilot",
                                            "createdAt":  "2025-08-31T14:47:10Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-08-31T16:02:05Z",
        "body":  "From the package README https://www.nuget.org/packages/Microsoft.Bcl.Memory/9.0.7#readme-body-tab\n(same for latest https://www.nuget.org/packages/Microsoft.Bcl.Memory/10.0.0-preview.5.25277.114#readme-body-tab)\n\u003eThis library is not necessary nor recommended when targeting versions of .NET that include the relevant support.\n\nWhich are those versions? Please include that info in the README itself.\n\n\nInspired by https://github.com/microsoftgraph/msgraph-sdk-dotnet/issues/2948",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOuVZpXQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc63IMNK",
                                           "createdAt":  "2025-07-15T07:21:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEaxomQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Frulfump",
                                                                               "createdAt":  "2025-07-15T10:01:18Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2025-07-16T12:01:02Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "`Index` and `Range` are included since .NET Standard 2.1 and .NET Core 3.0. `Base64Url` is included since .NET 9.\n\n\u003e This library is not necessary nor recommended when targeting versions of .NET that include the relevant support.\n\nThis is applicable to many OOB packages. I can\u0027t remember whether there\u0027s an SDK analyzer for this.",
                                           "updatedAt":  "2025-07-15T07:21:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc63LoPk",
                                           "createdAt":  "2025-07-15T11:41:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Frulfump",
                                           "body":  "\u003e `Index` and `Range` are included since .NET Standard 2.1 and .NET Core 3.0. `Base64Url` is included since .NET 9.\n\u003e \n\u003e \u003e This library is not necessary nor recommended when targeting versions of .NET that include the relevant support.\n\u003e \n\u003e This is applicable to many OOB packages. I can\u0027t remember whether there\u0027s an SDK analyzer for this.\n\nThanks!\n\nGetting a list of all of those OOB packages and for which .NET versions they shouldn\u0027t be used would help a lot in removing their usage since no analyzer exists and package pruning doesn\u0027t seem to cover them (yet?) (Is System.Memory included in that if so that will be handled by pruning at least.) But both of those (if they are two) would be nice to have clearly in one place to reference.\n\nI tried this using the 10.0.100-preview.5.25277.114 SDK (--tl:off made no significant difference)\n\n```sh\n➜ dotnet new console\nThe template \"Console App\" was created successfully.\n\nProcessing post-creation actions...\nRestoring C:\\repos\\repros\\runtime\\issue117647\\issue117647.csproj:\nRestore succeeded.\n\n➜ dotnet package add Microsoft.Bcl.Memory@9.0.7\n\nBuild succeeded in 0,5s\ninfo : X.509 certificate chain validation will use the default trust store selected by .NET for code signing.\ninfo : X.509 certificate chain validation will use the default trust store selected by .NET for timestamping.\ninfo : Adding PackageReference for package \u0027Microsoft.Bcl.Memory\u0027 into project \u0027C:\\repos\\repros\\runtime\\issue117647\\issue117647.csproj\u0027.\ninfo : Restoring packages for C:\\repos\\repros\\runtime\\issue117647\\issue117647.csproj...\ninfo :   GET https://api.nuget.org/v3-flatcontainer/microsoft.bcl.memory/index.json\ninfo :   OK https://api.nuget.org/v3-flatcontainer/microsoft.bcl.memory/index.json 143ms\ninfo :   GET https://api.nuget.org/v3-flatcontainer/microsoft.bcl.memory/9.0.7/microsoft.bcl.memory.9.0.7.nupkg\ninfo :   OK https://api.nuget.org/v3-flatcontainer/microsoft.bcl.memory/9.0.7/microsoft.bcl.memory.9.0.7.nupkg 139ms\ninfo : Installed Microsoft.Bcl.Memory 9.0.7 from https://api.nuget.org/v3/index.json to C:\\Users\\Christian\\.nuget\\packages\\microsoft.bcl.memory\\9.0.7 with content hash TzkwODSycZL6pdIvKYvmo8xgeObMeohNsKcqkJKrz77A7z96YRbVcwndQAQg1mBYpP3agOqeycyJjNv5fvo3wg==.\ninfo :   GET https://api.nuget.org/v3/vulnerabilities/index.json\ninfo :   OK https://api.nuget.org/v3/vulnerabilities/index.json 17ms\ninfo :   GET https://api.nuget.org/v3-vulnerabilities/2025.07.10.23.23.28/vulnerability.base.json\ninfo :   GET https://api.nuget.org/v3-vulnerabilities/2025.07.10.23.23.28/2025.07.15.05.23.42/vulnerability.update.json\ninfo :   OK https://api.nuget.org/v3-vulnerabilities/2025.07.10.23.23.28/vulnerability.base.json 19ms\ninfo :   OK https://api.nuget.org/v3-vulnerabilities/2025.07.10.23.23.28/2025.07.15.05.23.42/vulnerability.update.json 38ms\ninfo : Package \u0027Microsoft.Bcl.Memory\u0027 is compatible with all the specified frameworks in project \u0027C:\\repos\\repros\\runtime\\issue117647\\issue117647.csproj\u0027.\ninfo : PackageReference for package \u0027Microsoft.Bcl.Memory\u0027 version \u00279.0.7\u0027 added to file \u0027C:\\repos\\repros\\runtime\\issue117647\\issue117647.csproj\u0027.\ninfo : Writing assets file to disk. Path: C:\\repos\\repros\\runtime\\issue117647\\obj\\project.assets.json\nlog  : Restored C:\\repos\\repros\\runtime\\issue117647\\issue117647.csproj (in 859 ms).\n\n➜ dotnet build\nRestore complete (0,6s)\nYou are using a preview version of .NET. See: https://aka.ms/dotnet-support-policy\n  issue117647 succeeded (2,0s) → bin\\Debug\\net10.0\\issue117647.dll\n\nBuild succeeded in 2,9s\n```\n\nI would have hoped that PackagePruning would have identified it but that maybe is only for packages within the shared framework like `System.Memory`?\n\n(I tried `\u003cRestoreEnablePackagePruning\u003etrue\u003c/RestoreEnablePackagePruning\u003e` explicitly if I had misunderstood under what conditions it was enabled in .NET 10 but it showed no difference.)\n\nSo no warning there atleast. `deps.json` and `project.assets.json` contains it and the dll is present in the `bin` folder\n\nThen I was thinking if I would see a difference if I installed the latest .NET 10 version\n\n```sh\n➜ dotnet package remove Microsoft.Bcl.Memory\nUnhandled exception: Value cannot be null. (Parameter \u0027_fileOrDirectory\u0027)\n```\n\n```sh\n➜ dotnet package remove --help\nDescription:\n  Remove a NuGet package reference from the project.\n\nUsage:\n  dotnet package remove \u003cPACKAGE_NAME\u003e... [options]\n\nArguments:\n  \u003cPACKAGE_NAME\u003e  The package reference to remove.\n\nOptions:\n  --interactive        Allows the command to stop and wait for user input or action (for example to complete authentication). [default: True]\n  --project \u003cproject\u003e  The project file to operate on. If a file is not specified, the command will search the current directory for one. [default: C:\\repos\\repros\\runtime\\issue117647]\n  -?, -h, --help       Show command line help.\n```\nWhat am I missing? EDIT `dotnet package remove` not working is tracked in this issue https://github.com/dotnet/sdk/issues/49313\n\nRe-did the process with \n`dotnet package add Microsoft.Bcl.Memory@10.0.0-preview.5.25277.114` and still no indicator.\n\nAny chance of an analyzer landing in .NET 10 before the 10.0.100 SDK GAs November? (or later within 1xx, 2xx, 3xx or 4xx?)",
                                           "updatedAt":  "2025-07-16T07:42:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc63P5BM",
                                           "createdAt":  "2025-07-15T16:46:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-07-15T16:46:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc63YPMm",
                                           "createdAt":  "2025-07-16T03:24:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "https://learn.microsoft.com/nuget/reference/errors-and-warnings/nu1510\n\nWhen I\u0027m using .NET 10 SDK Preview 6, I\u0027m seeing warning NU1510 for unnecessary PackageReference.",
                                           "updatedAt":  "2025-07-16T03:24:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc63a3Ld",
                                           "createdAt":  "2025-07-16T07:18:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Frulfump",
                                           "body":  "\u003e https://learn.microsoft.com/nuget/reference/errors-and-warnings/nu1510\n\u003e \n\u003e When I\u0027m using .NET 10 SDK Preview 6, I\u0027m seeing warning NU1510 for unnecessary PackageReference.\n\nPreview 6 was released ~10 hours ago. I re-tried my repro with `10.0.100-preview.6.25358.103`  and I still don\u0027t see a warning, could you share your repro steps?",
                                           "updatedAt":  "2025-07-16T07:18:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc63bnsv",
                                           "createdAt":  "2025-07-16T08:08:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "I created an empty new net10.0 project and added package references of latest stable versions. NU1510 was raised for System.Text.Encoding.CodePages, Microsoft.Win32.Registry etc.\n\nThe Microsoft.Bcl.* packages are different because sometimes they are still needed for forwarding (#115124).",
                                           "updatedAt":  "2025-07-16T08:08:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc63b7ts",
                                           "createdAt":  "2025-07-16T08:35:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Frulfump",
                                           "body":  "Ok so it repros under entirely different conditions i.e not a repro.\n\n(I only get NU1510 on `dotnet build` when I add `System.Memory` but shouldn\u0027t it be able to tell me that already during(after) restore as the TFM is known at that point and it creates the new dependency graph? `dotnet add package` seems to implicitly trigger a restore but I can work around that by using `--no-restore`)\n\nBut given the package README.md statement\n\u003eThis library is not necessary nor recommended when targeting versions of .NET that include the relevant support.\n\nThat seems strange then to me, so either the statement is not true or there\u0027s a gap in package pruning since I assume when I\u0027m using only the `net10.0` TFM I have no need for `Microsoft.Bcl.*` packages?\n\nAnd it seems the referenced issue is only a problem when multi-targeting with `netstandard2.0` based on the description/comments? A simple `dotnet new console` only targets `net10.0`.",
                                           "updatedAt":  "2025-07-16T10:46:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc63jaqa",
                                           "createdAt":  "2025-07-16T17:11:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "\u003e (I only get NU1510 on `dotnet build` when I add `System.Memory` but shouldn\u0027t it be able to tell me that already during(after) restore as the TFM is known at that point and it creates the new dependency graph?\n\nIt\u0027s a reasonable feature request for https://github.com/dotnet/sdk . I assume the limitation is from how infrastructure runs analyzers.\n\n\u003e That seems strange then to me, so either the statement is not true or there\u0027s a gap in package pruning since I assume when I\u0027m using only the `net10.0` TFM I have no need for `Microsoft.Bcl.*` packages?\n\nTechnically the reference is not totally meaningless. If you references a multi-target dependency that doesn\u0027t reference this package for all TFMs, adding a top-level reference will \"fix\" the problem demonstrated in #115124.\n\n\u003e And it seems the referenced issue is only a problem when multi-targeting with `netstandard2.0` based on the description/comments?\n\nIt is a problem for multi-targeting with any target framework that gets additional API from the package. Most of the old packages are included in netstandard2.1 or higher.",
                                           "updatedAt":  "2025-07-16T17:11:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc63k7Nm",
                                           "createdAt":  "2025-07-16T18:56:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Frulfump",
                                           "body":  "\u003e It\u0027s a reasonable feature request for https://github.com/dotnet/sdk . I assume the limitation is from how infrastructure runs analyzers.\n\nIsn\u0027t it NuGet/Home that owns the pruning feature (NU* prefix and they seem to have all the issues about the package pruning feature development in their repo), is it still correct to open the issue in dotnet/sdk?\n\n\u003e Technically the reference is not totally meaningless. If you references a multi-target dependency that doesn\u0027t reference this package for all TFMs, adding a top-level reference will \"fix\" the problem demonstrated in [#115124](https://github.com/dotnet/runtime/issues/115124).\n\nOh that makes the README call out even more peculiar, but in that issue they state (my emphasis in bold)\n\u003eKnown Workarounds\n\u003e\n\u003e    Adding a net8.0 target to SdkLibrary\n\u003e    Keep the reference to Microsoft.Bcl.AsyncInterfaces in the net8.0 target in BaseLibrary - this is the current solution\n\u003e    **Adding a direct reference to Microsoft.Bcl.AsyncInterfaces in the customer app (non-solution in the real scenario as this could be breaking**)\n\nSo we could actually run into issues when referencing some of those packages? But the real solution is to ask the references that multi-target to correctly supply the package for all TFMs?\n\n\u003e It is a problem for multi-targeting with any target framework that gets additional API from the package. Most of the old packages are included in netstandard2.1 or higher.\n\nSo we will only see this where `netstandard2.0` is multi-targeted like the Azure SDK packages (because of their .NET Framework support https://github.com/Azure/azure-sdk-for-net/issues/50873#issuecomment-3005609868 .NET Framework is the gift that keeps on giving...)?\n\nSeems like the comment here https://github.com/dotnet/runtime/issues/115124#issuecomment-2836313581 further discusses changes to the README of these packages when multi-targeting.",
                                           "updatedAt":  "2025-07-16T18:56:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc64f2kS",
                                           "createdAt":  "2025-07-21T06:17:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "\u003e Isn\u0027t it NuGet/Home that owns the pruning feature\n\nYes it should. There are existing discussions about NU1510 there.\n\n\u003e \u003e Technically the reference is not totally meaningless. If you references a multi-target dependency that doesn\u0027t reference this package for all TFMs, adding a top-level reference will \"fix\" the problem demonstrated in [#115124](https://github.com/dotnet/runtime/issues/115124).\n\u003e \n\u003e Oh that makes the README call out even more peculiar, but in that issue they state (my emphasis in bold)\n\nThis is applicable to all Microsoft.Bcl.* packages. We may need a dedicated documentation page for the details.\n\n\u003e So we could actually run into issues when referencing some of those packages? But the real solution is to ask the references that multi-target to correctly supply the package for all TFMs?\n\nAs library author: if you are multi-targeting, you should add package reference of Microsoft.Bcl.* to all TFMs, then your consumers are free from the issue.\nAs library consumer: if your dependency is having the issue, you should target the frameworks that targeted by your dependency and  missed the package reference, and add the missing references for the framework. Then you are fixing the issue for you and your dependencies.\n\n\u003e So we will only see this where `netstandard2.0` is multi-targeted like the Azure SDK packages (because of their .NET Framework support [Azure/azure-sdk-for-net#50873 (comment)](https://github.com/Azure/azure-sdk-for-net/issues/50873#issuecomment-3005609868) .NET Framework is the gift that keeps on giving...)?\n\nDepending on exactly which package. Microsoft.Bcl.Memory adds content for net8.0.",
                                           "updatedAt":  "2025-07-21T06:17:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc642sAS",
                                           "createdAt":  "2025-07-22T06:58:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEbahhA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "Frulfump",
                                                                               "createdAt":  "2025-07-22T07:57:48Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "This would be valuable to refine as part of the .NET 10 LTS release. Thanks for reporting this feedback, @Frulfump.",
                                           "updatedAt":  "2025-07-22T06:58:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc646BoD",
                                           "createdAt":  "2025-07-22T10:55:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Frulfump",
                                           "body":  "\u003e \u003e Isn\u0027t it NuGet/Home that owns the pruning feature\n\u003e \n\u003e Yes it should. There are existing discussions about NU1510 there.\n\nI looked again and I do get a warning in text while doing `dotnet package add System.Memory@4.6.3` but it looks like it\u0027s just an info level text, with build it\u0027s an actual warning. I think that behavior is by design so I will wait with the issue creation and think about it some more.\n\n\u003e \u003e \u003e Technically the reference is not totally meaningless. If you references a multi-target dependency that doesn\u0027t reference this package for all TFMs, adding a top-level reference will \"fix\" the problem demonstrated in [#115124](https://github.com/dotnet/runtime/issues/115124).\n\u003e \u003e \n\u003e \u003e\n\u003e \u003e Oh that makes the README call out even more peculiar, but in that issue they state (my emphasis in bold)\n\u003e \n\u003e This is applicable to all Microsoft.Bcl.* packages. We may need a dedicated documentation page for the details.\n\nAh good to know, yes I think so and by Jeffs response it seems like that will happen before .NET 10 GA:s in November.\n\n\u003e \u003e So we could actually run into issues when referencing some of those packages? But the real solution is to ask the references that multi-target to correctly supply the package for all TFMs?\n\u003e \n\u003e As library author: if you are multi-targeting, you should add package reference of Microsoft.Bcl.* to all TFMs, then your consumers are free from the issue. As library consumer: if your dependency is having the issue, you should target the frameworks that targeted by your dependency and missed the package reference, and add the missing references for the framework. Then you are fixing the issue for you and your dependencies.\n\nGood to know, thanks!\n\n\u003e \u003e So we will only see this where `netstandard2.0` is multi-targeted like the Azure SDK packages (because of their .NET Framework support [Azure/azure-sdk-for-net#50873 (comment)](https://github.com/Azure/azure-sdk-for-net/issues/50873#issuecomment-3005609868) .NET Framework is the gift that keeps on giving...)?\n\u003e \n\u003e Depending on exactly which package. Microsoft.Bcl.Memory adds content for net8.0.\n\nOh I did not know that, makes documenting the circumstances more important.\n\n\u003e This would be valuable to refine as part of the .NET 10 LTS release. Thanks for reporting this feedback, [@Frulfump](https://github.com/Frulfump).\n\nThanks!",
                                           "updatedAt":  "2025-07-22T10:55:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc65Vmld",
                                           "createdAt":  "2025-07-23T17:06:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEbqhJw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Frulfump",
                                                                               "createdAt":  "2025-07-23T17:11:07Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "m-redding",
                                           "body":  "+1 on this - Azure SDK gets a lot of support tickets about removing Microsoft.Bcl.AsyncInterfaces from our Azure.Core dependencies. It\u0027d be nice to have official docs to point at and not have to explain the whole polyfill complexity",
                                           "updatedAt":  "2025-07-23T17:06:08Z"
                                       }
                                   ],
                         "totalCount":  13
                     },
        "title":  "Microsoft.Bcl.Memory README unclear on where it\u0027s not necessary or recommended",
        "labels":  [
                       "documentation",
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/117677",
        "createdAt":  "2025-07-15T18:34:20Z",
        "number":  117677,
        "author":  "aromaa",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODHNYdg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2025-07-15T19:13:45Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MichalPetryka",
                                            "createdAt":  "2025-07-15T22:41:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2025-07-16T11:58:41Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2025-07-22T07:05:25Z",
        "body":  "### Background and motivation\n\nSplitting in reverse iteration order in non-allocating way currently requires manual usage of `LastIndexOf` and is not nearly as efficient as it could be. It would be useful to take advantage of `SpanSplitEnumerator\u003cT\u003e` and possible built-in optimizations to do this efficiently.\n\n### API Proposal\n\n```csharp\nnamespace System;\n\n[Flags]\npublic enum StringSplitOptions\n{\n    IndexFromEnd = 4\n}\n\n// Methods added in #934 didn\u0027t include the StringSplitOptions.\npublic static partial class MemoryExtensions\n{\n    public static SpanSplitEnumerator\u003cT\u003e Split\u003cT\u003e(this ReadOnlySpan\u003cT\u003e source, T separator, StringSplitOptions options = StringSplitOptions.None);\n    public static SpanSplitEnumerator\u003cT\u003e Split\u003cT\u003e(this ReadOnlySpan\u003cT\u003e source, ReadOnlySpan\u003cT\u003e separator, StringSplitOptions options = StringSplitOptions.None);\n    public static SpanSplitEnumerator\u003cT\u003e SplitAny\u003cT\u003e(this ReadOnlySpan\u003cT\u003e source, params ReadOnlySpan\u003cT\u003e separators, StringSplitOptions options = StringSplitOptions.None);\n    public static SpanSplitEnumerator\u003cT\u003e SplitAny\u003cT\u003e(this ReadOnlySpan\u003cT\u003e source, SearchValues\u003cT\u003e separators, StringSplitOptions options = StringSplitOptions.None);\n}\n```\n\n### API Usage\n\n```csharp\nstring value = \"1 2 3\";\n\nforeach (Range range in value.AsSpan().Split(\u0027 \u0027, StringSplitOptions.IndexFromEnd ))\n{\n    Console.WriteLine(value[range]);\n}\n\n// Output:\n// 3\n// 2\n// 1\n```\n\n\n### Alternative Designs\n\nInstead of a new flag to the `StringSplitOptions`, add explicit methods to perform the operation exclusively. This avoids the need to support the other options for the `SpanSplitEnumerator\u003cT\u003e` returning methods which were not added as part of #934. It also has the advantage of not requiring to implement this on `String.Split` which is easily doable as one can iterate the returned array backwards.\n\nThere are also the older `MemoryExtensions.Split` methods that take in `Span\u003cRange\u003e` which would need to be adjusted to support the new option. Would it be as useful there?\n\n```csharp\npublic static partial class MemoryExtensions\n{\n    public static SpanSplitEnumerator\u003cT\u003e ReverseSplit\u003cT\u003e(this ReadOnlySpan\u003cT\u003e source, T separator);\n    public static SpanSplitEnumerator\u003cT\u003e ReverseSplit\u003cT\u003e(this ReadOnlySpan\u003cT\u003e source, ReadOnlySpan\u003cT\u003e separator);\n    public static SpanSplitEnumerator\u003cT\u003e ReverseSplitAny\u003cT\u003e(this ReadOnlySpan\u003cT\u003e source, params ReadOnlySpan\u003cT\u003e separators);\n    public static SpanSplitEnumerator\u003cT\u003e ReverseSplitAny\u003cT\u003e(this ReadOnlySpan\u003cT\u003e source, SearchValues\u003cT\u003e separators);\n}\n```\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOt0f6bw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc63R_pv",
                                           "createdAt":  "2025-07-15T18:35:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-07-15T18:35:02Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "[API Proposal]: Add reverse iteration order support for split",
        "labels":  [
                       "api-suggestion",
                       "area-System.Memory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/119901",
        "createdAt":  "2025-09-19T17:18:31Z",
        "number":  119901,
        "author":  "peterwald",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-19T20:04:25Z",
        "body":  "### Description\n\nWhen calling a.SequenceEqual(b) with string arrays that contain some null values, a NullReferenceException is thrown from inside SequenceEqual.\n\nThanks to @drognanar for narrowing this down to a small repro.\n\n### Reproduction Steps\n\nProgram.cs\n```csharp\nstring?[] a1 = new string?[] { \"a\", \"b\", null, null };\nstring?[] a2 = new string?[] { \"a\", \"b\", null, null };\n \nConsole.WriteLine($\"Are equal {a1.SequenceEqual(a2)}\");\n```\n\nSequenceEqual.csproj\n```xml\n\u003cProject Sdk=\"Microsoft.NET.Sdk\"\u003e\n \n  \u003cPropertyGroup\u003e\n    \u003cOutputType\u003eExe\u003c/OutputType\u003e\n    \u003cTargetFramework\u003enet481\u003c/TargetFramework\u003e\n    \u003cImplicitUsings\u003eenable\u003c/ImplicitUsings\u003e\n    \u003cNullable\u003eenable\u003c/Nullable\u003e\n    \u003cLangVersion\u003elatest\u003c/LangVersion\u003e\n  \u003c/PropertyGroup\u003e\n \n  \u003cItemGroup\u003e\n    \u003cPackageReference Include=\"System.Memory\" Version=\"4.6.0\" /\u003e\n  \u003c/ItemGroup\u003e\n\u003c/Project\u003e\n```\n\n### Expected behavior\n\nAfter `dotnet run`\n\nConsole Output\n```\nAre equal True\n```\n\n### Actual behavior\n\nActual Output\n```\nUnhandled Exception: System.NullReferenceException: Object reference not set to an instance of an object.\n   at System.SpanHelpers.SequenceEqual[T](T\u0026 first, T\u0026 second, Int32 length)\n   at System.MemoryExtensions.SequenceEqual[T](ReadOnlySpan`1 span, ReadOnlySpan`1 other)\n   at Program.\u003cMain\u003e$(String[] args) in C:\\src\\SequenceEqual\\Program.cs:line 4\n```\n\n### Regression?\n\nThis works if you remove the reference to System.Memory, or if you downgrade to an earlier SDK, or if you compile to net8.\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n.NET SDK:\n Version:           10.0.100-rc.1.25451.107\n Commit:            2db1f5ee2b\n Workload version:  10.0.100-manifests.a6e8bec0\n MSBuild version:   17.15.0-preview-25451-107+2db1f5ee2\n\nRuntime Environment:\n OS Name:     Windows\n OS Version:  10.0.26100\n OS Platform: Windows\n RID:         win-x64\n Base Path:   C:\\Program Files\\dotnet\\sdk\\10.0.100-rc.1.25451.107\\\n\n.NET workloads installed:\nThere are no installed workloads to display.\nConfigured to use workload sets when installing new manifests.\nNo workload sets are installed. Run \"dotnet workload restore\" to install a workload set.\n\nHost:\n  Version:      10.0.0-rc.1.25451.107\n  Architecture: x64\n  Commit:       2db1f5ee2b\n\n\n### Other information\n\nHere is an image of the decompiled code in System.SpanHelpers.SequenceEqual\u003cT\u003e(ref T first, ref T second, int length) where the exception is thrown.\n\u003cimg width=\"1352\" height=\"348\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/0ce6d980-df2e-4f03-a723-a2db45f8acbc\" /\u003e",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOxYJt6A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc7FfTyD",
                                           "createdAt":  "2025-09-19T18:24:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-09-19T18:24:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7Ff-hG",
                                           "createdAt":  "2025-09-19T19:13:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Looks like none of these equality checks in the downlevel package are doing the proper null checking.\nhttps://github.com/dotnet/maintenance-packages/blob/cf8d27a145c74a6632671f4d62575fe9c23b0b3c/src/System.Memory/src/System/SpanHelpers.T.cs#L607-L649\nCompare that to what\u0027s in core, with plentiful null checking:\nhttps://github.com/dotnet/runtime/blob/2db45f150630e8116e393e00edd14844b0465aa8/src/libraries/System.Private.CoreLib/src/System/SpanHelpers.T.cs#L1205-L1273\nThat was fixed in 2018:\nhttps://github.com/dotnet/coreclr/pull/21232\nbut the fix apparently never made it to the copy of the code used in the System.Memory package.\n\n@ericstj, does this issue belong here or in the maintenace-packages repo?",
                                           "updatedAt":  "2025-09-19T19:13:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7Fgm3o",
                                           "createdAt":  "2025-09-19T20:03:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "Leaving the issue here but applying the fix in maintenance-packages works for me.\n\nI think this warrants a servicing fix to the package.",
                                           "updatedAt":  "2025-09-19T20:03:41Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "SequenceEqual throws NullReferenceException",
        "labels":  [
                       "area-System.Memory"
                   ]
    }
]
