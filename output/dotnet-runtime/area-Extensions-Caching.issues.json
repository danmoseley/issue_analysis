[
    {
        "url":  "https://github.com/dotnet/runtime/issues/36568",
        "createdAt":  "2015-07-28T10:54:10Z",
        "number":  36568,
        "author":  "ehabelgindy",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC_xtcA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "RickBlouch",
                                            "createdAt":  "2022-02-23T02:41:18Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "bbrandt",
                                            "createdAt":  "2022-04-11T20:23:31Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "wojtek-viirtue",
                                            "createdAt":  "2022-05-03T21:36:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "viktor-svub",
                                            "createdAt":  "2022-06-11T05:46:55Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "glen-84",
                                            "createdAt":  "2022-07-15T10:35:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "austinw-fineart",
                                            "createdAt":  "2023-06-08T07:34:33Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "leocalzavara",
                                            "createdAt":  "2025-03-06T13:48:14Z"
                                        }
                                    ],
                          "totalCount":  7
                      },
        "updatedAt":  "2024-07-17T16:21:05Z",
        "body":  "Would it be useful if the IDistibutedCache interface can allow bulk remove?\n\nUnlike the memory cache, removing multiple entries from distributed caches can be an expensive task. Providing an overload of the _Remove_ function that accept an array of keys - e.g. Task Remove(string [] keys) - would allow more efficient implementations of distributed caches.\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHORMbVhw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIwODk4MTU5MA==",
                                           "createdAt":  "2016-04-12T16:01:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAV1dZA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Themodem",
                                                                               "createdAt":  "2018-04-27T05:50:29Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "RehanSaeed",
                                           "body":  "I posted an `IDistributedCache` helper which clears the cache and also bulk removes keys [here](https://github.com/aspnet/Caching/issues/96), just in case someone finds it useful.\n",
                                           "updatedAt":  "2016-04-12T16:29:08Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQxNjA2NTA4Mg==",
                                           "createdAt":  "2018-08-26T19:45:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "SimonOrdo",
                                           "body":  "@RehanSaeed  It looks like you\u0027re missing IDistributedCacheExtended definition in your post.  ",
                                           "updatedAt":  "2018-08-26T19:45:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc40nFVl",
                                           "createdAt":  "2021-07-19T15:53:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "eerhardt",
                                           "body":  "We\u0027ve reached feature complete for .NET 6. Moving to 7.",
                                           "updatedAt":  "2021-07-19T15:53:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5EvbG8",
                                           "createdAt":  "2022-06-12T20:14:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "deeprobin",
                                           "body":  "`MemoryCache` already implements this (see #45593). I think we can tag this as `api-suggestion`. However, this API would also be a `breaking-change`, due to other non-BCL implementations of the interface.\r\n\r\nHere my proposal:\r\n\r\n```cs\r\nnamespace Microsoft.Extensions.Caching.Distributed\r\n{\r\n    public interface IDistributedCache\r\n    {\r\n        void Clear();\r\n        // Maybe, a ValueTask would not be a bad idea, but other Async APIs use a normal Task in this class.\r\n        Task ClearAsync(CancellationToken cancellationToken = default);\r\n    }\r\n\r\n    public partial class MemoryDistributedCache : IDistributedCache {\r\n        public void Clear();\r\n        public Task ClearAsync(CancellationToken cancellationToken = default);\r\n    }\r\n}\r\n\r\nnamespace Microsoft.Extensions.Caching.Redis\r\n{\r\n    public partial class RedisCache : IDisposable, IDistributedCache {\r\n        public void Clear();\r\n        public Task ClearAsync(CancellationToken cancellationToken = default);\r\n    }\r\n}\r\n\r\nnamespace Microsoft.Extensions.Caching.StackExchangeRedis\r\n{\r\n    public partial class RedisCache : IDisposable, IDistributedCache {\r\n        public void Clear();\r\n        public Task ClearAsync(CancellationToken cancellationToken = default);\r\n    }\r\n}\r\n\r\nnamespace Microsoft.Extensions.Caching.SqlServer\r\n{\r\n    public partial class SqlServerCache : IDistributedCache {\r\n        public void Clear();\r\n        public Task ClearAsync(CancellationToken cancellationToken = default);\r\n    }\r\n}\r\n```",
                                           "updatedAt":  "2022-06-12T20:14:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5EvbPJ",
                                           "createdAt":  "2022-06-12T20:17:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "deeprobin",
                                           "body":  "\u003e * The interface can\u0027t be changed, per our breaking change rules.\r\n\r\n_Originally posted by @bartonjs in https://github.com/dotnet/runtime/issues/45593#issuecomment-900541842_\r\n\r\nIt would probably make sense to update only the implementations and not change the interface due to the breaking change.",
                                           "updatedAt":  "2022-06-12T20:17:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ExtWH",
                                           "createdAt":  "2022-06-13T12:57:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODMsHMg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "adamsitnik",
                                                                               "createdAt":  "2023-11-15T15:00:07Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "eerhardt",
                                           "body":  "We have started using Default Interface Members (DIMs) in Microsoft.Extensions. This may be a candidate to add in .NET 6.0+ APIs just like we did for #66479.\r\n\r\n\u003e Here my proposal:\r\n\r\nI don\u0027t believe the original intention of this issue is to remove all the entries from the cache, but remove a set of them specified by a collection of keys.",
                                           "updatedAt":  "2022-06-13T12:57:25Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "Bulk remove on IDistributedCache",
        "labels":  [
                       "feature-request",
                       "area-Extensions-Caching"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/36560",
        "createdAt":  "2017-11-01T22:13:58Z",
        "number":  36560,
        "author":  "analogrelay",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCzS5Fg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "alexvaluyskiy",
                                            "createdAt":  "2019-01-08T22:48:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "amiru3f",
                                            "createdAt":  "2023-10-14T21:13:01Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2021-03-23T03:31:14Z",
        "body":  "Some events listed below. The goal is to add events that will help users solve problems so if these aren\u0027t going to do that job, feel free to suggest/discuss others!\r\n\r\n* `Microsoft.Extensions.Caching.Memory` EventSource\r\n    * `cache-hits` event \u0026 counter - Triggered when a cache lookup succeeds.\r\n    * `cache-misses` event \u0026 counter - Triggered when a cache lookup fails.\r\n    * `cache-count` counter - Counts the number of items in the cache\r\n    * `estimated-size` counter - Counts the number of bytes based on `Size` values? (which are opt-in and estimates already)\r\n    \r\n* `Microsoft.Extensions.Caching.Distributed` EventSource\r\n    * `cache-hits` event \u0026 counter - Triggered when a cache lookup succeeds.\r\n    * `cache-misses` event \u0026 counter - Triggered when a cache lookup fails.\r\n\t* Size and count should be tracked on the server/service providing the cache.\r\n\r\n~~See https://gist.github.com/anurse/af1859663ac91c6cf69c820cebe92303 for some guidance on adding EventSources and EventCounters to ASP.NET projects.~~ This is out of date.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOL_TzOg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNDMyODEzOQ==",
                                           "createdAt":  "2021-03-22T19:16:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericstj",
                                           "body":  "@noahfalk / @shirhatti -- what\u0027s your thinking around this?  Does it make sense to add EventCounter usage in Microsoft.Extensions.Caching, or do we need to take a look at the broader customer scenario of diagnostics in ASP.NETCore to identify more libraries to instrument?  I\u0027d want to make sure that any additions we make here fit well with the overall diagnostics story.",
                                           "updatedAt":  "2021-03-23T00:55:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNDMzMDkzMQ==",
                                           "createdAt":  "2021-03-22T19:20:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBlUVzw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "maryamariyan",
                                                                               "createdAt":  "2021-03-30T06:48:01Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "shirhatti",
                                           "body":  "My vote is to wait till we have support for dimensions on metrics. With dimensions you can always disambiguate hit/miss counter by filtering on the cache name (or some other unique identifier) dimension that you care about.\r\n",
                                           "updatedAt":  "2021-03-22T19:20:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNDUwMzc5NQ==",
                                           "createdAt":  "2021-03-23T00:55:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericstj",
                                           "body":  "@noahfalk @shirhatti how should we be thinking about EventCounter support in general?  Is it already supported everywhere customers want it and this is just one place it was missed, or does it need a more thorough look to ensure it\u0027s added everywhere?",
                                           "updatedAt":  "2021-03-23T01:30:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNDU4MjIwMg==",
                                           "createdAt":  "2021-03-23T03:31:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "\u003e Is it already supported everywhere customers want it and this is just one place it was missed, or does it need a more thorough look to ensure it\u0027s added everywhere?\r\n\r\nSo far the strategy has been a mixture, we proactively identified counters we thought would be most impactful and got those added during .NET 3 and 5. The remainder are things that didn\u0027t stand out/we weren\u0027t aware of and we have been handling those reactively. IMO it is easier to fault in cases like these on-demand because we have a specific customer who can help us validate the scenario + drive the priority. So this probably isn\u0027t \"just one place we missed\", but I also wasn\u0027t planning to initiate a broad survey where we add more counters that we don\u0027t yet have any .NET Core customers asking for. If requests to fill gaps become numerous and handling them as a batch looks more efficient I\u0027m happy to switch course.\r\n\r\n\u003e My vote is to wait till we have support for dimensions on metrics\r\n\r\nWere the previous .NET Framework counters multi-dimensional? I still need to look more closely.\r\n\r\n",
                                           "updatedAt":  "2021-03-23T03:31:14Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Add EventSource/EventCounter tracing and metrics for Caching",
        "labels":  [
                       "feature-request",
                       "area-Extensions-Caching"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/36386",
        "createdAt":  "2018-07-05T10:38:42Z",
        "number":  36386,
        "author":  "khellang",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC9hyLg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "trekco",
                                            "createdAt":  "2019-06-24T12:08:31Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mmoser",
                                            "createdAt":  "2019-08-12T20:14:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "harindaka",
                                            "createdAt":  "2019-09-13T11:47:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mgernand",
                                            "createdAt":  "2019-10-16T22:02:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "cd21h",
                                            "createdAt":  "2020-03-05T21:04:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DavudSafarli",
                                            "createdAt":  "2020-10-12T14:11:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MatisseHack",
                                            "createdAt":  "2021-09-07T16:25:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "TropinAlexey",
                                            "createdAt":  "2022-02-02T10:38:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "revocengiz",
                                            "createdAt":  "2022-02-24T14:04:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "tinohager",
                                            "createdAt":  "2022-06-08T20:26:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mtinnes",
                                            "createdAt":  "2022-06-24T17:27:45Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "iuliana-minea",
                                            "createdAt":  "2022-08-31T07:37:06Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MatiasSzekelySepio",
                                            "createdAt":  "2023-07-12T17:41:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "naeemaei",
                                            "createdAt":  "2024-04-13T09:56:57Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "gaborxszabo",
                                            "createdAt":  "2024-12-17T07:33:23Z"
                                        }
                                    ],
                          "totalCount":  15
                      },
        "updatedAt":  "2024-04-24T08:50:48Z",
        "body":  "It would be really nice to have for scenarios like rate limiting.\r\n\r\nI don\u0027t know about SQL Server support for this, but I guess this would map to Redis\u0027 `INCR` and `DECR` operations.\r\nIf the key does not exist, it would be set to 0 before performing the operation. The methods would return the value of key after increment/decrement.\r\n\r\nI propose the following new members:\r\n\r\n```diff\r\nnamespace Microsoft.Extensions.Caching.Distributed\r\n{\r\n    public interface IDistributedCache\r\n    {\r\n        // Existing members:\r\n        byte[] Get(string key);\r\n        Task\u003cbyte[]\u003e GetAsync(string key, CancellationToken token = default(CancellationToken));\r\n        void Set(string key, byte[] value, DistributedCacheEntryOptions options);\r\n        Task SetAsync(string key, byte[] value, DistributedCacheEntryOptions options, CancellationToken token = default(CancellationToken));\r\n        void Refresh(string key);\r\n        Task RefreshAsync(string key, CancellationToken token = default(CancellationToken));\r\n        void Remove(string key);\r\n        Task RemoveAsync(string key, CancellationToken token = default(CancellationToken));\r\n\r\n        // New members:\r\n+       long Increment(string key, DistributedCacheEntryOptions options);\r\n+       Task\u003clong\u003e IncrementAsync(string key, DistributedCacheEntryOptions options, CancellationToken token = default(CancellationToken));\r\n+       long Decrement(string key, DistributedCacheEntryOptions options);\r\n+       Task\u003clong\u003e DecrementAsync(string key, DistributedCacheEntryOptions options, CancellationToken token = default(CancellationToken));\r\n+       long IncrementBy(string key, long value, DistributedCacheEntryOptions options);\r\n+       Task\u003clong\u003e IncrementByAsync(string key, long value, DistributedCacheEntryOptions options, CancellationToken token = default(CancellationToken));\r\n+       long DecrementBy(string key, long value, DistributedCacheEntryOptions options);\r\n+       Task\u003clong\u003e DecrementByAsync(string key, long value, DistributedCacheEntryOptions options, CancellationToken token = default(CancellationToken));\r\n    }\r\n}\r\n```\r\n\r\n@Eilon @Tratcher @davidfowl Is this something you\u0027d consider for 3.0?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOe6VJng==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ0NzQ4NDE3NQ==",
                                           "createdAt":  "2018-12-14T21:26:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "khellang",
                                           "body":  "Ping! ",
                                           "updatedAt":  "2018-12-14T21:26:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ0ODA0MjE3OA==",
                                           "createdAt":  "2018-12-17T23:46:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Eilon",
                                           "body":  "This seems like a different service than `IDistributedCache`, no? (Aside from it\u0027s obviously a breaking change.)",
                                           "updatedAt":  "2018-12-17T23:46:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ0ODE1MzM3Nw==",
                                           "createdAt":  "2018-12-18T09:25:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "khellang",
                                           "body":  "\u003e This seems like a different service than `IDistributedCache`, no?\r\n\r\nYou mean because you operate on numbers instead of bytes? I dunno, it\u0027s pretty common to cache \"counters\" like this.",
                                           "updatedAt":  "2018-12-18T09:25:02Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ0ODE2OTQ5Nw==",
                                           "createdAt":  "2018-12-18T10:17:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "slang25",
                                           "body":  "When I think distributed caching, I don\u0027t think of atomicity. What you are describing sounds more like a distributed semaphore (which [consul implements for example](https://www.consul.io/docs/guides/semaphore.html)), which does seem like it belongs to a separate interface.",
                                           "updatedAt":  "2018-12-18T10:17:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ0ODE4ODY0OQ==",
                                           "createdAt":  "2018-12-18T11:25:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODSSJyg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "slang25",
                                                                               "createdAt":  "2018-12-18T11:26:07Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "brainded",
                                                                               "createdAt":  "2019-05-13T16:53:35Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "mmoser",
                                                                               "createdAt":  "2019-08-12T20:14:54Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "mgernand",
                                                                               "createdAt":  "2019-10-16T22:02:40Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "aaronhudon",
                                                                               "createdAt":  "2020-04-22T23:38:13Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "DavudSafarli",
                                                                               "createdAt":  "2020-10-12T14:11:38Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "lourencomcviana",
                                                                               "createdAt":  "2021-06-07T19:38:50Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jonataspc",
                                                                               "createdAt":  "2024-01-12T18:06:51Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  8
                                                         },
                                           "author":  "khellang",
                                           "body":  "I don\u0027t really care where the methods live, I just want to be able to invoke a Redis [`INCR`](https://redis.io/commands/incr) operation 😝 ",
                                           "updatedAt":  "2018-12-18T11:25:18Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ0ODE5MTY0Mw==",
                                           "createdAt":  "2018-12-18T11:37:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "slang25",
                                           "body":  "Yeah, fair point. Why not do that rather than wait for an abstraction:\r\n```csharp\r\nvar redis = StackExchange.Redis.ConnectionMultiplexer.Connect(\"localhost\");\r\nvar db = redis.GetDatabase();\r\ndb.*Increment(...\r\n```\r\nYou already a transitive dependency on `StackExchange.Redis.Signed` from the distributed caching extension.",
                                           "updatedAt":  "2018-12-18T11:37:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ0ODE5MjI4MQ==",
                                           "createdAt":  "2018-12-18T11:40:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "khellang",
                                           "body":  "Because I\u0027m writing a middleware that I\u0027d like to keep decoupled from Redis. Because ASP.NET Core already has the `IDistributedCache` abstraction, I thought it would be a good fit.",
                                           "updatedAt":  "2018-12-18T11:40:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ0ODIwMzI5Nw==",
                                           "createdAt":  "2018-12-18T12:25:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "It\u0027s not a great fit, at least not for this interface.",
                                           "updatedAt":  "2018-12-18T12:25:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwNjA3Nzg4NQ==",
                                           "createdAt":  "2019-06-26T23:12:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "analogrelay",
                                           "body":  "We don\u0027t intend to support this behavior in the `IDistributedCache`.",
                                           "updatedAt":  "2019-06-26T23:12:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwNjQ2MDM1Nw==",
                                           "createdAt":  "2019-06-27T18:31:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "khellang",
                                           "body":  "So, for implementing throttling/rate limiting, what kind of service would you recommend I use to store the number of requests for the current IP, without forcing all my users to use Redis? Does it exist? 🤔\r\n\r\nThis is straight forward with caching primitives for most (other) platforms... ",
                                           "updatedAt":  "2019-06-27T18:33:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwNjQ2NzkwOQ==",
                                           "createdAt":  "2019-06-27T18:52:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "analogrelay",
                                           "body":  "Can you tell me more about the caching primitives other platforms provide? I\u0027m certainly not opposed to this if there\u0027s prior art. Redis has an `INCR` primitive, but that\u0027s not necessarily something an abstraction can depend upon. Increment is also very difficult (if not impossible) to implement on top of our existing abstraction (i.e. in terms of `Get`/`Set`) since it requires some kind of transactionality, so it would be a breaking change that would force all providers to find a way to do this.\r\n\r\nIt sounds like you\u0027re basically looking for a \"database\" (for lack of a better term) here rather than a cache, since you\u0027re storing data that you\u0027re relying upon. Caches generally are targeted at transient data storage backed up by some underlying store. What would happen to the throttling data when the cache drops your key as part of scavenging/expiration? Redis (as an implementation) is more of a database, so using it directly for this makes some sense, or providing your own abstraction in your middleware component.\r\n\r\nI\u0027m not necessarily opposed to having an abstraction for this, just trying to understand how this fits into the area of \"caching\".",
                                           "updatedAt":  "2019-06-27T18:52:02Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwNjUzNjg4OA==",
                                           "createdAt":  "2019-06-27T22:41:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "khellang",
                                           "body":  "\u003e Can you tell me more about the caching primitives other platforms provide?\r\n\r\n## [Laravel](https://laravel.com/docs/5.8/cache) \r\n\r\n\u003e Laravel provides an expressive, unified API for various caching backends. Laravel supports popular caching backends like Memcached and Redis out of the box.\r\n\r\n\u003e The `increment` and `decrement` methods may be used to adjust the value of integer items in the cache. Both of these methods accept an optional second argument indicating the amount by which to increment or decrement the item\u0027s value.\r\n\r\n## [Rails](https://api.rubyonrails.org/classes/ActiveSupport/Cache/Store.html)\r\n\r\nHas an abstract cache store class with implementations for in-memory, Memcached and Redis out of the box.\r\n\r\nHas both an `increment` and `decrement` method, both taking an optional amount.\r\n\r\n## [Django](https://docs.djangoproject.com/en/2.2/topics/cache/) \r\n\r\n\u003e Django comes with a robust cache system that lets you save dynamic pages so they don’t have to be calculated for each request. For convenience, Django offers different levels of cache granularity: You can cache the output of specific views, you can cache only the pieces that are difficult to produce, or you can cache your entire site.\r\n\r\n\u003e You can also increment or decrement a key that already exists using the `incr()` or `decr()` methods, respectively. By default, the existing cache value will be incremented or decremented by 1. Other increment/decrement values can be specified by providing an argument to the increment/decrement call. \r\n\r\n---\r\n\r\nThis was just the first three I looked at, in ten minutes on my phone. They\u0027re also some of the most popular web frameworks out there. All of them expose increment and decrement operations directly in their caching primitives. The most popular stores like Memcached and Redis support these operations natively. \r\n\r\n\u003e Redis has an INCR primitive, but that\u0027s not necessarily something an abstraction can depend upon.\r\n\r\nWhy not? 🤔 \r\n\r\n\u003e Increment is also very difficult (if not impossible) to implement on top of our existing abstraction (i.e. in terms of `Get`/`Set`) since it requires some kind of transactionality, so it would be a breaking change that would force all providers to find a way to do this.\r\n\r\nYes, tell me about it. It works somewhat, but has no transactional guarantees. Hence this suggestion. I\u0027m not saying that must be a guarantee, but it would be nice to have if the backend support it. \r\n\r\n\u003e It sounds like you\u0027re basically looking for a \"database\" (for lack of a better term) here rather than a cache, since you\u0027re storing data that you\u0027re relying upon. Caches generally are targeted at transient data storage backed up by some underlying store.\r\n\r\nNo, I\u0027m looking for a cache. I know what a cache is. What is a cache if not a \"database\"? The most popular caches support these operations.\r\n\r\n\u003e What would happen to the throttling data when the cache drops your key as part of scavenging/expiration\r\n\r\nThat\u0027s also a key point here. You want to be able to reason about expiry etc. as well. In the throttling example you\u0027d like to have a sliding expiration so whenever someone makes a request, it gets incremented and the expiration is reset. When the expiration goes out, the counter is removed (reset).\r\n\r\n\u003e Redis (as an implementation) is more of a database, so using it directly for this makes some sense, or providing your own abstraction in your middleware component.\r\n\r\nI doubt anyone using any other cache backend would use throttling middleware that only support Redis. Especially when their existing cache already supports what they need (and could be used instead). \r\n\r\nSure, I could roll my own abstraction, but that means I\u0027d have to either leave the implementation up to the end user or ship separate ThrottleMiddleware.Redis, ThrottleMiddleware.Memcached and ThrottleMiddleware.InMemory etc. packages. I\u0027d much rather rely on the existing packages in the shared framework if I could. ",
                                           "updatedAt":  "2019-06-27T22:43:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwNjU0NDM3OA==",
                                           "createdAt":  "2019-06-27T23:17:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "analogrelay",
                                           "body":  "\u003e What is a cache if not a \"database\"?\r\n\r\nOur understanding of caching here has traditionally been that the data in the cache can never be expected to remain there, it could disappear at any time (due to scavenging, expiration, etc.). I could buy that it\u0027s up to the consumer to set that policy though.\r\n\r\n\u003e The most popular caches support these operations.\r\n\r\nYeah, that does seem to be the case. Fair point.\r\n\r\nAlright, I can see those points. I guess I\u0027m still not totally clear on how scavenging affects this but I can buy that it\u0027s a common enough pattern to be warranted.\r\n\r\nWe still have to reconcile the breaking change angle, since adding this API would force any caching provider to support it. Perhaps we can do something hacky with default interface members but it would require making a lot of assumptions. It\u0027s much too late to do this in 3.0 but I\u0027ll reopen and backlog this.",
                                           "updatedAt":  "2019-06-27T23:18:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwNjYxMzIzNA==",
                                           "createdAt":  "2019-06-28T06:04:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "khellang",
                                           "body":  "\u003e We still have to reconcile the breaking change angle, since adding this API would force any caching provider to support it. Perhaps we can do something hacky with default interface members but it would require making a lot of assumptions. It\u0027s much too late to do this in 3.0 but I\u0027ll reopen and backlog this.\r\n\r\nI\u0027m totally fine with introducing a new interface and do a cast check on the injected `IDistributedCache` to utilize the new methods if available, like DI\u0027s `ISupportRequiredService` 😉 Then fall back to what I\u0027m currently doing if it\u0027s not available.",
                                           "updatedAt":  "2019-06-28T06:04:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2OTUwMjQ2NQ==",
                                           "createdAt":  "2019-12-29T12:50:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "abhiyx",
                                           "body":  "when is this feature getting rolled out",
                                           "updatedAt":  "2019-12-29T12:50:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2OTU0MjQzOQ==",
                                           "createdAt":  "2019-12-29T21:12:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "analogrelay",
                                           "body":  "@abhiyx at this point we have no scheduled release for this feature. We\u0027re in the midst of planning for 5.0, and this will be considered there (it will have to be prioritized against other work we have to plan for 5.0 though, so there are no guarantees :)).",
                                           "updatedAt":  "2019-12-29T21:12:10Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMjcyMTg1OQ==",
                                           "createdAt":  "2020-10-02T13:03:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "glucaci",
                                           "body":  "there are any news for this feature ?",
                                           "updatedAt":  "2020-10-02T13:03:40Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwNDQ2OTA0NQ==",
                                           "createdAt":  "2020-10-06T18:32:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "khellang",
                                           "body":  "Yeah, I\u0027d still like to get this feature in. What would be the best way to attack this? Submit a PR for an additional interface with the new members? Does it have to go through API review?",
                                           "updatedAt":  "2020-10-06T18:32:08Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwNDQ3ODU5MA==",
                                           "createdAt":  "2020-10-06T18:45:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "Everything has to go through API review and it\u0027s a breaking change and we haven\u0027t even agreed that this makes sense on anything besides a redis implementation.",
                                           "updatedAt":  "2020-10-06T18:45:35Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwNDQ4MTc5OQ==",
                                           "createdAt":  "2020-10-06T18:50:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBTMRFA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "DavudSafarli",
                                                                               "createdAt":  "2020-10-12T14:13:21Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "khellang",
                                           "body":  "\u003e it\u0027s a breaking change\r\n\r\nAdding a separate interface that implementations can opt into is a breaking change?\r\n\r\n\u003e we haven\u0027t even agreed that this makes sense on anything besides a redis implementation.\r\n\r\nMost other platforms seems to be able to handle this just fine, whether the backing store is in-memory, Redis, Memcached or SQL-based 🤷‍♂️ \r\n\r\nWhat can we do to further this proposal?",
                                           "updatedAt":  "2020-10-06T18:50:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwNTAxNDI4NA==",
                                           "createdAt":  "2020-10-07T15:28:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "eerhardt",
                                           "body":  "\u003e What can we do to further this proposal?\r\n\r\nCheck out the API proposal review process here: https://github.com/dotnet/runtime/blob/master/docs/project/api-review-process.md. Specifically this part:\r\n\r\n\u003e Please use [this template](https://github.com/dotnet/runtime/issues/new?assignees=\u0026labels=api-suggestion\u0026template=02_api_proposal.md\u0026title=). The issue should have the label api-suggestion. Here is a [good example](https://github.com/dotnet/runtime/issues/38344) of an issue following that template.\r\n\r\nThe current proposal on top of this issue would be a breaking change, which we\u0027ve decided we can\u0027t take. To make progress, can you edit the top proposal to match the template with the newly proposed APIs?",
                                           "updatedAt":  "2020-10-07T15:28:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42f8H2",
                                           "createdAt":  "2021-09-07T14:13:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "atuls9390",
                                           "body":  "@khellang Any work-around for above-mentioned INCR issue? ",
                                           "updatedAt":  "2021-09-07T14:14:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42gAEi",
                                           "createdAt":  "2021-09-07T14:34:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCuOCSQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "CONFUSED",
                                                                               "user":  "ImoutoChan",
                                                                               "createdAt":  "2022-04-18T15:09:42Z"
                                                                           },
                                                                           {
                                                                               "content":  "CONFUSED",
                                                                               "user":  "pinkfloydx33",
                                                                               "createdAt":  "2022-10-20T19:36:37Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "khellang",
                                           "body":  "Not really. I ended up just using the Redis API directly and not shipping a library to NuGet as it wouldn\u0027t be as useful without proper abstractions.",
                                           "updatedAt":  "2021-09-07T14:34:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Mp53O",
                                           "createdAt":  "2022-10-20T19:44:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pinkfloydx33",
                                           "body":  "I ended up having to switch my abstractions over to the replacements offered by [Foundatio](https://github.com/FoundatioFx/Foundatio.Redis#caching) just to get increment/decrement. I\u0027d prefer to use those offered by the framework rather than leek Foundatio into all my projects (though I admit there\u0027s definite bonus points for all the other stuff their abstractions offer.). ",
                                           "updatedAt":  "2022-10-20T19:44:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57pUme",
                                           "createdAt":  "2024-04-24T08:50:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AlOnestone01",
                                           "body":  "Hi. Are there any updates on this? We would also love to see this being implemented!",
                                           "updatedAt":  "2024-04-24T08:50:47Z"
                                       }
                                   ],
                         "totalCount":  25
                     },
        "title":  "Add atomic increment/decrement operations to IDistributedCache",
        "labels":  [
                       "api-suggestion",
                       "area-Extensions-Caching"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/36402",
        "createdAt":  "2018-12-21T14:33:16Z",
        "number":  36402,
        "author":  "RajivPandi",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODNigkQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "stefankip",
                                            "createdAt":  "2019-08-09T08:41:31Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "John0King",
                                            "createdAt":  "2019-08-20T01:50:09Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dropsonic",
                                            "createdAt":  "2020-03-24T18:16:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "raulgomezn",
                                            "createdAt":  "2020-05-07T23:26:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lopezbertoni",
                                            "createdAt":  "2020-05-21T18:12:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "BrandonBoone",
                                            "createdAt":  "2020-05-28T16:49:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "marcasmar94",
                                            "createdAt":  "2020-06-14T20:29:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "gBritz",
                                            "createdAt":  "2020-06-19T19:13:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hdinizribeiro",
                                            "createdAt":  "2020-07-17T12:42:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ganhammar",
                                            "createdAt":  "2020-09-26T09:24:20Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "VadimOvchinnikov",
                                            "createdAt":  "2021-06-14T12:06:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sanjaydebnath",
                                            "createdAt":  "2021-07-16T17:32:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "altso",
                                            "createdAt":  "2021-07-29T19:26:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mark-bentley-vizworx",
                                            "createdAt":  "2021-07-29T19:59:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "unchase",
                                            "createdAt":  "2021-08-03T13:21:17Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "steven-rothwell",
                                            "createdAt":  "2021-10-11T19:25:25Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "alikrc",
                                            "createdAt":  "2022-01-27T12:06:33Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "bbrandt",
                                            "createdAt":  "2022-04-14T19:32:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dmpe",
                                            "createdAt":  "2022-05-28T12:12:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "damianog",
                                            "createdAt":  "2022-06-03T17:56:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "viktor-svub",
                                            "createdAt":  "2022-06-11T05:46:51Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dario-oppl",
                                            "createdAt":  "2022-06-29T13:37:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DefinitelyADev",
                                            "createdAt":  "2022-07-05T21:38:02Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "DefinitelyADev",
                                            "createdAt":  "2022-07-05T21:38:05Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "glen-84",
                                            "createdAt":  "2022-07-15T10:59:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rinukkusu",
                                            "createdAt":  "2022-07-18T07:36:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dchennaraidu",
                                            "createdAt":  "2022-07-26T03:10:25Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ddynamight",
                                            "createdAt":  "2023-11-28T10:48:37Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "GovindKarthikeyan",
                                            "createdAt":  "2024-01-01T01:31:03Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "matrix101",
                                            "createdAt":  "2024-01-13T11:19:09Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "abbasaryanpour",
                                            "createdAt":  "2024-05-20T13:15:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "powareverb",
                                            "createdAt":  "2025-01-12T06:47:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "erikbozic",
                                            "createdAt":  "2025-01-23T13:59:25Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "IT-CASADO",
                                            "createdAt":  "2025-02-04T08:46:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "prasob-ps",
                                            "createdAt":  "2025-02-05T06:01:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Alex69rus",
                                            "createdAt":  "2025-03-18T10:53:37Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "huyHA9597",
                                            "createdAt":  "2025-07-22T13:52:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sevensolutions",
                                            "createdAt":  "2025-08-31T13:01:12Z"
                                        }
                                    ],
                          "totalCount":  38
                      },
        "updatedAt":  "2024-07-17T16:21:31Z",
        "body":  "Is there an extension method available to get the list of keys from the cache. \r\nI am using Redis Cache provider, i can able to get the list of keys matching the patter using Redis CLI. I am looking for similar feature using IDistributedCache.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOdYbu-w==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4NjA3MTM2Ng==",
                                           "createdAt":  "2019-04-24T05:17:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEbd0PQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hfaran",
                                                                               "createdAt":  "2019-04-25T00:07:56Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "navaei",
                                                                               "createdAt":  "2019-04-29T12:02:02Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "cihangll",
                                                                               "createdAt":  "2019-05-28T10:32:57Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Confusingboat",
                                                                               "createdAt":  "2019-07-25T21:12:39Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ralftar",
                                                                               "createdAt":  "2019-09-16T09:08:21Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "one-matrix",
                                                                               "createdAt":  "2019-11-07T05:37:48Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "viktordineout",
                                                                               "createdAt":  "2019-11-21T13:34:08Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "TheTedster",
                                                                               "createdAt":  "2019-12-09T17:23:28Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "dropsonic",
                                                                               "createdAt":  "2020-03-24T18:16:41Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "raulgomezn",
                                                                               "createdAt":  "2020-05-07T23:26:46Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "dev-thinks",
                                                                               "createdAt":  "2020-05-17T23:40:11Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "lopezbertoni",
                                                                               "createdAt":  "2020-05-21T18:12:37Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "BrandonBoone",
                                                                               "createdAt":  "2020-05-28T16:50:11Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "marcasmar94",
                                                                               "createdAt":  "2020-06-14T20:29:58Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "gBritz",
                                                                               "createdAt":  "2020-06-19T19:13:10Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Sharaf0",
                                                                               "createdAt":  "2020-07-21T17:17:01Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ganhammar",
                                                                               "createdAt":  "2020-09-26T09:24:20Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "VadimOvchinnikov",
                                                                               "createdAt":  "2021-06-14T12:06:07Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "sanjaydebnath",
                                                                               "createdAt":  "2021-07-16T17:32:56Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "altso",
                                                                               "createdAt":  "2021-07-29T19:26:44Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "steven-rothwell",
                                                                               "createdAt":  "2021-10-11T19:25:29Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "awa-nc",
                                                                               "createdAt":  "2021-12-17T13:41:12Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alikrc",
                                                                               "createdAt":  "2022-01-27T12:06:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "dmpe",
                                                                               "createdAt":  "2022-05-28T12:12:10Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "danbopes",
                                                                               "createdAt":  "2022-06-06T05:46:42Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "dario-oppl",
                                                                               "createdAt":  "2022-06-29T13:37:31Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "rinukkusu",
                                                                               "createdAt":  "2022-07-18T07:36:44Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "gabrbuiv",
                                                                               "createdAt":  "2022-11-21T12:41:23Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "grrigore",
                                                                               "createdAt":  "2024-05-09T08:20:30Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "abbasaryanpour",
                                                                               "createdAt":  "2024-05-20T13:15:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alexey-gorshkov",
                                                                               "createdAt":  "2024-10-16T08:24:02Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "medvedevden1s",
                                                                               "createdAt":  "2025-04-29T08:40:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "huyHA9597",
                                                                               "createdAt":  "2025-07-22T13:52:38Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  33
                                                         },
                                           "author":  "chuanboz",
                                           "body":  "+1 for this request. Any plan to add this support in the near future?",
                                           "updatedAt":  "2019-04-24T05:17:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUxOTgzNTM1OA==",
                                           "createdAt":  "2019-08-09T08:41:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stefankip",
                                           "body":  "Too bad nobody cares to help is with this 👎 ",
                                           "updatedAt":  "2019-08-09T08:41:47Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3MjMwOTc1MQ==",
                                           "createdAt":  "2020-01-08T23:35:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "skironDotNet",
                                           "body":  "You could write your own. I know not a good answer but I\u0027m looking for same thing, so I\u0027m going to have my instance of IDistributedCache  where I pass original IDistributedCache  and low level Redis client, then will have a method to get keys, keeping ready features of IDistributedCache  like sliding expiration management. \r\n\r\nSaying all that I\u0027m supprised MS, didn\u0027t make this by deafult like KeyExists() or didn\u0027t expose Redis client as a property of IDistributedCache so it would be super easy to write extensions to use every feature of Redis.",
                                           "updatedAt":  "2020-01-08T23:35:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYwMzQyODU2NA==",
                                           "createdAt":  "2020-03-24T18:24:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dropsonic",
                                           "body":  "It is a very important feature indeed.\r\nIn my scenario, I have some features in every cache item (e.g., locale, username, etc.), and I want to invalidate the cache by a specific feature (e.g., invalidate all cache items where locale = \"en-US\").\r\nIt is impossible to do with the current interface.\r\n\r\n@skironDotNet exposing Redis client is not a good idea because `IDistributedCache` hides implementation details from you. It might be Redis, but it also might be SQL or in-memory cache so you cannot use Redis-specific details.",
                                           "updatedAt":  "2020-03-24T18:24:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwNTAzNDUwNQ==",
                                           "createdAt":  "2020-10-07T16:00:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "maryamariyan",
                                           "body":  "I believe this would be a new feature request.\r\n\r\ncc: @Tratcher @eerhardt \r\n",
                                           "updatedAt":  "2020-10-07T16:00:50Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwNTAzOTI3NQ==",
                                           "createdAt":  "2020-10-07T16:08:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Tratcher",
                                           "body":  "Yes this would require new APIs. We\u0027ve decided against this in the past for both IDistributedCache and IMemoryCache because of the ephemeral nature of cache entries. An entry name might be returned in the list, but then be removed and/or replaced before you could request it.",
                                           "updatedAt":  "2020-10-07T16:08:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwNTA0NzYxNA==",
                                           "createdAt":  "2020-10-07T16:22:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD2goxw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "maryamariyan",
                                                                               "createdAt":  "2020-10-07T16:27:24Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "davidfowl",
                                                                               "createdAt":  "2020-10-14T07:40:03Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "eldiosyeldiablo",
                                                                               "createdAt":  "2020-11-01T02:18:27Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alanleouk",
                                                                               "createdAt":  "2020-11-25T13:07:06Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "rolfik",
                                                                               "createdAt":  "2020-11-30T10:44:58Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "udlose",
                                                                               "createdAt":  "2020-12-31T19:52:37Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "VadimOvchinnikov",
                                                                               "createdAt":  "2021-06-14T12:08:06Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "sanjaydebnath",
                                                                               "createdAt":  "2021-07-16T17:33:09Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pradeepgururani",
                                                                               "createdAt":  "2021-08-23T08:19:39Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "d1820",
                                                                               "createdAt":  "2021-10-28T15:12:37Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "olaj",
                                                                               "createdAt":  "2021-12-06T21:11:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "danbopes",
                                                                               "createdAt":  "2022-06-06T05:47:05Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alexey-gorshkov",
                                                                               "createdAt":  "2024-10-16T08:25:22Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  13
                                                         },
                                           "author":  "eerhardt",
                                           "body":  "\u003e We\u0027ve decided against this in the past for both IDistributedCache and IMemoryCache because of the ephemeral nature of cache entries. \r\n\r\nMy thinking is that we could return a \"snapshot\" of the keys in the cache at the point in time you ask for them. There wouldn\u0027t be a guarantee that the key would still exist (or have the same value) after the call. The idea being you could use this new API in conjunction with #36568, to allow users to remove many entries in a single call. Given the snapshot, they can look through them (maybe apply Regex or StartsWith or similar), and build up a list of the entries they want to remove. This seems to be a pretty popular scenario - we saw a handful of issues discussing this same thing.",
                                           "updatedAt":  "2020-10-07T16:22:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DqC_C",
                                           "createdAt":  "2022-05-23T20:13:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rickdgray",
                                           "body":  "How is this still not implemented? Disappointed.",
                                           "updatedAt":  "2022-05-23T20:13:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DvL48",
                                           "createdAt":  "2022-05-24T21:20:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "maryamariyan",
                                           "body":  "Set milestone to 8.0. Next step here we\u0027ll need to prepare API suggestions.",
                                           "updatedAt":  "2022-05-24T21:20:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5EvTWY",
                                           "createdAt":  "2022-06-12T18:10:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD4sbnw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "viktor-svub",
                                                                               "createdAt":  "2022-06-13T09:22:07Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "rinukkusu",
                                                                               "createdAt":  "2022-06-29T13:43:31Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alexzuev",
                                                                               "createdAt":  "2023-04-19T09:13:07Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "xvdm",
                                                                               "createdAt":  "2023-05-10T18:17:56Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ricred",
                                                                               "createdAt":  "2023-10-09T13:04:50Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alexey-gorshkov",
                                                                               "createdAt":  "2024-10-16T08:25:59Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "elmanav",
                                                                               "createdAt":  "2024-10-30T10:38:52Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  7
                                                         },
                                           "author":  "Strandedpirate",
                                           "body":  "When you don\u0027t dogfood your own code, and basic requirements fall through the cracks for literal years... oof\r\nSee you all in .net 10 when this finally drops, and we\u0027ve all retired.",
                                           "updatedAt":  "2022-06-12T18:10:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5FvKeN",
                                           "createdAt":  "2022-06-29T13:37:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEfP5AQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "glen-84",
                                                                               "createdAt":  "2022-07-15T11:00:06Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "rinukkusu",
                                                                               "createdAt":  "2022-07-18T07:37:30Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MayurAristocrat",
                                                                               "createdAt":  "2023-06-13T10:21:50Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "liculm",
                                                                               "createdAt":  "2024-05-02T12:04:06Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ppmaluch",
                                                                               "createdAt":  "2024-09-19T14:12:05Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alexey-gorshkov",
                                                                               "createdAt":  "2024-10-16T08:26:18Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Layiri",
                                                                               "createdAt":  "2025-08-22T10:31:28Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  7
                                                         },
                                           "author":  "dario-oppl",
                                           "body":  "\u003e this would require new APIs. We\u0027ve decided against this in the past for both IDistributedCache and IMemoryCache because of the ephemeral nature of cache entries. An entry name might be returned in the list, but then be removed and/or replaced before you c\r\n\r\nBut let me decide about what do I do in that case!\r\nCan\u0027t believe this is `THE` reason for not adding the method.\r\nI can\u0027t imagine rdbms not implementing SELECT because they implement a DELETE :( and data can be deleted before is queried.\r\n\r\n",
                                           "updatedAt":  "2022-06-29T13:37:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Jhi1c",
                                           "createdAt":  "2022-08-31T23:04:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "BuddhaBuddy1",
                                           "body":  "Just give us a Command or Action method. That way, it can be atomic, not a returned list of values, but an action that is performed during the scan at the moment a matching key is found.",
                                           "updatedAt":  "2022-08-31T23:04:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5LLwOz",
                                           "createdAt":  "2022-09-28T19:27:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC1pQYA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "wilkovanderveen",
                                                                               "createdAt":  "2023-02-08T06:17:07Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "WhitWaldo",
                                           "body":  "I would urge the team to think less about downstream ramifications of returning keys that may no longer be present and leave that as an exercise to the developer about how to handle the issue. Presumably, we\u0027re aware (since we\u0027re querying a cache implementation) that we\u0027re requesting information about keys whose values are bound to various expiration windows.\r\n\r\nI would thus propose that the revised API add both a 1) method for listing known, current (at that time, knowing it\u0027s a distributed operation and this snapshot may not be perfectly up to date) keys stored in the system making no guarantees about whether they\u0027ll be available in a future call or not and 2) a method (e.g. GetCacheItemMetadata or the like) that allows the developer to, given a key, get information about the expiration window for a given cache item, if it is still valid when this call is made.\r\n\r\nIf the expiration information is meaningful to the developer, this gives them an opportunity to do that second round-trip to the implementation to both 1) determine if the entry is still valid and 2) learn how much longer it will be valid for. \r\n\r\nOtherwise, when requesting a list of keys with no guarantees made about their lifetime after that ask, any calls to get the value would succeed or fail just like any other time I attempt to access a cache entry with a valid or expired key: you don\u0027t know until you ask. \r\n\r\nI don\u0027t see any reason to overcomplicate the ask here, but I\u0027d be interested to hear more about why the team thinks such guardrails are necessary here.",
                                           "updatedAt":  "2022-09-28T19:27:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5UwyC6",
                                           "createdAt":  "2023-02-08T06:16:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wilkovanderveen",
                                           "body":  "So if I understand correctly, the only way to retrieve multiple cached items by an expression based on the key, is, for now, to know and use the concrete implementation behind the interface for allowing to get all keys which match a certain pattern? ",
                                           "updatedAt":  "2023-02-08T06:16:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5WwU46",
                                           "createdAt":  "2023-03-06T06:06:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD2gqEw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ericrrichards",
                                                                               "createdAt":  "2024-01-08T19:55:43Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hoangsang03",
                                                                               "createdAt":  "2024-02-01T04:15:23Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "rina67",
                                                                               "createdAt":  "2024-02-19T08:02:35Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Petro1985",
                                                                               "createdAt":  "2024-02-22T12:24:41Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "abbasaryanpour",
                                                                               "createdAt":  "2024-05-20T13:15:59Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alexey-gorshkov",
                                                                               "createdAt":  "2024-10-16T08:27:06Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  6
                                                         },
                                           "author":  "davidhenley",
                                           "body":  "Is this still not done after 5 years? I guess back to using the IConnectionMultiplexer itself\r\n\r\n```csharp\r\nvar db = Redis.GetDatabase();\r\nvar endpoint = Redis.GetEndPoints().First();\r\nvar redisServer = Redis.GetServer(endpoint);\r\nawait foreach (var key in redisServer.KeysAsync(pattern: $\"{typeof(TEntity).Name}:list*\"))\r\n{\r\n    await db.KeyDeleteAsync(key);\r\n}\r\n```",
                                           "updatedAt":  "2023-03-06T06:10:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5b5WOC",
                                           "createdAt":  "2023-05-10T09:28:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "acandaldev",
                                           "body":  "With a concurrentDictionary and adding deleting in Get and Remove can be done?\r\nI did my personal implementation of this",
                                           "updatedAt":  "2023-05-10T21:14:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51hu77",
                                           "createdAt":  "2024-02-29T18:59:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODclmZg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jodydonetti",
                                                                               "createdAt":  "2024-03-02T17:53:05Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Askolein",
                                                                               "createdAt":  "2024-04-01T16:43:12Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "mgravell",
                                           "body":  "net9-timescale update; we\u0027re discussing a range of `IDistributedCache` changes [here](https://github.com/dotnet/aspnetcore/issues/53255); to be explicit, \"list of keys\" support is *not* currently on the \"doing right now\" list, but: the idea that we *might* want to support this is duly noted. The fundamental idea on that ticket is that `IDistributedCache` is not a particularly useful API, and the plan is to add a higher-level `HybridCache` which uses `IDistributedCache` as a backend. With *that* perspective, it means that we *could* also add some optional `ISomeNewKeysWhatever` API that the backend can implement if appropriate, and a suitable \"get keys if you can\" method on `HybridCache`. And since that is a *base class* rather than an *interface*, we can add methods without it breaking anything.\r\n\r\nHowever: I\u0027ll be honest - I\u0027m not a huge fan of \"list the keys\" APIs; in reality, most times I\u0027ve seen people use this kind of API: they\u0027ve been using it inappropriately and in ways that are actively harmful to the system. Key-value stores usually aren\u0027t optimized for this scenario *if it is even possible at all* - they\u0027re optimized for \"GET {key}\" and \"PUT {KEY} {value} {expiry}\" (in the language of the backend). This usage might make sense for a \"database admin / visualization\" tool, but it *isn\u0027t* usually something you should use in routine/regular application code, IMO.\r\n\r\nI will note that Aspire makes it easier to also get to the \"real\" backend, such as `IConnectionMultiplexer` in the case of redis, and *from there*: there are ways of getting the keys - although it would be up to the consumer to enforce DB/prefix/etc complications, which are the things we would deal with on the caller\u0027s behalf if we *did* add direct support. Obviously this doesn\u0027t generalize - i.e. if you\u0027re using SQL or Cosmos or NCache or whatever: you\u0027d need to start from scratch. The \"add some `ISomeNewKeysWhatever` that `HybridCache` knows about\" *would* generalize, but would still be dependent on individual backends adding support (we would help with that for some backends).",
                                           "updatedAt":  "2024-02-29T19:03:10Z"
                                       }
                                   ],
                         "totalCount":  17
                     },
        "title":  "How to get the list of keys using IDistributedCache extension.",
        "labels":  [
                       "feature-request",
                       "area-Extensions-Caching"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/36379",
        "createdAt":  "2019-05-30T08:41:54Z",
        "number":  36379,
        "author":  "avin-kavish",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC3mm5w==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MisinformedDNA",
                                            "createdAt":  "2019-10-03T15:24:36Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dibiancoj",
                                            "createdAt":  "2020-02-22T21:53:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "alexander-lysenko-88",
                                            "createdAt":  "2020-04-03T16:01:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "loraderon",
                                            "createdAt":  "2020-11-17T12:06:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "bbrandt",
                                            "createdAt":  "2021-03-03T20:40:20Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sanjaydebnath",
                                            "createdAt":  "2021-08-10T22:43:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "gregbrant2",
                                            "createdAt":  "2021-10-05T13:07:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "awa-nc",
                                            "createdAt":  "2021-12-03T08:46:06Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AdisonCavani",
                                            "createdAt":  "2022-07-08T21:09:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "glen-84",
                                            "createdAt":  "2022-07-15T10:20:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "twpol",
                                            "createdAt":  "2022-09-22T18:56:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "glacasa",
                                            "createdAt":  "2022-11-30T11:40:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "tmzblue",
                                            "createdAt":  "2023-06-03T16:01:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "tsemer",
                                            "createdAt":  "2023-09-29T11:09:05Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "TechWatching",
                                            "createdAt":  "2023-11-22T13:14:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "FunksMaName",
                                            "createdAt":  "2024-02-23T14:40:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dmurphyfa",
                                            "createdAt":  "2024-05-01T08:31:09Z"
                                        }
                                    ],
                          "totalCount":  17
                      },
        "updatedAt":  "2024-03-14T14:49:35Z",
        "body":  "### Is your feature request related to a problem? Please describe.\r\nMaybe I\u0027ve missed it, but I searched the API docs. It felt a bit odd not finding this.\r\nIt is often a common pattern to fetch a value from a cache or to compute and set the value if the cache does not contain the value. For this purpose the IMemoryCache has an extension in the form `CacheExtensions.GetOrCreateAsync`. In-memory caches are practically limited and most production scenarios use a distributed cache of some form or the other. But IDistributedCache does not seem to contain a similar extension. \r\n\r\n### Describe the solution you\u0027d like\r\n\r\nThe IMemoryCache extension has the following signature\r\n```c#\r\npublic static System.Threading.Tasks.Task\u003cTItem\u003e GetOrCreateAsync\u003cTItem\u003e (this Microsoft.Extensions.Caching.Memory.IMemoryCache cache, object key, Func\u003cMicrosoft.Extensions.Caching.Memory.ICacheEntry,System.Threading.Tasks.Task\u003cTItem\u003e\u003e factory);\r\n```\r\n\r\nSimilarly, I have created my own set of IDistributedCache extensions for this purpose, one of which has the signature,\r\n```c#\r\npublic static async Task\u003cT\u003e GetOrCreateAsync\u003cT\u003e(this IDistributedCache cache, \r\nstring key, Func\u003cTask\u003cT\u003e\u003e creator, DistributedCacheEntryOptions options = null)\r\n```\r\n\r\nI propose adding this or perhaps one or more of the following variants to the upstream project.\r\n\r\n```c#\r\npublic static async Task\u003cT\u003e GetOrCreateAsync\u003cT\u003e(this IDistributedCache cache, \r\nFunc\u003cIDistributedCacheEntry\u003cT\u003e, Task\u003cT\u003e\u003e factory)\r\n\r\nwhere IDistributedCacheEntry : { string Key; T Value; .....Expiration Options }\r\n\r\npublic static async Task\u003cT\u003e GetOrCreateAsync\u003cT\u003e(this IDistributedCache cache, string key, Func\u003cTask\u003cT\u003e\u003e factory)\r\n\r\npublic static async Task\u003cstring\u003e GetOrCreateAsync(this IDistributedCache cache, string key, Func\u003cTask\u003cstring\u003e\u003e factory)\r\n\r\npublic static async Task\u003cbyte[]\u003e GetOrCreateAsync(this IDistributedCache cache, string key, Func\u003cTask\u003cbyte[]\u003e\u003e factory)\r\n```\r\nIDistributedCache already has string and byte overloads for Get and Set so it only seems appropriate for GetOrCreate to do the same.\r\n\r\n### Describe alternatives you\u0027ve considered\r\nThe developer can always do \r\n\r\n```c#\r\nif(Get() == null)\r\n{\r\n   ComputeValue();\r\n   SetValue();\r\n}\r\n```\r\nBut this pattern gets repeated so much that it warrants it\u0027s own method. It also introduces a branched condition and a closure under the if statement which increases the cyclomatic complexity of the (action) method, requiring variables to be hoisted and such. eg: In totally not psuedo CJavaSharp++\r\n\r\n```c#\r\nModel model;\r\nmodel = cache.Get(\u0027key\u0027)\r\nif(model == null)\r\n{\r\n  model = ComputeValue();\r\n  cache.Set(\u0027key\u0027, model);\r\n}\r\nreturn view(model);\r\n```\r\nwith the proposed extension:\r\n```c#\r\nvar model = await cache.GetOrCreateAsync(\u0027key\u0027, \r\n  async () =\u003e await TableScanorAPICallorSomeDelayInducingComputation())\r\n```\r\nalso enabling this on rare occasions:\r\n```c#\r\npublic async Task\u003cIActionResult\u003e Action() =\u003e View(await GetOrCreateAsync(\u0027key\u0027, async () =\u003e await TableScanorAPICallorSomeDelayInducingComputation()));\r\n```\r\n\r\n### Real World Usage Example\r\nThis is how I use my personal extensions:\r\n```c#\r\n    var vm = await _cache.GetOrCreateAsync(\"default-home-page-data\", \r\n      async () =\u003e new HomePageViewModel\r\n      {\r\n        Years = await _catalog.YearsWithModelsAsync(),\r\n        Makes = await _catalog.PopularMakesAsync(),\r\n        Categories = await _catalog.CategoriesAtDepthAsync(1),\r\n        Stores = await _merchant.TopStoresAsync(),\r\n        FeaturedListings = await _listing.FeaturedListingsAsync()\r\n       });\r\n\r\n    var user = await _cache.GetOrCreateAsync(\"summary-user-\" + userId, \r\n      () =\u003e _userM.GetUserAsync(User), \r\n      new DistributedCacheEntryOptions()\r\n        .SetAbsoluteExpiration(TimeSpan.FromMinutes(5)));\r\n```\r\n\r\n### Real World Implementations in Alternate Frameworks\r\nIf you can\u0027t take my word for it, Rails already has this implementation as\r\n\r\n```c#\r\nRails.cache.fetch(\"#{cache_key}/competing_price\", expires_in: 12.hours) do\r\n      Competitor::API.find_price(id)\r\n    end\r\n```\r\nWhere the return value of the do block is cached and returned if the fetch misses.\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOdxGClA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwNjA0NDM0NQ==",
                                           "createdAt":  "2019-06-26T21:04:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "analogrelay",
                                           "body":  "Generally, a distributed cache can\u0027t give the same kind of behaviors that an in-memory cache can provide here, so we don\u0027t provide a built-in `GetOrCreateAsync` method. Also it would a major breaking change since we\u0027d be adding a method to an interface, and Extensions needs to run on .NET Standard 2.0 which doesn\u0027t support Default Interface Members.\r\n\r\nWe don\u0027t plan to do this, but it sounds like your extension method is working for you!",
                                           "updatedAt":  "2019-06-26T21:04:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwNjIyNTM2NA==",
                                           "createdAt":  "2019-06-27T07:21:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "avin-kavish",
                                           "body":  "\u003e Generally, a distributed cache can\u0027t give the same kind of behaviors that an in-memory cache can provide here, so we don\u0027t provide a built-in GetOrCreateAsync method.\r\n\r\nCan you ungenarilize this for me please? Can you elaborate on why you say a distributed cache cannot support this? Why can\u0027t a distributed cache provide a get or create method if it supports both get and create individually? Is this due to the expectation of atomicity? or that the method has to be a distributed cache provider primitive?\r\n\r\n\u003e Also it would a major breaking change since we\u0027d be adding a method to an interface, and Extensions needs to run on .NET Standard 2.0 which doesn\u0027t support Default Interface Members.\r\n\r\nCan\u0027t it be an extension method instead of part of the interface definition?",
                                           "updatedAt":  "2019-06-27T07:22:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwNjM5NTEwMA==",
                                           "createdAt":  "2019-06-27T15:30:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "analogrelay",
                                           "body":  "In investigating further, it does appear that our existing memory cache `GetOrCreateAsync` doesn\u0027t provide full atomicity (since multiple instances of the creation delegate can run simultaneously and overwrite each other), so we could probably support this here. I\u0027ll re-open. We don\u0027t have a concrete plan to do this yet though, as we have quite a lot of other high-priority issues on our plate.\r\n\r\n\u003e Can\u0027t it be an extension method instead of part of the interface definition?\r\n\r\nYes, it certainly **can** be an extension method. However, that completely locks out the ability for a distributed provider to override the behavior. For memory caches, we decided this was OK. I\u0027m not totally sure that\u0027s the same for distributed caches, but it\u0027s certainly an option.",
                                           "updatedAt":  "2019-06-27T15:30:01Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUzNzk5NDY1NQ==",
                                           "createdAt":  "2019-10-03T15:25:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MisinformedDNA",
                                           "body":  "This is something that people commonly want to do in a cache (per Google search).",
                                           "updatedAt":  "2019-10-03T15:25:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNTU1NzQwMw==",
                                           "createdAt":  "2020-05-08T00:04:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "As part of the migration of components from dotnet/extensions to dotnet/runtime (https://github.com/aspnet/Announcements/issues/411) we will be bulk closing some of the older issues. If you are still interested in having this issue addressed, just comment and the issue will be automatically reactivated (even if you aren\u0027t the author). When you do that, I\u0027ll page the team to come take a look. If you\u0027ve moved on or workaround the issue and no longer need this change, just ignore this and the issue will be closed in **7 days**.\n\nIf you know that the issue affects a package that has moved to a different repo, please consider re-opening the issue in that repo. If you\u0027re unsure, that\u0027s OK, someone from the team can help!",
                                           "updatedAt":  "2020-05-08T00:04:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNjA3NzQ2Mw==",
                                           "createdAt":  "2020-05-09T00:46:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MisinformedDNA",
                                           "body":  "Still interested. ",
                                           "updatedAt":  "2020-05-09T00:46:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNjA3NzQ3MQ==",
                                           "createdAt":  "2020-05-09T00:46:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Paging @dotnet/extensions-migration ! This issue has been revived from staleness. Please take a look and route to the appropriate repository.",
                                           "updatedAt":  "2020-05-09T00:46:09Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc1MzQ4NjAwMA==",
                                           "createdAt":  "2021-01-02T15:20:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEXBF6g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "suhrab",
                                                                               "createdAt":  "2022-12-21T12:56:25Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "suhrab",
                                                                               "createdAt":  "2022-12-21T12:56:28Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ukod",
                                                                               "createdAt":  "2023-09-01T08:20:25Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "ukod",
                                                                               "createdAt":  "2023-09-01T08:20:27Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "FunksMaName",
                                                                               "createdAt":  "2024-02-23T14:46:34Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "lukehook",
                                                                               "createdAt":  "2025-06-18T08:00:32Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  6
                                                         },
                                           "author":  "jodydonetti",
                                           "body":  "Hi @avin-kavish , if you still need some sort of optimized GetOrCreate for distributed caches may I suggest taking a look at [FusionCache ⚡🦥](https://github.com/jodydonetti/ZiggyCreatures.FusionCache) ?\r\n\r\nIt is an optionally multi-level (memory + distributed) cache with some other advanced features you may be interested in, like a fail-safe mechanism (see [here](https://github.com/jodydonetti/ZiggyCreatures.FusionCache/blob/main/docs/FailSafe.md)) , soft/hard timeouts with background factory completion (see [here](https://github.com/jodydonetti/ZiggyCreatures.FusionCache/blob/main/docs/Timeouts.md)) and more.\r\n\r\nAn introduction is available [here](https://github.com/jodydonetti/ZiggyCreatures.FusionCache/blob/main/docs/AGentleIntroduction.md).\r\n\r\nIn particular the method you are looking for is `GetOrSet[Async]` and is optimized for high concurrency on the same cache key (you can even provide your own impl of `IDistributedCache`).\r\n\r\nI just released it and, if you find it helpful, that would be great to know.\r\n\r\n/shameless-plug\r\n\r\nAlso, any comment on it would be greatly appreciated!\r\n\r\n**p.s.:** the locking works transparently on both the local memory cache and the optional distributed cache at the same time, but I\u0027d like to point out that what we are talking about is a **local lock** that will prevent multiple concurrent factory calls for the same key **in the same app** but **not in different apps/nodes**, because that would require a distributed lock and it\u0027s not something that nice to deal with.",
                                           "updatedAt":  "2021-01-02T15:20:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2ODg1NjU0Ng==",
                                           "createdAt":  "2021-06-25T22:05:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericsampson",
                                           "body":  "The OP request would be useful to consider.",
                                           "updatedAt":  "2021-06-25T22:05:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PdUYU",
                                           "createdAt":  "2022-12-01T02:55:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "peter-dolkens",
                                           "body":  "I\u0027m here also looking for a way to achieve GetOrCreate.\r\n\r\nI\u0027d like a reliable way to create a distributed lock using a IDistributedCache, and whilst I\u0027m not expecting distributed locks to be worked into IDistributedCache directly, it would be trivial to implement as an extension method if we had GetOrCreate.\r\n\r\ne.g. an extremely limited version might be:\r\n\r\n```\r\npublic Boolean AquireLock(this IDistributedCache cache, String lockID, TimeSpan lockDuration)\r\n{\r\n    var lockValue = $\"{Guid.NewGuid()}\";\r\n    var lockResult = await cache.GetOrCreate(lockID, lockValue, lockDuration);\r\n    return lockResult == lockValue;\r\n}\r\n```\r\n\r\nObviously this has serious limitations, but the intent is obvious.\r\n\r\nAs things stand now, I\u0027m having to do Get/Set/Wait/Check loops to try and make sure a different distributed system with greater latency didn\u0027t meet a race condition setting the cache - and in our scenario, we\u0027re expecting lots of collisions, increasing the frequency of these race conditions to virtually guaranteed.",
                                           "updatedAt":  "2022-12-01T02:55:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53DSEo",
                                           "createdAt":  "2024-03-14T12:32:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Polymathical",
                                           "body":  "I\u0027d like this. I think it\u0027s out of the scope of what amounts to a \"helper\" extensions to account for cache stampeding. ",
                                           "updatedAt":  "2024-03-14T12:32:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53EYKU",
                                           "createdAt":  "2024-03-14T14:49:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD7XGzg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Arthur-Lee",
                                                                               "createdAt":  "2024-11-18T13:10:34Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jodydonetti",
                                           "body":  "Look [here](https://github.com/dotnet/aspnetcore/issues/53255) for the new developments.",
                                           "updatedAt":  "2024-03-14T14:49:34Z"
                                       }
                                   ],
                         "totalCount":  12
                     },
        "title":  "GetOrCreateAync for IDistributedCache",
        "labels":  [
                       "api-suggestion",
                       "area-Extensions-Caching"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/42624",
        "createdAt":  "2020-09-23T14:13:17Z",
        "number":  42624,
        "author":  "xboxeer",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-10T05:03:18Z",
        "body":  "\u003c!--\r\n\r\nMore information on our issue management policies can be found here: https://aka.ms/aspnet/issue-policies\r\n\r\nPlease keep in mind that the GitHub issue tracker is not intended as a general support forum, but for reporting **non-security** bugs and feature requests.\r\n\r\nIf you believe you have an issue that affects the SECURITY of the platform, please do NOT create an issue and instead email your issue details to secure@microsoft.com. Your report may be eligible for our [bug bounty](https://www.microsoft.com/en-us/msrc/bounty-dot-net-core) but ONLY if it is reported through email.\r\nFor other types of questions, consider using [StackOverflow](https://stackoverflow.com).\r\n\r\n--\u003e\r\n\r\n### Describe the bug\r\nWhen we have a limit to the MemoryCache, its Evict logic does not behavior as expected\r\nThis is a bug we found in community [Why do I need to call twice the Set on my size limited MemoryCache when I hit the size limit?](https://stackoverflow.com/questions/63342763/why-do-i-need-to-call-twice-the-set-on-my-size-limited-memorycache-when-i-hit-th), the replier of this thread helped build a reproduce sample\r\n\r\n### To Reproduce\r\n\u003c!--\r\nWe ❤ code! Point us to a minimalistic repro project hosted in a GitHub repo.\r\nFor a repro project, create a new ASP.NET Core project using the template of your your choice, apply the minimum required code to result in the issue you\u0027re observing.\r\n\r\nWe will close this issue if:\r\n- the repro project you share with us is complex. We can\u0027t investigate custom projects, so don\u0027t point us to such, please.\r\n- if we will not be able to repro the behavior you\u0027re reporting\r\n--\u003e\r\nthe below code can reproduce this issue\r\n```c#\r\nclass Program\r\n    {\r\n        private static MemoryCache _cache;\r\n        private static MemoryCacheEntryOptions _options;\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            _cache = new MemoryCache(new MemoryCacheOptions\r\n            {\r\n                SizeLimit = 2\r\n            });\r\n\r\n            _options = new MemoryCacheEntryOptions\r\n            {\r\n                Size = 1\r\n            };\r\n            _options.PostEvictionCallbacks.Add(new PostEvictionCallbackRegistration\r\n            {\r\n                EvictionCallback = (key, value, reason, state) =\u003e\r\n                {\r\n                    if (reason == EvictionReason.Capacity)\r\n                    {\r\n                        Console.WriteLine($\"Evicting \u0027{key}\u0027 for capacity\");\r\n                    }\r\n                }\r\n            });\r\n\r\n            Console.WriteLine(TestCache(\"first\"));\r\n            Console.WriteLine(TestCache(\"second\"));\r\n            Console.WriteLine(TestCache(\"third\")); // starts compaction\r\n\r\n            Thread.Sleep(1000);\r\n\r\n            Console.WriteLine(TestCache(\"third\"));\r\n            Console.WriteLine(TestCache(\"third\")); // now from cache\r\n        }\r\n\r\n        private static object TestCache(string id)\r\n        {\r\n            if (_cache.TryGetValue(id, out var cachedEntry))\r\n            {\r\n                return cachedEntry;\r\n            }\r\n\r\n            _cache.Set(id, $\"{id} - cached\", _options);\r\n            return id;\r\n        }\r\n    }\r\n```\r\n\r\nExpected result should be \r\n```\r\nfirst\r\nsecond\r\nEvicting \u0027first\u0027 for capacity\r\nthird\r\nthird - cached\r\n```\r\n\r\nThe actual result is \r\n```\r\nfirst\r\nsecond\r\nthird\r\nEvicting \u0027third\u0027 for capacity\r\nEvicting \u0027first\u0027 for capacity\r\nthird\r\nthird - cached\r\n```\r\n\r\n### Exceptions (if any)\r\n\u003c!-- \r\nInclude the exception you get when facing this issue\r\n--\u003e\r\n\r\n### Further technical details\r\n- ASP.NET Core version\r\n3.1\r\n- Include the output of `dotnet --info`\r\n.NET Core SDK (reflecting any global.json):\r\n Version:   3.1.402\r\n Commit:    9b5de826fd\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.19042\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\3.1.402\\\r\n\r\nHost (useful for support):\r\n  Version: 3.1.8\r\n  Commit:  9c1330dedd\r\n\r\n.NET Core SDKs installed:\r\n  2.1.202 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.504 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.505 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.507 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.508 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.509 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.511 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.602 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.700 [C:\\Program Files\\dotnet\\sdk]\r\n  2.2.108 [C:\\Program Files\\dotnet\\sdk]\r\n  2.2.300 [C:\\Program Files\\dotnet\\sdk]\r\n  3.0.100 [C:\\Program Files\\dotnet\\sdk]\r\n  3.1.402 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET Core runtimes installed:\r\n  Microsoft.AspNetCore.All 2.1.8 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.11 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.12 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.13 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.15 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.22 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.2.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.2.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.App 2.1.8 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.11 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.12 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.13 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.15 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.22 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.2.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.2.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 3.0.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 3.0.1-dev [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 3.0.2 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 3.1.8 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 1.0.7 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.8 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.11 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.12 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.13 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.15 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.22 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.2.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.2.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 3.0.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 3.1.1 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 3.1.8 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.WindowsDesktop.App 3.0.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 3.1.8 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n- The IDE (VS / VS Code/ VS4Mac) you\u0027re running on, and it\u0027s version\r\nVS 2019 16.7.3\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOKeQpVw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMjgxODY0Nw==",
                                           "createdAt":  "2020-10-02T16:03:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @eerhardt, @maryamariyan\nSee info in area-owners.md if you want to be subscribed.",
                                           "updatedAt":  "2020-10-02T16:03:41Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "MemoryCache Evict Bug - Added item is evicted when capacity is hit",
        "labels":  [
                       "bug",
                       "help wanted",
                       "area-Extensions-Caching"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/44512",
        "createdAt":  "2020-11-11T07:03:19Z",
        "number":  44512,
        "author":  "maryamariyan",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC74Hnw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rolfik",
                                            "createdAt":  "2020-12-01T10:51:36Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DillonN",
                                            "createdAt":  "2020-12-03T05:49:16Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "adamsitnik",
                                            "createdAt":  "2020-12-04T12:38:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "udlose",
                                            "createdAt":  "2020-12-31T19:53:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ShreyasJejurkar",
                                            "createdAt":  "2021-01-04T17:26:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "d-oit",
                                            "createdAt":  "2021-03-22T15:02:18Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ncoussemacq",
                                            "createdAt":  "2021-07-05T10:16:37Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "falvarez1",
                                            "createdAt":  "2021-07-21T21:55:03Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "altso",
                                            "createdAt":  "2021-07-29T19:28:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "seanlmcgill",
                                            "createdAt":  "2021-08-30T19:27:32Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "avisra",
                                            "createdAt":  "2021-09-24T15:11:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "TAGC",
                                            "createdAt":  "2021-11-26T11:30:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "bbrandt",
                                            "createdAt":  "2022-04-14T19:33:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "14skywalker",
                                            "createdAt":  "2022-06-09T08:27:03Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "viktor-svub",
                                            "createdAt":  "2022-06-11T05:47:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "glen-84",
                                            "createdAt":  "2022-07-15T10:31:18Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "majora2007",
                                            "createdAt":  "2023-10-24T14:51:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Edgaras91",
                                            "createdAt":  "2023-10-30T12:52:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "xjose97x",
                                            "createdAt":  "2024-10-16T14:37:20Z"
                                        }
                                    ],
                          "totalCount":  19
                      },
        "updatedAt":  "2024-07-18T14:37:33Z",
        "body":  "As @eerhardt and I were triaging through caching extensions issues, we noticed a theme of requests being around allowing for key enumeration and bulk removal of items in IDistributedCache:\r\n\r\n- [ ] #36547: How to flush all cache\r\n- [ ] #36568: Bulk remove on IDistributedCache\r\n- [ ] #36402: Enumerating keys using IDistributedCache \r\n \r\nWe closed a number of items as dupes of the above issues as well.\r\n\r\nMore information on the intricacies of this issue and ways to approach it:\r\n\r\n- When using caching in extensions, we don\u0027t want to allow enumerating on keys while elements may get removed within another thread, (keeping as atomic operation). In order to allow for (e.g. bulk remove) we can offer returning a snapshot (say array of elements. For example to allow for bulk remove of items with a certain prefix (e.g. \"ZZZ\"), given a snapshot, we may use TryGetValue and if already gone it would not throw.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOVMOO5Q==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyNTI0NjE5NA==",
                                           "createdAt":  "2020-11-11T07:03:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @eerhardt, @maryamariyan\nSee info in area-owners.md if you want to be subscribed.\u003cdetails\u003e\n  \u003chr\u003e\n  \u003cb\u003eIssue meta data\u003c/b\u003e\n  \u003ctable\u003e\n  \u003ctr\u003e\n    \u003ctd\u003eIssue content:\u003c/td\u003e\n    \u003ctd\u003eAs @eerhardt and I were triaging through caching extensions issues, we noticed a theme of requests being around request to allow for key enumeration and bulk removal of items in IDistributedCache:\r\n\r\n- [ ] #36547: How to flush all cache\r\n- [ ] #36568: Bulk remove on IDistributedCach\r\n- [ ] #36402: Enumerating keys using IDistributedCache \r\n \r\nWe closed a number of items as dupes of the above issues as well.\r\n\r\nMore information on the intricacies of this issue and ways to approach it:\r\n\r\n- When using caching in extensions, we don\u0027t want to allow enumerating on keys while elements may get removed within another thread, (keeping as atomic operation). In order to allow for (e.g. bulk remove) we can offer returning a snapshot (say array of elements. For example to allow for bulk remove of items with a certain prefix (e.g. \"ZZZ\"), given a snapshot, we may use TryGetValue and if already gone it would not throw.\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003ctd\u003eIssue author:\u003c/td\u003e\n    \u003ctd\u003emaryamariyan\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003ctd\u003eAssignees:\u003c/td\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003ctd\u003eMilestone:\u003c/td\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003c/table\u003e\n  \u003c/details\u003e",
                                           "updatedAt":  "2020-11-11T07:03:21Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc1MzExMzQ2OA==",
                                           "createdAt":  "2020-12-31T20:34:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "udlose",
                                           "body":  "\u003e * ..... For example to allow for bulk remove of items with a certain prefix (e.g. \"ZZZ\"), given a snapshot, we may use TryGetValue and if already gone it would not throw.\r\n\r\n@maryamariyan, `StackExchange.Redis.IDatabase.KeyDeleteAsync(RedisKey[] keys, CommandFlags flags = CommandFlags.None)` does not throw an exception if a key is not found.  See - https://github.com/StackExchange/StackExchange.Redis/blob/6409b9d1f2afd01a7eab9498a525360d1ca2b752/src/StackExchange.Redis/Interfaces/IDatabaseAsync.cs#L442\r\n\r\nIs there a concern I\u0027m missing?",
                                           "updatedAt":  "2020-12-31T20:34:36Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwMTI0MDc2Mw==",
                                           "createdAt":  "2021-03-17T16:47:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kosmakoff",
                                           "body":  "I wonder if it is being worked on. I recently stumbled upon a case when I very much need to enumerate values (or keys at least) by pattern (prefix), otherwise I will have to use underlying caching solution directly, which breaks my abstractions.",
                                           "updatedAt":  "2021-03-17T16:47:37Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwMTQ0MTEyMw==",
                                           "createdAt":  "2021-03-17T21:03:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "udlose",
                                           "body":  "It looks like this has been added to the .NET 6.0 milestone (tentatively sched to be released in November 2021 - https://devblogs.microsoft.com/dotnet/announcing-net-6-preview-2/#:~:text=.NET%206%20will%20be%20released,Term%20Support%20(LTS)%20release.",
                                           "updatedAt":  "2021-03-17T21:03:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc40nFpu",
                                           "createdAt":  "2021-07-19T15:55:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "eerhardt",
                                           "body":  "We\u0027ve reached feature complete for .NET 6. Moving to 7.",
                                           "updatedAt":  "2021-07-19T15:55:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48t304",
                                           "createdAt":  "2022-01-21T16:20:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCxvF_g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "CONFUSED",
                                                                               "user":  "ATLSAPI",
                                                                               "createdAt":  "2022-01-22T07:16:19Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "sinanopcommerce",
                                                                               "createdAt":  "2022-03-09T06:17:30Z"
                                                                           },
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "khanhvu161188",
                                                                               "createdAt":  "2022-04-10T23:24:26Z"
                                                                           },
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "Strandedpirate",
                                                                               "createdAt":  "2022-06-12T18:10:25Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Strandedpirate",
                                                                               "createdAt":  "2022-06-12T18:10:30Z"
                                                                           },
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "meisenring",
                                                                               "createdAt":  "2022-09-13T10:46:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "arslanaybars",
                                                                               "createdAt":  "2022-12-23T09:21:10Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  7
                                                         },
                                           "author":  "avisra",
                                           "body":  "So this is being bumped again to .NET 8 now?",
                                           "updatedAt":  "2022-01-21T16:20:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49O-1x",
                                           "createdAt":  "2022-02-01T22:11:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "maryamariyan",
                                           "body":  "@avisra this is still being considered for 7.0 as a nice to have but not committed",
                                           "updatedAt":  "2022-02-02T01:01:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4-Cmg2",
                                           "createdAt":  "2022-02-15T22:39:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "maryamariyan",
                                           "body":  "@avisra I was looking to learn more about how IDistrbutedCache is being used? do you have sample code snippets to share to kick this off?",
                                           "updatedAt":  "2022-02-15T22:39:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4-FaDy",
                                           "createdAt":  "2022-02-16T15:18:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCw3GgQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "RickBlouch",
                                                                               "createdAt":  "2022-02-23T14:22:31Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "oyhan",
                                                                               "createdAt":  "2022-04-13T05:55:46Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "14skywalker",
                                                                               "createdAt":  "2022-06-10T11:06:11Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "viktor-svub",
                                                                               "createdAt":  "2022-06-11T05:47:55Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "bkagan98",
                                                                               "createdAt":  "2022-09-09T15:47:47Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "mehrdad-seno",
                                                                               "createdAt":  "2022-12-07T15:58:08Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  6
                                                         },
                                           "author":  "avisra",
                                           "body":  "@maryamariyan I am currently using IDistributedCache for caching data in my application (and for caching things within my IdentityServer instance). On my deployed application, I am configuring my cache to use Redis. Locally, I am using in-memory. But regardless of the provider, it is going through IDistributedCache. My goal for this ticket is to be able to enumerate the cache without identifying the provider. I\u0027d like to have a page in the administration of my application which displays a table with all of the objects in my cache (by key) and have a button for deleting/revalidating, etc. The only piece missing from this, which I\u0027m hoping this ticket can provider, is the ability to enumerate the objects in the cache collection.",
                                           "updatedAt":  "2022-02-16T15:18:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5EvVFs",
                                           "createdAt":  "2022-06-12T18:43:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Strandedpirate",
                                           "body":  "@avisra Here are a couple of potential interface additions for `IDistributedCache` for getting and performing common tasks with keys.\r\n\r\n```\r\n// retrieve a list of keys list synchronously using a pattern (pattern will be third-party dependent)\r\nIEnumerable\u003cstring\u003e Keys(string pattern);\r\n// retrieve a list of keys asynchronously using a pattern (pattern will be third-party dependent)\r\nTask\u003cIEnumerable\u003cstring\u003e\u003e KeysAsync(string pattern);\r\n\r\n// retrieve a list of values synchronously based on a set of keys\r\nIEnumerable\u003cbyte[]\u003e Get(param string[] keys);\r\n// retrieve a list of values asynchronously based on a set of keys\r\nTask\u003cIEnumerable\u003cbyte[]\u003e\u003e GetAsync(param string[] keys);\r\n\r\n// remove a list of values synchronously based on a set of keys\r\nvoid Remove(param string[] keys);\r\n// remove a list of values asynchronously based on a set of keys\r\nTask RemoveAsync(param string[] keys);\r\n\r\n// refresh a list of values synchronously based on a set of keys\r\nvoid Refresh(param string[] keys);\r\n// refresh a list of values asynchronously based on a set of keys\r\nTask RefreshAsync(param string[] keys);\r\n```\r\n\r\nusage:\r\n```\r\n// assume that the developer will have a wrapper that converts from bytes (used in `IDistrubutedCache` interface) to a .net value type or reference type.\r\n// redis specific example. using star (*) as the wildcard\r\nvar allAccessTokenKeys = _redisCacheService.Keys(\"AccessTokens:*\");\r\nforeach(var key in allAccessTokenKeys)\r\n{\r\n    Console.WriteLine(key);\r\n}\r\n\r\n// get all the values for all the keys we retrieved above\r\nvar allAccessTokens = _redisCacheService.Get(allAccessTokenKeys.ToArray());\r\nforeach(var token in allAccessTokens)\r\n{\r\n    Console.WriteLine(token);\r\n}\r\n\r\n// refresh all allAccessTokens in the cache, so they don\u0027t expire\r\n_redisCacheService.Refresh(allAccessTokenKeys.ToArray());\r\n\r\n// remove all allAccessTokens from the cache, except a special one\r\n_redisCacheService.Remove(allAccessTokenKeys.Where(a =\u003e a.Equals(\"AccessTokens:MySpecialKey\") == false).ToArray());\r\n```",
                                           "updatedAt":  "2022-06-12T18:43:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Uw47l",
                                           "createdAt":  "2023-02-08T06:57:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wilkovanderveen",
                                           "body":  "It seems that this is already possible with libraries _such as EasyCaching_.",
                                           "updatedAt":  "2023-02-08T06:57:49Z"
                                       }
                                   ],
                         "totalCount":  11
                     },
        "title":  "Enhancement to IDistributedCache - Allow for bulk remove and key enumeration",
        "labels":  [
                       "Epic",
                       "area-Extensions-Caching",
                       "User Story",
                       "Bottom Up Work",
                       "Team:Libraries"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/46032",
        "createdAt":  "2020-12-14T09:01:51Z",
        "number":  46032,
        "author":  "adamsitnik",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOBZ-vDQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "gfoidl",
                                            "createdAt":  "2020-12-14T09:05:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Tornhoof",
                                            "createdAt":  "2020-12-15T07:47:49Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2022-02-09T23:39:11Z",
        "body":  "As noticed by @gfoidl in https://github.com/dotnet/runtime/pull/45962/files#r541573802\r\n\r\nIt\u0027s possible that when the following code responsible for propagating the options to the linked cache entry:\r\n\r\nhttps://github.com/dotnet/runtime/blob/8d6e098d647bd59a79165c3ad6b31957999479bb/src/libraries/Microsoft.Extensions.Caching.Memory/src/CacheEntry.cs#L329-L341\r\n\r\ncalls the `parent.AddExpirationToken` method:\r\n\r\nhttps://github.com/dotnet/runtime/blob/1d9e50cb4735df46d3de0cee5791e97295eaf588/src/libraries/Microsoft.Extensions.Caching.Abstractions/src/CacheEntryExtensions.cs#L40\r\n\r\nis using `_expirationTokens` which **might be used without a lock** in the `CheckForExpiredTokens` method at the same time\r\n\r\nhttps://github.com/dotnet/runtime/blob/8d6e098d647bd59a79165c3ad6b31957999479bb/src/libraries/Microsoft.Extensions.Caching.Memory/src/CacheEntry.cs#L207-L229\r\n\r\nAdding a lock to `CheckForExpiredTokens` would be trivial, but it would hurt the perf...\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOPaZucw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0NDI5MDU5OQ==",
                                           "createdAt":  "2020-12-14T09:01:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @eerhardt, @maryamariyan\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nAs noticed by @gfoidl in https://github.com/dotnet/runtime/pull/45962/files#r541573802\r\n\r\nIt\u0027s possible that when the following code responsible for propagating the options to the linked cache entry:\r\n\r\nhttps://github.com/dotnet/runtime/blob/8d6e098d647bd59a79165c3ad6b31957999479bb/src/libraries/Microsoft.Extensions.Caching.Memory/src/CacheEntry.cs#L329-L341\r\n\r\ncalls the `parent.AddExpirationToken` method:\r\n\r\nhttps://github.com/dotnet/runtime/blob/1d9e50cb4735df46d3de0cee5791e97295eaf588/src/libraries/Microsoft.Extensions.Caching.Abstractions/src/CacheEntryExtensions.cs#L40\r\n\r\nis using `_expirationTokens` which **might be used without a lock** in the `CheckForExpiredTokens` method at the same time\r\n\r\nhttps://github.com/dotnet/runtime/blob/8d6e098d647bd59a79165c3ad6b31957999479bb/src/libraries/Microsoft.Extensions.Caching.Memory/src/CacheEntry.cs#L207-L229\r\n\r\nAdding a lock to `CheckForExpiredTokens` would be trivial, but it would hurt the perf...\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eadamsitnik\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-Extensions-Caching`, `bug`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2020-12-14T09:01:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49L-QC",
                                           "createdAt":  "2022-02-01T07:32:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "DobrovAlexey",
                                           "body":  "Hi I looked at the code and found that method `SetExpired` will be called from `CheckForExpiredTokens` \r\nhttps://github.com/dotnet/runtime/blob/8d6e098d647bd59a79165c3ad6b31957999479bb/src/libraries/Microsoft.Extensions.Caching.Memory/src/CacheEntry.cs#L207-L229\r\n\r\nInside the `SetExpired` method, `DetachTokens` will be called\r\n\r\nhttps://github.com/dotnet/runtime/blob/8d6e098d647bd59a79165c3ad6b31957999479bb/src/libraries/Microsoft.Extensions.Caching.Memory/src/CacheEntry.cs#L169-L177\r\n\r\nIn the `DetachTokens` method, The lock on the `_lock ` variable is already taken\r\n\r\nhttps://github.com/dotnet/runtime/blob/8d6e098d647bd59a79165c3ad6b31957999479bb/src/libraries/Microsoft.Extensions.Caching.Memory/src/CacheEntry.cs#L265-L281\r\n\r\nThus, we will not be able to get a lock on the `_lock ` variable inside `CheckForExpiredTokens`\r\n\r\nCan you suggest how this should be done?\r\nThanks.",
                                           "updatedAt":  "2022-02-01T07:32:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49pm5z",
                                           "createdAt":  "2022-02-09T23:39:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCOym_A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "eerhardt",
                                                                               "createdAt":  "2022-02-09T23:39:29Z"
                                                                           },
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "adamsitnik",
                                                                               "createdAt":  "2022-02-15T18:49:09Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "sebastienros",
                                           "body":  "I had this issue open in a popup, and clicked the \"Close\" button that was purple expecting it to close the popup ... I was wrong",
                                           "updatedAt":  "2022-02-09T23:39:11Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Possible thread safety issue with linked cache entries",
        "labels":  [
                       "bug",
                       "help wanted",
                       "area-Extensions-Caching"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/47239",
        "createdAt":  "2021-01-20T18:45:51Z",
        "number":  47239,
        "author":  "jeffhandley",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCqaPXA==",
                          "nodes":  [
                                        {
                                            "content":  "HEART",
                                            "user":  "danmoseley",
                                            "createdAt":  "2021-02-25T15:47:01Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "AraHaan",
                                            "createdAt":  "2022-09-03T00:24:25Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2022-09-03T00:28:45Z",
        "body":  "Previously, we avoided using a `Timer` for checking cache expiration because such usage would prevent recycling of idle services; this constraint no longer exists. With a `Timer`-based expiration check, `MemoryCache` APIs will no longer incur the cost of checking expiration time to spawn a background task to remove expired items. This will yield a ~10% RPS performance gain. See #45842 for more performance benchmark details and conversation.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOSava0A==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2Mzg1NTA0MA==",
                                           "createdAt":  "2021-01-20T18:45:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @eerhardt, @maryamariyan\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nPreviously, we avoided using a `Timer` for checking cache expiration because such usage would prevent recycling of idle services; this constraint no longer exists. With a `Timer`-based expiration check, `MemoryCache` APIs will no longer incur the cost of checking expiration time to spawn a background task to remove expired items. This will yield a ~10% RPS performance gain. See #45842 for more performance benchmark details and conversation.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejeffhandley\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003eadamsitnik\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`Bottom Up Work`, `User Story`, `area-Extensions-Caching`, `tenet-performance`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e6.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-01-20T18:45:53Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1MjUxNzI5Mw==",
                                           "createdAt":  "2021-06-01T22:19:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Tratcher",
                                           "body":  "\u003e Previously, we avoided using a `Timer` for checking cache expiration because such usage would prevent recycling of idle services; this constraint no longer exists.\r\n\r\nWhy does that constraint no longer exist? ASP.NET Core does not want timers firing on idle web services. @davidfowl ",
                                           "updatedAt":  "2021-06-01T22:19:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1MjUxOTY4Mw==",
                                           "createdAt":  "2021-06-01T22:21:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "We do have timers firing on idle web services. All the time.",
                                           "updatedAt":  "2021-06-01T22:21:34Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg3NTc3OTYxMQ==",
                                           "createdAt":  "2021-07-07T17:12:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "We are moving this out to .NET 7 as we haven\u0027t been able to get to it yet during .NET 6.",
                                           "updatedAt":  "2021-07-07T17:12:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Byp_p",
                                           "createdAt":  "2022-04-20T10:56:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCZBeog==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pentp",
                                                                               "createdAt":  "2022-04-21T08:01:34Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "I was chatting with @adamsitnik about some possible optimizations for MemoryCache:\r\n\r\n- DateTimeOffset.UtcNow called in the Add and Lookup paths can be expensive and it gives precision the cache expiration logic probably doesn\u0027t need. A different implementation of ISystemClock based on Environment.TickCount would probably be accurate enough and much faster.\r\n\r\n- There are a number of fields in the MemoryCacheEntry object that could be removed, split, and/or made lazy to save space per entry. On x64 the current layout looks like this:\r\n```\r\nSize:        152(0x98) bytes\r\n              MT    Field   Offset                 Type VT     Attr            Value Name\r\n00007ff7f8ea7a00  4000008        8 ...emory.MemoryCache  0 instance 0000025f1ca75960 _cache\r\n0000000000000000  4000009       10 ...+CacheEntryTokens  0 instance 0000000000000000 _tokens\r\n00007ff7f8eaa608  400000d       18 ...Memory.CacheEntry  0 instance 0000000000000000 _previous\r\n00007ff7f8bd5678  400000e       20        System.Object  0 instance 0000000000000000 _value\r\n00007ff7f8bd5678  4000011       28        System.Object  0 instance 0000025f1ca75888 \u003cKey\u003ek__BackingField\r\n00007ff7f8eaa138  400000a       30 ...Private.CoreLib]]  1 instance 0000025f1ca8aaf0 _absoluteExpirationRelativeToNow\r\n00007ff7f8eaa138  400000b       40 ...Private.CoreLib]]  1 instance 0000025f1ca8ab00 _slidingExpiration\r\n00007ff7f8ea8728  400000c       50 ...Private.CoreLib]]  1 instance 0000025f1ca8ab10 _size\r\n00007ff7f8eaa388  400000f       60 ...y+CacheEntryState  1 instance 0000025f1ca8ab20 _state\r\n00007ff7f8eaa510  4000010       68 ...Private.CoreLib]]  1 instance 0000025f1ca8ab28 \u003cAbsoluteExpiration\u003ek__BackingField\r\n00007ff7f8d4d308  4000012       80 ...em.DateTimeOffset  1 instance 0000025f1ca8ab40 \u003cLastAccessed\u003ek__BackingField\r\n00007ff7f8d95230  4000007       10 ...Private.CoreLib]]  0   static 0000000000000000 ExpirationCallback\r\n```\r\n\r\nThere are 5 nullable valuetype fields (_absoluteExpirationRelativeToNow, _slidingExpiration, _size, AbsoluteExpiration, and LastAccessed). Each of those fields adds a single bit to store the Nullable.HasValue state and that bit gets padded out to 8 bytes to preserve the type alignment requirements. Moving those bits to the _state field would save 5*8 = 40 bytes per entry.\r\n\r\nThere are 2 DateTimeOffset fields (LastAccessed and AbsoluteExpiration). DateTimeOffset has an 8 byte ticks value and a 2 byte offset value. The 2 byte offset is padded up to 8 bytes to preserve alignment. If the DateTimeOffset will always be reported as a UTC time then the offset is zero and there is no need to store it. We could instead store an 8 byte DateTime and convert it to a DateTimeOffset when it is accessed if needed. If it is important for users to be able to round trip a non-zero offset in AbsoluteExpiration those two bytes could still be stored separately in a location that won\u0027t be padded.\r\n\r\nThe lazy allocation pattern being used for _tokens could be extended to store other uncommon data, for example rename the CacheEntryTokens type to be UncommonCacheEntryFields. We could move the _previous field into the uncommon set saving another 8 bytes. If it is rare for users to set both the _slidingExpiration and AbsoluteExpiration a single TimeSpan field could be used for both with a bit from _state used to store which one is present. If both are used simultaneously the 2nd field can be stored in the uncommon data. 8-16 more bytes savable here with the tradeoff that anyone who does use those fields will have more memory usage.\r\n\r\nThe _cache field could also be removable if we stored that object reference in the same field as the current _tokens reference and use a bit from state to discriminate which one is there. If the uncommon fields are ever needed then the _cache field has to be copied into the uncommon state at that point.\r\n\r\nThe size field could be changed to a 2 byte value within the state structure and if the full 8 bytes are needed then use the uncommon fields.\r\n\r\nI haven\u0027t vetted carefully, but if everything here panned out it should save 88 bytes per entry.",
                                           "updatedAt":  "2022-04-20T10:56:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Bys4Q",
                                           "createdAt":  "2022-04-20T11:10:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCZBeqA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pentp",
                                                                               "createdAt":  "2022-04-21T08:01:37Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "@noahfalk, have you looked at https://github.com/dotnet/runtime/pull/59110? ",
                                           "updatedAt":  "2022-04-20T11:10:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Byvx6",
                                           "createdAt":  "2022-04-20T11:25:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "I wasn\u0027t aware of it, I only knew of this one because Adam pointed me here : ) Now I am taking a look...",
                                           "updatedAt":  "2022-04-20T11:25:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ByxTR",
                                           "createdAt":  "2022-04-20T11:33:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "#59110 looks like it does the first 2 of the 5 size optimizations, nice : )",
                                           "updatedAt":  "2022-04-20T11:33:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Jq9rQ",
                                           "createdAt":  "2022-09-03T00:25:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AraHaan",
                                           "body":  "I think a Timer that can accept an DateTimeOffset / DateTime would be great for this (aka is based on those types) and not like the ones in: System.Timers.Timer and System.Threading.Timer.\r\n\r\nLikewise I do have need to patch https://github.com/dotnet/runtime/blob/main/src/libraries/System.ComponentModel.TypeConverter/src/System/Timers/Timer.cs to max at uint.MaxValue and not int.MaxValue because for example a TimeSpan or DateTimeOffset that differs by 1 month can be a breaking for me (as I do have need for such a thing where I want to run a task only once a month inside of a program of mine).",
                                           "updatedAt":  "2022-09-03T00:28:45Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "Developers observe more efficient expiration checks within MemoryCache",
        "labels":  [
                       "tenet-performance",
                       "area-Extensions-Caching",
                       "User Story",
                       "Priority:3",
                       "Bottom Up Work"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/48567",
        "createdAt":  "2021-02-21T07:55:04Z",
        "number":  48567,
        "author":  "davidfowl",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCvjfew==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "benaadams",
                                            "createdAt":  "2021-02-21T08:19:17Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Tornhoof",
                                            "createdAt":  "2021-02-21T08:43:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "samsosa",
                                            "createdAt":  "2021-02-21T09:38:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pinkfloydx33",
                                            "createdAt":  "2021-02-21T09:48:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "antoniofreire",
                                            "createdAt":  "2021-02-21T17:50:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "adamsitnik",
                                            "createdAt":  "2021-02-25T09:18:05Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AndersMad",
                                            "createdAt":  "2021-02-27T19:51:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "JoeShook",
                                            "createdAt":  "2021-03-03T00:50:09Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "brjohnstmsft",
                                            "createdAt":  "2021-03-17T06:03:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AmrAlSayed0",
                                            "createdAt":  "2021-03-23T00:46:31Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jesperkristensen",
                                            "createdAt":  "2021-04-20T08:00:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "cdonnellytx",
                                            "createdAt":  "2021-05-10T23:07:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mbrookson",
                                            "createdAt":  "2021-05-21T14:17:55Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "grrttedwards",
                                            "createdAt":  "2021-06-01T14:18:52Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Swimburger",
                                            "createdAt":  "2021-06-08T01:50:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "paulomorgado",
                                            "createdAt":  "2021-06-08T06:53:05Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kieranbenton",
                                            "createdAt":  "2021-06-08T07:41:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "arknu",
                                            "createdAt":  "2021-06-08T08:48:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "loraderon",
                                            "createdAt":  "2021-06-08T10:20:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jotatoledo",
                                            "createdAt":  "2021-06-08T19:58:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "KoalaBear84",
                                            "createdAt":  "2021-06-08T19:58:03Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "bbeda",
                                            "createdAt":  "2021-06-09T08:57:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "zawor",
                                            "createdAt":  "2021-06-17T12:06:32Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "chrishawl",
                                            "createdAt":  "2021-06-21T14:57:55Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ericsampson",
                                            "createdAt":  "2021-06-25T13:21:50Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "koheatel",
                                            "createdAt":  "2021-08-05T06:13:42Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kislovs",
                                            "createdAt":  "2021-08-05T06:17:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Dewarrum",
                                            "createdAt":  "2021-08-05T06:19:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "v-borovikov",
                                            "createdAt":  "2021-08-05T06:25:58Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aayjaychan",
                                            "createdAt":  "2021-08-10T05:08:03Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jasper-d",
                                            "createdAt":  "2021-08-11T17:08:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kronic",
                                            "createdAt":  "2021-09-16T19:13:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lippinio",
                                            "createdAt":  "2021-10-18T14:49:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "yufeih",
                                            "createdAt":  "2021-12-10T06:17:31Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "coderdnewbie",
                                            "createdAt":  "2021-12-13T13:38:18Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MarioGruda",
                                            "createdAt":  "2021-12-17T09:38:05Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aromaa",
                                            "createdAt":  "2021-12-24T11:56:50Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "neon-sunset",
                                            "createdAt":  "2022-01-03T11:09:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ankitvijay",
                                            "createdAt":  "2022-01-20T23:08:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "TeraNovell",
                                            "createdAt":  "2022-06-07T12:28:57Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "domi2120",
                                            "createdAt":  "2022-06-07T12:28:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "glen-84",
                                            "createdAt":  "2022-07-15T10:46:42Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "gao-artur",
                                            "createdAt":  "2022-08-07T10:30:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "roozbehid",
                                            "createdAt":  "2022-10-16T16:27:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Jure-BB",
                                            "createdAt":  "2022-11-04T17:28:58Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "0xced",
                                            "createdAt":  "2022-11-17T13:22:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "wrakocy",
                                            "createdAt":  "2022-11-17T18:02:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dylanvdmerwe",
                                            "createdAt":  "2022-12-19T13:13:58Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "splitt3r",
                                            "createdAt":  "2022-12-31T11:18:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "maxreb",
                                            "createdAt":  "2023-04-18T10:54:55Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "avsorokin",
                                            "createdAt":  "2023-06-26T07:02:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "petrzjunior",
                                            "createdAt":  "2023-07-10T15:05:50Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "xeromorph",
                                            "createdAt":  "2023-07-12T16:26:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "LeszekKalibrate",
                                            "createdAt":  "2023-07-19T13:27:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "daniilchervyakov",
                                            "createdAt":  "2023-09-13T13:00:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Arasfon",
                                            "createdAt":  "2023-10-09T00:25:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "BoundedChenn31",
                                            "createdAt":  "2023-10-28T11:45:05Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "aloraman",
                                            "createdAt":  "2023-10-28T11:59:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Aleksey-M",
                                            "createdAt":  "2023-12-01T10:31:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "austinmfb",
                                            "createdAt":  "2023-12-05T17:23:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ebejko",
                                            "createdAt":  "2023-12-19T11:25:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "inson1",
                                            "createdAt":  "2024-01-04T23:20:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "alexsteeel",
                                            "createdAt":  "2024-01-22T14:33:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "angelofb",
                                            "createdAt":  "2024-02-21T20:09:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "HaptelmanovArtem",
                                            "createdAt":  "2024-04-11T12:20:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "0xfeeddeadbeef",
                                            "createdAt":  "2024-04-22T15:58:20Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Reveon",
                                            "createdAt":  "2024-04-26T15:31:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lonix1",
                                            "createdAt":  "2024-06-23T11:53:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "YohanSciubukgian",
                                            "createdAt":  "2024-07-26T09:14:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MikeNicholls",
                                            "createdAt":  "2024-08-09T03:39:33Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Measurity",
                                            "createdAt":  "2024-08-19T12:29:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "joergmetzler",
                                            "createdAt":  "2025-07-15T18:29:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lvde0",
                                            "createdAt":  "2025-08-18T13:57:52Z"
                                        }
                                    ],
                          "totalCount":  73
                      },
        "updatedAt":  "2023-12-07T16:55:44Z",
        "body":  "## Background and Motivation\r\n\r\nThe MemoryCache implementation and interface leaves much to be desired. At the core of it, we ideally want to expose something more akin to `ConcurrentDictionary\u003cTKey, TValue\u003e` that supports expiration and can handle memory pressure. What we have right now has issues:\r\n- ICacheEntry uses an unintuitive pattern for adding new entries (https://github.com/dotnet/runtime/issues/36556)\r\n- It\u0027s non generic which means it boxes value types (keys and values) (#48455)\r\n- Since there\u0027s no TryAdd, it\u0027s hard to implement GetOrAdd/Async in an extension method in a way that prevents the \"cache stampede problem\" (https://github.com/dotnet/runtime/issues/36499)\r\n- It\u0027s impossible to enumerate keys or entries (https://github.com/dotnet/runtime/issues/36026)\r\n- There\u0027s no way to clear the cache (https://github.com/dotnet/runtime/issues/45593)\r\n\r\n## Proposed API\r\n\r\nThe APIs are still TBD but I\u0027m thinking a generic memory cache.\r\n\r\n```c#\r\nnamespace Microsoft.Extensons.Caching\r\n{\r\n    public class MemoryCache\u003cTKey, TValue\u003e\r\n    {\r\n        public TValue this[TKey key] { get; set; }\r\n        public bool IsEmpty { get; }\r\n        public int Count { get; }\r\n        public ICollection\u003cTKey\u003e Keys { get; }\r\n        public ICollection\u003cTValue\u003e Values { get; }\r\n        public void Clear();\r\n        public bool ContainsKey(TKey key);\r\n        public IEnumerator\u003cKeyValuePair\u003cTKey, TValue\u003e\u003e GetEnumerator();\r\n        public KeyValuePair\u003cTKey, TValue\u003e[] ToArray();\r\n\r\n        public bool TryAdd(TKey key, CacheEntry\u003cTValue\u003e value);\r\n        public bool TryGetValue(TKey key, [MaybeNullWhen(false)] out TValue value);\r\n        public bool TryRemove(TKey key, [MaybeNullWhen(false)] out TValue value);\r\n    }\r\n\r\n    public class CacheEntry\u003cTValue\u003e\r\n    {\r\n        TValue Value { get; set; }\r\n        DateTimeOffset? AbsoluteExpiration { get; set; }\r\n        TimeSpan? AbsoluteExpirationRelativeToNow { get; set; }\r\n        TimeSpan? SlidingExpiration { get; set; }\r\n        IList\u003cIChangeToken\u003e ExpirationTokens { get; }\r\n        IList\u003cPostEvictionCallbackRegistration\u003e PostEvictionCallbacks { get; }\r\n        CacheItemPriority Priority { get; set; }\r\n        long? Size { get; set; }\r\n    }\r\n}\r\n\r\n```\r\n\r\nI\u0027m convinced now that this shouldn\u0027t be an interface or an abstract class but I\u0027m open to discussion.\r\n\r\n## Usage Examples\r\n\r\nTBD\r\n\r\n## Alternative Designs\r\n\r\nTBD\r\n\r\n## Risks\r\n\r\nHaving 3 implementations.\r\n\r\ncc @Tratcher @JunTaoLuo @maryamariyan @eerhardt",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOM8s3Cg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4MjgxNjMzNA==",
                                           "createdAt":  "2021-02-21T07:55:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @eerhardt, @maryamariyan, @michaelgsharp\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n## Background and Motivation\r\n\r\nThe MemoryCache implementation and interface leaves much to be desired. At the core of it, we ideally want to expose something more akin to `ConcurrentDictionary\u003cTKey, TValue\u003e` that supports expiration and can handle memory pressure. What we have right now has issues:\r\n- ICacheEntry uses an unintuitive pattern for adding new entries (https://github.com/dotnet/runtime/issues/36556)\r\n- It\u0027s non generic which means it boxes value types (keys and values)\r\n- Since there\u0027s no TryAdd, it\u0027s hard to implement GetOrAdd/Async in an extension method in a way that prevents the \"cache stampede problem\" (https://github.com/dotnet/runtime/issues/36499)\r\n- It\u0027s impossible to enumerate keys or entries (https://github.com/dotnet/runtime/issues/36026)\r\n- There\u0027s no way to clear the cache (https://github.com/dotnet/runtime/issues/45593)\r\n\r\n## Proposed API\r\n\r\nThe APIs are still TBD but I\u0027m thinking a generic memory cache.\r\n\r\n```C#\r\nnamespace Microsoft.Extensons.Caching\r\n{\r\n    public class IMemoryCache\u003cTKey, TValue\u003e\r\n    {\r\n         // TBD\r\n    }\r\n}\r\n```\r\n\r\n## Usage Examples\r\n\r\nTBD\r\n\r\n## Alternative Designs\r\n\r\nTBD\r\n\r\n## Risks\r\n\r\nHaving 2 implementations.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003edavidfowl\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-Extensions-Caching`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-02-21T07:55:10Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NTc2NTU1NA==",
                                           "createdAt":  "2021-02-25T09:48:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBtyerg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jodydonetti",
                                                                               "createdAt":  "2021-03-30T07:29:32Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "drieseng",
                                                                               "createdAt":  "2021-05-08T10:07:50Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "arknu",
                                                                               "createdAt":  "2021-06-08T08:48:44Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "\u003e It\u0027s non generic which means it boxes value types (keys and values)\r\n\r\nHow is it being typically used by the end-users: to cache multiple instances of the same type or different types? If we make it generic but users end up having more cache instances we might get a memory overhead bigger from just the boxing in the non-generic version.",
                                           "updatedAt":  "2021-02-25T09:48:43Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NTc2OTE0NQ==",
                                           "createdAt":  "2021-02-25T09:54:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBlH86Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "davidfowl",
                                                                               "createdAt":  "2021-02-25T14:59:23Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jodydonetti",
                                                                               "createdAt":  "2021-03-28T17:54:44Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "```cs\r\n        DateTimeOffset? AbsoluteExpiration { get; set; }\r\n        TimeSpan? AbsoluteExpirationRelativeToNow { get; set; }\r\n        TimeSpan? SlidingExpiration { get; set; }\r\n```\r\n\r\nWould it be possible to make these properties have setter only, to keep the internal representation of these fields an implementation detail? So we could for example translate `AbsoluteExpiration ` and `AbsoluteExpirationRelativeToNow ` to ticks like [StackOverflow](https://github.com/dotnet/runtime/issues/45592#issuecomment-741994471) did in their implementation\r\n\r\n```cs\r\n        private long _absoluteExpirationTicks;\r\n        private readonly uint _slidingSeconds;\r\n```\r\n\r\nWe could also take @edevoogd experiment under the consideration:  https://github.com/dotnet/runtime/pull/45842#issuecomment-767931390\r\n\r\n\r\n\r\n",
                                           "updatedAt":  "2021-02-25T09:54:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NTc2OTk0OA==",
                                           "createdAt":  "2021-02-25T09:56:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBlH89A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "davidfowl",
                                                                               "createdAt":  "2021-02-25T14:58:59Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jodydonetti",
                                                                               "createdAt":  "2021-03-28T17:54:58Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "The StackOverflow implementation also introduced an `AccessCount` field to the cache entry: https://github.com/dotnet/runtime/issues/45592#issuecomment-741994471",
                                           "updatedAt":  "2021-02-25T09:56:05Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NTc3MDI2NQ==",
                                           "createdAt":  "2021-02-25T09:56:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBl6DVA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "NickCraver",
                                                                               "createdAt":  "2021-04-04T12:13:45Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "cc @NickCraver @mgravell",
                                           "updatedAt":  "2021-02-25T09:56:40Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NTk2NTcyNQ==",
                                           "createdAt":  "2021-02-25T15:00:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBhYnpg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "adamsitnik",
                                                                               "createdAt":  "2021-02-25T15:21:35Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "\u003e How is it being typically used by the end-users: to cache multiple instances of the same type or different types? If we make it generic but users end up having more cache instances we might get a memory overhead bigger from just the boxing in the non-generic version.\n\nLibraries end up with their own private caches. Apps usually have a single cache.",
                                           "updatedAt":  "2021-02-25T15:00:22Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NzEyODg3Mg==",
                                           "createdAt":  "2021-02-27T20:13:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODOlV_w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "austinmfb",
                                                                               "createdAt":  "2023-12-05T17:24:35Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "AndersMad",
                                           "body":  "**Wish:** Pre- vs. PostEvictionCallbacks (instead of or additional)\r\n\r\n**Short:** Called **before** eviction with an option to skip eviction / keep the cache entry.\r\n\r\n**Long:** Skip could be:\r\n- A way to swap cached value with fresh data e.g. if hit count is high then refresh the data (from callback) instead of removing it and letting first user wait for new. Call should be async as IO is expected. \r\n- Smart extended expiration on the basis of hit count or a state of the current data etc.\r\n\r\nAnd all topic main 👍 !.. That could reduce my code removing reflection to get the main collection etc. + make cache a lot faster with this suggestion. Think the hardest part of cache is estimating the memory. Came here to clone - hope above will be a thing ~:)",
                                           "updatedAt":  "2021-02-27T20:13:48Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NzU4NzM5OA==",
                                           "createdAt":  "2021-03-01T02:13:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "\u003e Short: Called before eviction with an option to skip eviction / keep the cache entry.\r\n\r\nCan you file an issue for this? With details and usage patterns etc.",
                                           "updatedAt":  "2021-03-01T02:13:04Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc5OTcxNzY0Mg==",
                                           "createdAt":  "2021-03-15T20:09:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "alastairtree",
                                           "body":  "There is a long running discussion on why I have not implemented Clear() in LazyCache over at https://github.com/alastairtree/LazyCache/issues/67 which largely is due to the use of MemoryCache and it\u0027s current API. If this went ahead I suspect I would rewrite LazyCache to use MemoryCache\u003cTKey, TValue\u003e as David\u0027s proposal would make that much easier.\r\n\r\nWorth considering usage scenarios - are you suggesting one cache per item-type, or one cache per app? Having TValue in the definition would encourage me to have one cache per item-type, which makes doing Clear on all cached data (a common use case) more difficult as there are many caches. Typically up to now apps usually have one cache, with the TValue know at time of Get, but that does cause the boxing issue.\r\n",
                                           "updatedAt":  "2021-03-15T20:10:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc5OTcyNDI0Mw==",
                                           "createdAt":  "2021-03-15T20:20:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOB-_wmw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "roji",
                                                                               "createdAt":  "2021-03-15T22:50:19Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alastairtree",
                                                                               "createdAt":  "2021-03-16T08:55:19Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "zawor",
                                                                               "createdAt":  "2021-06-17T12:09:15Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kronic",
                                                                               "createdAt":  "2021-10-20T01:11:06Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "I think having lots of caches is fine (we basically have this today all over the framework). It\u0027s should be treated like a dictionary with expiration. ",
                                           "updatedAt":  "2021-03-15T20:20:20Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwMjEyNjY4MA==",
                                           "createdAt":  "2021-03-18T17:08:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODOlWVA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "geeknoid",
                                                                               "createdAt":  "2021-06-04T12:50:44Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hammypants",
                                                                               "createdAt":  "2021-06-08T03:01:02Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "zacatkogan",
                                                                               "createdAt":  "2021-06-08T06:38:58Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "HurricanKai",
                                                                               "createdAt":  "2021-06-08T08:12:05Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "falvarez1",
                                                                               "createdAt":  "2022-09-20T22:33:39Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "austinmfb",
                                                                               "createdAt":  "2023-12-05T17:25:17Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  6
                                                         },
                                           "author":  "JoeShook",
                                           "body":  "I would like to see cache hit and cache miss EventCounters per cache.  I want to be able to capture metrics in something like InfluxDb.  And filter the cache name as a Tag and the cache-hit/cache-miss as a field.  \r\n\r\nToday I am experimenting with LazyCache and adding metrics.  I found with my strategy of collecting counters by cache name it becomes a dynamic process of adding counters as they are called rather than knowing the cache names ahead of time and then having to create a specific EventSource for every application.  At the moment I have not reached my destination with LazyCache and many named caches, but the point is I would hope some thought would be put towards metrics or at least hooks to allow metrics to be plugged in.  \r\n\r\nLooking around the .NET ecosystem in relation to resiliency frameworks, hooks for metrics don\u0027t seem to be a consideration.  Like looking at Polly, metrics are absent and not easy to add.       \r\n",
                                           "updatedAt":  "2021-03-18T17:08:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwODk0Mjk3NA==",
                                           "createdAt":  "2021-03-28T19:02:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBtygMw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "marklagendijk",
                                                                               "createdAt":  "2021-04-26T08:02:28Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hammypants",
                                                                               "createdAt":  "2021-06-08T03:09:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "arknu",
                                                                               "createdAt":  "2021-06-08T08:50:54Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "jodydonetti",
                                           "body":  "My 2 cents:\r\n\r\n- 👍 for a `Clear()` method, is something requested a lot by cache users\r\n\r\n- I\u0027ve very rarely seen a cache used with only one cache-wide specific TValue. I understand the boxing concerns, but the fixed TValue to me does not have a real-world usage. On the contrary, to then support that scenario I can imagine people coming up with higher level abstractions with separate lower level caches per type, but that would make the perf concerns about boxing basically evaporate VS having multiple caches, on top of having potential problems coordinating the different caches for high level operations (like the `Clear()` above)\r\n\r\n- I agree with @adamsitnik with having only one **actual** field with the expiration, but have a different design proposal: instead of having set-only props (which would make reading the expiration prob impossible) we may have a `DateTimeOffset? AbsoluteExpiration { get; set; }` and 2 set methods `SetAbsoluteExpiration(DateTimeOffset)` and `SetAbsoluteExpiration(TimeSpan)` which would both write to the same place\r\n\r\n- in my experience the `long? Size` prop have created a lot of issues: if a `SizeLimit` is specified for the cache and a size is not specified for each entry an exception is thrown, which is frequently unexpected. I would either make it not throw in that case or make the `Size` prop non-nullable, aka just a `long` (also less pressure on the stack), with a default value of 1. This would make any entry without a specific size be worth 1 generic unit, which seems reasonable even when specifying a `SizeLimit`\r\n\r\nOne question: what would be the rationale behind the implementation of the GetOrSet/Add via an ext method instead of being a functionality baked in?",
                                           "updatedAt":  "2021-03-29T19:20:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwOTE4MjAzOQ==",
                                           "createdAt":  "2021-03-29T08:28:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "roji",
                                           "body":  "\u003e I\u0027ve never seen a cache used with only one cache-wide specific TValue. I understand the boxing concerns, but the fixed TValue to me does not have a real-world usage.\r\n\r\nThere are ample cases where people cache objects with specific key/value types (similarly to Dictionary). EF Core uses this internally in multiple places (see #48455).",
                                           "updatedAt":  "2021-03-29T08:28:37Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwOTE5NTIwNg==",
                                           "createdAt":  "2021-03-29T08:47:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODM6feA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "adamsitnik",
                                                                               "createdAt":  "2021-03-29T09:25:59Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Turnerj",
                                                                               "createdAt":  "2021-03-30T05:57:39Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hammypants",
                                                                               "createdAt":  "2021-06-08T04:57:11Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "HurricanKai",
                                                                               "createdAt":  "2021-06-08T08:12:57Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ImoutoChan",
                                                                               "createdAt":  "2023-11-17T15:34:08Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  5
                                                         },
                                           "author":  "jodydonetti",
                                           "body":  "\u003e There are ample cases where people cache objects with specific key/value types (similarly to Dictionary). EF Core uses this internally in multiple places (see #48455).\r\n\r\nI see what you are saying, but I think there is a big difference between what could be described as \"a dictionary with an optional expiration logic\" and \"an application cache\", and maybe we are trying to squeeze 2 different concepts into the same abstraction, which may be problematic.\r\n\r\nI can see a partial convergence in the feature set, but imho they should remain separate.\r\n\r\nMaybe the right thing would be to have 2 different types?",
                                           "updatedAt":  "2021-03-29T11:28:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxMDAxMDUzMw==",
                                           "createdAt":  "2021-03-30T08:07:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "\u003e I agree with @adamsitnik with having only one actual field with the expiration, but have a different design proposal: instead of having set-only props (which would make reading the expiration prob impossible) we may have a DateTimeOffset? AbsoluteExpiration { get; set; } and 2 set methods SetAbsoluteExpiration(DateTimeOffset) and SetAbsoluteExpiration(TimeSpan) which would both write to the same place\r\n\r\nSeems fine.\r\n\r\n\u003e in my experience the long? Size prop have created a lot of issues: if a SizeLimit is specified for the cache and a size is not specified for each entry an exception is thrown, which is frequently unexpected. I would either make it not throw in that case or make the Size prop non-nullable, aka just a long (also less pressure on the stack), with a default value of 1. This would make any entry without a specific size be worth 1 generic unit, which seems reasonable even when specifying a SizeLimit\r\n\r\nWe may remove it on this generic cache and instead expose a specialized cache for strings and bytes where the count actually works.\r\n\r\n\u003e One question: what would be the rationale behind the implementation of the GetOrSet/Add via an ext method instead of being a functionality baked in?\r\n\r\nGetOrAdd can be built in but right now our implementation doesn\u0027t work well because we\u0027re missing the right primitives on the IMemoryCache to implement it.",
                                           "updatedAt":  "2021-03-30T08:07:05Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxMzAyNTMwNg==",
                                           "createdAt":  "2021-04-04T12:32:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODOQZyg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kieranbenton",
                                                                               "createdAt":  "2021-06-08T07:42:03Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kapsiR",
                                                                               "createdAt":  "2021-06-08T13:17:10Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nicolasguzca",
                                                                               "createdAt":  "2021-06-09T21:54:07Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jspuij",
                                                                               "createdAt":  "2021-06-21T09:27:01Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "falvarez1",
                                                                               "createdAt":  "2022-09-20T22:40:13Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "markashleybell",
                                                                               "createdAt":  "2023-12-02T08:55:00Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  6
                                                         },
                                           "author":  "NickCraver",
                                           "body":  "Would we consider an `AccessCount` on `CacheEntry\u003cTValue\u003e` here? This has been essential in all our use cases in eliminating a lot of very low (and often zero) usage cache members resulting in less GC work and memory usage peaks. IMO, it\u0027s something fantastic to have at scale and the overhead wouldn\u0027t matter if you weren\u0027t at scale (esp. relative to the current interface-based cache primitives).\r\n\r\nOverall, we found that there is a huge barrier to taking and analyzing a memory dump at scale. However, if we can expose this information in the app with a few tweaks like this it becomes immensely more useful and actionable by far more people.\r\n\r\nFram a practical standpoint, we went from doing memory dumps and using ClrMd in LINQPad or other bits to having views like this live in production any time:\r\n\r\n\u003cimg width=\"1088\" alt=\"Screen Shot 2021-04-04 at 8 22 45 AM\" src=\"https://user-images.githubusercontent.com/454813/113508598-f8c2b700-951e-11eb-86fd-8cc644b32539.png\"\u003e\r\n\r\n\u003cimg width=\"1084\" alt=\"Screen Shot 2021-04-04 at 8 23 12 AM\" src=\"https://user-images.githubusercontent.com/454813/113508606-06783c80-951f-11eb-856d-3ac641b10cd2.png\"\u003e\r\n\r\n\u003cimg width=\"1082\" alt=\"Screen Shot 2021-04-04 at 8 23 37 AM\" src=\"https://user-images.githubusercontent.com/454813/113508616-12fc9500-951f-11eb-9eba-89f77bac6d73.png\"\u003e\r\n\r\n\u003cimg width=\"1083\" alt=\"Screen Shot 2021-04-04 at 8 24 04 AM\" src=\"https://user-images.githubusercontent.com/454813/113508628-23147480-951f-11eb-965a-f41841c83104.png\"\u003e\r\n\r\n\u003cimg width=\"1076\" alt=\"Screen Shot 2021-04-04 at 8 24 27 AM\" src=\"https://user-images.githubusercontent.com/454813/113508646-30c9fa00-951f-11eb-9d24-90f9e08e89df.png\"\u003e\r\n\r\n(apologies for the bad developer UX, but you can see the info!)\r\n\r\nIf anyone\u0027s curious about the last one - it\u0027s the death by a thousand papercuts, we\u0027ve found it very useful to just crawl the cache and dump some random entries to see any surprises. The `*` are also configured patterns in code of anything common we know about, basically collapsing anything with a list of known prefixes there but really any name translation and collapse could happen far outside the primitives as long as we could enumerate the cache.\r\n\r\nIdeally, whatever primitives we move to here would allow such enumeration without that high \"take a memory dump\" bar. At current, it doesn\u0027t seem possible because:\r\n1. `GetEnumerator()` returns the value directly and so in a full enumeration the `CacheEntry\u003cTValue\u003e` and any properties wouldn\u0027t be accessible.\r\n2. `CacheEntry\u003cTValue\u003e` doesn\u0027t have an access/usage count.",
                                           "updatedAt":  "2021-04-04T12:32:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxMzA0MTE0OA==",
                                           "createdAt":  "2021-04-04T14:17:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "How would users make sense of which of the many memory caches they should use? Are neither of the existing cache APIs redeemable?",
                                           "updatedAt":  "2021-04-04T14:17:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxMzE4Mjc5MA==",
                                           "createdAt":  "2021-04-05T04:59:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC1lSDw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "bklooste",
                                                                               "createdAt":  "2021-05-28T01:04:40Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kieranbenton",
                                                                               "createdAt":  "2021-06-08T07:42:19Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Hawkwind250",
                                                                               "createdAt":  "2023-02-07T11:22:13Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "\u003e How would users make sense of which of the many memory caches they should use? \r\n\r\nI don\u0027t think this matters. The whole point of this implementation is to be a lightweight concurrent dictionary with expiration that **doesn\u0027t** try to respond to memory pressure and start kicking out entries. That\u0027s the only reason I see to be concerned about having a single cache. The for it to have a global process wide view of the state. That is already not the case today with .NET Core. Applications have different caches with different policies. I think this is no different.\r\n\r\n\u003e Are neither of the existing cache APIs redeemable?\r\n\r\nI don\u0027t think so, but I haven\u0027t given it a fair chance. ",
                                           "updatedAt":  "2021-04-05T04:59:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxMzI2MTM4Mw==",
                                           "createdAt":  "2021-04-05T08:04:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBtwDFg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hammypants",
                                                                               "createdAt":  "2021-06-08T03:03:45Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jodydonetti",
                                           "body":  "\u003e The whole point of this implementation is to be a lightweight concurrent dictionary with expiration that doesn\u0027t try to respond to memory pressure and start kicking out entries.\r\n\r\nThat is what I was talking about: being for a single `TKey` + `TValue` type I see this new type as an addition to our collections toolbelt - just like the new `PriorityQueue` - and not as a new \"cache\", where cache is typically meant imho as an application-wide one, with a non-fixed `TValue`. Also, not kicking out entries automatically _maybe_ means no need for both the `Priority` and ` Size` + `SizeLimit` part.\r\n\r\nThe use case is surely interesting, and I for one would like to have that at my disposal, but calling it the \"new memory cache implementation\" would be potentially misleading: maybe putting it in the `System.Collections.Concurrent` namespace and naming it something like `ConcurrentExpirableDictionary` or `ConcurrentDictionaryWithExpiration` or simply `ExpirableDictionary` would be more aligned with what is already there and users expectations?",
                                           "updatedAt":  "2021-04-05T08:06:01Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxMzM2Mzk1Mw==",
                                           "createdAt":  "2021-04-05T12:14:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBsisdQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "bklooste",
                                                                               "createdAt":  "2021-05-28T01:03:13Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "FYI the current IMemoryCache does the same. To be clear, we already end up with multiple in the app that each have they own policies for eviction.\n\nI hear you in the size limit and generics though. The generics especially encourage more caches in the app itself and might cause confusion in some cases.",
                                           "updatedAt":  "2021-04-05T12:22:08Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxMzk2MDY2OA==",
                                           "createdAt":  "2021-04-06T09:06:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOB0kHgw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jodydonetti",
                                                                               "createdAt":  "2021-04-06T09:25:10Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hammypants",
                                                                               "createdAt":  "2021-06-08T03:04:10Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "geeknoid",
                                                                               "createdAt":  "2021-07-30T17:20:17Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "roji",
                                           "body":  "FWIW in the EF Core usage, query compilation artifacts are being cached (rather than e.g. remote data). So expiration definitely isn\u0027t what we\u0027re looking for (artifacts remain valid forever), but rather a decent LRU which guarantees that memory consumption is capped in case there\u0027s an explosion of queries. Not saying this has to be the same type/problem being discussed here, though.",
                                           "updatedAt":  "2021-04-06T09:06:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxMzk3NTI2OA==",
                                           "createdAt":  "2021-04-06T09:29:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBt310w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "LeaFrock",
                                                                               "createdAt":  "2021-04-06T09:32:56Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "YohanSciubukgian",
                                                                               "createdAt":  "2021-04-06T20:11:38Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "rzepinskip",
                                                                               "createdAt":  "2021-05-07T14:31:53Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hammypants",
                                                                               "createdAt":  "2021-06-08T03:04:21Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "arknu",
                                                                               "createdAt":  "2021-06-08T08:52:31Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Daniel-Svensson",
                                                                               "createdAt":  "2021-06-08T17:24:54Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  6
                                                         },
                                           "author":  "jodydonetti",
                                           "body":  "Yes absolutely: on top of a date-based expiration dictionary, an LRU dictionary is another data structure missing in the BCL that would be really useful and requested a lot by the community (see on stackoverflow \u0026 co).",
                                           "updatedAt":  "2021-04-06T09:29:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgzNDk1MjczOA==",
                                           "createdAt":  "2021-05-08T01:52:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "edevoogd",
                                           "body":  "@adamsitnik, FWIW, I finally found time to write down some [notes and performance measurements](https://github.com/edevoogd/ClockQuantization/blob/develop/potential.md) that I collected in the experiment.",
                                           "updatedAt":  "2021-05-08T01:52:51Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1MDA0MDI1Mg==",
                                           "createdAt":  "2021-05-28T01:06:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bklooste",
                                           "body":  "No convenience interface ? \r\n\r\nI agree but there will be a whole round of how do we mock it  questions ?  And to the obvious answer dont , you get but how do we get 100% coverage. \r\n",
                                           "updatedAt":  "2021-05-28T01:06:47Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NDcwMjIxNA==",
                                           "createdAt":  "2021-06-04T12:52:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geeknoid",
                                           "body":  "\u003e * I\u0027ve very rarely seen a cache used with only one cache-wide specific TValue. I understand the boxing concerns, but the fixed TValue to me does not have a real-world usage. On the contrary, to then support that scenario I can imagine people coming up with higher level abstractions with separate lower level caches per type, but that would make the perf concerns about boxing basically evaporate VS having multiple caches, on top of having potential problems coordinating the different caches for high level operations (like the `Clear()` above)\r\n\r\nYou can always make TValue of type object, right?",
                                           "updatedAt":  "2021-06-04T12:52:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NDcwOTU0NA==",
                                           "createdAt":  "2021-06-04T13:05:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geeknoid",
                                           "body":  "Couple thoughts:\r\n\r\n* I don\u0027t recall seeing a scenario where I want to be able to enumerate the content of a cache. I think implementing GetEnumerator, Keys, Values, ToArray correctly can have a substantial impact on the complexity of the implementation and more importantly on the efficiency of the implementation. I would remove this functionality from the design.\r\n\r\n* I find that workloads generally underreports cache efficiency, partly because caches make it hard to do so. As such, I  think it would be great if the cache kept track of total number of reads, total number of writes, total number of hits.\r\n\r\n* Why not make this an interface?\r\n\r\n* Are you proposing that eviction strictly be based on expiration time? That seems unwise from a resilience perspective. Since you\u0027re keeping track of cache entry size, I think eviction should also be driven by max cache size. This is cheap and makes it so an app developer can decide how much memory to dedicate to X data vs. Y data. And these sizes can be tuned, either dynamically or statically, based on the observed cache hit rate I mentioned above.",
                                           "updatedAt":  "2021-06-04T13:05:10Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NDczMTQxNA==",
                                           "createdAt":  "2021-06-04T13:39:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jodydonetti",
                                           "body":  "\u003e You can always make TValue of type object, right?\r\n\r\nFrom a technical point of view yes, sure, it would work. But the developer experience of using it would be bad imho, because you would then have something like `Get(key)` which would always return an `object` that you would need to manually convert to your needed type.\r\n\r\nObviously you may solve that with some extension methods on the type \"cache of object\" type but it should also take into account the generic part of TKey so I don\u0027t know if it would be such a good solution 🤷\r\n\r\nMy take is that this new type should be seen as a low level \"concurrent dictionary + expiration\" thing, and it would be a useful new tool on our belt (which would be even usable as a substitute for [this](https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.Caching.Memory/src/MemoryCache.cs#L26) in the `MemoryCache` impl).\r\n\r\nI just don\u0027t see it as the new `MemoryCache` which natively supports multiple types and is mostly (in my exp at least) used as an application-level cache.",
                                           "updatedAt":  "2021-06-04T13:39:02Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NTU0MDU1Mg==",
                                           "createdAt":  "2021-06-07T02:59:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bklooste",
                                           "body":  "I dont think its good to build polymorphism into the cache itself developer experience like always can be done via some extention methods . ",
                                           "updatedAt":  "2021-06-07T02:59:26Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NTU3NjUwNg==",
                                           "createdAt":  "2021-06-07T04:58:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBtljDw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "bklooste",
                                                                               "createdAt":  "2021-06-07T05:25:55Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "OK so lets say the polymorphism isn\u0027t important because of the overhead of the cache entry itself it bigger than small value types. @roji what sort of value types are you storing in the cache today? ",
                                           "updatedAt":  "2021-06-07T04:58:34Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NTU5Mzg1OA==",
                                           "createdAt":  "2021-06-07T05:35:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bklooste",
                                           "body":  "Not Roji but mulitple Value tuple type support  would be really nice and suite the newer more functional style microservices...kind of anoying from an implimentation point of view and there is always the option of multiple caches. \r\n\r\nI sometimes store tagged unions  in caches eg \r\n\r\nTUnion (T) :TUnion\r\n{\r\nstring type \r\nT value; \r\n}\r\n\r\nesp other languages but C# AFAIK doesnt have a nice way of handling multiple T types without going to polymorphism or  (box) reference type with type to value code.   ",
                                           "updatedAt":  "2021-06-07T05:35:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NTY0NTg4MA==",
                                           "createdAt":  "2021-06-07T06:55:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBtvt3Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "bklooste",
                                                                               "createdAt":  "2021-06-08T01:56:22Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "I\u0027m not sure how that would work with a generic without preserving that generic argument in the `CacheEntry\u003cT\u003e`. The only thing you could do beyond that is hardcode a fixed set of types e.g. https://github.com/dotnet/runtime/issues/28882.",
                                           "updatedAt":  "2021-06-07T06:55:53Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NjIwODY4NA==",
                                           "createdAt":  "2021-06-07T19:47:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBtx4NQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "roji",
                                                                               "createdAt":  "2021-06-08T07:55:15Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "geeknoid",
                                           "body":  "I really don\u0027t see the need for anything beyond a class generic abstraction. With the types defined above, you can do:\r\n\r\nMemoryCache\u003cstring, MyType\u003e  - strongly typed\r\nMemoryCache\u003cstring, IMyInterface\u003e - strongly-typed with polymorphism \r\nMemoryCache\u003cstring, object\u003e - untyped, fully polymorphic\r\n\r\nFor most of the scenarios I\u0027m familiar with, a strongly typed model is what I want. I can get different cache hit stats for different types of data, I can control cache sizing independently, etc.",
                                           "updatedAt":  "2021-06-07T19:47:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NjM0NTM3Mg==",
                                           "createdAt":  "2021-06-08T00:15:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODOQZ3A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "sps014",
                                                                               "createdAt":  "2021-06-08T16:24:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ericsampson",
                                                                               "createdAt":  "2021-06-25T16:25:35Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "glen-84",
                                                                               "createdAt":  "2022-07-15T10:54:07Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "markashleybell",
                                                                               "createdAt":  "2023-12-02T08:56:12Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "NickCraver",
                                           "body":  "Do we think that a cache per type is something that scales well? I know where I\u0027m at we have hundreds of types in cache, generally we\u0027re using `.Get\u003cT\u003e`, or `.Set\u003cT\u003e` and object underneath the covers. Managing `n` caches in pretty much every form seems like a very onerous thing for users to take on. How do you handle eviction when low on memory? Max capacity of any of them? Do we have expiration timers and iterators for each?\r\n\r\nI\u0027m overall wondering what the use cases are for a cache-per-type in general. In my experience thus far, that\u0027s a very niche thing and not worth the overhead (of managing many) vs. generic accessors...but maybe there are big use cases in specific areas where this makes a lot of sense. Can anyone expound on some of the cases this aims to cover? I don\u0027t doubt they exist, only very curious what they are, and if their volume justifies adding a cache with that base type structure.",
                                           "updatedAt":  "2021-06-08T00:15:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NjM0NzQyMg==",
                                           "createdAt":  "2021-06-08T00:21:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "\u003e How do you handle eviction when low on memory? Max capacity of any of them? \r\n\r\nThis isn\u0027t even supported in the memory cache today.",
                                           "updatedAt":  "2021-06-08T00:21:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NjM2ODYzMw==",
                                           "createdAt":  "2021-06-08T01:24:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODL745Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "markjbrown",
                                                                               "createdAt":  "2021-06-08T01:29:48Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kevin-montrose",
                                                                               "createdAt":  "2021-06-08T01:32:33Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jdalley",
                                                                               "createdAt":  "2021-06-08T01:38:51Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jeffpapp",
                                                                               "createdAt":  "2021-06-08T01:39:02Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "RichiCoder1",
                                                                               "createdAt":  "2021-06-08T01:48:32Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "RandyPJ",
                                                                               "createdAt":  "2021-06-08T01:54:18Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "gpshonik",
                                                                               "createdAt":  "2021-06-08T02:26:27Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hammypants",
                                                                               "createdAt":  "2021-06-08T03:06:16Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "georgevanburgh",
                                                                               "createdAt":  "2021-06-08T05:03:29Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "rchamorro",
                                                                               "createdAt":  "2021-06-08T05:31:04Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jrgcubano",
                                                                               "createdAt":  "2021-06-08T05:53:41Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "zacatkogan",
                                                                               "createdAt":  "2021-06-08T06:47:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kieranbenton",
                                                                               "createdAt":  "2021-06-08T07:16:05Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Romanx",
                                                                               "createdAt":  "2021-06-08T08:05:16Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jodydonetti",
                                                                               "createdAt":  "2021-06-08T08:16:55Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "JesperTreetop",
                                                                               "createdAt":  "2021-06-08T08:25:11Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Turnerj",
                                                                               "createdAt":  "2021-06-08T08:43:31Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ldematte",
                                                                               "createdAt":  "2021-06-08T08:48:19Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "arknu",
                                                                               "createdAt":  "2021-06-08T08:54:19Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "slashP",
                                                                               "createdAt":  "2021-06-08T09:27:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Katabrok",
                                                                               "createdAt":  "2021-06-08T09:44:54Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "m-gasser",
                                                                               "createdAt":  "2021-06-08T11:04:13Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kapsiR",
                                                                               "createdAt":  "2021-06-08T13:21:30Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "sps014",
                                                                               "createdAt":  "2021-06-08T16:24:43Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Daniel-Svensson",
                                                                               "createdAt":  "2021-06-08T17:29:18Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "deanmarcussen",
                                                                               "createdAt":  "2021-06-08T17:46:44Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pharring",
                                                                               "createdAt":  "2021-06-08T20:09:37Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "RomanBadiornyi",
                                                                               "createdAt":  "2021-06-08T20:44:06Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "gabi-raducu",
                                                                               "createdAt":  "2021-06-09T08:37:13Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "rokleM",
                                                                               "createdAt":  "2021-06-09T12:47:14Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "StephenCleary",
                                                                               "createdAt":  "2022-01-21T12:19:07Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "celluj34",
                                                                               "createdAt":  "2022-03-11T18:02:23Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "JulienGreen-Acres",
                                                                               "createdAt":  "2023-11-06T22:20:40Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  33
                                                         },
                                           "author":  "NickCraver",
                                           "body":  "\u003e This isn\u0027t even supported in the memory cache today.\r\n\r\nIt\u0027s not _built-in_, but it is doable with the surface area it exposes. The same is true here with the enumerator, but the design encourages managing `n` of them. Whenever you\u0027re adding a new cache of whatever, you\u0027d be in the position of making and managing a new cache. This may work great in niche scenarios where you\u0027re dealing with 1 or a few types, but for most apps I\u0027ve seen that\u0027s not the case - there are many types to cache. _If_ (I\u0027m asking here) that is the majority use case, making `TValue` effectively `object` seems to be an odd design choice.\r\n\r\nTangential to this, one of the major things we do to avoid lock contention at scale is the concept of a stale serve, which may be something to consider either as a base or extension method here. What that looks like (simplified) is:\r\n```cs\r\npublic static T GetSet\u003cT\u003e(this MemoryCache cache, string key, Func\u003cT, T\u003e lookup, TimeSpan duration, TimeSpan serveStaleDuration)\r\n```\r\n\r\nWhat this does is extend a cache (our internal in this case), and for a key, takes a function. This function gets the old value (or `default`, if it doesn\u0027t exist)\tand is tasked with getting the result (e.g. from a database or API or whatever, and in the case of failure, you could return the old value). The `duration` argument is how long this cache is fresh for. The `serveStaleDuration` is how long the cache is additionally served for, past freshness.\r\n\r\nLet\u0027s say we cache for 5 seconds, and serve stale another minute, what would happen on a timeline is:\r\n- `00:00` First hit: `lookup` executed synchronously and returns the value.\r\n- `00:04` Cache fetch `#\u003cwhatever\u003e`: result is a fresh value, no work beyond the fetch\r\n- `00:06` Cache fetch `#\u003cwhatever2\u003e`: result is a stale value, consumer gets the value immediately, but `lookup` is kicked off in the background (taking a lock, based on the key - so only one of these runs at a time). When it finishes, the cache is refreshed and good for `duration` in length, before being stale again.\r\n- `00:08` Cache fetch `#\u003cwhatever3\u003e`: result is a fresh value, from the background lookup above\r\n\r\nThe tradeoff here is that we\u0027re serving a cache that might be a tad stale to some users, but we don\u0027t fall off a cliff and have many threads trying to get a value or block of getting a value when the cache expires. Instead, for that duration we serve the value a bit past freshness while exactly one instance of `lookup` goes off and gets a fresher value.\r\n\r\nBehind the scenes, what\u0027s actually cached is a `GetSetWrapper\u003cT\u003e` which contains a `DateTime StaleAfter` and a `T Data`. That object is cached for the fresh + stale duration combined since that\u0027s the total efficacy.\r\n\r\nWe have a similar version that\u0027s `.GetSetAsync\u003cT\u003e` as well.\r\n\r\nI\u0027m not sure if that\u0027s germane to this design conversation, but I thought I\u0027d bring it up because it\u0027s something we use a _lot_ at Stack Overflow - it\u0027s our go-to for hot paths so that we don\u0027t have a task/thread pile-up when critical caches expire in the app, nor do we go beat the crap out of the data source at the same time. It would be awesome, if this is desirable, to support such an extension method at least on whatever data structure is designed here. In our current world, it\u0027s ultimately using `object` and converting on the fetch. If you were to re-use a key with a different type...nothing good would happen.\r\n\r\nApologies if that\u0027s way off the goals here, just thought I\u0027d bring it up somewhere possibly relevant since it\u0027s been a great approach to us internally.",
                                           "updatedAt":  "2021-06-08T01:39:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NjM4NDcyMw==",
                                           "createdAt":  "2021-06-08T02:13:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bklooste",
                                           "body":  "\"it is doable with the surface area it exposes\" \r\n\r\nIts the interface here that is key ..  and a KISS memory cache now is better than a promised one with memory pressure that never arrives.   You also quickly get into IDistributeCache\r\n\r\nYou can have a per type interface on a  more complex cache with memory pressure in the future. \r\n\r\n\r\n\r\n",
                                           "updatedAt":  "2021-06-08T02:13:55Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NjUzNjMwMA==",
                                           "createdAt":  "2021-06-08T07:40:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kieranbenton",
                                           "body":  "I\u0027ve always had this pattern described to me as \"dog piling protection\". \r\n\r\nWe do something very similar, but in a slightly different manner as we tier caches (per request, in memory and redis) depending on a policy for individual keys. \r\n\r\nInstead of extending the timeout when serving the stale request, we actually extend the true cache timeout at SET time and store a wrapper data structure within the cache value that has the \u0027soft\u0027 expiry and \u0027is regenerating\u0027 flags that are checked on GET.\r\n\r\nProbably not that memory efficient as it adds two extra fields to the entry and requires an additional comparison on each get, but it massively simplifies the tiering logic. ",
                                           "updatedAt":  "2021-06-08T07:40:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NjU1MTIyOQ==",
                                           "createdAt":  "2021-06-08T08:02:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "roji",
                                           "body":  "@davidfowl \r\n\r\n\u003e @roji what sort of value types are you storing in the cache today?\r\n\r\nEF Core has various places where a struct key is used, pointing to various other heavy objects which are traversed as part of the lookup (e.g. [here](https://github.com/dotnet/efcore/blob/main/src/EFCore/Query/CompiledQueryCacheKeyGenerator.cs#L78), [here](https://github.com/dotnet/efcore/blob/main/src/EFCore.Relational/Query/Internal/RelationalCommandCache.cs#L120)). Note that again that we\u0027re not interested in expiration-based eviction (entries stay valid for over), only for capping memory usage if a lot of values are getting inserted into the cache (because tons of different queries are being executed).\r\n\r\n@NickCraver \r\n\u003e If (I\u0027m asking here) that is the majority use case, making TValue effectively object seems to be an odd design choice.\r\n\r\nWhat are we concretely losing by making this generic? If a single, application-wide heterogeneous cache is what you want, you can do that (with TValue being an object). People who want separate caches for whatever reasons can do their thing by specifying a specific TValue. It basically feels like there\u0027s no downside to it, no?",
                                           "updatedAt":  "2021-06-08T08:02:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NjU3MDg3OA==",
                                           "createdAt":  "2021-06-08T08:29:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jodydonetti",
                                           "body":  "In my oss lib [FusionCache](https://github.com/jodydonetti/ZiggyCreatures.FusionCache/) (shameless plug) I do kind of the same  thing as @NickCraver or @kieranbenton, that is serving stale data in case bad things happen (a refresh fails, takes too much, etc): it is a very useful approach and saves a ton of errors in the face of end users when the infrastructure is having a bad day.\r\nBut honestly I don\u0027t know if putting something like that into a core api is the way to go.\r\n\r\nps: sorry if the shameless plug is undesired, if that is the case please remove my comment.",
                                           "updatedAt":  "2021-06-08T08:29:40Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NjU4NTk5Nw==",
                                           "createdAt":  "2021-06-08T08:50:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOB0kKAQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "arknu",
                                                                               "createdAt":  "2021-06-08T08:55:16Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Turnerj",
                                                                               "createdAt":  "2021-06-08T09:01:05Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pharring",
                                                                               "createdAt":  "2021-06-08T20:12:17Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "zawor",
                                                                               "createdAt":  "2021-06-18T08:18:41Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ericsampson",
                                                                               "createdAt":  "2021-06-25T16:26:21Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "geeknoid",
                                                                               "createdAt":  "2021-07-30T17:25:02Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  6
                                                         },
                                           "author":  "jodydonetti",
                                           "body":  "In general I think we\u0027re circling around this: there are imho 2 **different** use cases, and trying to crunch them into 1 api design may not be the best thing.\r\n\r\n### 2 different use cases\r\n\r\nThe first is _“I need to cache some objs of a certain specific type and *I* will access it”_ and these caches are typically created locally, via new, and nobody except my code will access it. It\u0027s more of a low level thing.\r\n\r\nThe second is more of an app-wide, shared, typically singleton (think DI registration) cache that is used across an application by a lot of different pieces of code, not \"owned\" by someone in particular.\r\n\r\nToday the first is typically done with a [concurrent] dict or similar, but is lacking some sort of expiration/lru logic.\r\nThe second is done via the old ObjectCache or the new MemoryCache, and is more heavyweight.\r\n\r\nIf you try to use the MemoryCache for the first case, you are worried about boxing and some useless extra features.\r\nIf you use dict for the second case, well, that is not really doable because it\u0027s too low level and is missing a lot of functionality.\r\n\r\nIt may **seem** like they are the same thing but they are actually not, and I think the confusion comes from the word itself, \"cache\", because it is both a **general practice** that can be even implemented with a simple static class and some init code w/ a lock, no expiration and extra bells and whistles (think \"I save this piece of data here for faster reuse later\") and a **type of service** tyipically shared between different parts of an application.\r\n\r\n### Lifetime and instance creation\r\n\r\nI\u0027ll add an additional thing which may be helpful to reason about.\r\nAs we all know DI is the official \"way to go\" right? And how is MemoryCache registered? Yep, as a [singleton](https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.Caching.Memory/src/MemoryCacheServiceCollectionExtensions.cs#L30), meaning it is expected to be used in a shared way accross the entire application, and that falls into the second use case above.\r\nBut when we look at how a \"local cache\" is used, that is typically not requested globally to the system via DI but is created and managed locally.\r\n\r\nOpinions?",
                                           "updatedAt":  "2021-06-08T09:31:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NjU5NTcxNQ==",
                                           "createdAt":  "2021-06-08T09:04:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "paulomorgado",
                                           "body":  "@NickCraver, doesn\u0027t having a single cache, usually with a `string` key, cause the creation of lots of `string`s just for indexing the cache?",
                                           "updatedAt":  "2021-06-08T09:04:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NzM2NjI1MQ==",
                                           "createdAt":  "2021-06-09T04:38:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bklooste",
                                           "body":  "@jodydonetti  I think using a cache in the first form  is really rare , normally you would just use a dictionary (ToDictionary)  or hashset. sometimes a concurrent dictiionary.  esp since the add normally require long lived life times and external IO. \r\n\r\nThe 2nd case is nearly all use cases and in this case whethere its IOC ( note NOT DI ) or not is irrelevant a console app , azure / lamda function or micro service with a global cache is the same as a larger app managed by an IOC container.  The key thing both are app lifetime scoped .\r\n\r\n ",
                                           "updatedAt":  "2021-06-09T04:38:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NzQxNTQxMQ==",
                                           "createdAt":  "2021-06-09T06:20:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bklooste",
                                           "body":  "@paulomorgado  strings are not normally big compared to value and if you want tiny objects as a consumer your better of using the hash as a key . \r\n\r\nI have some implimentations use the hash internally but its best done by the caller.   ",
                                           "updatedAt":  "2021-06-09T06:20:35Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NzUxMjgxNQ==",
                                           "createdAt":  "2021-06-09T08:50:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBt-bPQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Turnerj",
                                                                               "createdAt":  "2021-06-09T09:12:55Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jodydonetti",
                                           "body":  "\u003e @jodydonetti I think using a cache in the first form is really rare , normally you would just use a dictionary (ToDictionary) or hashset. sometimes a concurrent dictiionary. esp since the add normally require long lived life times and external IO.\r\n\r\nExactly, you would use something lower level (like a dict, etc) \"to cache some data\" and not \"as a cache service\", that was my point.\r\nBut as it turns out people who need a \"dict + date-based expiration\" or \"dict + size-based compaction\" end up using the MemoryCache because it has those features, like @roji in EFCore (if I understood correctly).\r\nThis new type may fit that space, so that would be in fact not a \"cache service\" but a pumped up dict.\r\n\r\n\r\n\u003e The 2nd case is nearly all use cases and in this case whethere its IOC ( note NOT DI ) or not is irrelevant a console app , azure / lamda function or micro service with a global cache is the same as a larger app managed by an IOC container. The key thing both are app lifetime scoped .\r\n\r\nYep, I agree. And since in those use cases we are talking about something that is app-lifetime-scoped and shared (eg: typically singleton), that would be a \"cache service\" shared accross the entire app, and that means a single TValue is probably not what\u0027s needed, at least to me.\r\n\r\nAgain, I think the main point of confusion and the big difference is between \"a low level component to cache some data that can expire/be evicted in some way\" (eg: a smarter dict or similar) and \"a shared app-wide cache service\". Both are useful, just different in scope and design.\r\n\r\nIf I misunderstood you let me know.",
                                           "updatedAt":  "2021-06-09T14:59:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1Nzg1NjU0MA==",
                                           "createdAt":  "2021-06-09T16:38:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "paulomorgado",
                                           "body":  "@bklooste,\r\n\r\n\u003e strings are not normally big compared to value and if you want tiny objects as a consumer your better of using the hash as a key .\r\n\r\nIt\u0027s mostly not about the length of the strings but the number of times you have to compute them and allocate them. That\u0027s CPU comsumtion to compute the key and memory and GC work to allocate/deallocate them.\r\n\r\n\u003e I have some implimentations use the hash internally but its best done by the caller.\r\n\r\nBeware that different strings might have the same hash code.\r\n\r\n",
                                           "updatedAt":  "2021-06-09T16:38:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1ODEwMjg1MQ==",
                                           "createdAt":  "2021-06-09T21:08:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "Given that memory pressure based eviction seems to be an explicit non-goal here, I guess unloading is also a non-goal. But I wanted to make sure it\u0027s considered. It\u0027s another example of an eviction policy, but one which should be typically combined with some other eviction policy and almost never used on its own.\r\n\r\nWhat I mean by unloading is making sure that all entries which have references to an `AssemblyLoadContext` which is being unloaded are evicted (the trigger would be the `AssemblyLoadContext.Unloading` event in this case).\r\n\r\nI\u0027m sure it\u0027s possible to build this on top, but then it becomes a question of how to make all the libraries in the app implement these additional eviction policies so that the app works as a whole (and for example can successfully unload a plugin).",
                                           "updatedAt":  "2021-06-09T21:08:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1OTE1MzQxNw==",
                                           "createdAt":  "2021-06-10T23:31:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBuW3iA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jodydonetti",
                                                                               "createdAt":  "2021-06-11T12:11:23Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "NickCraver",
                                           "body":  "\u003e @NickCraver, doesn\u0027t having a single cache, usually with a string key, cause the creation of lots of strings just for indexing the cache?\r\n\r\nYep, for lack of a better option generally. It\u0027s also very fast though, for example you could cache based on the hash of a tuple or something, but since that would be _on fetch_ there is a computational cost to it. Is that cheaper than the GC cost? I\u0027m not sure, but it\u0027s an interesting experiment to try at scale. Most alternatives I\u0027m aware of have similar risks of hash collision if that\u0027s your lookup model, though. I\u0027m all ears for better options - strings are simple, easy to understand, and fairly cheap to compute (though you deal with cost later) - that\u0027s not an argument for them over other things, it just places them high on the usability tradeoff scale today.",
                                           "updatedAt":  "2021-06-10T23:31:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2MDMwOTczNA==",
                                           "createdAt":  "2021-06-14T01:25:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBuj4xQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jodydonetti",
                                                                               "createdAt":  "2021-06-14T08:19:55Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "bklooste",
                                                                               "createdAt":  "2021-06-14T11:17:17Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "NickCraver",
                                           "body":  "For what it\u0027s worth, I always thought a model that allow caching via a tuple with minimum allocations might be interesting, but I\u0027m not sure how we address the collision issue or exactly what the interface for such could look like in the current type system. If you had `n` caches that approach works, but becomes a `n` caches management problem (at least, we\u0027d have hundreds of caches at a minimum). \r\n\r\nIf we could have a cache that internally was exposed like (these arguments being a _completely_ arbitrary example):\r\n```cs\r\npublic MyCachedType Get(int userId, int categoryId)\r\n{\r\n    var key = (\"SomeUniqueKey\", userId, category); // Tuple here for cache key\r\n    // ...something...\r\n}\r\n```\r\n\r\nToday, we\u0027d do something like:\r\n```cs\r\npublic MyCachedType Get(int userId, int categoryId)\r\n{\r\n    var key = $\"SomeUniquePattern:{userId.ToString()}:{categoryId.ToString()}\";\r\n    // ...something...\r\n}\r\n```\r\n(so that it\u0027s using `string.Concat` in the end)\r\n\r\n...anyway, I think that\u0027d potentially be useful, but would want a shared cache for such a variant key pattern. The return type from cache would likely be `object` and casted still, as we do today.",
                                           "updatedAt":  "2021-06-14T01:25:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2ODg1NzAwNg==",
                                           "createdAt":  "2021-06-25T22:07:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODO4PcA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "zawor",
                                                                               "createdAt":  "2021-06-26T06:20:30Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Jure-BB",
                                                                               "createdAt":  "2022-11-04T17:30:13Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "austinmfb",
                                                                               "createdAt":  "2023-12-07T20:55:07Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "ericsampson",
                                           "body":  "It seems to me like there are two quite different usecases that people are looking for, and that a) trying to address both in one design might lead to a compromise, and b) the current discussion/proposal seems to lean more heavily towards the \"ConcurrentDictionary with expiration, caching objects with key/value types, N caches\" scenario. \r\nThe other scenario being more the \"application cache, one per app, key is often a string currently but maybe a tuple could work well, often used to cache things like API bearer tokens\"\r\n\r\nShould there be a separate proposal/interface for the latter application-cache usecase? To prevent the design from getting muddled between the two different needs.\r\nFor instance, in this case as David points out by referring to [https://github.com/dotnet/runtime/issues/36499], people get bit by not realizing the fact that the factory in `GetOrCreate*` is not re-entrant-proof, which matters when you\u0027re calling an external API or token endpoint that takes N seconds to respond.\r\nOr another angle to consider for this usecase is if it would be worthwhile to build in the \"serve-stale\" functionality that Nick Craver mentioned, as an extension if desired.\r\n\r\nI just feel like the two usecases are sufficiently different that trying to address both in one API might make things messy.\r\n\r\nCheers!",
                                           "updatedAt":  "2021-06-25T22:07:02Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2ODk1NTkxNA==",
                                           "createdAt":  "2021-06-26T06:23:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Turnerj",
                                           "body":  "One thing to consider is how much should be in the runtime as default. There are several caching libraries in the .NET ecosystem (FusionCache, CacheManager, Cache Tower, EasyCaching, LazyCache, MonkeyCache, and probably a bunch of others) which can handle the more complicated and feature rich scenarios.\r\n\r\nI am biased as the creator of one of those caching libraries but my view is that it is the simple/common scenario that the MemoryCache implementation should aim for - the `ConcurrentDictionary` with expiration scenario. It should be fast, it should be straight forward and a lot of people should use it, it just shouldn\u0027t be all-encompassing.",
                                           "updatedAt":  "2021-06-26T06:23:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2ODk1NjUyOA==",
                                           "createdAt":  "2021-06-26T06:30:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "zawor",
                                           "body":  "@ericsampson I thnik you nailed here the core of the problem\r\n\r\nWhile from my standpoint, 99% of the cases would be solved by ConcurrentDictionary with expiration as they mainly revolve around small services where I simply don\u0027t want to hammer one particular resource too much with as small overhead as it can be.\r\n\r\nOn the other hand usecase of Nick gives me meme vibes ;)\r\n![image](https://user-images.githubusercontent.com/2988966/123504302-a3e39800-d658-11eb-8809-0804d0993126.png)\r\n",
                                           "updatedAt":  "2021-06-26T06:30:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2OTAxNjUwOQ==",
                                           "createdAt":  "2021-06-26T15:11:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBwRNBA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Turnerj",
                                                                               "createdAt":  "2021-06-26T15:25:22Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "ericsampson",
                                           "body":  "\u003e One thing to consider is how much should be in the runtime as default. There are several caching libraries in the .NET ecosystem (FusionCache, CacheManager, Cache Tower, EasyCaching, LazyCache, MonkeyCache, and probably a bunch of others) which can handle the more complicated and feature rich scenarios.\n\nThat\u0027s a fair point :) If the .NET/ASP docs for caching can list these community packages, that would go a long way. \n\u003e \n\u003e \n\u003e I am biased as the creator of one of those caching libraries but my view is that it is the simple/common scenario that the MemoryCache implementation should aim for - the `ConcurrentDictionary` with expiration scenario. It should be fast, it should be straight forward and a lot of people should use it, it just shouldn\u0027t be all-encompassing.\n\n\"straight forward\" is an important qualifier :) \nMaybe the theoretical MemoryCache extension library could have \n`GetOrAddLazy*`\nalongside the current re-entrant factory version, to help discoverability in the IDE etc. Because that\u0027s the biggest current footgun for people IME. Cheers",
                                           "updatedAt":  "2021-06-26T15:14:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc40y1hA",
                                           "createdAt":  "2021-07-23T16:04:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODVMtzA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hrvoje-grabusic",
                                                                               "createdAt":  "2024-02-02T16:58:06Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "ohroy",
                                           "body":  "+1\r\ncurrent cache is hard to use, the **cache stampede** is very serious problem",
                                           "updatedAt":  "2021-07-23T16:04:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc40y34W",
                                           "createdAt":  "2021-07-23T16:20:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "\u003e current cache is hard to use, the cache stampede is very serious problem\r\n\r\nIts possible to work around manually.",
                                           "updatedAt":  "2021-07-23T16:20:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc40y5QA",
                                           "createdAt":  "2021-07-23T16:29:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODTk_JA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "ohroy",
                                                                               "createdAt":  "2021-07-23T16:33:10Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "davidfowl",
                                                                               "createdAt":  "2021-07-23T17:48:31Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "Turnerj",
                                                                               "createdAt":  "2021-07-24T00:44:42Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "molinch",
                                                                               "createdAt":  "2022-01-20T19:06:30Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "0x25CBFC4F",
                                                                               "createdAt":  "2023-11-17T14:53:22Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "onyxmaster",
                                                                               "createdAt":  "2023-11-17T19:22:25Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "alexsteeel",
                                                                               "createdAt":  "2024-01-22T14:35:26Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  7
                                                         },
                                           "author":  "jodydonetti",
                                           "body":  "\u003e current cache is hard to use, the **cache stampede** is very serious problem\n\nIf you\u0027d like to avoid the cache stampede problem you can take a look at some alternatives (in alphabetical order):\n\n- [CacheTower](https://github.com/TurnerSoftware/CacheTower)\n- [EasyCaching](https://github.com/dotnetcore/EasyCaching)\n- [FusionCache](https://github.com/jodydonetti/ZiggyCreatures.FusionCache) (shameless plug 🙋‍♂️)\n- [LazyCache](https://github.com/alastairtree/LazyCache)\n\nHope this helps.",
                                           "updatedAt":  "2021-07-23T16:29:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc40y5hL",
                                           "createdAt":  "2021-07-23T16:31:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODVMucA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hammypants",
                                                                               "createdAt":  "2022-03-02T22:24:46Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hrvoje-grabusic",
                                                                               "createdAt":  "2024-02-02T16:59:18Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "ohroy",
                                           "body":  "\u003e \u003e current cache is hard to use, the cache stampede is very serious problem\r\n\u003e \r\n\u003e Its possible to work around manually.\r\n\r\nsure, it can work around by lazy and lock etc, but not everyone can realize that it may have the problem of cache stampede , which will lead to serious consequences. \r\nwhatever, it is not easy to use.\r\nI very hope to have a built-in solution , thank you for this proposal\r\n",
                                           "updatedAt":  "2021-07-23T16:31:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48qjCB",
                                           "createdAt":  "2022-01-20T18:16:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "molinch",
                                           "body":  "\u003e \u003e current cache is hard to use, the cache stampede is very serious problem\r\n\u003e \r\n\u003e Its possible to work around manually.\r\n\r\nI know it\u0027s a fairly broad question where implementation may depend on uses cases, but what solution would you suggest when the cache key is dynamic ? (for example when you want to cache fetched user permissions so cache key could be user-17, user-18, ...). Having a `SemaphoreSlim` per key seems complicated and in the long run implies a memory leak. Relying on `Lazy\u003cT\u003e` semantics may work too depending on how the current MemoryCache is implemented.",
                                           "updatedAt":  "2022-01-20T18:17:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48qn0X",
                                           "createdAt":  "2022-01-20T18:38:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jodydonetti",
                                           "body":  "\u003e \u003e \u003e current cache is hard to use, the cache stampede is very serious problem\n\u003e \n\u003e \u003e \n\u003e \n\u003e \u003e Its possible to work around manually.\n\u003e \n\u003e \n\u003e \n\u003e I know it\u0027s a fairly broad question where implementation may depend on uses cases, but what solution would you suggest when the cache key is dynamic ? (for example when you want to cache fetched user permissions so cache key could be user-17, user-18, ...). Having a `SemaphoreSlim` per key seems complicated and in the long run implies a memory leak. Relying on `Lazy\u003cT\u003e` semantics may work too depending on how the current MemoryCache is implemented.\n\nOne of these https://github.com/dotnet/runtime/issues/48567#issuecomment-885756928 ?",
                                           "updatedAt":  "2022-01-20T18:38:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48sUg7",
                                           "createdAt":  "2022-01-21T07:28:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCK9Jjg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jodydonetti",
                                                                               "createdAt":  "2022-01-21T11:04:15Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "molinch",
                                           "body":  "Thanks @jodydonetti, since our need is simply an IMemoryCache without cache stampede issue, nothing more, nothing less. We went with @StephenCleary solution in the end:  https://gist.github.com/StephenCleary/39a2cd0aa3c705a984a4dbbea8275fe9 \r\n\r\nI like this solution, it\u0027s a slim wrapper on top of IMemoryCache and you can easily follow the code.\r\n",
                                           "updatedAt":  "2022-01-21T07:29:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GuYnf",
                                           "createdAt":  "2022-07-17T16:42:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "robertbaumann",
                                           "body":  "Consider something that can be extensible to support [Azure Caching Guidance](https://docs.microsoft.com/en-us/azure/architecture/best-practices/caching)\r\n\r\n- ICache\u003cTKey, TValue\u003e: This is the base interface that would be the dependency for code\r\n  - Has simple Add(TKey, TValue), Remove(TKey), TValue Get(TKey) methods as well as async flavors of those methods to await retrieval from a remote source\r\n  - Concrete implementations for ICache\u003cTKey, TValue\u003e, e.g. MemoryCache, RedisCache\r\n- MemoryCache\u003cTKey, TValue\u003e: Wraps a ConcurrentDictionary\u003cT\u003e with expiration\r\n  - Default expiration policy for cache entries passed in during initialization",
                                           "updatedAt":  "2022-07-17T16:42:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5tOt4I",
                                           "createdAt":  "2023-11-29T19:31:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEeo-tQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "roji",
                                                                               "createdAt":  "2023-11-29T19:34:58Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "Jure-BB",
                                                                               "createdAt":  "2023-11-29T19:54:37Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "jodydonetti",
                                                                               "createdAt":  "2023-11-29T20:09:06Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "paulomorgado",
                                                                               "createdAt":  "2023-11-29T20:34:20Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "neon-sunset",
                                                                               "createdAt":  "2023-12-03T14:47:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "jjnrmason",
                                                                               "createdAt":  "2023-12-19T11:46:28Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "wdolek",
                                                                               "createdAt":  "2024-01-07T21:43:35Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "alexsteeel",
                                                                               "createdAt":  "2024-01-22T14:35:40Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "lvde0",
                                                                               "createdAt":  "2025-08-18T13:58:55Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  9
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "There\u0027s a proposal for a new cache implementation here https://github.com/dotnet/extensions/issues/4766. Can those interested review it and leave comments?",
                                           "updatedAt":  "2023-11-29T19:31:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5tVq7Y",
                                           "createdAt":  "2023-11-30T19:12:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jodydonetti",
                                           "body":  "Thanks David, will do!",
                                           "updatedAt":  "2023-11-30T19:12:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5twC1c",
                                           "createdAt":  "2023-12-05T17:47:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "austinmfb",
                                           "body":  "Interesting that there is no mention of managing cache dependencies in this thread. Not that it would have to be baked into a new cache class, but still seems like a relevant design consideration. Is nobody really using a consistent pattern for this that they want their cache class to handle? Is everyone just opting for inline code in each application component requiring this, and managing its specific set of dependent caches?",
                                           "updatedAt":  "2023-12-05T17:47:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5uAzEB",
                                           "createdAt":  "2023-12-07T16:55:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEhKwgQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "TheCodingOwl",
                                                                               "createdAt":  "2025-09-06T15:48:19Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "JoelDavidLang",
                                           "body":  "\u003e ICacheEntry uses an unintuitive pattern for adding new entries\r\n\r\nI was bitten by this just recently. I did not see any documentation in CreateEntry() nor on ICacheEntry that stated that the object needed to be disposed to commit it to the cache. As a result, the code I initially wrote didn\u0027t have working caching!\r\n\r\nI would like to see this documentation clarified for the current version of the cache at least.",
                                           "updatedAt":  "2023-12-07T16:55:43Z"
                                       }
                                   ],
                         "totalCount":  64
                     },
        "title":  "New memory cache implementation",
        "labels":  [
                       "api-suggestion",
                       "area-Extensions-Caching"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/67770",
        "createdAt":  "2022-04-08T18:11:33Z",
        "number":  67770,
        "author":  "maryamariyan",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-08-08T16:03:27Z",
        "body":  "## Summary\r\n\r\nToday, the user has to write their own metrics retrieval system. By adding built-in metrics, the library could hook into existing list of caches, and publish all stats so it could handle all that user would do otherwise in their code to support multiple caches. To help identify caches, MemoryCache would need a `Name` property to help support the meter scenario.\r\n\r\nWith the built-in metrics the name is shown per memory cache, and the onus is on user to provide a unique name otherwise the library could add a warning and either pick one or update the duplicated name with a warning.\r\n\r\nTo learn more check out [this gist](https://gist.github.com/maryamariyan/1a7c6fbd4b2f065157ac3d92abcaf7ba).\r\n\r\n## Goal\r\n\r\nThis issue helps focus on a good user experience for developers who wish to track statistics for multiple memory caches by having built-in meters added to the library. Today getting statistics for multiple caches is possible but requires developer to write their own meter.\r\n\r\nOur focus here is to add support for cache names, a built-in Meter, and a default naming convention for the cache created by `AddMemoryCache()` in M.E.C (tracked in https://github.com/dotnet/runtime/issues/67769).\r\n\r\n#### NOTE:\r\nThis issue needs to also address https://github.com/dotnet/runtime/issues/67769\r\nFor more information refer to https://github.com/dotnet/runtime/pull/66479#issuecomment-1093157356. \r\n\r\n## What is already available in Preview 4:\r\n\r\n`GetCurrentStatistics()` API (based on https://github.com/dotnet/runtime/issues/50406) allows app developers to use either event counters or metrics APIs to track statistics for one or more memory caches with code snippets. \r\n\r\nWith `IMemoryCache.GetCurrentStatistics()`, the user now has support for the following use cases:\r\n\r\n- One cache with either event counters or metrics APIs\r\n- Multiple caches with metrics API\r\n\r\n### Using `IMemoryCache.GetCurrentStatistics()` for one memory cache\r\n\r\nUse [`AddMemoryCache`](https://apisof.net/catalog/3cb04c03-2845-725f-eebb-1eb7ba5d0515) API to instantiate a single memory cache and via DI get it injected to enable them calling `GetCurrentStatistics`.\r\n\r\n#### Sample usage/screenshot for event counter:\r\n\r\n```c#\r\n// when using `services.AddMemoryCache(options =\u003e options.TrackStatistics = true);` to instantiate\r\n\r\n    [EventSource(Name = \"Microsoft-Extensions-Caching-Memory\")]\r\n    internal sealed class CachingEventSource : EventSource\r\n    {\r\n        public CachingEventSource(IMemoryCache memoryCache) { _memoryCache = memoryCache; }\r\n        protected override void OnEventCommand(EventCommandEventArgs command)\r\n        {\r\n            if (command.Command == EventCommand.Enable)\r\n            {\r\n                if (_cacheHitsCounter == null)\r\n                {\r\n                    _cacheHitsCounter = new PollingCounter(\"cache-hits\", this, () =\u003e\r\n                        _memoryCache.GetCurrentStatistics().CacheHits)\r\n                    {\r\n                        DisplayName = \"Cache hits\",\r\n                    };\r\n                }\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\nHelps them view stats below with `dotnet-counters` tool:\r\n\r\n\u003cimg width=\"400\" alt=\"image\" src=\"https://user-images.githubusercontent.com/5897654/156053460-46db5070-04b0-478c-9013-ab0298a7b1ec.png\"\u003e\r\n\r\n### Using `IMemoryCache.GetCurrentStatistics()` for multiple memory caches\r\n\r\nIn order to get stats for more than one memory cache in the app, the user may use metrics APIs in their own code, so long as they have a way of distinguishing their caches by name or ID:\r\n\r\n#### sample usage/screenshot for multiple caches using metrics APIs\r\n\r\n```cs\r\n Meter s_meter = new Meter(\"Microsoft.Extensions.Caching.Memory.MemoryCache\", \"1.0.0\");\r\n var cacheHitsMetrics = s_meter.CreateObservableGauge\u003cint\u003e(\"cache-hits\", GetCacheHits);\r\n\r\n// metrics callback for cache hits\r\nstatic IEnumerable\u003cMeasurement\u003cint\u003e\u003e GetCacheHits()\r\n{\r\n    return new Measurement\u003cint\u003e[]\r\n    {\r\n            // or measurements could be looped or read from a real queue somewhere:\r\n            new Measurement\u003cint\u003e(mc1.GetCurrentStatistics().CacheHits, new KeyValuePair\u003cstring,object\u003e(\"CacheName\", \"mc1\")),\r\n            new Measurement\u003cint\u003e(mc2.GetCurrentStatistics().CacheHits, new KeyValuePair\u003cstring,object\u003e(\"CacheName\", \"mc2\")),\r\n            new Measurement\u003cint\u003e(mc3.GetCurrentStatistics().CacheHits, new KeyValuePair\u003cstring,object\u003e(\"CacheName\", \"mc3\")),\r\n    };\r\n}\r\n```\r\n\r\nSample stats with `dotnet-counters` tool:\r\n\r\n\u003cimg width=\"539\" alt=\"image\" src=\"https://user-images.githubusercontent.com/5897654/162268060-b0e5751d-143b-4eea-b00f-466729bd6742.png\"\u003e\r\n\r\nEach metrics would need to create its own observable gauge (one for hits, then misses, etc.) and each callback function for the gauge iterates through list of caches creating measurements.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOh6u4zg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5BKDRN",
                                           "createdAt":  "2022-04-08T18:11:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-04-08T18:11:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5BKDS_",
                                           "createdAt":  "2022-04-08T18:11:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-extensions-caching\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nIn the first issue in https://github.com/dotnet/runtime/issues/50406, we added support for adding metrics for `IMemoryCache`, by adding `GetCurrentStatistics()` API.\r\n\r\n`GetCurrentStatistics()` API allows app developers to use either event counters or metrics APIs to track statistics with code snippets illustrated in [this gist](https://gist.github.com/maryamariyan/1a7c6fbd4b2f065157ac3d92abcaf7ba).\r\n\r\nNext we want to focus on having a good user experience for developers who wish to track statistics for multiple memory caches built-in to the library. Today getting statistics for multiple caches is possible but requires developer to write their own meter.\r\n\r\nOur focus here is to add support for cache names, a built-in Meter, and a default naming convention for the cache created by `AddMemoryCache()` in M.E.C (tracked in XXX).\r\n\r\n\r\n\r\n\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003emaryamariyan\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`untriaged`, `area-Extensions-Caching`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-04-08T18:11:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5EsT8K",
                                           "createdAt":  "2022-06-10T15:12:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC-ssxg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "vmandic",
                                                                               "createdAt":  "2023-06-22T11:14:16Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "supertr0n",
                                           "body":  "Some feedback from my recent experimentation in using `IMemoryCache.GetCurrentStatistics` in a Blazor Server app.\r\n\r\nThis may or may not be the best place for this feedback, but I was too slow to comment on #50406 😄 \r\n\r\nI really appreciate the work here to add further metrics for `IMemoryCache`, this is great stuff! \r\n\r\nMy comment is around API naming and the possible need to clearly set expectations in docs/announcements regarding this new feature because I think many developers will wrongly assume what type of value `CurrentEstimatedSize` returns.\r\n\r\nI was rather excited to try out this feature, with the mistaken expectation that `CurrentEstimatedSize` would be returning an estimated size of the cache _in bytes_ rather than the sum of the arbitrary `Size` values that can be assigned when adding items to the cache.\r\n\r\nKnowing that historically it was quite a challenge to calculate an estimation of real world memory usage for the in-memory cache, I was excited at the prospect of finally having a quick way to gauge this!  (My fault for not reading the docs / changes closely enough!)\r\n\r\nIn retrospect, it seems totally understandable that `CurrentEstimatedSize` returns the total of all cache entries `Size` properties.\r\n\r\nHowever, I think there are a couple of issues here which I believe will lead a lot of developers (perhaps _most_) to make the same incorrect assumption as me.\r\n\r\nFirstly the use of \"Estimated\" led me to assume this was a measure of real-world memory usage because it wasn\u0027t initially intuitive to me that you could know the exact deterministic count of cache entries via `CurrentEntryCount` but not also know, at the same point in time, the exact total of the  cache item \"arbitrary\" sizes, so I wrongly assumed from the property name that this would be an estimation of _memory usage._  (Reading further, I do now understand that `CurrentEstimatedSize` is necessarily a lagging measure which may not always be in sync).\r\n\r\nThe second challenge is the use of the terminology `Size` which elsewhere in the framework does often refer to memory usage in bytes.  Eg. `System.Diagnostics.Process` has properties with a `Size` suffix which do in fact return a \"size\" in bytes.\r\n\r\nThe combination of \"estimated\" and \"size\" may lead a lot of developers to assume that this is a memory footprint estimation.  (Perhaps with a dose of wishful thinking driving this too...)\r\n\r\nHaving watched the [code review video](https://www.youtube.com/watch?v=0nixAM-u2Fw) regarding this, where the estimated size property was initially proposed, I noticed that the first assumption by one of the review team was also that this size property, would be a \"bytes\" measurement too.  (Followed by lengthy discussion/clarification about what the \"Size\" terminology actually means in the context of IMemoryCache!).\r\n\r\nLastly, there was a [comment](https://github.com/dotnet/runtime/issues/50406#issuecomment-895584750) in #50406 which suggested the addition of an estimated cache size.  I\u0027m not sure if this was the \"request\" that was mentioned (in the video) to support the addition of `CurrentEstimatedSize` but I think it\u0027s important to note that this comment specifically mentioned \"estimate of the total cache size **in memory**\" (emphasis mine) so I believe this request was also for a memory footprint estimation and not necessarily the arbitrary Size total.\r\n\r\nFor me, in a Blazor Server app, where memory usage is a primary concern and I am working on ways to both effectively monitor and regulate this usage, an estimated measurement of real-world memory usage would have been very useful.  I do also fully understand why this is difficult to achieve.\r\n\r\nIn summary, I think the default assumption for most people, when encountering this property for the first time, (based on all of the above) is that `CurrentEstimatedSize` returns a memory usage estimation in bytes, and the purpose of this comment is just to suggest that any documentation and announcements regarding this new feature (and for any associated counters/meters) should make it very clear up front that this is not the case, just to avoid any potential confusion, unnecessary support questions and mismatch of developer expectations up front!\r\n\r\nHaving said all that, these new metrics are very useful and a great addition, thank you team!\r\n\r\nIf this feedback is best left elsewhere, please do let me know.",
                                           "updatedAt":  "2022-06-10T15:12:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5EyKQU",
                                           "createdAt":  "2022-06-13T14:32:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "eerhardt",
                                           "body":  "Thank you, @basecde, for the feedback!\r\n\r\nDo you happen to have a suggestion that you think would alleviate the problem? Can you think of a better name that would better describe the property?",
                                           "updatedAt":  "2022-06-13T14:32:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5EySqo",
                                           "createdAt":  "2022-06-13T15:00:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "supertr0n",
                                           "body":  "Well, you\u0027ve called my bluff there @eerhardt 😄 \r\n\r\nNo, given the historical context and the fact that we already have `Size` terminology when adding items to the cache, I think `CurrentEstimatedSize` is appropriate.\r\n\r\nOn the assumption that it\u0027s not possible to provide a property with a real memory usage estimate (and I\u0027m guessing it\u0027s not, at least for .NET 7), my concrete suggestion would just be around setting developer expectations carefully in the announcement of this feature for .NET 7 and in accompanying docs.\r\n\r\nSpecifically, calling out (or reminding) potential consumers of this API that the Size in question is the total \"arbitrary Size\" value and not an absolute measurement in bytes.\r\n\r\nI think there is no problem at all here if the potential confusion is anticipated and expectations are set up-front in the docs!\r\n\r\nHere\u0027s a suggested tweak to the [current feature announcement wording](https://github.com/dotnet/core/issues/7378#issuecomment-1108945705):\r\n\r\n**Current version:**\r\n\r\n\u003e For preview 4 we added metrics support for `IMemoryCache`. The main APIs being added for Preview 4 are:\r\n\u003e \r\n\u003e * `MemoryCacheStatistics` which holds cache hit/miss/estimated size and count for `IMemoryCache`\r\n\r\n**Proposed updated version:**\r\n\r\n\u003e For preview 4 we added metrics support for `IMemoryCache`. The main APIs being added for Preview 4 are:\r\n\u003e \r\n\u003e * `MemoryCacheStatistics` which holds totals for `IMemoryCache`, namely; cache hits, misses, item count and estimated cache size (the latter being the sum of each cache item\u0027s Size property)\r\n\r\nIf helpful, I\u0027m happy to make concrete wording suggestions for any proposed docs for this feature too (not sure if these are written yet?)",
                                           "updatedAt":  "2022-06-13T15:03:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5FB8M0",
                                           "createdAt":  "2022-06-16T21:14:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCiYKcQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "noahfalk",
                                                                               "createdAt":  "2022-06-17T06:15:14Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "maryamariyan",
                                           "body":  "@noahfalk @davidfowl as per offline conversation moving this out of 7.0 to first investigate proper design for metrics in DI aware systems in a non static way.",
                                           "updatedAt":  "2022-06-16T21:14:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Hq7jO",
                                           "createdAt":  "2024-08-08T16:03:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "julealgon",
                                           "body":  "This request has been stale for a while. I assume at this point that this won\u0027t hit .NET9 anymore as the window for that has now closed, so this is at least .NET10 timeframe? Or perhaps this is not necessarily tied with the .NET releases since this is all library code inside `Microsoft.Extensions.Caching.Memory`?\r\n\r\nOur team has been struggling a bit with finding optimization opportunities and I stumbled upon this whole memory caching metrics thing after thinking about adding custom metrics to our caches and searching for something native first before doing that.\r\n\r\nI landed on that `MemoryCacheStatistics` class on learn.microsoft and then found this related issue here.\r\n\r\nSo, my take thus far is that there is an idea to provide native metrics from the library itself, but that\u0027s not yet available (basically, this issue here). Thus, in the meantime, the expectation is that consumers would create their own custom instrumentation leveraging the `GetCurrentStatistics` method and observable gauges (using the modern metrics API).\r\n\r\nAssuming we went with our own custom metrics for now, would the team recommend anything in particular? For example, should we consider using a `Meter` with a specific name for future compatibility with the native meters coming up, or should we actively _avoid_ doing that and instead use our own names for the meter? Same question would go for the instrument names and types: would the team recommend using the names mentioned in the samples/linked gist, or would you suggest each implementor come up with their own naming scheme for now?\r\n\r\nThe reasons I ask these questions are of course I want to avoid unnecessary clashing when the \"official\" meters are exposed in case we need something before then, which is looking very likely now that this is seemingly out of scope for v9 of the library.\r\n\r\nI\u0027d also like to know if all of this work also applies to `HybridCache`, since we do intend to switch to that when it goes out of preview I assume in November with the launch of .NET9. I see it has a [`ReportTagMetrics` property](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.caching.hybrid.hybridcacheoptions.reporttagmetrics?view=net-8.0) which I would assume is directly related to this subject, but the interface is not exactly the same as the one for `MemoryCache` which uses `TrackStatistics` instead. Some clarification on this would be very appreciated so we can minimize rework later.",
                                           "updatedAt":  "2024-08-08T16:03:25Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "Allow developers to use built-in meters for tracking stats on caches",
        "labels":  [
                       "api-suggestion",
                       "feature-request",
                       "area-Extensions-Caching"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/72879",
        "createdAt":  "2022-07-26T19:51:56Z",
        "number":  72879,
        "author":  "danmoseley",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-11-15T08:42:30Z",
        "body":  "```\r\nAssert.False() Failure\r\nExpected: False\r\nActual:   True\r\n\r\n\r\nStack trace\r\n   at Microsoft.Extensions.Caching.Memory.MemoryCacheSetAndRemoveTests.GetAndSet_AreThreadSafe_AndUpdatesNeverLeavesNullValues() in /_/src/libraries/Microsoft.Extensions.Caching.Memory/tests/MemoryCacheSetAndRemoveTests.cs:line 588\r\n   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)\r\n   at System.Reflection.MethodInvoker.Invoke(Object obj, IntPtr* args, BindingFlags invokeAttr) in /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodInvoker.cs:line 6\r\n```\r\nnet7.0-Linux-Release-arm-CoreCLR_checked-(Alpine.314.Arm32.Open)Ubuntu.1804.ArmArch.Open@mcr.microsoft.com/dotnet-buildtools/prereqs:alpine-3.14-helix-arm32v7-20210910135806-8a6f4f3\r\n\r\nPerhaps Linux specific? Creating issue so I can reference when disabling.\r\n\u003c!-- runfo report start --\u003e\r\nRunfo Tracking Issue: [GetAndSet_AreThreadSafe_AndUpdatesNeverLeavesNullValues failing](https://runfo.azurewebsites.net/tracking/issue/402)\r\n|Build|Definition|Kind|Run Name|\r\n|---|---|---|---|\r\n\r\n\r\n\r\nBuild Result Summary\r\n|Day Hit Count|Week Hit Count|Month Hit Count|\r\n|---|---|---|\r\n|0|0|0|\r\n\r\n\u003c!-- runfo report end --\u003e\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOSB_T_Q==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5HSDGe",
                                           "createdAt":  "2022-07-26T19:52:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-extensions-caching\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n```\r\nAssert.False() Failure\r\nExpected: False\r\nActual:   True\r\n\r\n\r\nStack trace\r\n   at Microsoft.Extensions.Caching.Memory.MemoryCacheSetAndRemoveTests.GetAndSet_AreThreadSafe_AndUpdatesNeverLeavesNullValues() in /_/src/libraries/Microsoft.Extensions.Caching.Memory/tests/MemoryCacheSetAndRemoveTests.cs:line 588\r\n   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)\r\n   at System.Reflection.MethodInvoker.Invoke(Object obj, IntPtr* args, BindingFlags invokeAttr) in /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodInvoker.cs:line 6\r\n```\r\nnet7.0-Linux-Release-arm-CoreCLR_checked-(Alpine.314.Arm32.Open)Ubuntu.1804.ArmArch.Open@mcr.microsoft.com/dotnet-buildtools/prereqs:alpine-3.14-helix-arm32v7-20210910135806-8a6f4f3\r\n\r\nPerhaps Linux specific? Creating issue so I can reference when disabling.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003edanmoseley\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`blocking-clean-ci`, `area-Extensions-Caching`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-07-26T19:52:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HSGNq",
                                           "createdAt":  "2022-07-26T20:06:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "It\u0027s Arm/Arm64 only?\r\n\r\n|Started|QueueName|OS|Architecture|\r\n|---|---|---|---|\r\n|2022-07-26 06:58:30.5840000|ubuntu.1804.armarch.open|Debian.10.Arm32.Open|arm|\r\n|2022-07-26 06:58:31.6350000|ubuntu.1804.armarch.open|Debian.11.Arm32.Open|arm|\r\n|2022-07-26 07:40:01.1380000|ubuntu.1804.armarch.open|Ubuntu.1804.Arm32.Open|arm|\r\n|2022-07-26 07:40:02.3870000|ubuntu.1804.armarch.open|Ubuntu.1804.Arm32.Open|arm|\r\n|2022-07-26 08:21:28.9620000|windows.10.arm64v8.open|Windows.10.Arm64v8.Open|arm64|\r\n|2022-07-26 08:21:32.9770000|windows.10.arm64v8.open|Windows.10.Arm64v8.Open|arm64|\r\n|2022-07-26 08:28:14.1640000|ubuntu.1804.armarch.open|Ubuntu.1804.Arm32.Open|arm|\r\n|2022-07-26 09:01:46.0320000|windows.10.arm64v8.open|Windows.10.Arm64v8.Open|arm64|\r\n|2022-07-26 09:17:31.4570000|windows.10.arm64v8.open|Windows.10.Arm64v8.Open|arm64|\r\n|2022-07-26 09:34:12.9690000|windows.10.arm64v8.open|Windows.10.Arm64v8.Open|arm64|\r\n|2022-07-26 09:48:48.9630000|windows.10.arm64v8.open|Windows.10.Arm64v8.Open|arm64|\r\n|2022-07-26 09:51:14.7440000|ubuntu.1804.armarch.open|Debian.11.Arm32.Open|arm|\r\n|2022-07-26 10:04:30.5840000|ubuntu.1804.armarch.open|Alpine.314.Arm32.Open|arm|\r\n|2022-07-26 10:49:40.2350000|ubuntu.1804.armarch.open|Alpine.314.Arm32.Open|arm|\r\n|2022-07-26 10:57:55.9570000|ubuntu.1804.armarch.open|Debian.10.Arm32.Open|arm|\r\n|2022-07-26 13:13:47.7310000|ubuntu.1804.armarch.open|Debian.10.Arm32.Open|arm|\r\n|2022-07-26 13:13:49.0750000|ubuntu.1804.armarch.open|Debian.11.Arm32.Open|arm|\r\n|2022-07-26 15:00:56.3730000|ubuntu.1804.armarch.open|Alpine.314.Arm32.Open|arm|\r\n|2022-07-26 15:59:14.2010000|ubuntu.1804.armarch.open|Debian.11.Arm32.Open|arm|\r\n",
                                           "updatedAt":  "2022-07-26T20:06:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HSMJ7",
                                           "createdAt":  "2022-07-26T20:32:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCoptdQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "maryamariyan",
                                                                               "createdAt":  "2022-07-26T21:07:21Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "vonzshik",
                                                                               "createdAt":  "2022-07-26T22:51:25Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "@vonzshik pointed out a memory model bug here https://github.com/dotnet/runtime/pull/72821#discussion_r930358482\r\n\r\nSuch a bug could be Arm-specific because it has a weaker memory model, so missing \u0027volatile\u0027 is more likely to show up there.\r\n\r\n@dotnet/area-extensions-caching owners, there is no evidence this is a regression in 7.0, so I\u0027d be inclined to leave as-is until we fork. thoughts?",
                                           "updatedAt":  "2022-07-26T20:32:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HTAzS",
                                           "createdAt":  "2022-07-27T01:26:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "VincentBu",
                                           "body":  "Failed again in: [runtime-coreclr libraries-jitstress 20220726.1](https://dev.azure.com/dnceng/public/_build/results?buildId=1903335\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=49495534\u0026paneView=debug\u0026resultId=101095)\r\n\r\nFailed test:\r\n```\r\nnet7.0-windows-Release-arm64-CoreCLR_checked-jitstress1_tiered-Windows.10.Arm64v8.Open\r\n- Microsoft.Extensions.Caching.Memory.MemoryCacheSetAndRemoveTests.GetAndSet_AreThreadSafe_AndUpdatesNeverLeavesNullValues\r\n\r\nnet7.0-windows-Release-arm64-CoreCLR_checked-tailcallstress-Windows.10.Arm64v8.Open\r\n- Microsoft.Extensions.Caching.Memory.MemoryCacheSetAndRemoveTests.GetAndSet_AreThreadSafe_AndUpdatesNeverLeavesNullValues\r\n\r\nnet7.0-windows-Release-arm64-CoreCLR_checked-jitstress2_tiered-Windows.10.Arm64v8.Open\r\n- Microsoft.Extensions.Caching.Memory.MemoryCacheSetAndRemoveTests.GetAndSet_AreThreadSafe_AndUpdatesNeverLeavesNullValues\r\n\r\nnet7.0-windows-Release-arm64-CoreCLR_checked-zapdisable-Windows.10.Arm64v8.Open\r\n- Microsoft.Extensions.Caching.Memory.MemoryCacheSetAndRemoveTests.GetAndSet_AreThreadSafe_AndUpdatesNeverLeavesNullValues\r\n\r\nnet7.0-windows-Release-arm64-CoreCLR_checked-jitstress2-Windows.10.Arm64v8.Open\r\n- Microsoft.Extensions.Caching.Memory.MemoryCacheSetAndRemoveTests.GetAndSet_AreThreadSafe_AndUpdatesNeverLeavesNullValues\r\n\r\nnet7.0-Linux-Release-arm-CoreCLR_checked-no_tiered_compilation-(Ubuntu.1804.Arm32.Open)Ubuntu.1804.Armarch.Open@mcr.microsoft.com/dotnet-buildtools/prereqs:ubuntu-18.04-helix-arm32v7-bfcd90a-20200121150440\r\n- Microsoft.Extensions.Caching.Memory.MemoryCacheSetAndRemoveTests.GetAndSet_AreThreadSafe_AndUpdatesNeverLeavesNullValues\r\n\r\nnet7.0-Linux-Release-arm-CoreCLR_checked-zapdisable-(Ubuntu.1804.Arm32.Open)Ubuntu.1804.Armarch.Open@mcr.microsoft.com/dotnet-buildtools/prereqs:ubuntu-18.04-helix-arm32v7-bfcd90a-20200121150440\r\n- Microsoft.Extensions.Caching.Memory.MemoryCacheSetAndRemoveTests.GetAndSet_AreThreadSafe_AndUpdatesNeverLeavesNullValues\r\n\r\nnet7.0-Linux-Release-arm-CoreCLR_checked-jitminopts-(Ubuntu.1804.Arm32.Open)Ubuntu.1804.Armarch.Open@mcr.microsoft.com/dotnet-buildtools/prereqs:ubuntu-18.04-helix-arm32v7-bfcd90a-20200121150440\r\n- Microsoft.Extensions.Caching.Memory.MemoryCacheSetAndRemoveTests.GetAndSet_AreThreadSafe_AndUpdatesNeverLeavesNullValues\r\n\r\nnet7.0-windows-Release-arm64-CoreCLR_checked-no_tiered_compilation-Windows.10.Arm64v8.Open\r\n- Microsoft.Extensions.Caching.Memory.MemoryCacheSetAndRemoveTests.GetAndSet_AreThreadSafe_AndUpdatesNeverLeavesNullValues\r\n\r\nnet7.0-windows-Release-x86-CoreCLR_checked-jitstress2-Windows.10.Amd64.Open\r\n- System.Runtime.Intrinsics.Tests.Vectors.Vector64Tests.Vector64Int64SumTest\r\n```\r\n\r\n**Error message:**\r\n```\r\nAssert.False() Failure\r\nExpected: False\r\nActual:   True\r\n\r\n\r\nStack trace\r\n   at Microsoft.Extensions.Caching.Memory.MemoryCacheSetAndRemoveTests.GetAndSet_AreThreadSafe_AndUpdatesNeverLeavesNullValues() in /_/src/libraries/Microsoft.Extensions.Caching.Memory/tests/MemoryCacheSetAndRemoveTests.cs:line 588\r\n   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)\r\n   at System.Reflection.MethodInvoker.Invoke(Object obj, IntPtr* args, BindingFlags invokeAttr) in /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodInvoker.cs:line 64\r\n```",
                                           "updatedAt":  "2022-07-27T01:26:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5IFdMU",
                                           "createdAt":  "2022-08-09T13:34:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "eerhardt",
                                           "body":  "@v-wenyuxu - that stack trace looks like a different test. Also the test being tracked here has been disabled for over a week.",
                                           "updatedAt":  "2022-08-09T13:34:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5IH9P9",
                                           "createdAt":  "2022-08-10T01:18:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "VincentBu",
                                           "body":  "@v-wenyuxu , you need to open a new issue for that test and delete that comment.",
                                           "updatedAt":  "2022-08-10T01:18:59Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "GetAndSet_AreThreadSafe_AndUpdatesNeverLeavesNullValues failing",
        "labels":  [
                       "arch-arm32",
                       "arch-arm64",
                       "disabled-test",
                       "area-Extensions-Caching"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/72890",
        "createdAt":  "2022-07-26T22:26:51Z",
        "number":  72890,
        "author":  "danmoseley",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-11-15T08:43:16Z",
        "body":  "GetAndSet_AreThreadSafe_AndUpdatesNeverLeavesNullValues\r\nOvercapacityPurge_AreThreadSafe\r\nAddAndReplaceEntries_AreThreadSafe\r\n\r\nThese were inherited from aspnet/caching but have been disabled as they need rewriting to not be racy. \r\n\r\nexample failure\r\n```\r\nSystem.AggregateException : One or more errors occurred.\r\n---- System.Threading.Tasks.TaskCanceledException : A task was canceled.\r\n\r\n\r\nStack trace\r\n   at System.Threading.Tasks.Task.WaitAll(Task[] tasks, Int32 millisecondsTimeout, CancellationToken cancellationToken)\r\n   at Microsoft.Extensions.Caching.Memory.MemoryCacheSetAndRemoveTests.OvercapacityPurge_AreThreadSafe() in /_/src/libraries/Microsoft.Extensions.Caching.Memory/tests/MemoryCacheSetAndRemoveTests.cs:line 655\r\n----- Inner Stack Trace -----\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOR0on-w==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5HSif7",
                                           "createdAt":  "2022-07-26T22:27:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-extensions-caching\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nGetAndSet_AreThreadSafe_AndUpdatesNeverLeavesNullValues\r\nOvercapacityPurge_AreThreadSafe\r\nAddAndReplaceEntries_AreThreadSafe\r\n\r\nThese were inherited from aspnet/caching but have been disabled as they need rewriting to not be racy. \r\n\r\nexample failure\r\n```\r\nSystem.AggregateException : One or more errors occurred.\r\n---- System.Threading.Tasks.TaskCanceledException : A task was canceled.\r\n\r\n\r\nStack trace\r\n   at System.Threading.Tasks.Task.WaitAll(Task[] tasks, Int32 millisecondsTimeout, CancellationToken cancellationToken)\r\n   at Microsoft.Extensions.Caching.Memory.MemoryCacheSetAndRemoveTests.OvercapacityPurge_AreThreadSafe() in /_/src/libraries/Microsoft.Extensions.Caching.Memory/tests/MemoryCacheSetAndRemoveTests.cs:line 655\r\n----- Inner Stack Trace -----\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003edanmoseley\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-Extensions-Caching`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-07-26T22:27:01Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Rewrite 3 MemoryCache tests to not be timing sensitive ",
        "labels":  [
                       "disabled-test",
                       "help wanted",
                       "area-Extensions-Caching"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/72912",
        "createdAt":  "2022-07-27T06:23:23Z",
        "number":  72912,
        "author":  "radical",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-08-01T20:02:37Z",
        "body":  "Hit with `Libraries Test Run release coreclr windows x86 Release` on https://github.com/dotnet/runtime/pull/72892 .\r\n[build](https://dev.azure.com/dnceng/public/_build/results?buildId=1905656\u0026view=logs\u0026jobId=c6f8dc49-92a1-5760-c098-ba97b8142bfb\u0026j=457f7e88-dfa2-5bd9-f871-fdf124c2477d), and [log](https://helixre107v0xdeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-pull-72892-merge-e5e60afce5e74b27b8/Microsoft.Extensions.Caching.Memory.Tests/1/console.997b7406.log?helixlogtype=result):\r\n\r\n```\r\n  Starting:    Microsoft.Extensions.Caching.Memory.Tests (parallel test collections = on, max threads = 2)\r\n    Microsoft.Extensions.Caching.Memory.CapacityTests.AddingReplacementWhenTotalSizeExceedsCapacityDoesNotUpdateRemovesOldEntryAndTriggersCompaction [FAIL]\r\n      Assert.True() Failure\r\n      Expected: True\r\n      Actual:   False\r\n      Stack Trace:\r\n        /_/src/libraries/Microsoft.Extensions.Caching.Memory/tests/CapacityTests.cs(264,0): at Microsoft.Extensions.Caching.Memory.CapacityTests.AddingReplacementWhenTotalSizeExceedsCapacityDoesNotUpdateRemovesOldEntryAndTriggersCompaction()\r\n        --- End of stack trace from previous location ---\r\n  Finished:    Microsoft.Extensions.Caching.Memory.Tests\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOR1pJFw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5HTksc",
                                           "createdAt":  "2022-07-27T06:23:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-extensions-caching\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nHit with `Libraries Test Run release coreclr windows x86 Release` on https://github.com/dotnet/runtime/pull/72892 .\r\n[build](https://dev.azure.com/dnceng/public/_build/results?buildId=1905656\u0026view=logs\u0026jobId=c6f8dc49-92a1-5760-c098-ba97b8142bfb\u0026j=457f7e88-dfa2-5bd9-f871-fdf124c2477d), and [log](https://helixre107v0xdeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-pull-72892-merge-e5e60afce5e74b27b8/Microsoft.Extensions.Caching.Memory.Tests/1/console.997b7406.log?helixlogtype=result):\r\n\r\n```\r\n  Starting:    Microsoft.Extensions.Caching.Memory.Tests (parallel test collections = on, max threads = 2)\r\n    Microsoft.Extensions.Caching.Memory.CapacityTests.AddingReplacementWhenTotalSizeExceedsCapacityDoesNotUpdateRemovesOldEntryAndTriggersCompaction [FAIL]\r\n      Assert.True() Failure\r\n      Expected: True\r\n      Actual:   False\r\n      Stack Trace:\r\n        /_/src/libraries/Microsoft.Extensions.Caching.Memory/tests/CapacityTests.cs(264,0): at Microsoft.Extensions.Caching.Memory.CapacityTests.AddingReplacementWhenTotalSizeExceedsCapacityDoesNotUpdateRemovesOldEntryAndTriggersCompaction()\r\n        --- End of stack trace from previous location ---\r\n  Finished:    Microsoft.Extensions.Caching.Memory.Tests\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eradical\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`blocking-clean-ci`, `area-Extensions-Caching`, `test-failure`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-07-27T06:23:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HVPP2",
                                           "createdAt":  "2022-07-27T13:16:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "eerhardt",
                                           "body":  "cc @danmoseley ",
                                           "updatedAt":  "2022-07-27T13:16:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HWFMd",
                                           "createdAt":  "2022-07-27T16:19:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "failing here\r\n```\r\n            // Wait for compaction to complete\r\n            Assert.True(await sem.WaitAsync(TimeSpan.FromSeconds(10)));\r\n```\r\nI\u0027ll run locally and see how long it normally takes to get an idea of whether it\u0027s hung or just taking eg 11 seconds.",
                                           "updatedAt":  "2022-07-27T16:19:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HWkkX",
                                           "createdAt":  "2022-07-27T17:48:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "On my machine, the wait is \u003c 1 millisecond so very likely increasing the wait won\u0027t help, and there is a bug eg EvictionCallback isn\u0027t getting called for some reason.\r\n\r\nI\u0027ll disable the tests that wait for compaction.",
                                           "updatedAt":  "2022-07-27T17:48:20Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Failing test `Microsoft.Extensions.Caching.Memory.CapacityTests.AddingReplacementWhenTotalSizeExceedsCapacityDoesNotUpdateRemovesOldEntryAndTriggersCompaction`",
        "labels":  [
                       "test-failure",
                       "disabled-test",
                       "area-Extensions-Caching"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/76340",
        "createdAt":  "2022-09-28T22:19:27Z",
        "number":  76340,
        "author":  "WhitWaldo",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCu1j2g==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "wilkovanderveen",
                                            "createdAt":  "2023-02-08T06:09:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rickdgray",
                                            "createdAt":  "2023-02-08T06:43:58Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hrestakd",
                                            "createdAt":  "2023-03-13T10:08:03Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2023-07-27T16:47:03Z",
        "body":  "### Background and motivation\n\nThere are a great many reasons to cache values across disparate application types. Recently, I\u0027ve been working to cache \"recently used\" values, such as those used in searches on a per-user basis. \r\n\r\nIdeally, each value stored to the cache should be capable of independent expirations so I might save two values for a given user on Monday, with a 5 day expiry, three more on Wednesday and be confident that come Saturday, the values saved Monday will be expired and no longer available in the cache.\r\n\r\nHowever, this scenario is frustrated by the current IDistributedCache API for a couple of reasons:\r\n- There exists no mechanism for partial key matches (this proposal)\r\n- There\u0027s no mechanism for me to retrieve the list of keys currently in use in the cache (discussed in https://github.com/dotnet/runtime/issues/36402) so I might evaluate for myself on which keys I wish to operate and kick off each as separate operations\r\n\r\nAs it stands, I instead have to serialize each of my recent values along with their own local expiry values into a single list identified by a single known key, retrieve and deserialize them all for any search history queries and do a client-side evaluation of which values are still valid. This should ideally all be done within the IDistributedCache implementation to improve performance and eliminate surface area for bugs.\n\n### API Proposal\n\nI would suggest implementing the following using the default interface methods introduced in C# 8.0. That said, I propose it as a discrete interface so as to simplify my example of it and more easily highlight what I\u0027m articulating.\r\n\r\n```csharp\r\nnamespace Microsoft.Extensions.Caching.Distributed;\r\n\r\n    public interface IExpressibleDistributedCache// : IDistributedCache //The name could use some additional contemplation\r\n    {\r\n        /// \u003csummary\u003e\r\n        /// Gets the values for any key that matches the predicate.\r\n        /// \u003c/summary\u003e\r\n        /// \u003cparam name=\"keyPredicate\"\u003eAn expression identifying the requested key(s).\u003c/param\u003e\r\n        /// \u003creturns\u003eThe located value or null.\u003c/returns\u003e\r\n        IReadOnlyDictionary\u003cstring, byte[]\u003e Get(Expression\u003cFunc\u003cstring, bool\u003e\u003e keyPredicate);\r\n\r\n        /// \u003csummary\u003e\r\n        /// Gets the values for any key that matches the predicate.\r\n        /// \u003c/summary\u003e\r\n        /// \u003cparam name=\"keyPredicate\"\u003eAn expression identifying the requested key(s).\u003c/param\u003e\r\n        /// \u003cparam name=\"token\"\u003eOptional. The \u003csee cref=\"CancellationToken\"/\u003e used to propagate notifications that the operation should be canceled.\u003c/param\u003e\r\n        /// \u003creturns\u003eThe \u003csee cref=\"Task\"/\u003e that represents the asynchronous operation, containing the located value or null.\u003c/returns\u003e\r\n        Task\u003cIReadOnlyDictionary\u003cstring, byte[]\u003e\u003e GetAsync(Expression\u003cFunc\u003cstring, bool\u003e\u003e keyPredicate, CancellationToken token = default);\r\n\r\n        /// \u003csummary\u003e\r\n        /// Refreshes values in the cache based on their respective keys, resetting their sliding expiration timeout (if any).\r\n        /// \u003c/summary\u003e\r\n        /// \u003cparam name=\"keyPredicate\"\u003eA expression identifying the specified key(s).\u003c/param\u003e\r\n        void Refresh(Expression\u003cFunc\u003cstring, bool\u003e\u003e keyPredicate);\r\n\r\n        /// \u003csummary\u003e\r\n        /// Refreshes values in the cache based on their respective keys, resetting their sliding expiration timeout (if any).\r\n        /// \u003c/summary\u003e\r\n        /// \u003cparam name=\"keyPredicate\"\u003eAn expression identifying the specified key(s).\u003c/param\u003e\r\n        /// \u003cparam name=\"token\"\u003eOptional. The \u003csee cref=\"CancellationToken\"/\u003e used to propagate notifications that the operation should be canceled.\u003c/param\u003e\r\n        /// \u003creturns\u003eThe \u003csee cref=\"Task\"/\u003e that represents the asynchronous operation.\u003c/returns\u003e\r\n        Task RefreshAsync(Expression\u003cFunc\u003cstring, bool\u003e\u003e keyPredicate, CancellationToken token = default);\r\n\r\n        /// \u003csummary\u003e\r\n        /// Removes the value with the given key(s).\r\n        /// \u003c/summary\u003e\r\n        /// \u003cparam name=\"keyPredicate\"\u003eAn expression identifying the requested value.\u003c/param\u003e\r\n        void Remove(Expression\u003cFunc\u003cstring, bool\u003e\u003e keyPredicate);\r\n\r\n        /// \u003csummary\u003e\r\n        /// Removes the value with the given key(s).\r\n        /// \u003c/summary\u003e\r\n        /// \u003cparam name=\"keyPredicate\"\u003eAn expression identifying the specified key(s).\u003c/param\u003e\r\n        /// \u003cparam name=\"token\"\u003eOptional. The \u003csee cref=\"CancellationToken\"/\u003e used to propagate notifications that the operation should be canceled.\u003c/param\u003e\r\n        /// \u003creturns\u003eThe \u003csee cref=\"Task\"/\u003e that represents the asynchronous operation.\u003c/returns\u003e\r\n        Task RemoveAsync(Expression\u003cFunc\u003cstring, bool\u003e\u003e keyPredicate, CancellationToken token = default);\r\n    }\r\n\r\n```\r\n\r\nThe reason to use `Expression\u003cFunc\u003cstring, bool\u003e\u003e` is so that the expression remains quotable for expression tree serializers such the recently open-sourced [Bonsai ](https://www.nuget.org/packages/Nuqleon.Linq.Expressions.Bonsai.Serialization) ([docs](https://reaqtive.net/documentation/nuqleon/nuqleon.linq.expressions.bonsai)) to serialize the predicate across network boundaries as necessary.\n\n### API Usage\n\n```csharp\r\nIExpressibleDistributedCache cache; //Injected\r\n\r\nIExpressibleDistributedCache _cache;\r\n\r\n//Get all the cached entries starting with \"recentSearchTerms_user\"\r\n_cache.GetAsync(key =\u003e key.StartsWith(\"recentSearchTerms_user\"));\r\n\r\n//Refresh these cached entries\r\n_cache.RefreshAsync(key =\u003e key.StartsWith(\"recentSearchTerms_user\"));\r\n\r\n//Remove the terms belonging to a specific user\r\n_cache.RemoveAsync(key =\u003e key.StartsWith(\"recentSearchTerms_user123456_\"));\r\n```\r\n\n\n### Alternative Designs\n\nAlternatively, provide a mechanism, per #36402 so clients can list all the keys (available at time of query) and perform the filtering locally before sending follow-up queries.\r\n\r\nThis would be an inferior solution though because it requires at least two round-trips and because #36402 is susceptible to keys no longer being available when the follow-up call is made. Rather, this approach would ensure that the operations were being run against as fresh a set of data can be made available and specifically how that\u0027s done (e.g. checkpoints, follower cache, etc.) is left as an implementation detail.\n\n### Risks\n\nWhile it\u0027s reported that the Bonsai serializer has been used for several years now within Microsoft, it\u0027s only recently been open sourced, so it might be subject to bugs for more elaborate queries in the wild. This is why I kept the expression signature simple in my API example above.\r\n\r\nIf released as IExpressibleDistributedCache (a better name TBD), there\u0027s the risk that there are limited implementations of it due to the more commonly used and visible IDistributedCache. Thus my recommendation to instead release via default interface methods on IDistributedCache so that not only can existing implementations continue to work without issue, but a team-recommended approach for demonstrating the relatively new (at least publicly) Bonsai serialization can be provided out of the box.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOSzH-3Q==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5LMUjH",
                                           "createdAt":  "2022-09-28T22:19:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-09-28T22:19:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5LMf7d",
                                           "createdAt":  "2022-09-28T23:27:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-extensions-caching\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nThere are a great many reasons to cache values across disparate application types. Recently, I\u0027ve been working to cache \"recently used\" values, such as those used in searches on a per-user basis. \r\n\r\nIdeally, each value stored to the cache should be capable of independent expirations so I might save two values for a given user on Monday, with a 5 day expiry, three more on Wednesday and be confident that come Saturday, the values saved Monday will be expired and no longer available in the cache.\r\n\r\nHowever, this scenario is frustrated by the current IDistributedCache API for a couple of reasons:\r\n- There exists no mechanism for partial key matches (this proposal)\r\n- There\u0027s no mechanism for me to retrieve the list of keys currently in use in the cache (discussed in https://github.com/dotnet/runtime/issues/36402) so I might evaluate for myself on which keys I wish to operate and kick off each as separate operations\r\n\r\nAs it stands, I instead have to serialize each of my recent values along with their own local expiry values into a single list identified by a single known key, retrieve and deserialize them all for any search history queries and do a client-side evaluation of which values are still valid. This should ideally all be done within the IDistributedCache implementation to improve performance and eliminate surface area for bugs.\n\n### API Proposal\n\nI would suggest implementing the following using the default interface methods introduced in C# 8.0. That said, I propose it as a discrete interface so as to simplify my example of it and more easily highlight what I\u0027m articulating.\r\n\r\n```csharp\r\nnamespace Microsoft.Extensions.Caching.Distributed;\r\n\r\n    public interface IExpressibleDistributedCache// : IDistributedCache //The name could use some additional contemplation\r\n    {\r\n        /// \u003csummary\u003e\r\n        /// Gets the values for any key that matches the predicate.\r\n        /// \u003c/summary\u003e\r\n        /// \u003cparam name=\"keyPredicate\"\u003eAn expression identifying the requested key(s).\u003c/param\u003e\r\n        /// \u003creturns\u003eThe located value or null.\u003c/returns\u003e\r\n        IReadOnlyDictionary\u003cstring, byte[]\u003e Get(Expression\u003cFunc\u003cstring, bool\u003e\u003e keyPredicate);\r\n\r\n        /// \u003csummary\u003e\r\n        /// Gets the values for any key that matches the predicate.\r\n        /// \u003c/summary\u003e\r\n        /// \u003cparam name=\"keyPredicate\"\u003eAn expression identifying the requested key(s).\u003c/param\u003e\r\n        /// \u003cparam name=\"token\"\u003eOptional. The \u003csee cref=\"CancellationToken\"/\u003e used to propagate notifications that the operation should be canceled.\u003c/param\u003e\r\n        /// \u003creturns\u003eThe \u003csee cref=\"Task\"/\u003e that represents the asynchronous operation, containing the located value or null.\u003c/returns\u003e\r\n        Task\u003cIReadOnlyDictionary\u003cstring, byte[]\u003e\u003e GetAsync(Expression\u003cFunc\u003cstring, bool\u003e\u003e keyPredicate, CancellationToken token = default);\r\n\r\n        /// \u003csummary\u003e\r\n        /// Refreshes values in the cache based on their respective keys, resetting their sliding expiration timeout (if any).\r\n        /// \u003c/summary\u003e\r\n        /// \u003cparam name=\"keyPredicate\"\u003eA expression identifying the specified key(s).\u003c/param\u003e\r\n        void Refresh(Expression\u003cFunc\u003cstring, bool\u003e\u003e keyPredicate);\r\n\r\n        /// \u003csummary\u003e\r\n        /// Refreshes values in the cache based on their respective keys, resetting their sliding expiration timeout (if any).\r\n        /// \u003c/summary\u003e\r\n        /// \u003cparam name=\"keyPredicate\"\u003eAn expression identifying the specified key(s).\u003c/param\u003e\r\n        /// \u003cparam name=\"token\"\u003eOptional. The \u003csee cref=\"CancellationToken\"/\u003e used to propagate notifications that the operation should be canceled.\u003c/param\u003e\r\n        /// \u003creturns\u003eThe \u003csee cref=\"Task\"/\u003e that represents the asynchronous operation.\u003c/returns\u003e\r\n        Task RefreshAsync(Expression\u003cFunc\u003cstring, bool\u003e\u003e keyPredicate, CancellationToken token = default);\r\n\r\n        /// \u003csummary\u003e\r\n        /// Removes the value with the given key(s).\r\n        /// \u003c/summary\u003e\r\n        /// \u003cparam name=\"keyPredicate\"\u003eAn expression identifying the requested value.\u003c/param\u003e\r\n        void Remove(Expression\u003cFunc\u003cstring, bool\u003e\u003e keyPredicate);\r\n\r\n        /// \u003csummary\u003e\r\n        /// Removes the value with the given key(s).\r\n        /// \u003c/summary\u003e\r\n        /// \u003cparam name=\"keyPredicate\"\u003eAn expression identifying the specified key(s).\u003c/param\u003e\r\n        /// \u003cparam name=\"token\"\u003eOptional. The \u003csee cref=\"CancellationToken\"/\u003e used to propagate notifications that the operation should be canceled.\u003c/param\u003e\r\n        /// \u003creturns\u003eThe \u003csee cref=\"Task\"/\u003e that represents the asynchronous operation.\u003c/returns\u003e\r\n        Task RemoveAsync(Expression\u003cFunc\u003cstring, bool\u003e\u003e keyPredicate, CancellationToken token = default);\r\n    }\r\n\r\n```\r\n\r\nThe reason to use `Expression\u003cFunc\u003cstring, bool\u003e\u003e` is so that the expression remains quotable for expression tree serializers such the recently open-sourced [Bonsai ](https://www.nuget.org/packages/Nuqleon.Linq.Expressions.Bonsai.Serialization) ([docs](https://reaqtive.net/documentation/nuqleon/nuqleon.linq.expressions.bonsai)) to serialize the predicate across network boundaries as necessary.\n\n### API Usage\n\n```csharp\r\nIExpressibleDistributedCache cache; //Injected\r\n\r\nIExpressibleDistributedCache _cache;\r\n\r\n//Get all the cached entries starting with \"recentSearchTerms_user\"\r\n_cache.GetAsync(key =\u003e key.StartsWith(\"recentSearchTerms_user\"));\r\n\r\n//Refresh these cached entries\r\n_cache.RefreshAsync(key =\u003e key.StartsWith(\"recentSearchTerms_user\"));\r\n\r\n//Remove the terms belonging to a specific user\r\n_cache.RemoveAsync(key =\u003e key.StartsWith(\"recentSearchTerms_user123456_\"));\r\n```\r\n\n\n### Alternative Designs\n\nAlternatively, provide a mechanism, per #36402 so clients can list all the keys (available at time of query) and perform the filtering locally before sending follow-up queries.\r\n\r\nThis would be an inferior solution though because it requires at least two round-trips and because #36402 is susceptible to keys no longer being available when the follow-up call is made. Rather, this approach would ensure that the operations were being run against as fresh a set of data can be made available and specifically how that\u0027s done (e.g. checkpoints, follower cache, etc.) is left as an implementation detail.\n\n### Risks\n\nWhile it\u0027s reported that the Bonsai serializer has been used for several years now within Microsoft, it\u0027s only recently been open sourced, so it might be subject to bugs for more elaborate queries in the wild. This is why I kept the expression signature simple in my API example above.\r\n\r\nIf released as IExpressibleDistributedCache (a better name TBD), there\u0027s the risk that there are limited implementations of it due to the more commonly used and visible IDistributedCache. Thus my recommendation to instead release via default interface methods on IDistributedCache so that not only can existing implementations continue to work without issue, but a team-recommended approach for demonstrating the relatively new (at least publicly) Bonsai serialization can be provided out of the box.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eWhitWaldo\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `untriaged`, `area-Extensions-Caching`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-09-28T23:27:31Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[API Proposal]: Operations on partial IDistributedCache key values",
        "labels":  [
                       "api-suggestion",
                       "area-Extensions-Caching"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/88733",
        "createdAt":  "2023-07-12T12:57:47Z",
        "number":  88733,
        "author":  "Lilk",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-11-15T08:40:29Z",
        "body":  "### Description\r\n\r\nIf holding onto a Microsoft.Extensions.Caching.Memory.CacheEntry, in order to update the size after it is known (If e.g. caching AsyncLazy values, and needing to update the size once the value has been materialized), the overall CurrentEstimatedSize is not updated.  \r\n\r\nIf the size is updated to a smaller value than the initally set value, this will lead to emptying of the cache and busy-loop of compaction upon reaching the size limit. \r\n\r\nSeen here is the result of a compaction with the parameter 0.5, causing half of the entries being dropped (lower graph), but seemingly no to little impact on the reported size. \r\n![image](https://github.com/dotnet/runtime/assets/710640/6f5a21c2-55b4-4f12-8e2c-1ef2545ab1da)\r\n\r\nAs the overcapacitycompaction scheduling is based on this metric, such a scenario will cause repeated scheduling of OvercapacityCompaction (for every insertion), and will cause a busy CPU loop, quickly dumping all of the entries in the cache, but never stopping the compaction cycle. See here graphs for patterns of entry count vs estimated size as well as cache misses.\r\n\r\n![image](https://github.com/dotnet/runtime/assets/710640/8a81be82-32cc-42c3-824f-887f723e7a38)\r\n\r\nAnd the CPU busy iterating the coherent state:\r\n\r\n![image](https://github.com/dotnet/runtime/assets/710640/265ee8f5-0016-46e3-8672-0018141b3b1c)\r\n\r\n\r\nI am at this point unsure of the symptoms if Size were to be update to a higher value, the reported CurrentEstimatedSize  would be less than the actual size, but what effects would it have to the MemoryCache, what effects will take place if the CurrentEstimatedSize  is less than zero?\r\n\r\n### Reproduction Steps\r\n```\r\n// See https://aka.ms/new-console-template for more information\r\nusing Microsoft.Extensions.Caching.Memory;\r\n\r\nConsole.WriteLine(\"Hello, World!\");\r\nvar _cache = new MemoryCache(new MemoryCacheOptions()\r\n{\r\n    TrackStatistics = true,\r\n    ExpirationScanFrequency = TimeSpan.FromMinutes(1),\r\n    CompactionPercentage = 0.1,\r\n    SizeLimit = 10,\r\n\r\n});\r\n\r\nTask task = null;\r\n\r\n_cache.GetOrCreate(\"test\", (ICacheEntry entry) =\u003e\r\n{\r\n    entry.Size = 4;\r\n    task = Task.Delay(1000);\r\n    task.ContinueWith((t) =\u003e\r\n    {\r\n        try\r\n        {\r\n            entry.Size = 2;\r\n        }\r\n        catch (Exception e)\r\n        {\r\n            Console.WriteLine(e.Message);\r\n        }\r\n        return;\r\n    });\r\n\r\n    return new object();\r\n});\r\n\r\nvar stats1 = _cache.GetCurrentStatistics();\r\nConsole.WriteLine($\"Cache size after GetOrCreate {stats1.CurrentEntryCount}, {stats1.CurrentEstimatedSize}\");\r\nawait task;\r\nvar stats2 = _cache.GetCurrentStatistics();\r\nConsole.WriteLine($\"Cache size after GetOrCreate {stats2.CurrentEntryCount}, {stats2.CurrentEstimatedSize}\");\r\n```\r\n### Expected behavior\r\nHello, World!            \r\nCache size after GetOrCreate 1, 4  \r\nCache size after GetOrCreate 1, 2   \r\n\r\n\r\nI would assume one of two options:\r\n\r\n1.  The CurrentEstimatedSize is updated correctly, by applying an interlocked add on the cache size using the delta of the entries new and old size.\r\n2. If 1) is not possible, assigning Size or calling SetSize() should throw if the CacheEntry has been disposed (ingested into the cache), since the cache obviously doesnt support such properties being set after ingestion. \r\n\r\nAt the very least this behaviour should be documented, and it should be noted that calling SetSize after the callback passed to GetOrCreate has returned is undefined/dangerous. \r\n\r\n\r\n### Actual behavior\r\n\r\nHello, World!            \r\nCache size after GetOrCreate 1, 4  \r\nCache size after GetOrCreate 1, 4    \r\n\r\nCurrentEstimatedSize is not updated, but the entries size is. \r\n\r\n### Regression?\r\n\r\nI do not know if this worked on earlier builds. \r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\ndotnet 7, windows and linux. \r\n\r\n### Other information\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHObAFCVg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5hTbi4",
                                           "createdAt":  "2023-07-12T12:57:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-extensions-caching\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nIf holding onto a Microsoft.Extensions.Caching.Memory.CacheEntry, in order to update the size after it is known (If e.g. caching AsyncLazy values, and needing to update the size once the value has been materialized), the overall CurrentEstimatedSize is not updated.  \r\n\r\nIf the size is updated to a smaller value than the initally set value, this will lead to emptying of the cache and busy-loop of compaction upon reaching the size limit. \r\n\r\nSeen here is the result of a compaction with the parameter 0.5, causing half of the entries being dropped (lower graph), but seemingly no to little impact on the reported size. \r\n![image](https://github.com/dotnet/runtime/assets/710640/f7b7a9d9-792c-4581-b0e9-4c2197c7fbbc)\r\n\r\nAs the overcapacitycompaction scheduling is based on this metric, such a scenario will cause repeated scheduling of OvercapacityCompaction (for every insertion), and will cause a busy CPU loop, quickly dumping all of the entries in the cache, but never stopping the compaction cycle. See here graphs for patterns of entry count vs estimated size as well as cache misses.\r\n\r\n![image](https://github.com/dotnet/runtime/assets/710640/8a81be82-32cc-42c3-824f-887f723e7a38)\r\n\r\nAnd the CPU busy iterating the coherent state:\r\n\r\n![image](https://github.com/dotnet/runtime/assets/710640/265ee8f5-0016-46e3-8672-0018141b3b1c)\r\n\r\n\r\nI am at this point unsure of the symptoms if Size were to be update to a higher value, the reported CurrentEstimatedSize  would be less than the actual size, but what effects would it have to the MemoryCache, what effects will take place if the CurrentEstimatedSize  is less than zero?\n\n### Reproduction Steps\n\n// See https://aka.ms/new-console-template for more information\r\nusing Microsoft.Extensions.Caching.Memory;\r\n\r\nConsole.WriteLine(\"Hello, World!\");\r\nvar _cache = new MemoryCache(new MemoryCacheOptions()\r\n{\r\n    TrackStatistics = true,\r\n    ExpirationScanFrequency = TimeSpan.FromMinutes(1),\r\n    CompactionPercentage = 0.1,\r\n    SizeLimit = 10,\r\n\r\n});\r\n\r\nTask task = null;\r\n\r\n_cache.GetOrCreate(\"test\", (ICacheEntry entry) =\u003e\r\n{\r\n    entry.Size = 4;\r\n    task = Task.Delay(1000);\r\n    task.ContinueWith((t) =\u003e\r\n    {\r\n        try\r\n        {\r\n            entry.Size = 2;\r\n        }\r\n        catch (Exception e)\r\n        {\r\n            Console.WriteLine(e.Message);\r\n        }\r\n        return;\r\n    });\r\n\r\n    return new object();\r\n});\r\nvar stats1 = _cache.GetCurrentStatistics();\r\nConsole.WriteLine($\"Cache size after GetOrCreate {stats1.CurrentEntryCount}, {stats1.CurrentEstimatedSize}\");\r\nawait task;\r\nvar stats2 = _cache.GetCurrentStatistics();\r\nConsole.WriteLine($\"Cache size after GetOrCreate {stats2.CurrentEntryCount}, {stats2.CurrentEstimatedSize}\");\n\n### Expected behavior\n\nI would assume one of two options:\r\n\r\n1.  The CurrentEstimatedSize is updated correctly, by applying an interlocked add on the cache size using the delta of the entries new and old size.\r\n2. If 1) is not possible, assigning Size or calling SetSize() should throw if the CacheEntry has been disposed (ingested into the cache), since the cache obviously doesnt support such properties being set after ingestion. \r\n\r\nAt the very least this behaviour should be documented, and it should be noted that calling SetSize after the callback passed to GetOrCreate has returned is undefined/dangerous. \r\n\n\n### Actual behavior\n\nCurrentEstimatedSize is not updated, but the entries size is. \n\n### Regression?\n\nI do not know if this worked on earlier builds. \n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\ndotnet 7, windows and linux. \n\n### Other information\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eLilk\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-Extensions-Caching`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-07-12T12:57:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5sAUJW",
                                           "createdAt":  "2023-11-15T08:40:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "Triage: it is a bug. In my opinion, the `Size` property should throw and `GetOrCreateAsync` should be used instead of `GetOrCreate` . It would call the async factory lazily, only when needed.",
                                           "updatedAt":  "2023-11-15T08:40:23Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Setting Size on MemoryCacheEntry after insertion causes faulty CurrentEstimatedSize",
        "labels":  [
                       "area-Extensions-Caching"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/98252",
        "createdAt":  "2024-02-10T01:14:50Z",
        "number":  98252,
        "author":  "thompson-tomo",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-06-25T15:55:54Z",
        "body":  "### Background and motivation\n\nI would like a way in which to fetch all the keys in the cache so that i can provide an actuator just like the way in which spring boot does it (https://docs.spring.io/spring-boot/docs/current/actuator-api/htmlsingle/#caches).\n\n### API Proposal\n\nInterface extension\r\n```csharp\r\nnamespace System.Collections.Generic;\r\n\r\nIEnumerable\u003cCacheItem\u003e GetCacheItems =\u003e new IEnumerable\u003cCacheItem\u003e();\r\n```\r\nUse class as proposed in #98251\n\n### API Usage\n\n```csharp\r\n\r\nforeach (var item in _memoryCache.GetCacheItems.ToList())\r\n{\r\n    //build object as per actuator needs which includes \r\n}\r\n```\n\n### Alternative Designs\n\n- Default implementation throws a not implemented exception\n\n### Risks\n\nShould be low risk as not a breaking change by providing default implementation.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOgn6XRw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5zcRPd",
                                           "createdAt":  "2024-02-10T01:14:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-extensions-caching\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nI would like a way in which to fetch all the keys in the cache so that i can provide an actuator just like the way in which spring boot does it (https://docs.spring.io/spring-boot/docs/current/actuator-api/htmlsingle/#caches).\n\n### API Proposal\n\nInterface extension\r\n```csharp\r\nnamespace System.Collections.Generic;\r\n\r\nIEnumerable\u003cCacheItem\u003e GetCacheItems =\u003e new IEnumerable\u003cCacheItem\u003e();\r\n```\r\nUse class as proposed in #98251\n\n### API Usage\n\n```csharp\r\n\r\n        foreach (var item in _memoryCache.GetCacheItems.ToList())\r\n        {\r\n            //build object as per actuator needs which includes \r\n        }\r\n```\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\nShould be low risk as not a breaking change by providing default implementation.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ethompson-tomo\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `untriaged`, `area-Extensions-Caching`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-02-10T01:14:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6CfpdH",
                                           "createdAt":  "2024-06-25T15:55:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jozkee",
                                           "body":  "Related to https://github.com/dotnet/runtime/issues/98251.",
                                           "updatedAt":  "2024-06-25T15:55:38Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[API Proposal]: Extend IDistributedCache to also provide keys/provider info",
        "labels":  [
                       "api-suggestion",
                       "area-Extensions-Caching"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/108333",
        "createdAt":  "2024-09-27T15:38:44Z",
        "number":  108333,
        "author":  "verdie-g",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-04-15T00:01:52Z",
        "body":  "### Description\n\nThe stats provided by [MemoryCache](https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.Caching.Memory/src/MemoryCache.cs) might randomly decrease for a short time when a thread dies.\n\nThat problem did not occur to me in production but I would like to use a similar pattern in my library, so I would be interested to double check that the pattern is valid.\n\n### Reproduction Steps\n\n1. A thread dies\n2. The thread and thread locals get collected\n3. The WeakReference in [MemoryCache._allStats](https://github.com/dotnet/runtime/blob/c315bac8ae7cfc613cb446ca594a17d07d02aa3d/src/libraries/Microsoft.Extensions.Caching.Memory/src/MemoryCache.cs#L28) should now point to null\n4. During that time, the thread local stats is not referenced by the `_allStats` list anymore and is not in the [dead threads accumulator](https://github.com/dotnet/runtime/blob/c315bac8ae7cfc613cb446ca594a17d07d02aa3d/src/libraries/Microsoft.Extensions.Caching.Memory/src/MemoryCache.cs#L406-L407) either\n5. The [Stats finalizer](https://github.com/dotnet/runtime/blob/c315bac8ae7cfc613cb446ca594a17d07d02aa3d/src/libraries/Microsoft.Extensions.Caching.Memory/src/MemoryCache.cs#L390) is called and the value of the thread counter is now added to the accumulators.\n\nHere is some code reproducing the problem\n```csharp\nusing Microsoft.Extensions.Caching.Memory;\n\nMemoryCache cache = new(new MemoryCacheOptions { TrackStatistics = true });\n\nvoid RunThread()\n{\n    Thread t = new(() =\u003e\n    {\n        for (int j = 0; j \u003c 10_000; j += 1)\n        {\n            _ = cache.Get(\"\");\n        }\n\n        RunThread();\n    })\n    {\n        Name = \"Cache Worker\",\n    };\n    t.Start();\n}\n\nfor (int i = 0; i \u003c Environment.ProcessorCount - 1; i += 1)\n{\n    RunThread();\n}\n\nThread integrityThread = new(() =\u003e\n{\n    long lastValue = -1;\n    while (true)\n    {\n        long newValue = cache.GetCurrentStatistics()!.TotalMisses;\n        if (newValue \u003c lastValue)\n        {\n            Console.WriteLine($\"{DateTime.Now:HH:mm:ss.fff} ERROR: total misses decreased from {lastValue} to {newValue} (-{lastValue - newValue})\");\n        }\n\n        lastValue = newValue;\n    }\n})\n{\n    Name = \"Stats Integrity Checker\"\n};\nintegrityThread.Start();\nintegrityThread.Join();\n```\nprints\n```\n12:33:56.685 ERROR: total misses decreased from 15228455 to 8638696 (-6589759)\n12:33:57.135 ERROR: total misses decreased from 36542054 to 9262055 (-27279999)\n12:33:57.614 ERROR: total misses decreased from 71470000 to 62226058 (-9243942)\n12:33:57.635 ERROR: total misses decreased from 68743304 to 49932686 (-18810618)\n12:33:58.084 ERROR: total misses decreased from 99334439 to 90553748 (-8780691)\n12:33:58.178 ERROR: total misses decreased from 105862703 to 96402589 (-9460114)\n12:33:58.224 ERROR: total misses decreased from 109891914 to 84536179 (-25355735)\n12:33:58.719 ERROR: total misses decreased from 144071687 to 134984002 (-9087685)\n12:33:58.755 ERROR: total misses decreased from 146512384 to 117584531 (-28927853)\n12:33:59.307 ERROR: total misses decreased from 182709797 to 173511034 (-9198763)\n12:33:59.318 ERROR: total misses decreased from 179256370 to 150150238 (-29106132)\n12:33:59.810 ERROR: total misses decreased from 217835394 to 208725505 (-9109889)\n12:33:59.831 ERROR: total misses decreased from 217951354 to 192014222 (-25937132)\n```\n\nPrometheus counters are expected to be strictly monotonic increasing. A counter being decreased will be interpreted as a counter reset and will impact the rate computation.\n\n### Expected behavior\n\nThe MemoryCache stats should always increase and never decrease.\n\n### Actual behavior\n\nThe MemoryCache stats might decrease in some case.\n\n### Configuration\n\n.NET: net9.0\nOS: Mac OS Sequoia 15.3.2\nArchitecture: ARM64",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOpxfeBA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6N1Vae",
                                           "createdAt":  "2024-09-27T15:39:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-extensions-caching\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-09-27T15:39:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6aYk6I",
                                           "createdAt":  "2025-01-14T14:51:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "verdie-g",
                                           "body":  "@maryamariyan @tarekgh could you have a look at this issue 🙏 \n\nAgain, I\u0027m not sure this is a real problem but I\u0027m really interested by this pattern to have a low-cost Interlocked.Increment.",
                                           "updatedAt":  "2025-04-10T19:12:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6aZ_6s",
                                           "createdAt":  "2025-01-14T16:41:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tarekgh",
                                           "body":  "@adamsitnik @jozkee could you please help looking at this issue? Thanks!",
                                           "updatedAt":  "2025-01-14T16:41:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dtz4M",
                                           "createdAt":  "2025-02-09T02:22:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "Thank you for a good explanation, @verdie-g. I do not expect our team will be able to investigate this during .NET 10, so I\u0027m marking it as https://github.com/dotnet/runtime/labels/help%20wanted and moving it to the Future milestone. I think the trickiest part will be setting up a minimal and reliable repro that can be used to validate a change on this.",
                                           "updatedAt":  "2025-02-09T02:22:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mlvwg",
                                           "createdAt":  "2025-04-10T19:13:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "verdie-g",
                                           "body":  "@jeffhandley I\u0027ve edited my issue to provide a minimal repo. Could you please upgrade this issue to a bug 🙏 ",
                                           "updatedAt":  "2025-04-10T19:13:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6nF94E",
                                           "createdAt":  "2025-04-15T00:00:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "\u003e That problem did not occur to me in production but I would like to use a similar pattern in my library, so I would be interested to double check that the pattern is valid.\n\nI think you are accurate that as-is there is a bug. A couple potential ways the bug could be fixed:\n\n1. Instead of having the ThreadLocal point to the Stats directly, have the ThreadLocal point to some StatsHandle that has a reference to Stats inside. Then change the _allStats to be List\u003cStats\u003e and a member of Stats is a WeakReference to the StatsHandle. This way when the thread exits the Stats object doesn\u0027t leave the list immediately. The WeakReference allows it to be detected as dead and pruned eventually at the same time it is copied over to the accumulated stats. Pruning the list whenever a new thread is added would probably be reasonable.\n\n2. Add a Stats _lastStats field in addition to the accumulated stats which stores the last values reported by Sum(). If the internals of Sum() ever computes numbers that are less than _lastStats, return _lastStats instead. This isn\u0027t as accurate as (1), but it at least guarantees the results never decrease during the window where a dead thread\u0027s stats aren\u0027t included in either _allStats or _accumulatedStats.",
                                           "updatedAt":  "2025-04-15T00:01:51Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "Inconsistent MemoryCache stats",
        "labels":  [
                       "help wanted",
                       "area-Extensions-Caching"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/108626",
        "createdAt":  "2024-10-07T20:45:58Z",
        "number":  108626,
        "author":  "BehtashShirzad",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-10-29T09:57:05Z",
        "body":  "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nI would like to suggest adding a GetExpirationTime(Time-to-Live) method to the IMemoryCache interface in Microsoft.Extensions.Caching.Memory. This method would allow developers to retrieve the remaining time before a cached item expires, which is currently not possible using the existing API.\r\n\r\nAt present, the IMemoryCache API allows us to add, retrieve, and remove items from the cache, but it doesn\u0027t expose any direct mechanism to retrieve the remaining expiration time (TTL) for a cached item. This feature is often useful in scenarios where cache invalidation and monitoring is important.\r\n\r\nDevelopers currently have no way to determine how long a cache entry will last before it expires. This can be particularly limiting when we want to implement cache-aware features such as refreshing an entry before it expires or logging cache expiration diagnostics or if you want to update a value without changing the time.\n\n### Describe the solution you\u0027d like\n\n```cs\r\npublic interface IMemoryCache\r\n{\r\n    // Existing methods...\r\n\r\n    TimeSpan? GetExpirationTime(string key);\r\n}\r\n```\r\n\r\n**I used redis for this option because the ttl was crucial for me and this inteface does not provide it,but the thing is that there are some points that I would rather to use IMemoryCache instead of redis:**\r\n\r\n- Increased Complexity: Integrating Redis adds a technology layer, complicating development and deployment for small teams.\r\n\r\n- Infrastructure Overhead: Requires setup and maintenance of a separate Redis server, leading to added resource demands.\n\n### Additional context\n\nThis will be the usage:\r\n```cs\r\npublic class MyService\r\n{\r\n    private readonly IMemoryCache _memoryCache;\r\n\r\n    public MyService(IMemoryCache memoryCache)\r\n    {\r\n        _memoryCache = memoryCache;\r\n    }\r\n\r\n    public void UpdateCachedItem(string key, int valueChange, bool addFlag)\r\n    {\r\n        var currentTTL = _memoryCache.GetExpirationTime(key);\r\n\r\n        if (currentTTL.HasValue \u0026\u0026 _memoryCache.TryGetValue(key, out int cachedValue))\r\n        {\r\n            if (addFlag)\r\n            {\r\n                cachedValue += valueChange;\r\n                Console.WriteLine($\"Adding {valueChange} to the cached value. New value: {cachedValue}\");\r\n            }\r\n            else\r\n            {\r\n                cachedValue -= valueChange;\r\n                Console.WriteLine($\"Subtracting {valueChange} from the cached value. New value: {cachedValue}\");\r\n            }\r\n\r\n            var cacheOptions = new MemoryCacheEntryOptions\r\n            {\r\n                AbsoluteExpirationRelativeToNow = currentTTL.Value\r\n            };\r\n\r\n            _memoryCache.Set(key, cachedValue, cacheOptions);\r\n            Console.WriteLine($\"Cache item \u0027{key}\u0027 updated with the same TTL of {currentTTL.Value.TotalMinutes} minutes.\");\r\n        }\r\n        else\r\n        {\r\n            Console.WriteLine($\"Cache item \u0027{key}\u0027 does not exist or has no expiration time.\");\r\n        }\r\n    }\r\n}\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOjz-T1Q==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6O7uYa",
                                           "createdAt":  "2024-10-07T22:18:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-extensions-caching\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-10-07T22:18:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6PCyav",
                                           "createdAt":  "2024-10-08T13:36:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "BehtashShirzad",
                                           "body":  "@mgravell\r\n@sebastienros\r\n@dotnet/area-extensions-caching",
                                           "updatedAt":  "2024-10-08T13:37:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6PDpvL",
                                           "createdAt":  "2024-10-08T15:01:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "Adding a GetExpirationTime method to interface IMemoryCache would be a breaking change.  Other new features like \u003chttps://github.com/dotnet/runtime/issues/45593\u003e were added only to class MemoryCache and not to the interface.\r\n\r\nIf the method were added, then the parameter should be `object key`, like in the existing `bool TryGetValue(object key, out object? value)`.\r\n\r\nMemoryCache supports \"linked entries\" that can expire together with other entries, before their own expiration times.  I suppose GetExpirationTime would ignore that feature.\r\n\r\nThere are plans to replace IMemoryCache and MemoryCache, in \u003chttps://github.com/dotnet/runtime/issues/48567\u003e.  That may make the team less willing to add features to MemoryCache.  However, the planned replacement RCache\\\u003cTKey, TValue\\\u003e in \u003chttps://github.com/dotnet/extensions/issues/4766#issuecomment-2341808266\u003e doesn\u0027t have a GetExpirationTime method either.\r\n",
                                           "updatedAt":  "2024-10-08T15:01:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6PE5lT",
                                           "createdAt":  "2024-10-08T17:21:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD1cSnQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "BehtashShirzad",
                                                                               "createdAt":  "2024-10-09T16:33:35Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "mgravell",
                                           "body":  "What @KalleOlaviNiemitalo said :)",
                                           "updatedAt":  "2024-10-08T17:21:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6PN8qT",
                                           "createdAt":  "2024-10-09T16:34:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "BehtashShirzad",
                                           "body":  "\u003e Adding a GetExpirationTime method to interface IMemoryCache would be a breaking change. Other new features like [#45593](https://github.com/dotnet/runtime/issues/45593) were added only to class MemoryCache and not to the interface.\n\u003e \n\u003e If the method were added, then the parameter should be `object key`, like in the existing `bool TryGetValue(object key, out object? value)`.\n\u003e \n\u003e MemoryCache supports \"linked entries\" that can expire together with other entries, before their own expiration times. I suppose GetExpirationTime would ignore that feature.\n\u003e \n\u003e There are plans to replace IMemoryCache and MemoryCache, in [#48567](https://github.com/dotnet/runtime/issues/48567). That may make the team less willing to add features to MemoryCache. However, the planned replacement RCache\u003cTKey, TValue\u003e in [dotnet/extensions#4766 (comment)](https://github.com/dotnet/extensions/issues/4766#issuecomment-2341808266) doesn\u0027t have a GetExpirationTime method either.\n\nSo what you suggest for the scenario that you wanna update an object without changing ttl in .net?",
                                           "updatedAt":  "2024-10-09T16:34:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6PP5PV",
                                           "createdAt":  "2024-10-09T19:49:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "You can store a mutable object, and update its fields while it\u0027s referenced by the cache.\n\nIf the actual values you want to store are instances of a value type, then I don\u0027t think this indirection will even cost any extra CPU time or memory: the values would have to be boxed anyway, because MemoryCache is not generic and stores values as `object` references.",
                                           "updatedAt":  "2024-10-09T19:49:19Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "adding a GetExpirationTime(Time-to-Live) method to the IMemoryCache",
        "labels":  [
                       "area-Extensions-Caching"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/111959",
        "createdAt":  "2025-01-29T14:56:54Z",
        "number":  111959,
        "author":  "AkbarDizaji",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODBWONQ==",
                          "nodes":  [
                                        {
                                            "content":  "EYES",
                                            "user":  "julealgon",
                                            "createdAt":  "2025-01-29T15:02:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "vahidvdn",
                                            "createdAt":  "2025-01-30T08:39:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "keivankashani",
                                            "createdAt":  "2025-01-30T12:35:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mehdipayervand",
                                            "createdAt":  "2025-01-30T12:50:42Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "0xfeeddeadbeef",
                                            "createdAt":  "2025-04-18T05:13:24Z"
                                        }
                                    ],
                          "totalCount":  5
                      },
        "updatedAt":  "2025-02-09T02:19:14Z",
        "body":  "### Description\n\nThe current implementation of MemoryCache updates `_cacheSize` using `Interlocked.CompareExchange` in a retry loop (up to 100 times). This creates high contention when multiple threads attempt to modify `_cacheSize`, leading to increased CPU usage and reduced throughput under high concurrency.\n\n```C#\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Caching.Memory;\nusing Microsoft.Extensions.Options;\n\nvar cache = new MemoryCache(Options.Create(new MemoryCacheOptions { SizeLimit = 1000 }));\n\nParallel.For(0, 100, i =\u003e\n{\n    cache.Set(i, i, new MemoryCacheEntryOptions { Size = 10 });\n});\n\nConsole.WriteLine($\"Cache Count: {cache.Count}\"); \n```\n\nIssue: When running with a high number of concurrent threads, CPU usage spikes and cache performance degrades due to frequent retries in UpdateCacheSizeExceedsCapacity.\n\n### Configuration\n.NET Version: .NET 9\nOS: Windows 11\nArchitecture: x64\nMachine Specs: 16-core CPU, 16GB RAM\n### Regression?\n\nNot a regression but a long-standing inefficiency in MemoryCache.\n\n### Data\n\n\u003c!--\n* Please include any benchmark results, images of graphs, timings or measurements, or callstacks that are relevant.\n* If possible please include text as text rather than images (so it shows up in searches).\n* If applicable please include before and after measurements.\n* There is helpful information about measuring code in this repo [here](https://github.com/dotnet/performance/blob/master/docs/benchmarking-workflow-dotnet-runtime.md).\n  --\u003e\n\n### Analysis\n\n Problem:\n\n- Interlocked.CompareExchange retried up to 100 times under contention.\n\n- Causes CPU spikes when multiple threads modify _cacheSize.\n\n- Locks too frequently, slowing down high-throughput applications.\n\n Proposed Fix: \n✅ Use `ConcurrentQueue\u003clong\u003e` for batch updates instead of per-entry updates.\n✅ Process updates asynchronously in a background task, reducing lock contention.\n✅ Minimize atomic operations on `_cacheSize`, improving cache scalability.\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOnbc6hQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6cRy1N",
                                           "createdAt":  "2025-01-29T15:05:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "julealgon",
                                           "body":  "@AkbarDizaji do you know if this _only_ affects the cache `Size` updates and nothing else?",
                                           "updatedAt":  "2025-01-29T15:05:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6cR5cm",
                                           "createdAt":  "2025-01-29T15:15:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AkbarDizaji",
                                           "body":  "@julealgon  Yes. I know this method is just about checking size but it affect on performance because of 100 retries. It can be better",
                                           "updatedAt":  "2025-01-29T15:15:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6cbRzd",
                                           "createdAt":  "2025-01-30T12:38:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "keivankashani",
                                           "body":  "@AkbarDizaji , simple and great suggestion for controlling size limit and multiple retries.\nThanks",
                                           "updatedAt":  "2025-01-30T12:41:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dtzqF",
                                           "createdAt":  "2025-02-09T02:19:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "Marking as https://github.com/dotnet/runtime/labels/help%20wanted for the Future milestone. The change would need to come with assurance that we have proper coverage in [dotnet/performance](https://github.com/dotnet/performance) and an assessment of performance trade-offs required.",
                                           "updatedAt":  "2025-02-09T02:19:12Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "High Contention in MemoryCache _cacheSize Updates Causing Performance Degradation",
        "labels":  [
                       "tenet-performance",
                       "help wanted",
                       "area-Extensions-Caching"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/114011",
        "createdAt":  "2025-03-28T15:27:15Z",
        "number":  114011,
        "author":  "ErisApps",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODPE2jA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "martincostello",
                                            "createdAt":  "2025-03-30T07:41:03Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "WeihanLi",
                                            "createdAt":  "2025-03-31T10:08:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Levi--G",
                                            "createdAt":  "2025-04-01T16:25:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lilinus",
                                            "createdAt":  "2025-04-03T13:59:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Xor-el",
                                            "createdAt":  "2025-04-11T01:31:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Clockwork-Muse",
                                            "createdAt":  "2025-05-23T19:31:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "CSymes",
                                            "createdAt":  "2025-06-12T01:51:36Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mikocot",
                                            "createdAt":  "2025-07-16T12:10:45Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "askbk",
                                            "createdAt":  "2025-07-21T11:31:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "glen-84",
                                            "createdAt":  "2025-07-29T13:56:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "damianh",
                                            "createdAt":  "2025-09-08T12:59:39Z"
                                        }
                                    ],
                          "totalCount":  11
                      },
        "updatedAt":  "2025-08-08T18:03:46Z",
        "body":  "Hii,\n\nI\u0027ve been using TimeProvider (and it\u0027s unit testing equivalent) for some time now and noticed recently that `MemoryCache` still uses the `ISystemClock`, which [I thought was deprecated ](https://learn.microsoft.com/en-us/dotnet/core/compatibility/aspnet-core/8.0/isystemclock-obsolete) (In reality, it\u0027s most likely a copy of it\u0027s equivalent in the ASP.NET Core repo, as it\u0027s part of Microsoft.Extensions.Caching.Abstractions).\n\nI know it\u0027s perfectly possible to just implement a proxy from ISystemClock towards TimeProvider, but I was wondering whether there were any plans to actually deprecate that remaining symbol and transition MemoryCache towards TimeProvider in the BCL altogether? Especially since [HybridCache already uses TimeProvider](https://github.com/dotnet/extensions/blob/d256f6b3c15f358c6b9ad28958900238da4deb9d/src/Libraries/Microsoft.Extensions.Caching.Hybrid/Internal/DefaultHybridCache.cs#L42).",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOvOFx0Q==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc65KxxI",
                                           "createdAt":  "2025-07-23T08:57:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "This seems like a reasonable request that needs to be turned into an API proposal that marks the existing property as obsolete and adds a new property based on `TimeProvider`.",
                                           "updatedAt":  "2025-07-23T08:57:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc65O5p9",
                                           "createdAt":  "2025-07-23T12:13:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEdKH_g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "JensSchadron",
                                                                               "createdAt":  "2025-08-05T12:55:06Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "mikocot",
                                           "body":  "@ErisApps the HybridCache already uses TimeProvider but it seems like it does not even pass it in any way to the MemoryCache, fixing it at the memory cache level as you suggest would definitely make such integrations easier:\n\nsee: https://github.com/dotnet/extensions/issues/6646",
                                           "updatedAt":  "2025-07-23T12:13:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc684XHR",
                                           "createdAt":  "2025-08-08T18:03:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ErisApps",
                                           "body":  "@jeffhandley I\u0027m not sure whether the API design proposal was expected from my end.\n\nBut if I need to do a proposal, I\u0027d propose the following:\n```diff\n public class MemoryCacheOptions\n {\n     ...\n\n     /// \u003csummary\u003e\n     /// Gets or sets the clock used by the cache for expiration.\n     /// \u003c/summary\u003e\n+    [Obsolete(\"Please use TimeProvider property instead. If both Clock and TimeProvider are set, TimeProvider will be used for expiration.\")]\n     public ISystemClock? Clock { get; set; }\n\n+    /// \u003csummary\u003e\n+    /// Gets or sets the time provider used by the cache for expiration.\n+    /// \u003c/Summary\u003e\n+    public TimeProvider? TimeProvider { get; set; }\n\n     ...\n }\n``` \n\nSubsequently, in the underlying implementation of MemoryCache, we could do something along the lines of:\n```diff\n public class MemoryCache\n {\n     ...\n    \n-    private DateTime UtcNow =\u003e _options.Clock?.UtcNow.UtcDateTime ?? DateTime.UtcNow;\n+    private DateTime UtcNow =\u003e _options.TimeProvider?.GetUtcNow().UtcDateTime ?? _options.Clock?.UtcNow.UtcDateTime ?? DateTime.UtcNow;\n\n     ...\n }\n```\n\nHowever, I do realize that this is just a simple replacement which might incur a bit more overhead on every check for UtcNow within the `MemoryCache` implemention.\nMaybe it\u0027s more beneficial to write an `ISystemClock` adapter for `TimeProvider` alongside the MemoryCacheOptions implementation change instead to reduce overhead in case the user doesn\u0027t specify neither `ISystemClock` nor `TimeProvider`?\n\nHowever, that poses the question instead whether the UtcNow provider is supposed to immutable once the MemoryCache instance has been created? If it can/may be, then it could be possible to just do something the lines of this in the MemoryCache implementation instead.\n\n```diff\n public class MemoryCache\n {\n     ...\n\n+    private readonly TimeProvider _timeProvider;\n\n     ...\n    \n     public MemoryCache(IOptions\u003cMemoryCacheOptions\u003e optionsAccessor, ILoggerFactory loggerFactory)\n     {\n         ArgumentNullException.ThrowIfNull(optionsAccessor);\n         ArgumentNullException.ThrowIfNull(loggerFactory);\n\n         _options = optionsAccessor.Value;\n         _logger = loggerFactory.CreateLogger\u003cMemoryCache\u003e();\n        \n+       if (_options.TimeProvider != null)\n+       {\n+           _timeProvider = _options.TimeProvider;\n+       }\n+       else if (_options.Clock != null)\n+       {\n+           _timeProvider = new SystemClockTimeProviderAdapter(_options.Clock);\n+       }\n+       else\n+       {\n+           _timeProvider = TimeProvider.System;\n+       }\n\n         ...\n     }\n\n-    private DateTime UtcNow =\u003e _options.Clock?.UtcNow.UtcDateTime ?? DateTime.UtcNow;\n+    private DateTime UtcNow =\u003e _timeProvider.GetUtcNow().UtcDateTime;\n\n     ...\n }\n```\n\nand\n```diff\n+ /// \u003csummary\u003e\n+ /// An adapter used for switching over from ISystemClock to TimeProvider.\n+ /// The primary use case of this class usage of this class is intended for use within MemoryCache\n+ /// \u003c/summary\u003e\n+ internal sealed class SystemClockTimeProviderAdapter : TimeProvider\n+ {\n+     private readonly ISystemClock _clock;\n+\n+     public SystemClockTimeProviderAdapter(ISystemClock clock)\n+     {\n+         ArgumentNullException.ThrowIfNull(clock);\n+         _clock = clock;\n+     }\n+\n+     /// \u003cinheritdoc /\u003e\n+     public override DateTimeOffset GetUtcNow() =\u003e _clock.UtcNow;\n+\n+     /// \u003cinheritdoc /\u003e\n+     public override long GetTimestamp() =\u003e throw new NotSupportedException();\n+\n+     /// \u003cinheritdoc /\u003e\n+     public override TimeZoneInfo LocalTimeZone =\u003e throw new NotSupportedException();\n+\n+     /// \u003cinheritdoc /\u003e\n+     public override long TimestampFrequency =\u003e throw new NotSupportedException();\n+\n+     /// \u003cinheritdoc /\u003e\n+     public override ITimer CreateTimer(TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period) =\u003e throw new NotSupportedException();\n+ }\n```\n\nPlease note that I throw a NotSupportedException for the properties and methods of that aren\u0027t exepected to be used within the MemoryCache implementation. \n\nPlease let me know if any further action is required from my end. Just fyi, I wouldn\u0027t mind attempting to contribute a PR for this if the proposal gets accepted. 🙂 ",
                                           "updatedAt":  "2025-08-08T18:03:30Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Adopting TimeProvider in MemoryCache",
        "labels":  [
                       "area-Extensions-Caching",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/114366",
        "createdAt":  "2025-04-08T07:09:40Z",
        "number":  114366,
        "author":  "bebo-dot-dev",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODRNAPw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jodydonetti",
                                            "createdAt":  "2025-09-17T09:04:19Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-07-25T12:40:37Z",
        "body":  "### Description\n\n`HybridCache` and `HybridCacheEntryOptions` currently has no support for assigning a size to cached items to enable `HybridCache` to work in harmony with [MemoryCacheOptions.SizeLimit](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/memory?view=aspnetcore-9.0#use-setsize-size-and-sizelimit-to-limit-cache-size).\n\nThis means that use of L1 cache with ~~`HybridCache`~~ `FusionHybridCache` results in unbounded memory use and this is the issue that we\u0027re currently experiencing when using ~~`HybridCache`~~ `FusionHybridCache`\n\nIn addition [HybridCacheEntryOptions](https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.Caching.Abstractions/src/Hybrid/HybridCacheEntryOptions.cs) is sealed which prevents other implementers of `HybridCache` (i.e. [FusionCache](https://github.com/ZiggyCreatures/FusionCache/blob/main/src/ZiggyCreatures.FusionCache/MicrosoftHybridCache/FusionHybridCache.cs)) from extending `HybridCacheEntryOptions` to support size.\n\nDid I miss something or are there plans to further improve the surface of this API?\n\nMany thanks, \nJoe",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOudNk3A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6mBrDT",
                                           "createdAt":  "2025-04-08T07:10:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-extensions-caching\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-04-08T07:10:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mOlY7",
                                           "createdAt":  "2025-04-09T08:51:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mgravell",
                                           "body":  "On size: the dotnet/extensions version of `HybridCache` uses the serialized payload size to assign a value for size; it should *already \"just work\"*; could you perhaps expand on what you\u0027re seeing?",
                                           "updatedAt":  "2025-04-09T08:51:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mRmS6",
                                           "createdAt":  "2025-04-09T13:02:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bebo-dot-dev",
                                           "body":  "\u003e On size: the dotnet/extensions version of HybridCache uses the serialized payload size to assign a value for size; it should already \"just work; could you perhaps expand on what you\u0027re seeing?\"\n\nUsing `FusionCache` as `HybridCache` is where we had an issue with unbounded `MemoryCache` memory usage because there\u0027s currently no way to specify `Size` through `HybridCacheEntryOptions` and the [FusionCache](https://github.com/ZiggyCreatures/FusionCache/blob/main/src/ZiggyCreatures.FusionCache/MicrosoftHybridCache/FusionHybridCache.cs) flavour of `HybridCache` doesn\u0027t perform any automatic determination of cache item size.\n\nWhat you said about the .NET HybridCache using serialized payload size for cache item Size is interesting because FusionCache doesn\u0027t do this. On the the face it, FusionHybridCache has different behaviour to how the .NET HybridCache behaves around cache item Size.\n\nHowever having said that automatic calculation/determination of Size for L1 cache items seems to go against [the MemoryCache docs](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/memory?view=aspnetcore-9.0#use-setsize-size-and-sizelimit-to-limit-cache-size) which say:\n\n\u003e _The cache size limit doesn\u0027t have a defined unit of measure because the cache has no mechanism to measure the size of entries_.  \n\nand also \n\n\u003e _SizeLimit doesn\u0027t have units. Cached entries must specify size in whatever units they consider most appropriate if the cache size limit has been set. All users of a cache instance should use the same unit system._\n\nTo put this another way the docs suggest that once a `SizeLimit` of arbitrary units has been assigned to a `MemoryCache` via `MemoryCacheOptions`, the onus is on the caller when adding an item to the cache to set `Size` on a cache item to an appropriate size of arbitrary units. I suppose the arbitrary unit system in use could mean / be equal to the serialized cache item size in bytes or I guess it could be something else entirely.\n\nIt might be ideal if both `SizeLimit` and `Size` could be trusted to be bytes and considered to always be bytes because automatic determination/calculation of `Size` would then work. This isn\u0027t what the `MemoryCache` docs say today however so there seems to be a gap in the `HybridCache` API surface because there\u0027s no way to pass `Size` through `HybridCacheOptions`. \n\nSo perhaps this really is a problem or possibly the [the MemoryCache docs](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/memory?view=aspnetcore-9.0#use-setsize-size-and-sizelimit-to-limit-cache-size) are wrong, the `HybridCacheOptions` code contract is fine as it stands and `FusionCache` needs to trust that `SizeLimit` and `Size` are bytes and determine `Size` at runtime based on the size of a cache item in bytes?",
                                           "updatedAt":  "2025-04-09T13:04:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mSZ9E",
                                           "createdAt":  "2025-04-09T14:00:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOENlABg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jodydonetti",
                                                                               "createdAt":  "2025-04-09T17:08:43Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "mgravell",
                                           "body":  "It is perhaps something we should explore. Putting the size on the *options* is awkward because it isn\u0027t necessarily try that you know the size in advance - it could be hugely contextual (when I was at Stack Overflow, we called this the \"Jon Skeet problem\" - some data could be heavily skewed based on the inputs) If anything, I wonder whether this ties into some other topics like setting the expiration based on the payload. Kind of like:\n\n``` c#\nvar blah = cache.GetOrCreateAsync($\"foos/{region}/{id}\", async ctx =\u003e {\n    // blah await blah\n    ctx.Size = 42; // if not done, uses existing approach\n    ctx.CacheDuration = TimeSpan.FromMinutes(10); // defaults to time via options\n\n    return someValue;\n});\n```\n\nThe *problem* is how to squeeze this into the existing API without causing ambiguity; we already have overloads that take `Func\u003cCancellationToken, ValueTask\u003cT\u003e\u003e` and `Func\u003cTState, CancellationToken, ValueTask\u003cT\u003e\u003e`, so to avoid lambda ambiguity, we\u0027d need to use a triplet arg - something like:\n\n``` c#\nvar blah = cache.GetOrCreateAsync($\"foos/{region}/{id}\", (region, id), async (ctx, state, ct) =\u003e {\n    // blah await blah\n    ctx.Size = 42; // if not done, uses existing approach\n    ctx.CacheDuration = TimeSpan.FromMinutes(10); // defaults to time via options\n\n    return someValue;\n});\n```\n\nWhere `ctx` here is some `CacheContext`  type.\n\n---\n\nAnother approach might be to have an `IHybridCacheItem` interface that the result `T` could optionally implement, allowing the *existing* API to pass some values back out, for example:\n\n``` c#\n[ImmutableObject(true)] // enables L1 object reuse, i.e. don\u0027t deserialize repeatedly\nsealed class CustomerCacheItem(int id, string name, ...) : IHybridCacheItem\n{\n    int? IHybridCacheItem.Size =\u003e 100 * orders.Length;\n    TimeSpan IHybridCacheItem.CacheDuration =\u003e IsVIP ? TimeSpan.FromMinutes(1) : TimeSpan.FromMinutes(10);\n}\n```\n\nwith the library type-testing for `IHybridCacheItem` and applying things on the way *out*.\n\n---\n\nI\u0027m just thinking aloud here; all input welcome.",
                                           "updatedAt":  "2025-04-09T14:01:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mSkyZ",
                                           "createdAt":  "2025-04-09T14:13:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mgravell",
                                           "body":  "I also tried some things with `[OverloadResolutionPriority]`, which *works-ish*, but is a pain because we can\u0027t use partial naming in the lambda; we can get `(CacheContext ctx) =\u003e ...` to be preferred, but we can\u0027t do `(TState state, CacheContext ctx)` without explicitly naming the `TState`, which is usually inconvenient and sometimes impossible; of course, we could just use a different name:\n\n``` c#\nusing Microsoft.Extensions.Caching.Hybrid;\n\nvar obj = new Foo();\nint id = 42;\nstring name = \"abc\";\nvar x = await obj.GetOrCreateAsync($\"foos/{id}/{name}\", async ct =\u003e await GetAsync(id, ct));\nvar y = await obj.GetOrCreateAsync($\"foos/{id}/{name}\", (id, name), static async (state, ct) =\u003e await GetAsync(state.id, ct));\nvar z = await obj.GetOrCreateAsync2($\"foos/{id}/{name}\", (id, name), static async (state, ctx) =\u003e\n{\n    var value = await GetAsync(42, ctx.CancellationToken);\n    ctx.Size = 100 * value.Length;\n    ctx.CacheDuration = TimeSpan.FromSeconds(10);\n    return value;\n});\n\n\nstatic ValueTask\u003cstring\u003e GetAsync(int i, CancellationToken cancellationToken = default) =\u003e default;\nclass Foo\n{\n\n    public ValueTask\u003cT\u003e GetOrCreateAsync\u003cT\u003e(string key, Func\u003cCancellationToken, ValueTask\u003cT\u003e\u003e factory,\n        HybridCacheEntryOptions? options = null, IEnumerable\u003cstring\u003e? tags = null, CancellationToken cancellationToken = default)\n        =\u003e default;\n    public ValueTask\u003cT\u003e GetOrCreateAsync\u003cT, TState\u003e(string key, TState state, Func\u003cTState, CancellationToken, ValueTask\u003cT\u003e\u003e factory,\n        HybridCacheEntryOptions? options = null, IEnumerable\u003cstring\u003e? tags = null, CancellationToken cancellationToken = default)\n        =\u003e default;\n\n    public ValueTask\u003cT\u003e GetOrCreateAsync2\u003cT, TState\u003e(string key, TState state, Func\u003cTState, CacheContext, ValueTask\u003cT\u003e\u003e factory,\n        HybridCacheEntryOptions? options = null, IEnumerable\u003cstring\u003e? tags = null, CancellationToken cancellationToken = default)\n        =\u003e default;\n}\npublic class CacheContext(CancellationToken cancellationToken, TimeSpan cacheDuration)\n{\n    public int? Size { get; set; }\n    public TimeSpan CacheDuration { get; set; } = cacheDuration;\n    public CancellationToken CancellationToken =\u003e cancellationToken; \n}\n```\n\n",
                                           "updatedAt":  "2025-04-09T14:15:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mUlU-",
                                           "createdAt":  "2025-04-09T17:07:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jodydonetti",
                                           "body":  "Hi @bebo-dot-dev \n\n\u003e Using `FusionCache` as `HybridCache` is where we had an issue with unbounded `MemoryCache` memory usage because there\u0027s currently no way to specify `Size` through `HybridCacheEntryOptions` and the [FusionCache](https://github.com/ZiggyCreatures/FusionCache/blob/main/src/ZiggyCreatures.FusionCache/MicrosoftHybridCache/FusionHybridCache.cs) flavour of `HybridCache` doesn\u0027t perform any automatic determination of cache item size.\n\u003e \n\u003e What you said about the .NET HybridCache using serialized payload size for cache item Size is interesting because FusionCache doesn\u0027t do this.\n\nThat\u0027s because... I didn\u0027t know about such behaviour 😅\n\n@mgravell is it documented somewhere, just to be sure I can implement it in the right way? It\u0027s \"just\" the \"length in bytes\"?\n\nAlso, that\u0027s because serialization may not happen without L2: I know HC serialize always, even with just L1, to avoid returning a \"live instance\", but what if that is disabled? Btw: I remember it being a possibility, I mean to disable the auto cloning, is this still a thing in the GA version?\n\n\u003e On the the face it, FusionHybridCache has different behaviour to how the .NET HybridCache behaves around cache item Size.\n\nIf desired and if there\u0027s a \"spec\" or similar I can of course align the impl, more than happy to have the same behaviour as much as possible!\n\n\u003e However having said that automatic calculation/determination of Size for L1 cache items seems to go against [the MemoryCache docs](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/memory?view=aspnetcore-9.0#use-setsize-size-and-sizelimit-to-limit-cache-size) which say:\n\u003e [...]\n\u003e To put this another way the docs suggest that once a `SizeLimit` of arbitrary units has been assigned to a `MemoryCache` via `MemoryCacheOptions`, the onus is on the caller when adding an item to the cache to set `Size` on a cache item to an appropriate size of arbitrary units. I suppose the arbitrary unit system in use could mean / be equal to the serialized cache item size in bytes or I guess it could be something else entirely.\n\nYeah I guess (my 2 cents) it can be a defined behaviour, something like \"when using HC the Size is calculated this way, that\u0027s it\".\nOr, at least, it can be the default in case it\u0027s something that Marc \u0026 the team want to change this.\n\n\u003e It might be ideal if both `SizeLimit` and `Size` could be trusted to be bytes and considered to always be bytes because automatic determination/calculation of `Size` would then work. This isn\u0027t what the `MemoryCache` docs say today however so there seems to be a gap in the `HybridCache` API surface because there\u0027s no way to pass `Size` through `HybridCacheOptions`.\n\nBecause as of today the underlying MemoryCache is taken from the DI container as-is, so it can\u0027t change it after getting it and/or it\u0027s there (during DI setup) where you may configure it.\n\nThoughts?",
                                           "updatedAt":  "2025-05-25T17:31:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mUtfQ",
                                           "createdAt":  "2025-04-09T17:23:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jodydonetti",
                                           "body":  "\u003e It is perhaps something we should explore. Putting the size on the _options_ is awkward because it isn\u0027t necessarily try that you know the size in advance - it could be hugely contextual (when I was at Stack Overflow, we called this the \"Jon Skeet problem\" - some data could be heavily skewed based on the inputs) If anything, I wonder whether this ties into some other topics like setting the expiration based on the payload. Kind of like:\n\u003e \n\u003e var blah = cache.GetOrCreateAsync($\"foos/{region}/{id}\", async ctx =\u003e {\n\u003e     // blah await blah\n\u003e     ctx.Size = 42; // if not done, uses existing approach\n\u003e     ctx.CacheDuration = TimeSpan.FromMinutes(10); // defaults to time via options\n\u003e \n\u003e     return someValue;\n\u003e });\n\u003e The _problem_ is how to squeeze this into the existing API without causing ambiguity; we already have overloads that take `Func\u003cCancellationToken, ValueTask\u003cT\u003e\u003e` and `Func\u003cTState, CancellationToken, ValueTask\u003cT\u003e\u003e`, so to avoid lambda ambiguity, we\u0027d need to use a triplet arg - something like:\n\u003e \n\u003e var blah = cache.GetOrCreateAsync($\"foos/{region}/{id}\", (region, id), async (ctx, state, ct) =\u003e {\n\u003e     // blah await blah\n\u003e     ctx.Size = 42; // if not done, uses existing approach\n\u003e     ctx.CacheDuration = TimeSpan.FromMinutes(10); // defaults to time via options\n\u003e \n\u003e     return someValue;\n\u003e });\n\u003e Where `ctx` here is some `CacheContext` type.\n\nFWIW that\u0027s what I did in FusionCache (see [Adaptive Caching](https://github.com/ZiggyCreatures/FusionCache/blob/main/docs/AdaptiveCaching.md)), anche the community likes that a lot.\n\n\u003e Another approach might be to have an `IHybridCacheItem` interface that the result `T` could optionally implement, allowing the _existing_ API to pass some values back out, for example:\n\u003e \n\u003e [ImmutableObject(true)] // enables L1 object reuse, i.e. don\u0027t deserialize repeatedly\n\u003e sealed class CustomerCacheItem(int id, string name, ...) : IHybridCacheItem\n\u003e {\n\u003e     int? IHybridCacheItem.Size =\u003e 100 * orders.Length;\n\u003e     TimeSpan IHybridCacheItem.CacheDuration =\u003e IsVIP ? TimeSpan.FromMinutes(1) : TimeSpan.FromMinutes(10);\n\u003e }\n\u003e with the library type-testing for `IHybridCacheItem` and applying things on the way _out_.\n\u003e \n\u003e I\u0027m just thinking aloud here; all input welcome.\n\nCorrect, that\u0027s another approach, but this limits it to types \"owned\" but the caller, and a lot of times the adaptability is not based on the type but on usage, meaning that I may want that with a cache entry of type int, string, etc, not necessarily my own `Person` class.\n\nMy 2 cents.",
                                           "updatedAt":  "2025-04-09T17:23:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mUvCs",
                                           "createdAt":  "2025-04-09T17:25:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jodydonetti",
                                           "body":  "\u003e However having said that automatic calculation/determination of Size for L1 cache items seems to go against [the MemoryCache docs](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/memory?view=aspnetcore-9.0#use-setsize-size-and-sizelimit-to-limit-cache-size) which say:\n\u003e [...]\n\u003e It might be ideal if both `SizeLimit` and `Size` could be trusted to be bytes and considered to always be bytes because automatic determination/calculation of `Size` would then work. This isn\u0027t what the `MemoryCache` docs say today however so there seems to be a gap in the `HybridCache` API surface because there\u0027s no way to pass `Size` through `HybridCacheOptions`.\n\u003e \n\u003e So perhaps this really is a problem or possibly the [the MemoryCache docs](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/memory?view=aspnetcore-9.0#use-setsize-size-and-sizelimit-to-limit-cache-size) are wrong, the `HybridCacheOptions` code contract is fine as it stands and `FusionCache` needs to trust that `SizeLimit` and `Size` are bytes and determine `Size` at runtime based on the size of a cache item in bytes?\n\nAnyway this is, in fact, quite delicate: deciding on something specific may reduce flexibility quite a bit, in case that\u0027s then needed... some brainstorming needed here...",
                                           "updatedAt":  "2025-04-09T18:29:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mV0BJ",
                                           "createdAt":  "2025-04-09T19:06:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bebo-dot-dev",
                                           "body":  "Having read more docs, my takeaway is that the [.NET HybridCache docs](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/hybrid?view=aspnetcore-9.0#cache-storage) confirm that the .NET HybridCache uses the same `MemoryCache` for L1 that `FusionCache` also uses.\n\nAt the same time the .NET HybridCache manages to satisfy the rules of [the MemoryCache docs](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/memory?view=aspnetcore-9.0#use-setsize-size-and-sizelimit-to-limit-cache-size) and assume that the serialized payload size of a cache item is a valid value for `Size` for an item stored in L1 cache.\n\nWhat is interesting is that there\u0027s no mention in the [.NET HybridCache docs](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/hybrid?view=aspnetcore-9.0#cache-storage) how / where the L1 MemoryCache `SizeLimit` is set or where the responsibility for doing this lies so it\u0027s not 100% clear what MemoryCache \"arbitrary units\" means to the .NET HybridCache. However since it\u0027s able to work in bytes and use the serialized payload size of a cache item, I assume that it in it\u0027s own view, `SizeLimit` and `Size` are trusted to be bytes and considered to always be bytes and it\u0027s this which enables it to work the way that it does around sizing cache items in L1.\n\nI think I\u0027m with you @jodydonetti, there may be a \"spec\" somewhere or perhaps codified rules baked into the .NET HybridCache that explain how it manages to work the way that it does with `MemoryCache`.",
                                           "updatedAt":  "2025-04-09T19:06:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mWHSl",
                                           "createdAt":  "2025-04-09T19:39:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jodydonetti",
                                           "body":  "\u003e Having read more docs, my takeaway is that the [.NET HybridCache docs](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/hybrid?view=aspnetcore-9.0#cache-storage) confirm that the .NET HybridCache uses the same `MemoryCache` for L1 that `FusionCache` also uses.\n\nYup, can confirm.\n\nOr, to be more precise (nitpicking corner here): both HybridCache and (current) FusionCache both use `IMemoryCache` as the L1, not necessarily the same _instance_ if you use them both together for whatever reasons.\n\nHybridCache (currently) always uses the `IMemoryCache` instance returned via DI, while FusionCache can use that, or can accept a different instance provided by the user or via a builder, etc (see [here](https://github.com/ZiggyCreatures/FusionCache/blob/main/docs/DependencyInjection.md)).\n\nJust wanted to point out it\u0027s not \"the same\" instance.\n\n\u003e What is interesting is that there\u0027s no mention in the [.NET HybridCache docs](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/hybrid?view=aspnetcore-9.0#cache-storage) how / where the L1 MemoryCache `SizeLimit` is set or where the responsibility for doing this lies so it\u0027s not 100% clear what MemoryCache \"arbitrary units\" means to the .NET HybridCache. However since it\u0027s able to work in bytes and use the serialized payload size of a cache item, I assume that it in it\u0027s own view, `SizeLimit` and `Size` are trusted to be bytes and considered to always be bytes and it\u0027s this which enables it to work the way that it does around sizing cache items in L1.\n\n@mgravell can correct me if I\u0027m wrong, but I think that he set the `Size` in each cache entry so that, IF a user has set a `SizeLimit` on the DI-provided `IMemoryCache`, HybridCache would not start throwing exceptions (that is what happens with `MemoryCache` when you set a `SizeLimit` but fail to provide a `Size` for even 1 cache entry.\n\nMeaning: if, as is the default, a `SizeLimit` is not configured -\u003e nothing happens anyway.\n\nOn my hand instead (FusionCache), you can specify an `IMemoryCache` instance, and maybe set a `SizeLimit`: if you do so, you then MUST set some `Size`, otherwise you\u0027d be asking to set a limit without providing a way to check that limit.\n\n\u003e I think I\u0027m with you [@jodydonetti](https://github.com/jodydonetti), there may be a \"spec\" somewhere or perhaps codified rules baked into the .NET HybridCache that explain how it manages to work the way that it does with `MemoryCache`.\n\nYes that would be nice.\n\nAnyway, and maybe not the best place here (but it may be interesting for future 3rd party HC impls), when using the FC-HC adapter, the initial setup is the FC one (meaning: more control over which L1 to use etc), so my question is: would it make sense to add support for automatically calculating the `Size` based on the binary payload size in bytes or not? With FC you can avoid the forced serialization, and therefore there would be no bytes to count... so?\n\nAny thoughts may be helpful on both sides, and future 3rd party implementers.",
                                           "updatedAt":  "2025-04-10T05:53:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mWLyE",
                                           "createdAt":  "2025-04-09T19:49:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bebo-dot-dev",
                                           "body":  "\u003e Meaning: if, as is the default, a SizeLimit is not configured -\u003e nothing happens anyway.\n\nMany things are not known to me but there is one thing that I know for certain; if _something_ doesn\u0027t set a `SizeLimit` on `MemoryCache` it is a surefire way to using all available memory. I found this out the hard way just a few days ago 😊",
                                           "updatedAt":  "2025-04-09T19:49:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mteqR",
                                           "createdAt":  "2025-04-11T13:36:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jodydonetti",
                                           "body":  "\u003e Many things are not known to me but there is one thing that I know for certain; if _something_ doesn\u0027t set a `SizeLimit` on `MemoryCache` it is a surefire way to using all available memory. I found this out the hard way just a few days ago 😊\n\nI _think_ I get what you are saying, but just to be sure we are on the same page about \"using all available memory\": if you properly set a reasonable duration, a MemoryCache will not grow forever since internally the removal of expired entries is taken care of automatically, see [here](https://gist.github.com/jodydonetti/91cf185f44a484379c3b833eeaa804e5) for an example.\n\nThe option to pilot that internal scan for expired entries is [`MemoryCacheOptions.ExpirationScanFrequency`](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.caching.memory.memorycacheoptions.expirationscanfrequency?view=net-9.0-pp#microsoft-extensions-caching-memory-memorycacheoptions-expirationscanfrequency), and after that time a scan for internal removal will start right after the first get/set/remove operation is called (so, not just \"after the specified frequency\").\n\nSetting a `SizeLimit` prevents you from adding entries that you are anyway explicitly asking to be added.\n\nAgain, maybe we were already on the same page, but just to be 100% sure.",
                                           "updatedAt":  "2025-04-11T13:36:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mu8Ey",
                                           "createdAt":  "2025-04-11T15:54:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bebo-dot-dev",
                                           "body":  "Thanks for that @jodydonetti, to clarify / add a bit more detail, we encountered the unbounded memory usage problem with FusionCache L1 during a load test which admittedly is an extreme way but a necessary way to test. \n\nExpiry duration was set to 10 minutes on cache items which is a real world config value for our load test scenario but memory was being consumed quicker than it was being freed up.\n\nI suppose it can be argued that there\u0027s a balance to be struck between choosing a reasonable expiry duration for a load test which may be a lower duration vs a normal system operation duration but as I said we needed to load test in a semi real-world fashion.\n\nMy view is what happened was a self inflicted problem because [the memory cache docs](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/memory?view=aspnetcore-9.0#use-setsize-size-and-sizelimit-to-limit-cache-size) advise:\n\n\u003e If [SizeLimit](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.caching.memory.memorycacheoptions.sizelimit#microsoft-extensions-caching-memory-memorycacheoptions-sizelimit) isn\u0027t set, the cache grows without bound. The ASP.NET Core runtime doesn\u0027t trim the cache when system memory is low. Apps must be architected to:\n\n\u003e * Limit cache growth.\n\u003e * Call [Compact](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.caching.memory.memorycache.compact) or [Remove](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.caching.memory.memorycache.remove) when available memory is limited.\n\nOr to paraphrase the docs if you don\u0027t put a lid on how much memory the L1 is allowed to use, you only have your self to blame if / when it uses all available RAM :)",
                                           "updatedAt":  "2025-04-11T15:55:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mvOk0",
                                           "createdAt":  "2025-04-11T16:24:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jodydonetti",
                                           "body":  "\u003e My view is what happened was a self inflicted problem because [the memory cache docs](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/memory?view=aspnetcore-9.0#use-setsize-size-and-sizelimit-to-limit-cache-size) advise:\n\u003e \n\u003e \u003e If [SizeLimit](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.caching.memory.memorycacheoptions.sizelimit#microsoft-extensions-caching-memory-memorycacheoptions-sizelimit) isn\u0027t set, the cache grows without bound. The ASP.NET Core runtime doesn\u0027t trim the cache when system memory is low. Apps must be architected to:\n\u003e \u003e \n\u003e \u003e * Limit cache growth.\n\u003e \u003e * Call [Compact](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.caching.memory.memorycache.compact) or [Remove](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.caching.memory.memorycache.remove) when available memory is limited.\n\u003e \n\u003e Or to paraphrase the docs if you don\u0027t put a lid on how much memory the L1 is allowed to use, you only have your self to blame if / when it uses all available RAM :)\n\nCorrect, the growth would be \"without bound\" if you keep adding new stuff: of course after expiration hits, it will go down.\nGlad we are on the same page :-)",
                                           "updatedAt":  "2025-04-11T16:24:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6m09gq",
                                           "createdAt":  "2025-04-12T16:43:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jodydonetti",
                                           "body":  "Wait a sec, I have a doubt: @mgravell can you clarify one thing?\n\nWhen caching immutable objects with only L1 (no L2), if I remember correctly the theory was that serialization would not have been needed, as an optimization, correct? If so, how is the size calculated in that case?",
                                           "updatedAt":  "2025-04-12T16:43:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6nyNJ7",
                                           "createdAt":  "2025-04-18T08:55:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bebo-dot-dev",
                                           "body":  "Hi @jodydonetti \n\nToday I decided to have a decompile and debug inside the .NET `DefaultHybridCache` implementation and found that cache items stored in L1 are pre-serialized. This is how it manages to auto-determine the size of cache items stored in the L1 memory cache.\n\nI followed the debug stack and found that the code path for a new cache item is through a method called `TrySerialize\u003cT\u003e` in `DefaultHybridCache.cs` which serializes and allocates a buffer for the size of the item. Following this, the item is converted to an immutable `DefaultHybridCache.CacheItem\u003cT\u003e` with the size assigned to it and then finally a method called `SetL1` is called which converts the `DefaultHybridCache.CacheItem\u003cT\u003e` to an `ICacheEntry` and the size is assigned to the `ICacheEntry`\n\nI understand this analysis might be slightly hard to follow, unfortunately I\u0027m unable to find the source code for `DefaultHybridCache.cs`. That said I do think this sheds some light on how the .NET `DefaultHybridCache` manages to work with an L1 memory cache that has had `SetSize` configured on it without the need for cache item sizes to be explicitly supplied via `HybridCacheEntryOptions` or by any other means.\n\nThere could be an argument to say that the `DefaultHybridCache` shouldn\u0027t work like this by default and that this `TrySerialize\u003cT\u003e` pre-serialize for storage in L1 behaviour should be opt-in but this is how I\u0027ve found it is at the moment.",
                                           "updatedAt":  "2025-04-18T08:55:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6nyoHD",
                                           "createdAt":  "2025-04-18T09:26:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEO2P1g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "bebo-dot-dev",
                                                                               "createdAt":  "2025-04-18T09:38:13Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jodydonetti",
                                           "body":  "The code for the abstraction (`public abstract class HybridCache`) is in dotnet/runtime, the code for the default implementation (`internal class DefaultHybridCache`) is in dotnet/extensions, [here](https://github.com/dotnet/extensions/tree/main/src/Libraries/Microsoft.Extensions.Caching.Hybrid/Internal).",
                                           "updatedAt":  "2025-04-18T09:26:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6nypRr",
                                           "createdAt":  "2025-04-18T09:28:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jodydonetti",
                                           "body":  "\u003e I followed the debug stack and found that the code path for a new cache item is through a method called `TrySerialize\u003cT\u003e` in `DefaultHybridCache.cs` which serializes and allocates a buffer for the size of the item. Following this, the item is converted to an immutable `DefaultHybridCache.CacheItem\u003cT\u003e` with the size assigned to it and then finally a method called `SetL1` is called which converts the `DefaultHybridCache.CacheItem\u003cT\u003e` to an `ICacheEntry` and the size is assigned to the `ICacheEntry`\n\nThat\u0027s what I thought, but I\u0027m wondering about forcing allocations even when they are not needed. Maybe it\u0027s just a v1 thing, in the future an option may be added to avoid this?",
                                           "updatedAt":  "2025-04-18T09:28:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6nywug",
                                           "createdAt":  "2025-04-18T09:49:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bebo-dot-dev",
                                           "body":  "\u003e Maybe it\u0027s just a v1 thing, in the future an option may be added to avoid this?\n\nPotentially/hopefully which is why I opened this issue for discussion and I think it\u0027s sort of in the ballpark of @mgravell.\n\nPersonally I like the factory / callback approach for setting size and I\u0027m not sure that Fusioncache should try and fix anything by emulating what DefaultHybridCache does but that\u0027s in your ballpark ;)\n\nThe problem at the moment though is that FusionHybridCache is broken for any serious usage scenarios because it\u0027s very easy to unintentionally use too much memory with it.",
                                           "updatedAt":  "2025-04-18T09:49:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6n1fp6",
                                           "createdAt":  "2025-04-18T16:37:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jodydonetti",
                                           "body":  "\u003e Personally I like the factory / callback approach for setting size and I\u0027m not sure that Fusioncache should try and fix anything by emulating what DefaultHybridCache does but that\u0027s in your ballpark ;)\n\nAgree, but if I\u0027m able to _\"smooth things out\"_ for some common scenarios I\u0027d gladly do it :-)\n\n\u003e The problem at the moment though is that FusionHybridCache is broken for any serious usage scenarios because it\u0027s very easy to unintentionally use too much memory with it.\n\nCouldn\u0027t disagree more 😅\nI think I\u0027ve _never_ set a `SizeLimit` in my career, and I\u0027ve worked on some pretty big systems, with Redis/Memcached instances in the order of millions of entries. I just carefully set reasonable values for the `Duration`.\n\nOn the other hand though, it\u0027s true that if the underlying `MemoryCache` you pass to FusionCache has a `SizeLimit` set, and you use it via the HybridCache adapter, then there\u0027s currently no way to work with that. But, also, you would not be forced to serialize every single entry, so if the issue is memory usage there\u0027s also that to consider.",
                                           "updatedAt":  "2025-04-18T16:37:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6n1lM4",
                                           "createdAt":  "2025-04-18T16:52:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mgravell",
                                           "body":  "It is awkward to discover whether the L2 is configured to require size. If we are willing to get a bit sneaky, we could:\n\n- try sniffing DI for the memory cache options, to see if the size limit is set\n- try an experimental assignment to L1 without size, to see if it gets accepted",
                                           "updatedAt":  "2025-04-18T16:52:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6n3qxI",
                                           "createdAt":  "2025-04-19T00:19:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jodydonetti",
                                           "body":  "\u003e It is awkward to discover whether the L2 is configured to require size. If we are willing to get a bit sneaky, we could:\n\u003e \n\u003e * try sniffing DI for the memory cache options, to see if the size limit is set\n\u003e * try an experimental assignment to L1 without size, to see if it gets accepted\n\nSome time ago for FC I tried to get the same info and... yeah, that was weird 😅\n\nFWIW I haven\u0027t tried with the first approach (sniffing DI) because:\n- to support the good old direct `new` instantiation, I don\u0027t rely on the fact that there\u0027s DI at all\n- it is possible to pass an `IMemoryCache` instance directly\n- with multiple cache instances, which one to look for in DI?\n- it felt a little fragile/not future proof\n\nSo I tried with the second approach: just add something (with a `Guid.NewGuid()` key) without a `Size` and see if it fails, then remove it. If I remember correctly it worked, but I was not sure that the only case in which an `InvalidOperationException` would\u0027ve been thrown was that specific one (ok, you can also do a \"contains\" on the exc msg, but, mmh).\n\nFinally, just \"for fun\", I tried with reflection: it \"worked\", but, oh dear thanks but no thanks.",
                                           "updatedAt":  "2025-04-19T00:19:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6502Tc",
                                           "createdAt":  "2025-07-25T12:40:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mgravell",
                                           "body":  "(if someone could unassign me, that\u0027d be awesome, thx)",
                                           "updatedAt":  "2025-07-25T12:40:12Z"
                                       }
                                   ],
                         "totalCount":  23
                     },
        "title":  "FusionHybridCache and L1 memory usage",
        "labels":  [
                       "tenet-performance",
                       "area-Extensions-Caching"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/116059",
        "createdAt":  "2025-05-28T07:37:16Z",
        "number":  116059,
        "author":  "dashiell-zhang",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-23T07:19:13Z",
        "body":  "### Description\n\nHybridCache recommends adjusting the default json serialization settings. The current default value will directly cause a bug in the DTO model with a cycle in the result.\n\n![Image](https://github.com/user-attachments/assets/239c8625-99f1-462e-a468-8550c282e610)\n\n### Reproduction Steps\n\n var userList = await hybridCache.GetOrCreateAsync(\"AllUser\", async c =\u003e await (db.TUser.ToListAsync()));\n![Image](https://github.com/user-attachments/assets/02386d39-8107-49c2-8c92-c4b6a791f02c)\n\n### Expected behavior\n\n```\npublic sealed class HybridCacheJsonSerializerFactory : IHybridCacheSerializerFactory\n{\n    private static readonly JsonSerializerOptions _defaultOptions;\n\n    static HybridCacheJsonSerializerFactory()\n    {\n        _defaultOptions = new()\n        {\n            ReferenceHandler = ReferenceHandler.Preserve, \n            DefaultIgnoreCondition = JsonIgnoreCondition.Never, \n            Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping, \n        };\n    }\n\n    public bool TryCreateSerializer\u003cT\u003e([NotNullWhen(true)] out IHybridCacheSerializer\u003cT\u003e? serializer)\n    {\n        serializer = new DefaultJsonSerializer\u003cT\u003e();\n        return true;\n    }\n\n    internal sealed class DefaultJsonSerializer\u003cT\u003e : IHybridCacheSerializer\u003cT\u003e\n    {\n        T IHybridCacheSerializer\u003cT\u003e.Deserialize(ReadOnlySequence\u003cbyte\u003e source)\n        {\n            var reader = new Utf8JsonReader(source);\n            return JsonSerializer.Deserialize\u003cT\u003e(ref reader, _defaultOptions)!;\n        }\n\n        void IHybridCacheSerializer\u003cT\u003e.Serialize(T value, IBufferWriter\u003cbyte\u003e target)\n        {\n            using var writer = new Utf8JsonWriter(target);\n            JsonSerializer.Serialize(writer, value, _defaultOptions);\n        }\n    }\n}\n\n\nbuilder.Services.AddHybridCache(options =\u003e\n{\n    options.MaximumPayloadBytes = 1024 * 1024 * 4;\n    options.MaximumKeyLength = 1024;\n    options.DefaultEntryOptions = new HybridCacheEntryOptions\n    {\n        Expiration = TimeSpan.FromSeconds(300),\n        LocalCacheExpiration = TimeSpan.FromSeconds(60)\n    };\n\n}).AddSerializerFactory\u003cHybridCacheJsonSerializerFactory\u003e();\n```\n\nI manually configured and avoided similar problems, but in fact, for the cache level, directly adopt\n\n\n**ReferenceHandler = ReferenceHandler.Preserve,\nDefaultIgnoreCondition = JsonIgnoreCondition.Never,\nEncoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping,**\n\n\nAs the default value, it seems to be a better choice\n\n### Actual behavior\n\nA possible object cycle was detected. This can either be due to a cycle or if the object depth is larger than the maximum allowed depth of 64. Consider using ReferenceHandler.Preserve on JsonSerializerOptions to support cycles. Path: $.UpdateUser.InverseCreateUserList.UpdateUser.InverseCreateUserList.UpdateUser.InverseCreateUserList.UpdateUser.InverseCreateUserList.UpdateUser.InverseCreateUserList.UpdateUser.InverseCreateUserList.UpdateUser.InverseCreateUserList.UpdateUser.InverseCreateUserList.UpdateUser.InverseCreateUserList.UpdateUser.InverseCreateUserList.UpdateUser.InverseCreateUserList.UpdateUser.InverseCreateUserList.UpdateUser.InverseCreateUserList.UpdateUser.InverseCreateUserList.UpdateUser.InverseCreateUserList.UpdateUser.InverseCreateUserList.UpdateUser.InverseCreateUserList.UpdateUser.InverseCreateUserList.UpdateUser.InverseCreateUserList.UpdateUser.InverseCreateUserList.UpdateUser.InverseCreateUserList.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOrc7NGQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6tw-CV",
                                           "createdAt":  "2025-05-28T07:38:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-05-28T07:38:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6tzs0Z",
                                           "createdAt":  "2025-05-28T11:48:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-extensions-caching\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-05-28T11:48:12Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "HybridCache recommends adjusting the default json serialization settings. The current default value will directly cause a bug in the DTO model with a cycle in the result.",
        "labels":  [
                       "area-Extensions-Caching"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/117870",
        "createdAt":  "2025-07-21T03:02:56Z",
        "number":  117870,
        "author":  "kelly-yinn",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-14T08:13:50Z",
        "body":  "### Background and motivation\n\nHi team, are we considering add a batch API to support load multiple keys instead of a single key? since cache warm up (seed)  can benefit from the batch API, or we need to start multiple c# Tasks and leverage the single API to load multiple keys, thanks.\n\n\n\n### API Proposal\n\n```csharp\npublic abstract ValueTask\u003cIEnumerable\u003cT\u003e\u003e GetOrCreateAsync\u003cTState, IEnumerable\u003cT\u003e\u003e(IEnumerable\u003cstring\u003e key, TState state, Func\u003cTState, CancellationToken, ValueTask\u003cIEnumerable\u003cT\u003e\u003e\u003e factory,\n        HybridCacheEntryOptions? options = null, IEnumerable\u003cstring\u003e? tags = null, CancellationToken cancellationToken = default);\n```\n\n\n### API Usage\n\n```csharp\nhybridCache.GetOrCreateAsync(keys)\n```\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOuM_w8Q==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc64r9Yo",
                                           "createdAt":  "2025-07-21T20:15:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "Interesting idea. Is this something that could be achieved with an extension method in your application layer, or do you see a reason why this would need to be built in for performance gains? If this can be achieved with an extension method sufficiently, it\u0027s unlikely we would add this into the product.",
                                           "updatedAt":  "2025-07-21T20:15:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc64z_Dx",
                                           "createdAt":  "2025-07-22T03:08:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kelly-yinn",
                                           "body":  "Hi @jeffhandley , thanks for the reply. Sure we can implement this as an extension method in our side, but having a batch API interface in the HybridCache and implementing it in the DefaultHybridCache will definitely benefit more developers. \n\nIn fact i do not do perf testing on comparing a batch API and using Task.WhenAll on the single API, but in general a batch API will overperforms the  other? at least the Task.whenAll way brings more network overhead I think. ",
                                           "updatedAt":  "2025-08-14T08:13:50Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[API Proposal]: Add GetOrCreateAsync to support load multiple keys",
        "labels":  [
                       "api-suggestion",
                       "area-Extensions-Caching",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/118552",
        "createdAt":  "2025-08-09T02:19:21Z",
        "number":  118552,
        "author":  "markalward",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODLsUXg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "avparuch",
                                            "createdAt":  "2025-08-09T02:35:57Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "vinaychandra",
                                            "createdAt":  "2025-08-09T02:43:36Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "karimsalem1",
                                            "createdAt":  "2025-08-09T05:28:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "thadumi",
                                            "createdAt":  "2025-08-10T16:49:58Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "zwang27",
                                            "createdAt":  "2025-08-12T05:28:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "omaralkaalesmsft",
                                            "createdAt":  "2025-08-19T02:13:15Z"
                                        }
                                    ],
                          "totalCount":  6
                      },
        "updatedAt":  "2025-08-20T10:05:40Z",
        "body":  "### Description\n\n`Microsoft.Extensions.Caching.Memory.MemoryCache` supports registering a post-eviction callback for cache entries. We noticed the following symptoms when using a `MemoryCache` with a high turnover rate and post-eviction callbacks:\n- The ThreadPool Thread Count metric doubled in our web service.\n- The ThreadPool Queue Length increased significantly (~13x).\n- The ThreadPool Completed Work Item Count showed periodic spikes.\n\nThis code reproduces the issue:\n\n```cs\npublic static void Main(string[] args)\n{\n    ThreadPool.SetMinThreads(100, 100);\n\n    var cache = new MemoryCache(Options.Create(\n        new MemoryCacheOptions()\n        {\n            ExpirationScanFrequency = TimeSpan.FromSeconds(30),\n        }));\n\n    var entryOptions = new MemoryCacheEntryOptions()\n    {\n        SlidingExpiration = TimeSpan.FromSeconds(30),\n    };\n\n    int capacityEvictionCount = 0;\n    entryOptions.RegisterPostEvictionCallback((_, _, reason, _) =\u003e\n    {\n        // The contents of the eviction callback don\u0027t matter. This example shows that even\n        // a very short-running method can reproduce the issue.\n        if (reason == EvictionReason.Capacity)\n        {\n            Interlocked.Increment(ref capacityEvictionCount);\n        }\n    });\n\n    // add 600 cache entries per second.\n    int key = 0;\n    while (true)\n    {\n        const int batchSize = 120;\n        for (int i = 0; i \u003c batchSize; i++)\n        {\n            cache.Set(key, \"test\", entryOptions);\n            key++;\n        }\n    \n        Thread.Sleep(200);\n    }\n}\n```\n\nThe code sets `ExpirationScanFrequency` to 30 seconds and adds 600 entries to the cache per second, each with a sliding expiration of 30 seconds.  The expiration scan at time (app start + 1 minute) removes 18,000 entries, since there are (600 entries per second) * (30 seconds) = 18,000 entries that are older than 30 seconds at that point. This expiration scan causes the first spike in thread pool size:\n\n\u003cimg width=\"398\" height=\"187\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/60375375-8f28-491e-91f2-903b3fa0a223\" /\u003e\n\nConfiguring the thread pool using `ThreadPool.SetMinThreads()` causes the thread pool scale up more, compared to using default settings. This is a realistic configuration, since web services often configure this setting to handle traffic bursts.\n\n### Configuration\n\n- .NET 8 (8.0.19)\n- Windows 11\n- x64\n- 4 core machine\n\n### Regression?\n\nNo\n\n### Data\n\nThese charts show the regression in our service performance when we were using a `MemoryCache` with post-eviction callbacks. The drop-off on the right was after reverting the change that introduced post-eviction callbacks:\n\n\u003cimg width=\"1107\" height=\"400\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/f7eec99c-1e35-413b-8efd-831b17214546\" /\u003e\n\nThe Web Server Queue Length chart shows that the issue causing an increase in the amount of time requests spend queued in the web server before being dispatched to our app. In our scenario, ~200 cache entries were being added to the cache per second.\n\n### Analysis\n\n[ScanForExpiredItems](https://source.dot.net/#Microsoft.Extensions.Caching.Memory/MemoryCache.cs,464) calls `CacheEntry.InvokeEvictionCallbacks()` for each expired entry. This [routine](https://source.dot.net/#Microsoft.Extensions.Caching.Memory/CacheEntry.CacheEntryTokens.cs,105) uses `Task.Factory.StartNew()` to queue each eviction callback as a thread pool work item.\n\nSince `ScanForExpiredItems` finds many expired entries each time it runs, and each entry\u0027s eviction callback is queued as a separate thread pool work item, this causes a sudden burst of work items to be submitted, causing the thread pool to scale up. In the repro code above, around 18,000 work items are submitted in each of these bursts.\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOvw1x-Q==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc687Tmb",
                                           "createdAt":  "2025-08-09T02:20:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MihuBot",
                                           "body":  "Possible related and/or duplicate issues:\n- https://github.com/dotnet/runtime/issues/97736\n- https://github.com/dotnet/runtime/issues/115142",
                                           "updatedAt":  "2025-08-09T02:20:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc68_hsC",
                                           "createdAt":  "2025-08-09T13:51:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-extensions-caching\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-08-09T13:51:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc69MMIW",
                                           "createdAt":  "2025-08-11T10:17:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEd2B2A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Tratcher",
                                                                               "createdAt":  "2025-08-11T14:24:53Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "Tagging @davidfowl and @Tratcher who were the original authors of `MemoryCache` as I don\u0027t see a clean fix here as of now. \n\nMy reasoning: when the user provides the callback, we don\u0027t know whether it\u0027s fast and never blocking, time consuming or a buggy callback that could cause deadlock. Because of that, we can\u0027t be running the callbacks from the thread that removes the entries and we queue these to the Thread Pool.",
                                           "updatedAt":  "2025-08-11T10:17:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc69QG6W",
                                           "createdAt":  "2025-08-11T14:29:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Tratcher",
                                           "body":  "Yeah, it can\u0027t really work any other way. This may be more of a question about guidance on the usage of post eviction callbacks, or an ask for a more appropriate mechanism.\n\n@markalward can you give an example of why you\u0027re using post eviction callbacks? Maybe there\u0027s an alternative.",
                                           "updatedAt":  "2025-08-11T14:29:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc69ZKh6",
                                           "createdAt":  "2025-08-12T02:32:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "markalward",
                                           "body":  "I was using post-eviction callbacks to get telemetry on the number of evictions with `reason == EvictionReason.Capacity`. It\u0027s good to have this telemetry, since we want to know when we\u0027re running above the cache capacity. For that one use case, I suppose `MemoryCacheStatistics` could be extended to support a `CapacityEvictionCount` property.\n\nAnother example was using the post-eviction callback to log information about TCP connections. We were collecting stats for each active connection, then logging that information when the connection\u0027s entry was removed from the cache. We used a custom cache implementation for this, but its another example where post-eviction callbacks are useful.\n\nWould either of these ideas work?\n1. Coalesce all the post-eviction callbacks into a single thread pool work item: If 6000 entries expire in one `ScanForExpiredItems()` call, run them all in the same work item. Or possibly submit them in batches (say 100 at a time).\n\n   It\u0027s possible that a user could write one post-eviction callback that blocks waiting for another callback to complete (entry A\u0027s callback blocks waiting for entry B to be evicted). Then the user\u0027s code deadlocks if both callbacks are running on the same thread. This is one argument I can see against making this change.\n\n2. Do the same as (1), except make the change opt-in to avoid any possibility of deadlocking existing code. A new flag like `MemoryCacheOptions.CoalescePostEvictionCallbacks` would be added to allow users to opt in to running multiple callbacks in the same work item.",
                                           "updatedAt":  "2025-08-12T02:32:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc69ZcsF",
                                           "createdAt":  "2025-08-12T03:24:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Tratcher",
                                           "body":  "\u003e I was using post-eviction callbacks to get telemetry on the number of evictions with reason == EvictionReason.Capacity. It\u0027s good to have this telemetry, since we want to know when we\u0027re running above the cache capacity. For that one use case, I suppose MemoryCacheStatistics could be extended to support a CapacityEvictionCount property.\n\nYes, improving the stats sounds like a better solution long term.\n\n\u003e Would either of these ideas work?\n\n\u003e Coalesce all the post-eviction callbacks into a single thread pool work item: If 6000 entries expire in one ScanForExpiredItems() call, run them all in the same work item. Or possibly submit them in batches (say 100 at a time).\n\n\u003e It\u0027s possible that a user could write one post-eviction callback that blocks waiting for another callback to complete (entry A\u0027s callback blocks waiting for entry B to be evicted). Then the user\u0027s code deadlocks if both callbacks are running on the same thread. This is one argument I can see against making this change.\n\nIsn\u0027t this duplicating the functionality of the threadpool queue? It sounds like you want to queue to your own threadpool with different settings.",
                                           "updatedAt":  "2025-08-12T03:24:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc69qjZj",
                                           "createdAt":  "2025-08-13T03:22:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEegTsg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "avparuch",
                                                                               "createdAt":  "2025-08-16T06:10:50Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "markalward",
                                           "body":  "\u003e Isn\u0027t this duplicating the functionality of the threadpool queue?\n\nBased on some experiments, the two approaches produce significantly different behavior in terms of the thread pool counters. Queueing one work item to run 18,000 callbacks doesn\u0027t increase the thread pool size at all. Queueing 18,000 works items to run 18,000 callbacks causes a large increase in the thread pool size. In the 18,000 work items case, I\u0027m also measuring the time delta from (work item submitted time) to (work item started time) for each work item to estimate queueing delay and seeing the P90 time is around 100ms. When submitting one work item at a time, the P90 is below 1ms.\n\n\u003e It sounds like you want to queue to your own threadpool with different settings.\n\nNo, I don\u0027t think so. The thread pool usage here is opaque to the user—ideally, they shouldn’t need to worry about where work items run or how often the MemoryCache submits them. In this case, the submission rate led to increased thread pool queueing latency and higher request latency. With this github issue, I wanted to see whether the MemoryCache implementation can be adjusted to avoid this performance trap for typical users.",
                                           "updatedAt":  "2025-08-13T03:22:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6_DXH5",
                                           "createdAt":  "2025-08-20T10:05:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "\u003e I suppose MemoryCacheStatistics could be extended to support a CapacityEvictionCount property\n\nThis sounds very reasonable to me 👍 \n\n\u003e Coalesce all the post-eviction callbacks into a single thread pool work item\n\nThis would add yet another thread to the thread pool. Since the scan for expired entries is performed by a dedicated task:\n\nhttps://github.com/dotnet/runtime/blob/3376cbd4d130ff45ac6ac2871180b1712bc12f7d/src/libraries/Microsoft.Extensions.Caching.Memory/src/MemoryCache.cs#L397-L398\n\nhttps://github.com/dotnet/runtime/blob/3376cbd4d130ff45ac6ac2871180b1712bc12f7d/src/libraries/Microsoft.Extensions.Caching.Memory/src/MemoryCache.cs#L464-L477\n\nhttps://github.com/dotnet/runtime/blob/3376cbd4d130ff45ac6ac2871180b1712bc12f7d/src/libraries/Microsoft.Extensions.Caching.Memory/src/MemoryCache.cs#L784-L798\n\nWe could add a flag that would extend it\u0027s responsibility with running the callbacks rather than scheduling them. This would of course need to be disabled by default and documented as risky (deadlocks if used in wrong way).\n\n@markalward Would you like to prepare the [API proposal](https://github.com/dotnet/runtime/issues/new?assignees=\u0026labels=api-suggestion\u0026template=02_api_proposal.yml\u0026title=%5BAPI+Proposal%5D%3A+)? More about the [API review process](https://github.com/dotnet/runtime/blob/main/docs/project/api-review-process.md).\n\n\n",
                                           "updatedAt":  "2025-08-20T10:05:12Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Microsoft.Extensions.Caching.Memory.MemoryCache post-eviction callbacks cause thread pool queueing",
        "labels":  [
                       "tenet-performance",
                       "area-Extensions-Caching"
                   ]
    }
]
