[
    {
        "url":  "https://github.com/dotnet/runtime/issues/4525",
        "createdAt":  "2015-09-27T21:32:53Z",
        "number":  4525,
        "author":  "GSPP",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCqHqdQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "samueldjack",
                                            "createdAt":  "2018-09-06T15:19:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aayjaychan",
                                            "createdAt":  "2020-01-13T08:22:09Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "matthew-jackson-hms",
                                            "createdAt":  "2022-01-04T00:51:09Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "paulomorgado",
                                            "createdAt":  "2022-01-04T01:33:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Mrxx99",
                                            "createdAt":  "2022-01-04T08:36:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jukkahyv",
                                            "createdAt":  "2022-01-04T11:36:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jzabroski",
                                            "createdAt":  "2022-01-04T15:57:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pedoc",
                                            "createdAt":  "2022-01-05T12:26:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Tragetaschen",
                                            "createdAt":  "2022-05-31T08:03:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aradalvand",
                                            "createdAt":  "2022-08-13T22:57:36Z"
                                        }
                                    ],
                          "totalCount":  10
                      },
        "updatedAt":  "2022-07-29T15:30:35Z",
        "body":  "Values in attributes currently do not support nullable values. That is annoying because it forces us back to obsolete techniques used pre-.NET-2.0. Decimal support also would be nice.\n\nMaybe we can even have a general way we can add \"JSON-like\" object trees. e.g.\n\n```\n[ActionMethod(\n  name: \"abc\",\n  routes: new [] { \"/a\", \"/b\" },\n  connectionString: new ConnectionString() { Server = \"s\", Port = 42 })]\n```\n\nI hope you get what I mean. I made up a contrived, yet plausible, example.\n\nThat way we can have very high generality in attributes. We no longer need to make up rules and add piecemeal support for certain things.\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOR39YXg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDE0NDg0NjgxNA==",
                                           "createdAt":  "2015-10-01T21:00:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "DixonDs",
                                           "body":  "This issue seems to be related to my request as well: https://github.com/dotnet/coreclr/issues/1534\n",
                                           "updatedAt":  "2015-10-01T21:00:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc47m7Ic",
                                           "createdAt":  "2021-12-23T05:46:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "robertmclaws",
                                           "body":  "Hi @terrajobst! Any chance we could get this worked into the schedule for .NET 7.0? ",
                                           "updatedAt":  "2021-12-23T05:46:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc473rMP",
                                           "createdAt":  "2022-01-04T00:41:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "terrajobst",
                                           "body":  "Tagging @jkotas @tmat.\r\n\r\nMy understanding is that this is a major work item as it requires to rev the underlying metadata format. Attributes are essentially stored as binary blobs and the set of supported types is a closed set.\r\n\r\nThis issue pops up from time to time but so far there wasn\u0027t compelling enough evidence that warrants that level of investment yet.\r\n\r\nThat\u0027s not to say it\u0027s a bad idea (it would certainly be neat) just that this would mean we get to spend less time on features that seem more compelling.",
                                           "updatedAt":  "2022-01-04T00:42:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc475kl9",
                                           "createdAt":  "2022-01-04T16:19:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jzabroski",
                                           "body":  "* Decimal.\r\n  * Current workarounds: (1) Encode value in string, call decimal.Parse. (2) Use doubles, risk lossy precision when casting double to decimal. (3) doesn\u0027t work in all cases, see below for example of open data type closed at run-time.\r\n* DateTime\r\n  * Example: for FluentMigrator, we recommend people use the ISO 8601 prefixed long integer encoding of DateTime values to represent a migration version number.  `[Migration(202201040001, \"DOTNET-4525: Demonstrate DateTime for attribute values\")]` would instead be written as, perhaps, `[Migration(new DateTime(2022, 1, 4), sequence: 1, \"DOTNET-4525: Demonstrate DateTime for attribute values\")]` - this is maybe not the best example, because I can\u0027t confirm people would prefer writing it this way, which brings me to the next point.\r\n  * Example: DateTime constructors are noisy as hell and a pain to write.  Why can\u0027t we simply write `dt\"20220104\"` and .NET infer the ISO 8601 value from a DateTime string literal?  With modern IDEs it can probably even be color-coded, and code-lens can probably display a compile-time constant value help tip on what the constructed value would be.\r\n* static readonly properties, especially for things that have no free variables in the initialization logic.\r\n  * I\u0027m sure there are compiler limitations I am not thinking about for why the ECMA standard disallows this, but it is a really annoying restriction.  Our workaround is to use Constants, and Constants don\u0027t propagate across assemblies, they\u0027re copy-pasted by the compiler, so there is no way to dynamically link values.\r\n  * Perhaps there should be a different concept than static readonly here - like Robert Harper\u0027s notion of assignable vs. mobile values http://www.cs.cmu.edu/~rwh/talks/hope13.pdf\r\n\r\nThat said, my most frequent use case is xunit.net theories.  I use theories a lot to guarantee 100% code coverage.  In these circumstances, I often have to use MemberData instead of InlineData because decimal and other values are not supported.\r\n\r\nHere is a good example xunit test I would also love to be able to generalize to more native data types like Decimal:\r\n\r\n```c#\r\n        [Theory]\r\n        [InlineData(1)]\r\n        [InlineData(1L)]\r\n        [SuppressMessage(\"Usage\", \"xUnit1026:Theory methods should use all of their parameters\", Justification = \"\u003cPending\u003e\")]\r\n        public void TestGetNullableWhenNull\u003cT\u003e(T _) where T : struct\r\n        {\r\n            var fieldName = Fixture.Create\u003cstring\u003e();\r\n            var ordinal = Fixture.Create\u003cint\u003e();\r\n            var fieldValue = DBNull.Value;\r\n            var sqlDataReaderMock = new Mock\u003cIDataRecord\u003e();\r\n            sqlDataReaderMock.Setup(s =\u003e s.GetOrdinal(fieldName))\r\n                .Returns(ordinal);\r\n            sqlDataReaderMock.Setup(s =\u003e s.GetFieldType(ordinal))\r\n                .Returns(typeof(T));\r\n            sqlDataReaderMock.Setup(s =\u003e s[It.IsAny\u003cstring\u003e()])\r\n                .Returns(fieldValue);\r\n\r\n            var sqlDataReader = sqlDataReaderMock.Object;\r\n\r\n            var result = sqlDataReader.Get\u003cT?\u003e(fieldName);\r\n            Assert.Null(result);\r\n\r\n            Mock.VerifyAll(sqlDataReaderMock);\r\n        }\r\n\r\n        [Theory]\r\n        [InlineData(1)]\r\n        [InlineData(1L)]\r\n        [InlineData(\"\")]\r\n        [SuppressMessage(\"Usage\", \"xUnit1026:Theory methods should use all of their parameters\", Justification = \"\u003cPending\u003e\")]\r\n        public void TestGetMockUserDefinedTypeThrowsException\u003cT\u003e(T _)\r\n        {\r\n            var fieldName = Fixture.Create\u003cstring\u003e();\r\n            var ordinal = Fixture.Create\u003cint\u003e();\r\n            var sqlDataReaderMock = new Mock\u003cIDataRecord\u003e();\r\n            sqlDataReaderMock.Setup(s =\u003e s.GetOrdinal(fieldName))\r\n                .Returns(ordinal);\r\n            // The documentation for SqlDataReader says that GetFieldType returns null for SQL columns with user-defined data types.\r\n            sqlDataReaderMock.Setup(s =\u003e s.GetFieldType(ordinal))\r\n                .Returns((Type)null);\r\n\r\n            var sqlDataReader = sqlDataReaderMock.Object;\r\n\r\n            Assert.Throws\u003cNotSupportedException\u003e(() =\u003e sqlDataReader.Get\u003cT\u003e(fieldName));\r\n            \r\n            Mock.VerifyAll(sqlDataReaderMock);\r\n        }\r\n\r\n        [Theory]\r\n        [InlineData(1, 1L)]\r\n        [InlineData(1L, 1)]\r\n        [SuppressMessage(\"Usage\", \"xUnit1026:Theory methods should use all of their parameters\", Justification = \"\u003cPending\u003e\")]\r\n        public void TestGetWhenDatabaseTypeFieldTypeAndClrTypeMismatch\u003cTFieldType, TClrType\u003e(TFieldType _, TClrType __)\r\n        {\r\n            var fieldName = Fixture.Create\u003cstring\u003e();\r\n            var ordinal = Fixture.Create\u003cint\u003e();\r\n            var fieldValue = Fixture.Create\u003cTFieldType\u003e();\r\n            var sqlDataReaderMock = new Mock\u003cIDataRecord\u003e();\r\n            sqlDataReaderMock.Setup(s =\u003e s.GetOrdinal(fieldName))\r\n                .Returns(ordinal);\r\n            sqlDataReaderMock.Setup(s =\u003e s.GetFieldType(ordinal))\r\n                .Returns(typeof(TFieldType));\r\n\r\n            var sqlDataReader = sqlDataReaderMock.Object;\r\n\r\n            var exception = Assert.Throws\u003cException\u003e(() =\u003e sqlDataReader.Get\u003cTClrType\u003e(fieldName));\r\n            Assert.Equal($\"Database fieldType {typeof(TFieldType).FullName} does not match C# destination: {typeof(TClrType).FullName}.  fieldName: {fieldName}\", exception.Message);\r\n\r\n            Mock.VerifyAll(sqlDataReaderMock);\r\n        }\r\n```\r\n\r\nThis example is not representative of every test I write, but it is a decent example where I can\u0027t simply call decimal.Parse on a string, because T is an open data type that is closed at run-time by the test runner.",
                                           "updatedAt":  "2022-01-05T00:51:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc475rUf",
                                           "createdAt":  "2022-01-04T16:42:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jzabroski",
                                           "body":  "\u003e Attributes are essentially stored as binary blobs and the set of supported types is a closed set.\r\n\u003e \r\n\u003e This issue pops up from time to time but so far there wasn\u0027t compelling enough evidence that warrants that level of investment yet.\r\n\r\nJust a thought - why not implement some sort of \"Gradual Attributes\" as a workaround to this?  They would simply derive a different superclass than System.Attribute.  Perhaps System.Annotation.  A compiler transform similar to nameof would then effectively implement the manual transform most of us use in frameworks like xunit in order to be able to read data at run-time.  The two APIs, System.Attribute and System.Annotation, could be source-level compatible for fields, methods and other APIs (reflection), such that it could eventually be merged into a single type in the future.\r\n\r\nI\u0027m not saying this is even a good idea - just a workaround proposal to why this feature would have a heavy complexity cost budget as well as [\"Paying the Language Design UI Tax\"](http://www.panopticoncentral.net/2006/01/14/language-design-paying-the-ui-tax/).",
                                           "updatedAt":  "2022-01-04T16:42:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HRVSg",
                                           "createdAt":  "2022-07-26T16:45:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jzabroski",
                                           "body":  "@jcouv @RikkiGibson How does this proposal intersect with C# 10.0 Generic Attributes https://github.com/dotnet/csharplang/issues/124 viz a viz https://github.com/dotnet/csharplang/pull/4936 ? I haven\u0027t played around with the Generic Attributes feature yet, but it would seem like either Generic Attributes would workaround these limitations or resolve them directly for non-generic attributes.\r\n\r\nIf a generic type parameter in an attribute constructor isn\u0027t storable, then how are generic attributes even possible?\r\n\r\ne.g., it\u0027s not clear from the spec if any of these should compile:\r\n\r\n```c#\r\n// Freeze the application clock so that all test fixture requests for date time resolve to 1/1/2020\r\n[Freeze\u003cDateTime\u003e(new DateTime(2020, 1, 1))]\r\n```\r\n\r\nThis is not my favorite example, but I imagine it\u0027s something some people might enjoy writing:\r\n```c#\r\n/* Expression Trees */\r\n// This property is a ForeignKey to entity Foo via Bar navigation property.\r\n[ForeignKey\u003cFoo\u003e(f =\u003e f.Bar)]\r\n```\r\n\r\n",
                                           "updatedAt":  "2022-07-26T16:45:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HR1d_",
                                           "createdAt":  "2022-07-26T18:49:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "RikkiGibson",
                                           "body":  "Use of generic attributes doesn\u0027t change which types are allowed as attribute arguments. So `[Attr\u003cDateTime\u003e(new DateTime(..))]` as of now would not work.\n",
                                           "updatedAt":  "2022-07-26T18:49:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HR3HN",
                                           "createdAt":  "2022-07-26T18:57:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "robertmclaws",
                                           "body":  "@RikkiGibson That\u0027s going to be a massive point of failure for a lot of people, I think. Enabling generic attributes is going to exacerbate this problem quite a bit because T in Attribute\u003cT\u003e is unconstrained, and people are going to want to know why they can put a massively-complex type in there, but not something simple a decimal.\r\n\r\nAlso, in the [pull request](https://github.com/dotnet/coreclr/pull/9189), there are no unit tests to outline which types are expected to fail, only happy-path tests. So there is no indication that `decimal` will fail, except the time they will waste trying to figure it out.",
                                           "updatedAt":  "2022-07-26T18:58:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HSa0a",
                                           "createdAt":  "2022-07-26T21:41:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jzabroski",
                                           "body":  "@robertmclaws It\u0027s a good catch that the unit tests don\u0027t call out negative test cases, but it\u0027s not exactly clear how those would be caught via unit test (to me).  You can\u0027t even express as valid syntax some of these examples, so it would have to be fairly high level compilation tests for C#, vs. CLR tests.\r\n\r\nIn general, having generic attributes does enable some more type-safe programming. For example, Imagine closing `SomeSourceGeneratorAttribute\u003cTDataTransferObject\u003e` vs. `SomeSourceGeneratorAttribute(typeof(DataTransferObject))` - the former is more safe than the latter and easier to use from an API builder perspective, as it allows directly referencing constraints from TDataTransferObject\u0027s generic interface.\r\n\r\nThe broader reason I raised this point is that I wonder to what extent C# and the CLR would be best off implementing support for higher-kinded polymorphism.  F# would certainly benefit as a functional language where higher-kinded polymorphism makes for very powerful functional abstractions.  And it is pretty common to implement data constructors through some higher-kinded mechanism.  The other major benefit of higher-kinded polymorphism is it eliminates a lot of edge cases composing open generic types, like open generic delegates.\r\n\r\nWe could also just do the simple thing and implement my System.Annotation hack via Source Generators, especially now that we have Generic Attributes in preview mode.  An Annotation would just lift data constructor terms to a closed type.  So you could have a \"generic attribute\" whose sole purpose is to unwrap a data transfer object that carries the real attribute.\r\n\r\nMy particular desire in resurfacing this old issue is rather silly - I want to have a clearer boundary between Input Test Data and Expected Result Test Data in my xunit.net theory test\u0027s InlineData attributes.  I\u0027ve never liked how I have had no clear boundary between the two sides of Arrange and Assert in my theory specifications.",
                                           "updatedAt":  "2022-07-26T21:44:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HcuB6",
                                           "createdAt":  "2022-07-28T23:07:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "RikkiGibson",
                                           "body":  "\u003e people are going to want to know why they can put a massively-complex type in there, but not something simple a decimal.\r\n\r\nYou can use most any concrete type, including `decimal`, as a type argument to an attribute type. It\u0027s just that if this causes a parameter on the attribute constructor to have a disallowed type after substitution, you\u0027ll get an error. So, for example, `[Attr\u003cDateTime\u003e]` or `[Attr\u003cdecimal\u003e]` are just fine if `Attr` has an accessible parameterless constructor.\r\n",
                                           "updatedAt":  "2022-07-28T23:07:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Hf1he",
                                           "createdAt":  "2022-07-29T15:24:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jzabroski",
                                           "body":  "\u003e So, for example, `[Attr\u003cDateTime\u003e]` or `[Attr\u003cdecimal\u003e]` are just fine if `Attr` has an accessible parameterless constructor.\r\n\u003e -- @RikkiGibson \r\n\r\nTo elaborate on my Annotation hack, you can imagine something like this:\r\n\r\n```c#\r\npublic class AnnotationAttribute\u003cT\u003e : Attribute where T : new()\r\n{\r\n  T Unwrap\u003cT\u003e() =\u003e new T();\r\n}\r\n\r\npublic class Cargo\r\n{\r\n  public DateTime Date =\u003e new DateTime(2020, 1, 1);\r\n}\r\n\r\n[Annotation\u003cCargo\u003e]\r\npublic class Foo\r\n{\r\n  public Cargo GetAttributeData()\r\n  {\r\n    // Read attribute into some variable  named \u0027annotation\u0027 ....\r\n    return annotation.Unwrap\u003cCargo\u003e();\r\n  }\r\n}\r\n```\r\n\r\nand, in my case of extending xunit\u0027s InlineData into something nicer to work with, you can imagine tupling the annotation:\r\n\r\n```c#\r\npublic class AnnotationAttribute\u003cT1, T2\u003e : Attribute where T1 : new(), T2 : new()\r\n{\r\n  (T1, T2) Unwrap\u003cT1, T2\u003e() =\u003e (new T1(), new T2());\r\n}\r\n```",
                                           "updatedAt":  "2022-07-29T15:30:35Z"
                                       }
                                   ],
                         "totalCount":  11
                     },
        "title":  "Allow common types in attribute values (nullable, decimal)",
        "labels":  [
                       "enhancement",
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/4556",
        "createdAt":  "2015-10-07T22:03:18Z",
        "number":  4556,
        "author":  "gafter",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODCU8PQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "JinShil",
                                            "createdAt":  "2021-07-25T00:05:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sakno",
                                            "createdAt":  "2021-10-05T21:39:53Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "steveharter",
                                            "createdAt":  "2022-12-05T19:01:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "omariom",
                                            "createdAt":  "2025-04-19T21:25:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2025-05-13T14:54:51Z"
                                        }
                                    ],
                          "totalCount":  5
                      },
        "updatedAt":  "2021-10-06T09:42:54Z",
        "body":  "The delegate combine operator does not properly account for delegate variance.\n\nSee https://github.com/dotnet/roslyn/issues/3711 for details.\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHON8gDpQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDE0NjM0NjUzMg==",
                                           "createdAt":  "2015-10-07T22:06:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gafter",
                                           "body":  "The managed language design team requests that this be addressed for the next VS product release.\n",
                                           "updatedAt":  "2015-10-07T22:06:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDE0OTk3MDQ2OQ==",
                                           "createdAt":  "2015-10-21T17:30:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gafter",
                                           "body":  "@LLITCHEV: Can you please suggest who I should tag to get some commitment on this?\n",
                                           "updatedAt":  "2015-10-21T17:30:34Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDE0OTk3ODgzNg==",
                                           "createdAt":  "2015-10-21T18:02:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "LLITCHEV",
                                           "body":  "@jkotas Jan, could you please help Neal with the right people to talk to. I assume that this will require changes in the VM. Not so much in the Jit, but maybe yes?\n",
                                           "updatedAt":  "2015-10-21T18:02:01Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDE0OTk5NTEzNQ==",
                                           "createdAt":  "2015-10-21T19:02:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "cc @gkhanna79 This is type system issue.\r\n\r\nI do not think that it is a simple bug fix. We would need a new overload of Combine method that takes the type of the combined delegate as an argument, and change C# compiler to use it to combine delegates.\r\n\r\nConsider this case - there is no way for the existing Combine method to figure out that the result type should be `Func\u003cIFace, object\u003e`:\r\n\r\n```c#\r\ninternal class Program\r\n{\r\n    interface IBaseA { }\r\n    interface IBaseB { }\r\n\r\n    interface IFace1 : IBaseA, IBaseB { }\r\n    interface IFace2 : IBaseA, IBaseB { }\r\n\r\n    interface IFace : IFace1, IFace2 { }\r\n\r\n    static void Main(string[] args)\r\n    {\r\n        Func\u003cIFace1, object\u003e d1 = SomeFunction1;\r\n        Func\u003cIFace2, object\u003e d2 = SomeFunction2;\r\n\r\n        Func\u003cIFace, object\u003e e1 = d1;\r\n        Func\u003cIFace, object\u003e e2 = d2;\r\n\r\n        var d = e1 + e2;\r\n    }\r\n\r\n    static object SomeFunction1(IFace1 input)\r\n    {\r\n        return null;\r\n    }\r\n\r\n    static object SomeFunction2(IFace2 input)\r\n    {\r\n        return null;\r\n    }\r\n}\r\n```\r\n",
                                           "updatedAt":  "2017-03-17T09:25:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDE1MDAwMTQyMw==",
                                           "createdAt":  "2015-10-21T19:28:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gafter",
                                           "body":  "The C# (and VB and F#) compiler team will be happy to use whatever API you need to add.\n",
                                           "updatedAt":  "2015-10-21T19:30:14Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDE1MTkwMjA0Mg==",
                                           "createdAt":  "2015-10-28T16:32:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gkhanna79",
                                           "body":  "@JohnChen0 Can you please look into this for RC2?\n",
                                           "updatedAt":  "2015-10-28T16:32:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDE5ODE0MTg5OQ==",
                                           "createdAt":  "2016-03-18T00:17:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gafter",
                                           "body":  "@fadimounir @JohnChen0 @gkhanna79 Do you anticipate having this fixed in time to ship with C#7? The C# and VB compiler teams are happy to do our end of the work, but we need you to tell us which API we should be using.\n",
                                           "updatedAt":  "2016-03-18T00:17:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIwMTA2NzkzMQ==",
                                           "createdAt":  "2016-03-24T23:10:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gkhanna79",
                                           "body":  "@gafter What is the timeframe for C# 7? We are heads down with .NET Core RTM and it will be good to understand the timeline before commenting on the next steps.\n",
                                           "updatedAt":  "2016-03-24T23:10:46Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI0MTgzODY3OQ==",
                                           "createdAt":  "2016-08-23T18:53:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gafter",
                                           "body":  "@gkhanna79 The time frame for getting this fixed in C# 7 is the same as the time frame for the ValueTuple libraries. Having this in place in the next month would enable us to fix the compiler for Dev15.\n",
                                           "updatedAt":  "2016-08-23T18:53:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI0NTA0MjE4Nw==",
                                           "createdAt":  "2016-09-06T18:21:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gkhanna79",
                                           "body":  "@gafter I think we can look into this for .NET Core 1.2 as part of the overall API edition effort (it will be a Dev15 Update and not RTM).\n",
                                           "updatedAt":  "2016-09-06T18:21:51Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI0NTEyMzc4OA==",
                                           "createdAt":  "2016-09-06T23:06:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gafter",
                                           "body":  "@gkhanna79 We can have the compiler test for the presence of the new delegate combine API so that the fix will kick in for anyone who compiles against a platform that contains it. Please loop me in when it is being designed.\n",
                                           "updatedAt":  "2016-09-06T23:06:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI0NTEyNDQxOA==",
                                           "createdAt":  "2016-09-06T23:10:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gkhanna79",
                                           "body":  "@gafter @JohnChen0 will sync with you when he starts looking into this.\n",
                                           "updatedAt":  "2016-09-06T23:10:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI3MDc5MzI0NQ==",
                                           "createdAt":  "2017-01-05T23:58:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gafter",
                                           "body":  "Ping. Just a reminder that the front ends [need this to produce correct code](https://github.com/dotnet/roslyn/issues/3711), and would be happy to work with you at your earliest convenience to get this addressed.",
                                           "updatedAt":  "2017-01-05T23:58:01Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI3MDc5MzUxNg==",
                                           "createdAt":  "2017-01-05T23:59:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gkhanna79",
                                           "body":  "@rahku Can you please look into this and determine the next steps?",
                                           "updatedAt":  "2017-01-05T23:59:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI4MDk3Nzk3NA==",
                                           "createdAt":  "2017-02-20T03:11:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gafter",
                                           "body":  "Ping. Just a reminder that the front ends [need this to produce correct code](https://github.com/dotnet/roslyn/issues/3711), and would be happy to work with you at your earliest convenience to get this addressed.",
                                           "updatedAt":  "2017-02-20T03:11:01Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI4MTIxMDA1NQ==",
                                           "createdAt":  "2017-02-21T00:08:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "@MeiChin-Tsai will chat with @jaredpar about this and similar issues.",
                                           "updatedAt":  "2017-02-21T00:08:18Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI4MTIzMjk4OA==",
                                           "createdAt":  "2017-02-21T03:07:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gafter",
                                           "body":  "@jkotas Excellent. For reference a useful umbrella issue (a list of places where runtime bugs interfere with compiler correctness or language evolution) is https://github.com/dotnet/roslyn/issues/13295\r\n",
                                           "updatedAt":  "2017-02-21T03:07:02Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI5MzcyMjYwNQ==",
                                           "createdAt":  "2017-04-12T22:13:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gkhanna79",
                                           "body":  "@jaredpar Is this being targeted for 2.0? If not, can you please move this out?",
                                           "updatedAt":  "2017-04-12T22:13:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNDQ1OTg0MA==",
                                           "createdAt":  "2017-10-05T13:10:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "TylerBrinkley",
                                           "body":  "Perhaps if [csharplang#103](https://github.com/dotnet/csharplang/issues/103) is implemented then this new generic covariant/contravariant `Delegate.Combine` API could be added.",
                                           "updatedAt":  "2017-10-05T13:10:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNDU3MDE2OQ==",
                                           "createdAt":  "2017-10-05T19:38:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gafter",
                                           "body":  "I don\u0027t believe a new language feature is needed to address this. As @jkotas says\r\n\r\n\u003e We would need a new overload of `Combine` method that takes the type of the combined delegate as an argument\r\n\r\nI think that is all that is needed.",
                                           "updatedAt":  "2017-10-05T19:38:01Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNDU3Mjc5Mg==",
                                           "createdAt":  "2017-10-05T19:49:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gafter",
                                           "body":  "Correction: we need a similar accommodation for `Delegate.Remove`. See https://github.com/dotnet/roslyn/issues/3711 for the original bug report, which demonstrates issues with both.",
                                           "updatedAt":  "2017-10-05T19:49:01Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM3Njk3MTIzNg==",
                                           "createdAt":  "2018-03-28T17:34:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "RussKeldorph",
                                           "body":  "Future per @sergiy-k",
                                           "updatedAt":  "2018-03-28T17:34:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1NjE5NTQyMg==",
                                           "createdAt":  "2019-01-21T20:50:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gafter",
                                           "body":  "We are still interested in getting these small APIs added so that the C# compiler can produce correct code.",
                                           "updatedAt":  "2019-01-21T20:50:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1NjQ5NDU1MQ==",
                                           "createdAt":  "2019-01-22T17:47:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sergiy-k",
                                           "body":  "@MichalStrehovsky, could you please work with @gafter to define the exact set of APIs needed by the C# compiler and the cost of adding them? Thank you!",
                                           "updatedAt":  "2019-01-22T17:47:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1NjkxOTM3Mg==",
                                           "createdAt":  "2019-01-23T18:44:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "Per the example Jan provided above, we would need to add versions of `Combine`/`Remove` where the caller can specify the resulting type of the delegate. This shouldn\u0027t be too difficult to do, but before we talk about costing and exact API shape, we should think about the impact of delegate equality on allowing mixed multicast delegates.\r\n\r\nDelegates are considered equal in .NET if their types are the same and\r\n* For multicast delegates, the invocation list is the same\r\n* For singlecast delegates their function pointer and captured first parameter is the same\r\n\r\nThere are some subtleties, but \"if their types are the same\" is the important part for this discussion.\r\n\r\nSuppose someone has this existing code somewhere (adapted from Jan\u0027s example above):\r\n\r\n```csharp\r\nFunc\u003cIFace1, object\u003e d1 = SomeFunction1;\r\nFunc\u003cIFace1, object\u003e d2 = SomeFunction2;\r\n\r\nFunc\u003cIFace, object\u003e e1 = d1;\r\nFunc\u003cIFace, object\u003e e2 = d2;\r\n\r\nvar d = e1 + e2;\r\n```\r\n\r\nThe code currently works, and produces an instance of `Func\u003cIFace1, object\u003e` in `d` (while statically typed as `Func\u003cIFace, object\u003e` in C#).\r\n\r\nIf we add a new `Combine` API that specifies the type of the new, combined, delegate that returns an instance of `Func\u003cIFace, object\u003e`, it will break equality for anyone who compares it to a `Func\u003cIFace1, object\u003e` with the same invocation list. We could maybe tweak the API to only use the provided type if the types of the combined delegates are different, but it\u0027s going to introduce subtleties, especially around how `Remove` works in these mixed delegates (what does it mean to have an equal delegate in the invocation list).\r\n\r\nI\u0027m still trying to figure out if there\u0027s real implications (besides maybe a perf hit for `Combine`/`Remove`), but I wanted to write down where I am right now.",
                                           "updatedAt":  "2019-01-23T18:44:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1NzQxMTkxOA==",
                                           "createdAt":  "2019-01-25T00:37:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gafter",
                                           "body":  "\u003e The code currently works, and produces an instance of `Func\u003cIFace1, object\u003e` in `d` (while statically typed as `Func\u003cIFace, object\u003e` in C#).\r\n\r\nThis code does not work in some cases.\r\n\r\n``` c#\r\nusing System;\r\npublic class C {\r\n    public static void Main() {\r\n        Func\u003cIFace1, object\u003e d1 = SomeFunction1;\r\n        Func\u003cIFace1, object\u003e d2 = SomeFunction2;\r\n\r\n        Func\u003cIFace, object\u003e e1 = d1;\r\n        Func\u003cIFace, object\u003e e2 = d2;\r\n\r\n        var d = e1 + e2;\r\n    }\r\n    \r\n    static Func\u003cIFace1, object\u003e SomeFunction1 = SomeFunction1Impl;\r\n    static object SomeFunction1Impl(IFace1 o) =\u003e o;\r\n    static Func\u003cIFace2, object\u003e SomeFunction2 = SomeFunction2Impl;\r\n    static object SomeFunction2Impl(IFace2 o) =\u003e o;\r\n}\r\n\r\ninterface IFace2 { }\r\ninterface IFace1 : IFace2 { }\r\ninterface IFace : IFace1 { }\r\n```\r\n\r\nThe new API should use the runtime type of the delegate if they are the same, reproducing the current behavior.  Only if they are not the same (in which case the current API would fail) would the new API produce a delegate of the provided runtime type.  This would be compatible.  In either case it would produce an object of the provided static type.\r\n\r\n",
                                           "updatedAt":  "2019-01-25T00:37:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5MzU2NjcwNA==",
                                           "createdAt":  "2020-09-16T17:58:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "Hi @gafter is this something we need to consider for 6?",
                                           "updatedAt":  "2020-09-16T17:58:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczNjE3MjA2MQ==",
                                           "createdAt":  "2020-12-01T02:17:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "Would this also work for changing the type of a delegate? For example, say that I have a `Predicate\u003cstring\u003e`, but I need a `Func\u003cstring, bool\u003e`. There\u0027s one kinda-hokey workaround right now:\r\n\r\n```cs\r\nPredicate\u003cstring\u003e del1 = GetDelegate();\r\nFunc\u003cstring, bool\u003e del2 = del1.Invoke; // points to Predicate\u003cstring\u003e.Invoke\u0027s MethodDesc\r\n```\r\n\r\nBut this isn\u0027t ideal since it\u0027s a hidden recursive operation: every invocation incurs an extra indirection. With a new `Combine` method, maybe something like the below would be possible?\r\n\r\n```cs\r\nPredicate\u003cstring\u003e del1 = GetDelegate();\r\nFunc\u003cstring, bool\u003e del2 = (Func\u003cstring, bool\u003e)Delegate.Combine(del1, null, typeof(Func\u003cstring, bool\u003e)); // points to whatever MethodDesc del1 pointed to\r\n```",
                                           "updatedAt":  "2020-12-01T02:17:50Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczNjE3OTEzOQ==",
                                           "createdAt":  "2020-12-01T02:39:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOB9KhPw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "GrabYourPitchforks",
                                                                               "createdAt":  "2020-12-01T02:57:06Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jaredpar",
                                                                               "createdAt":  "2020-12-01T12:53:38Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "TylerBrinkley",
                                                                               "createdAt":  "2020-12-01T14:04:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "sakno",
                                                                               "createdAt":  "2021-10-06T09:20:56Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "jkotas",
                                           "body":  "The original intention of this proposal was to only deal with generic variance. The runtime check for generic variance is cheap or free (depends on the design of the API).\r\n\r\nYou are asking for ability to retype delegates. The runtime check for that is much more involved (requires walking and comparing signatures, etc.). I think we would want it to be different API.",
                                           "updatedAt":  "2020-12-01T02:39:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43yAOl",
                                           "createdAt":  "2021-10-06T09:41:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sakno",
                                           "body":  "I\u0027m also (still) waiting for this feature since the last [post](https://stackoverflow.com/questions/6065898/combining-delegates-and-contravariance) by Eric Lippert on StackOverflow.\r\n\r\n`Delegate.Combine(Delegate d1, Delegate d2)` requires runtime check for generic variance. Probably yes, it can be cheap. But I believe we can do better and hint the target type to the runtime:\r\n\r\n```csharp\r\npublic abstract class Delegate\r\n{\r\n  public static TDelegate Combine\u003cTDelegate\u003e(TDelegate d1, TDelegate d2) where TDelegate : MulticastDelegate;\r\n}\r\n```\r\n\r\nWith this helper method, the variance is controlled at compile-time. The runtime is responsible for constructing the final delegate without any checks. The target type is known by the compiler.\r\n\r\nFor instance,\r\n```csharp\r\nAction\u003cstring\u003e? chain = null;\r\n\r\nstatic void Action1(object obj) { }\r\nstatic void Action2(IEnumerable\u003cchar\u003e enumerable) { }\r\n\r\nchain += new Action\u003cobject\u003e(Action1);\r\nchain += new Action\u003cIEnumerable\u003cchar\u003e\u003e(Action2);\r\n```\r\n\r\nCan be translated to the following code by Roslyn:\r\n```csharp\r\nchain = Delegate.Combine\u003cAction\u003cstring\u003e\u003e(chain, new Action\u003cobject\u003e(Action1));\r\nchain = Delegate.Combine\u003cAction\u003cstring\u003e\u003e(chain, new Action\u003cIEnumerable\u003cchar\u003e\u003e(Action2));\r\n```\r\n\r\nThe actual generic type can be inferred by compiler using `lvalue` of `+=`/`+` operator.",
                                           "updatedAt":  "2021-10-06T09:42:54Z"
                                       }
                                   ],
                         "totalCount":  30
                     },
        "title":  "Combine of covarince/contravariance delegates",
        "labels":  [
                       "enhancement",
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/4945",
        "createdAt":  "2016-01-15T01:28:47Z",
        "number":  4945,
        "author":  "nguerrera",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-03-26T10:24:20Z",
        "body":  "In the process of developing signature parsing facilities for System.Reflection.Metadata, I came across some discrepancies in the CLI specification vs. various signature parsing implementations.\n\nMy notes on that are here: https://github.com/dotnet/corefx/pull/5435\n\nOne such discrepancy is that the specification states that the encoded token following CMOD_OPT/CMOD_REQ is a TypeDef or TypeRef, but it can be TypeSpec in practice.\n\nThis opens up a loophole to cycles as TypeSpecs can contain modifiers, and modifiers can contain TypeSpecs. I put together some quick code to create such bad TypeSpecs here in https://github.com/nguerrera/signature-repros and experimented with ilasm, peverify, and running the resulting programs.\n# Repro steps\n1. git clone https://github.com/nguerrera/signature-repros \n2. cd signature-repros\n3. build.bat\n4. ildasm SignatureCycle1.exe\n5. peverify SignatureCycle1.exe\n6. SignatureCycle1.exe\n7. repeat steps 4-6 for SignatureCycle2.exe and SignatureCycle3.exe\n# Expected results\n\nFor all 3 programs:\n- ildasm succeeds, but indicates a bad signature as it does in other cases.\n- peverify reports the signature as invalid\n\nIf the particular program causes the runtime to have to inspect the bad modifiers contents rather than just skip the bad typespec token:\n- An appropriate BadImageFormat/InvalidProgram/TypeLoadException is raised.\n# Actual results\n- ildasm crashes in all 3 cases\n- peverify sometimes succeeds without error, sometimes crashes\n- program sometimes crashes with stack overflow rather than a meaningful BadImageFormat/InvalidProgram/TypeLoadException.\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOKVcDJw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5MzU2ODI5NQ==",
                                           "createdAt":  "2020-09-16T18:01:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "Moving to 6 to triage. ",
                                           "updatedAt":  "2020-09-16T18:01:31Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Issues with malformed cyclical TypeSpec",
        "labels":  [
                       "area-TypeSystem-coreclr",
                       "in-pr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/7176",
        "createdAt":  "2016-12-30T23:42:29Z",
        "number":  7176,
        "author":  "lilith",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCOWS5g==",
                          "nodes":  [
                                        {
                                            "content":  "HEART",
                                            "user":  "jnm2",
                                            "createdAt":  "2016-12-30T23:45:00Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "adamralph",
                                            "createdAt":  "2016-12-31T00:08:11Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "Jetski5822",
                                            "createdAt":  "2016-12-31T00:42:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Jetski5822",
                                            "createdAt":  "2016-12-31T00:42:33Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "shahid-pk",
                                            "createdAt":  "2016-12-31T17:04:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "liquidboy",
                                            "createdAt":  "2016-12-31T22:31:29Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "kijanawoodard",
                                            "createdAt":  "2017-02-07T20:47:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ig-sinicyn",
                                            "createdAt":  "2017-03-07T05:27:51Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Lakritzator",
                                            "createdAt":  "2017-04-13T09:01:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jrlost",
                                            "createdAt":  "2017-06-09T17:36:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pnstickne",
                                            "createdAt":  "2017-06-27T01:02:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "schotime",
                                            "createdAt":  "2017-08-28T05:19:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "gabrielsadaka",
                                            "createdAt":  "2017-08-28T05:19:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "bmermet",
                                            "createdAt":  "2018-02-07T17:56:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "itsmecurtis",
                                            "createdAt":  "2018-06-26T07:17:42Z"
                                        },
                                        {
                                            "content":  "THUMBS_DOWN",
                                            "user":  "masonwheeler",
                                            "createdAt":  "2018-08-21T19:19:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "viktor-svub",
                                            "createdAt":  "2019-04-08T11:15:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "michaelherndon",
                                            "createdAt":  "2019-12-17T16:14:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "martinbliss",
                                            "createdAt":  "2020-03-26T01:51:05Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "martinbliss",
                                            "createdAt":  "2020-03-26T01:51:09Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "manigandham",
                                            "createdAt":  "2021-08-13T05:58:06Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "manigandham",
                                            "createdAt":  "2021-08-13T05:58:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "alessandromuresan",
                                            "createdAt":  "2021-10-21T12:04:52Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "alessandromuresan",
                                            "createdAt":  "2021-10-21T12:04:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "0xfeeddeadbeef",
                                            "createdAt":  "2022-02-12T09:18:07Z"
                                        }
                                    ],
                          "totalCount":  25
                      },
        "updatedAt":  "2025-01-06T19:22:51Z",
        "body":  "We were very close to achieving loose coupling in .NET via [Assembly Neutral Interfaces](http://davidfowl.com/assembly-neutral-interfaces/)... then victory was snatched from our grasp with [its removal in 2015](https://github.com/aspnet/dnx/pull/1206). I know this would also [need to be added to .NET Full](https://github.com/aspnet/dnx/issues/2003), but it is a very worthwhile feature. \r\n\r\nDiamond dependencies are a problem, MxN adapter proliferation is madness, and [this is a pain point even for basic tasks](https://github.com/aspnet/Logging/issues/332). This small thing would represent a significant reduction in pain/friction for OSS authors seeking interoperability with other packages. We\u0027re tired. We want our time and keystrokes to go farther, and preferably while remaining on .NET\r\n\r\n\r\nTrue [structural typing has been suggested for C#](https://github.com/dotnet/roslyn/issues/7844), but it looks like this is unlikely to get any attention. **foreach + GetEnumerator** alone gets this special ability. ANI consumption was supported by all CLR languages.\r\n\r\nIf the NuGet ecosystem is never able to expand past the interfaces in System.*, how will we ever start making progress on library compatibility?\r\n\r\nAdding dependencies just for interface assemblies does not happen, particularly if interoperability is not absolutely crucial. It\u0027s not worth the risk and cost. \r\n\r\nI\u0027d like to reiterate the comments when the supporting [~900 lines of code for ANI were pulled](https://github.com/aspnet/dnx/commit/5f8bf5614d04b82dc69aedf48a5b2f832f00ca8f#comments). \r\n\r\n\"BOOOOOOOO!\" - @ChrisMcKee\r\n\"*Why?*\" - @adamralph \r\n\"yeah, whats with this?\" - @Jetski5822\r\n\"NOOO!\" - @markrendle\r\n\r\nAnd kindly request that this feature be reconsidered for inclusion in both versions of .NET. \r\n\r\n\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOmWh9rw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI2OTg3MDc4MA==",
                                           "createdAt":  "2016-12-31T15:54:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCstxwg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "adamralph",
                                                                               "createdAt":  "2016-12-31T16:56:02Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "shahid-pk",
                                                                               "createdAt":  "2016-12-31T17:04:51Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "jnm2",
                                                                               "createdAt":  "2016-12-31T17:25:56Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "liquidboy",
                                                                               "createdAt":  "2016-12-31T22:31:51Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "lilith",
                                                                               "createdAt":  "2017-01-01T22:04:12Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "kijanawoodard",
                                                                               "createdAt":  "2017-01-02T16:27:59Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Lakritzator",
                                                                               "createdAt":  "2017-04-13T09:01:06Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "alessandromuresan",
                                                                               "createdAt":  "2022-09-23T13:19:59Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alessandromuresan",
                                                                               "createdAt":  "2022-09-23T13:20:04Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  9
                                                         },
                                           "author":  "jkotas",
                                           "body":  "The ANI prototype had bad performance characteristics. It would be performance disaster if it gets used broadly in the form that it was implemented.\r\n\r\n@davidwrighton and @jaredpar are looking into how to do it properly.",
                                           "updatedAt":  "2016-12-31T22:10:09Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI2OTg4MzQyMQ==",
                                           "createdAt":  "2016-12-31T22:03:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "That\u0027s the first I\u0027m hearing about this and it makes me very happy 😊 ",
                                           "updatedAt":  "2016-12-31T22:03:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI2OTg4NjAyOQ==",
                                           "createdAt":  "2016-12-31T23:34:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "damianh",
                                           "body":  "@jkotas Is there an issue to track this or anything to share (even thoughts) at this point?\r\n\r\nI, for one, look forward to killing `LibLog`.",
                                           "updatedAt":  "2016-12-31T23:34:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMwODAxMTY5Mw==",
                                           "createdAt":  "2017-06-13T05:36:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "graemechristie",
                                           "body":  "Is there any update on this @davidwrighton and @jaredpar ? Is there somewhere we can track the progress of the new feature ?",
                                           "updatedAt":  "2017-06-13T05:36:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMwODEzNDY2Ng==",
                                           "createdAt":  "2017-06-13T14:28:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAUdo9Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "NinoFloris",
                                                                               "createdAt":  "2017-09-04T14:05:15Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hugufc",
                                                                               "createdAt":  "2018-03-27T18:10:37Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "jaredpar",
                                           "body":  "@graemechristie no updates as of yet.  A couple of other items have priority at the moment.  Going to switch back to ANI / other type system innovations later in the summer. ",
                                           "updatedAt":  "2017-06-13T14:28:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM0OTg2Mjc5Mw==",
                                           "createdAt":  "2017-12-07T04:54:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "graemechristie",
                                           "body":  "Are there any more updates on this @davidwrighton and @jaredpar ? ",
                                           "updatedAt":  "2017-12-07T04:54:50Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY1Mzk5OTc1NQ==",
                                           "createdAt":  "2020-07-06T03:46:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBJa4pQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "davidfowl",
                                                                               "createdAt":  "2020-07-06T04:55:13Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "kzu",
                                           "body":  "Would love to see some movement on this one. I think it can be big to grow the ecosystem more easily and achieve quicker agreements on shared contacts.",
                                           "updatedAt":  "2020-07-06T03:46:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY1NDEwMTY1NA==",
                                           "createdAt":  "2020-07-06T08:46:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "adamralph",
                                           "body":  "I guess now that .NET is going to be a single platform (.NET 5) and no more .NET Framework, this will be easier?",
                                           "updatedAt":  "2020-07-06T08:46:53Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY1NDQwMjU0MQ==",
                                           "createdAt":  "2020-07-06T18:41:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODmEDCw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "schotime",
                                                                               "createdAt":  "2020-07-07T07:07:31Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "kzu",
                                                                               "createdAt":  "2020-08-27T06:32:33Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "damianh",
                                                                               "createdAt":  "2020-09-21T17:43:40Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ericsampson",
                                                                               "createdAt":  "2020-10-07T20:37:04Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ReubenBond",
                                                                               "createdAt":  "2021-01-22T19:58:43Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "rcollina",
                                                                               "createdAt":  "2021-01-23T11:37:17Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "poke",
                                                                               "createdAt":  "2021-01-23T19:24:09Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "manigandham",
                                                                               "createdAt":  "2021-08-13T05:58:20Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ChrisMcKee",
                                                                               "createdAt":  "2021-12-02T11:01:19Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alessandromuresan",
                                                                               "createdAt":  "2022-09-23T13:20:35Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "alessandromuresan",
                                                                               "createdAt":  "2022-09-23T13:20:38Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hoetz",
                                                                               "createdAt":  "2024-06-18T09:02:20Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  12
                                                         },
                                           "author":  "jaredpar",
                                           "body":  "I plan to revisit this for the post .NET 5 world. Still heads down on .NET 5 at the moment though. ",
                                           "updatedAt":  "2020-07-06T18:41:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ZUtjC",
                                           "createdAt":  "2025-01-06T06:04:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lilith",
                                           "body":  "Bump\r\n\r\nOn Sun, Jan 5, 2025, 12:32 PM dotnet-policy-service[bot] \u003c\r\n***@***.***\u003e wrote:\r\n\r\n\u003e Due to lack of recent activity, this issue has been marked as a candidate\r\n\u003e for backlog cleanup. It will be closed if no further activity occurs within\r\n\u003e 14 more days. Any new comment (by anyone, not necessarily the author) will\r\n\u003e undo this process.\r\n\u003e\r\n\u003e This process is part of our issue cleanup automation\r\n\u003e \u003chttps://github.com/dotnet/runtime/blob/main/docs/issue-cleanup.md\u003e.\r\n\u003e\r\n\u003e —\r\n\u003e Reply to this email directly, view it on GitHub\r\n\u003e \u003chttps://github.com/dotnet/runtime/issues/7176#issuecomment-2571728260\u003e,\r\n\u003e or unsubscribe\r\n\u003e \u003chttps://github.com/notifications/unsubscribe-auth/AAA2LH3DRTPBAEBEBQDGVPD2JGCDJAVCNFSM6AAAAABUUM37G6VHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDKNZRG4ZDQMRWGA\u003e\r\n\u003e .\r\n\u003e You are receiving this because you authored the thread.Message ID:\r\n\u003e ***@***.***\u003e\r\n\u003e\r\n",
                                           "updatedAt":  "2025-01-06T06:04:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ZaH2v",
                                           "createdAt":  "2025-01-06T19:22:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEDLcyw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "kzu",
                                                                               "createdAt":  "2025-01-20T01:39:55Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "julealgon",
                                           "body":  "@lilith , @davidfowl \u0027s blog post link in the OP is now broken. Is that mantained somewhere else? Can the link be updated?\n\nI found this other article that explains this concept while looking for it:\n- [What is an Assembly Neutral Interface and why do we need it?](https://davidzych.com/what-is-an-assembly-neutral-interface-and-why-do-we-need-it/)\n\n---\n\n\u003e I plan to revisit this for the post .NET 5 world.\n\n@jaredpar do you have any updates on this since that last post you shared?",
                                           "updatedAt":  "2025-01-06T19:22:50Z"
                                       }
                                   ],
                         "totalCount":  11
                     },
        "title":  "Bring back Assembly Neutral Interfaces",
        "labels":  [
                       "enhancement",
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/9588",
        "createdAt":  "2018-01-23T13:10:20Z",
        "number":  9588,
        "author":  "MichalStrehovsky",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC5vySQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2024-07-27T23:18:30Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2022-07-19T15:23:39Z",
        "body":  "Interface methods on generic types require an instantiating stub which the current devirtualization code doesn\u0027t provide.\r\n\r\nThis is just a perf issue, not a correctness issue.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  null,
                         "nodes":  [

                                   ],
                         "totalCount":  0
                     },
        "title":  "[Default interfaces] Support for default interface method devirtualization",
        "labels":  [
                       "tenet-performance",
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/11400",
        "createdAt":  "2018-11-04T17:56:29Z",
        "number":  11400,
        "author":  "jkotas",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-07-09T23:24:18Z",
        "body":  "Repro:\r\n\r\n`dotnet run -c Release`\r\nActual result: Prints ERRORs or crashes during GC within seconds\r\nExpected result: Runs forever without error\r\n\r\n```csharp\r\nusing System;\r\nusing System.Threading;\r\nusing System.Runtime.InteropServices;\r\n\r\n[StructLayout(LayoutKind.Sequential, Pack = 1)]\r\ninternal ref struct NumberBuffer\r\n{\r\n    public bool Sign;\r\n    public Span\u003cchar\u003e Digits;\r\n}\r\n\r\nclass Program\r\n{\r\n    static int MoreWork(ref NumberBuffer buffer)\r\n    {\r\n        for (int i = 0; i \u003c buffer.Digits.Length; i++)\r\n            buffer.Digits[i % buffer.Digits.Length] = (char)i;\r\n        int sum = 0;\r\n        for (int i = 0; i \u003c buffer.Digits.Length; i++)\r\n            sum += buffer.Digits[i];\r\n        return sum;\r\n    }\r\n\r\n    static char[][] s = new char[1000][];\r\n\r\n    static void Work()\r\n    {\r\n        Random r = new Random();\r\n        for (;;)\r\n        {\r\n            NumberBuffer buffer = default;\r\n            buffer.Digits = s[r.Next(s.Length)];\r\n            if (buffer.Digits.Length == 0) continue;\r\n            int sum = MoreWork(ref buffer);\r\n            if (sum != 499500)\r\n                Console.WriteLine(\"ERROR: \" + sum);\r\n        }\r\n    }\r\n\r\n    static void Main(string[] args)\r\n    {\r\n        new Thread(Work).Start();\r\n        new Thread(Work).Start();\r\n        new Thread(Work).Start();\r\n\r\n        Random r = new Random();\r\n        for (;;) { s[r.Next(s.Length)] = new char[1000]; GC.KeepAlive(new char[r.Next(1000)]); }\r\n    }\r\n}\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOHkdrMg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQzNTY5MTI5Nw==",
                                           "createdAt":  "2018-11-04T17:58:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Related to https://github.com/dotnet/corert/issues/6512. I think the type loader should ignore the Pack directive and align byref fields as pointers; similar to what it does for regular objref fields.",
                                           "updatedAt":  "2018-11-04T17:58:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwNzk5Njk3OA==",
                                           "createdAt":  "2019-07-03T08:34:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "Moving this out to Future. This requires changes in type layout that look very risky. https://github.com/dotnet/coreclr/pull/25056#issuecomment-505564364",
                                           "updatedAt":  "2019-07-03T08:34:28Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Bad GC info generated for structures that contain Span field and small packing",
        "labels":  [
                       "bug",
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/12024",
        "createdAt":  "2019-02-12T21:35:11Z",
        "number":  12024,
        "author":  "gafter",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCqCPQg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SupinePandora43",
                                            "createdAt":  "2022-08-09T08:17:10Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2021-04-18T15:40:28Z",
        "body":  "Consider the following code: \r\n\r\n```\r\nstruct ImmutableArray\u003cT\u003e\r\n{\r\n    private T[] _array;\r\n}\r\n\r\nstruct S\r\n{\r\n    internal readonly ImmutableArray\u003cS\u003e More;\r\n}\r\n\r\nclass Program\r\n{\r\n    static void Main()\r\n    {\r\n        F();\r\n    }\r\n\r\n    static void F()\r\n    {\r\n        var s = new S();\r\n    }\r\n}\r\n```\r\n\r\nThis code will compile with C# 6.0 and is legal according to the CLI spec.  The type definition is recursive but the layout of the struct is not because the field involved here is an array (just a reference).  The CLR is unable to handle this though and fails at runtime with a `TypeLoadException`\r\n\r\nSee also https://github.com/dotnet/coreclr/issues/4049 and https://github.com/dotnet/coreclr/issues/7957\r\n/cc @cston @jaredpar @jkotas \r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOMP7nMQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyMjAxMTY5Nw==",
                                           "createdAt":  "2021-04-18T15:40:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tristanlabelle",
                                           "body":  "I hit this today with the reduced code below. The original code was trying to make an immutable array of common values for the struct available as a static member.\r\n\r\n```cs\r\nstruct Foo\r\n{\r\n\tstatic ImmutableArray\u003cFoo\u003e Array = ImmutableArray\u003cFoo\u003e.Empty;\r\n}\r\n```",
                                           "updatedAt":  "2021-04-18T15:40:28Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Arrays should not contribute to cyclic struct layout",
        "labels":  [
                       "bug",
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/12886",
        "createdAt":  "2019-06-13T19:16:07Z",
        "number":  12886,
        "author":  "AlekseyTs",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCu0mLg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hamarb123",
                                            "createdAt":  "2023-03-11T18:33:51Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2023-08-01T04:27:26Z",
        "body":  "In C# and VB we are planning to add support for a special expression representing an invocation of an implementation of a particular virtual method from a specific base type. This includes virtual methods declared in classes as well as in interfaces. \r\n\r\nCompilers have to make sure that there is a most specific implementation of the method in the specified base type, and, in that case, emit an instruction that “says”: “Runtime, call the most specific implementation of this method in the type specified. If the method is an interface method, the implementation method should be called with a virtual dispatch. If the method is a class method, the implementation method should be called non virtually.”\r\n\r\nThe IL instruction or the pattern should capture the following information about the target of the invocation:\r\n- A receiver\r\n- A method which implementation should be found and invoked. The receiver should derive (including interface implementations) from the type declaring the method.\r\n- A type in which to look for the implementation. Receiver should derive from this type, this type should be the same or derive from the type declaring the method.\r\n\r\nPossibly a usage of constrained prefix can be expanded. Or a new IL instruction added. Also, we should make sure that it is possible to create function pointers that capture the same semantics, primary usage scenarios - creation/invocation of delegates.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYuqq4w==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwNDEyMzM3MA==",
                                           "createdAt":  "2019-06-20T17:58:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jzabroski",
                                           "body":  "Something to think about before diving too deep into a new IL instruction: .NET currently does not support the composition of open instance delegates to generic interface methods.\r\n\r\nSome background: http://higherlogics.blogspot.com/2011/08/open-instance-delegate-for-generic.html\r\n\r\nWhile the linked blog post was written in 2011, it remains true on netcoreapp2.2 today. - Just tested to make sure.\r\n\r\nSimilarly, before adding a bunch of magic, maybe add a regression suite on this stuff.  Developers hate when syntactically valid programs are semantically not supported.",
                                           "updatedAt":  "2019-06-20T23:48:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwODgyMzcwNg==",
                                           "createdAt":  "2019-07-05T17:36:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mburbea",
                                           "body":  "@jzabroski,\r\nThis is true. But my awful solution suggested on stackoverflow still does work.\r\n```cs\r\npublic class C\r\n{\r\n    public virtual void DoNothing\u003cT\u003e()=\u003e Console.WriteLine(typeof(T));\r\n}\r\n\r\nvar dynamicMethod = new DynamicMethod(\"a\", typeof(void), new[] { typeof(C) }, typeof(object), true);\r\nvar ilgen = dynamicMethod.GetILGenerator();\r\nilgen.Emit(OpCodes.Ldarg_0);\r\nilgen.Emit(OpCodes.Dup);\r\nilgen.Emit(OpCodes.Ldvirtftn, typeof(C).GetMethod(\"DoNothing\").MakeGenericMethod(typeof(int)));\r\nilgen.Emit(OpCodes.Calli, SignatureHelper.GetMethodSigHelper(CallingConventions.HasThis, typeof(void)));\r\nilgen.Emit(OpCodes.Ret);\r\n(dynamicMethod.CreateDelegate(typeof(Action\u003cC\u003e)) as Action\u003cC\u003e).Invoke(new C())\r\n```\r\nNow why does `calli` support it and not delegates? Who knows. ",
                                           "updatedAt":  "2019-07-05T18:20:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwODgzMTM2NA==",
                                           "createdAt":  "2019-07-05T18:13:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jzabroski",
                                           "body":  "@mburbea What SO post are you referring to? Thanks.",
                                           "updatedAt":  "2019-07-05T18:13:08Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwODgzMjc5NA==",
                                           "createdAt":  "2019-07-05T18:20:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mburbea",
                                           "body":  "The blog post you linked mentions a SO link.\n\nOn Fri, Jul 5, 2019, 2:13 PM John Zabroski \u003cnotifications@github.com\u003e wrote:\n\n\u003e @mburbea \u003chttps://github.com/mburbea\u003e What SO post are you referring to?\n\u003e Thanks.\n\u003e\n\u003e —\n\u003e You are receiving this because you were mentioned.\n\u003e Reply to this email directly, view it on GitHub\n\u003e \u003chttps://github.com/dotnet/coreclr/issues/25156?email_source=notifications\u0026email_token=AABUB4OHI45VOQDLELKX673P56FOBA5CNFSM4HX5GFO2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODZKCNBA#issuecomment-508831364\u003e,\n\u003e or mute the thread\n\u003e \u003chttps://github.com/notifications/unsubscribe-auth/AABUB4KBASDBNYJ4K6WRPBLP56FOBANCNFSM4HX5GFOQ\u003e\n\u003e .\n\u003e\n",
                                           "updatedAt":  "2019-07-05T18:20:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwODg0MjA4OQ==",
                                           "createdAt":  "2019-07-05T19:10:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jzabroski",
                                           "body":  "OK, my point is that open delegates _should_ use the same dispatch logic as the rest of the CLR, unless there is a good reason not to.\r\n\r\n@AlekseyTs said at the end of his request:\r\n\r\n\u003e Also, we should make sure that it is possible to create function pointers that capture the same semantics, primary usage scenarios - creation/invocation of delegates.\r\n\r\nRather than add new instructions or patterns, we should probably first revisit what and why the CLR does what it does today.  The only clue is this paragraph from the [ECMA-335](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf) CLI specification (emphasis mine):\r\n\r\n\u003e Delegates shall be declared sealed, and the only members a delegate shall have are either the first two or all four methods as specified here. These methods shall be declared runtime and managed (§II.15.4.3). **They shall not have a body, since that body shall be created automatically by the VES**. Other methods available on delegates are inherited from the class System.Delegate in the Base Class Library (see Partition IV).\r\n\r\nMy hunch has always been that the constraint that the Virtual Execution System (VES) causes this to not be possible, presumably because it is too low-level to know how to handle such things.  But I\u0027ve not investigated.  I guess now that it\u0027s open source it\u0027s possible to investigate.  My second hunch is that calli bypasses the VES entirely.",
                                           "updatedAt":  "2019-07-05T19:13:22Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwODg2NDYzMw==",
                                           "createdAt":  "2019-07-05T21:22:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAr7I7A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "jzabroski",
                                                                               "createdAt":  "2019-07-05T21:34:41Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "mattwarren",
                                           "body":  "\u003e But I\u0027ve not investigated. I guess now that it\u0027s open source it\u0027s possible to investigate.\r\n\r\n@jzabroski This post I wrote [How do .NET delegates work?](https://mattwarren.org/2017/01/25/How-do-.NET-delegates-work/) might help you get started if you want to investigate (I don\u0027t *think* the post on its own answers your question, but it might help)",
                                           "updatedAt":  "2019-07-05T21:22:04Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2NjI5NTkyNw==",
                                           "createdAt":  "2019-12-16T23:27:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOA3aS8w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2019-12-17T01:28:17Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "davidwrighton",
                                           "body":  "These are my thoughts on the additional runtime support needed for the `base(T)` feature request.\r\n\r\nWe should be able to support this with a variation on the constrained prefix. This is my idea of what the spec would generally look like.\r\n```\r\n.constrained \u003ctype\u003e call \u003cmethod\u003e\r\nStack Transition:\r\n..., this reference, arg1, arg2, arg3, argN -\u003e ..., retVal (not always returned)\r\n```\r\nDescription:\r\nThe `.constrained \u003ctype\u003e call \u003cmethod\u003e` instruction calls implementation of the method indicated by the descriptor method on the type `\u003ctype\u003e`. This sequence may be preceded by the `.tail` prefix to specify that the current method state should be released before transferring control. If `\u003ctype\u003e` is an interface, the target method is chosen using the default interface method resolution rules where `\u003ctype\u003e` is the most derived interface. If `\u003ctype\u003e` is not an interface type, the target method is resolved by computing the normal virtual resolution algorithm as if it was called on an object of runtime type `\u003ctype\u003e`, and calling that method. If `\u003cmethod\u003e` is an interface method, and the resolution would be ambiguous, throw an `AmbiguousMatchException` (as with other failed Default Interface Method resolution failures). If the resolution does not find a target method body, throw an `System.EntryPointNotFoundException`.\r\n\r\nIf `\u003ctype\u003e` is an interface type, `\u003cmethod\u003e` must be defined on an interface type.\r\nIf `\u003ctype\u003e` is not an interface type, `\u003cmethod\u003e` must be defined on a class.\r\n\r\n*Add note about how `\u003cmethod\u003e` resolves that matches the details of method token resolution as specified in the call instruction*\r\n\r\nCorrectness:\r\nCorrect CIL ensures that the `\u003cmethod\u003e` is defined on `\u003ctype\u003e` or on a superclass of `\u003ctype\u003e`. `\u003ctype\u003e` must be a reference type. `\u003cmethod\u003e` must be a virtual or abstract function. `\u003cmethod\u003e` must be an instance function.\r\n\r\nVerifiability:\r\nVerification checks to ensure that `\u003ctype\u003e` is a superclass of the type that defines the method being compiled, and that `\u003cmethod\u003e` is accessible to the method providing IL. and the types of the objects on the stack are consistent with the types expected by the method call. It also verifies that the first parameter is `this` pointer if the current IL method body is defined on a reference type, or a boxed instance of the current method bodie\u0027s type.",
                                           "updatedAt":  "2019-12-17T01:31:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2NjMwMjQ2OQ==",
                                           "createdAt":  "2019-12-16T23:48:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jzabroski",
                                           "body":  "@davidwrighton Can you edit your post to fix the `\u003cT\u003e` references?  It makes it hard to grok what you were saying, and took me awhile to figure out what you were saying.  You can use the backtick operator for inline code on Github. Thanks in advance.",
                                           "updatedAt":  "2019-12-16T23:48:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NDkzMzU1OQ==",
                                           "createdAt":  "2020-01-16T01:12:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "IS4Code",
                                           "body":  "How is this different from simple `call`?",
                                           "updatedAt":  "2020-01-16T16:55:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NTI5Nzg4Ng==",
                                           "createdAt":  "2020-01-16T19:06:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidwrighton",
                                           "body":  "The difference is that the actual method called may not be the same as the method referenced by the instruction, if the method is overrided by the type it is constrained to. The primary purpose for the new instruction is around behavior of default interface methods, and the multiple-inheritance style overriding that is available through their use. (Although there are some more subtle benefits for base calls on classes.)",
                                           "updatedAt":  "2020-01-16T19:06:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5i6qrj",
                                           "createdAt":  "2023-08-01T04:27:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "What is the state of this feature currently? I\u0027m really looking forward to it!\r\n\r\ncc @davidwrighton @MichalStrehovsky",
                                           "updatedAt":  "2023-08-01T04:27:26Z"
                                       }
                                   ],
                         "totalCount":  11
                     },
        "title":  "Feature request: New IL instruction or new IL pattern to represent an invocation of a method implementation found in specific base type ",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/13330",
        "createdAt":  "2019-08-28T20:54:57Z",
        "number":  13330,
        "author":  "lostmsu",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCqxELQ==",
                          "nodes":  [
                                        {
                                            "content":  "HEART",
                                            "user":  "ChristophTF",
                                            "createdAt":  "2021-02-24T11:19:14Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "rodrigo-speller",
                                            "createdAt":  "2021-06-09T02:41:03Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "snipervld",
                                            "createdAt":  "2022-09-28T08:56:51Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2021-06-09T13:27:57Z",
        "body":  "Right now the only way to resolve an external function declared like\r\n`static extern ReturnType FunctionName(Args...)` is to mark it with `DllImport` attribute, so that CLR would load this function from an external assembly.\r\n\r\nI propose adding a new attribute, that could be used in place of `DllImport` which CLR should recognize, and whose behavior can be customized in managed code.\r\n\r\n```csharp\r\npublic abstract class AbstractExternResolverAttribute: Attribute {\r\n  public abstract MethodInfo /* or IntPtr */ Resolve(MethodInfo externMethod);\r\n}\r\n```\r\n\r\nWhich could later be used like this:\r\n```csharp\r\npublic sealed class MyDllImportAttribute: AbstractExternResolverAttribute {\r\n  readonly string libraryName;\r\n\r\n  public MyDllImportAttribute(string libraryName) { this.libraryName = libraryName; }\r\n\r\n  public override MethodInfo Resolve(MethodInfo externMethod) {\r\n    // here we could do any custom probing for the library\r\n    var library = NativeLibrary.Load(libraryName); \r\n    var export = library.GetFunction(externMethod.Name);\r\n    var delegateType = ...;\r\n    var @delegate = Marshal.GetDelegateForFunctionPointer(export, delegateType);\r\n    return @delegate.Method;\r\n  }\r\n}\r\n```\r\n\r\nThis would enable several things:\r\n1. Fully customizable DLL search, which is a relatively common problem. dotnet/runtime#10759\r\n2. Interfacing with exported functions from languages besides C. I could make a `CppExternResolverAttribute`, that would not only find the appropriate overload of the function given its signature, but could also generate a wrapper method, that would do parameter and result marshaling.\r\n3. Enable some meta programming via reflection. Like deciding to use a native function vs a managed implementation without having to repeat the decision code. Or generating efficient method bodies based on value-typed generic argument.\r\n4. (if possible) Having generic external functions and/or external functions in generic classes, that actually represent different functions for different type parameters. AFAIK it is possible for value types.\r\n\r\nI have to be honest I am clueless about the possibility to describe it in metadata in a backwards-compatible way.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOMx9dQg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyNTk0NjAzNQ==",
                                           "createdAt":  "2019-08-28T22:25:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAvepDg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2019-08-28T22:31:53Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Fully customizable DLL search, which is a relatively common problem\r\n\r\nCustomizable DLL search was addressed by `NativeLibrary.SetDllImportResolver` API added in .NET Core 3.0.\r\n\r\n",
                                           "updatedAt":  "2019-08-28T22:25:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0NTUwMzg5OQ==",
                                           "createdAt":  "2019-10-23T15:36:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KoromaruKoruko",
                                           "body":  "I propose that we expand on the `NativeLibrary.SetDllImportResolver` because it\u0027s extremely limited.\r\njust adding in the MethodInfo of the method being imported would be very helpful as then we can get Attribute Data and maybe even match/validate Method Layout to Multiple different exported functions or even Methods from other Assemblies.\r\n\r\n",
                                           "updatedAt":  "2019-10-23T15:36:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYwOTYzODI0Mw==",
                                           "createdAt":  "2020-04-06T08:01:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Duplicate of https://github.com/dotnet/runtime/issues/1906",
                                           "updatedAt":  "2020-04-06T08:01:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYwOTk3NjM0NA==",
                                           "createdAt":  "2020-04-06T18:57:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lostmsu",
                                           "body":  "@jkotas this is not a duplicate. The other is \"I want my code to be called when runtime sees `DllImport`\". This one is \"I want to declare an attribute, that can be put on `extern` methods, which will be called to resolve them\". It is much more generic.",
                                           "updatedAt":  "2020-04-06T18:57:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYwOTk3OTA2MQ==",
                                           "createdAt":  "2020-04-06T19:02:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lostmsu",
                                           "body":  "@jkotas to be precise, this can be covered by any mechanism to set `MethodInfo` -\u003e `MethodInfo` function on `extern` methods. `DllImport` is a special case here. Not everything needs a DLL and a symbol name.\r\n\r\nTBH though, all of this is unnecessary if statically resolved delegates (e.g. `static readonly MyFunc val = ...`) would be always dispatched without performance hit over regular non-virtual methods.",
                                           "updatedAt":  "2020-04-06T19:02:53Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYwOTk4NDQ2Mg==",
                                           "createdAt":  "2020-04-06T19:14:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "The function pointers that are being introduced for C# will allow you to call methods without paying the delegate overhead. They will be usable only in unsafe context though.\r\n",
                                           "updatedAt":  "2020-04-06T19:14:10Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5NDYyODg2Mg==",
                                           "createdAt":  "2020-09-18T03:36:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "Hey @lostmsu does the function pointer support in c# 9 help with your usecase? ",
                                           "updatedAt":  "2020-09-18T03:36:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5NTExMjc1Mw==",
                                           "createdAt":  "2020-09-18T22:25:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lostmsu",
                                           "body":  "@mangod9 it helps partially, as it is only well-suitable for direct interop with C code.\r\n\r\n1. For managed code the pointer approach makes any call optimization unlikely (e.g. if I resolve `extern` method to a managed function, if it is called via pointer, it is likely not going to be inlined).\r\n\r\n2. Unmanaged but non-C code will likely require extra marshaling work, that would be implemented in C#, which goes back to the problem 1 above.",
                                           "updatedAt":  "2020-09-18T22:25:51Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5NTEzMTQ2Ng==",
                                           "createdAt":  "2020-09-18T23:53:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "Adding @AaronRobinsonMSFT here since this should probably be considered as part of interop rather than typesystem work. ",
                                           "updatedAt":  "2020-09-18T23:53:20Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NzY5MzUwNg==",
                                           "createdAt":  "2021-06-09T13:27:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rodrigo-speller",
                                           "body":  "I think a good approach is to just define the extern method body using ILGenerator. When the Runtime detects a load from an extern method marked with an AbstractExternResolverAttribute implementation, the runtime instantiates an ILGenerator to build the extern method\u0027s body and pass it with its MethodInfo.\r\n\r\n```cs\r\npublic abstract class AbstractExternResolverAttribute : Attribute {\r\n  public abstract void Resolve(MethodInfo externMethod, ILGenerator il);\r\n}\r\n```\r\n\r\nA simple usage example might look like this:\r\n\r\n```cs\r\npublic sealed class MyDllImportAttribute : AbstractExternResolverAttribute {\r\n  readonly string libraryName;\r\n\r\n  public MyDllImportAttribute(string libraryName) { this.libraryName = libraryName; }\r\n\r\n  public override void Resolve(MethodInfo externMethod, ILGenerator il) {\r\n    // here we could do any custom probing for the library\r\n    var library = NativeLibrary.Load(libraryName);\r\n    var export = NativeLibrary.GetExport(library, externMethod.Name);\r\n    Type delegateType = ...;\r\n\r\n    // load the arguments onto the stack\r\n    var parameters = externMethod.GetParameters();\r\n    for (var i = 0; i \u003c parameters.Length; i++)\r\n        il.Emit(OpCodes.Ldarg, i);\r\n\r\n    // call the delegate invocation\r\n    il.Emit(OpCodes.Callvirt, delegateType.GetMethod(\"Invoke\"));\r\n\r\n    // return\r\n    il.Emit(OpCodes.Ret);\r\n  }\r\n}\r\n```\r\n",
                                           "updatedAt":  "2021-06-09T13:27:57Z"
                                       }
                                   ],
                         "totalCount":  10
                     },
        "title":  "Proposal: Custom attribute to provide extern method body at runtime",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/13627",
        "createdAt":  "2019-10-23T14:04:55Z",
        "number":  13627,
        "author":  "tannergooding",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCNPZ1Q==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "john-h-k",
                                            "createdAt":  "2019-10-23T14:09:16Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Gnbrkm41",
                                            "createdAt":  "2019-10-23T14:28:25Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Scott-Caldwell",
                                            "createdAt":  "2019-10-23T14:37:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PJB3005",
                                            "createdAt":  "2019-10-23T14:38:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "NinjaKitt3n",
                                            "createdAt":  "2019-10-23T14:43:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "reflectronic",
                                            "createdAt":  "2019-10-23T14:54:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "JustNrik",
                                            "createdAt":  "2019-10-23T14:59:33Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sylveon",
                                            "createdAt":  "2019-10-23T14:59:50Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "4creators",
                                            "createdAt":  "2019-10-23T16:27:57Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "4creators",
                                            "createdAt":  "2019-10-23T16:28:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ufcpp",
                                            "createdAt":  "2019-10-23T23:57:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hypeartist",
                                            "createdAt":  "2019-11-12T07:30:37Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "hypeartist",
                                            "createdAt":  "2019-11-12T07:30:40Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "Gnbrkm41",
                                            "createdAt":  "2019-11-25T14:01:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sos-dll",
                                            "createdAt":  "2019-11-27T23:37:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kindermannhubert",
                                            "createdAt":  "2020-01-10T17:46:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "EgorBo",
                                            "createdAt":  "2020-02-08T23:34:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PathogenDavid",
                                            "createdAt":  "2020-10-27T01:07:06Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "alexrp",
                                            "createdAt":  "2020-10-27T13:53:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Unknown6656",
                                            "createdAt":  "2020-10-27T14:39:31Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "Unknown6656",
                                            "createdAt":  "2020-10-27T14:39:33Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "Unknown6656",
                                            "createdAt":  "2020-10-27T14:39:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SingleAccretion",
                                            "createdAt":  "2020-11-01T00:00:05Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Sergio0694",
                                            "createdAt":  "2020-11-19T22:30:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Enderlook",
                                            "createdAt":  "2020-11-27T15:16:43Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "Enderlook",
                                            "createdAt":  "2020-11-27T15:16:45Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AArnott",
                                            "createdAt":  "2020-12-02T18:54:31Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "stillwwater",
                                            "createdAt":  "2020-12-18T08:53:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "stillwwater",
                                            "createdAt":  "2020-12-18T08:53:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "saucecontrol",
                                            "createdAt":  "2021-01-07T00:45:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Rekkonnect",
                                            "createdAt":  "2021-01-07T12:35:23Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "Sergio0694",
                                            "createdAt":  "2021-01-30T11:33:53Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "Sergio0694",
                                            "createdAt":  "2021-01-30T11:33:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Ryken100",
                                            "createdAt":  "2021-02-03T03:11:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dlech",
                                            "createdAt":  "2021-03-01T04:55:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "erikpowa",
                                            "createdAt":  "2021-03-17T02:30:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Thealexbarney",
                                            "createdAt":  "2021-03-27T01:03:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "conorlawton",
                                            "createdAt":  "2021-07-12T19:24:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aromaa",
                                            "createdAt":  "2021-09-03T19:44:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "slotthhy",
                                            "createdAt":  "2021-09-30T16:35:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "akira0245",
                                            "createdAt":  "2021-09-30T16:44:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "StefDevs",
                                            "createdAt":  "2021-10-01T14:59:06Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "giladfrid009",
                                            "createdAt":  "2021-12-05T01:14:43Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "giladfrid009",
                                            "createdAt":  "2021-12-05T01:14:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "NN---",
                                            "createdAt":  "2021-12-05T10:03:36Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "xparadoxical",
                                            "createdAt":  "2022-01-17T04:38:07Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "xparadoxical",
                                            "createdAt":  "2022-01-17T04:38:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "TheLeftExit",
                                            "createdAt":  "2022-01-30T16:15:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "HurricanKai",
                                            "createdAt":  "2022-01-30T16:54:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SupinePandora43",
                                            "createdAt":  "2022-02-05T16:02:18Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "CodingMadness",
                                            "createdAt":  "2022-03-15T23:08:13Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "CodingMadness",
                                            "createdAt":  "2022-03-15T23:08:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "CodingMadness",
                                            "createdAt":  "2022-03-15T23:08:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "reijerh",
                                            "createdAt":  "2022-03-30T09:38:49Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "gerhard17",
                                            "createdAt":  "2022-04-06T10:17:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "cgytrus",
                                            "createdAt":  "2022-05-01T11:48:18Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2022-05-28T00:19:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mohumohu-corp",
                                            "createdAt":  "2022-08-06T21:50:20Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "js6pak",
                                            "createdAt":  "2022-09-02T22:44:37Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ppebb",
                                            "createdAt":  "2023-01-17T14:23:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MichalPetryka",
                                            "createdAt":  "2023-01-26T11:18:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "miyu",
                                            "createdAt":  "2023-03-04T00:26:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "keysmashes",
                                            "createdAt":  "2023-04-05T20:16:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "timcassell",
                                            "createdAt":  "2023-05-27T10:20:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MineCake147E",
                                            "createdAt":  "2023-08-15T06:13:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hamarb123",
                                            "createdAt":  "2023-10-01T23:07:14Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "jgcodes2020",
                                            "createdAt":  "2023-11-13T04:02:20Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "thautwarm",
                                            "createdAt":  "2023-11-23T12:55:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jwosty",
                                            "createdAt":  "2023-12-02T16:25:09Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "edward-a",
                                            "createdAt":  "2024-01-04T01:15:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-01-26T14:17:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kyoyama-kazusa",
                                            "createdAt":  "2024-02-01T03:31:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DjArt",
                                            "createdAt":  "2024-02-07T09:30:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Speedberg",
                                            "createdAt":  "2024-02-25T18:18:44Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ScrubN",
                                            "createdAt":  "2024-03-14T04:12:04Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Neme12",
                                            "createdAt":  "2024-03-16T17:54:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "RT0405",
                                            "createdAt":  "2024-03-21T21:21:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Limiana",
                                            "createdAt":  "2024-06-25T17:29:25Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "palapapa",
                                            "createdAt":  "2024-06-29T14:01:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "BjarkeCK",
                                            "createdAt":  "2024-11-11T13:55:12Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "BjarkeCK",
                                            "createdAt":  "2024-11-11T13:55:46Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "BjarkeCK",
                                            "createdAt":  "2024-11-11T13:55:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "JamByte",
                                            "createdAt":  "2025-03-17T14:59:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "smaillet",
                                            "createdAt":  "2025-03-24T17:03:37Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "smaillet",
                                            "createdAt":  "2025-03-24T17:04:36Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Aberro",
                                            "createdAt":  "2025-06-05T05:14:18Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "EzeAGB",
                                            "createdAt":  "2025-08-30T16:31:18Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "0x5bfa",
                                            "createdAt":  "2025-09-01T08:41:19Z"
                                        }
                                    ],
                          "totalCount":  88
                      },
        "updatedAt":  "2025-06-18T22:50:10Z",
        "body":  "In .NET and the latest C# language versions, it is currently allowed to have `MyStruct\u003cT\u003e*` and `T*` (.NET allows this more generally, but C# allows it only for \"unmanaged\" types).\r\n\r\nHowever, it is not possible to have `MyStruct\u003cT*\u003e`. This can be \"problematic\" for certain types of generic code, such as being able to have a `Span\u003cint*\u003e x` or `Lazy\u003cID3D12Device*\u003e` since you instead must instantiate it as `IntPtr` and cast at the relevant usage sites.\r\n\r\nGoing through ECMA-335, the rationale given in `II.9.4 Instantiating generic types` is:\r\n\u003e [Rationale: Unmanaged pointers are disallowed because as currently specified unmanaged pointers are not technically subclasses of System.Object. This restriction can be lifted, but currently the runtime enforces this restriction and this spec reflects that. ]\r\n\r\nI would propose that this restriction be lifted and pointers be allowed as generic type arguments. If that is possible, I would open a corresponding proposal on dotnet/csharplang suggesting that the language allow the same.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOrC62_w==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0NTQ2MzIwMw==",
                                           "createdAt":  "2019-10-23T14:11:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "john-h-k",
                                           "body":  "I can see `GetHashCode/ToString/Equals` simply using the `IntPtr` methods, but how would GetType work here? Would the actual pointer types be given that method?",
                                           "updatedAt":  "2019-10-23T14:11:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0NTQ2NDQwNQ==",
                                           "createdAt":  "2019-10-23T14:13:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEgQKCA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Unknown6656",
                                                                               "createdAt":  "2020-10-27T14:40:31Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "SupinePandora43",
                                                                               "createdAt":  "2022-02-05T16:03:13Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CodingMadness",
                                                                               "createdAt":  "2022-03-15T22:57:32Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "SunSerega",
                                                                               "createdAt":  "2023-10-25T08:41:02Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-01-26T14:17:32Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "EzeAGB",
                                                                               "createdAt":  "2025-08-30T16:31:31Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  6
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "I would imagine it works the same as `typeof(int*)`, which is it returns `[System.Int32*]`:\r\nhttps://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA0AXEBLANgHwAEAmARgFgAoQgZgAIS6BhOgbyrs4foBUBPAA4w6AcRgZ+QgJIA7DDWIAFCNjkwoACgCUdALwA+OhkEwIAMw2qMAKi0BuKgF8gA==\r\n\r\n*Edit:* Noting that this is the same codegen as is already done for an arbitrary `T`: https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA0AXEBLANgHwAEAmARgFgAoQgZgAIS6BhOgbyrs4foBUBPAA4w6AcRgZ+QgPIAzHgB4eAPgAUASjoBeJXQyCYEGSp5qA3FQC+QA=",
                                           "updatedAt":  "2019-10-23T14:15:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0NTQ3MDM3Ng==",
                                           "createdAt":  "2019-10-23T14:26:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "john-h-k",
                                           "body":  "I meant something more like this \r\nhttps://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA0AXEBLANgHwAEAmARgFgAoQgZgAIS6BhOgbyrs4foBUBPAA4w6AcRgZ+QgPIAzHgB4eAPgAUASjoBeJXQAmMGQEMArrgwqeagHRiJgmOoDcVAL5A===\r\nwhere in the IL it is calling `constrained. !!T System.Object.GetType()`, which obviously isn\u0027t an actual method on pointer types so I guess the JIT would need to recognise it and just insert the type handle there instead?\r\n\r\n",
                                           "updatedAt":  "2019-10-23T14:26:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0NTQ3ODY1Mw==",
                                           "createdAt":  "2019-10-23T14:44:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "That would likely require some work (either on the language side or the runtime side) to ensure things don\u0027t blow up 😄. I imagine there will be a few places like that if the relaxation was allowed.",
                                           "updatedAt":  "2019-10-23T14:44:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0NTUxMDY0Ng==",
                                           "createdAt":  "2019-10-23T15:50:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "The main restriction is that generic parameters can be boxed (one can do `box !T` in IL). So this would be about figuring out how the boxing happens for pointer types.\r\n\r\nMaking pointers derive from `System.Object` (or `System.ValueType`... or a new `System.Pointer`?) would be the first step. Then there would be questions about whether we want them to box like `Nullable\u003cT\u003e` (i.e. boxing a null pointer produces a null reference; unboxing a null reference produces a null pointer). How do we define equality of these boxed objects (just dispatch to `IntPtr.Equals` and ignore the type, or include the type of the pointer?).\r\n\r\nI expect there would be a pretty long bug tail after that.",
                                           "updatedAt":  "2019-10-23T15:50:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0NTUxNDg0MA==",
                                           "createdAt":  "2019-10-23T15:59:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEXIl1A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Gnbrkm41",
                                                                               "createdAt":  "2019-11-25T14:07:05Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "GazziFX",
                                                                               "createdAt":  "2023-10-01T06:34:07Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-01-26T14:17:51Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "sunkin351",
                                                                               "createdAt":  "2025-06-19T00:16:44Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "Having a special-cased `Pointer\u003cT\u003e` type might be feasible. It could internally just be `private T* _value` and then in generic instantiations would just be `Span\u003cPointer\u003cT\u003e\u003e`. Everything else is just syntax sugar/specialized handling after that (much like `Nullable\u003cT\u003e` like you called out).",
                                           "updatedAt":  "2019-10-23T15:59:36Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0NTUyODM4MA==",
                                           "createdAt":  "2019-10-23T16:31:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "4creators",
                                           "body":  "IMHO this issue belongs to https://github.com/dotnet/csharplang/ repo.\r\n\r\nOtherwise, I fully support the idea. It\u0027s a huge simplification for multiple coding patterns.",
                                           "updatedAt":  "2019-10-23T16:31:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0NTUyOTkxMg==",
                                           "createdAt":  "2019-10-23T16:35:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e IMHO this issue belongs to https://github.com/dotnet/csharplang/ repo.\r\n\r\nThe C# language can\u0027t reliably do this without the restriction first being lifted in the runtime. Now it\u0027s also reasonable that the runtime wouldn\u0027t do this without the language also agreeing to expose said support, but ensuring it is feasible for the runtime to handle is the first step (thus this issue and the note \"If that is possible, I would open a corresponding proposal on dotnet/csharplang suggesting that the language allow the same.\").",
                                           "updatedAt":  "2019-10-23T16:35:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0NTU0NTA3MQ==",
                                           "createdAt":  "2019-10-23T17:11:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "4creators",
                                           "body":  "\u003e  ensuring it is feasible for the runtime to handle is the first step\r\n\r\n\u003e thus this issue and the note \"If that is possible, I would open a corresponding proposal on dotnet/csharplang suggesting that the language allow the same.\"\r\n\r\nIMHO this is a C# language feature which requires runtime support. Reading between lines I understand you want to avoid pushback in csharplang repo due to the requirement of the runtime support. But this doesn\u0027t change the fact that the issue should go to dotnet/csharplang .",
                                           "updatedAt":  "2019-10-23T17:13:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HGIiH",
                                           "createdAt":  "2022-07-22T17:27:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODMa7nQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "xparadoxical",
                                                                               "createdAt":  "2023-11-13T04:07:29Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "alexrp",
                                           "body":  "Assuming that this work would enable function pointers as type arguments as well, then FWIW, I have a function hooking API in one of my projects that would benefit considerably from this. (Apologies in advance for the somewhat lengthy comment.)\r\n\r\nThe API shape currently looks like this (simplified):\r\n\r\n```csharp\r\npublic sealed unsafe class FunctionHook\r\n{\r\n    public void* Target { get; }\r\n    public void* Hook { get; }\r\n    public void* Trampoline { get; }\r\n    public object? State { get; }\r\n\r\n    public static FunctionHook Current { get; }\r\n\r\n    public static FunctionHook Create(void* target, void* hook, object? state = null);\r\n}\r\n```\r\n\r\nUsage looks like this:\r\n\r\n```csharp\r\n[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]\r\nstatic int SetThreadDescriptionHook(nint hThread, char* lpThreadDescription)\r\n{\r\n    Console.WriteLine(new string(lpThreadDescription) + FunctionHook.Current.State);\r\n\r\n    return 0;\r\n}\r\n\r\nvar kernel32 = NativeLibrary.Load(\"kernel32.dll\");\r\nvar setThreadDescription = (delegate* unmanaged[Stdcall]\u003cnint, char*, int\u003e)NativeLibrary.GetExport(\"SetThreadDescription\");\r\n\r\nusing (var hook = FunctionHook.Create(func, (delegate* unmanaged[Stdcall]\u003cnint, char*, int\u003e)\u0026SetThreadDescriptionHook, \"bar\"))\r\n    fixed (char* p = \"foo\")\r\n        _ = setThreadDescription(-1, p); // Prints \"foobar\".\r\n```\r\n\r\nI would much rather have an API shape like this:\r\n\r\n```csharp\r\npublic sealed unsafe class FunctionHook\u003cT\u003e\r\n    where T : delegate* /* or simply : unmanaged */\r\n{\r\n    public T Target { get; }\r\n    public T Hook { get; }\r\n    public T Trampoline { get; }\r\n    public object? State { get; }\r\n\r\n    public static FunctionHook Current { get; }\r\n}\r\n\r\npublic sealed unsafe class FunctionHook\r\n{\r\n    // (target is typed as void* since you almost always obtain it as that and forcing an extra cast doesn\u0027t actually add value.)\r\n    // (Throws if !typeof(T).IsFunctionPointer.)\r\n    public static FunctionHook Create\u003cT\u003e(void* target, T hook, object? state = null)\r\n        where T : delegate* /* or simply : unmanaged */;\r\n}\r\n```\r\n\r\nThis new API shape doesn\u0027t change the above example much - it just has to be changed to pass the function pointer type as a generic argument and remove the cast from `\u0026SetThreadDescriptionHook`. Importantly, though, the properties are now typed properly so they can be easily called without needing highly error-prone casts.\r\n\r\nAn even more significant benefit is the type information that is now available to the `FunctionHook` implementation (once function pointer introspection lands, anyway). I need entry/exit to/from the hook function to go through a \u0027hook gate\u0027 - that gate guards against some common pitfalls when hooking native APIs, and also takes care of making the `FunctionHook.Current` property work correctly. Unfortunately, this means doing some really nasty hacks that involve hijacking the return address currently on the stack and tail calling the hook function. (I have to do so because I have no idea what the prototype of the target/hook functions is, so I am not allowed to push another return address onto the stack.) This hack is very unfortunate because, while the basic calling convention is satisfied, other aspects of the ABI such as unwindability certainly are not.\r\n\r\nIf I could know from `typeof(T)` exactly what the calling convention, return type, and parameter types are, I would be able to drop this hack completely and instead generate correct code that forwards parameters and the return value when doing a normal call to the hook function, removing the need for the return address hijacking. Of course, I could take a `Type` parameter in my `Create` method -- likely what I\u0027ll end up doing in the short term -- but then I would still lose out on type safety for the properties, and it would be easy for the `typeof(delegate* ...)` argument to get out of sync with the actual function type without getting a compiler error.\r\n\r\nSo, being able to pass a function pointer type as a generic argument here would help me solve a bunch of API safety, usability, and implementation problems all at once.",
                                           "updatedAt":  "2022-07-22T17:27:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5jfOBO",
                                           "createdAt":  "2023-08-08T08:11:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEI35uQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Enderlook",
                                                                               "createdAt":  "2023-08-08T11:38:21Z"
                                                                           },
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "SupinePandora43",
                                                                               "createdAt":  "2023-08-08T12:51:55Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "rickbrew",
                                                                               "createdAt":  "2023-08-08T15:22:15Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "SupinePandora43",
                                                                               "createdAt":  "2023-08-24T09:33:17Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Marlax0",
                                                                               "createdAt":  "2023-10-16T20:23:20Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "xparadoxical",
                                                                               "createdAt":  "2023-11-13T04:07:41Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-01-26T14:18:10Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Neme12",
                                                                               "createdAt":  "2024-03-16T17:58:41Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ScrubN",
                                                                               "createdAt":  "2024-03-21T08:07:47Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "BoyBaykiller",
                                                                               "createdAt":  "2025-03-07T04:44:01Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  10
                                                         },
                                           "author":  "alexrp",
                                           "body":  "Another reason we need this: The shiny new inline arrays (#61135) are completely unusable with pointers and function pointers, presumably due to conversion to `Span\u003cT\u003e`, severely hampering their usefulness for interop bindings.",
                                           "updatedAt":  "2023-08-08T08:11:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5jh7J6",
                                           "createdAt":  "2023-08-08T15:27:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODFiEYw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alexrp",
                                                                               "createdAt":  "2023-09-01T21:23:17Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "rickbrew",
                                           "body":  "\u003e Another reason we need this: The shiny new inline arrays (#61135) are completely unusable with pointers and function pointers, presumably due to conversion to `Span\u003cT\u003e`, severely hampering their usefulness for interop bindings.\r\n\r\nAs an example of this, these can be useful for methods that take an array of COM interface pointers. Here are a few used in my project:\r\n\r\n`ID2D1Factory::CreateGeometryGroup` https://learn.microsoft.com/en-us/windows/win32/api/d2d1/nf-d2d1-id2d1factory-creategeometrygroup\r\n\r\n`ID2D1GeometryGroup::GetSourceGeometries` https://learn.microsoft.com/en-us/windows/win32/api/d2d1/nf-d2d1-id2d1geometrygroup-getsourcegeometries\r\n\r\n`IWICBitmapEncoder::SetColorContexts` https://learn.microsoft.com/en-us/windows/win32/api/wincodec/nf-wincodec-iwicbitmapencoder-setcolorcontexts\r\n",
                                           "updatedAt":  "2023-08-08T15:27:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5pNwH1",
                                           "createdAt":  "2023-10-16T20:23:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOELN8og==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "SupinePandora43",
                                                                               "createdAt":  "2023-10-17T08:55:43Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "xparadoxical",
                                                                               "createdAt":  "2023-10-18T19:44:58Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ScrubN",
                                                                               "createdAt":  "2024-03-14T04:22:01Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Neme12",
                                                                               "createdAt":  "2024-03-16T16:33:05Z"
                                                                           },
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "smaillet",
                                                                               "createdAt":  "2025-03-24T17:05:36Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  5
                                                         },
                                           "author":  "Marlax0",
                                           "body":  "\u003e Another reason we need this: The shiny new inline arrays (#61135) are completely unusable with pointers and function pointers, presumably due to conversion to `Span\u003cT\u003e`, severely hampering their usefulness for interop bindings.\r\n\r\nThis alone should be enough of a reason to seriously consider lifting this limitation.\r\n\r\nThere are always workarounds, but they _feel_ unnecessary when generics exist.\r\nI _feel_ like a dope casting `Thing*` to `nint` and back to `Thing*` all over the place, just to use generic helpers.\r\nIn an odd way it makes unsafe C# even more unsafe than usual.",
                                           "updatedAt":  "2023-10-16T20:23:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ru2JJ",
                                           "createdAt":  "2023-11-13T04:02:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jgcodes2020",
                                           "body":  "This issue\u0027s been up for a while now, what\u0027s happening?",
                                           "updatedAt":  "2023-11-13T04:02:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ru4l1",
                                           "createdAt":  "2023-11-13T04:18:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "It\u0027s in the \"Future\" milestone, that means it\u0027s not being actively worked on.",
                                           "updatedAt":  "2023-11-13T04:18:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VHAQ",
                                           "createdAt":  "2024-03-16T15:34:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "The-Futurist",
                                           "body":  "A similar argument suggest we should support `\u003cref T\u003e` as well as `\u003cT*\u003e` is this being actively pursued by the team?",
                                           "updatedAt":  "2024-03-16T15:34:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VLPW",
                                           "createdAt":  "2024-03-16T16:34:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "\u003e A similar argument suggest we should support `\u003cref T\u003e` as well as `\u003cT*\u003e` is this being actively pursued by the team?\r\n\r\nref is not even part of the type in C# (that\u0027s why you have to keep saying `ref` to keep the `ref`ness, and why you can\u0027t have `ref` of `ref`), so I\u0027m not really sure how this would work.",
                                           "updatedAt":  "2024-03-16T18:40:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VLdo",
                                           "createdAt":  "2024-03-16T16:38:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "john-h-k",
                                           "body":  "\u003e ref is not even part of the type in C# (that\u0027s why you have to keep saying `ref` to keep the `ref`ness), so I\u0027m not really sure how this would work.\r\n\r\nThat\u0027s not really true. It\u0027s a syntactic decision by the language that makes it feel like it is implicit, but `ref T` is still a fundamentally different type from `T`. `Type.IsByRef` wouldn\u0027t make any sense if `ref` wasn\u0027t part of the type",
                                           "updatedAt":  "2024-03-16T16:38:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VL7w",
                                           "createdAt":  "2024-03-16T16:45:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "\u003e `ref T` is still a fundamentally different type from `T`.\r\n\r\nIn the runtime yes, but in C# it\u0027s not a type.",
                                           "updatedAt":  "2024-03-16T18:36:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VMBu",
                                           "createdAt":  "2024-03-16T16:47:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "It\u0027s why there\u0027s no syntax (like there is for pointers) for dereferencing a `ref`. If you made generics support ref, it would have to work differently than elsewhere in the language, and you\u0027d have to introduce a syntax for dereferencing the `T` inside that generic method.",
                                           "updatedAt":  "2024-03-16T18:36:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VMKB",
                                           "createdAt":  "2024-03-16T16:49:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "You\u0027d also have to allow `ref` of `ref`. Let\u0027s say you have two generic parameters `T` and `U`. You want to set `T` to `ref U`. But what if `U` is a ref? You\u0027d then have a `ref` of `ref`. You\u0027d have to completely redo how `ref` works in C#.\r\n\r\nWith pointers, this isn\u0027t an issue - there is syntax for dereferencing, the \"`pointer`ness\" doesn\u0027t automatically constantly decay like `ref` does, and you *can* have pointers to pointers.",
                                           "updatedAt":  "2024-03-16T18:36:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VMWd",
                                           "createdAt":  "2024-03-16T16:52:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "john-h-k",
                                           "body":  "\u003e \u003e `ref T` is still a fundamentally different type from `T`.\r\n\u003e \r\n\u003e In the runtime yes, but in C# it\u0027s not a type.\r\n\r\nI agree it is not a type in the sense \"the C# spec does not mention it under the category `Types`\", but I don\u0027t see what meaningful distinction there is that makes it not a type. Yes it has implicit dereference, but that in no way makes it \"not a type\".\r\n\r\n\u003e It\u0027s why there\u0027s no syntax (like there is for pointers) for dereferencing a ref. If you made generics support ref, it would have to work differently than elsewhere in the language, and you\u0027d have to introduce a syntax for dereferencing the T inside that generic method.\r\n\r\nThe reason there is no syntax for dereferencing a ref is because that was the decision made. Classes are implicitly dereferenced, and there is no syntax for dereferencing them, so surely they are not types by this logic?\r\n\r\n\u003e If you made generics support ref, it would have to work differently than elsewhere in the language, and you\u0027d have to introduce a syntax for dereferencing the T inside that generic method.\r\n\r\nWhy would you need to do that? A generic method that takes a `T` _never_ needs to explicitly dereference that `T` - it can\u0027t because it doesn\u0027t know if it is a ref or not. If the generic method does need to dereference it, then it must guarantee `T` is a ref, and that can already achieved by parameterising on the underlying type and taking a `ref T` instead.",
                                           "updatedAt":  "2024-03-16T16:52:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VMgW",
                                           "createdAt":  "2024-03-16T16:55:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "\u003e \"the C# spec does not mention it under the category `Types`\"\r\n\r\nSo you agree it\u0027s not a type in C# :D you just said it.",
                                           "updatedAt":  "2024-03-16T18:36:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VMhi",
                                           "createdAt":  "2024-03-16T16:55:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "john-h-k",
                                           "body":  "\u003e You\u0027d also have to allow `ref` of `ref`. Let\u0027s say you have two generic parameters `T` and `U`. You want to set `T` to `ref U`. But what if `U` is a ref? You\u0027d then have a `ref` of `ref`. You\u0027d have to completely redo how `ref` works in C#.\r\n\u003e \r\n\u003e With pointers, this isn\u0027t an issue - there is syntax for dereferencing, the \"`pointer`ness\" doesn\u0027t automatically constantly decay like `ref` does, and you _can_ have pointers to pointers.\r\n\r\nI agree this becomes messy (syntactically), but there\u0027s two clear routes:\r\n* Support `ref ref Foo`\r\n* Support compiling nested refs in the context of generics, but don\u0027t bring nested `ref`s to the rest of the language, for simplicity",
                                           "updatedAt":  "2024-03-16T16:55:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VMqn",
                                           "createdAt":  "2024-03-16T16:58:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "john-h-k",
                                           "body":  "\u003e \u003e \"the C# spec does not mention it under the category `Types`\"\r\n\u003e \r\n\u003e So you agree it\u0027s not a type in C# :D you just said it.\r\n\r\nI agree that the C# 8 Draft specification says it is not a type. But A) that\u0027s pretty old, and B) I think it is irrelevant. There is nothing about `ref T` that makes it fundamentally \"not a type\"",
                                           "updatedAt":  "2024-03-16T16:58:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VMtp",
                                           "createdAt":  "2024-03-16T16:58:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "\u003e Why would you need to do that? A generic method that takes a `T` _never_ needs to explicitly dereference that `T` - it can\u0027t because it doesn\u0027t know if it is a ref or not.\r\n\r\nTo support the scenario in a truly generic way - have a type parameter `T` that can be ref but also might not be, you\u0027d have to have a syntax for dereferencing. If you don\u0027t, how do you set `T` to another `ref`? By saying `ref x`? But now you made `T` *require* being a `ref` and it\u0027s not an open generic anymore. And at this point, you don\u0027t need `ref` as type parameters at all - if it\u0027s always a `ref`, then you can just use `ref T` already today without the type parameter itself being ref.",
                                           "updatedAt":  "2024-03-16T18:35:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VM_z",
                                           "createdAt":  "2024-03-16T17:02:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "john-h-k",
                                           "body":  "\u003e \u003e Why would you need to do that? A generic method that takes a `T` _never_ needs to explicitly dereference that `T` - it can\u0027t because it doesn\u0027t know if it is a ref or not.\r\n\u003e \r\n\u003e To support the scenario in a truly generic way - have a type parameter `T` that can be ref but also might not be, you\u0027d have to have a syntax for dereferencing. If you don\u0027t, how do you set `T` to another `ref`? By saying `ref x`? But now you made `T` _require_ being a `ref` and it\u0027s not an open generic anymore. And at this point, you don\u0027t need `ref` as type parameters at all - if it\u0027s always a `ref`, then you can just use `ref T` already today without the type parameter itself being ref.\r\n\r\nIn a generic method such as this\r\n\r\n```cs\r\npublic static void F\u003cT\u003e(T a)\r\n{\r\n    T b = a;\r\n}\r\n```\r\n\r\nIt would just be decided that if `T` is a `ref`, then this is a ref assignment. This makes sense, because given an open `T`, the only possible operation to do here is an exact assignment which does not dereference.",
                                           "updatedAt":  "2024-03-16T17:02:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VM_8",
                                           "createdAt":  "2024-03-16T17:02:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "\u003e But A) that\u0027s pretty old, and B) I think it is irrelevant\r\n\r\nIt doesn\u0027t matter that it\u0027s old, the fact that it\u0027s not a type in C# hasn\u0027t changed at all. And of course it\u0027s relevant. You\u0027d have to make this work in C# if you want to use it in C#, and you can\u0027t make it work if you don\u0027t change how `ref` works and make `ref` a type.",
                                           "updatedAt":  "2024-03-16T18:35:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VNFu",
                                           "createdAt":  "2024-03-16T17:03:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "\u003e It would just be decided that if `T` is a `ref`, then this is a ref assignment\r\n\r\nGreat. But then how do you do \"regular\" assign (assign to what `T` points to)? You can\u0027t, without a syntax for dereferencing.\r\n\r\nAnd in any case, if this is how it should work, then you have to change the language to make `ref` part of the type. And that affects the whole type system.",
                                           "updatedAt":  "2024-03-16T18:35:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VNnr",
                                           "createdAt":  "2024-03-16T17:07:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "john-h-k",
                                           "body":  "\u003e \u003e It would just be decided that if `T` is a `ref`, then this is a ref assignment\r\n\u003e \r\n\u003e Great. But then how do you do \"regular\" assign (assign to what `T` points to)? You can\u0027t, without a syntax for dereferencing.\r\n\r\nOf course you can\u0027t - because that is impossible in an open generic? To do a dereferencing-assign like that, you need to restrict `T` to be a reference type, which as we both said, is possible by just making `T` a generic and taking `ref T` instead.\r\n\r\nIf you want an open-generic function over `T` that can take any type (`int` and `ref int` for example), you CANNOT dereference. It doesn\u0027t make sense.\r\n\r\nIf you want a function over `T` that can dereference `T`, then you must take a `ref T` instead, and then the normal syntax works.\r\n\r\nYou are trying to do operations specific to ref-types within the context of a generic that accepts both ref and non-ref types. That will not work",
                                           "updatedAt":  "2024-03-16T17:07:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VNyW",
                                           "createdAt":  "2024-03-16T17:08:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "john-h-k",
                                           "body":  "\u003e \u003e But A) that\u0027s pretty old, and B) I think it is irrelevant\r\n\u003e \r\n\u003e It doesn\u0027t matter that it\u0027s old, the fact that it\u0027s not a type in C# hasn\u0027t changed at all. And of course it\u0027s relevant. You\u0027d have to make this work in C# if you want to use it in C#, and you can\u0027t make it work if you don\u0027t change how `ref` works and make `ref` a type.\r\n\r\nBut by this definition (\"`ref T` is not a type because it is not in the spec\"), making `ref T` a type would simply entail putting it in the spec, which is not too hard. If there is something fundamentally difficult about making `ref T` a type (which I believe it effectively already is, albeit restricted and with some odd syntactical constructs), then that would be a different story.",
                                           "updatedAt":  "2024-03-16T17:08:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VOfi",
                                           "createdAt":  "2024-03-16T17:19:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "\u003e Of course you can\u0027t - because that is impossible in an open generic?\r\n\r\nOK you\u0027re right. But you still couldn\u0027t do this without completely changing the language. It\u0027s not just a matter of \"putting it in the spec\". Today, if a method returns `ref X`, you can just do `M() = x`. If you say that a method returning by `ref` like that is actually returning a type called `ref X`, then assigning to that would be a ref assignment, which it\u0027s not today.",
                                           "updatedAt":  "2024-03-16T18:35:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VOom",
                                           "createdAt":  "2024-03-16T17:21:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "\u003e Classes are implicitly dereferenced, and there is no syntax for dereferencing them, so surely they are not types by this logic?\r\n\r\nThey are types by the language, unlike `ref`. And classes work with generics without an issue because they\u0027re *not* implicitly dereferenced the same way that `ref` is. If you have a class `C` and variables `C x;` and `C y;` assign `x = y;`, you are assigning the reference itself.  You are *not* assigning to what `C` points to. There\u0027s only automatic dereference by the `.` operator, not during assignment.",
                                           "updatedAt":  "2024-03-16T18:35:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VOu_",
                                           "createdAt":  "2024-03-16T17:23:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "john-h-k",
                                           "body":  "\u003e \u003e Of course you can\u0027t - because that is impossible in an open generic?\r\n\u003e \r\n\u003e OK you\u0027re right. But you still couldn\u0027t do this without completely changing the language. It\u0027s not just a matter of \"putting it in the spec\". Today, if a method returns `ref X`, you can just do `M() = x`. If you say that a method returning by `ref` like that is actually returning a type called `ref X`, then assigning to that would be a ref assignment, which it\u0027s not today.\r\n\r\nYou are equating my view that \"ref is a type\" with \"ref shouldn\u0027t automatically dereference\". That\u0027s not what I am saying.\r\n`M(x) = x` works fine with ref as a type. It returns the type `ref X`, and a `ref X` on the left hand side of an assignment is automatically dereferenced, just as it always has been.\r\n\r\nThe only change I am suggesting is how refs interact in generic contexts. Nothing else",
                                           "updatedAt":  "2024-03-16T17:23:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VPLO",
                                           "createdAt":  "2024-03-16T17:29:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "john-h-k",
                                           "body":  "\u003e \u003e Classes are implicitly dereferenced, and there is no syntax for dereferencing them, so surely they are not types by this logic?\r\n\u003e \r\n\u003e They are types by the language, unlike `ref`. And classes work with generics without an issue because they\u0027re _not_ implicitly dereferenced the same way that `ref` is. If you have a class `C` and variables `C x;` and `C y;` assign `x = y;`, you are assigning the reference itself. You are _not_ assigning to what `C` points to. There\u0027s only automatic dereference by the `.` operator.\r\n\r\nAgain, \"types by the language\" just seems to mean \"in the spec\". Refs being added as a type in the spec wouldn\u0027t change how the language worked, but then they would be considered types. \r\nThe argument about ref not being types needs to have a fundamental difference between `ref T` and `T`/`T?`/`T*` etc. If it\u0027s just a technicality (being in the spec), then it doesn\u0027t matter.\r\n\r\n\u003e And classes work with generics without an issue because they\u0027re not implicitly dereferenced the same way that ref is. If you have a class C and variables C x; and C y; assign x = y;, you are assigning the reference itself. You are not assigning to what C points to. There\u0027s only automatic dereference by the . operator.\r\n\r\nI do see the difference around assignment there and that is a big difference. But that doesn\u0027t feel like it is the \"reason\" they work with generics. They work with generics because generics were written to support classes. Generics could be written to support refs too (with the rules I mentioned earlier). The only caveat is it leave some unintuitive parts of the syntax (the fact `{Some Type} a = b` is legal if and only if `{Some Type}` is not a concrete ref-type)",
                                           "updatedAt":  "2024-03-16T17:29:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VQA_",
                                           "createdAt":  "2024-03-16T17:40:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "I don\u0027t think you could make this work without a huge breaking change in the language. If you have `ref int x;` and assign `x = 5;` and say that `x` is of type `ref int` and a `ref` type of the left-hand side of an assignment is automatically dereferenced, then ok, but what if you do `x = ref y;`? You said that `x` is automatically dereferenced, so now you can\u0027t ref-assign it (you\u0027d have to do `ref x = ref y`). If you say `x` is automatically dereferenced when the right-hand side isn\u0027t of a `ref` type, then what if the right-hand side is a function call and that function returns a `ref X`? That still isn\u0027t a ref assignment today. You\u0027d have to make the `ref` keyword somehow special and not just simply part of the type (which is what it is today - not part of the type). And that fact is not just \"some technicality\". It affects how the language works.\r\n\r\nAnd even if you could make this somehow work by adding special rules on top of special rules, the most unintuivite part about it would be that if you have a generic method, call it with type `ref X` and then decide to make the function not generic and substitute `T` for `ref X`, you\u0027d have completely different semantics.",
                                           "updatedAt":  "2024-03-16T18:35:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VQXK",
                                           "createdAt":  "2024-03-16T17:45:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "john-h-k",
                                           "body":  "\u003e I don\u0027t think you could make this work without a huge breaking change in the language. If you have `ref int x;` and assign `x = 5;` and say that `x` is of type `ref int` and a `ref` type of the left-hand side of an assignment is automatically dereferenced, then ok, but what if you do `x = ref y;`? You said that `x` is automatically dereferenced, so now you can\u0027t ref-assign it (you\u0027d have to do `ref x = ref y`). If you say `x` is automatically dereferenced when the right-hand side isn\u0027t of a `ref` type, then what if the right-hand side is a function call and that function returns a `ref X`? That still isn\u0027t a ref assignment today. You\u0027d have to make the `ref` keyword somehow special and not just simply part of the type (which is what it is today).\r\n\r\nI don\u0027t understand why considering `ref T` a type makes you think the rules about how it works have to change. Just as it used to, `x = ref y` is a ref assignment because that is literally meaning of `= ref`. It is called the `Ref Assignment Operator`. So to clarify the rules:\r\n* A ref on the left-hand-side of an assignment will dereference\r\n* A ref on the left-hand-side of a ref assignment will not dereference\r\n\r\nThese are the EXACT same rules as now. No changes\r\n\r\n\u003e And even if you could make this somehow work by adding special rules on top of special rules, the most unintuivite part about it would be that if you have a generic method, call it with type `ref X` and then decide to make the function not generic and substitute `T` for `ref X`, you\u0027d have completely different semantics.\r\n\r\nI agree, this would be intuitive. But I don\u0027t see any other ways to achieve it",
                                           "updatedAt":  "2024-03-16T17:45:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VQXQ",
                                           "createdAt":  "2024-03-16T17:45:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "\u003e you\u0027d have to do `ref x = ref y`\r\n\r\nThough I do wish this was how it worked so that the rules could be more consistent with `ref` being a type, and you\u0027d have a clear difference between regular assignment and a ref assignment, and not just only depending on the right-hand side. But that\u0027s not where we are.",
                                           "updatedAt":  "2024-03-16T18:35:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VQdL",
                                           "createdAt":  "2024-03-16T17:47:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "\u003e Just as it used to, `x = ref y` is a ref assignment because that is literally meaning of `= ref`.\r\n\r\nBut then... you agree that what you have there is the `= ref` operator and `ref` isn\u0027t part of `y` and the type of the right-hand side is *NOT* `ref Y`. So `ref` is not part of the type, and we\u0027re back to square one. You can\u0027t \"just make it part of the type\" without changing the language.",
                                           "updatedAt":  "2024-03-16T18:34:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VRih",
                                           "createdAt":  "2024-03-16T17:58:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "john-h-k",
                                           "body":  "\u003e \u003e Just as it used to, `x = ref y` is a ref assignment because that is literally meaning of `= ref`.\r\n\u003e \r\n\u003e But then... you agree that what you have there is the `= ref` operator and `ref` isn\u0027t part of `y` and the type of the right-hand side is _NOT_ `ref Y`. So `ref` is not part of the type, and we\u0027re back to square one. You can\u0027t \"just make it part of the type\" without changing the language.\r\n\r\n\r\n\u003e `ref` isn\u0027t part of `y`\r\n\r\n`ref` is not part of `y` in the sense that the `= ref` operator\u0027s \"ref\" token is not part of it. But `ref` _must_ be a part of `y`, because for `x = ref y` to be legal `y` must have been declared as `ref T`!\r\n\r\nWe don\u0027t write integer assignments like this\r\n```cs\r\nx = int 10;\r\n```\r\n_but 10 still has type `int`_. Just as `y` has type `ref T` in `x = ref y`.\r\n\r\n\r\n\u003e the type of the right-hand side is NOT ref Y.\r\nThis does not follow from \"`= ref` is an operator\". \r\n\r\n1. `x` is a local variable of type `ref int`\r\n2. `y` is a local variable of type `ref int`\r\n3. `x = y` is an assignment operation\r\n4. Ref-type variables on the LHS of an assignment dereference\r\n5. Ref-type variables on the RHS of an assignment dereference\r\n6. The assignment works as expected\r\n\r\nAnd for `= ref`:\r\n\r\n1. `x` is a local variable of type `ref int`\r\n2. `y` is a local variable of type `ref int`\r\n3. `x = ref y` is a ref assignment operation\r\n4. Ref-type variables on the LHS of a ref assignment do not dereference\r\n5. Ref-type variables on the RHS of a ref assignment do not dereference\r\n6. The assignment works as expected\r\n\r\n\u003e You can\u0027t \"just make it part of the type\" without changing the language.\r\n\r\nI am suggesting it is already effectively a type and should be treated as such. I don\u0027t know what definition of type you have, but I still haven\u0027t seen a reason for why `ref T` is not a type, and if so, what changes would \"make it a type\". If the answer is \"well it isn\u0027t on the spec\", then you can just add it to the spec as a type and that _is_ making it part of a type without changing the language",
                                           "updatedAt":  "2024-03-16T18:00:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VSPA",
                                           "createdAt":  "2024-03-16T18:04:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "john-h-k",
                                           "body":  "\u003e \u003e you\u0027d have to do `ref x = ref y`\r\n\u003e \r\n\u003e Though I do wish this was how it worked so that the rules could be more consistent with `ref` being a type, and you\u0027d have a clear difference between regular assignment and a ref assignment, and not just only depending on the right-hand side. But that\u0027s not where we are.\r\n\r\nBut this would be `ref` being an operator almost, rather than a type. `x = ref y` is unambiguous because `= ref` MUST mean ref assignment. You know purely from seeing `= ref` that `x` is a ref variable",
                                           "updatedAt":  "2024-03-16T18:04:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VS9i",
                                           "createdAt":  "2024-03-16T18:10:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "\u003e But `ref` _must_ be a part of `y`, because for `x = ref y` to be legal `y` must have been declared as `ref T`!\r\n\r\nThat\u0027s not true. It could be a normal variable. And you are assigning a reference to that variable.\r\n\r\n\u003e But this would be `ref` being an operator almost, rather than a type\r\n\r\nThat\u0027s what it currently is.",
                                           "updatedAt":  "2024-03-16T18:34:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VTeU",
                                           "createdAt":  "2024-03-16T18:13:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "\u003e \u003e \u003e But `ref` _must_ be a part of `y`, because for `x = ref y` to be legal `y` must have been declared as `ref T`!\r\n\u003e \u003e \r\n\u003e \u003e \r\n\u003e \u003e That\u0027s not true. It could be a normal variable. And you are assigning a reference to that variable.\r\n\u003e \r\n\u003e No, that is illegal. [Sharplab](https://sharplab.io/#v2:CYLg1APgAgTAjAWAFBQMwAJboMLoN7LpGYZQAs6AsgBQCU+hxTAlgHYAu6rA9gE4C2AQwA2ANUG9mggEbCApugC86OAAYA3IyZE2nAO7NhwgCqCA1nIBKcgGZL0AVk1JtxLdt630u9AE97nnYGRqYW1jbOrkQ8AiLikjLyAV6+kcQAvsjpQA)\r\n\r\nThat\u0027s an error because the left-hand side isn\u0027t a ref variable. The right-hand side *can* be a regular variable.",
                                           "updatedAt":  "2024-03-16T18:34:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VTiP",
                                           "createdAt":  "2024-03-16T18:14:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "john-h-k",
                                           "body":  "\u003e \u003e But `ref` _must_ be a part of `y`, because for `x = ref y` to be legal `y` must have been declared as `ref T`!\r\n\u003e \r\n\u003e That\u0027s not true. It could be a normal variable. And you are assigning a reference to that variable.\r\n\r\nAh yes I realise what you mean. But I stand by the rest of my points",
                                           "updatedAt":  "2024-03-16T18:14:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VTsf",
                                           "createdAt":  "2024-03-16T18:15:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "john-h-k",
                                           "body":  "\u003e \u003e \u003e \u003e But `ref` _must_ be a part of `y`, because for `x = ref y` to be legal `y` must have been declared as `ref T`!\r\n\u003e \u003e \u003e \r\n\u003e \u003e \u003e \r\n\u003e \u003e \u003e That\u0027s not true. It could be a normal variable. And you are assigning a reference to that variable.\r\n\u003e \u003e \r\n\u003e \u003e \r\n\u003e \u003e No, that is illegal. [Sharplab](https://sharplab.io/#v2:CYLg1APgAgTAjAWAFBQMwAJboMLoN7LpGYZQAs6AsgBQCU+hxTAlgHYAu6rA9gE4C2AQwA2ANUG9mggEbCApugC86OAAYA3IyZE2nAO7NhwgCqCA1nIBKcgGZL0AVk1JtxLdt630u9AE97nnYGRqYW1jbOrkQ8AiLikjLyAV6+kcQAvsjpQA)\r\n\u003e \r\n\u003e That\u0027s an error because the left-hand side isn\u0027t a ref variable. The right-hand side _can_ be a regular variable.\r\n\r\nYeah, realised what you meant just after. I read \"And you are assigning a reference to that variable\" to mean \"assigning a reference [RHS] to that variable [normal variable on LHS]\" instead of \"assigning a reference [of LHS] to that variable [normal variable on RHS]\", my bad",
                                           "updatedAt":  "2024-03-16T18:16:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VUag",
                                           "createdAt":  "2024-03-16T18:22:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "\u003e But `ref` _must_ be a part of `y`, because for `x = ref y` to be legal `y` must have been declared as `ref T`!\r\n\r\nIt\u0027s irrelevant whether `y` was declared as `ref` or not for `x = ref y` to work. So if `ref Y` is a type, it\u0027s irrelevant whether `y` is `ref Y` or `Y`. So it\u0027s not a meaningful part of the type system. You can call the type `ref Y` instead of `Y` if you wish, but it\u0027s not actually a meaningful type and different from `Y` itself. At this point you\u0027re just creating a synonym.",
                                           "updatedAt":  "2024-03-16T18:34:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VVKs",
                                           "createdAt":  "2024-03-16T18:30:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "john-h-k",
                                           "body":  "\u003e It\u0027s irrelevant whether y was declared as ref or not for x = ref y to work\r\n\r\nYep\r\n\r\n\u003e So if ref Y is a type, it\u0027s irrelevant whether y is ref Y or Y\r\n\r\nI do not in anyway see how this follows. Here is an argument using the same reasoning as this one\r\n\r\nInstead of the two types being `ref Y x` and `Y y`/`ref Y y`, use `double x` and `float y`/`double y`. Of course, `x = y` is valid in both scenarios, just as `x = ref y` was valid in both prior scenarios. \r\n\r\nIt\u0027s irrelevant whether `y` was declared as double or float for `x = y` to work. So if float is a type, it\u0027s irrelevant whether y is float or double. So it\u0027s not a meaningful part of the type system. You can call the type float instead of double if you wish, but it\u0027s not actually a different type from double itself.\r\n\r\nIt\u0027s the exact same argument. Both are the compiler allowing multiple types on the RHS. Suggesting that something is not a \"meaningful part of the type system\" because there are SOME scenarios where it behaves as something else just doesn\u0027t make sense. If in EVERY scenario, `ref Y` and `Y` were indistinguishable, then yes they would be the same type. But that isn\u0027t true, because `ref Y` can be used in entirely different ways to `Y` ",
                                           "updatedAt":  "2024-03-16T18:30:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VVQJ",
                                           "createdAt":  "2024-03-16T18:31:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOELN-CA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Neme12",
                                                                               "createdAt":  "2024-03-16T18:33:38Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Joe4evr",
                                                                               "createdAt":  "2024-03-16T18:40:50Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "smaillet",
                                                                               "createdAt":  "2025-03-24T17:08:12Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "alexrp",
                                           "body":  "\u003e A similar argument suggest we should support `\u003cref T\u003e` as well as `\u003cT*\u003e` is this being actively pursued by the team?\r\n\r\nIt would be a completely separate feature from what this issue is proposing. Pointers in generics are relatively \u0027easy\u0027 to implement, while `ref`s in generics would have far-reaching effects on all parts of the runtime.\r\n\r\nCan we please take the debate about `ref`s in generics to a separate issue/discussion? This is getting a little bit noisy and off topic.",
                                           "updatedAt":  "2024-03-16T18:31:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53VVlT",
                                           "createdAt":  "2024-03-16T18:36:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "You\u0027re right, I\u0027m sorry. I\u0027ll hide my comments.",
                                           "updatedAt":  "2024-03-16T18:36:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6sLrb_",
                                           "createdAt":  "2025-05-18T03:32:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEUmGew==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "js6pak",
                                                                               "createdAt":  "2025-05-20T13:39:38Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "RamType0",
                                                                               "createdAt":  "2025-05-26T11:55:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MaksimAnishko",
                                                                               "createdAt":  "2025-05-31T15:04:03Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "ds5678",
                                           "body":  "\u003e The main restriction is that generic parameters can be boxed (one can do `box !T` in IL). So this would be about figuring out how the boxing happens for pointer types.\n\u003e \n\u003e Making pointers derive from `System.Object` (or `System.ValueType`... or a new `System.Pointer`?) would be the first step. Then there would be questions about whether we want them to box like `Nullable\u003cT\u003e` (i.e. boxing a null pointer produces a null reference; unboxing a null reference produces a null pointer). How do we define equality of these boxed objects (just dispatch to `IntPtr.Equals` and ignore the type, or include the type of the pointer?).\n\u003e \n\u003e I expect there would be a pretty long bug tail after that.\n\nSince we now have `allows ref struct`, could we just extend that to include pointer types if the boxing work is too arduous?",
                                           "updatedAt":  "2025-05-18T03:32:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6x7Muq",
                                           "createdAt":  "2025-06-18T17:11:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ds5678",
                                           "body":  "If a community member (such as myself) wanted to implement runtime support for pointers as generic type arguments, would that be welcome?",
                                           "updatedAt":  "2025-06-18T17:11:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6x7m0o",
                                           "createdAt":  "2025-06-18T17:48:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "\u003e If a community member (such as myself) wanted to implement runtime support for pointers as generic type arguments, would that be welcome?\n\nI assume it\u0027d first need an approved design spec for the runtime for it cc @jkotas \n\nThere are also some unanswered questions for this like for example whether it\u0027d still forbid boxing of pointers and then do `allows` at language level or if pointers would be made boxable which IIRC even the ECMA says can be changed in the future.",
                                           "updatedAt":  "2025-06-18T17:51:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6x78zC",
                                           "createdAt":  "2025-06-18T18:19:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "It would have to be a pair of C# and runtime specs. We are not interested in building runtime support without matching C# support.\n\nIt is very non-trivial to do this thoroughly. I do not think it is a suitable task for a community member.\n\n\u003e There are also some unanswered questions for this like for example whether it\u0027d still forbid boxing of pointers\n\nRight. A good question to ask is whether and how `List\u003cint*\u003e` would work.",
                                           "updatedAt":  "2025-06-18T18:19:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6x8lHX",
                                           "createdAt":  "2025-06-18T19:23:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ds5678",
                                           "body":  "\u003e It would have to be a pair of C# and runtime specs. We are not interested in building runtime support without matching C# support.\n\nUnderstood\n\n\u003e It is very non-trivial to do this thoroughly. I do not think it is a suitable task for a community member.\n\nI\u0027m no stranger to working on big projects. I know that it\u0027s a significant undertaking, which frankly is why I\u0027m worried nothing will happen without outside help. If it were trivial, it would have already been done sometime in the past 6 years, or earlier.\n\n\u003e \u003e There are also some unanswered questions for this like for example whether it\u0027d still forbid boxing of pointers\n\u003e \n\u003e Right. A good question to ask is whether and how `List\u003cint*\u003e` would work.\n\nYes, `List\u003cint*\u003e` (and therefore boxing) should be supported.\n\n* Null pointers should box to `null`, similar to `Nullable\u003cT\u003e`.\n* Pointers should inherit from a new type `System.Pointer`.\n  * This enables code like `if (obj is Pointer ptr)`.\n  * Similar to other important types, it is illegal for normal classes to inherit from this type.\n  * This type has explicit conversions to `IntPtr` and `void*`.\n* Boxed pointers equate both on value and type.\n* It is invalid to cast a boxed pointer to a different pointer type.\n* Since boxing is part of the implementation, pointers do not require an anti-constraint like `allows ref struct`.",
                                           "updatedAt":  "2025-06-18T19:24:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6x-fZG",
                                           "createdAt":  "2025-06-18T22:50:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jaredpar",
                                           "body":  "\u003e Yes, List\u003cint*\u003e (and therefore boxing) should be supported.\n\nThis has deeper implications. Consider that the set of interfaces on `T[]` differ based on whether `T` is a pointer or not. When it\u0027s not a pointer it implements generic interfaces like `IEnumerable\u003cT\u003e`. This feature would likely need to make it always implement the generic features to be fully plumbed through `List\u003cT\u003e`. \n\n\u003e Since boxing is part of the implementation, pointers do not require an anti-constraint like allows ref struct.\n\nThis would imply that pointers in non-generic context also allow for boxing. Essentially items like this will become legal:\n\n```cs\nint* p = null;\nobject o = p;\n```\n\nThis has decent impact into C# language semantics. At the least it would likely result in overload resolution breaking change behavior in some cases. \n\nI\u0027m pretty skeptical of this being done without an anti-constraint being needed. \n\n\u003e I\u0027m no stranger to working on big projects\n\nIt\u0027s not just one\u0027s willingness to commit to doing work. This also requires the compiler and language design team to commit substantial resources to such an effort. For a feature that will have this amount of impact to semantics, it generally isn\u0027t going to happen unless there is a substantial win from doing the work. Personally, I\u0027m not convinced that win is present at this time. Others opinions may differ though. \n\n",
                                           "updatedAt":  "2025-06-18T22:50:10Z"
                                       }
                                   ],
                         "totalCount":  55
                     },
        "title":  "Consider allow pointers as generic type arguments",
        "labels":  [
                       "enhancement",
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/43486",
        "createdAt":  "2020-01-05T07:05:33Z",
        "number":  43486,
        "author":  "Horusiath",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODAV0Zg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Nirmal4G",
                                            "createdAt":  "2020-06-09T20:37:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sidristij",
                                            "createdAt":  "2020-10-30T10:47:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Sergio0694",
                                            "createdAt":  "2021-01-29T17:32:17Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jcotton42",
                                            "createdAt":  "2021-03-22T14:09:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "xparadoxical",
                                            "createdAt":  "2021-03-22T14:21:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Alex-ABPerson",
                                            "createdAt":  "2021-03-22T15:35:42Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "xoofx",
                                            "createdAt":  "2021-05-07T13:00:17Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hypeartist",
                                            "createdAt":  "2021-05-07T13:49:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "alaatm",
                                            "createdAt":  "2021-05-24T03:24:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "matthew-a-thomas",
                                            "createdAt":  "2021-05-27T21:00:21Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "matthew-a-thomas",
                                            "createdAt":  "2021-05-27T21:00:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "moshg",
                                            "createdAt":  "2021-08-07T15:06:45Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Jure-BB",
                                            "createdAt":  "2021-08-13T08:20:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Timovzl",
                                            "createdAt":  "2021-09-16T11:42:16Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mostlyfun",
                                            "createdAt":  "2021-12-09T08:16:18Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "mostlyfun",
                                            "createdAt":  "2021-12-10T16:26:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ProphetLamb",
                                            "createdAt":  "2022-07-05T17:43:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "timcassell",
                                            "createdAt":  "2022-09-14T20:17:18Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kkwpsv",
                                            "createdAt":  "2023-01-30T05:06:50Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DanteMarshal",
                                            "createdAt":  "2023-03-21T08:18:49Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "erikpowa",
                                            "createdAt":  "2023-05-24T23:26:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "gerhard17",
                                            "createdAt":  "2023-06-16T10:07:45Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Sardelka9515",
                                            "createdAt":  "2024-02-12T05:31:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kevingosse",
                                            "createdAt":  "2024-03-07T17:42:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "NatElkins",
                                            "createdAt":  "2024-05-31T18:03:42Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "MineCake147E",
                                            "createdAt":  "2024-06-03T04:12:25Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "fitdev",
                                            "createdAt":  "2024-07-10T11:47:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "julealgon",
                                            "createdAt":  "2024-07-10T13:33:36Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "BrunoJuchli",
                                            "createdAt":  "2024-07-16T14:53:35Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "BrunoJuchli",
                                            "createdAt":  "2024-07-16T14:53:37Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ElectroJr",
                                            "createdAt":  "2025-01-14T06:36:58Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "domn1995",
                                            "createdAt":  "2025-03-21T01:36:51Z"
                                        }
                                    ],
                          "totalCount":  32
                      },
        "updatedAt":  "2024-11-22T08:42:54Z",
        "body":  "Right now .NET doesn\u0027t allow to combine generics with structures and explicit layout, eg.:\r\n\r\n```csharp\r\n[StructLayout(LayoutKind.Explicit)]\r\nstruct Result\u003cTSuccess, TError\u003e\r\n{\r\n    [FieldOffset(0)] private byte tag;\r\n    [FieldOffset(1)] private TSuccess success;\r\n    [FieldOffset(1)] private TError error;\r\n}\r\n// System.TypeLoadException: Could not load type \u0027Result`2\u0027 from assembly \u0027\u0027 \r\n// because generic types cannot have explicit layout.\r\n```\r\n\r\nHowever pattern like this - a.k.a tagged union - is quite popular and often used in other languages, including Rust, OCaml, Haskell or even C.\r\n\r\nWhile this can be done in other ways, but each of them fails in its unique ways:\r\n\r\n1. Using classes with inheritance, which can produce a lot of garbage and is a no go in many performance-critical paths.\r\n2. Using sequential layout, which becomes infeasible pretty much after we got several fields, as we are bloating the stack with data that must be mem-copied between function calls but it\u0027s mostly unused.\r\n\r\nAnticipating the question *how is runtime supposed to determine size of such generic struct*, it\u0027s the same way as in the languages mentioned above: a dynamically sized, but the size is known to be a maximum possible size required to store the data.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOlJs3JQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3MTU5NjYxOQ==",
                                           "createdAt":  "2020-01-07T13:56:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "eiriktsarpalis",
                                           "body":  "I believe that the restriction stems from the fact that the CLR does not permit overlap of struct and reference type fields, regardless of generics. In your example, this would be admissible if, for example, `TSuccess` were specialized to a reference type and `TError` was a struct.",
                                           "updatedAt":  "2020-01-07T13:56:20Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3MTYwMTg3MA==",
                                           "createdAt":  "2020-01-07T14:10:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "eiriktsarpalis",
                                           "body":  "\u003e but the size is known to be a maximum possible size required to store the data.\r\n\r\nI may have misunderstood what you\u0027re saying here, but the size of a generic struct is unbounded at runtime.",
                                           "updatedAt":  "2020-01-07T14:10:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3MTc1MTk5NA==",
                                           "createdAt":  "2020-01-07T20:13:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Horusiath",
                                           "body":  "\u003e I believe that the restriction stems from the fact that the CLR does not permit overlap of struct and reference type fields\r\n\r\nI can imagine that this reason might caused by difficulties from GC perspective (which at least in theory could be solved by conservative GC approach), but it would be great to hear about other challenges, if there are any.\r\n\r\n\u003e I may have misunderstood what you\u0027re saying here, but the size of a generic struct is unbounded at runtime.\r\n\r\nI think you\u0027ve meant at compile time. Unless I misunderstood something, at some point it must be known to the runtime (since we need to allocate a frame on stack of certain size for any struct).",
                                           "updatedAt":  "2020-01-07T20:13:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2OTk0NDgwMg==",
                                           "createdAt":  "2021-01-29T17:34:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODkQpow==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "gerhard17",
                                                                               "createdAt":  "2023-06-16T10:08:28Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Sardelka9515",
                                                                               "createdAt":  "2024-02-12T05:33:12Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kevingosse",
                                                                               "createdAt":  "2024-03-07T17:41:53Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MineCake147E",
                                                                               "createdAt":  "2024-06-03T04:13:25Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "Sergio0694",
                                           "body":  "Would it be possible to lift this restriction when all types involved are blittable at least?\r\nThis would be pretty handy when porting code from C++ and dealing with raw bindings types.\r\nIn this scenario there shouldn\u0027t be as much work necessary on the runtime side to make this possible since the GC wouldn\u0027t be involved at all, right? I can open a separate issue for that in case this one was specifically about broad support for this 🙂",
                                           "updatedAt":  "2021-01-29T17:34:55Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2OTk0Nzg1OA==",
                                           "createdAt":  "2021-01-29T17:40:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "This might be similar to the change I made to support marshalling blittable generics: https://github.com/dotnet/runtime/pull/103\r\n\r\nThe runtime side changes ended up being small (~75 lines, which includes comments and newlines), while I added some significant test coverage (~10k lines).\r\n@jkotas and @AaronRobinsonMSFT were the primary contacts for that and would likely know if they would be any issues with the VM or marshaling side of things.",
                                           "updatedAt":  "2021-01-29T17:40:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2OTk5MTE3NQ==",
                                           "createdAt":  "2021-01-29T19:05:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "john-h-k",
                                           "body":  "I have got this working locally with a ~4 line change and it so far seems to be working with everything (throws when the reified layout is invalid). The check was in `MethodTableBuilder::GatherGenericsInfo`, but it was redundant as it seems the entire type layout is checked later in `MethodTableBuilder::BuildMethodTableThrowing`, so I simply removed the check",
                                           "updatedAt":  "2021-01-29T19:05:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyNDczMDA4Mg==",
                                           "createdAt":  "2021-04-22T10:38:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "RomanZhu",
                                           "body":  "Any update on that?\r\nIt\u0027s blocking my requirement to have the same guaranteed memory layout on all machines right now ",
                                           "updatedAt":  "2021-04-22T10:38:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5X7dRs",
                                           "createdAt":  "2023-03-19T10:51:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODp-g-A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "BrunoJuchli",
                                                                               "createdAt":  "2024-07-16T14:53:10Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "timcassell",
                                           "body":  "`generic types cannot have explicit layout` is overly restrictive. I think the runtime can verify that blittable types do not overlap with reference types without that restriction (doesn\u0027t it already?). I can\u0027t even do this, which should be perfectly valid:\r\n\r\n```cs\r\nstruct PromiseMethodBuilder\u003cT\u003e\r\n{\r\n    [StructLayout(LayoutKind.Explicit)]\r\n    private struct RefWrapper\r\n    {\r\n        // Both types are reference types, so it should be fine.\r\n        // But the runtime complains because it\u0027s using generics.\r\n        [FieldOffset(0)]\r\n        internal AsyncPromiseRef\u003cT\u003e _async;\r\n        [FieldOffset(0)]\r\n        internal PromiseRef\u003cT\u003e _task;\r\n    }\r\n\r\n    private RefWrapper _ref;\r\n    private T _result;\r\n}\r\n```",
                                           "updatedAt":  "2023-03-19T10:53:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5swY8M",
                                           "createdAt":  "2023-11-23T15:34:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "2A5F",
                                           "body":  "Both cases should be allowed\r\n\r\n```cs\r\n[StructLayout(LayoutKind.Explicit)]\r\npublic struct Foo\u003cT\u003e where T : unmanaged\r\n{\r\n    [FieldOffset(0)]\r\n    public T Value;\r\n}\r\n\r\n[StructLayout(LayoutKind.Explicit)]\r\npublic struct Bar\u003cT\u003e where T : class\r\n{\r\n    [FieldOffset(0)]\r\n    public T Value;\r\n}\r\n\r\n```",
                                           "updatedAt":  "2023-11-23T15:34:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc52Q7RR",
                                           "createdAt":  "2024-03-07T18:11:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEKzg6w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "gwiazdorrr",
                                                                               "createdAt":  "2024-07-05T14:19:42Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "fitdev",
                                                                               "createdAt":  "2024-07-10T11:51:21Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "BrunoJuchli",
                                                                               "createdAt":  "2024-07-16T14:53:31Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "domn1995",
                                                                               "createdAt":  "2025-03-21T01:37:25Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "kevingosse",
                                           "body":  "I wonder if it would be possible to give some traction to this? It would really help for some native interop scenarios, and it could be constrained to `where T : unmanaged` is there are any concern.",
                                           "updatedAt":  "2024-03-07T18:11:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EV050",
                                           "createdAt":  "2024-07-10T11:51:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "fitdev",
                                           "body":  "Really need this feature as well.",
                                           "updatedAt":  "2024-07-10T11:51:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Umzcl",
                                           "createdAt":  "2024-11-22T08:42:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "fitdev",
                                           "body":  "Perhaps it can also be extended to _any_ generic type `T` (even without `unmanaged` constraint) so long as _struct does NOT contain any `T`-typed instance fields_:\n\n```cs\n[StructLayout(LayoutKind.Explicit)]\nstruct Custom\u003cT\u003e {\n  static readonly T DefaultT = default(T);\n\n  [FieldOffset(0)]\n  int A;\n\n  [FieldOffset(4)]\n  int B;\n\n}\n```",
                                           "updatedAt":  "2024-11-22T08:42:52Z"
                                       }
                                   ],
                         "totalCount":  12
                     },
        "title":  "Make explicit struct layout compatible with generics.",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/37875",
        "createdAt":  "2020-06-14T15:33:29Z",
        "number":  37875,
        "author":  "GSPP",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODJWjaw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ForNeVeR",
                                            "createdAt":  "2020-06-14T16:51:15Z"
                                        },
                                        {
                                            "content":  "CONFUSED",
                                            "user":  "ImoutoChan",
                                            "createdAt":  "2020-06-14T17:15:57Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "svick",
                                            "createdAt":  "2020-06-14T17:19:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ericstj",
                                            "createdAt":  "2020-06-26T13:41:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MichalPetryka",
                                            "createdAt":  "2022-06-30T07:46:18Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dubiousconst282",
                                            "createdAt":  "2022-11-30T17:56:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2025-07-31T14:25:00Z"
                                        }
                                    ],
                          "totalCount":  7
                      },
        "updatedAt":  "2022-11-30T18:11:41Z",
        "body":  "The `IgnoresAccessChecksToAttribute` attribute appears to be not documented on MSDN and not even defined in the base class libraries.\r\n\r\nIs it supported? If yes, it should be documented and defined out of the box. If no, well, according to my research it has found usage and there is unofficial documentation. This is not a great state to be in.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOT20k-Q==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY3MjE4NTE0Nw==",
                                           "createdAt":  "2020-08-11T18:43:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidwrighton",
                                           "body":  "This api is not supported. It was built for internal runtime team support, and not intended for use outside of special purpose build logic. In addition, there are no tests, or spec for the attribute, and the mono runtime does not support the attribute.",
                                           "updatedAt":  "2020-08-11T18:43:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PbST5",
                                           "createdAt":  "2022-11-30T18:11:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEcquvg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2025-07-31T14:25:09Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "dubiousconst282",
                                           "body":  "This might be a little stretched, but is there a reason for the runtime to even enforce access rules nowadays? I can\u0027t see how it provides meaningfulness since access checks can be readily bypassed using reflection and unsafe ref trickery.\r\n\r\nIn either way, I believe that documenting IACT would be very helpful for IL rewriting/optimization tools, as it already allows for transforms such as inlining to be significantly more effective (at least functionality-wise).",
                                           "updatedAt":  "2022-11-30T18:11:41Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Document IgnoresAccessChecksToAttribute",
        "labels":  [
                       "documentation",
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/43022",
        "createdAt":  "2020-10-05T03:36:40Z",
        "number":  43022,
        "author":  "CaCTuCaTu4ECKuu",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-04-19T05:13:14Z",
        "body":  "All static properties of class will be initialized on acessing, and that\u0027s expected behavior, but if you inherit some class with static properties and methods and call\\access to them from derived class then runtime treat them as it\u0027s base class methods and properties regardless base is abstract and generic. That leads to floating exceptions that can cause troubles - if this methods called before accessing any property of derived class result does not correspond to what you may expect.\r\n\r\nI\u0027m attaching my class and test where I found that behavior - [Gist](https://gist.github.com/CaCTuCaTu4ECKuu/801a7a6297a8db54ad099ac75f0e20ab)\r\nIf you run all the test they (may) complete successfully, but run it one by one and **TestCount** and **TestValidValueCheck** will fail as base class static property has no registred values.\r\n\r\nI tried to somehow explicitly tell runtime that it\u0027s deriveded class, but even declaring/overriding static methods that I use in derived class didnt help as when I accessing base class static properties it still doesn\u0027t treat them as call to derived class properties.\r\n\r\nIf it\u0027s intentional behavior I\u0027m asking for confirmation and it\u0027s my request to change it.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOp-EHzg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMzM3ODc1Mg==",
                                           "createdAt":  "2020-10-05T03:36:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @eiriktsarpalis, @jeffhandley\nSee info in area-owners.md if you want to be subscribed.",
                                           "updatedAt":  "2020-10-05T03:36:48Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMzM5NTE1Nw==",
                                           "createdAt":  "2020-10-05T04:55:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "You can try to replace the static constructor with inline static initialization (`protected static Dictionary\u003cstring, T\u003e _possibleValues = new Dictionary\u003cstring, T\u003e(StringComparer.OrdinalIgnoreCase);` to check. I remember that the behavior differs by whether an explicit static constructor is present.",
                                           "updatedAt":  "2020-10-05T04:55:36Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMzY0NDc3MA==",
                                           "createdAt":  "2020-10-05T13:49:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CaCTuCaTu4ECKuu",
                                           "body":  "@huoyaoyuan initially it was inline initialization and class behaved same way, then I moved it to static ctor\r\nAlso, if I remember correctly, when compiling static ctor and static properties initialization basically merging together so there is no actual difference ",
                                           "updatedAt":  "2020-10-05T13:50:47Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMzY1NzI0NQ==",
                                           "createdAt":  "2020-10-05T14:09:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "\u003e so there is no actual difference\r\n\r\nThere is actual difference, but I\u0027m not sure if it\u0027s related to this behavior. See https://docs.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca1810?view=vs-2019 .",
                                           "updatedAt":  "2020-10-05T14:09:36Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMzY2MDI5OQ==",
                                           "createdAt":  "2020-10-05T14:14:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CaCTuCaTu4ECKuu",
                                           "body":  "\u003e if it\u0027s related to this behavior\r\n\r\nAs I mentioned, no difference within this case",
                                           "updatedAt":  "2020-10-05T14:14:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMzY2MTAzOA==",
                                           "createdAt":  "2020-10-05T14:15:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "If you make the `GetAll`, `IsValidValue`, `Parse`, and `TryParse` methods of `StringEnum\u003cT\u003e` run the static constructor of `T` before they read `_possibleValues`, then each test will pass on its own.\r\n\r\n```C#\r\nSystem.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(typeof(T).TypeHandle);\r\n```\r\n\r\nMaybe there is a way to do this without spending time on a runtime check every time those methods are called.\r\n\r\nI\u0027d also change the `_possibleValues` field from `protected` to `private`, to reduce the risk that a derived class reads the field before its own initialization.",
                                           "updatedAt":  "2020-10-05T14:16:01Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMzY2NjQ1Mw==",
                                           "createdAt":  "2020-10-05T14:24:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CaCTuCaTu4ECKuu",
                                           "body":  "@KalleOlaviNiemitalo I already find out that workaround, but that means that if a have a lot of enum classes (which I do) i have to run this for all of them or create static method to find them in all assemblies with reflection and initialize. I dont see it as an option in production environment. And thanks for advice, it make sense.\r\n\r\n",
                                           "updatedAt":  "2020-10-05T15:00:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMzY3MDAzMg==",
                                           "createdAt":  "2020-10-05T14:29:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "\u003e if a have a lot of enum classes (which I do)\r\n\r\nYou\u0027d only need to add the calls in `StringEnum\u003cT\u003e`, not in `StringEnumTestModel`. Do you mean you have more generic types like that, e.g. `GuidEnum\u003cT\u003e`?",
                                           "updatedAt":  "2020-10-05T14:29:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMzY3NDMzMg==",
                                           "createdAt":  "2020-10-05T14:36:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CaCTuCaTu4ECKuu",
                                           "body":  "\u003e If you make the `GetAll`, `IsValidValue`, `Parse`, and `TryParse` methods of `StringEnum\u003cT\u003e` run the static constructor of `T` before they read `_possibleValues`, then each test will pass on its own.\r\n\r\nAnd about that, i\u0027m not sure about hitting initialization every time, should I call method even if it\u0027s basically `if` check - is it good practice to do so?\r\nMy initiall thought was to create two implementations as delegates for listed methods and one that initialize `StringEnum\u003cT\u003e` will replace themselves with another implementations after, so only first call will run that method. Does that make any sense? I already tried this approach for different scenario. I mean that is for API and there will be a lot of parsing so I want to get as much pure performance as I can with it.",
                                           "updatedAt":  "2020-10-05T14:37:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMzY3ODM4MQ==",
                                           "createdAt":  "2020-10-05T14:43:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CaCTuCaTu4ECKuu",
                                           "body":  "Oh looks like putting `System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(typeof(T).TypeHandle);` inside `StringEnum\u003cT\u003e` static ctor basically helps. I\u0027l better get more details and update tests",
                                           "updatedAt":  "2020-10-05T14:43:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMzY4NzA4Nw==",
                                           "createdAt":  "2020-10-05T14:56:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CaCTuCaTu4ECKuu",
                                           "body":  "Ok. Clear workaround found. Thank\u0027s for help, I just missed that moment yesterday.\r\n\r\nLast question is if it\u0027s intentional behavior. So while I see why that\u0027s happening open question is sould it work like this?\r\n\r\nTo summarize. if I understand correctly.\r\nGeneric static constructor and properties are independent from it\u0027s derived class static ctor and properties and treated as different class even if acessed trough derived class static methods, but derived class initialization will, of course, initialize base class.",
                                           "updatedAt":  "2020-10-05T15:18:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6n3Y3y",
                                           "createdAt":  "2025-04-18T22:46:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CaCTuCaTu4ECKuu",
                                           "body":  "The question is still up.\nIs this expected behaviour?",
                                           "updatedAt":  "2025-04-18T22:46:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6n4QfO",
                                           "createdAt":  "2025-04-19T05:13:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "To summarize the gist:\n\n- StringEnum\\\u003cT\\\u003e has a static dictionary field, a static RegisterPossibleValue method that adds an entry to the dictionary, and a static IsValidValue method that reads from the dictionary.\n- StringEnumTestModel is derived from StringEnum\\\u003cStringEnumTestModel\\\u003e.  It has static fields with initialisers that call StringEnum\\\u003cStringEnumTestModel\\\u003e.RegisterValue.\n- A test calls StringEnumTestModel.IsValidValue(\"A\").  When this test is run on its own, it fails because the call goes to StringEnum\\\u003cStringEnumTestModel\\\u003e. IsValidValue(\"A\") and runs the static initialisation of StringEnum\\\u003cStringEnumTestModel\\\u003e but not the static field initialisers in StringEnumTestModel; the RegisterPossibleValue method is thus not called and the static dictionary remains empty.\n\nThen, whether it is a bug and whether it will be fixed.\n\nRelated sections in the C# 7 standard:\n\n- §15.3.1 General [in Class Members]\n\n  \u003e The members of a class consist of the members introduced by its *class_member_declarations* and the members inherited from the direct base class.\n\n- §15.3.4 Inheritance\n\n- §15.5.6.2 Static field initialization\n\n  \u003e If a static constructor (§15.12) exists in the class, execution of the static field initializers occurs immediately prior to executing that static constructor. Otherwise, the static field initializers are executed at an implementation-dependent time prior to the first use of a static field of that class.\n\n- §15.12 Static constructors\n\n  \u003e The static constructor for a closed class executes at most once in a given application domain. The execution of a static constructor is triggered by the first of the following events to occur within an application domain:\n  \u003e\n  \u003e * An instance of the class is created.\n  \u003e * Any of the static members of the class are referenced.\n\nIf there is no static constructor in StringEnumTestModel, then the meaning of the standard is clear: because the test does not use any static field of StringEnumTestModel, the implementation is not required to execute the static field initialisers, and the dictionary can thus be left empty.\n\nIf there is a static constructor in StringEnumTestModel, then it depends on whether the StringEnumTestModel.IsValidValue(\"A\") call counts as referencing a static member of class StringEnumTestModel.  Based on §15.3.1, the StringEnum\\\u003cStringEnumTestModel\\\u003e.IsValidValue method is also a member of class StringEnumTestModel.  So the standard appears to require the static constructor of StringEnumTestModel to be executed in this case.  However, that requirement cannot be intended because it would mean that calling the static method Object.ReferenceEquals executes the static constructors of all classes directly or indirectly derived from Object.",
                                           "updatedAt":  "2025-04-19T05:13:13Z"
                                       }
                                   ],
                         "totalCount":  13
                     },
        "title":  "Static properties initialization does not work as expected when inheriting",
        "labels":  [
                       "question",
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/45694",
        "createdAt":  "2020-12-07T19:10:08Z",
        "number":  45694,
        "author":  "verelpode",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOBZKUDA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_DOWN",
                                            "user":  "jkotas",
                                            "createdAt":  "2020-12-07T20:00:35Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2021-07-06T06:46:21Z",
        "body":  "What does everyone think of the idea of tweaking the JIT and AOT to allow the `ldsfld` instruction to load *some* fields marked with `static literal`?    \"Some fields\" meaning `ldsfld` would only support a `static literal` field if it has at least one attribute applied to the field.  For example:\r\n\r\n```cs\r\nclass Example\r\n{\r\n\t// ldsfld would support this field because it has at least one attribute applied:\r\n\t[System.Reflection.Obfuscation(Exclude = true)]\r\n\tconst string kExcludedFromObfuscation = \"PropertyXYZ\";\r\n\r\n\t// ldsfld would support this field because it has at least one attribute applied:\r\n\t[FieldMutability(FieldMutability.ReflectedMemberName)]\r\n\tconst string kNameOfPropertyXYZ = nameof(PropertyXYZ);\r\n\r\n\t// ldsfld would continue to reject this field, same as currently done:\r\n\tconst string kSomethingElse = \"abc\";\r\n\r\n\tpublic int PropertyXYZ { get; set; }\r\n\t\r\n\tstatic string UseConstant()\r\n\t{\r\n\t\treturn kExcludedFromObfuscation;\r\n\t}\r\n}\r\n```\r\n\r\nRemoving this limitation with `ldsfld` would be helpful for:\r\n* AOT compilers.\r\n* IL obfuscators.\r\n* IL decompilers such as ILSpy (quite useful for troubleshooting).\r\n\r\nYou can see in my above example that I marked `kExcludedFromObfuscation` as being excluded from obfuscation, which would be necessary because its value (\"PropertyXYZ\") is coincidentally identical to a member name.  Smart/automatic obfuscators and AOT-compilers can get confused and make incorrect transformations when a constant string is coincidentally identical to a member name but in reality is unrelated to the member and should not be transformed or renamed.\r\n\r\nUnfortunately the above usage of `Obfuscation(Exclude = true)` fails to have any effect, because the compiler loads the constant value using `ldstr` instead of `ldsfld`, because `ldsfld` doesn\u0027t allow `static literal` fields.  Currently the above-shown `UseConstant()` method is compiled to:\r\n\r\n```\r\nldstr \"PropertyXYZ\"\r\nret\r\n```\r\ninstead of:\r\n\r\n```\r\nldsfld string kExcludedFromObfuscation\r\nret\r\n```\r\n\r\nThus tools such as IL obfuscators, IL decompilers, and IL-to-x86-64 AOT-compilers are unable to see that the `UseConstant()` method references the constant field named `kExcludedFromObfuscation`, and thus unable to use any attributes (such as ObfuscationAttribute) that were applied to the field.   This problem would be solved if the JIT/AOT allowed `ldsfld` to load a `static literal` field when the field has at least one attribute applied to the field.\r\n\r\nIt\u0027s also useful in the opposite case:  It would be helpful to use an attribute to explicitly mark strings produced by the C# `nameof` operator, such as:\r\n\r\n```cs\r\n[FieldMutability(FieldMutability.ReflectedMemberName)]\r\nconst string kNameOfPropertyXYZ = nameof(PropertyXYZ);\r\n```\r\n\r\n.NET 5.x could be given a new attribute named perhaps `FieldMutabilityAttribute`, and corresponding `enum FieldMutability`, like follows:\r\n\r\n```cs\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n\tpublic enum FieldMutability : byte\r\n\t{\r\n\t\t/// \u003csummary\u003eInformation about field mutability was not supplied or is unknown.  Default or automatic behavior may be used.\u003c/summary\u003e\r\n\t\tUnspecified = 0,\r\n\r\n\t\t/// \u003csummary\u003eThe field is/was/should NOT be marked with the C# \"readonly\" nor \"const\" keywords.  The field value is NOT a reflected type name or member name.\u003c/summary\u003e\r\n\t\tMutable,\r\n\r\n\t\t/// \u003csummary\u003eThe field is/was/should be marked with the C# \"readonly\" keyword.  The field value is NOT a reflected type name or member name.\u003c/summary\u003e\r\n\t\tImmutable,\r\n\r\n\t\t/// \u003csummary\u003eThe field is/was/should be marked with the C# \"const\" keyword and should be optimized as a constant value.  The value is NOT a reflected type name or member name.  AOT-compilers and obfuscators must not transform this value, even if the value happens to be identical to the name of a type or member of a type.\u003c/summary\u003e\r\n\t\tConstantValue,\r\n\r\n\t\t/// \u003csummary\u003eThis is equivalent to a C# property setter marked with the \"init\" keyword.  The field is read-only but its value can be set or supplied at the time of object construction/instantiation.\u003c/summary\u003e\r\n\t\tInitializeOnly,\r\n\r\n\t\t/// \u003csummary\u003eThe field value is constant, and it is the name of a type used in reflection or the C# \"nameof\" keyword.  The name is not fully-qualified (should not contain \".\" character).\u003c/summary\u003e\r\n\t\tReflectedTypeName,\r\n\r\n\t\t/// \u003csummary\u003eThe field value is constant, and it is the fully-qualified name of a type used in reflection or the C# \"nameof\" keyword.  The name is fully-qualified thus it contains zero or more \".\" characters.\u003c/summary\u003e\r\n\t\tReflectedTypeFullName,\r\n\r\n\t\t/// \u003csummary\u003eThe field value is constant, and it is the name of a member of a type used in reflection or the C# \"nameof\" keyword.  The name is not fully-qualified (should not contain \".\" character).\u003c/summary\u003e\r\n\t\tReflectedMemberName,\r\n\r\n\t\t/// \u003csummary\u003eThe field value is constant, and it is the fully-qualified name of a member of a type used in reflection or the C# \"nameof\" keyword.  The name is fully-qualified thus it contains zero or more \".\" characters.\u003c/summary\u003e\r\n\t\tReflectedMemberFullName,\r\n\r\n\t\t/// \u003csummary\u003eThe field value is constant, and it is a name used in reflection, other than the name of a type or member of a type.\u003c/summary\u003e\r\n\t\tOtherReflectedName,\r\n\t}\r\n\r\n\t[AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]\r\n\tpublic class FieldMutabilityAttribute : System.Attribute\r\n\t{\r\n\t\tpublic FieldMutabilityAttribute(FieldMutability inMutability)\r\n\t\t{\r\n\t\t\tthis.Mutability = inMutability;\r\n\t\t}\r\n\r\n\t\tpublic FieldMutability Mutability { get; }\r\n\r\n\t} // class FieldMutabilityAttribute\r\n\r\n} // namespace System.Runtime.CompilerServices\r\n```\r\n\r\nEven before Roslyn takes advantage of `ldsfld` lifting the restriction on `static literal`, people could start using the new attribute immediately by using C# `static readonly` keywords instead of `const` for now.  Currently Roslyn accepts this code and generates a `ldsfld` instruction:\r\n\r\n```cs\r\n[FieldMutability(FieldMutability.ReflectedMemberName)]\r\nstatic readonly string kNameOfPropertyXYZ = nameof(PropertyXYZ);\r\n\r\nstatic string UseMemberName()\r\n{\t// `ldsfld` is already generated here because the field is \"static readonly\":\r\n\treturn kNameOfPropertyXYZ;\r\n}\r\n\r\npublic int PropertyXYZ { get; set; }\r\n```\r\n\r\nJIT\u0027s and AOT\u0027s could optimize/transform the `static readonly` field to a constant value whenever they see that the `FieldMutabilityAttribute` is applied to the `static readonly` field and indicates that the field is a constant value.\r\n\r\nThus the IL inside a .exe or .dll file on-disk would use `ldsfld`, but at runtime the `ldsfld` would be compiled to the equivalent of `ldc` or `ldstr` when the `static readonly/initonly` field is marked with a `FieldMutabilityAttribute` that indicates that the value is a constant.\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOLFdTlQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MDEyMDYzNQ==",
                                           "createdAt":  "2020-12-07T19:10:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @ajcvickers\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nWhat does everyone think of the idea of tweaking the JIT and AOT to allow the `ldsfld` instruction to load *some* fields marked with `static literal`?    \"Some fields\" meaning `ldsfld` would only support a `static literal` field if it has at least one attribute applied to the field.  For example:\r\n\r\n```cs\r\nclass Example\r\n{\r\n\t// ldsfld would support this field because it has at least one attribute applied:\r\n\t[System.Reflection.Obfuscation(Exclude = true)]\r\n\tconst string kExcludedFromObfuscation = \"PropertyXYZ\";\r\n\r\n\t// ldsfld would support this field because it has at least one attribute applied:\r\n\t[FieldMutability(FieldMutability.ReflectedMemberName)]\r\n\tconst string kNameOfPropertyXYZ = nameof(PropertyXYZ);\r\n\r\n\t// ldsfld would continue to reject this field, same as currently done:\r\n\tconst string kSomethingElse = \"abc\";\r\n\r\n\tpublic int PropertyXYZ { get; set; }\r\n\t\r\n\tstatic string UseConstant()\r\n\t{\r\n\t\treturn kExcludedFromObfuscation;\r\n\t}\r\n}\r\n```\r\n\r\nRemoving this limitation with `ldsfld` would be helpful for:\r\n* AOT compilers.\r\n* IL obfuscators.\r\n* IL decompilers such as ILSpy (quite useful for troubleshooting).\r\n\r\nYou can see in my above example that I marked `kExcludedFromObfuscation` as being excluded from obfuscation, which would be necessary because its value (\"PropertyXYZ\") is coincidentally identical to a member name.  Smart/automatic obfuscators and AOT-compilers can get confused and make incorrect transformations when a constant string is coincidentally identical to a member name but in reality is unrelated to the member and should not be transformed or renamed.\r\n\r\nUnfortunately the above usage of `Obfuscation(Exclude = true)` fails to have any effect, because the compiler loads the constant value using `ldstr` instead of `ldsfld`, because `ldsfld` doesn\u0027t allow `static literal` fields.  Currently the above-shown `UseConstant()` method is compiled to:\r\n\r\n```\r\nldstr \"PropertyXYZ\"\r\nret\r\n```\r\ninstead of:\r\n\r\n```\r\nldsfld string kExcludedFromObfuscation\r\nret\r\n```\r\n\r\nThus tools such as IL obfuscators, IL decompilers, and IL-to-x86-64 AOT-compilers are unable to see that the `UseConstant()` method references the constant field named `kExcludedFromObfuscation`, and thus unable to use any attributes (such as ObfuscationAttribute) that were applied to the field.   This problem would be solved if the JIT/AOT allowed `ldsfld` to load a `static literal` field when the field has at least one attribute applied to the field.\r\n\r\nIt\u0027s also useful in the opposite case:  It would be helpful to use an attribute to explicitly mark strings produced by the C# `nameof` operator, such as:\r\n\r\n```cs\r\n[FieldMutability(FieldMutability.ReflectedMemberName)]\r\nconst string kNameOfPropertyXYZ = nameof(PropertyXYZ);\r\n```\r\n\r\n.NET 5.x could be given a new attribute named perhaps `FieldMutabilityAttribute`, and corresponding `enum FieldMutability`, like follows:\r\n\r\n```cs\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n\tpublic enum FieldMutability : byte\r\n\t{\r\n\t\t/// \u003csummary\u003eInformation about field mutability was not supplied or is unknown.  Default or automatic behavior may be used.\u003c/summary\u003e\r\n\t\tUnspecified = 0,\r\n\r\n\t\t/// \u003csummary\u003eThe field is/was/should NOT be marked with the C# \"readonly\" nor \"const\" keywords.  The field value is NOT a reflected type name or member name.\u003c/summary\u003e\r\n\t\tMutable,\r\n\r\n\t\t/// \u003csummary\u003eThe field is/was/should be marked with the C# \"readonly\" keyword.  The field value is NOT a reflected type name or member name.\u003c/summary\u003e\r\n\t\tImmutable,\r\n\r\n\t\t/// \u003csummary\u003eThe field is/was/should be marked with the C# \"const\" keyword and should be optimized as a constant value.  The value is NOT a reflected type name or member name.  AOT-compilers and obfuscators must not transform this value, even if the value happens to be identical to the name of a type or member of a type.\u003c/summary\u003e\r\n\t\tConstantValue,\r\n\r\n\t\t/// \u003csummary\u003eThis is equivalent to a C# property setter marked with the \"init\" keyword.  The field is read-only but its value can be set or supplied at the time of object construction/instantiation.\u003c/summary\u003e\r\n\t\tInitializeOnly,\r\n\r\n\t\t/// \u003csummary\u003eThe field value is constant, and it is the name of a type used in reflection or the C# \"nameof\" keyword.  The name is not fully-qualified (should not contain \".\" character).\u003c/summary\u003e\r\n\t\tReflectedTypeName,\r\n\r\n\t\t/// \u003csummary\u003eThe field value is constant, and it is the fully-qualified name of a type used in reflection or the C# \"nameof\" keyword.  The name is fully-qualified thus it contains zero or more \".\" characters.\u003c/summary\u003e\r\n\t\tReflectedTypeFullName,\r\n\r\n\t\t/// \u003csummary\u003eThe field value is constant, and it is the name of a member of a type used in reflection or the C# \"nameof\" keyword.  The name is not fully-qualified (should not contain \".\" character).\u003c/summary\u003e\r\n\t\tReflectedMemberName,\r\n\r\n\t\t/// \u003csummary\u003eThe field value is constant, and it is the fully-qualified name of a member of a type used in reflection or the C# \"nameof\" keyword.  The name is fully-qualified thus it contains zero or more \".\" characters.\u003c/summary\u003e\r\n\t\tReflectedMemberFullName,\r\n\r\n\t\t/// \u003csummary\u003eThe field value is constant, and it is a name used in reflection, other than the name of a type or member of a type.\u003c/summary\u003e\r\n\t\tOtherReflectedName,\r\n\t}\r\n\r\n\t[AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]\r\n\tpublic class FieldMutabilityAttribute : System.Attribute\r\n\t{\r\n\t\tpublic FieldMutabilityAttribute(FieldMutability inMutability)\r\n\t\t{\r\n\t\t\tthis.Mutability = inMutability;\r\n\t\t}\r\n\r\n\t\tpublic FieldMutability Mutability { get; }\r\n\r\n\t} // class FieldMutabilityAttribute\r\n\r\n} // namespace System.Runtime.CompilerServices\r\n```\r\n\r\nEven before Roslyn takes advantage of `ldsfld` lifting the restriction on `static literal`, people could start using the new attribute immediately by using C# `static readonly` keywords instead of `const` for now.  Currently Roslyn accepts this code and generates a `ldsfld` instruction:\r\n\r\n```cs\r\n[FieldMutability(FieldMutability.ReflectedMemberName)]\r\nstatic readonly string kNameOfPropertyXYZ = nameof(PropertyXYZ);\r\n\r\nstatic string UseMemberName()\r\n{\t// `ldsfld` is already generated here because the field is \"static readonly\":\r\n\treturn kNameOfPropertyXYZ;\r\n}\r\n\r\npublic int PropertyXYZ { get; set; }\r\n```\r\n\r\nJIT\u0027s and AOT\u0027s could optimize/transform the `static readonly` field to a constant value whenever they see that the `FieldMutabilityAttribute` is applied to the `static readonly` field and indicates that the field is a constant value.\r\n\r\nThus the IL inside a .exe or .dll file on-disk would use `ldsfld`, but at runtime the `ldsfld` would be compiled to the equivalent of `ldc` or `ldstr` when the `static readonly/initonly` field is marked with a `FieldMutabilityAttribute` that indicates that the value is a constant.\r\n\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003everelpode\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.ComponentModel.DataAnnotations`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2020-12-07T19:10:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MDE0ODkxNg==",
                                           "createdAt":  "2020-12-07T20:04:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "The literal fields are compile-time only artifact today. If we allowed referencing them in IL instructions, they would have to be materialized at runtime. Attributes do not help with that. Parsing attributes takes time too.\r\n\r\n```\r\nAOT compilers.\r\nIL obfuscators.\r\nIL decompilers such as ILSpy (quite useful for troubleshooting).\r\n```\r\nI do not see how this helps any of these. \r\n\r\nIf obsluscators wants to obfluscate constant strings, they should be able to do it on their own, without any help from the runtime.",
                                           "updatedAt":  "2020-12-07T20:04:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MTcxMzQ4Nw==",
                                           "createdAt":  "2020-12-09T11:31:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "verelpode",
                                           "body":  "\r\n@jkotas -- alright I accept your viewpoint on that.  To address your critique, would you like it better if the idea is replaced with the following?  The following design has the advantage of being much simpler and it would solve the problem without requiring any changes to the `ldsfld` instruction.\r\n\r\nAs the first step, .NET Framework 5.x would be given a class containing several super-simple methods that do nothing other than merely returning the same string as passed in a parameter, like this:\r\n\r\n```cs\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n\tpublic static class ReflectedNameMarkers\r\n\t{\r\n\t\t[MethodImplAttribute(MethodImplOptions.AggressiveInlining)]\r\n\t\tpublic static string NameOfType(string name) { return name; }\r\n\t\t\r\n\t\t[MethodImplAttribute(MethodImplOptions.AggressiveInlining)]\r\n\t\tpublic static string NameOfProperty(string name) { return name; }\r\n\t\r\n\t\t// ... and a few more ...\r\n\t\t\r\n\t} // class\r\n} // namespace System.Runtime.CompilerServices\r\n```\r\n\r\nAnd then when the C# compiler / Roslyn compiles `nameof(x)`, such as...\r\n```cs\r\nclass ExampleClass\r\n{\r\n\tpublic string Test1()\r\n\t{\r\n\t\treturn nameof(ExampleClass);\r\n\t}\r\n\t\r\n\tpublic int PropertyXYZ { get; set; }\r\n\tpublic string Test2()\r\n\t{\r\n\t\treturn nameof(PropertyXYZ);\r\n\t}\r\n}\r\n```\r\n\r\nIt would be compiled to the same as:\r\n```cs\r\nclass ExampleClass\r\n{\r\n\tpublic string Test1()\r\n\t{\r\n\t\treturn System.Runtime.CompilerServices.\r\n\t\t\tReflectedNameMarkers.NameOfType(\"ExampleClass\");\r\n\t}\r\n\t\r\n\tpublic int PropertyXYZ { get; set; }\r\n\tpublic string Test2()\r\n\t{\r\n\t\treturn System.Runtime.CompilerServices.\r\n\t\t\tReflectedNameMarkers.NameOfProperty(\"PropertyXYZ\");\r\n\t}\r\n}\r\n```\r\n\r\nWhereas currently it is compiled to the same as:\r\n\r\n```cs\r\nclass ExampleClass\r\n{\r\n\tpublic string Test1()\r\n\t{\r\n\t\treturn \"ExampleClass\";\r\n\t}\r\n\t\r\n\tpublic int PropertyXYZ { get; set; }\r\n\tpublic string Test2()\r\n\t{\r\n\t\treturn \"PropertyXYZ\";\r\n\t}\r\n}\r\n```\r\n\r\nCurrently strings produced by `nameof(x)` are not annotated/marked any differently than other strings, thus IL tools have trouble recognizing that these strings are for reflection purposes.\r\n\r\nHowever, if the C# compiler wraps these reflection strings in calls to `ReflectedNameMarkers.NameOfType(string)` etc as demonstrated above, then IL tools could simply look for invocations of these methods, and then they would reliably know that a string is for reflection purposes when it is wrapped in an invocation of `ReflectedNameMarkers.NameOfType(string)`.\r\n\r\nIt\u0027d also be useful to make a method `ReflectedNameMarkers.NotForReflection(string)` that does the opposite of `NameOfType(string)`.  When a developer is experiencing troubles with an IL tool because the developer is using a string that is coincidentally identical to a type or member name, and because the IL tool may be using heuristics to try to identify reflection names (because currently no other solution exists), then the developer could explicitly instruct the IL tool that the string is unrelated to reflection, by doing this:\r\n\r\n```cs\r\nusing System.Runtime.CompilerServices;\r\nclass ExampleClass\r\n{\r\n\tpublic int PropertyXYZ { get; set; }\r\n\t\r\n\tpublic string Test3()\r\n\t{\r\n\t\treturn ReflectedNameMarkers.NotForReflection(\"PropertyXYZ\");\r\n\t}\r\n}\r\n```\r\n\r\nIn full, the class `ReflectedNameMarkers` could contain:\r\n\r\n```cs\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n\tpublic static class ReflectedNameMarkers\r\n\t{\r\n\t\t[MethodImplAttribute(MethodImplOptions.AggressiveInlining)]\r\n\t\tpublic static string NameOfType(string name) { return name; }\r\n\t\t\r\n\t\t[MethodImplAttribute(MethodImplOptions.AggressiveInlining)]\r\n\t\tpublic static string NameOfMethod(string name) { return name; }\r\n\t\t\r\n\t\t[MethodImplAttribute(MethodImplOptions.AggressiveInlining)]\r\n\t\tpublic static string NameOfField(string name) { return name; }\r\n\t\t\r\n\t\t[MethodImplAttribute(MethodImplOptions.AggressiveInlining)]\r\n\t\tpublic static string NameOfProperty(string name) { return name; }\r\n\t\r\n\t\t[MethodImplAttribute(MethodImplOptions.AggressiveInlining)]\r\n\t\tpublic static string NameOfEvent(string name) { return name; }\r\n\t\t\r\n\t\t[MethodImplAttribute(MethodImplOptions.AggressiveInlining)]\r\n\t\tpublic static string NameOfEnumMember(string name) { return name; }\r\n\t\t\r\n\t\t[MethodImplAttribute(MethodImplOptions.AggressiveInlining)]\r\n\t\tpublic static string NotForReflection(string text) { return text; }\r\n\t\t\r\n\t} // class\r\n} // namespace System.Runtime.CompilerServices\r\n```\r\n\r\nIf desired, the `NameOfType(string)` method could be split into several more-specific methods named as follows, because this additional info might be useful to IL tools:\r\n* `NameOfClass` or `NameOfReferenceType`\r\n* `NameOfStructValueType`\r\n* `NameOfEnumType`\r\n* `NameOfDelegateType`\r\n* `NameOfPrimitiveType`\r\n* `NameOfOtherType`\r\n\r\nAlso if desired, the `ReflectedNameMarkers` class might also contain methods to explicitly identify fully-qualified names as opposed to unqualified names, but this is probably unnecessary because IL tools could instead look for the presence of one or more \".\" characters in the name.\r\n\r\nWhat do you think?  Do you like this design better?",
                                           "updatedAt":  "2020-12-09T11:31:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MTcyMDUyOA==",
                                           "createdAt":  "2020-12-09T11:46:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "verelpode",
                                           "body":  "\r\nIt occurred to me that people could begin using this new class `System.Runtime.CompilerServices.ReflectedNameMarkers` even before Roslyn supports it (or even if Roslyn never supports it).  In the meantime, people could use the C# `nameof` keyword/function together with a manual invocation of the method `ReflectedNameMarkers.NameOfType(string)`.  For example, people could write:\r\n\r\n```cs\r\nusing System.Runtime.CompilerServices;\r\nclass ExampleClass\r\n{\r\n\tpublic int PropertyXYZ { get; set; }\r\n\r\n\tpublic string Test1()\r\n\t{\r\n\t\treturn ReflectedNameMarkers.NameOfType(nameof(ExampleClass));\r\n\t}\r\n\t\r\n\tpublic string Test2()\r\n\t{\r\n\t\treturn ReflectedNameMarkers.NameOfProperty(nameof(PropertyXYZ));\r\n\t}\r\n\t\r\n\tpublic string Test3()\r\n\t{\r\n\t\treturn ReflectedNameMarkers.NotForReflection(\"PropertyXYZ\");\r\n\t}\r\n}\r\n```\r\n\r\nThus it would be usable immediately, and various IL tools could immediately begin supporting the recognition / special meaning of invocations of `ReflectedNameMarkers.NameOfType`.  Obviously, to gain widespread support, this class `ReflectedNameMarkers` (or similar) would need to be made official, i.e. added to .NET Framework 5.x in a suitable official namespace (presumably `System.Runtime.CompilerServices` is best).\r\n\r\nObviously the final solution would be nicer if/when Roslyn automatically transforms `nameof(x)` to `ReflectedNameMarkers.NameOfType(\"x\")` instead of requiring people to manually write `ReflectedNameMarkers.NameOfType(nameof(x))`.\r\n",
                                           "updatedAt":  "2020-12-09T11:46:36Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MTc4MjQzNA==",
                                           "createdAt":  "2020-12-09T13:48:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "I do not see the scenario that this helps with.\r\n\r\nAs I have said above - if obfuscators want to obfuscate constant strings, they should be able to do it on their own, without any help from the runtime.",
                                           "updatedAt":  "2020-12-09T15:09:25Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MTgyODExMQ==",
                                           "createdAt":  "2020-12-09T15:02:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "verelpode",
                                           "body":  "\u003e As I have said above - if obfuscators wants to obfuscate constant strings, they should be able to do it on their own, without any help from the runtime.\r\n\r\nI was also thinking about the experiences that were learned from \".NET Native\", not only thinking about obfuscators, but if I use the obfuscator example for now since you and I mentioned it, I\u0027ll try to explain the problem more clearly than my previous messages.\r\n\r\nFirstly, if the original/input source code is....\r\n```cs\r\nclass ExampleClass\r\n{\r\n\tpublic int PropertyXYZ { get; set; }\r\n\tpublic string Test()\r\n\t{\r\n\t\treturn nameof(PropertyXYZ); // Currently compiled to: return \"PropertyXYZ\";\r\n\t}\r\n}\r\n```\r\n\r\n...and when an obfuscator needs to rename **property** `PropertyXYZ` to `a1`, then obfuscators lack sufficient information to know whether the **string** `\"PropertyXYZ\"` should also be transformed to `\"a1\"` or left unchanged.  Obfuscators -- but also other IL tools such as cross-compilers and analyzers -- are left unable to reliably determine which of the following two transformations is the correct one:\r\n\r\n```cs\r\npublic int a1 { get; set; }\r\npublic string Test()\r\n{\r\n\treturn \"a1\";\r\n}\r\n\r\n// VERSUS:\r\n\r\npublic int a1 { get; set; }\r\npublic string Test()\r\n{\r\n\treturn \"PropertyXYZ\";\r\n}\r\n```\r\n\r\nCurrently IL tools are prevented from seeing the C# `nameof` expression, thus these tools see only a string that equals the name of a property/member or type, thus these tools cannot know whether the string is truly the name of a property versus just coincidentally identical to the name of a member or type.   This lack of the necessary information leads to incorrect transformations or analysis results or cross-compiles, such as the above example of an obfuscator not knowing whether the correct transformation is `return \"a1\";` OR unchanged `return \"PropertyXYZ\";`.\r\n",
                                           "updatedAt":  "2020-12-09T15:02:21Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MTgzMTgyMg==",
                                           "createdAt":  "2020-12-09T15:08:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "This problem is not limited to `nameof` - it\u0027s a more general problem of figuring out what parts of the program are accessed by reflection. Someone not using `nameof` is going to hit this too - `nameof` is not mandatory - one can just spell out the name as a literal string in the source code and the runtime behavior is the same.\r\n\r\nIL Linker faces similar problem - the problem there is \"is it safe to remove a statically unreachable part of the program\" - this problem is very similar. The safety problem comes from the fact that an app could reflection-access something that wasn\u0027t seen as used.\r\n\r\nhttps://github.com/mono/linker/blob/a86658f4602e616d71e5d6db23a30940534132e2/docs/design/reflection-flow.md is one of the ways we\u0027re trying to address this. In .NET 5 we shipped a preview and we\u0027re iterating on that further.",
                                           "updatedAt":  "2020-12-09T15:08:01Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MTg4NjE2NA==",
                                           "createdAt":  "2020-12-09T16:27:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "verelpode",
                                           "body":  "@MichalStrehovsky \r\n\u003e Someone not using nameof is going to hit this too - nameof is not mandatory - one can just spell out the name as a literal string in the source code and the runtime behavior is the same.\r\n\r\nTrue.  I don\u0027t want to ask for too much, and I don\u0027t want to set my expectations unfairly high, therefore I wouldn\u0027t complain if I use ILLink now or in future and ILLink \"fails\" to handle a case where I wrote a type or member name as a literal string instead of `nameof`.  I would say that ILLink\u0027s failure is my own fault because I could\u0027ve and should\u0027ve used `nameof` but I wrote a literal string instead, so it\u0027s my fault, BUT....\r\n\r\nBut currently I\u0027m unable to say it\u0027s my own fault, because currently even if I do use `nameof` correctly, ILLink or other IL tools still cannot see that I used `nameof` correctly.  Either of my two aforementioned suggestions could eliminate this `nameof` problem, because either of those would make `nameof` visible/detectable in the IL.\r\n\r\nThanks for the link to the very relevant **\"reflection-flow.md\"** re .NET Native and ILLink.  .NET Native is/was fundamentally great in principle, so it\u0027s sad that .NET Native received so many complaints as a result of reflection issues.\r\n\r\nMy suggestion for `nameof` would help reduce these problems.  It wouldn\u0027t solve everything mentioned in that \"reflection-flow.md\", but it would help.  I don\u0027t believe there exists any single \"killer solution\" that kills all reflection/ILLink problems all at once, so I think progress needs to be made step-by-step, and one of those steps is eliminating the `nameof` problem, such as how I mentioned.  Ofcourse I\u0027d love to kill the entire problem, but since that\u0027s impossible, I suggest making progress by shrinking the size of the problem starting with `nameof`.\r\n\r\nI see the \"reflection-flow.md\" includes several examples of invoking `Type.GetMethod(string)` such as:\r\n```cs\r\n_otherType.GetMethod(\"RandomMethod\");\r\n```\r\n\r\nI suggest that invoking `Type.GetMethod(string)` should be avoided as much as possible, and instead the following IL should be produced whenever possible:\r\n\r\n```\r\nldtoken OtherType.RandomMethod\r\ncall class System.Reflection.MethodBase System.Reflection.MethodBase::GetMethodFromHandle(System.RuntimeMethodHandle)\r\n```\r\n\r\nThat is already supported and preexisting at the IL level, but unfortunately at the C# level there does not yet exist any equivalent of `typeof(x)` that works for members instead of types.  For example, ideally C# would support:\r\n\r\n```cs\r\nSystem.Reflection.MethodBase info = metadataof(OtherType.RandomMethod);\r\n// ...to be used instead of:\r\nSystem.Reflection.MethodBase info = typeof(OtherType).GetMethod(\"RandomMethod\");\r\n// and also instead of:\r\nSystem.Reflection.MethodBase info = typeof(OtherType).GetMethod(nameof(OtherType.RandomMethod));\r\n```\r\n\r\nIf `metadataof` and the improved `nameof` would be implemented, then yes I realize there would still remain several unsolved problems as mentioned in \"reflection-flow.md\", but at least good progress can be made, and that\u0027s practically a requirement because no single killer solution exists.",
                                           "updatedAt":  "2020-12-09T17:04:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MTkwNDE5Ng==",
                                           "createdAt":  "2020-12-09T16:56:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "verelpode",
                                           "body":  "@MichalStrehovsky  -- I see the \"reflection-flow.md\" also says:\r\n\u003e To document reflection use across methods, we\u0027ll introduce a new attribute DynamicallyAccessedMembersAttribute that can be attached to method parameters, the method return parameter, fields, and properties (whose type is System.Type, or System.String).\r\n\r\nIt says fields of type string, but it may break when the string field is marked `const`.  Although you can already apply any Attributes to `const string` fields, there is a problem because ILLink or other IL tools cannot see where the constant field is used.  IL tools can only see where the `const string` field is defined and what Attributes are applied to it, but not where the const field is used.   \r\n\r\nHence my `ldsfld` idea described in the very first message in this issue.  This would allow IL tools to see where a const field is used, not only where it is defined, provided the const field has at least one Attribute applied to it.\r\nHowever I would also still be happy if the `ldsfld` idea is rejected in favor of using the simpler idea of `ReflectedNameMarkers.NameOfType(string)`.\r\n\r\nNote the `ldsfld` idea is more powerful and might be useful for \"reflection-flow.md\", or possibly even mandatory within a goal of solving ALL of the problems described in the \"reflection-flow.md\".  So the `ldsfld` idea does more than the `ReflectedNameMarkers.NameOfType` idea, but `ReflectedNameMarkers.NameOfType` is appealing because it is much simpler and much less work than the `ldsfld` idea, and perhaps sufficient.\r\n\r\nIt boils down to a choice between:\r\n* Do you want to solve only `nameof`? (then use the `ReflectedNameMarkers.NameOfType` idea), or...\r\n* Do you want to solve all reflection/linking issues that might require attributes to be applied to `const` fields, including `nameof` but also other issues where it may be useful to apply attributes to const fields (if yes, then use the idea of allowing `ldsfld` to load attribute-annotated const fields, plus make  `nameof` produce a backing field, that is a const string field with a suitable Attribute applied).\r\n",
                                           "updatedAt":  "2020-12-09T17:09:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MjAyOTE3Ng==",
                                           "createdAt":  "2020-12-09T20:28:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "It is not possible to use `nameof` in many situations. For example, when the code is using reflection to access types or methods that it does not have direct access to, like here: https://github.com/dotnet/runtime/blob/master/src/libraries/System.Private.CoreLib/src/System/AppDomain.cs#L415\r\n\r\nIt means that any solution based on nameof will be partial at best.\r\n\r\nThe solution we are going after with the linker attributes is much more complete solution for this problem. The obfuscators can use these same attributes to figure what is reflected upon as well.",
                                           "updatedAt":  "2020-12-09T20:28:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MzgwNTk0MA==",
                                           "createdAt":  "2020-12-12T19:41:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "verelpode",
                                           "body":  "Here\u0027s an improvement to my previous designs.  This would provide more info to ILLinker and other tools.  For example, if the original/input source code is....\r\n\r\n```cs\r\nclass ExampleClass\r\n{\r\n\tpublic string TestNameOfType()\r\n\t{\r\n\t\treturn nameof(ExampleClass);\r\n\t}\r\n}\r\n```\r\n\r\nThen the C# compiler would transform it to the equivalent of:\r\n\r\n```cs\r\nclass ExampleClass\r\n{\r\n\t[ReflectedNameInfoAttribute(typeof(ExampleClass))]\r\n\tprivate const string __nameOf_ExampleClass = \"ExampleClass\";\r\n\t// Alternatively \"static readonly\" (instead of \"const\") would be required if \"ldsfld\" will never load const fields.\r\n\r\n\tpublic string TestNameOfType()\r\n\t{\r\n\t\treturn __nameOf_ExampleClass; // was: return nameof(ExampleClass);\r\n\t}\r\n}\r\n```\r\n\r\nWhere `ReflectedNameInfoAttribute` would be like this:\r\n\r\n```cs\r\n[AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]\r\npublic class ReflectedNameInfoAttribute : System.Attribute\r\n{\r\n\tpublic ReflectedNameInfoAttribute(System.Type inTargetType)\r\n\t{\r\n\t\tif (inTargetType is null) throw new ArgumentNullException();\r\n\t\tthis.TargetType = inTargetType;\r\n\t\t// If desired, can also save a copy of the full names:\r\n\t\tthis.TypeFullName = inTargetType.FullName;\r\n\t\tthis.AssemblyFullName = inTargetType.Assembly.FullName;\r\n\t}\r\n\r\n\tpublic ReflectedNameInfoAttribute(System.Reflection.MemberInfo inMember)\r\n\t{\r\n\t\tif (inMember is null) throw new ArgumentNullException();\r\n\t\tthis.TargetMember = inMember;\r\n\t\tthis.TargetMemberType = inMember.MemberType;\r\n\t\tSystem.Type t = inMember.DeclaringType;\r\n\t\tthis.TargetType = t;\r\n\t\t// If desired, can also save a copy of the full names:\r\n\t\tthis.TypeFullName = t.FullName;\r\n\t\tthis.AssemblyFullName = t.Assembly.FullName;\r\n\t}\r\n\r\n\t// This can be used to target a member when the System.Reflection.MemberInfo is unavailable.\r\n\tpublic ReflectedNameInfoAttribute(System.Type inTargetType, System.Reflection.MemberTypes inTargetMemberType)\r\n\t{\r\n\t\tif (inTargetType is null) throw new ArgumentNullException();\r\n\t\tthis.TargetType = inTargetType;\r\n\t\tthis.TargetMemberType = inTargetMemberType;\r\n\t\t// If desired, can also save a copy of the full names:\r\n\t\tthis.TypeFullName = inTargetType.FullName;\r\n\t\tthis.AssemblyFullName = inTargetType.Assembly.FullName;\r\n\t}\r\n\r\n\tpublic ReflectedNameInfoAttribute(string inTypeFullName, string inAssemblyFullName)\r\n\t{\r\n\t\tthis.TypeFullName = inTypeFullName;\r\n\t\tthis.AssemblyFullName = inAssemblyFullName;\r\n\t}\r\n\r\n\tpublic System.Type TargetType { get; set; }\r\n\r\n\tpublic System.Reflection.MemberInfo TargetMember { get; set; }\r\n\r\n\t// Equals System.Reflection.MemberInfo.MemberType.\r\n\tpublic System.Reflection.MemberTypes TargetMemberType { get; set; }\r\n\r\n\t// Equals System.Type.FullName.\r\n\tpublic string TypeFullName { get; set; }\r\n\r\n\t// Equals System.Type.Assembly.FullName.\r\n\tpublic string AssemblyFullName { get; set; }\r\n\r\n}\r\n```\r\n\r\nWhen `nameof` is used for a member instead of a type, for example...\r\n\r\n```cs\r\nclass ExampleClass\r\n{\r\n\tpublic int PropertyXYZ { get; set; }\r\n\t\r\n\tpublic string TestNameOfProperty()\r\n\t{\r\n\t\treturn nameof(PropertyXYZ);\r\n\t}\r\n}\r\n```\r\n\r\nThen the C# compiler would transform it to the equivalent of:\r\n\r\n```cs\r\nclass ExampleClass\r\n{\r\n\tpublic int PropertyXYZ { get; set; }\r\n\t\r\n\t[ReflectedNameInfoAttribute(metadataof(PropertyXYZ))]\r\n\tprivate const string __nameOf_PropertyXYZ = \"PropertyXYZ\";\r\n\t// Alternatively \"static readonly\" (instead of \"const\") would be required if \"ldsfld\" will never load const fields.\r\n\r\n\tpublic string TestNameOfProperty()\r\n\t{\r\n\t\treturn __nameOf_PropertyXYZ; // was: return nameof(PropertyXYZ);\r\n\t}\r\n}\r\n```\r\n\r\nWhere `metadataof` would be a function like `typeof` except for members.  Where `typeof` returns `System.Type`, `metadataof` would return `System.Reflection.MemberInfo`.\r\nAlternatively, if no `metadataof` will exist, then:\r\n\r\n```cs\r\nclass ExampleClass\r\n{\r\n\tpublic int PropertyXYZ { get; set; }\r\n\t\r\n\t[ReflectedNameInfoAttribute(typeof(ExampleClass), System.Reflection.MemberTypes.Property)]\r\n\tprivate const string __nameOf_PropertyXYZ = \"PropertyXYZ\";\r\n\r\n\tpublic string TestNameOfProperty()\r\n\t{\r\n\t\treturn __nameOf_PropertyXYZ; // was: return nameof(PropertyXYZ);\r\n\t}\r\n}\r\n```\r\n\r\n\r\n",
                                           "updatedAt":  "2020-12-12T19:41:55Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MzgwNzg3NQ==",
                                           "createdAt":  "2020-12-12T19:58:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "verelpode",
                                           "body":  "@jkotas wrote:\r\n\u003e It is not possible to use nameof in many situations. For example, when the code is using reflection to access types or methods that it does not have direct access to, like here:\r\n\r\nI see line 417 is:\r\n```cs\r\nType type = Type.GetType(\"System.Security.Principal.GenericPrincipal, System.Security.Claims\", throwOnError: true)!;\r\n```\r\n\r\nThis could be either manually or automatically transformed to:\r\n\r\n```cs\r\n[ReflectedNameInfoAttribute(\"System.Security.Principal.GenericPrincipal\", \"System.Security.Claims\")]\r\nprivate const/*or static readonly*/ string __fullnameOf_GenericPrincipal = \"System.Security.Principal.GenericPrincipal, System.Security.Claims\";\r\n\r\nType type = Type.GetType(__fullnameOf_GenericPrincipal, throwOnError: true)!;\r\n```\r\n\r\nIn other words, the `ReflectedNameInfoAttribute` could be usable both with and without the `nameof(x)` function.\r\n\r\nEither you manually use the `ReflectedNameInfoAttribute` similar to the above, or maybe the C# compiler might recognize special method invocations such as `Type.GetType(string)` and automatically generate a backing field with `ReflectedNameInfoAttribute` applied.\r\n\r\n\r\n\r\n\u003e The solution we are going after with the linker attributes is much more complete solution for this problem.\r\n\r\nI\u0027m unsure if you\u0027re saying that a solution was already recently invented, but if that\u0027s what you mean, then that\u0027s great news.\r\n",
                                           "updatedAt":  "2020-12-12T19:58:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MzgxMDIyNA==",
                                           "createdAt":  "2020-12-12T20:08:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e In other words, the ReflectedNameInfoAttribute could be usable both with and without the nameof(x) function.\r\n\r\nWhat benefit does it have over the reflection flow attributes (https://github.com/mono/linker/blob/a86658f4602e616d71e5d6db23a30940534132e2/docs/design/reflection-flow.md)?\r\n\r\n\u003e maybe the C# compiler might recognize special method invocations\r\n\r\nThis would mean teaching the whole stack about this feature. Features like that have to be very high value for it to be worth it. I do not see the very high value here.",
                                           "updatedAt":  "2020-12-12T20:08:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MzgxNDE2Ng==",
                                           "createdAt":  "2020-12-12T20:12:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "verelpode",
                                           "body":  "I don\u0027t see how anything currently described in the \"reflection-flow.md\" solves the `nameof` problem, but possibly that\u0027s because I don\u0027t understand some particular part of it or I missed something in it.",
                                           "updatedAt":  "2020-12-12T20:12:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MzkxNjIzMQ==",
                                           "createdAt":  "2020-12-12T22:50:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "verelpode",
                                           "body":  "A neat syntax idea just occurred to me.  What if the C# compiler allowed you to write a string with quotation marks inside of `nameof(x)` like follows?\r\n\r\n```cs\r\nType t = System.Type.GetType(nameof(\"System.Security.Principal.GenericPrincipal\"));\r\n```\r\n\r\nAnd then the compiler would transform the above to use an attribute-annotated compiler-generated backing field, something like this:\r\n\r\n```cs\r\n[ReflectedNameInfoAttribute(\"System.Security.Principal.GenericPrincipal\")]\r\nprivate const/*or static readonly*/ string __nameOf1234 = \"System.Security.Principal.GenericPrincipal\";\r\n\r\nType t = System.Type.GetType(__nameOf1234);\r\n```\r\n\r\nThus obviously people would and should still try to use `nameof(x)` without quotation marks as much as possible, but for the situations where such direct access is impossible or bad, then the compiler could allow you to write it as a string with quotation marks:  `nameof(\"x\")` whenever `nameof(x)` is impossible.  The string would be immediately recognizable to ILLinker and other tools thanks to the compiler-generated attribute applied to the backing field.\r\n\r\n### Soft References that allow nameof to be used where currently it cannot be used?\r\nAlternatively, if people want to go further with this idea, another possibility is:  Don\u0027t use quotation marks inside `nameof`;  don\u0027t change any C# syntax;  instead give Visual Studio an ability to add a **\"soft reference\"** to a .csproj !\r\n\r\nIf you added the Assembly \"System.Security.Claims.dll\" to a .csproj as a \"soft reference\", then you\u0027d be able to use `nameof(System.Security.Principal.GenericPrincipal)` with the normal syntax, but the C# compiler would convert it to a string because it\u0027s only a \"soft reference\" to the DLL/Assembly.\r\n\r\nThe compiler would still perform compile-time checking, thus if you make a typo, frex `nameof(System.Security.Principal.GenericPrincpl)` then the compiler would generate an error saying that \"GenericPrincpl\" doesn\u0027t exist.  The compiler can do this because it has access to read the Assembly at compile-time.  However the output IL would not contain any true/hard/normal reference to the DLL, rather it would contain an attribute-annotated string, when in Visual Studio you only add the Assembly \"System.Security.Claims.dll\" as a \"soft reference\" or a \"dynamic reference\" or a \"weak reference\" or whatever you want to name the new feature.\r\n",
                                           "updatedAt":  "2020-12-12T22:50:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MzkyMDUzMw==",
                                           "createdAt":  "2020-12-12T23:36:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "verelpode",
                                           "body":  "### Use the extern keyword and DllImportAttribute?\r\n\r\n\u003e It is not possible to use nameof in many situations. For example, when the code is using reflection to access types or methods that it does not have direct access to, like here:\r\n\r\nHow about changing that code to use the [extern](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/extern) keyword?  Currently that code is written like this....\r\n```cs\r\nIPrincipal Example()\r\n{\r\n\tSystem.Type t = System.Type.GetType(\"System.Security.Principal.GenericPrincipal, System.Security.Claims\");\r\n\tSystem.Reflection.MethodInfo mi = t.GetMethod(\"GetDefaultInstance\");\r\n\treturn (IPrincipal) mi.Invoke(null, null);\r\n}\r\n```\r\n\r\nHow about changing it to use `extern` like this:\r\n\r\n```cs\r\n[System.Runtime.InteropServices.DllImport(\"System.Security.Claims.dll\", EntryPoint =\"System.Security.Principal.GenericPrincipal.GetDefaultInstance\", \r\n\tCallingConvention = CallingConvention.Clr, WeakLink = true)]\r\nprivate static extern IPrincipal GetDefaultInstance();\r\n\r\nIPrincipal Example()\r\n{\r\n\treturn GetDefaultInstance();\r\n}\r\n```\r\n\r\nOfcourse currently that doesn\u0027t work, but it could.  The above `WeakLink` property of `DllImportAttribute` doesn\u0027t exist, but it could.  Likewise the above member `CallingConvention.Clr` of the `enum CallingConvention` doesn\u0027t exist, but it could, thus `DllImportAttribute` or some other new attribute could be used for weak-linking/importing C# methods into C# Assemblies, instead of the current problematic way of passing a string to `System.Type.GetType(string)`.\r\n\r\nCurrently the preexisting `extern` keyword already provides a much nicer syntax (the normal syntax) for passing parameters to external methods, much nicer than the comparatively cumbersome way of constructing an object array to pass to `MethodInfo.Invoke(object, object[])`.   So why not use `extern` for importing both C#/CLR and C++ methods, not only C++ methods?   It looks like it may be feasible to extend `extern` and `DllImportAttribute` to support importing CLR methods from IL DLL\u0027s, not only native DLL\u0027s.",
                                           "updatedAt":  "2020-12-12T23:51:13Z"
                                       }
                                   ],
                         "totalCount":  16
                     },
        "title":  "[JIT\u0026AOT] Allow ldsfld to load attribute-annotated static literal fields",
        "labels":  [
                       "area-TypeSystem-coreclr",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/46104",
        "createdAt":  "2020-12-15T23:25:09Z",
        "number":  46104,
        "author":  "jaredpar",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC0O0Lg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SingleAccretion",
                                            "createdAt":  "2020-12-15T23:40:18Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jeffschwMSFT",
                                            "createdAt":  "2020-12-16T00:06:33Z"
                                        },
                                        {
                                            "content":  "ROCKET",
                                            "user":  "MichalStrehovsky",
                                            "createdAt":  "2020-12-16T08:27:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AlgorithmsAreCool",
                                            "createdAt":  "2020-12-16T14:08:03Z"
                                        },
                                        {
                                            "content":  "ROCKET",
                                            "user":  "Sergio0694",
                                            "createdAt":  "2020-12-16T20:11:41Z"
                                        },
                                        {
                                            "content":  "ROCKET",
                                            "user":  "GabrielMotaAlexandre",
                                            "createdAt":  "2021-01-09T00:26:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hez2010",
                                            "createdAt":  "2021-04-01T04:34:37Z"
                                        },
                                        {
                                            "content":  "ROCKET",
                                            "user":  "Thealexbarney",
                                            "createdAt":  "2021-04-12T21:17:49Z"
                                        },
                                        {
                                            "content":  "ROCKET",
                                            "user":  "carmineos",
                                            "createdAt":  "2021-05-04T21:14:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sgf",
                                            "createdAt":  "2021-06-03T14:04:51Z"
                                        },
                                        {
                                            "content":  "ROCKET",
                                            "user":  "sgf",
                                            "createdAt":  "2021-06-03T14:04:51Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "sgf",
                                            "createdAt":  "2021-06-03T14:04:57Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "sgf",
                                            "createdAt":  "2021-06-03T14:05:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aromaa",
                                            "createdAt":  "2021-10-15T10:31:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "CodingMadness",
                                            "createdAt":  "2022-11-21T23:31:09Z"
                                        },
                                        {
                                            "content":  "ROCKET",
                                            "user":  "CodingMadness",
                                            "createdAt":  "2022-11-21T23:31:12Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "CodingMadness",
                                            "createdAt":  "2022-11-21T23:31:17Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "samsosa",
                                            "createdAt":  "2022-12-08T16:19:18Z"
                                        },
                                        {
                                            "content":  "ROCKET",
                                            "user":  "samsosa",
                                            "createdAt":  "2022-12-08T16:19:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "0xfeeddeadbeef",
                                            "createdAt":  "2023-11-26T14:58:16Z"
                                        }
                                    ],
                          "totalCount":  20
                      },
        "updatedAt":  "2024-05-31T11:59:00Z",
        "body":  "This is a \"User Story\" to track the proposed improvements to low level struct performance improvements. \r\n\r\nC# Language Features\r\n- [ ] Allow `ref` fields in `ref struct` types dotnet/csharplang#1147\r\n- [ ] Allow safe fixed sized buffers of any type dotnet/csharplang#1314\r\n\r\nThe feature proposal for both C# features is captured [here](https://github.com/dotnet/csharplang/blob/master/proposals/low-level-struct-improvements.md)\r\n\r\nRelated Runtime Requests: \r\n- [ ] Allow `ref` fields in `ref struct` dotnet/runtime#32060\r\n- [ ] `FixedSizBufferAttribute` proposal dotnet/runtime#12320\r\n- [x] Mono support dotnet/runtime#48113",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOMe8GLg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0NTYzMDI0MQ==",
                                           "createdAt":  "2020-12-15T23:25:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Dotnet-GitSync-Bot",
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2020-12-15T23:25:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0NTYzMzk3NA==",
                                           "createdAt":  "2020-12-15T23:35:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "What about...?\r\n\r\n`Span\u003cobject\u003e span = stackalloc object[5];` \r\n\r\nWhich is sorta\r\n```csharp\r\nstruct Obj5\r\n{\r\n    object o0;\r\n    object o1;\r\n    object o2;\r\n    object o3;\r\n    object o4;\r\n}\r\n\r\nObj5 objs = default;\r\nSpan\u003cobject\u003e span = CreateSpan(ref objs.o0, 5);\r\n```",
                                           "updatedAt":  "2020-12-15T23:35:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0NTYzNDY2Ng==",
                                           "createdAt":  "2020-12-15T23:37:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jaredpar",
                                           "body":  "The `stackalloc` primitive doesn\u0027t support reference types. ",
                                           "updatedAt":  "2020-12-15T23:37:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0NTY4NTA1MQ==",
                                           "createdAt":  "2020-12-16T00:31:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "`localloc` returning a `byte*` pointer is obv problematic for a reference type; however if it was limited to a `Span\u003cref type\u003e` receiver and a fixed size rather than variable size then t could be translated to something closer to the safe fixed sized buffer proposal? e.g.\r\n```csharp\r\nstruct \u003cBuffer\u003ee__FixedBuffer_1024\u003cT\u003e\r\n{\r\n    private T _e0;\r\n    private T _e1;\r\n    // _e2 ... _e1023\r\n    private T _e1024;\r\n\r\n    public ref T this[int index] =\u003e ref (uint)index \u003c= 1024u ?\r\n                                         ref RefAdd\u003cT\u003e(ref _e0, index):\r\n}\r\n```\r\nNot sure what the GC would make of referring only to an internal element of a stack struct (if it was sliced)",
                                           "updatedAt":  "2020-12-16T00:31:47Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0NTY5NjM0Mw==",
                                           "createdAt":  "2020-12-16T01:06:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBaGedA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "benaadams",
                                                                               "createdAt":  "2020-12-16T01:24:42Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "I think https://github.com/dotnet/runtime/issues/25423 is the proposal we should follow to improve stackalloc.",
                                           "updatedAt":  "2020-12-16T01:06:02Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxODA1MDA0Mg==",
                                           "createdAt":  "2021-04-12T18:53:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "@jaredpar this is unlikely for 6 due to statics in interfaces work. Ok to move out? ",
                                           "updatedAt":  "2021-04-12T18:53:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgzNzIxMTA4Ng==",
                                           "createdAt":  "2021-05-10T19:37:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOB-duhw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "CONFUSED",
                                                                               "user":  "MichalStrehovsky",
                                                                               "createdAt":  "2021-05-10T20:07:21Z"
                                                                           },
                                                                           {
                                                                               "content":  "CONFUSED",
                                                                               "user":  "sgf",
                                                                               "createdAt":  "2021-06-03T14:05:45Z"
                                                                           },
                                                                           {
                                                                               "content":  "CONFUSED",
                                                                               "user":  "aromaa",
                                                                               "createdAt":  "2021-10-15T10:33:29Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "mangod9",
                                           "body":  "Moving this to future, since this is moved out of .net 6. ",
                                           "updatedAt":  "2021-05-10T19:37:14Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgzNzc0ODI3MA==",
                                           "createdAt":  "2021-05-11T03:51:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "iSazonov",
                                           "body":  "Fore reference https://github.com/dotnet/runtime/issues/38743",
                                           "updatedAt":  "2021-05-11T03:51:21Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Improve low level struct performance ",
        "labels":  [
                       "area-TypeSystem-coreclr",
                       "User Story",
                       "Bottom Up Work"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/46705",
        "createdAt":  "2020-12-18T04:28:46Z",
        "number":  46705,
        "author":  "ly5222518000",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-07-04T16:22:07Z",
        "body":  "\u003c!--\r\n\r\nMore information on our issue management policies can be found here: https://aka.ms/aspnet/issue-policies\r\n\r\nPlease keep in mind that the GitHub issue tracker is not intended as a general support forum, but for reporting **non-security** bugs and feature requests.\r\n\r\nIf you believe you have an issue that affects the SECURITY of the platform, please do NOT create an issue and instead email your issue details to secure@microsoft.com. Your report may be eligible for our [bug bounty](https://www.microsoft.com/en-us/msrc/bounty-dot-net-core) but ONLY if it is reported through email.\r\nFor other types of questions, consider using [StackOverflow](https://stackoverflow.com).\r\n\r\n--\u003e\r\n\r\n### Describe the bug\r\n无法通过TypeFilterAttribute的Arguments参数传递F#的Enum类型，看了下反编译的代码，和C#的枚举进行对比，发现F#的Enum类型会多两个特性  [CompilationMapping(SourceConstructFlags.ObjectType)]  [Serializable]，可能是由于这个原因导致无法传参\r\n\r\n相关代码如下\r\nAPI函数特性 [\u003cTypeFilter(typeof\u003cAuthorizeFilter\u003e, Arguments = [| UserCharacter.Admin |])\u003e]\r\nF#枚举定义 [\u003cFlags\u003e] type UserCharacter = Guest = 1 | Admin = 2 | User = 4\r\n授权筛选器定义 type AuthorizeFilter(user: User, weekly: WeeklyDbContext, character: UserCharacter) = interface IAuthorizationFilter with ……\r\n\r\n### To Reproduce\r\n\u003c!--\r\nWe ❤ code! Point us to a minimalistic repro project hosted in a GitHub repo.\r\nFor a repro project, create a new ASP.NET Core project using the template of your your choice, apply the minimum required code to result in the issue you\u0027re observing.\r\n\r\nWe will close this issue if:\r\n- the repro project you share with us is complex. We can\u0027t investigate custom projects, so don\u0027t point us to such, please.\r\n- if we will not be able to repro the behavior you\u0027re reporting\r\n--\u003e\r\n\r\n### Exceptions (if any)\r\nSystem.InvalidOperationException: A suitable constructor for type \u0027xxx.AuthorizeFilter\u0027 could not be located. Ensure the type is concrete and services are registered for all parameters of a public constructor.\r\n如果我将授权筛选器定义中的character参数类型改为int，则可以正常运行\r\n\r\n### Further technical details\r\n- ASP.NET Core version\r\n- Include the output of `dotnet --info`\r\n- The IDE (VS / VS Code/ VS4Mac) you\u0027re running on, and its version\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOLRWLDQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0Nzg4NzQzMg==",
                                           "createdAt":  "2020-12-18T06:00:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mkArtakMSFT",
                                           "body":  "#### Translated using Bing Traslator\r\n\r\n\r\n#### Describe the bug\r\nUnable to pass the Enum type of F# through the SharpeFilter Attribute parameter, look at the decompiled code and compare it with the enumeration of C#s, and find that the Enum type of F# is two more features\r\n\r\nThe code is as follows\r\nAPI function \u003c ( typeof, Arguments UserCharacter.Admin |]) \u003e]\r\nThe F# enumerumered definition is type UserCharacter , Guest , and 1 Admin = 2 |。 User = 4。\r\nAuthorization filter definition type AuthorizeFilter (user: User, Weekly: WeeklyDbContext, character: UserCharacter) . . . interface IAuthorityFilter with ...\r\n\r\n#### To Reproduce\r\n\r\n#### Exceptions (if any)\r\nSystem.InvalidOperationException: A suitable constructor for type \u0027xxx.AuthorizeFilter\u0027 could not be located. Ensure the type is concrete and services are registered for all parameters of a public constructor.\r\nIf I change the acter parameter type in the authorization filter definition to int, it works",
                                           "updatedAt":  "2020-12-18T06:01:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0ODIyNTY1Ng==",
                                           "createdAt":  "2020-12-18T17:43:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pranavkm",
                                           "body":  "Could you share a minimal app that reproduces the problem?",
                                           "updatedAt":  "2020-12-18T17:43:20Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0ODQwODA5NQ==",
                                           "createdAt":  "2020-12-19T02:46:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ly5222518000",
                                           "body":  "\u003e Could you share a minimal app that reproduces the problem?\r\nTks, here`s the demo.\r\n[TypeFilterAttributeTestDemo.zip](https://github.com/dotnet/aspnetcore/files/5718814/TypeFilterAttributeTestDemo.zip)\r\n",
                                           "updatedAt":  "2020-12-19T02:46:14Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc1NjM4NjU3Mw==",
                                           "createdAt":  "2021-01-07T21:10:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Dotnet-GitSync-Bot",
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-01-07T21:10:57Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "The Enum type of F# cannot be passed through the Arguments parameter of TypeFilterAttribute",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/48699",
        "createdAt":  "2021-02-24T13:09:45Z",
        "number":  48699,
        "author":  "eddynaka",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-07-06T05:52:39Z",
        "body":  "Hi,\r\n\r\ntoday I have the following code that is trying to identify if a dll is netframework/netcore/netstandard:\r\n```csharp\r\ninternal static ManagedPlatform ComputeIsDotNetCore(MetadataReader metadataReader)\r\n{\r\n    foreach (AssemblyReferenceHandle handle in metadataReader.AssemblyReferences)\r\n    {\r\n        AssemblyReference assemblyReference = metadataReader.GetAssemblyReference(handle);\r\n        StringHandle stringHandle = assemblyReference.Name;\r\n        string assemblyName = metadataReader.GetString(stringHandle);\r\n\r\n        switch (assemblyName)\r\n        {\r\n            case \"mscorlib\":\r\n            {\r\n                return ManagedPlatform.DotNetFramework;\r\n            }\r\n\r\n            case \"System.Runtime\":\r\n            {\r\n                return ManagedPlatform.DotNetCore;\r\n            }\r\n\r\n            case \"netstandard\":\r\n            {\r\n                return ManagedPlatform.DotNetStandard;\r\n            }\r\n\r\n            default:\r\n            {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    throw new InvalidOperationException(\"Could not identify managed platform.\");\r\n}\r\n```\r\n\r\nFor a few dlls generated in runtime linux, net5 and in obj/linked folder, i can\u0027t identify what type is it.\r\n\r\nAttached you can find a dll that was generated with those flags and I can\u0027t read anything that I could identify.\r\n[linked.zip](https://github.com/dotnet/runtime/files/6036122/linked.zip)\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOMVPzug==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NTA2MzQ5NA==",
                                           "createdAt":  "2021-02-24T13:09:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-02-24T13:09:48Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NTA2NDMwOQ==",
                                           "createdAt":  "2021-02-24T13:11:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "eddynaka",
                                           "body":  "@krwq , don\u0027t know if you know this or if you could point me to.\r\nthank you!",
                                           "updatedAt":  "2021-02-24T13:11:18Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NTA2ODYxMQ==",
                                           "createdAt":  "2021-02-24T13:18:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "alexrp",
                                           "body":  "You probably need to handle `System.Private.CoreLib` for your `DotNetCore` case. I would imagine (without checking) that some platform assemblies reference it directly rather than `System.Runtime`.",
                                           "updatedAt":  "2021-02-24T13:18:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NTA2OTU5OA==",
                                           "createdAt":  "2021-02-24T13:20:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "eddynaka",
                                           "body":  "Right. I saw that `CoreLib` was one of the hits, but I wasn\u0027t sure if that was a good check.",
                                           "updatedAt":  "2021-02-24T13:20:25Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NTA5NjkzNQ==",
                                           "createdAt":  "2021-02-24T14:02:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kevingosse",
                                           "body":  "I believe the most reliable way would be to check the value of the `TargetFramework` attribute, but I\u0027m not sure how to decode the value of the attribute from the MetadataReader:\r\n\r\n```csharp\r\n\r\nforeach (var handle in metadata.CustomAttributes)\r\n{\r\n    var attribute = metadata.GetCustomAttribute(handle);\r\n    var ctor = metadata.GetMemberReference((MemberReferenceHandle)attribute.Constructor);\r\n    var type = metadata.GetTypeReference((TypeReferenceHandle)ctor.Parent);\r\n    var typeName = metadata.GetString(type.Name);\r\n\r\n    if (typeName == \"TargetFrameworkAttribute\")\r\n    {\r\n        var bytes = metadata.GetBlobBytes(attribute.Value);\r\n\r\n        // ?\r\n    }\r\n}\r\n```",
                                           "updatedAt":  "2021-02-24T14:03:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NTg1MTMxNQ==",
                                           "createdAt":  "2021-02-25T12:12:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "krwq",
                                           "body":  "Usually you should design your app so that you depend on the information in the nuget package rather than dll but having said that I think checking assembly references + attributes is probably the best approach you can get from just DLL. Unfortunately I do not have a specific guidelines I can share, probably easiest is to create couple of test assemblies and compare with ILSpy or IL DASM.\r\n\r\nFor custom attributes and metadata reader in general it\u0027s best to refer to the ECMA-335 spec and then search for corresponding API, i.e.: `II.21` mentions the details. Also you can take a look at MetadtaReader tests, i.e. https://github.com/dotnet/runtime/blob/master/src/libraries/System.Reflection.Metadata/tests/Metadata/Decoding/CustomAttributeDecoderTests.cs - if you know specific attribute you\u0027re looking for then it should be much simpler to decode",
                                           "updatedAt":  "2021-02-25T12:19:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyNzU4NTQ2Ng==",
                                           "createdAt":  "2021-04-27T12:57:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "eddynaka",
                                           "body":  "Looking again at this, there are cases where either my approach or @kevingosse does not work.\r\nAlso tried to open in ILSpy and DotPeek.\r\nFor ILSpy it is showing as NET4.0 and for DotPeek NET4.8.\r\n\r\nexecuted the dumpbin to see if i can easily see something. but again, no clear information.",
                                           "updatedAt":  "2021-04-27T12:57:00Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "Is it possible to check if dll is netframework/netcore/netstandard using MetadataReader?",
        "labels":  [
                       "question",
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/57459",
        "createdAt":  "2021-08-16T01:31:33Z",
        "number":  57459,
        "author":  "mpolicki",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-08-18T16:03:47Z",
        "body":  "\u003c!--This is just a template - feel free to delete any and all of it and replace as appropriate.--\u003e\r\n\r\n### Description\r\n\r\nConsider the following program:\r\n```C#\r\n        static void Main(string[] args)\r\n        {\r\n            object o1 = new();\r\n            object o2 = new();\r\n            var a = (1, o1).CompareTo((0, o2));\r\n            Console.WriteLine(a);\r\n            // the following line throws System.ArgumentException: \u0027At least one object must implement IComparable.\u0027 from System.Collections.Comparer.Compare(object, object)\r\n            var b = (1, o1).CompareTo((1, o2));\r\n            Console.WriteLine(b);\r\n        }\r\n```\r\n\r\nThe behavior of `ValueTuple\u003cT1, T2, ...\u003e.CompareTo` is inconsistent because it throws only some of the time, depending on the contents of the tuple. Specifically, it throws when at least one `Item` in {`Item1`, `Item2`, ...} can not be compared by `System.Collections.Comparer` to objects of the same type, and all the preceding `Item`s compare as equal. This leads to a situation where apparently working code suddenly fails at run time.\r\n\r\nThere are two ways the behavior of `ValueTuple\u003cT1, T2, ...\u003e.CompareTo` can be made consistent:\r\n\r\n1. If at least one `Item` in {`Item1`, `Item2`, ...} can not be compared by `System.Collections.Comparer` to objects of the same type, throw `System.InvalidOperationException`.\r\n2. If all `Item`s in {`Item1`, `Item2`, ...} can not be compared by `System.Collections.Comparer` to objects of the same type (respectively), throw `System.InvalidOperationException`. Otherwise, compare as usual, ignoring those `Item`s that can\u0027t be compared.\r\n\r\nOption 1 is better than the current behavior because by throwing immediately, it alerts the programmer to the error immediately. The error doesn\u0027t happen unexpectedly at some point during run time.\r\n\r\nHowever, I prefer option 2, because it has the benefits of option 1, while also allowing for comparison of partially-comparable `ValueTuple`s. For example, you might have an array of `(int score, object something)` tuples that you want to sort by `score`.\r\n\r\n### Configuration\r\n\r\n.NET 5.0, Windows 10 x64\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHONZmbHg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc41mAPN",
                                           "createdAt":  "2021-08-16T01:31:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-08-16T01:31:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41mZse",
                                           "createdAt":  "2021-08-16T06:32:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "En3Tho",
                                           "body":  "I think this is actually a good candidate of a compile time analyzer. If comparison is going to throw anyway and the reason is known already at compile time then it should produce a warning",
                                           "updatedAt":  "2021-08-16T06:32:12Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "ValueTuple comparison is inconsistent",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/58040",
        "createdAt":  "2021-08-18T21:28:39Z",
        "number":  58040,
        "author":  "PathogenDavid",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCTdBjQ==",
                          "nodes":  [
                                        {
                                            "content":  "HOORAY",
                                            "user":  "Therzok",
                                            "createdAt":  "2021-08-19T05:11:24Z"
                                        },
                                        {
                                            "content":  "LAUGH",
                                            "user":  "Joe4evr",
                                            "createdAt":  "2021-08-26T03:02:05Z"
                                        },
                                        {
                                            "content":  "LAUGH",
                                            "user":  "SupinePandora43",
                                            "createdAt":  "2022-03-17T16:07:55Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2021-09-07T15:41:06Z",
        "body":  "(It could be argued this is the runtime\u0027s fault, but it\u0027s not clear to me where the fix would end up being -- assuming this should be fixed at all. I\u0027m 80% reporting this issue because this probably isn\u0027t the first time I\u0027ve done this and probably won\u0027t be the last and I need something that comes up when I search `CS0208`.)\r\n\r\n**Version Used**:\r\n\r\n* Compiler version: \u00274.0.0-3.21403.23 (d51d1a73)\u0027. Language version: preview.\r\n* Compiler version: \u00273.10.0-4.21310.5 (473e349f)\u0027. Language version: preview.\r\n* Compiler version: \u00274.0.0-3.21403.23 (d51d1a73)\u0027. Language version: 9.0.\r\n\r\n**Steps to Reproduce**:\r\n\r\n1. Create a new C# project\r\n2. Enable unsafe blocks\r\n3. Write `Span\u003cchar\u003e* elements = stackalloc Span\u003cchar\u003e[16];` somewhere in an unsafe context.\r\n4. Observe there is an error.\r\n5. Add the following to your csproj (substituting the path as appropriate):\r\n\r\n```xml\r\n  \u003cItemGroup\u003e\r\n    \u003cReference Include=\"C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\5.0.9\\System.*.dll\" /\u003e\r\n  \u003c/ItemGroup\u003e\r\n```\r\n\r\n**Expected Behavior**: A compiler error should occur:\r\n\r\n```\r\nerror CS0208: Cannot take the address of, get the size of, or declare a pointer to a managed type (\u0027Span\u003cchar\u003e\u0027)\r\n```\r\n\r\n**Actual Behavior**: Code compiles and runs just fine.\r\n\r\n# In other Roslyn-powered tools\r\n\r\nObviously the above `\u003cReference ...\u003e` item is extremely atypical of a modern .NET project, but what is more common is how this issue surfaces in various Roslyn-powered tools since they seem to love referencing the runtime assemblies directly.\r\n\r\nIf you [try the same on SharpLab](https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA+ABATARgLABQhGAzAATZkDChA3oWYxeQK4B2AzgIYBmMFKMgBUYHAC4AKAJQMm9Ak0VkAygAcubADxgAFlygA+AFRkYAGxgBbGGzEcyAXjLiuYANZczZiGBXqtuvoGANo4SAC6ANyyjAC+hLFAA) you will not experience a compiler error.\r\n\r\nSimilarly, it works in the C# Interactive in Visual Studio (in both 17.0.0p3.1 and 16.11.1):\r\n\r\n![image](https://user-images.githubusercontent.com/278957/129970271-75760d5c-f531-4492-b1f0-7162b11c2688.png)\r\n\r\nAs well as [CSharpRepl](https://github.com/waf/CSharpRepl):\r\n\r\n![image](https://user-images.githubusercontent.com/278957/129970411-293867d5-cfe4-4125-9c49-81b27f7face0.png)\r\n\r\n# The  underlying cause\r\n\r\nThe reason this happens is the actual implementation of `Span\u003cT\u003e` is technically unmanaged because it is just [a pair of `ByReference\u003cT\u003e` and `int`](https://github.com/dotnet/runtime/blob/60af14837e78d69d5469c2c0c7632cfca761aa09/src/libraries/System.Private.CoreLib/src/System/Span.cs#L25-L28). (The runtime has a special understanding of it, but as far as Roslyn is concerned `ByReference\u003cT\u003e` is [just a struct with a single `IntPtr` field](https://github.com/dotnet/runtime/blob/60af14837e78d69d5469c2c0c7632cfca761aa09/src/libraries/System.Private.CoreLib/src/System/ByReference.cs#L16).)\r\n\r\nThis is not normally an issue because generally speaking the compiler is invoked with the runtime\u0027s reference assemblies, and [the reference assembly](https://github.com/dotnet/runtime/blob/49c74eec151b84e96ac829bc10794a227c8c4733/src/libraries/System.Runtime/ref/System.Runtime.cs) replaces the `ByReference\u003cT\u003e` field with an `object` dummy. (My understanding is this is special-cased [here in `IsOrContainsReferenceType`](https://github.com/dotnet/buildtools/blob/09e023059fec39b92fa5c3b5090c59e4402e5840/src/Microsoft.Cci.Extensions/Extensions/CSharp/CSharpCciExtensions.cs#L135-L137) -- For context as to why private fields become dummies see https://github.com/dotnet/runtime/issues/16402.)\r\n\r\n# Possible fixes\r\n\r\n1. Roslyn should understand `System.ByReference\u003cT\u003e` to be `object`-like.\r\n2. Roslyn should understand that pointers to `System.Span\u003cT\u003e`, `System.ReadOnlySpan\u003cT\u003e`, and `System.TypeReference` shouldn\u0027t be possible.\r\n3. The runtime should modify `ByReference\u003cT\u003e` to use `object` instead of `IntPtr` for the placeholder field. (Although I imagine there\u0027s a reason it doesn\u0027t.)\r\n4. The runtime reference assembly should not use a dummy object field. (Probably not a good idea since you can use this to create non-obvious GC holes.)\r\n5. Roslyn should add the most obscure warning in existence in the next warning wave.\r\n6. Do nothing since technically all of the above would be a breaking change.\r\n7. All three of the above Roslyn-powered tools should stop compiling against the actual runtime assemblies.\r\n8. I should be banished to the shadow realm for attempting to `stackalloc` an array of spans. (I swear it was kosher in context!)\r\n\r\n(Personally I am partial to option 8.)",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHONe7RLQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc417tCw",
                                           "createdAt":  "2021-08-24T17:38:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jaredpar",
                                           "body":  "\u003e Obviously the above \u003cReference ...\u003e item is extremely atypical of a modern .NET project, but what is more common is how this issue surfaces in various Roslyn-powered tools since they seem to love referencing the runtime assemblies directly.\r\n\r\nIt\u0027s more than atypical though, it\u0027s generally not supported. The reference assemblies are meant for compiling .NET programs, not the runtime assemblies. Compiling against the runtime assemblies is subject to a number of different problems (including breaks between versions). \r\n\r\nIf the runtime team wants to support this then they need to change the definition such that `Span\u003cT\u003e` is recognized as a pointer illegal type. It\u0027s possible we end up agreeing that roslyn should just inherently recognize it as such but at the moment that is not the case. We depend on the runtime team to define the type in such a way that it\u0027s recognized as non-pointer legal.\r\n",
                                           "updatedAt":  "2021-08-24T17:38:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc417tEt",
                                           "createdAt":  "2021-08-24T17:39:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-08-24T17:39:03Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Roslyn allows pointers to `Span\u003cT\u003e` if runtime assemblies are referenced directly",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/59593",
        "createdAt":  "2021-09-25T01:57:48Z",
        "number":  59593,
        "author":  "acaly",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-07-19T20:59:34Z",
        "body":  "### Description\r\n\r\n`object` and `nint` should have identical size and alignement when used as fields. However, in some cases, changing an `object` field into `nint` changes the struct size. This problem is also related to other fields in the struct.\r\n\r\n```c#\r\npublic class Program\r\n{\r\n    [StructLayout(LayoutKind.Sequential)]\r\n    public struct Empty\r\n    {\r\n    }\r\n    [StructLayout(LayoutKind.Sequential)]\r\n    public struct WrappedPointer1\r\n    {\r\n        public nint Ptr;\r\n    }\r\n    [StructLayout(LayoutKind.Sequential)]\r\n    public struct WrappedPointer2\r\n    {\r\n        public object Ptr;\r\n    }\r\n    [StructLayout(LayoutKind.Sequential)]\r\n    public struct TestSize1 //16\r\n    {\r\n        public WrappedPointer1 A; //struct { nint }\r\n        public int B;\r\n        public Empty C;\r\n        public Empty D;\r\n    }\r\n    [StructLayout(LayoutKind.Sequential)]\r\n    public struct TestSize2 //32\r\n    {\r\n        public WrappedPointer2 A; //struct { object }\r\n        public int B;\r\n        public Empty C;\r\n        public Empty D;\r\n    }\r\n    [StructLayout(LayoutKind.Sequential)]\r\n    public struct TestSize3 //16\r\n    {\r\n        public WrappedPointer2 A; //struct { object }\r\n        public int B;\r\n        public byte C;\r\n        public byte D;\r\n    }\r\n    [StructLayout(LayoutKind.Sequential)]\r\n    public struct TestSize4 //32\r\n    {\r\n        public object A;\r\n        public int B;\r\n        public Empty C;\r\n        public Empty D;\r\n    }\r\n\r\n    public static unsafe void Main()\r\n    {\r\n        Console.WriteLine(Unsafe.SizeOf\u003cnint\u003e()); //8\r\n        Console.WriteLine(Unsafe.SizeOf\u003cWrappedPointer1\u003e()); //8\r\n        Console.WriteLine(Unsafe.SizeOf\u003cWrappedPointer2\u003e()); //8\r\n        Console.WriteLine(Unsafe.SizeOf\u003cTestSize1\u003e()); //16\r\n        Console.WriteLine(Unsafe.SizeOf\u003cTestSize2\u003e()); //32\r\n        Console.WriteLine(Unsafe.SizeOf\u003cTestSize3\u003e()); //16\r\n        Console.WriteLine(Unsafe.SizeOf\u003cTestSize4\u003e()); //32\r\n\r\n        Console.WriteLine();\r\n\r\n        TestSize1 t1 = default;\r\n        Console.WriteLine((nint)Unsafe.AsPointer(ref t1.A) - (nint)Unsafe.AsPointer(ref t1)); //0\r\n        Console.WriteLine((nint)Unsafe.AsPointer(ref t1.B) - (nint)Unsafe.AsPointer(ref t1)); //8\r\n        Console.WriteLine((nint)Unsafe.AsPointer(ref t1.C) - (nint)Unsafe.AsPointer(ref t1)); //12\r\n        Console.WriteLine((nint)Unsafe.AsPointer(ref t1.D) - (nint)Unsafe.AsPointer(ref t1)); //13\r\n\r\n        TestSize4 t4 = default;\r\n        Console.WriteLine((nint)Unsafe.AsPointer(ref t4.A) - (nint)Unsafe.AsPointer(ref t4)); //0\r\n        Console.WriteLine((nint)Unsafe.AsPointer(ref t4.B) - (nint)Unsafe.AsPointer(ref t4)); //8\r\n        Console.WriteLine((nint)Unsafe.AsPointer(ref t4.C) - (nint)Unsafe.AsPointer(ref t4)); //16\r\n        Console.WriteLine((nint)Unsafe.AsPointer(ref t4.D) - (nint)Unsafe.AsPointer(ref t4)); //24\r\n    }\r\n}\r\n```\r\n\r\nOn 64-bit platform, TestSize1-4 should all have the same size of 16 bytes (2 pointers), but some extend into 32 bytes.\r\n\r\n### Configuration\r\n\r\n\u003c!--\r\n* Which version of .NET is the code running on?\r\n* What OS and version, and what distro if applicable?\r\n* What is the architecture (x64, x86, ARM, ARM64)?\r\n* Do you know whether it is specific to that configuration?\r\n* If you\u0027re using Blazor, which web browser(s) do you see this issue in?\r\n  --\u003e\r\nWindows 10.0.19043.1165 (21H1/May2021Update)\r\nIntel Core i7-7700HQ CPU 2.80GHz (Kaby Lake), 1 CPU, 8 logical and 4 physical cores\r\n.NET SDK=6.0.100-preview.7.21379.14\r\n\r\n### Regression?\r\n\r\n.NET 5 shows the same results.\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHORub-Nw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc43QMxI",
                                           "createdAt":  "2021-09-25T01:57:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-09-25T01:57:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43QunW",
                                           "createdAt":  "2021-09-25T14:51:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "`nint` and `object` are both 4 or 8 bytes, but they are not considered equivalent or interchangeable. In particular, `nint` is a blittable primitive type, it is simply a pointer-sized integer. `object` on the other hand is a managed (GC tracked) reference, it is not considered blittable.\r\n\r\nThe [remarks](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.structlayoutattribute?view=net-5.0#remarks) section of the `StructLayoutAttribute` covers this scenario and elaborates that `LayoutKind.Sequential` only controls the layout for managed memory if the type is considered blittable. For non-blittable types (such as `object`, `string`, `T[]`, `bool`, sometimes `char`, and others), instead it only controls the layout when the class or structure is marshaled to unmanaged code (and therefore what `Marshal.SizeOf` will return), it does not control the layout of the class or structure in managed memory (and therefore what `Unsafe.SizeOf` will return).\r\n\r\nYou can use `LayoutKind.Explicit` to control the layout of memory for non-blittable types, but there are rules about `managed references` and other types overlapping and potentially other quirks since these types are `variable` sized.\r\n",
                                           "updatedAt":  "2021-09-25T14:51:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43QzBq",
                                           "createdAt":  "2021-09-25T16:48:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "In particular, the managed layout for nested value type fields looks to force an alignment of `TARGET_POINTER_SIZE`: https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/methodtablebuilder.cpp#L8184-L8194\r\n```cpp\r\n#if !defined(TARGET_64BIT) \u0026\u0026 (DATA_ALIGNMENT \u003e 4)\r\n                dwCumulativeInstanceFieldPos = (DWORD)ALIGN_UP(dwCumulativeInstanceFieldPos,\r\n                    (pByValueMT-\u003eGetNumInstanceFieldBytes() \u003e= DATA_ALIGNMENT) ? DATA_ALIGNMENT : TARGET_POINTER_SIZE);\r\n#else // !(!defined(TARGET_64BIT) \u0026\u0026 (DATA_ALIGNMENT \u003e 4))\r\n#ifdef FEATURE_64BIT_ALIGNMENT\r\n                if (pByValueMT-\u003eRequiresAlign8())\r\n                    dwCumulativeInstanceFieldPos = (DWORD)ALIGN_UP(dwCumulativeInstanceFieldPos, 8);\r\n                else\r\n#endif // FEATURE_64BIT_ALIGNMENT\r\n                    dwCumulativeInstanceFieldPos = (DWORD)ALIGN_UP(dwCumulativeInstanceFieldPos, TARGET_POINTER_SIZE);\r\n#endif // !(!defined(TARGET_64BIT) \u0026\u0026 (DATA_ALIGNMENT \u003e 4))\r\n```\r\n\r\n@jkotas, do you know why we do this rather than looking up the `EEClassLayoutInfo` from the `MethodTable*` (assuming `HasLayout()` returns `true`) and getting the computed alignment required (which already should have taken managed reference requirements into account)?",
                                           "updatedAt":  "2021-09-25T16:48:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43Q0mU",
                                           "createdAt":  "2021-09-25T17:36:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOB7xUbg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tannergooding",
                                                                               "createdAt":  "2021-09-25T18:03:26Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "acaly",
                                                                               "createdAt":  "2021-09-25T21:38:59Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "jkotas",
                                           "body":  "This looks similar to #12977.\r\n\r\nThe field layout has number of corner cases that are either inefficient or too complex for no good reason. \r\n\r\n@trylek tried to clean it up in #51416, but we run out of time. If you touch field layout, a lot of random things start falling apart. I hope we will get it done in .NET 7.",
                                           "updatedAt":  "2021-09-25T17:36:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5G4vtd",
                                           "createdAt":  "2022-07-19T16:15:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "@trylek @jkoritzinsky assume this is fixed as part of the type layout work in 7? ",
                                           "updatedAt":  "2022-07-19T16:15:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5G5ln-",
                                           "createdAt":  "2022-07-19T20:05:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "This has been mitigated as part of the layout work, but it hasn\u0027t entirely been fixed.\r\n\r\nHere\u0027s the report from ObjectLayoutInspector from Preview 6:\r\n\r\n\u003cdetails\u003e\r\n\u003csummary\u003eDetails\u003c/summary\u003e\r\n\r\n```\r\nType layout for \u0027TestSize1\u0027\r\nSize: 16 bytes. Paddings: 2 bytes (%12 of empty space)\r\n|====================================|\r\n|   0-7: WrappedPointer1 A (8 bytes) |\r\n| |=============================|    |\r\n| |   0-7: IntPtr Ptr (8 bytes) |    |\r\n| |=============================|    |\r\n|------------------------------------|\r\n|  8-11: Int32 B (4 bytes)           |\r\n|------------------------------------|\r\n|    12: Empty C (1 byte)            |\r\n|------------------------------------|\r\n|    13: Empty D (1 byte)            |\r\n|------------------------------------|\r\n| 14-15: padding (2 bytes)           |\r\n|====================================|\r\n\r\n\r\nType layout for \u0027TestSize2\u0027\r\nSize: 24 bytes. Paddings: 10 bytes (%41 of empty space)\r\n|====================================|\r\n|   0-3: Int32 B (4 bytes)           |\r\n|------------------------------------|\r\n|   4-7: padding (4 bytes)           |\r\n|------------------------------------|\r\n|  8-15: WrappedPointer2 A (8 bytes) |\r\n| |=============================|    |\r\n| |   0-7: Object Ptr (8 bytes) |    |\r\n| |=============================|    |\r\n|------------------------------------|\r\n|    16: Empty C (1 byte)            |\r\n|------------------------------------|\r\n|    17: Empty D (1 byte)            |\r\n|------------------------------------|\r\n| 18-23: padding (6 bytes)           |\r\n|====================================|\r\n\r\n\r\nType layout for \u0027TestSize3\u0027\r\nSize: 16 bytes. Paddings: 2 bytes (%12 of empty space)\r\n|====================================|\r\n|   0-3: Int32 B (4 bytes)           |\r\n|------------------------------------|\r\n|     4: Byte C (1 byte)             |\r\n|------------------------------------|\r\n|     5: Byte D (1 byte)             |\r\n|------------------------------------|\r\n|   6-7: padding (2 bytes)           |\r\n|------------------------------------|\r\n|  8-15: WrappedPointer2 A (8 bytes) |\r\n| |=============================|    |\r\n| |   0-7: Object Ptr (8 bytes) |    |\r\n| |=============================|    |\r\n|====================================|\r\n\r\n\r\nType layout for \u0027TestSize4\u0027\r\nSize: 16 bytes. Paddings: 2 bytes (%12 of empty space)\r\n|===========================|\r\n|   0-7: Object A (8 bytes) |\r\n|---------------------------|\r\n|  8-11: Int32 B (4 bytes)  |\r\n|---------------------------|\r\n|    12: Empty C (1 byte)   |\r\n|---------------------------|\r\n|    13: Empty D (1 byte)   |\r\n|---------------------------|\r\n| 14-15: padding (2 bytes)  |\r\n|===========================|\r\n```\r\n\r\n\u003c/details\u003e\r\n\r\nAs you can see, TestSize4 is now 16 bytes, and TestSize2 has shrunk to 24 bytes. TestSize2 is still 24 bytes because of how the auto-layout algorithm handles non-primitive struct types. The auto-layout algorithm always handles non-primitive value types last and places them in metadata order at the end of the structure. This results in the TestSize2 struct being larger because even empty structs are 1 byte wide, so there ends up being quite a bit of padding at the end of the structure to meet the alignment requirements in arrays.\r\n\r\nChanging how the auto-layout algorithm handles value types of small sizes is likely a larger change (and more of a feature than a bug), so I don\u0027t know if we should try to fix this in .NET 7 given how late we are in the release.",
                                           "updatedAt":  "2022-07-19T20:05:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5G5ngS",
                                           "createdAt":  "2022-07-19T20:14:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "trylek",
                                           "body":  "While @jkotas previously suggested we should strive to fix as many issues of this type as we can in .NET 7, changing the auto layout now sounds pretty scary to me (not mentioning it\u0027s a coordinated change between CoreCLR runtime and Crossgen2 that also requires bumping up Crossgen2 major version).",
                                           "updatedAt":  "2022-07-19T20:14:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5G5v43",
                                           "createdAt":  "2022-07-19T20:58:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCngPDA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkoritzinsky",
                                                                               "createdAt":  "2022-07-19T21:19:13Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "I agree that this looks like a feature, not a bug fix. We can get to it during the next field layout overhaul.",
                                           "updatedAt":  "2022-07-19T20:58:10Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Unnecessary padding in struct field auto layout",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/61124",
        "createdAt":  "2021-11-02T21:17:21Z",
        "number":  61124,
        "author":  "bernd5",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-07-06T17:10:55Z",
        "body":  "### Description\n\nThe roslyn team recently fixed the following issue: https://github.com/dotnet/roslyn/issues/43680\r\n\r\nConsider the following code:\r\n\r\n```CSharp\r\nusing System;\r\n\r\nnamespace ProtectedInterfaceMember\r\n{\r\n    interface ISomething\r\n    {\r\n        protected void DoInternal()\r\n        {\r\n            Console.WriteLine(\"Do something which can be changed\");\r\n        }\r\n\r\n        void Do()\r\n        {\r\n            DoInternal();\r\n        }\r\n    }\r\n\r\n    public class App : ISomething\r\n    {\r\n        public void DoInternal()\r\n        {\r\n            Console.WriteLine(\"This has nothing to do with ISomething\");\r\n        }\r\n\r\n        public static void Main()\r\n        {\r\n            ISomething app = new App();\r\n            app.Do();\r\n        }\r\n    }\r\n}\r\n```\r\n\n\n### Reproduction Steps\n\nCompile the code\n\n### Expected behavior\n\nThe app should print:\r\n\r\n```\r\nDo something which can be changed\r\n```\r\n\r\nbecause `App.DoInternal()` is no interface override / implementation of `ISomething.DoInternal()` - this requires an explicit interface implementation.\r\n\r\nSee: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-04-18.md#dim-implementing-a-non-public-interface-member-not-in-list\r\nSee: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#overriding-non-public-interface-members-closed\n\n### Actual behavior\n\nThe app prints:\r\n\r\n```\r\nThis has nothing to do with ISomething\r\n```\n\n### Regression?\n\nNo\n\n### Known Workarounds\n\nNo workaround known\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOOU6lSw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc45HJFq",
                                           "createdAt":  "2021-11-02T21:17:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-11-02T21:17:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc45TmPE",
                                           "createdAt":  "2021-11-04T21:25:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "I don\u0027t recall these details as they happened before my involvement in the default interface method feature, but FWIW, Roslyn also thinks these are related. If you put this snippet into Visual Studio and do a rename of `App.DoInternal`, it will also rename the interface method. Also notice that `App.DoInternal` is virtual (even though you didn\u0027t make it virtual in the C# source code). This is Roslyn promoting the method to a virtual one so that it can implement the interface method. If Roslyn didn\u0027t make it virtual, the runtime wouldn\u0027t consider it an implementation either.",
                                           "updatedAt":  "2021-11-04T21:25:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc45TqVL",
                                           "createdAt":  "2021-11-04T21:46:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bernd5",
                                           "body":  "Oh, you are right. The IL (implicit `final` `virtual`) and IDE behaviour is still buggy - not spec conformant. I\u0027ll reopen the ticket in the roslyn repo.\r\nBut nevertheless the behaviour in the runtime should be fixed, too.",
                                           "updatedAt":  "2021-11-04T22:16:19Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Invalid override of protected interface member via regular puplic member",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/63005",
        "createdAt":  "2021-12-20T09:02:48Z",
        "number":  63005,
        "author":  "MihaZupan",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-07-06T17:59:00Z",
        "body":  "Consider the following type definitions:\r\n```c#\r\npublic abstract class Base1\r\n{\r\n    private object _object;\r\n    private byte _byte;\r\n}\r\npublic abstract class Base2\r\n{\r\n    private WrappedObject _object;\r\n    private byte _byte;\r\n\r\n    private struct WrappedObject\r\n    {\r\n        private object _object;\r\n    }\r\n}\r\n\r\npublic sealed class Derived1 : Base1\r\n{\r\n    private byte _byte;\r\n}\r\npublic sealed class Derived2 : Base2\r\n{\r\n    private byte _byte;\r\n}\r\n```\r\n\r\n`Derived1` will group the two `byte` fields together with 6 bytes of padding.\r\n`Derived2` will store the two `byte` fields separately and add 7 bytes of padding after each one.\r\nAs a result, `Derived1` takes up 16 bytes (after the header and MT), but `Derived2` takes up 24.\r\n\r\n![image](https://user-images.githubusercontent.com/25307628/146739199-ac6a57cb-4519-48cf-9407-d35fbb1fa0e8.png)\r\n![image](https://user-images.githubusercontent.com/25307628/146739294-56e3c4ad-3c96-4ac0-97c4-2834346d5bef.png)\r\n\r\nIs such a layout intentional, or just a random inefficiency?\r\n\r\nHit in #62981",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOO4s_Vg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc47eBy7",
                                           "createdAt":  "2021-12-20T09:02:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-12-20T09:02:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc47iz9W",
                                           "createdAt":  "2021-12-21T17:56:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "This layout (at least as of writing this response) is intentional. The auto-layout algorithm places primitive and ref (object or class-types) fields first and user-defined value types last, which is why you see WrappedObject after the padding in Derived2. There’s also a mechanism for derived types to place small primitive fields in any trailing padding in the base type, which is what you see happening in the Derived1 case.\r\n\r\nThis is something that can be improved on, it just takes a bit of work (and can only be done when we take an R2R breaking change, so either some time in the next few months or after .NET 7).",
                                           "updatedAt":  "2021-12-21T17:56:42Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Suboptimal field layout when an object is wrapped in a struct",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/63891",
        "createdAt":  "2022-01-17T16:39:49Z",
        "number":  63891,
        "author":  "hez2010",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-01-18T23:58:06Z",
        "body":  "\u003e The syntax is a relatively easy part ( _relatively_ ;-)  - compared to the runtime part). \r\n\u003e Roslyn has a long history mapping nice syntax to underlying types - nullable, tuples, arrays, delegates, even primitive types like `int`. \r\n\u003e \r\n\u003e It is work in progress (https://github.com/dotnet/roslyn/pull/57286)\r\n\u003e \r\n\u003e It would allow syntax like:\r\n\u003e ![image](https://user-images.githubusercontent.com/8218165/137828799-44ca6e46-0270-4d48-b830-2620bdcf666d.png)\r\n\u003e \r\n\u003e The tooltips reveal the underlying type, but will show `int[4]` too, eventually....\r\n\u003e \r\n\u003e _Originally posted by @VSadov in https://github.com/dotnet/runtime/issues/60519#issuecomment-946292361_\r\n\r\nInstead of using `ValueArray\u003cint, object[,,,]\u003e` and use the rank of the array type, how about introducing `Zero` and `Succ\u003c\u003e` types?\r\n\r\nSo a fixed value array with 4 elements can be represented with `ValueArray\u003cint, Succ\u003cSucc\u003cSucc\u003cSucc\u003cZero\u003e\u003e\u003e\u003e\u003e`. \r\nThe runtime can treat the `Zero` and `Succ\u003c\u003e` types as generic value specialization instead of only making the `ValueArray` type special.\r\nAlso, if users want to use negative numbers for generic value specialization, a type `Prev\u003c\u003e` can also be introduced, i.e. use `Prev\u003cZero\u003e` to represent `-1`.\r\n\r\nAlthough, the best way is to extend IL and support const generics via allowing const value as type parameter.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOUzkQGA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc48e3J4",
                                           "createdAt":  "2022-01-17T16:39:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-01-17T16:39:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48fPFB",
                                           "createdAt":  "2022-01-17T19:06:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "I am not familiar with `ValueArray\u003c..\u003e`. @VSadov do you have context?",
                                           "updatedAt":  "2022-01-17T19:06:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48hee9",
                                           "createdAt":  "2022-01-18T13:23:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "Recursion is not idea and can easily cause stack overflow.\r\nI remember CLR limits array rank to 32 since 2 in each dimension results in 2^32 elements.",
                                           "updatedAt":  "2022-01-18T13:23:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48iAc1",
                                           "createdAt":  "2022-01-18T15:51:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "The alternative design paragraph of https://github.com/dotnet/runtime/issues/61135 talks about this. \r\n\r\nThe hacky encoding of an integer constant explored during hackthon was using magic array type. Hacky encoding of an integer constant using magic generic `Succ` type is not really different.",
                                           "updatedAt":  "2022-01-18T15:51:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TORAY",
                                           "createdAt":  "2023-01-18T23:58:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "VSadov",
                                           "body":  "This is not much different from using a C# tuple type as the Size marker and treating the tuple length as the length of the inline array (tuple approach was considered, but MD arrays won as more compact). \r\n\r\nThe main difference is that the dimension of an array is already an integer in the description of the type and thus using it to encode fixed array length is cheap `O(1)` to the length of the array. Expressing the length via a *shape* of a type can\u0027t be better than that.  C# Tuple types, for example, have linear encoding. An arbitrary tuple type requires `O(Length)` underlying type instantiations.  \r\nIt is possible to come up with more compact structural length encodings, but that would still be worse than `O(1)` solution.",
                                           "updatedAt":  "2023-01-18T23:58:06Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "An alternative to ValueArray consideration",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/72334",
        "createdAt":  "2022-07-17T06:08:07Z",
        "number":  72334,
        "author":  "nathan-chappell",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-07-25T15:17:35Z",
        "body":  "### Description\n\nWhen types are loaded, they are associated with a namespace via the metadata (*Namespace* column in the *TypeDef* table).  This namespace is used for creating entries in hash tables used by reflection in methods like `Type.GetType`.  However, when types are searched for by name, their namespace is parsed from the name (generally in the obvious way, `ns::FindSep` is where the logic is).  The can lead to incorrect behavior if the namespace of the name was not specified in the metadata.  Note that ECMA-335 states that:\r\n\r\n\u003e **II.6** While some programming languages introduce the concept of a namespace, the only support in the CLI\r\nfor this concept is as a metadata encoding technique. Type names are always specified by their full\r\nname relative to the assembly in which they are defined.\r\n\r\nThis is described in a few different ways in the definition of the metadata, but nowhere does it state that the namespace shall be the longest prefix until `\u0027.\u0027`.\n\n### Reproduction Steps\n\nMake a `.dll` where types have namespaces, then remove the namespace association from the metadata and try to use `Type.GetType` to retrieve the value.\n\n### Expected behavior\n\nHonestly, I didn\u0027t really have expectations.  I discovered this inconsistency while troubleshooting an obfuscator.\r\n\r\nThis is such corner case, I don\u0027t think it\u0027s worth changing any code over, but I think that I would expect the fact that namespaces are semantically relevant to reflection to be documented.  We could have a small section in [ECMA-335 Augments](https://github.com/dotnet/runtime/blob/main/docs/design/specs/Ecma-335-Augments.md) that states that namespaces are used for performance reasons in Reflection and therefore must be correct.\n\n### Actual behavior\n\nNamespaces are used inconsistently.\n\n### Regression?\n\nDon\u0027t know.\n\n### Known Workarounds\n\nEither don\u0027t use `\u0027.\u0027` in your names (i.e. the obfuscator doesn\u0027t use those in obfuscated names), or include correct namespace information, or don\u0027t use reflection.\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHORrlNqA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5Gtz81",
                                           "createdAt":  "2022-07-17T06:08:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-07-17T06:08:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Gt-Mk",
                                           "createdAt":  "2022-07-17T09:19:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "svick",
                                           "body":  "I don\u0027t understand where the inconsistency is. If you change the metadata from e.g. `TypeNamespace=\"NS\", TypeName=\"T\"` to `TypeNamespace=null, TypeName=\"T\"`, then you\u0027re effectively changing the name from `NS.T` to `T`, so it\u0027s expected that the behavior changes.\r\n\r\nOr are you talking about changing the metadata to `TypeNamespace=null, TypeName=\"NS.T\"`?",
                                           "updatedAt":  "2022-07-17T09:19:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GuBzF",
                                           "createdAt":  "2022-07-17T10:21:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "nathan-chappell",
                                           "body":  "The second one, where the possibility for an inconsistency exists.  Reflection does not properly handle a name like `TypeNamespace=null, TypeName=\"NS.T\"`.",
                                           "updatedAt":  "2022-07-17T10:21:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GuREW",
                                           "createdAt":  "2022-07-17T14:25:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCnE5fQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nathan-chappell",
                                                                               "createdAt":  "2022-07-17T15:34:09Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "svick",
                                           "body":  "@nathan-chappell It seems you are right.\r\n\r\nWhen I compile a trivial library:\r\n\r\n```c#\r\nnamespace NS;\r\n\r\npublic class T {}\r\n```\r\n\r\nThen modify it using Mono Cecil and load it, I get inconsistent results:\r\n\r\n```c#\r\nusing System;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing System.Reflection;\r\nusing Mono.Cecil;\r\n\r\nstring path = @\"..\\lib\\bin\\Debug\\net6.0\\lib.dll\";\r\nstring path2 = @\"..\\lib\\bin\\Debug\\net6.0\\lib2.dll\";\r\n\r\nusing var adef = AssemblyDefinition.ReadAssembly(path);\r\nvar t = adef.MainModule.GetType(\"NS.T\");\r\nt.Namespace = null;\r\nt.Name = \"NS.T\";\r\n\r\nadef.Write(path2);\r\n\r\nvar a = Assembly.LoadFile(Path.GetFullPath(path2));\r\nConsole.WriteLine(a.GetType(\"NS.T\") is null); // True\r\nConsole.WriteLine(a.GetExportedTypes().Single()); // NS.T\r\n```",
                                           "updatedAt":  "2022-07-17T14:25:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GuU2o",
                                           "createdAt":  "2022-07-17T15:37:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "nathan-chappell",
                                           "body":  "@svick Thanks for the repro and elaboration. If it would be helpful to you guys I could look into some fix, or propose an addendum to the documentation.",
                                           "updatedAt":  "2022-07-17T15:37:20Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "Namespaces determined from Metadata during load, parsed from name during query.",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/76300",
        "createdAt":  "2022-09-28T11:28:44Z",
        "number":  76300,
        "author":  null,
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-10-11T17:49:59Z",
        "body":  "### Description\r\n\r\nThe GetEnumUnderlyingType() throws a System.ExecutionEngineException when I attempt to apply it to a generic type parameter, which is constrained to System.Enum.\r\n\r\nI cannot catch this exception in application code.\r\n\r\n### Reproduction Steps\r\n\r\nThis example code can be used to reproduce the problem.\r\n\r\n```csharp\r\nnamespace Example;\r\n\r\npublic class Example\u003cT\u003e where T : Enum\r\n{\r\n}\r\n\r\ninternal class Program\r\n{\r\n    static void Main()\r\n    {\r\n        Type type = typeof(Example\u003c\u003e).GetGenericArguments()[0].GetEnumUnderlyingType();\r\n    }\r\n}\r\n```\r\n\r\n### Expected behavior\r\n\r\nI\u0027m not actually sure, since it is not specifically documented.\r\n\r\nRegardless of whether this operation makes sense, I would expect any exception to be catchable.\r\n\r\n### Actual behavior\r\n\r\nSystem.ExecutionEngineException: \u0027Exception of type \u0027System.ExecutionEngineException\u0027 was thrown.\u0027\r\n\r\nUnfortunately, the stack trace is empty.\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\n- .NET 6 SDK 6.0.401\r\n- Windows 10 Enterprise (10.0.19044.2006)\r\n- x64\r\n- Microsoft Visual Studio Enterprise 2022 (64-bit) Version 17.3.4\r\n\r\n### Other information\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOS0H7qw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5LJcl_",
                                           "createdAt":  "2022-09-28T11:28:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-09-28T11:28:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5LJr4A",
                                           "createdAt":  "2022-09-28T12:27:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "Can repro it on .NET 6.0 but it doesn\u0027t reproduce with .NET 7.0\r\n",
                                           "updatedAt":  "2022-09-28T12:27:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5LKL65",
                                           "createdAt":  "2022-09-28T14:00:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "aromaa",
                                           "body":  "Dupe of #71884",
                                           "updatedAt":  "2022-09-28T14:00:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5LL6h_",
                                           "createdAt":  "2022-09-28T20:10:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Sorry about that - I did have a good search first but for some reason didn’t see this.",
                                           "updatedAt":  "2022-09-28T20:10:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5LQfur",
                                           "createdAt":  "2022-09-29T17:51:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "deeprobin",
                                           "body":  "@EgorBo Wouldn\u0027t it make sense to make a backport here?",
                                           "updatedAt":  "2022-09-29T17:51:51Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "GetEnumUnderlyingType() throws System.ExecutionEngineException for a System.Enum constrained generic type parameter",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/79927",
        "createdAt":  "2022-12-23T09:13:16Z",
        "number":  79927,
        "author":  "zvrba",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-07-24T18:40:33Z",
        "body":  "Please see the following repo for code, measurements and initial analysis: https://github.com/zvrba/Pfm\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOUU2gYQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5RSWkg",
                                           "createdAt":  "2022-12-23T09:13:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-12-23T09:13:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RTDWu",
                                           "createdAt":  "2022-12-23T13:21:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gfoidl",
                                           "body":  "The handling of generics didn\u0027t change with the introduction of static abstract interfaces.\r\nThis means for reference types a shared generic is created, whilst for value types the JIT creates dedicated code for that specific type, so it is able to apply more optimizations.\r\n\r\nSo your culprit lies [in the use of generics](https://github.com/zvrba/Pfm/blob/6651881604d6b981ff4f391b0fe6cfe02c8904c0/Pfm.Collections/IntrusiveTree/AbstractTree.cs#L12). It\u0027s not a normal static method that gets called, rather one of a shared generic. That perf is worse in this case I\u0027d say is by design.",
                                           "updatedAt":  "2022-12-23T13:21:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RTaBh",
                                           "createdAt":  "2022-12-23T15:24:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "zvrba",
                                           "body":  "So you\u0027re basically saying that today it\u0027s not possible to write highly performant generic code (think tight loops) that takes reference types as arguments? Devirtualization, inlining, etc., just never gets the opportunity to kick in?\r\n\r\n\u003e It\u0027s not a normal static method that gets called, rather one of a shared generic. That perf is worse in this case I\u0027d say is by design.\r\n\r\nYes. In retrospect, it matches how generics are implemented otherwise, though I find it unintuitive because interface methods are invoked on a known concrete type, so there\u0027s no need to go through virtual dispatch.\r\n\r\nAs for `DelegateFinder`: would performance be better if `struct NodeTraits` were replaced with \r\n```\r\ninterface INodeTraits\u003cTImpl, TNode\u003e where TImpl : struct, INodeTraits\u003cTImpl, TNode\u003e\r\n{\r\n  abstract static TNode Create();\r\n  abstract static TNode L(Tnode n);\r\n  ...\r\n}\r\n```\r\n\r\nand is there a performance-wise difference between the above and\r\n\r\n```\r\ninterface INodeTraits\u003cTImpl\u003e where TImpl : struct, INodeTraits\u003cTImpl\u003e\r\n{\r\n  abstract static TNode Create\u003cTNode\u003e();\r\n  abstract static TNode L\u003cTNode\u003e(TNode n);\r\n  ...\r\n}\r\n```\r\n\r\n---\r\n\r\nAre there any future plans for JIT to support emitting specialized methods also for reference generics like in my example? That could bring performance of the generated code to match C++. Specialization could possibly applied only to types flagged with some attribute, to avoid the code bloat that C++ templates usually cause. (Bloat being somewhat reduced by link-time optimizer merging identical code sections.)\r\n\r\nEDIT: I mean, I could use a source generator to generate specialized sealed classes for every combination of generic arguments, but that feels like an error-prone hack that belongs more to JIT.\r\n\r\n---\r\n\r\nPS: Thanks for any answers. I\u0027m exploring the limits of C# and am excited by the new \"abstract statics\" features because it enables new kinds of designs, also ones that are common in C++ and used in C++ for performance reasons (also known as \"static polymorphism\"). Making a library of customizbable data structures is a nice test-bed for the feature.\r\n",
                                           "updatedAt":  "2022-12-23T15:32:21Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Disappointing performance of abstract static interface methods",
        "labels":  [
                       "tenet-performance",
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/80315",
        "createdAt":  "2023-01-06T22:09:10Z",
        "number":  80315,
        "author":  "risc26z",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-07-24T18:40:10Z",
        "body":  "I don\u0027t feel that I\u0027m sufficiently familiar with the implementation of the runtime to make a full API suggestion, but I wonder if the following performance feature might be possible?\r\n\r\nMany data types logically contain a single array that\u0027s fixed in size at new() time.  However, there is a potential performance issue where a ref type contains a ref to an array.  It can also be memory footprint issue, especially when there are lots of small arrays.   Probably the most common situation where I feel the following would be of benefit is in the implementation of custom string-like types, such as those with cached hash values or non-UTF16 encodings, but other cases might include various buffers, immutable arbitrary-precision numeric types, runtime-generated lookup tables, etc. \r\n\r\nThe common C/C++ idiom in these cases is attaching an inline array to the \u0027tail\u0027 of an object, thus saving an extra allocation \u0026 pointer dereference.  So I wonder, would it be possible to be able to have a \u0027magic\u0027 generic base class, with runtime support, which could be used like this:\r\n\r\n```csharp\r\nclass ByteString : System.TailArray\u003cbyte\u003e\r\n{\r\n    private int randomField1;\r\n    private int randomField2;\r\n    public ByteString([TailArrayLength] int size) { }\r\n    // and perhaps, to save a wasted memzero() in some cases\r\n    public ByteString([TailArraySource] Span\u003cbyte\u003e copyFrom) { }\r\n    // example of accessing the tail array\r\n    public GetNthPlusOneByte(int offset) =\u003e GetTailArraySpan()[offset + 1];\r\n}\r\n```\r\n\r\nWhere the details of the implementation are hidden, even from reflection, and would only be accessible via one or more GetTailArraySpan accessors?  (These would be \u0027protected\u0027 to allow users to fully control the external interface.)  I figure that the TailArrayLength, etc, attributes would be needed as the runtime would need to know the object\u0027s size before the constructor is called.\r\n\r\nMy thinking is that much of this functionality must already exists inside the runtime, since arrays and strings are special cases of tail arrays.  Indeed, those types could, at least in principle, be rebuilt on top of this API.  It\u0027s just a case of making the existing functionality slightly more general, and exposing it via an interface.  But I\u0027m sure those more familiar with the code would have a better understanding of what would be involved.\r\n\r\nOn a related note, please see #61135 concerning inline array attributes.  This is a somewhat different proposal as there would only be a single array, and it wouldn\u0027t exist as a user-visible field but would instead remain internal to the runtime.  (If reflection could \"see\" an array, things would get very complicated and error-prone, I fear.)",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOUhH18w==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5R6IEs",
                                           "createdAt":  "2023-01-06T22:09:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2023-01-06T22:09:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5R6J6A",
                                           "createdAt":  "2023-01-06T22:18:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCyP9tQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Joe4evr",
                                                                               "createdAt":  "2023-01-07T07:18:52Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "\u003e Where the details of the implementation are hidden, even from reflection\r\n\r\nReflection can call other unsafe code, create an instance of such an interface, and a whole bunch of other fun things.  You might want to hide it from a debugger (there are attributes explicitly for this purpose), but hiding it from determined access attempts is nigh impossible (if nothing else, you can inspect the generated il).  What are you attempting to prevent with this statement?",
                                           "updatedAt":  "2023-01-06T22:18:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5R69Zz",
                                           "createdAt":  "2023-01-07T08:01:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "risc26z",
                                           "body":  "\u003e [...] hiding it from determined access attempts is nigh impossible (if nothing else, you can inspect the generated il). What are you attempting to prevent with this statement?\r\n\r\nVery good point.  I was just concerned about having a T[] field in there that _looks_ like a reference type but _behaves_ like a variably-sized value type with an intimate relationship to its enclosing ref type.  But if it turns out to be better to have a special private or protected field in there, it would work just as well as a building block.",
                                           "updatedAt":  "2023-01-07T08:01:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5R7aXp",
                                           "createdAt":  "2023-01-07T16:13:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "Such memory would most likely be exposed as a span instead of an array.",
                                           "updatedAt":  "2023-01-07T16:13:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5SEfXz",
                                           "createdAt":  "2023-01-10T08:40:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "risc26z",
                                           "body":  "I\u0027ve written a very rough benchmark to give an approximate idea of what improvements might be expected.  It generates a million objects with normal arrays and, separately, with 8-byte \u0027tail arrays\u0027, and increments the first element of each object\u0027s array.  Tail arrays are simulated with an unused length field (an int), and the payload uses C#\u0027s \u0027fixed\u0027 array notation.  This doesn\u0027t do bounds checking, so the difference in \u0027UseObjects...\u0027 may be exaggerated.\r\n\r\n|                Method |       Mean |     Error |    StdDev |      Gen0 |      Gen1 |      Gen2 |  Allocated |\r\n|---------------------- |-----------:|----------:|----------:|----------:|----------:|----------:|-----------:|\r\n|   CreateObjectsNoTail | 141.311 ms | 2.6544 ms | 4.6489 ms | 9500.0000 | 5000.0000 |  750.0000 | 56002700 B |\r\n| CreateObjectsWithTail |  81.226 ms | 1.6219 ms | 3.2764 ms | 6000.0000 | 3500.0000 | 1000.0000 | 32002081 B |\r\n|      UseObjectsNoTail |   8.319 ms | 0.0555 ms | 0.0492 ms |         - |         - |         - |       15 B |\r\n|    UseObjectsWithTail |   4.763 ms | 0.0307 ms | 0.0272 ms |         - |         - |         - |        7 B |\r\n\r\n",
                                           "updatedAt":  "2023-01-10T15:31:40Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "\u0027Tail\u0027 arrays? (An embedded or inline array at the end of a reference type.)",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/83007",
        "createdAt":  "2023-03-05T20:53:11Z",
        "number":  83007,
        "author":  "gurustron",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-03-22T20:52:59Z",
        "body":  "### Description\r\n\r\nNot sure if this a bug though and maybe this is better addressed in the csharplang repo. \r\n\r\nWhen interface provides implementation for `IEqualityOperators.==` operator the implementation is not resolved unless via generic indirection.\r\n\r\n[Original SO question](https://stackoverflow.com/questions/75643829/is-it-possible-to-auto-implement-iequatablet-and-icomparablet-in-c-sharp-11/75645158#75645158)\r\n\r\n### Reproduction Steps\r\n\r\n```csharp\r\npublic interface IAutoEquatable\u003cT\u003e : IEquatable\u003cT\u003e, IEqualityOperators\u003cT, T, bool\u003e where T : IAutoEquatable\u003cT\u003e\r\n{\r\n    static bool IEqualityOperators\u003cT, T, bool\u003e.operator ==(T? left, T? right)\r\n    {\r\n        Console.Write(\"ieop.== \");\r\n        if (ReferenceEquals(left, null) \u0026\u0026 ReferenceEquals(right, null))\r\n        {\r\n            return true;\r\n        }\r\n\r\n        if (ReferenceEquals(left, null) || ReferenceEquals(right, null))\r\n        {\r\n            return false;\r\n        }\r\n\r\n        return left.Equals(right);\r\n    }\r\n\r\n    static bool IEqualityOperators\u003cT, T, bool\u003e.operator !=(T? left, T? right)\r\n    {\r\n        return !(left == right);\r\n    }\r\n}\r\n\r\nclass Foo : IAutoEquatable\u003cFoo\u003e\r\n{\r\n    public bool Equals(Foo? other)\r\n    {\r\n        Console.Write(\"eq \");\r\n        return true;\r\n    }\r\n}\r\n```\r\n\r\nAnd usage:\r\n\r\n```\r\n// 1\r\nDo\u003cFoo\u003e();\r\n// 2\r\nDo1\u003cFoo\u003e();\r\n// 3\r\nConsole.WriteLine(new Foo() == new Foo());\r\n// 4\r\nIEqualityOperators\u003cFoo, Foo, bool\u003e foo1 = new Foo(); \r\nIEqualityOperators\u003cFoo, Foo, bool\u003e foo2 = new Foo();\r\nConsole.WriteLine(foo1 == foo2);\r\n// 5\r\nIAutoEquatable\u003cFoo\u003e foo3 = new Foo();\r\nIAutoEquatable\u003cFoo\u003e foo4 = new Foo();\r\nConsole.WriteLine(foo3 == foo4);\r\n\r\nvoid Do\u003cT\u003e() where T :IAutoEquatable\u003cT\u003e , new()\r\n{\r\n    Console.WriteLine(new T() == new T());\r\n}\r\n\r\nvoid Do1\u003cT\u003e() where T : IEqualityOperators\u003cT, T, bool\u003e , new()\r\n{\r\n    Console.WriteLine(new T() == new T());\r\n}\r\n```\r\n\r\n### Expected behavior\r\n\r\n1. `ieop.== eq True`\r\n2. `ieop.== eq True`\r\n3. ideally would be great to get `ieop.== eq True` but based on the fact that classes do not inherit members from its interfaces ([default interface implementation spec](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/default-interface-methods#concrete-methods-in-interfaces)) `False` can be somewhat explained\r\n4. `ieop.== eq True`\r\n5. `ieop.== eq True`\r\n\r\n### Actual behavior\r\n\r\n1. `ieop.== eq True`\r\n2. `ieop.== eq True`\r\n3. `False`\r\n4. `False`\r\n5. `False`\r\n\r\n### Regression?\r\n\r\nNA\r\n\r\n### Known Workarounds\r\n\r\nNA\r\n\r\n### Configuration\r\n\r\n- OS\r\n   Windows 11\r\n- SDK \r\n    7.0.100 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n### Other information\r\n\r\n[@sharplab](https://sharplab.io/#v2:C4LgTgrgdgPgAgJgAwFgBQiCM65IARyYB0AchALYCmYAlgMYDOA3OugPRt7ZoAiA9gB4AYnz4A+ABQBKFmg54E6fpmGjJM9pwDMOTAE4JUSgHc8IvtLwBeK3iOnz0jXM4AWdAEkAogEcIAQwAbGmAATwB5AAdqf2A+MAZVPgAaM1FUgCNRQLE8ADNRTGs7EzSLGTxPXwDgsKiYuISk1PNM7NyCvgRi+zLpWUIDTqKbfNEEZ3kAVk8AQQg46tj/DMDKJI7RLR7Sx2cPecW/ZdX1802+Vx2HUX7dIa3rW07XZxwr/gEAFXU8YwALaiUPBfPAgA4LPhLYArNbfXKpezSdAAb3QeAxBH0hlKX0so16eKkzgAvqwMB8+CofpYAUCQWC8N5jrUItEwLF4okvqkeXgsnwcnhESZkWg0WhMViDIT8bZZcTZGS0OS4NsaFBgNQ8v46MCIUcAjDTvDGcyjbD1j9UuagiE2Q0ud9eW1Bbk6WBgaCQEzDlDjsa4T9UVL0ABIQgANn52SZS1Z9Q5jW5LpjbqIfHZnLATwkXwA/Hg1nlgLzC7QAOb/YBScMSqVhgDCfCgDEFlCIAHVaFqJAAiGiUTNEUZ95xhsM0PJ4CQAJUoeSBUD18YYEmLpagEECgSkeAAZPu8PPF57l5RVxJK9Xklud8Tw2GJROIwB2PDASCUWQT5UTqczieS4riya4bre267ngMAwMeC7AReoFXjQVabpBD5oBOz4TnA746oEDDfo+f5vkWC7AEQl7XjWP7KqGmFRhiAqBBitoJlmybOiCro5BmHHxHgACEVh5oW4EguWKHVrWmHYbhQnruRTx4NR47KsqODdOYZp+tClobKi4ZqmmLGXuYhZ8MAgJgDJT7olKmLNq27Zdj2lD9pQPh4GOP6kZ+EBEZh6nkkAA===)",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOVrygkw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5WvKCT",
                                           "createdAt":  "2023-03-05T20:53:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2023-03-05T20:53:16Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Default interface implementation of static abstract operator is not resolved.",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/83189",
        "createdAt":  "2023-03-09T08:04:02Z",
        "number":  83189,
        "author":  "MichalStrehovsky",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCu-HpQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "BrzVlad",
                                            "createdAt":  "2023-03-09T14:47:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lambdageek",
                                            "createdAt":  "2023-03-20T16:08:56Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2025-07-07T17:56:00Z",
        "body":  "@BrzVlad pointed me to this passing test:\r\n\r\nhttps://github.com/dotnet/runtime/blob/201aae91a538e98e9dd16ff18f2752c747f5a000/src/tests/Loader/classloader/StaticVirtualMethods/DiamondShape/svm_diamondshape.il#L235-L239\r\n\r\nNotice that this is an `.override` marked `static abstract virtual`. Notably there\u0027s no `final`. This means we create a new slot that someone could individually override (on top of the method we\u0027re overriding). Is this intentional?\r\n\r\nIf this was a non-static default interface methods we enforce that these are always marked `final`. If they aren\u0027t, the runtime will throw `TypeLoadException` \"Method implementation on an interface \u0027X\u0027 from assembly \u0027Y\u0027 must be a final method.\".\r\n\r\nFWIW, attempting to actually override this method currently throws a `MissingMethodException` (for a method that exists, whatever that means), and Roslyn does emit these as `final`, so it should be safe to enforce it here too, unless it\u0027s intentional.\r\n\r\nCc @davidwrighton @trylek ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOZKYNIQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5X_8F6",
                                           "createdAt":  "2023-03-20T14:53:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "SamMonoRT",
                                           "body":  "cc @lambdageek for visibility",
                                           "updatedAt":  "2023-03-20T14:53:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5YAfY9",
                                           "createdAt":  "2023-03-20T16:08:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lambdageek",
                                           "body":  "Yea, @BrzVlad and I discussed this in the context of Mono\u0027s DIM implementation - I think the test is wrong - possibly there was some iterations between the runtime and Roslyn and earlier non-**final** methods were allowed.\r\n\r\nReading ECMA-335 augments https://github.com/dotnet/runtime/blob/main/docs/design/specs/Ecma-335-Augments.md#proposed-specification-change-5 \r\n\r\n\u003e Section \"II.12.1 Implementing interfaces\" is extended to say all virtual instance methods defined on an interface must be abstract, be marked with newslot and not have an associated MethodImpl which uses the method as its Impl, or final without newslot and with a MethodImpl that uses the method as its Impl entry.\r\n\r\nMy reading of this is that since reabstraction uses `.override` to add a MethodImpl, the reabstracted-method must be **final**.  The test is wrong.\r\n",
                                           "updatedAt":  "2023-03-20T16:08:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5YCMGV",
                                           "createdAt":  "2023-03-20T21:36:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC4McWQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "lambdageek",
                                                                               "createdAt":  "2023-03-20T21:44:55Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "\u003e My reading of this is that since reabstraction uses .override to add a MethodImpl\r\n\r\nThis section was added for instance default interface methods and wasn\u0027t updated for statics - \"all virtual **instance** methods defined on an interface must be\".\r\n\r\nIt would really help if @davidwrighton or @trylek could clarify whether we should update the wording to apply to static methods as well and fix the runtime (to throw) and test (to be final).",
                                           "updatedAt":  "2023-03-20T21:36:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5YCMR_",
                                           "createdAt":  "2023-03-20T21:37:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "@mangod9 I moved this to 8.0, this is blocking implementations in other runtimes.",
                                           "updatedAt":  "2023-03-20T21:37:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5YIw9W",
                                           "createdAt":  "2023-03-21T22:45:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "trylek",
                                           "body":  "Hmm. I have recently fixed this bit to put it in sync with what Roslyn emits in\r\n\r\nhttps://github.com/dotnet/runtime/pull/80987\r\n\r\nI was under the impression that requiring such overridden methods to be \u003ccode\u003efinal\u003c/code\u003e was a temporary limitation for the sake of code simplicity where we originally didn\u0027t allow multiple overrides in derived classes. For the reabstraction case the \u003ccode\u003efinal\u003c/code\u003e modifier doesn\u0027t make much sense to me as I believe the sole purpose of the reabstraction is to require an implementing class to override the method in question (basically as if the interface with the reabstraction declaration was the one declaring the original abstract virtual method). According to Vlad\u0027s explanation the Mono implementation is quite different than the CoreCLR version so I can easily understand these flags may have additional subtle meanings I\u0027m not used to from CoreCLR, I\u0027ll be happy to make sure we can continue making progress in all runtimes we currently support.",
                                           "updatedAt":  "2023-03-21T22:45:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5i5BY3",
                                           "createdAt":  "2023-07-31T20:28:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "@MichalStrehovsky @trylek does this need any fixing in 8? ",
                                           "updatedAt":  "2023-07-31T20:28:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5i5Prm",
                                           "createdAt":  "2023-07-31T21:16:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "\u003e @MichalStrehovsky @trylek does this need any fixing in 8?\r\n\r\nIf we want to block static reabstractions that are not marked final, we better do it earlier than later. I don\u0027t think non-final reabstractions actually work with CoreCLR today - the VM does something completely unexpected if I try to actually override the non-final slot.\r\n\r\nI believe non-final reabstractions should be blocked by the type loader, but I can\u0027t get David to make a statement on this (I tried here, over email, etc.). I\u0027m not in Redmond, so this is my best. Last time I checked, this was blocking the Mono team from making progress on their implementation.",
                                           "updatedAt":  "2023-07-31T21:16:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5kpg0h",
                                           "createdAt":  "2023-08-22T17:12:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mangod9",
                                           "body":  "Moving this to 9 at this point. ",
                                           "updatedAt":  "2023-08-22T17:12:03Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Static DIM reabstractions don\u0027t need to be final?",
        "labels":  [
                       "area-TypeSystem-coreclr",
                       "discussion"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/92566",
        "createdAt":  "2023-09-24T21:35:38Z",
        "number":  92566,
        "author":  "VoroninArtemii",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCy4kng==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "TERESH1",
                                            "createdAt":  "2023-09-27T12:55:19Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-07-26T15:41:02Z",
        "body":  "### Description\r\n\r\nWe have two pointer `pMT` dereferences:\r\nhttps://github.com/dotnet/runtime/blob/cc2670b53ecc1576d3aa1a1011476c99372adfd7/src/coreclr/vm/typedesc.cpp#L888\r\nhttps://github.com/dotnet/runtime/blob/cc2670b53ecc1576d3aa1a1011476c99372adfd7/src/coreclr/vm/typedesc.cpp#L909\r\nAnd they are absolutely identical. But before the second dereference there is a check for NULL, before the first there is not. I assume two options. The first option is an unnecessary check. The second option is that the pointer at the first dereference can really be NULL. Between these two dereferences, the pointer `pMT` itself does not change. Only the following lines:\r\nhttps://github.com/dotnet/runtime/blob/cc2670b53ecc1576d3aa1a1011476c99372adfd7/src/coreclr/vm/typedesc.cpp#L890-L898\r\nFound by Linux Verification Center ([portal.linuxtesting.ru](http://portal.linuxtesting.ru/)) with SVACE.\r\n\r\nAuthor A. Voronin.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOhkpgOQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6GEPoO",
                                           "createdAt":  "2024-07-25T02:51:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODrt7qg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "lambdageek",
                                                                               "createdAt":  "2024-07-26T15:35:11Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "steveisok",
                                           "body":  "Not 100% sure, but a good explanation may be the first dereference never gets hit when taking the else path in:\r\n https://github.com/dotnet/runtime/blob/cc2670b53ecc1576d3aa1a1011476c99372adfd7/src/coreclr/vm/typedesc.cpp#L855-L870 \r\n",
                                           "updatedAt":  "2024-07-25T02:51:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GSmA5",
                                           "createdAt":  "2024-07-26T15:39:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lambdageek",
                                           "body":  "yea I think there\u0027s probably a situation where we come in from the \"else\" case that @steveisok mentioned (line 855) and then hit try to throw from line 888.\r\n\r\nBut it would only happen with malformed IL, I think.\r\n\r\nThere might be a valid issue here, but the majority of the work will be in crafting an appropriately malformed assembly for a test case.\r\n\r\nPRs welcome",
                                           "updatedAt":  "2024-07-26T15:41:02Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Сhecking for NULL",
        "labels":  [
                       "help wanted",
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/95544",
        "createdAt":  "2023-12-02T13:44:19Z",
        "number":  95544,
        "author":  "bysdxt",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-04-20T07:51:24Z",
        "body":  "### Description\n\ndotnet runtime throws System.TypeLoadException when there is static field of ReadOnlyMemory\u003c\u003e with struct itself.\n\n### Reproduction Steps\n\n1.new console project,\r\n2.write code to Program.cs:\r\n```C#\r\nConsole.WriteLine(new Test());\r\nstruct Test{\r\n    public static ReadOnlyMemory\u003cTest\u003e s = ReadOnlyMemory\u003cTest\u003e.Empty;\r\n}\r\n\r\n```\r\n3.build and run\r\n\n\n### Expected behavior\n\nno exception\n\n### Actual behavior\n\nSystem.TypeLoadException occurred\r\n![e](https://github.com/dotnet/runtime/assets/13766766/2440838d-e07d-4e19-8183-b7b1c8638b27)\r\n\n\n### Regression?\n\nI don\u0027t know.This is my first time using ReadOnlyMemory.\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n.NET SDK:\r\n Version:           8.0.100\r\n Commit:            57efcf1350\r\n Workload version:  8.0.100-manifests.8d38d0cc\r\n\r\n运行时环境:\r\n OS Name:     Windows\r\n OS Version:  10.0.19045\r\n OS Platform: Windows\r\n RID:         win-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\8.0.100\\\r\n\r\n已安装 .NET 工作负载:\r\n Workload version: 8.0.100-manifests.8d38d0cc\r\n没有要显示的已安装工作负载。\r\n\r\nHost:\r\n  Version:      8.0.0\r\n  Architecture: x64\r\n  Commit:       5535e31a71\r\n\r\n.NET SDKs installed:\r\n  8.0.100 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET runtimes installed:\r\n  Microsoft.AspNetCore.App 6.0.25 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 8.0.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 3.1.32 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 5.0.17 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 6.0.25 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 8.0.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.WindowsDesktop.App 3.1.32 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 5.0.17 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 6.0.25 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 8.0.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n\r\nOther architectures found:\r\n  x86   [C:\\Program Files (x86)\\dotnet]\r\n    registered at [HKLM\\SOFTWARE\\dotnet\\Setup\\InstalledVersions\\x86\\InstallLocation]\r\n\r\nEnvironment variables:\r\n  Not set\r\n\r\nglobal.json file:\r\n  Not found\r\n![i](https://github.com/dotnet/runtime/assets/13766766/95d525b9-ad48-4310-bc5c-e86f5e159f35)\r\n\r\n\n\n### Other information\n\nThe exception occurred when I using VS 17.7 with dotnet 7.0.\r\nThen I upgrade VS to 17.8.2 with dotnet 8.0,but the exception still occurred.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOp-i4EQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5tgLn9",
                                           "createdAt":  "2023-12-02T13:47:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bysdxt",
                                           "body":  "code:\r\n\r\n[test.zip](https://github.com/dotnet/runtime/files/13536428/test.zip)\r\n",
                                           "updatedAt":  "2023-12-02T13:47:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5tgSEQ",
                                           "createdAt":  "2023-12-02T15:14:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "Similar to #88030",
                                           "updatedAt":  "2023-12-02T15:14:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6n6LgR",
                                           "createdAt":  "2025-04-20T07:45:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "leidegre",
                                           "body":  "Got some more information about this, seems related.\n\nThis runs fine.\n\n```cs\nConsole.WriteLine(new Foo());\n\nstruct Foo\n{\n  public ReadOnlyMemory\u003cFoo\u003e Bar;\n}\n```\n\nThis does not.\n\n```cs\nConsole.WriteLine(new Foo());\n\nstruct Bar\n{\n  public Foo Foo;\n}\n\nstruct Foo\n{\n  public ReadOnlyMemory\u003cBar\u003e Bar;\n}\n\n// System.TypeLoadException: Could not load type \u0027Foo\u0027 from assembly...\n```\n\nAnd neither does this.\n\n```cs\nConsole.WriteLine(new Foo());\n\nstruct Foo\n{\n  public ReadOnlyMemory\u003c(Foo, object)\u003e Bar;\n}\n\n// Could not load type \u0027Foo\u0027 from assembly [..] because of an invalid self-referential generic field.\n```\n\nIt is surprising to me that this succeeds in compiling but fails at runtime. Memory is just that, there should be no recursive instantiation of these struct types.\n\n---\n\n```\n\u003e dotnet --version\n9.0.203\n```",
                                           "updatedAt":  "2025-04-20T07:51:23Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "System.TypeLoadException occurred when there is static ReadOnlyMemory\u003c\u003e field",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/96831",
        "createdAt":  "2024-01-11T05:38:45Z",
        "number":  96831,
        "author":  "JJLovesLife",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-08-14T17:58:09Z",
        "body":  "I was reading the CLR source code these days to learn better of dotnet. The following code seems to be a bug to me.\r\nhttps://github.com/dotnet/runtime/blob/5535e31a712343a63f5d7d796cd874e563e5ac14/src/coreclr/utilcode/util.cpp#L1894-L1905\r\nAccording to the ECMA spec:\r\n\u003e *GenParamCount* is the number of generic parameters for the method.\r\n\r\nSo the `ulArgCount` here should be the # of parameters. And `ulArgIx = 0` is the `RetType`, so `[1, ulArgCount]` will be the actual args. That means the condition in the if statement should be `ulArgIx \u003c= ulArgCount` instead of `\u003c`.\r\n\r\nI did some debugging by debugger, it did forget to validate the last arg. If it is necessary, I might create an invalid dll that will not be detected by this piece of code.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOfPRVeQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc589FV5",
                                           "createdAt":  "2024-05-06T15:58:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveisok",
                                           "body":  "/cc @kg ",
                                           "updatedAt":  "2024-05-06T15:58:14Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "MethodDef validation seems miss to validate the last arg in `validateTokenSig`",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/97526",
        "createdAt":  "2024-01-25T23:14:24Z",
        "number":  97526,
        "author":  "MichalPetryka",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODJHf4g==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hamarb123",
                                            "createdAt":  "2024-01-25T23:16:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "IS4Code",
                                            "createdAt":  "2024-01-26T00:01:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "adams85",
                                            "createdAt":  "2024-01-26T23:55:52Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Rekkonnect",
                                            "createdAt":  "2024-02-04T22:45:45Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "NN---",
                                            "createdAt":  "2024-02-14T14:22:17Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-03-21T22:32:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "fitdev",
                                            "createdAt":  "2024-11-22T08:37:51Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ElectroJr",
                                            "createdAt":  "2025-01-14T06:36:44Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "domn1995",
                                            "createdAt":  "2025-03-21T01:35:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DanilovSoft",
                                            "createdAt":  "2025-07-30T09:38:55Z"
                                        }
                                    ],
                          "totalCount":  10
                      },
        "updatedAt":  "2025-07-16T20:22:40Z",
        "body":  "Currently the runtime errors out when trying to load such type:\r\n```cs\r\nusing System;\r\nusing System.Runtime.CompilerServices;\r\nusing System.Runtime.InteropServices;\r\n\r\n[StructLayout(LayoutKind.Explicit)]\r\npublic struct S\u003cT\u003e where T : unmanaged\r\n{\r\n    [FieldOffset(0)]\r\n    public T t;\r\n    [FieldOffset(0)]\r\n    public int i;\r\n}\r\n```\r\nwith ``System.TypeLoadException: Could not load type \u0027S`1\u0027 from assembly \u0027_, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\u0027 because generic types cannot have explicit layout.``\r\n\r\nWhile determining proper offsets for generics is problematic due to unknown sizes, union types with all fields at 0 offset don\u0027t face such issues and since the generic is constrained to `unmanaged`, the runtime doesn\u0027t need to worry about managed types appearing in the layout.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOiM3WKg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5x6dLn",
                                           "createdAt":  "2024-01-25T23:17:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "+1 from me, this would be very useful.",
                                           "updatedAt":  "2024-01-25T23:17:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5x8K1O",
                                           "createdAt":  "2024-01-26T07:22:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODbeFvw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "CONFUSED",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-03-21T22:32:24Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "Sidenote: the `unmanaged` constraint is a concept the C# compiler made up and runtime hasn\u0027t so far made decisions around that. `typeof(S\u003c\u003e).MakeGenericType(typeof(KeyValuePair\u003cstring, string\u003e))` will load fine.",
                                           "updatedAt":  "2024-01-26T07:22:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5x8Mi9",
                                           "createdAt":  "2024-01-26T07:30:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "\u003e Sidenote: the `unmanaged` constraint is a concept the C# compiler made up and runtime hasn\u0027t so far made decisions around that. `typeof(S\u003c\u003e).MakeGenericType(typeof(KeyValuePair\u003cstring, string\u003e))` will load fine.\r\n\r\nThat\u0027s inaccurate, and has been so since .NET 5.0 at least iirc, but probably even a bit earlier - [link](https://sharplab.io/#v2:EYLgtghglgdgNAFxAJwK4wD4AEBMBGAWACgsAGAAizwBYBuYsyvAOgCV0EowBTZgYQD2YAA5QANt2QBlSQDcoAY24BneiQpU2HLrwCSMBJIHCZyeUtXEGAZko5yfYgG9i5N3Zyv3Lou7/kEAE9hbgEAMwAKKQAeAD4ASmYAWQgAa24AcW4YSUUAFWDuCKCQ8IiAaW5AgDUIMVRuAAVoZGiqUjgmUgT4tT8AX2JBomIAbSkENAUEABkIQIFUBAi5haXy2AATZgBRAA9hMUUoBHiAXRtyZUnUafIYvNjyAHcAC0lucjzyEHJ0SBgEAA5txNs4vG5RgAxKDcMSbADyYTCym4y1I5whlFs3wQfXc0Nh8KRKLREQxF187iwtlgCHIUDU/SAA=).",
                                           "updatedAt":  "2024-01-26T07:30:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5x8NOC",
                                           "createdAt":  "2024-01-26T07:33:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODbeF0A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hamarb123",
                                                                               "createdAt":  "2024-01-26T07:34:43Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kg",
                                                                               "createdAt":  "2024-02-05T19:03:57Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-03-21T22:32:35Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "\u003e \u003e Sidenote: the `unmanaged` constraint is a concept the C# compiler made up and runtime hasn\u0027t so far made decisions around that. `typeof(S\u003c\u003e).MakeGenericType(typeof(KeyValuePair\u003cstring, string\u003e))` will load fine.\r\n\u003e \r\n\u003e That\u0027s inaccurate, and has been so since .NET 5.0 at least iirc, but probably even a bit earlier - [link](https://sharplab.io/#v2:EYLgtghglgdgNAFxAJwK4wD4AEBMBGAWACgsAGAAizwBYBuYsyvAOgCV0EowBTZgYQD2YAA5QANt2QBlSQDcoAY24BneiQpU2HLrwCSMBJIHCZyeUtXEGAZko5yfYgG9i5N3Zyv3Lou7/kEAE9hbgEAMwAKKQAeAD4ASmYAWQgAa24AcW4YSUUAFWDuCKCQ8IiAaW5AgDUIMVRuAAVoZGiqUjgmUgT4tT8AX2JBomIAbSkENAUEABkIQIFUBAi5haXy2AATZgBRAA9hMUUoBHiAXRtyZUnUafIYvNjyAHcAC0lucjzyEHJ0SBgEAA5txNs4vG5RgAxKDcMSbADyYTCym4y1I5whlFs3wQfXc0Nh8KRKLREQxF187iwtlgCHIUDU/SAA=).\r\n\r\nMy comment is about `unmanaged` constraint being meaningless to the runtime (it\u0027s the same as `struct`). Your example doesn\u0027t load because of the StructLayout, not because of unmet constraints.",
                                           "updatedAt":  "2024-01-26T07:33:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5x8O49",
                                           "createdAt":  "2024-01-26T07:42:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "I swear I tested this in the past with generic methods, but presumably I must have tested it incorrectly.\r\n\r\nI think it would make more sense to allow it based on what the type parameters are in practice, as opposed to what they\u0027re constrained to anyway.\r\n\r\nSo, what I would suggest, is that *if* the type parameters are `unmanaged` (checked when loading generic type instantiation), then we allow it to work as expected. And, if you constrain it, then you can ensure yourself that it will successfully load.",
                                           "updatedAt":  "2024-01-26T07:44:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5x_AtS",
                                           "createdAt":  "2024-01-26T16:30:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "\u003e \u003e \u003e Sidenote: the `unmanaged` constraint is a concept the C# compiler made up and runtime hasn\u0027t so far made decisions around that. `typeof(S\u003c\u003e).MakeGenericType(typeof(KeyValuePair\u003cstring, string\u003e))` will load fine.\r\n\u003e \u003e \r\n\u003e \u003e \r\n\u003e \u003e That\u0027s inaccurate, and has been so since .NET 5.0 at least iirc, but probably even a bit earlier - [link](https://sharplab.io/#v2:EYLgtghglgdgNAFxAJwK4wD4AEBMBGAWACgsAGAAizwBYBuYsyvAOgCV0EowBTZgYQD2YAA5QANt2QBlSQDcoAY24BneiQpU2HLrwCSMBJIHCZyeUtXEGAZko5yfYgG9i5N3Zyv3Lou7/kEAE9hbgEAMwAKKQAeAD4ASmYAWQgAa24AcW4YSUUAFWDuCKCQ8IiAaW5AgDUIMVRuAAVoZGiqUjgmUgT4tT8AX2JBomIAbSkENAUEABkIQIFUBAi5haXy2AATZgBRAA9hMUUoBHiAXRtyZUnUafIYvNjyAHcAC0lucjzyEHJ0SBgEAA5txNs4vG5RgAxKDcMSbADyYTCym4y1I5whlFs3wQfXc0Nh8KRKLREQxF187iwtlgCHIUDU/SAA=).\r\n\u003e \r\n\u003e My comment is about `unmanaged` constraint being meaningless to the runtime (it\u0027s the same as `struct`). Your example doesn\u0027t load because of the StructLayout, not because of unmet constraints.\r\n\r\nThat doesn\u0027t seem to be fully the case:\r\n```cs\r\nConsole.WriteLine(typeof(S\u003c\u003e).MakeGenericType(typeof(string)).FullName);\r\npublic struct S\u003cT\u003e where T : unmanaged\r\n{\r\n    public T t;\r\n}\r\n```\r\ngives:\r\n```cs\r\nSystem.ArgumentException: GenericArguments[0], \u0027System.String\u0027, on \u0027S`1[T]\u0027 violates the constraint of type \u0027T\u0027.\r\n ---\u003e System.TypeLoadException: GenericArguments[0], \u0027System.String\u0027, on \u0027S`1[T]\u0027 violates the constraint of type parameter \u0027T\u0027.\r\n   at System.RuntimeTypeHandle.Instantiate(RuntimeType inst)\r\n   at System.RuntimeType.MakeGenericType(Type[] instantiation)\r\n   --- End of inner exception stack trace ---\r\n   at System.RuntimeType.ValidateGenericArguments(MemberInfo definition, RuntimeType[] genericArguments, Exception e)\r\n   at System.RuntimeType.MakeGenericType(Type[] instantiation)\r\n   at Program.\u003cMain\u003e$(String[] args)\r\n   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)\r\n   at System.Reflection.MethodBaseInvoker.InvokeDirectByRefWithFewArgs(Object obj, Span`1 copyOfArgs, BindingFlags invokeAttr)\r\n```",
                                           "updatedAt":  "2024-01-26T16:30:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5yAx0Z",
                                           "createdAt":  "2024-01-26T23:02:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "\u003e That doesn\u0027t seem to be fully the case:\r\n\r\nNot sure I follow - I wrote unmanaged is same as struct constraint and yes, string is not a struct.",
                                           "updatedAt":  "2024-01-26T23:02:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5yAz55",
                                           "createdAt":  "2024-01-26T23:13:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "\u003e \u003e That doesn\u0027t seem to be fully the case:\r\n\u003e \r\n\u003e Not sure I follow - I wrote unmanaged is same as struct constraint and yes, string is not a struct.\r\n\r\nOh I thought you meant it as `struct` being meaningless to the runtime too.",
                                           "updatedAt":  "2024-01-26T23:13:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5y5m4E",
                                           "createdAt":  "2024-02-05T18:21:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lambdageek",
                                           "body":  "I wonder how this will interact with the ref/non-ref check in the runtime for something like this:\r\n\r\n```csharp\r\n[StructLayout(LayoutKind.Explicit)]\r\npublic struct S\u003cT\u003e where T : unmanaged\r\n{\r\n    [FieldOffset(0)]\r\n    public T t;\r\n    [FieldOffset(8)]\r\n    public object i;\r\n}\r\n\r\npublic struct TwoLongs {\r\n   public long a;\r\n   public long b;\r\n}\r\n```\r\n\r\nSo `S\u003clong\u003e` is ok, but `S\u003cTwoLongs\u003e` overlaps. I\u0027m not sure if we currently do the overlap check on instantiations.",
                                           "updatedAt":  "2024-02-05T18:21:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5y56Bp",
                                           "createdAt":  "2024-02-05T18:41:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "\u003e I wonder how this will interact with the ref/non-ref check in the runtime for something like this\r\n\r\nI\u0027d say that blocking such layouts with managed fields would be okay. I don\u0027t have any use cases for generic managed unions.",
                                           "updatedAt":  "2024-02-05T18:41:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5y59aE",
                                           "createdAt":  "2024-02-05T18:48:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lambdageek",
                                           "body":  "\u003e \u003e I wonder how this will interact with the ref/non-ref check in the runtime for something like this\r\n\u003e \r\n\u003e I\u0027d say that blocking such layouts with managed fields would be okay. I don\u0027t have any use cases for generic managed unions.\r\n\r\nMy point isn\u0027t just that we need to block such structs. (But yes, we would need to block them) My point is that we don\u0027t have a check on generic instances right now, but if we allow an explicit layout on generics, we would need such a check.  That might be fine - but right now the check isn\u0027t there.\r\n",
                                           "updatedAt":  "2024-02-05T18:49:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5y6MnU",
                                           "createdAt":  "2024-02-05T19:11:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kg",
                                           "body":  "I\u0027m curious about the use scenario for this. It makes me nervous since it would allow you to author a struct that *looks* memory and type safe but will be broken depending on the size of `T`. Is there a problem this solves that can\u0027t be solved by a property that wraps `Unsafe.As`?",
                                           "updatedAt":  "2024-02-05T19:11:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5y6SNu",
                                           "createdAt":  "2024-02-05T19:27:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODVjxjQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kg",
                                                                               "createdAt":  "2024-02-05T19:36:50Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "adams85",
                                           "body":  "\u003e It makes me nervous since it would allow you to author a struct that looks memory and type safe but will be broken depending on the size of T\r\n\r\nThere are safe use cases. For example, when the field with the generic type is the last one in the memory layout, it won\u0027t be broken. Or, when the set of possible type arguments are limited and known at compile time, so the layout offsets can be calculated in a type safe way (see the problem below).\r\n\r\n\u003e Is there a problem this solves that can\u0027t be solved by a property that wraps Unsafe.As?\r\n\r\nAlthough I\u0027m not 100% familiar with the topic, e.g. [this looks like a problem](https://fractalfir.github.io/generated_html/rustc_codegen_clr_v0_1_0.html#why_does_layoutkind.explicit_not_work_with_generics?) that could benefit from this.\r\n\r\n\r\n",
                                           "updatedAt":  "2024-02-05T19:29:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5y7Jyq",
                                           "createdAt":  "2024-02-05T21:17:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODWIJaw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hamarb123",
                                                                               "createdAt":  "2024-02-09T10:13:34Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "lambdageek",
                                           "body":  "\u003e Sidenote: the `unmanaged` constraint is a concept the C# compiler made up and runtime hasn\u0027t so far made decisions around that. \r\n\r\nI dont\u0027 think this issue is about `unmanaged` actually.\r\n\r\nWhat we need is some logic in the runtime like this:\r\n1. if a generic type definition has an explicit layout, set some bit on the type definition\r\n2. when instantiating a generic type definition, if the bit is set, run the field overlap check on the generic instance.\r\n\r\n\r\n",
                                           "updatedAt":  "2024-02-05T21:17:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6IzdYq",
                                           "createdAt":  "2024-08-18T09:20:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "#43486",
                                           "updatedAt":  "2024-08-18T09:20:43Z"
                                       }
                                   ],
                         "totalCount":  15
                     },
        "title":  "Permit loading Explicit layouts with generics constrained to unmanaged",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/101400",
        "createdAt":  "2024-04-07T16:15:05Z",
        "number":  101400,
        "author":  "Aytackydln",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-29T03:21:38Z",
        "body":  "Hopefully this is the correct repository to report. This behaviour is really annoying since you cannot find where this is caused from the exception trace since this is thrown in the consuming thread.\r\n\r\n**Version Used**: \r\nNET 8\r\n\r\n**Steps to Reproduce**:\r\n\r\nDispatcher case code sample:\r\nhttps://github.com/Aytackydln/OptionalParameterTaskWpf\r\n\r\n1. Define a method with optional parameter\r\n2. Pass it to an \"async\" method with only method name\r\nLike:\r\n`Dispatcher.BeginInvoke(MethodWithOptionalParameter)`\r\n`AsyncMethod(MethodWithOptionalParameter)`\r\n3. Let the dispatcher consume\r\n\r\n[quick sharplab sample](https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwAICYCMBYAUKgBgAJVMA6AFQAswBTAQzgEsoBzAbj0JMwFZPcXTAE4AFACIAStFQA2AMoQAxktoBnNeICUA6VDmKV6taNS9gTAPZQA6k2BUA8gAcL1+gBsdeanUZl5D1paZ1FMAgJvQXwRCT05ADF6Jg9NKNRhInjZJJSTMzdbeydXKyhPKN8GOACgkLCIqK4ADhJZLJkc5NTRABFaINZ6YFoiYHo1AGstPABvPCJFkky5Mj1RUS0iAF4APjGJybJegE9ygFsmJQBJKAA3S0naTaiAXzwuABYO/QVlVQ0fQGtCGIwOUxmuHmuCWbTW0A2Wz24KOpwuV1uDyeLwE72iqFachI5jKdgcLkKnlM4QA/ERnPQwPRzrQRmAdkQoBAPF45gslqQxOIALKsqiWOBEJlQACERHEREQ9MZzNZtDAbyAA===)\r\n\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOe2_lvw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc57b-W_",
                                           "createdAt":  "2024-04-22T20:51:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jaredpar",
                                           "body":  "Moving to runtime as this is not a compiler bug, it\u0027s about the exception information generated for this scenario. \n\nNote: not a regression, tested this all the way back to `net6.0` and observe the same behavior.",
                                           "updatedAt":  "2024-04-22T20:51:06Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Delegate creation with optional methods throw TargetParameterCountException when Dispatcher consumes",
        "labels":  [
                       "enhancement",
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/102121",
        "createdAt":  "2024-05-12T00:29:18Z",
        "number":  102121,
        "author":  "alrz",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-06-14T18:17:55Z",
        "body":  "In the following code `public void M(object arg)` should be enough to implement the interface but neither the compiler nor the runtime accept such code and an explicit impl is required to bridge the two overloads. ([sharplab.io](https://sharplab.io/#v2:EYLgtghglgdgNAGxFBcAuIBOBXGAfAAQDYACAfQFgAoAb2oF9rqA6AYwQgGdOSAHTKADcIaAKYkI2NAHsJMTlBLBRAM2mZVUUQgAmsKGhIAFTNIDmmCGGolbJUQA8xMHTwDaAZQCenMWGYASrhoUGCiALrevqL+APLAAFairGjUdFR2JGzYvtJgJLC+EDCs4oLSUDoknj5+gcGhEVF1QTAhYcwAwnm8KKKYHv2CUKWcXT19mADiojD9IqI6AIJoaALAUqIgIGwymAAUAJQkALwk+zaZdgAMAIwk19cPT4+XtodvJAD0XyQAsqI0AALaSuT7MMLA0F8ATCMQkIGVUTAHxQMwkIohVgkT6ZcqVEgAcgAPH9oDAAHwAEkJ51xV1svgEMDMbnCEkwZk49PeJAIAGYcRk7OkGbYfv9ASCqsozIUJIYAgA1JYPBwAJmuAFZrjzvr9ujpxAoAF7ifkADnO1w1RA+woZBC1JAteoIABYmA6rgBJAAyZEejxAJDmAHdpIkCvI0MVSiR8VVOttduojnr/YHHlqQzpsLwMwGg0QQ+HIwlo0USmUKlUatF/K12k1ajFmPEkikUyk0/axSRM0HQCRWBAEAhhphDIVY9WE7WRxxuAOPHlRD62v0VBBSgADW7E8vJNAU7Z/fYAQmufbFg7u11z+cLWdutxDuiZJAAREyv8/HrcJYjmOE5QFOlazvGiaLlwPA+quYQbmImDbnuB5Hikp4gOeV43gyd63MOH5rN+TLqn+3qZHemohqO46TtOMZxjWBLsLBK5rkhW47qI+7EkysBmFhOHXv+1zqjmJAaKk3r0Pq9guCQ0gqCQkLSsYpgWFY2wkmSsDUoSXqZAQACcGK8MkUBjjAVjiFOnAWawVkIDZYRCv2M7MfOBKppg5zHAK7kinqEoAlCMqiHK8gKiQyqqjamoAOyJSFBqgsaUBmiQiXWg4iV4VcToukZt5FkG746BAnLMLqlF2Hedy0SBEFedB9YtA0YSRK2cSJMe3Z7OmdW2A1QHSZ8ckSrMVTKapUrQiY5iWGAA3qF6k2/NNSkqWxy6LVp1hUCwu08LAyGoeI/BCAsEhSLIxQKBIwBMjuhjKGoGgqFouj6IY8GcZuKE8XxAC0AAqFJpJ8oXzWC3qmaGohhpwCDSIYEDPWsr0JmBaDYGOQUMp5c7QX8dLDVcF5gxyZh6gFgqfKKdgbQpM0qWp0L/YhgMXfuZ7rfJW2zSdHHc+dwO3F6bBLqdPM8TC13wpIMhyI9GMvSkSiqOomjaHoMAGAOABCXCiJ8oS8AgMSzGgPAi1z65y2hh59ZhUNUCzQs7TLxum1LItndx8ZXXC4jK/d8iKOrWOa+9OtfXrv0DgAIv0QiLObYCW9bbRwSbnCiHAepivbCGO+LzsYSeRcUyXPsO1xQPOwJLKQ7QXoMILinC/XqewhnR1UNL7Ehzd4eq4ocefd9+uG50nyOM4rjVM0bZNo03UNu2rsyZkFtW2Eucp2ngiLDX/a3vnhfFwypcAxXvHoTvFLnxfVx32LQeP/xayCW3TPil+GFaU3JvQQlhnwbAwAEAjBIF9GyCAERIhRAodE4YUZoxxlOfGiC9TEygguMmFxa52CrjTOmfIGbegAVcGG4UtZRR4CIWKKo1SagtK6CmEpDQZSyjlfYNp8pumdJwsSwYSC6CqmYZgksKYNTfHyW41wq4FSomVa4Y1AQTS7mzOa9DkzYRKrYBGDlLLWVslJW2jlnKuXEHgpiJMFy+X8pQwmJAaGZDoepWU8pmFxTYdcZKqUSA8IxJlcQ/DBGqLsEVURcj1EPgkZVaqtV+zyKauOFqjiCTtTXp1FsW8Oz9R2D2A40SRrqM0bvZmOjtp6PUgY3yAsprd29uxeeg8gA==))\r\n\r\n```cs\r\ninterface ISomeInterface\u003cin T\u003e {\r\n  void M(T arg);\r\n}\r\n\r\ninterface IBase : ISomeInterface\u003cobject\u003e;\r\n\r\ninterface IDerived : IBase, ISomeInterface\u003cstring\u003e {\r\n   // uncomment to resolve the error but this shouldn\u0027t be necessary\r\n   // void ISomeInterface\u003cstring\u003e.M(string obj) =\u003e M(obj as object); // calls base\r\n}\r\n\r\nclass C : IDerived {\r\n  // error: method `M(string)` is not implemented\r\n  public void M(object arg) { }\r\n}\r\n```\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOfYuWjw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc59iCIc",
                                           "createdAt":  "2024-05-12T00:44:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CyrusNajmabadi",
                                           "body":  "i thnik this would take a language change.  i don\u0027t think the variance part of the lang spec supports this.    The variance part affects things like conversions, but not interface impls.  ",
                                           "updatedAt":  "2024-05-12T00:44:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc59isDG",
                                           "createdAt":  "2024-05-12T13:22:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "alrz",
                                           "body":  "Indeed, but since identical method signatures from different interfaces are already merged, I think this would be just a relaxation of that rule in both sides. On the runtime, the variance already guaranteed that the call is safe.",
                                           "updatedAt":  "2024-05-12T13:39:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc59i5aP",
                                           "createdAt":  "2024-05-12T16:02:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODhyrPw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alrz",
                                                                               "createdAt":  "2024-05-14T17:59:02Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "CyrusNajmabadi",
                                           "body":  "I\u0027m not opposed to this being allowed. But would need runtime to push for wanting this. Otherwise, it\u0027s unlikely we would do it on the lang side. ",
                                           "updatedAt":  "2024-05-12T16:02:43Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Merge inherited interface methods according to variance",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/104633",
        "createdAt":  "2024-07-09T19:25:49Z",
        "number":  104633,
        "author":  "VSadov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-29T19:11:20Z",
        "body":  "Examples of timeout failures:\r\n\r\nhttps://[helixre107v0xdeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-pull-103076-merge-7269229228744033b5/Loader.2.3/1/console.f932d39f.log?helixlogtype=result](https://helixre107v0xdeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-pull-103076-merge-7269229228744033b5/Loader.2.3/1/console.f932d39f.log?helixlogtype=result)\r\n\r\nhttps://[helixre107v0xdeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-pull-85694-merge-c093b64e9e7a4971aa/Loader.1.3/1/console.60c249dc.log?helixlogtype=result](https://helixre107v0xdeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-pull-85694-merge-c093b64e9e7a4971aa/Loader.1.3/1/console.60c249dc.log?helixlogtype=result)\r\n\r\nhttps://[helixre107v0xdeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-pull-85694-merge-c093b64e9e7a4971aa/Loader.2.3/1/console.a7c2f169.log?helixlogtype=result](https://helixre107v0xdeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-pull-85694-merge-c093b64e9e7a4971aa/Loader.2.3/1/console.a7c2f169.log?helixlogtype=result)\r\n\r\nSince this is always on a different scenario, I think it is just the test takes too long on OSX-arm64 machines. \r\nPossibly the machines are too slow and the test is too big.  \r\n(the test was mentioned before as very large and causing trouble due to size in other contexts - https://github.com/dotnet/runtime/issues/92722)\r\n\r\nIf there is no something that is particularly interesting from GC stress perspective for this test, perhaps we should just do `\u003cGCStressIncompatible\u003etrue\u003c/GCStressIncompatible\u003e`",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOhoGbiQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6GCsRf",
                                           "createdAt":  "2024-07-24T20:34:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "VSadov",
                                           "body":  "This is blocking clean gcstress runs. I think this should be fixed in 9.0",
                                           "updatedAt":  "2024-07-24T20:34:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GCxRX",
                                           "createdAt":  "2024-07-24T20:48:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "VSadov",
                                           "body":  "Should be fixed by https://github.com/dotnet/runtime/pull/104686",
                                           "updatedAt":  "2024-07-24T20:48:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GgZuJ",
                                           "createdAt":  "2024-07-29T18:35:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "VSadov",
                                           "body":  "Sadly, the test seems to keep running, taking 4+ hours on osx-arm64, and failing in every `runtime-coreclr gcstress0x3-gcstress0xc` run.\r\n\r\nhttps://dev.azure.com/dnceng-public/public/_build?definitionId=112\u0026_a=summary",
                                           "updatedAt":  "2024-07-29T19:11:20Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "classloader/StaticVirtualMethods/GenericContext/GenericContextTest takes very long under GC stress, times out on OSX-arm64",
        "labels":  [
                       "test-failure",
                       "GCStress",
                       "area-TypeSystem-coreclr",
                       "blocking-clean-ci-optional"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/105064",
        "createdAt":  "2024-07-18T05:21:37Z",
        "number":  105064,
        "author":  "luislhg",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-07T17:38:57Z",
        "body":  "I have a project (tested with .NET6 and .NET8) with AllowUnsafeBlocks.\r\nI then have a struct containing 2 fixed int arrays and a regular int.\r\n\r\nThe first two structs (_SampleDataMemory_Works1_ and _SampleDataMemory_Works2_) do work, the third one _(SampleDataMemory_Crash1)_ crashes with _System.TypeLoadException: Could not find or load a type. (0x80131522)_.\r\n\r\n**class and structs**\r\n```[StructLayout(LayoutKind.Sequential, Pack = 1)]\r\npublic unsafe struct SampleDataMemory_Works1\r\n{\r\n    public int index;\r\n    public fixed int processComplete[ClassTest.MAX_SAMPLE_BUFFER_SIZE];\r\n    public fixed int data[ClassTest.MAX_SAMPLE_BUFFER_SIZE];\r\n};\r\n\r\n[StructLayout(LayoutKind.Sequential, Pack = 1)]\r\npublic unsafe struct SampleDataMemory_Works2\r\n{\r\n    public fixed int processComplete[ClassTest.MAX_SAMPLE_BUFFER_SIZE];\r\n    public int index;\r\n    public fixed int data[ClassTest.MAX_SAMPLE_BUFFER_SIZE];\r\n};\r\n\r\n[StructLayout(LayoutKind.Sequential, Pack = 1)]\r\npublic unsafe struct SampleDataMemory_Crash1\r\n{\r\n    public fixed int processComplete[ClassTest.MAX_SAMPLE_BUFFER_SIZE];\r\n    public fixed int data[ClassTest.MAX_SAMPLE_BUFFER_SIZE];\r\n    public int index;\r\n};\r\n\r\npublic class ClassTest\r\n{\r\n    public const int MAX_SAMPLE_BUFFER_SIZE = 20000000;\r\n\r\n    public static int GetSizeWorks1()\r\n    {\r\n        return Marshal.SizeOf\u003cSampleDataMemory_Works1\u003e();\r\n    }\r\n\r\n    public static int GetSizeWorks2()\r\n    {\r\n        return Marshal.SizeOf\u003cSampleDataMemory_Works2\u003e();\r\n    }\r\n\r\n    public static int GetSizeCrash1()\r\n    {\r\n        return Marshal.SizeOf\u003cSampleDataMemory_Crash1\u003e();\r\n    }\r\n}\r\n```\r\n\r\n**csproj**\r\n\r\n```\r\n\u003cProject Sdk=\"Microsoft.NET.Sdk\"\u003e\r\n\t\u003cPropertyGroup\u003e\r\n\t\t\u003cTargetFramework\u003enet6.0\u003c/TargetFramework\u003e\r\n\t\t\u003cImplicitUsings\u003eenable\u003c/ImplicitUsings\u003e\r\n\t\t\u003cNullable\u003eenable\u003c/Nullable\u003e\r\n\t\t\u003cAllowUnsafeBlocks\u003etrue\u003c/AllowUnsafeBlocks\u003e\r\n\t\u003c/PropertyGroup\u003e\r\n\u003c/Project\u003e\r\n```\r\n\r\nAs you can see all structs have the same size, the only thing different is the position of the the index property, all types are the same.\r\nI wonder why we get this behaviour, assuming the size should be the same.\r\n\r\nI can easily increase the size of the arrays even more and it still works for the first two structs, but a single int after the two fixed arrays makes it crash.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOh6cTTQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6FQ0bd",
                                           "createdAt":  "2024-07-18T07:05:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "It\u0027s likely because field *offset* exceeding the limit. Add a more `public fixed int processComplete2[ClassTest.MAX_SAMPLE_BUFFER_SIZE];` at the front of `SampleDataMemory_Works2`, or doubling the size of `MAX_SAMPLE_BUFFER_SIZE` will both result in `TypeLoadException`.\r\n\r\nhttps://github.com/dotnet/runtime/issues/95193#issuecomment-1825994956 indicates that the maximum field offset is around 2^27. `20000000 * sizeof(int)` is more than 2^26.",
                                           "updatedAt":  "2024-07-18T07:05:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6FUtxS",
                                           "createdAt":  "2024-07-18T14:59:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "fanyang-mono",
                                           "body":  "This looks like a similar issue to https://github.com/dotnet/runtime/issues/97412\r\n\r\nHowever, I would expect SampleDataMemory_Works1 and SampleDataMemory_Works2 trigger the TypeLoadException as well. I will look into it.",
                                           "updatedAt":  "2024-07-18T14:59:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6FVJcd",
                                           "createdAt":  "2024-07-18T15:52:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "luislhg",
                                           "body":  "\u003e It\u0027s likely because field _offset_ exceeding the limit. Add a more `public fixed int processComplete2[ClassTest.MAX_SAMPLE_BUFFER_SIZE];` at the front of `SampleDataMemory_Works2`, or doubling the size of `MAX_SAMPLE_BUFFER_SIZE` will both result in `TypeLoadException`.\r\n\u003e \r\n\u003e [#95193 (comment)](https://github.com/dotnet/runtime/issues/95193#issuecomment-1825994956) indicates that the maximum field offset is around 2^27. `20000000 * sizeof(int)` is more than 2^26.\r\n\r\nI actually tried setting `MAX_SAMPLE_BUFFER_SIZE`  to `1 \u003c\u003c 25` _(33.554.432)_  and it still fails when the field is after. If the field is positioned before then it works.\r\n\r\n**Below are new examples showing the real boundaries I found:**\r\n```\r\n[StructLayout(LayoutKind.Sequential, Pack = 1)]\r\npublic unsafe struct SampleDataMemory_Works3\r\n{\r\n    public int index;\r\n    public fixed int data[(1 \u003c\u003c 25)];\r\n};\r\n```\r\n\r\n```\r\n[StructLayout(LayoutKind.Sequential, Pack = 1)]\r\npublic unsafe struct SampleDataMemory_Crash2\r\n{\r\n    public fixed int data[(1 \u003c\u003c 25)];\r\n    public int index;\r\n};\r\n```\r\n\r\n```\r\n[StructLayout(LayoutKind.Sequential, Pack = 1)]\r\npublic unsafe struct SampleDataMemory_Works4\r\n{\r\n    public fixed int data[(1 \u003c\u003c 25) - 4];\r\n    public int index;\r\n};\r\n```\r\n\r\n```\r\n[StructLayout(LayoutKind.Sequential, Pack = 1)]\r\npublic unsafe struct SampleDataMemory_Works5\r\n{\r\n    public fixed int data[(1 \u003c\u003c 25) - 4];\r\n    public fixed int data2[1 \u003c\u003c 25];\r\n};\r\n```\r\n\r\nAs long as I declare my second field BEFORE `(1 \u003c\u003c 25) - 4` I can declare whatever I want (int, bool or even another huge array as you can see in SampleDataMemory_Works5)",
                                           "updatedAt":  "2024-07-18T15:53:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6HpmzR",
                                           "createdAt":  "2024-08-08T13:27:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveisok",
                                           "body":  "As noted in https://github.com/dotnet/runtime/pull/104393#issuecomment-2274379768, we want to have the change apply for all runtimes. This will likely to through in .NET 10 as a result. ",
                                           "updatedAt":  "2024-08-08T13:27:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Hpnog",
                                           "createdAt":  "2024-08-08T13:28:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveisok",
                                           "body":  "@MichalStrehovsky since nativeaot is the only runtime left, I\u0027m assigning this issue to you. ",
                                           "updatedAt":  "2024-08-08T13:28:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6HprM3",
                                           "createdAt":  "2024-08-08T13:34:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "\u003e @MichalStrehovsky since nativeaot is the only runtime left, I\u0027m assigning this issue to you.\r\n\r\nCould you clarify what work you expect me to do? This is a customer running into this limit in the CoreCLR VM:\r\n\r\nhttps://github.com/dotnet/runtime/blob/61b00205666de26231ed36dd4124517817a759f4/src/coreclr/vm/field.h#L14-L20\r\n\r\nManaged type system (as used by crossgen2 or ILC) doesn\u0027t have such limit. I don\u0027t see #104393 doing _anything_ for this. There was a suggestion from Jan to print a better exception message but even that wasn\u0027t done in that PR (and could be done in a different PR too, since it\u0027s unrelated).",
                                           "updatedAt":  "2024-08-08T13:34:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6HpxNN",
                                           "createdAt":  "2024-08-08T13:45:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveisok",
                                           "body":  "My bad, I got crossed up between this and https://github.com/dotnet/runtime/issues/97412",
                                           "updatedAt":  "2024-08-08T13:45:11Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "unsafe struct fails with primitive field only when at the end of the sequence",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/106582",
        "createdAt":  "2024-08-18T05:07:24Z",
        "number":  106582,
        "author":  "timcassell",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC8waPw==",
                          "nodes":  [
                                        {
                                            "content":  "HEART",
                                            "user":  "dczuo",
                                            "createdAt":  "2024-08-18T06:17:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_DOWN",
                                            "user":  "teo-tsirpanis",
                                            "createdAt":  "2024-08-18T09:32:55Z"
                                        },
                                        {
                                            "content":  "CONFUSED",
                                            "user":  "omariom",
                                            "createdAt":  "2024-08-18T12:09:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-08-18T14:31:05Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "julealgon",
                                            "createdAt":  "2024-08-19T15:41:39Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "D3-LucaPiombino",
                                            "createdAt":  "2024-08-19T20:28:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "toupswork",
                                            "createdAt":  "2024-10-17T18:21:24Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "MineCake147E",
                                            "createdAt":  "2024-11-07T10:31:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Enderlook",
                                            "createdAt":  "2024-11-18T18:22:52Z"
                                        }
                                    ],
                          "totalCount":  9
                      },
        "updatedAt":  "2025-08-12T00:50:03Z",
        "body":  "### Background and motivation\n\nMotivating csharplang discussions: https://github.com/dotnet/csharplang/discussions/8343 https://github.com/dotnet/csharplang/discussions/7785\n\nToday, delegates are nominal types, and delegates with matching signatures are not interchangeable. `Func\u003cT, bool\u003e` != `Predicate\u003cT\u003e`. It would be ideal to be able to declare delegates by their signature rather than by their nominal type, similar to how function pointers can be declared. `delegate\u003cT, bool\u003e` (or whatever syntax C# decides to go with).\n\nMoreover, at a fundamental level, delegates need not be more than an object reference + a function pointer. The existing class-based delegates have a lot more baggage, making them less efficient than they theoretically could be.\n\n### Details\n\nThe runtime adds new structural delegate types, along with new IL metadata to use them.\n\nA delegate declared in assembly A `delegate\u003cT, bool\u003e` and a delegate declared in assembly B `delegate\u003cT, bool\u003e` are the exact same type, and therefore are identity convertible. `delegate\u003cref T, void\u003e` can be used also.\n\n`System.Delegate` type already exists, so a new base type can be added.\n\n```cs\nnamespace System;\n\npublic abstract class StructuralDelegate : ValueType\n{\n}\n```\n\nYes, structural delegates are struct-based instead of class-based. It essentially looks like this:\n\n```cs\npublic struct delegate\u003cT, TResult\u003e : IEquatable\u003cdelegate\u003cT, TResult\u003e\u003e\n{\n    private object _obj;\n    private void* _mPtr;\n    \n    // ...\n}\n```\n\nThese new structural delegates do not support Begin/EndInvoke or multi-cast like existing delegates.\n\nTo avoid possible tearing of the struct due to thread races, each read/write of a structural delegate will be made atomic by the runtime (this may be blocked by #105054 or #31911). If a struct contains structural delegate fields (or nested struct with structural delegate fields), copying that struct requires each structural delegate field to be copied atomically (the entire struct copy need not be atomic). As an optimization, the atomic r/w could be relaxed if the target is on the stack instead of the heap.\n\nAdditionally, to ensure that these structural delegate types are \"safe\" managed types, the GC should be taught to specially treat the function pointer as an ALC reference.\n\nThese types should also be specially treated similar to `Nullable\u003cT\u003e`, such that comparing to `null` becomes the same as comparing the pointer to zero, and boxing a default value results in a null object. With that in mind, `Nullable\u003cdelegate\u003c\u003e\u003e` may also need to be treated specially.\n\n---\n\nThere could also be additional APIs to convert to/from existing delegates, or bypassing the atomic r/w with Unsafe, and other APIs that exist for current delegates, but those can be left to future proposals if this ever goes anywhere.\n\n### Feature Usage\n\n```cs\npublic class MyEvent\u003cT\u003e\n{\n    // Not thread-safe, but this should get the point across.\n    private HashSet\u003cdelegate\u003cT, void\u003e\u003e _callbacks = new();\n\n    public void AddListener(delegate\u003cT, void\u003e callback)\n        =\u003e _callbacks.Add(callback);\n    \n    public void RemoveListener(delegate\u003cT, void\u003e callback)\n        =\u003e _callbacks.Remove(callback);\n    \n    public void Raise(T arg)\n    {\n        foreach (var callback in _callbacks.ToArray())\n        {\n            callback(arg);\n        }\n    }\n}\n```\n\n```cs\n// Very common pattern\npublic class MyComponent : IDisposable\n{\n    private readonly MyEvent\u003cint\u003e _event;\n    \n    public MyComponent(MyEvent\u003cint\u003e e)\n    {\n        _event = e;\n        // Existing delegate allocates here, new structural delegate does not allocate.\n        e.AddListener(OnEvent);\n    }\n    \n    public void Dispose()\n    {\n        // Existing delegate allocates here, new structural delegate does not allocate.\n        _event.RemoveListener(OnEvent);\n    }\n    \n    private void OnEvent(int arg)\n    {\n        // ...\n    }\n}\n```\n\n### Alternative Designs\n\n1. Structural delegates are class-based like existing delegates. This avoids the issue with atomic r/w and ALC reference, but also adds allocations and other overhead.\n\n2. Disregard atomic r/w and allow developers to shoot themselves in the foot (greatly simplifies implementation, but makes them unsafe).\n\n### Risks\n\nEnforcing atomic r/w could impact performance of shared generics in AOT runtimes.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOixWBfg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6IzYBL",
                                           "createdAt":  "2024-08-18T08:06:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODuqzZw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "neon-sunset",
                                                                               "createdAt":  "2024-08-18T09:05:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-08-18T14:31:08Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AlgorithmsAreCool",
                                                                               "createdAt":  "2024-08-18T19:31:56Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "This would be a massive feature request, rather than API request.\r\n\r\nI\u0027m positive to this, but I\u0027d hope we can include more if we are making changes to this.",
                                           "updatedAt":  "2024-08-18T08:06:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6IzeSL",
                                           "createdAt":  "2024-08-18T09:32:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODusozw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "neon-sunset",
                                                                               "createdAt":  "2024-08-18T10:09:19Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Symbai",
                                                                               "createdAt":  "2024-08-19T05:19:53Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "I am not sure that the need for this feature justifies the required work to design and implement it. The request already mentions metadata changes and three quite major special cases for the JIT, the GC and the type system. With function pointers being always available for the performance-minded people that don\u0027t care about capturing objects or unloadability, I cannot see what niche struct delegates would fill.\r\n\r\nSome of the ideas described here can be extracted into individual feature suggestions:\r\n\r\n* Treating different delegate types with the same signature (such as `Func\u003cT,bool\u003e` and `Predicate\u003cT\u003e`) as the same types in the eyes of the compiler and the runtime.\r\n* Adding an `()` operator like C++ has, or supporting directly invoking values of types with an `Invoke` method.\r\n* Allowing delegate type definitions to omit the `Begin`/`EndInvoke` methods.\r\n  * Isn\u0027t this already allowed?\r\n\r\n\u003e These new structural delegates do not support […] multi-cast like existing delegates.\r\nI remember reading that multicast delegates are pay-to-play, i.e. if you don\u0027t use them they won\u0027t affect performance.",
                                           "updatedAt":  "2024-08-18T09:32:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Izg6B",
                                           "createdAt":  "2024-08-18T10:08:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODuqGsg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-08-18T15:33:13Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "neon-sunset",
                                           "body":  "I think the way for successful structural delegates is a generalized shape provided by an interface abstraction (IDelegate, IAction, IFunc, etc.) that users can provide struct implementations for and constrain generic arguments on. Then Roslyn could target that by emitting anonymous struct-based delegate implementations for methods eligible for those. To better enable scenarios that are currently replicated by hand e.g in TensorPrimitives.\r\n\r\nNotably, function pointers are *not* a performance optimization in such case as they do not enable monorphization and subsequent inlining of delegate calls. Nor they enable struct or ref struct closures.",
                                           "updatedAt":  "2024-08-18T12:24:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Iz8_c",
                                           "createdAt":  "2024-08-18T16:37:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "\u003e I think the way for successful structural delegates is a generalized shape provided by an interface abstraction (IDelegate, IAction, IFunc, etc.) that users can provide struct implementations for and constrain generic arguments on. Then Roslyn could target that by emitting anonymous struct-based delegate implementations for methods eligible for those. To better enable scenarios that are currently replicated by hand e.g in TensorPrimitives.\r\n\r\nI understand that static genericity on functions instead of data types is sometimes needed, but I am not sure if it\u0027s a good idea to make this easily accessible by elevating it to a first-class language feature. I am concerned by its downsides (increase in generated machine code size and fragility when used across logical modules) and its potential for abuse which I have seen happening in C++.\r\n\r\n\u003e enable monorphization and subsequent inlining of delegate calls. Nor they enable struct or ref struct closures.\r\n\r\nHow common do you believe are the cases where this would be beneficial? I don\u0027t personally believe that merely low-level code like `TensorPrimitives` would meet the bar.",
                                           "updatedAt":  "2024-08-18T16:37:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6I1CF4",
                                           "createdAt":  "2024-08-19T03:37:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "\u003e This would be a massive feature request, rather than API request.\r\n\r\nVery true. I just worked from the issue template.\r\n\r\n\u003e I\u0027d hope we can include more if we are making changes to this.\r\n\r\nCan you elaborate?",
                                           "updatedAt":  "2024-08-19T03:37:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6I1Ej8",
                                           "createdAt":  "2024-08-19T03:49:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODuucZw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-08-19T09:30:55Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "timcassell",
                                           "body":  "\u003e I am not sure that the need for this feature justifies the required work to design and implement it.\r\n\r\nYeah, I kinda figured that would be the reaction to this proposal.\r\n\r\n\u003e I cannot see what niche struct delegates would fill.\r\n\r\nIt\u0027s a similar niche to ref structs, possibly wider reaching, since just about everyone uses delegates, while not everyone uses ref structs.\r\n\r\nConsidering the amount of effort put into improving performance and usability of safe managed code in .Net recently, this proposal is along the same trajectory, and shouldn\u0027t be dismissed just because it\u0027s a large amount of work, IMO.\r\n\r\n\u003e * Treating different delegate types with the same signature (such as `Func\u003cT,bool\u003e` and `Predicate\u003cT\u003e`) as the same types in the eyes of the compiler and the runtime.\r\n\r\nThat looks like an issue that has been open for 9 years with no action. #4331\r\nI don\u0027t know all the details about it, but I wouldn\u0027t be surprised if there are complications and possibly breaking changes by changing the type compatibility of existing delegates.\r\n\r\nThis proposal is a fresh start from scratch, new types, no worries about breaking anything.\r\n\r\n\u003e * Adding an `()` operator like C++ has, or supporting directly invoking values of types with an `Invoke` method.\r\n\r\nI\u0027m not sure where that came from. This proposal has absolutely nothing to do with an invoke operator.\r\n\r\n\u003e * Allowing delegate type definitions to omit the `Begin`/`EndInvoke` methods.\r\n\u003e   \r\n\u003e   * Isn\u0027t this already allowed?\r\n\u003e \r\n\u003e \u003e These new structural delegates do not support […] multi-cast like existing delegates.\r\n\u003e \u003e I remember reading that multicast delegates are pay-to-play, i.e. if you don\u0027t use them they won\u0027t affect performance.\r\n\r\nThose were mentioned, not because it may or may not be possible to exclude them on existing delegates, but just to highlight that the new types absolutely will _not_ support them.\r\n",
                                           "updatedAt":  "2024-08-19T04:11:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6I1FP1",
                                           "createdAt":  "2024-08-19T03:53:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "\u003e I think the way for successful structural delegates is a generalized shape provided by an interface abstraction (IDelegate, IAction, IFunc, etc.) that users can provide struct implementations for and constrain generic arguments on. Then Roslyn could target that by emitting anonymous struct-based delegate implementations for methods eligible for those. To better enable scenarios that are currently replicated by hand e.g in TensorPrimitives.\r\n\r\nThat looks like the functional interfaces proposal. https://github.com/dotnet/csharplang/issues/3452\r\n\r\nThat is similar to this proposal, but serves a different purpose. Namely, it can achieve zero allocation by using variable-sized structs, while this is a fixed-size type.\r\n",
                                           "updatedAt":  "2024-08-19T03:53:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6I4y3W",
                                           "createdAt":  "2024-08-19T13:32:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "julealgon",
                                           "body":  "Does this essentially make `Action` and `Func` types obsolete? Or would there be any scenario where they would still be wanted?",
                                           "updatedAt":  "2024-08-19T13:32:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6I4_mO",
                                           "createdAt":  "2024-08-19T13:55:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODuxZUA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "julealgon",
                                                                               "createdAt":  "2024-08-19T15:40:12Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "timcassell",
                                           "body":  "I think this would be the preferred delegate type to use in most situations, but I wouldn\u0027t say those would be obsolete. Tons of APIs exist today that use those delegate types, and those aren\u0027t going anywhere. If you want to use the multi-cast feature of delegates (C# `event`), and don\u0027t want to allocate a custom event class, you would use those types.",
                                           "updatedAt":  "2024-08-19T13:55:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6I5MUx",
                                           "createdAt":  "2024-08-19T14:17:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "neon-sunset",
                                           "body":  "\u003e How common do you believe are the cases where this would be beneficial? I don\u0027t personally believe that merely low-level code like `TensorPrimitives` would meet the bar.\r\n\r\n`TensorPrimitives` is simply the latest example of a general \"zero-cost value delegate\" case that numerous libraries need and have to reimplement today manually.\r\n\r\nThe lowest effort kind of improvement in this area comes down to simply introducing the aforementioned interfaces and teaching Roslyn that method invocation operator applies to types implementing them.\r\n\r\nThis can be subsequently augmented with Roslyn learning to generate anonymous struct and ref struct[^1] delegates with respective closure types, possibly offering better UX with generic arguments displayed as e.g. `Where\u003cint, impl IFunc\u003cint, bool\u003e\u003e`. Notably, the area of this change would belong to dotnet/csharplang and an API proposal to dotnet/runtime but would *not* require changes in the runtime itself, beyond API work in CoreLib.\r\n\r\nOnce done, this could open up the possibility to introduce value-delegate taking method overloads to `System.Linq` which would further cut down on LINQ overhead without introducing breaking changes to existing customers or them to make changes in order to gain performance. There are other callsites that would also benefit from this like `string.Create`. This is in spirit of similar changes like the introduction of `params ReadOnlySpan\u003cT\u003e`.\r\n\r\nAt the end of the day, this is but one of many possible ways to improve delegate/higher order func/lambda story, and as we\u0027ve seen with \"Runtime handled Tasks\", a more out-of-box proposal could be suggested.\r\n\r\n[^1]: https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-13#ref-struct-interfaces",
                                           "updatedAt":  "2024-08-19T14:21:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6I6lwR",
                                           "createdAt":  "2024-08-19T17:19:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "Finally have time to leave my words here.\r\n\r\nWith stack promotion finally being a thing, it\u0027s now less important for being struct or class. If we don\u0027t provide extra support for reflection etc, structs of 2-pointers size would be OK.\r\n\r\nI\u0027m more interested about how can we provide implementation about this. For nominal types, the pain is that we can\u0027t declare one method that satisfies different arities. Without changing this, the implementation of structural delegates can only be runtime magic. If we have variable arity support, we may declare them in ordinal managed code. Hypothetical syntax:\r\n\r\n```csharp\r\nstruct StructuralDelegate\u003c..TArgs, TReturn\u003e\r\n    where TReturn : allows ref struct, allows void\r\n{\r\n    private object? target;\r\n    private delegate*\u003cobject?, ..TArgs, TReturn\u003e fnptr;\r\n    public TReturn Invoke(..TArgs args) =\u003e fnptr(target, args);\r\n}\r\n```",
                                           "updatedAt":  "2024-08-19T17:19:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6I7Ij7",
                                           "createdAt":  "2024-08-19T18:39:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "julealgon",
                                           "body":  "\u003e With stack promotion finally being a thing, it\u0027s now less important for being struct or class.\r\n\r\n@huoyaoyuan would you mind elaborating a bit on this or just providing some link with more information about it? It is the first time I hear about it so I\u0027m curious.",
                                           "updatedAt":  "2024-08-19T18:39:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6I-hi9",
                                           "createdAt":  "2024-08-20T06:47:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODu6tOw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "timcassell",
                                                                               "createdAt":  "2024-08-20T08:31:37Z"
                                                                           },
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "julealgon",
                                                                               "createdAt":  "2024-08-20T13:26:59Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "julealgon",
                                                                               "createdAt":  "2024-08-20T13:27:01Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "\u003e \u003e With stack promotion finally being a thing, it\u0027s now less important for being struct or class.\r\n\u003e \r\n\u003e @huoyaoyuan would you mind elaborating a bit on this or just providing some link with more information about it? It is the first time I hear about it so I\u0027m curious.\r\n\r\nSee more at #103361, and more follow-up PRs.\r\n\r\nNote that I\u0027m not saying that allocation is *not a problem*. It\u0027s just having different impact now. Large structs have their issues.\r\nIf we can implement structural delegates in 2 pointers and cut unnecessary features, then struct should be better.",
                                           "updatedAt":  "2024-08-20T06:47:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6JB5pM",
                                           "createdAt":  "2024-08-20T14:17:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hez2010",
                                           "body":  "The idea is great, but I don\u0027t think such thing can be implemented in the proposed way. \r\nExisting generic metadata has too many restrictions like no support for variadic type parameters as well as `ref/in/out/void` parameters etc. I expect \"structural delegates\" to work like how function pointers work today, i.e., introducing new `TypeDesc` for structural delegates, and encoding structural delegate types directly in the signature. ",
                                           "updatedAt":  "2024-08-20T14:17:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6JGslT",
                                           "createdAt":  "2024-08-21T02:14:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "\u003e The idea is great\r\n\r\nWhy the downvote then? \r\n\r\n\u003e but I don\u0027t think such thing can be implemented in the proposed way. Existing generic metadata... \r\n\r\nI\u0027m not sure what you mean. I proposed to add new IL metadata.",
                                           "updatedAt":  "2024-08-21T02:14:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6JLrU-",
                                           "createdAt":  "2024-08-21T09:03:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODvJHAA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-08-21T13:02:08Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "julealgon",
                                                                               "createdAt":  "2024-08-21T15:13:24Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "D3-LucaPiombino",
                                                                               "createdAt":  "2024-08-21T19:18:12Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "timcassell",
                                           "body":  "\u003e I\u0027m more interested about how can we provide implementation about this. For nominal types, the pain is that we can\u0027t declare one method that satisfies different arities. Without changing this, the implementation of structural delegates can only be runtime magic. If we have variable arity support, we may declare them in ordinal managed code. Hypothetical syntax:\r\n\u003e \r\n\u003e ```cs\r\n\u003e struct StructuralDelegate\u003c..TArgs, TReturn\u003e\r\n\u003e     where TReturn : allows ref struct, allows void\r\n\u003e {\r\n\u003e     private object? target;\r\n\u003e     private delegate*\u003cobject?, ..TArgs, TReturn\u003e fnptr;\r\n\u003e     public TReturn Invoke(..TArgs args) =\u003e fnptr(target, args);\r\n\u003e }\r\n\u003e ```\r\n\r\nI really like the idea, and I think it deserves its own proposal. I would love to be able to write a method that can return `ValueTuple\u003c..TArgs\u003e`.",
                                           "updatedAt":  "2024-08-21T09:03:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6JOvQJ",
                                           "createdAt":  "2024-08-21T15:16:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "julealgon",
                                           "body":  "\u003e I really like the idea, and I think it deserves its own proposal. I would love to be able to write a method that can return `ValueTuple\u003c..TArgs\u003e`.\r\n\r\nI\u0027m sure I\u0027m missing something... I thought there would already be a proposal for variadic generics, but I searched both here and on `csharplang` and didn\u0027t find a single issue proposing it?\r\n\r\nI would\u0027ve assumed folks would be proposing that ever since generics was introduced 😅 \r\n\r\nMaybe it just got stuck in discussions and was never promoted to an issue?\r\n\r\nWould definitely be nice to finally stop needing to maintain dozens of variations of `Action`, `Func` and tuples, besides all other obvious benefits it would bring.",
                                           "updatedAt":  "2024-08-21T17:36:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6JPEs2",
                                           "createdAt":  "2024-08-21T15:54:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "Variadics don\u0027t necessarily translate well to generics. Despite generics and templates having similar syntax, they are not the same thing and the implications of them are drastically different. This is particularly relevant as it pertains to the general ABI (Application Binary Interface) of an exposed API.\r\n\r\nOutside of templates, variadic functions themselves necessitate a different calling convention and specialized support for parameters. There is no support for variadic returns on concrete methods even in C++. The reason variadic returns look like they exist for templates is because templates don\u0027t really exist, they\u0027re \"erased\" at C++ compilation time. That is, they\u0027re just symbols that get specialized based on their usage and synthesize types as part of compilation. You can\u0027t \"export\" them from a library, the non-specialized implementation needs to exist in the header itself, you can\u0027t do `RTTI` over some non specialized type, etc (there is no `typeof(List\u003c\u003e)` like .NET has). So from the ABI perspective, there is no `MyType\u003c...TArgs\u003e` return, there are many individual methods like `MyType\u003cint\u003e` or `MyType\u003cint, int\u003e`, etc  that happened to have used templates to simplify the implementation. -- They are more akin to the erased generics that Java does.\r\n\r\nVersioning IL metadata is also incredibly breaking and we want to avoid it wherever possible; so if you really want a feature then the best approach is to find a way it can be represented without needing to go and break the entire ecosystem, such as by using attributes or other mechanisms that let the runtime and languages work with it using the existing support. In some cases there might not be an obvious alternative and it may require such revisions to IL, but that also makes it drastically less likely to happen in the near term.",
                                           "updatedAt":  "2024-08-21T15:54:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6JPJxR",
                                           "createdAt":  "2024-08-21T16:04:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "\u003e Variadics don\u0027t necessarily translate well to generics. Despite generics and templates having similar syntax, they are not the same thing and the implications of them are drastically different. This is particularly relevant as it pertains to the general ABI (Application Binary Interface) of an exposed API.\r\n\r\nTo make it more clear: I\u0027m not talking about va_args in C, or managed va_args in IL/managed C++. Instead, I\u0027m requesting an general IL/C# syntax for \"any signature\". The signature is applicable to any calling convention because the using methods will just pass every arguments and returns as-is. It\u0027s effectively using signatures as generic parameters.\r\n\r\nIt\u0027s a goal of higher-kind generic, and will naturally cover many runtime magics for delegates.",
                                           "updatedAt":  "2024-08-21T16:04:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6JP2g_",
                                           "createdAt":  "2024-08-21T17:44:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOET8fZg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "p3p3pp3",
                                                                               "createdAt":  "2025-05-27T15:05:09Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "julealgon",
                                           "body":  "@tannergooding I\u0027m aware of the differences between C++ templates and the C# generics system. I wasn\u0027t trying to make any point about it being _easy_ or even _feasible_ for that matter to do variadic generics in C#, but just expressing surprise in not seeing a proposal case anywhere (not even a closed one). \r\n\r\nI think anyone would immediately frown upon seeing _this_ for the first time, and would immediately jump to such proposal:\r\n![image](https://github.com/user-attachments/assets/2987071c-b451-45ad-9157-1c73fbb31dd7)\r\n",
                                           "updatedAt":  "2024-08-21T17:44:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6JP6d4",
                                           "createdAt":  "2024-08-21T17:53:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODvICIA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "neon-sunset",
                                                                               "createdAt":  "2024-08-21T17:54:17Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "julealgon",
                                                                               "createdAt":  "2024-08-21T18:07:13Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "I was simply trying to give some suggestions on how to approach this in a way that would give the highest possibility of a solution being found.\r\n\r\nIf the community wants some variadic generics like support, then someone should start by writing up proposal which covers how it could integrate with existing IL metadata in a pay for play mechanism and some basics on how it could reasonably be handled in reflection, the type system, etc.\r\n",
                                           "updatedAt":  "2024-08-21T17:53:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6JQJXP",
                                           "createdAt":  "2024-08-21T18:29:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODvJJmg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "D3-LucaPiombino",
                                                                               "createdAt":  "2024-08-21T19:20:36Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "timcassell",
                                           "body":  "\u003e In some cases there might not be an obvious alternative and it may require such revisions to IL, but that also makes it drastically less likely to happen in the near term.\r\n\r\nTbh, I don\u0027t expect this feature to be implemented any time soon. Besides the IL revisions, there is also the atomic r/w of 2 pointers which has been requested for 8+ years, and new GC tracking of managed function pointers. \r\n\r\nThis is a chance to learn from 22 years of imperfect delegates, and to do it right from the ground up. I wouldn\u0027t want to shoe horn it into existing functionalities just to get it done faster if it\u0027s not the best it can be. \r\n",
                                           "updatedAt":  "2024-08-21T18:50:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6JRWYA",
                                           "createdAt":  "2024-08-21T21:15:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "We can\u0027t require atomic r/w of 2 pointers, its not guaranteed to exist.\r\n\r\nIt\u0027s one of the reasons we can\u0027t trivially expose a BCL API for it, although a hardware intrinsic per platform might be feasible.",
                                           "updatedAt":  "2024-08-21T21:15:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6JUv5v",
                                           "createdAt":  "2024-08-22T06:53:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODvZIZQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-08-22T22:29:35Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "timcassell",
                                           "body":  "\u003e We can\u0027t require atomic r/w of 2 pointers, its not guaranteed to exist.\r\n\u003e \r\n\u003e It\u0027s one of the reasons we can\u0027t trivially expose a BCL API for it, although a hardware intrinsic per platform might be feasible.\r\n\r\nIt doesn\u0027t have to be an API only for 2 pointers. The `BitwiseAtomic\u003cT\u003e` proposal (#105054) suggests to fall back to a SpinLock if the architecture doesn\u0027t support it. ",
                                           "updatedAt":  "2024-08-22T06:57:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6LFYF-",
                                           "createdAt":  "2024-09-06T07:40:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "\u003e I\u0027m sure I\u0027m missing something... I thought there would already be a proposal for variadic generics, but I searched both here and on `csharplang` and didn\u0027t find a single issue proposing it?\r\n\r\nI found this old issue on roslyn repo. https://github.com/dotnet/roslyn/issues/5058 Not really any newer issues since then, and LDM would not likely adopt the proposed solution (hacky, compiler-driven). Probably more likely to gain traction as a runtime feature.",
                                           "updatedAt":  "2024-09-06T07:40:18Z"
                                       }
                                   ],
                         "totalCount":  25
                     },
        "title":  "[Feature Proposal]: Structural Delegates",
        "labels":  [
                       "api-suggestion",
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/107140",
        "createdAt":  "2024-08-29T16:14:25Z",
        "number":  107140,
        "author":  "aloraman",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC6rGrw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ForNeVeR",
                                            "createdAt":  "2024-08-31T11:05:35Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-09-03T18:08:00Z",
        "body":  "**Disclaimer**: I\u0027m not sure if this is an intended language design issue (to be asked in csharplang repo), compiler bug (to be filed in roslyn repo) or API design/compatibility issue (to be filed in runtime repo). Therefore, I\u0027m filing this issue here in dotnet/runtime, in hopes it will be moved into a proper repo later. \r\n\r\nOne of C# 13 features announced in [What\u0027s new in C# 13](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-13#ref-struct-interfaces) is to enable ref structs to implement interfaces. It allows ref structs to implement IDisposable interface, moreover it allows them to implement IDisposable explicitly. Currently, when implemented both implicitly and explicitly, ref structs behave differently to other types, e.g. consider the following example:\r\n\r\n```csharp\r\nusing System;\r\n\r\nTestClass(new FooClass()); // Explicit\r\nTestStruct(new FooStruct()); // Explicit\r\nTestRefStruct(new FooRefStruct()); // Implicit!\r\n\r\nvoid TestClass(FooClass target) {using(target){}}\r\nvoid TestStruct(FooStruct target) {using(target){}}\r\nvoid TestRefStruct(FooRefStruct target) {using(target){}}\r\n\r\n\r\npublic class FooClass: IDisposable\r\n{\r\n  public void Dispose() =\u003e Console.WriteLine(\"Implicit\");\r\n  void IDisposable.Dispose() =\u003e Console.WriteLine(\"Explicit\");\r\n}\r\n\r\npublic struct FooStruct: IDisposable\r\n{\r\n  public void Dispose() =\u003e Console.WriteLine(\"Implicit\");\r\n  void IDisposable.Dispose() =\u003e Console.WriteLine(\"Explicit\");\r\n}\r\n\r\npublic ref struct FooRefStruct: IDisposable\r\n{\r\n  public void Dispose() =\u003e Console.WriteLine(\"Implicit\");\r\n  void IDisposable.Dispose() =\u003e Console.WriteLine(\"Explicit\");\r\n}\r\n```\r\n[Run at Sharplab](https://sharplab.io/#v2:EYLgtghglgdgNAFxAJwK7wCYgNQB8ACATAIwCwAUBQCoCmAzggMIA2EddAFDDQO4AEAMQD2Qlm04BKCQG4+Aejl8AogA8ADsygBjKAmr0EAZQRotCLr0Ejjp81NkLl6zTr3laDAEo0AZjdRmFvzCQt5+JgF2MvKKAJJgGtq6AIQUFPgALHweTKzsHCFi7HwIEMgA5jQIEnwA3vgADBylFVUStQC+HelZOf6BIf0IJWWV1XWNzaNtnd3kmdkGYUMFIssRZiOt4/VNLWPtXWmU8wDMfERWonl0IHyxACJQdGpCdBDAzDQUtRR8F+cFk8Xm8aBwagBeAB8F2IAE4OAAieKJVyImR/C5ZR7PV7vT40AB0wLxYMhMPw8KRqlRunR0goc3S5wYtiuQzuOJB+K+P0x+EBWRJoPBfGhsIRyISLjpGPI/wWXLxHy+xNxIvJEupziSCHpjOOAr4yF8fFZkSu61snOFPO+5F+8oBWL4trJYopVKltL1coV2NtKqJbtF4spkppMt9DPIHSAA)\r\n\r\nThat is, ref structs prefer implicit Dispose implementation, while every other type prefers explicit Dispose implementation, conforming to ECMA-334 spec.\r\n\r\nIs this intended design or a bug? If former, would it be possible to reconsider this? Now, it creates a weird behavior, the only purpose of which is to be a nasty puzzler for a programmer interview. If changed, it would be a breaking change, but a very minor one. \r\nTo observe such a breaking change, you\u0027ll need to explicitly add an IDisposable implementation to an existing ref struct with implicit Dispose method - which is somewhat of a breaking change in itself. Now, if such a struct is used in a Dispose statement - different overload will be called, so it is a source level breaking change, but it\u0027s no different from adding explicit Dispose implementation to any regular disposable type anyway. As far as I understand, this is not a binary breaking change - existing binaries that utilize ref struct Disposal have a direct call to implicit Dispose method on IL level anyway - so they will continue to call implicit implementations.\r\n\r\n**NB**\r\nI can\u0027t test it right now, but it\u0027d be interesting to see how consistent the behavior is with `allow ref struct` feature (I don\u0027t have NET 9.0 version locally with this feature enabled), i.e. what Dispose implementations would be chosen here:\r\n\r\n```csharp\r\nTestGeneric(new FooClass());\r\nTestGeneric(new FooStruct());\r\nTestGeneric(new FooRefStruct());\r\n\r\nvoid TestGeneric\u003cT\u003e(T target) where T:IDisposable, allow ref struct =\u003e {using(target){}}\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOirUqRA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6KLoBy",
                                           "createdAt":  "2024-08-29T16:30:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "\u003e Currently, when implemented both implicitly and explicitly\r\n\r\nThis should not be described as such. An interface method can only be implemented in one way in a type. The types are providing *explicit interface implementation* and *pattern matching based Dispose*.\r\n\r\nHistorically, when ref structs can\u0027t implement interfaces, the `using` support is done via pattern matching, not the `IDisposable` interface. Sample in C# 12:\r\n\r\n```csharp\r\n    public ref struct RS\r\n    {\r\n        public void Dispose()\r\n        {\r\n        }\r\n    }\r\n\r\n    public struct S\r\n    {\r\n        public void Dispose()\r\n        {\r\n        }\r\n    }\r\n\r\nusing (new RS()) { } // valid - pattern patching supported in ref struct\r\nusing (new S()) { } // invalid - other types must implement the interface\r\n```\r\n\r\nAnd by convention in C#, patter matching based language feature are preferred over interface based:\r\n\r\n```csharp\r\n    public class C : IEnumerable\u003cint\u003e\r\n    {\r\n        IEnumerator\u003cint\u003e IEnumerable\u003cint\u003e.GetEnumerator()\r\n        {\r\n            Console.WriteLine(\"Interface\");\r\n            return new List\u003cint\u003e().GetEnumerator();\r\n        }\r\n\r\n        IEnumerator IEnumerable.GetEnumerator() =\u003e ((IEnumerable\u003cint\u003e)this).GetEnumerator();\r\n\r\n        public IEnumerator\u003cint\u003e GetEnumerator()\r\n        {\r\n            Console.WriteLine(\"Pattern matching\");\r\n            return new List\u003cint\u003e().GetEnumerator();\r\n        }\r\n    }\r\n\r\n            foreach (var _ in new C())\r\n            {\r\n                // Prints \"Pattern matching\"\r\n            }\r\n```",
                                           "updatedAt":  "2024-08-29T16:30:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6KLoym",
                                           "createdAt":  "2024-08-29T16:31:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "This is a language question for https://github.com/dotnet/csharplang/discussions . It\u0027s a bit inconsistent that pattern matching based members aren\u0027t considered for non-ref structs, but changing that would be a (slight) breaking change.",
                                           "updatedAt":  "2024-08-29T16:31:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6KszFQ",
                                           "createdAt":  "2024-09-03T16:50:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ivdiazsa",
                                           "body":  "\u003e This is a language question for https://github.com/dotnet/csharplang/discussions . It\u0027s a bit inconsistent that pattern matching based members aren\u0027t considered for non-ref structs, but changing that would be a (slight) breaking change.\r\n\r\nHi @aloraman! As explained in this reply, this is more fitting for a csharplang discussion. Please start up a thread over there, and link it here, so we can keep track of how such discussion goes, and later on do whatever work is needed, if any.",
                                           "updatedAt":  "2024-09-03T16:50:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6KtSpE",
                                           "createdAt":  "2024-09-03T18:07:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODw2Y7Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ivdiazsa",
                                                                               "createdAt":  "2024-09-03T19:10:27Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "aloraman",
                                           "body":  "Made a discussion in csharplang repo.\r\nhttps://github.com/dotnet/csharplang/discussions/8405",
                                           "updatedAt":  "2024-09-03T18:07:59Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Intended behavior of explicit IDisposable.Dispose implementations in ref structs.",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/108173",
        "createdAt":  "2024-09-24T08:14:18Z",
        "number":  108173,
        "author":  "ShadedBlink",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC7R-gQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "timcassell",
                                            "createdAt":  "2024-09-24T18:16:36Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-07-01T16:35:39Z",
        "body":  "### Background and motivation\r\n\r\nSometimes there are cases when you have multiple fields in object and want to store a reference to one of them for a long time, like in async code. Today you have to keep a reference to the object then decide required field in the target method.\r\n```csharp\r\nclass C1 {\r\n\tpublic int Field1;\r\n\tpublic int Field2;\r\n}\r\n\r\nasync Task MethodAsync(C1 obj, int targetField) {\r\n\tawait Task.Delay(1000);\r\n\tif (targetField == 1) {\r\n\t\tobj.Field1 = 123;\r\n\t} else {\r\n\t\tobj.Field2 = 123;\r\n\t}\r\n}\r\n\r\nasync Task TestAsync() {\r\n\tvar x1 = new C1();\r\n\tawait MethodAsync(x1, 1);\r\n}\r\n```\r\nStack references won\u0027t survive first `await`, while object references are still alive. In following case first part is totally safe, but it won\u0027t compile because `MethodAsync()` is not sure whether `output` would be alive till the method\u0027s end.\r\n```csharp\r\nclass C1 {\r\n\tpublic int Field;\r\n}\r\n\r\nasync Task MethodAsync(ref int output) {\r\n\tawait Task.Delay(1000);\r\n\toutput = 123;\r\n}\r\n\r\nasync Task TestAsync() {\r\n\t// safe\r\n\tvar x1 = new C1();\r\n\tawait MethodAsync(ref x1.Field);\r\n\tConsole.WriteLine(x1.Field);\r\n\r\n\t// unsafe\r\n\tvar x2 = 321;\r\n\tawait MethodAsync(ref x2);\r\n\tConsole.WriteLine(x2);\r\n}\r\n```\r\n\r\n### API Proposal\r\n\r\nTo solve such problem we can implement `safe ref` type of reference, which is guaranteed to be alive till the end of usage.\r\n```csharp\r\nclass C1 {\r\n\tpublic int Field;\r\n}\r\n\r\nclass C2 {\r\n\tpublic safe ref int Field; // Totally okay and doesn\u0027t require `C2` to be marked like `ref class` since we don\u0027t have to limit lifetime of `C2` - `C2` will be the reason to keep alive the target of `Field`.\r\n}\r\n\r\nasync Task MethodAsync(safe ref int output) {\r\n\tawait Task.Delay(1000);\r\n\toutput = 123;\r\n}\r\n```\r\n\r\nConversions:\r\n```\r\nsafe ref -\u003e ref // implicit\r\nsafe ref -\u003e pointer // explicit through `fixed` semantics\r\nref -\u003e safe ref // unsafe\r\npointer -\u003e safe ref // unsafe\r\n```\r\n\r\n`fixed` semantics:\r\nSame as with `ref`, we just pin given object that can be discovered through this address.\r\n\r\n### API Usage\r\n\r\n```csharp\r\nasync Task TestAsync() {\r\n\t// safe\r\n\tvar x1 = new C1();\r\n\tawait MethodAsync(ref x1.Field); // Compiles, because object reference can be kept alive till the end of `MethodAsync()`.\r\n\tConsole.WriteLine(x1.Field);\r\n\r\n\t// unsafe\r\n\tvar x2 = 321;\r\n\tawait MethodAsync(ref x2); // Compilation error? As I know, `AsyncStateMachine` is first allocated on stack, then it may be copied to object. Thus previous reference is invalid. GC should update previous reference, but it should not replace it with object\u0027s one. Up to discussions. \r\n\tConsole.WriteLine(x2);\r\n}\r\n\r\nvoid TestSync() {\r\n\t// unsafe\r\n\tvar x = 321;\r\n\tawait MethodAsync(ref x); // Just compilation error, since `MethodAsync()` is not guaranteed to complete till the end of `TestSync()`.\r\n\tConsole.WriteLine(x);\r\n}\r\n```\r\n\r\n### Alternative Designs\r\n\r\n```\r\nstrong ref\r\nheap ref\r\nobjref\r\n```\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOmUNFKQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6NTLIz",
                                           "createdAt":  "2024-09-24T08:30:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "This is not simply achievable as an API. For example, `Memory\u003cT\u003e` has to use two fields to store the array and offset, instead of one `ref` like `Span\u003cT\u003e`. The GC needs to be tweaked to allow interior references from heap object. The new ref type will only be allowed to point to heap locations.\r\n\r\nThe C# syntax is the last piece for such a feature. It should first be designed for CLR type system, like #63768 and #32060 for ref field on stack.",
                                           "updatedAt":  "2024-09-24T08:30:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6NTMdL",
                                           "createdAt":  "2024-09-24T08:32:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "Also note that the value would be much lower than `ref` field in spans. Unlike span access on stack, heap spilling and task suspensions has much more overhead than retrieving fields.",
                                           "updatedAt":  "2024-09-24T08:32:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6NTZI7",
                                           "createdAt":  "2024-09-24T08:54:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "Another approach would be a `Memory\u003cT\u003e`-like `HeapRef\u003cT\u003e` struct, just without the length field and MemoryManager support. Example API:\r\n\r\n```csharp\r\npublic readonly struct HeapRef\u003cT\u003e\r\n{\r\n    private readonly object _object;\r\n    private readonly nint _offset;\r\n\r\n    public HeapRef(object obj, RuntimeFieldHandle field); // safe constructor\r\n    public HeapRef(T[] array, nint offset);\r\n    public HeapRef(string, nint offset);\r\n\r\n    public unsafe ref T Get() =\u003e ref Unsafe.As\u003cbyte, T\u003e(ref Unsafe.AddByteOffset(ref Unsafe.As\u003cRawData\u003e(_object).Data, _offset));\r\n}\r\n```",
                                           "updatedAt":  "2024-09-24T08:56:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6NT2p7",
                                           "createdAt":  "2024-09-24T09:44:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ShadedBlink",
                                           "body":  "\u003e This is not simply achievable as an API. For example, Memory\u003cT\u003e has to use two fields to store the array and offset, instead of one ref like Span\u003cT\u003e. The GC needs to be tweaked to allow interior references from heap object. The new ref type will only be allowed to point to heap locations.\r\n\r\nYes, I understand that, that\u0027s why I posted this proposal here, not in `csharplang` repo. As for GC tweaks, I believe it to be less hurtfull as ref fields were added not long ago. This proposal just extrapolates this feature on object fields. Yeah, it still may be problematic, but definitely not impossible.\r\n\r\n\u003e Also note that the value would be much lower than ref field in spans. Unlike span access on stack, heap spilling and task suspensions has much more overhead than retrieving fields.\r\n\r\nI believe that there should not be any sensible performance overhead for this proposal. The target object resolving behaviour should be totally equal to current `ref` behaviour, because `safe ref` works exactly like `ref`. `safe` is just a modifier that limits usage of `ref` to objects. The GC seeking of alive objects should be equal to current object reference and `ref` collection. GC already iterates over all reference fields, we just add `ref` fields to them as well. As for calculating byte offset to reach original object, we already doing it for `ref`, so there is nothing new.\r\nPractical value of this implementation may not be as huge as ref fields in structs, but it is also not as hard to develop as ref fields in structs, because most of prerequisites are already implemented with those ref fields feature, we just need to extend and adapt them for this case.\r\n\r\n\u003e Another approach would be a Memory\u003cT\u003e-like HeapRef\u003cT\u003e struct, just without the length field and MemoryManager support.\r\n\r\nVery good idea that I am already using in another form, and it also can be used for backwards compatibility like good old times `ByRef\u003c\u003e`.  Yet it is too rough to include in any public implementation, because you have to manually resolve and store offsets.",
                                           "updatedAt":  "2024-09-24T09:44:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6NT_4F",
                                           "createdAt":  "2024-09-24T10:01:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "\u003e I believe that there should not be any sensible performance overhead for this proposal. The target object resolving behaviour should be totally equal to current `ref` behaviour, because `safe ref` works exactly like `ref`. `safe` is just a modifier that limits usage of `ref` to objects. The GC seeking of alive objects should be equal to current object reference and `ref` collection. GC already iterates over all reference fields, we just add `ref` fields to them as well. As for calculating byte offset to reach original object, we already doing it for `ref`, so there is nothing new.\r\n\r\nNo, it works different for GC. GC currently only expects `ref`s from stack, not from heap itself. I can\u0027t say the effort required by GC, but it does need change.\r\n\r\n\u003e Practical value of this implementation may not be as huge as ref fields in structs, but it is also not as hard to develop as ref fields in structs, because most of prerequisites are already implemented with those ref fields feature, we just need to extend and adapt them for this case.\r\n\r\nThey are indeed much different in area of implementations. GC was already supporting interior `ref`s, so the work are mostly in type loader. In the other hand, to enable heap reference within the heap, GC has to be changed, as well as the type loader.\r\n\r\n`ref` was a long concept in the CLR type system. The ref field feature only extends where it can exist. However, the new heap reference is an entirely new concept, although it works similar to `ref`. There need to be enforcement or verification to prevent stack references to be stored into heap, etc.\r\n\r\n----\r\n\r\nA new `Memory\u003cT\u003e` like struct would really be the simpler and reliable solution. That probably why `Memory\u003cT\u003e` was implemented with 3 fields while `Span\u003cT\u003e` was in 2. The extra addition instruction can really be negligible.\r\n\r\n\u003e Yet it is too rough to include in any public implementation, because you have to manually resolve and store offsets.\r\n\r\nIf we have that, we can have the C# language and JIT to incorporate to simplify it. For example, C# compiler can compile `magicsyntax(obj, field1)` into `new HeapRef\u003cField1Type\u003e(obj, constant(FieldHandle))`, and the JIT can see the object type and constant field handle and emit the offset as a constant.",
                                           "updatedAt":  "2024-09-24T10:01:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6NVTQu",
                                           "createdAt":  "2024-09-24T12:45:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "Would something along these lines be possible? It\u0027s more widely applicable (since it can work with all `ref`s, even if you no longer know the `object` it\u0027s a part of)?\r\n\r\n```csharp\r\nnamespace System.Runtime.InteropServices;\r\n//or similar scary namespace as this type is not intended to be safe (this is the low-level, max performance API for it) - you could write safe wrappers also or on top yourself and do basically whatever with the below design though\r\n//a safe one would probably need a class to control when it gets copied, etc.\r\n//also could have a safe c# feature built on top to only allow provably safe uses (e.g., only on heap), but would be nice for it to still support unmanaged memory and null like with normal interior refs, but getting these would obviously require some amount of unsafe code \u0026 would require manual verification\r\n\r\n/*\r\nWhen a GC happens:\r\n- If _interiorRef is not null - _interiorRef is set to null \u0026 it is converted to object + offset, or null + offset (for unmanaged pointer) when the GC happens\r\n- Otherwise, we can just rely on looking at _object to see what object we need to keep alive\r\n*/\r\n\r\nstruct InteriorRef\u003cT\u003e\r\n{\r\n    //we could technically probably get away with just object + offset if we have a sentinel object meaning \"this is an interior ref\" - I\u0027ve ignored that to make it simpler since it\u0027s just an optimisation\r\n    private void* _interiorRef; //gc has special knowledge about this field\r\n    private object? _object;\r\n    private nuint _offset;\r\n\r\n    public readonly ref T Reference\r\n    {\r\n        //nogc begin\r\n        var interiorRef = _interiorRef;\r\n        if (interiorRef != null) return ref *(T*)interiorRef; //we haven\u0027t converted to object + offset yet\r\n        else return Unsafe.As\u003cbyte, T\u003e(ref Unsafe.Add(ref Unsafe.GetFieldData(_object) /* returns null ref for null object */, _offset));\r\n        //nogc end\r\n    }\r\n\r\n    public void Set(ref T reference)\r\n    {\r\n        //nogc begin\r\n        _interiorRef = Unsafe.AsPointer(ref reference); //gc will treat as an interior ref at next relevant point in time, when it converts it to object + offset\r\n        _object = null;\r\n        _offset = 0;\r\n        //nogc end\r\n    }\r\n\r\n    public void SetWithObject(ref T reference, object? o)\r\n    {\r\n        //nogc begin\r\n        _interiorRef = null;\r\n        _object = o;\r\n        _offset = Unsafe.ByteOffset(ref Unsafe.As\u003cbyte, T\u003e(ref Unsafe.GetFieldData(o) /* null byref for null */, ref reference));\r\n        //nogc end\r\n    }\r\n    \r\n    public readonly void CopyTo(out InteriorRef\u003cT\u003e value) //safe helper for copying, since normal copy wouldn\u0027t necessarily stop GC from running half-way in (may not be necessary if that\u0027s easy to to)\r\n    {\r\n        //nogc begin\r\n        value = this;\r\n        //nogc end\r\n    }\r\n    \r\n    public readonly InteriorRef\u003cTOther\u003e UnsafeAs\u003cTOther\u003e =\u003e ...; //same idea as CopyTo - a correct method for re-interpreting the reference (while still being able to keep as object + offset if already changed to that), still an unsafe op though obviously\r\n    \r\n    //other: UnsafeAddByteOffset, and any other strictly necessary APIs (to avoid making unnecessary work for GC converting interior ref to object + offset as much as possible)\r\n}\r\n```",
                                           "updatedAt":  "2024-09-24T13:22:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6NkaKR",
                                           "createdAt":  "2024-09-25T19:56:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ShadedBlink",
                                           "body":  "@huoyaoyuan \r\n\u003e No, it works different for GC. GC currently only expects refs from stack, not from heap itself. I can\u0027t say the effort required by GC, but it does need change.\r\n\r\nOf course it will need changes, I don\u0027t object to that. I understand that it is not implemented yet, I just want to say that we have pretty similar mechanics that are already in use by GC. It already iterates over each object in heap to collect normal object references, so we can add `ref` collecting there, i.e. walk over both references and `ref`s. When GC encounters `ref` during that iteration, it just has to apply same logic that it already uses on the stack.\r\n\r\n\u003e They are indeed much different in area of implementations. GC was already supporting interior refs, so the work are mostly in type loader. In the other hand, to enable heap reference within the heap, GC has to be changed, as well as the type loader.\r\n\r\nI don\u0027t know the implementation details of GC in these matters, I just see that `safe ref` and object reference are pretty much similar. It\u0027s more like a `safe ref` is a normal object reference with offset. Such similarity makes me think that we just have to extend normal object reference logic to support offsets. As I know, current `ref` implementation is done this way, that target object is resolved through given address. If we reuse this logic in object reference resolving mechanic, it should deal with this case - this won\u0027t be a third reference type, it would be just an extension over normal object references.\r\n\r\n\u003e There need to be enforcement or verification to prevent stack references to be stored into heap, etc.\r\n\r\nWe can just use same rules that we use for object references at the moment - any way to create or modify a `safe ref` outside of normal `ref obj.Field` should be treated equally to an attempt to create or modify an object reference.\r\n\r\n\u003e If we have that, we can have the C# language and JIT to incorporate to simplify it. For example, C# compiler can compile magicsyntax(obj, field1) into new HeapRef\u003cField1Type\u003e(obj, constant(FieldHandle)), and the JIT can see the object type and constant field handle and emit the offset as a constant.\r\n\r\n I am totally okay with that, it looks like a temporary solution like old `ByRef\u003c\u003e` that is transparent to users and can be later transformed to a true native `safe ref` implementation without any changes to user code.",
                                           "updatedAt":  "2024-09-25T20:30:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Nkl7n",
                                           "createdAt":  "2024-09-25T20:22:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ShadedBlink",
                                           "body":  "\u003e Would something along these lines be possible? It\u0027s more widely applicable (since it can work with all refs, even if you no longer know the object it\u0027s a part of)?\r\n\r\nActually I see no difference from @huoyaoyuan proposal of `HeapRef\u003c\u003e`. The problem that I see in this approach is not in performance, but in usability. You have to pass both object and field and also have to make sure that they are connected. And manual construction of a custom type when you just need a reference to a damned `int` looks even more sad.\r\nYeah, we need a C# support for `safe ref` atleast. It won\u0027t be as ugly if these `InteriorRef\u003c\u003e`, `HeapRef\u003c\u003e` or `SafeRef\u003c\u003e` won\u0027t be directly mentioned in user code.",
                                           "updatedAt":  "2024-09-25T20:22:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6NktN0",
                                           "createdAt":  "2024-09-25T20:38:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ShadedBlink",
                                           "body":  "\u003e If we have that, we can have the C# language and JIT to incorporate to simplify it. For example, C# compiler can compile magicsyntax(obj, field1) into new HeapRef\u003cField1Type\u003e(obj, constant(FieldHandle)), and the JIT can see the object type and constant field handle and emit the offset as a constant.\r\n\r\nSo for this approach we have to add a `HeapRef\u003c\u003e` to dotnet API and add a `safe ref` concept to C#, i.e. when argument or field is declared as `safe ref`, it is compiled as an instance of `HeapRef\u003c\u003e`. C# then should insert conversions between `HeapRef\u003c\u003e` and `ref`.\r\n\r\n- `safe ref int x` compiles to `HeapRef\u003cint\u003e x`\r\n- `ref obj.Field` compiles to `new HeapRef(obj, in obj.Field)`\r\n- `ref safeRef` compiles to `ref safeRef.Get()`\r\n- `fixed (int* ptr = \u0026safeRef)` compiles to `fixed (int* ptr = \u0026safeRef.Get())`",
                                           "updatedAt":  "2024-09-25T20:41:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Nk6CV",
                                           "createdAt":  "2024-09-25T21:08:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "\u003e As I know, current ref implementation is done this way, that target object is resolved through given address.\r\n\r\nOnly at gc time as required. It does not explicitly track the object, it points directly to the field within the object itself.\r\n\r\n\u003e Actually I see no difference from @huoyaoyuan proposal of `HeapRef\u003c\u003e`. The problem that I see in this approach is not in performance, but in usability. You have to pass both object and field and also have to make sure that they are connected. And manual construction of a custom type when you just need a reference to a damned `int` looks even more sad.\r\n\r\nThe difference is that ref does not explicitly track the object. You cannot find the object from a ref yourself today - this is something only the gc can do. If we got `GetFieldData` you would be able to easily implement the HeapRef\u003cT\u003e mentioned, but you would not be able to convert a ref T to a `HeapRef\u003cT\u003e` in general (you\u0027d need to change the code all the way back when you got the ref itself). Whereas my `InteriorRef\u003cT\u003e` explicitly supports all valid ref Ts due to its requirements for the GC.\r\n\r\nAs I said, you would have appropriate safe APIs / language features built on top of this low level API. If you never wanted to touch the low level api in your code, you shouldn\u0027t have to, but if you needed it then you\u0027d be able to.\r\n\r\nMy approach supports all the things `HeapRef\u003cT\u003e` does (via its `SetWithObject` API), but also supports setting from a normal interior reference (`ref T`). It also comes with added implementation complexity as a result (that is the GC needs to be able to update the fields in the way I mentioned).\r\n\r\n\u003e Yeah, we need a C# support for `safe ref` atleast. It won\u0027t be as ugly if these `InteriorRef\u003c\u003e`, `HeapRef\u003c\u003e` or `SafeRef\u003c\u003e` won\u0027t be directly mentioned in user code.\r\n\r\nI have no issue with a safe c# feature existing obviously, but having the low level types is important for some of us, and I for one would certainly have uses for them in my code.",
                                           "updatedAt":  "2024-09-25T21:11:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Nn57x",
                                           "createdAt":  "2024-09-26T06:31:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ShadedBlink",
                                           "body":  "\u003e Only at gc time as required. It does not explicitly track the object, it points directly to the field within the object itself.\r\n\r\nWell, that\u0027s exactly when `ref` object is required. You keep a `safe ref int x` because you need an integer address, not an initial object. Keyword `safe` is just needed to ensure that `ref` will be alive till the moment you don\u0027t need it anymore. Even more, it would be right to ensure that user code won\u0027t be allowed to discover initial object.\r\n\r\n\u003e The difference is that ref does not explicitly track the object. You cannot find the object from a ref yourself today - this is something only the gc can do.\r\n\r\nOf course, `ref` tracks objects implicitly. And that\u0027s exactly what is needed. All we need object for is to keep it alive, thus we don\u0027t care whether we can get object itself - all we need is that GC will keep it alive because we still have that `safe ref`, which is treated as alive reference. And that\u0027s exactly why I noted in proposal that you can convert `safe ref` to `ref`(because `ref` will still keep object alive as `ref` can\u0027t escape stack), but you can\u0027t convert `ref` to `safe ref` as `ref` is not guaranteed to refer an object, thus `ref` is not guaranteed to be still valid on heap.\r\n\r\n\u003e If we got GetFieldData you would be able to easily implement the HeapRef mentioned, but you would not be able to convert a ref T to a HeapRef\u003cT\u003e in general (you\u0027d need to change the code all the way back when you got the ref itself). Whereas my InteriorRef\u003cT\u003e explicitly supports all valid ref Ts due to its requirements for the GC.\r\n\r\nYour `InteriorRef\u003c\u003e` is **unsafe** because it just stores `ref` as pointer. We can easily create instance of your `InteriorRef\u003c\u003e` from a stack variable then return this struct, thus immediately rendering it\u0027s pointer address invalid, and your `InteriorRef\u003c\u003e` won\u0027t be notified in any way. GC never cares about stack pops, only compiler do.\r\n```csharp\r\nInteriorRef\u003cint\u003e Method() {\r\n    var x = 123;\r\n    var result = new InteriorRef\u003cint\u003e();\r\n    result.Set(ref x);\r\n    return result;\r\n}\r\n```",
                                           "updatedAt":  "2024-09-26T06:33:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6NpEuv",
                                           "createdAt":  "2024-09-26T08:55:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "\u003e Your `InteriorRef\u003c\u003e` is **unsafe** because it just stores `ref` as pointer.\r\n\r\nAs I mentioned in the second block of comments - the GC would be expected to handle it specially for updating it and liveness analysis as to not cause issues by just storing it as a \"normal pointer\":\r\n\r\n```\r\nWhen a GC happens:\r\n- If _interiorRef is not null - _interiorRef is set to null \u0026 it is converted to object + offset, or null + offset (for unmanaged pointer) when the GC happens\r\n- Otherwise, we can just rely on looking at _object to see what object we need to keep alive\r\n```\r\n\r\nThe above is even a simplified explanation of would most likely actually happen, as e.g., not all GCs need to look at all objects - but it should get the idea across of how it could work.\r\n\r\n\u003e We can easily create instance of your InteriorRef\u003c\u003e from a stack variable then return this struct, thus immediately rendering it\u0027s pointer address invalid, and your InteriorRef\u003c\u003e won\u0027t be notified in any way. GC never cares about stack pops, only compiler do.\r\n\r\nIt\u0027s intended to be a low-level API that higher-level safe APIs can be built on, like I mentioned. This is like how `Span\u003cT\u003e` and its extension methods is built on top of `Unsafe`, `MemoryMarshal`, `unsafe` blocks, etc.\r\n\r\n\u003e Keyword `safe` is just needed to ensure that `ref` will be alive till the moment you don\u0027t need it anymore\r\n\r\nNormal refs keep things alive too... The only difference with your \"safe\" ref is that its value must have a specific lifetime (that being - must refer to heap memory) - this has no impact on the viability of runtime/GC support for refs being stored on the heap, only for verifiability/safety (which I\u0027m not saying is meaningless/unimportant to be clear) - unless I\u0027m missing something or not understanding what you\u0027re saying, your `safe ref` sounds like a purely language feature which needs to be built on top of a runtime/GC feature of allowing some form of interior references to be stored on the heap - I don\u0027t see any reason to disallow unmanaged/stack references for these from a runtime/GC POV (it\u0027s quite easy for the GC to check if a managed pointer may need to be updated \u0026 tracked to keep its target object alive - the more difficult part is figuring out precisely which object; see `GetContainingObject` in `gc.cpp` for example, it calls into `is_in_find_object_range` which does 3 comparisons basically to figure out if it is definitely a non-managed-heap pointer very quickly (insert asterisks, but you get the idea)) and there are provably safe/valid uses of such things (e.g., giving a ref that happens to point into the stack, but that you know won\u0027t be used after the method exists (also it\u0027s not passed across threads), or pointing into native memory where you\u0027d only deallocate it when it\u0027s not being used anymore, etc.), but it would be up to the programmer to verify that it is actually safe without stuff like delegate \"lifetimes\" or similar, which is why a language feature could say \"you can only safely create references to the heap for this\" but should not disallow unsafe code (by which I am referring to specifically, programmer-instead-of-compiler-verified-safety meaning of unsafe) to create non-managed-heap byrefs for this feature.\r\n\r\n\u003e \u003e Only at gc time as required. It does not explicitly track the object, it points directly to the field within the object itself.\r\n\r\n\u003e Well, that\u0027s exactly when `ref` object is required. You keep a `safe ref int x` because you need an integer address, not an initial object.\r\n\r\nThe reason I clarified this is because you demonstrated you didn\u0027t know the difference:\r\n\r\n\u003e Actually I see no difference from @huoyaoyuan proposal of HeapRef\u003c\u003e.\r\n\r\n\u003e You have to pass both object and field and also have to make sure that they are connected.\r\n\r\nTo clarify again, the @huoyaoyuan\u0027s proposal requires you to know which object it comes from at construction time (by design), whereas mine doesn\u0027t require that you know this (but can still benefit from this info when available).",
                                           "updatedAt":  "2024-09-26T09:02:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6NvTdS",
                                           "createdAt":  "2024-09-26T21:40:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ShadedBlink",
                                           "body":  "\u003e As I mentioned in the second block of comments - the GC would be expected to handle it specially for updating it and liveness analysis as to not cause issues by just storing it as a \"normal pointer\"\r\n\r\n_tldr: They are opposite in terms of lifetime - `ref` is used to limit usage of reference to the target\u0027s scope, while `safe ref` is used to extend usage of reference outside of any scope._\r\nGC is not involved with stack pops at all. You return from method - GC is not even invoked. That\u0027s why all `ref` are stack-bound - GC can\u0027t keep stack references alive because it will require GC to be performed on every return from any method.\r\nIn case of `ref`, the `ref` lifetime is limited to target\u0027s scope(`ref` ensures that `ref` lives no more than it\u0027s target), while in case of `safe ref` target\u0027s lifetime is extended to `safe ref` lifetime - it ensures that target object lives not less than `safe ref`. `ref` can\u0027t escape it\u0027s scope because it is not guaranteed that it\u0027s target exists outside of it\u0027s scope, while for `safe ref` it is guaranteed that it\u0027s target is definitely not limited to any scope.\r\nI understand that you want to have single container for both object and free references, but it is still unsafe till you solve given problem:\r\n```csharp\r\nInteriorRef\u003cnint\u003e CreateRef(nint value) {\r\n    var x = value;\r\n    var result = new InteriorRef\u003cnint\u003e();\r\n    result.Set(ref x); // No error since we set a real reference.\r\n    return result; // No error since InteriorRef\u003c\u003e is not limited to current scope.\r\n}\r\n\r\nnint Increment(ref nint x) {\r\n    var oldValue = x;\r\n    x = x + 1;\r\n    return oldValue;\r\n}\r\n\r\nvoid Main() {\r\n    ref var x = ref CreateRef(1);\r\n    Increment(ref x);\r\n    Assert.IsTrue(x == 1); // Error! x is 2!\r\n}\r\n```\r\nIn given example when you return from `CreateRef()` you get a reference to a stack variable that won\u0027t be cleared on return from `CreateRef()`, because GC is not invoked on method return. It is too heavy to invoke GC cleanup for `refs` on every return from method. When you enter in `Increment()` variable `oldValue` is allocated on the same place that `x` was previously allocated in `CreateRef()`, thus in `Increment()` `\u0026x` is equal to `\u0026oldValue`.\r\nThat\u0027s exactly why your proposal is unsafe. If you just want a pointer that can keep object alive if pointed to object, your proposal then should be called `unsafe ref`. Of course, there is a point in such tool as well, but it is pretty different from my proposal of `safe ref`, and I don\u0027t think that they can be compared - they have different purposes.",
                                           "updatedAt":  "2024-09-26T21:40:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6NvwJr",
                                           "createdAt":  "2024-09-26T23:16:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "Please read all of my response, but the main point is this:\r\n\r\nThere are a few reasons that interior refs are not allowed on the heap, including lifetime (which needs a language feature to be solved). But one you haven\u0027t addressed at all is mentioned in [this article](https://learn.microsoft.com/en-us/archive/msdn-magazine/2018/january/csharp-all-about-span-exploring-a-new-net-mainstay) when spans initially came out:\r\n\r\n\u003e These references are called interior pointers, and tracking them is a relatively expensive operation for the .NET runtime’s garbage collector. As such, the runtime constrains these refs to only live on the stack, as it provides an implicit low limit on the number of interior pointers that might be in existence.\r\n\r\nMy proposal attempts to solve this by making it so they stay as \"interior pointers\" as opposed to object + offset for no longer than needed. As I\u0027ve already mentioned, the expensive part is not for interior references that point off of the managed heap, as these can be detected in 3 comparisons, it\u0027s the interior references that point into the managed heap (i.e., as you\u0027ve proposed it, every `safe ref`).\r\n\r\nThere are also atomicity concerns, e.g., consider if `Span\u003cT\u003e` was allowed to be on the heap and 2 threads tried to write to it at once, you might end up with the byref from one and the length from another, which leads to an obviously incorrect span. Your `safe ref` wouldn\u0027t fix this issue either, as it\u0027s not really possible to fix this except by safe API design, e.g., you could have a class (not a struct) that stores `InteriorRef\u003cT\u003e` + a length and disallows mutation for a `HeapSpan\u003cT\u003e` - this would be safe since you can\u0027t get tearing due to it only ever being mutated by the creating thread and it\u0027s never mutated again.\r\n\r\n\u003e _tldr: They are opposite in terms of lifetime - `ref` is used to limit usage of reference to the target\u0027s scope, while `safe ref` is used to extend usage of reference outside of any scope._\r\n\r\nOk, so you agree that the only difference with your `safe ref` and normal `ref` is the lifetime difference, and hence this doesn\u0027t address the runtime/GC limitations (which my proposal attempts to address).\r\n\r\n\u003e GC is not involved with stack pops at all. You return from method - GC is not even invoked.\r\n\r\nOk...? GC involvement for any `InteriorRef\u003cT\u003e`s would be something along the lines of: check if it\u0027s not converted to object + offset, if not: find the object it\u0027s in (which normal `ref T` also does, and `safe ref T` would also need to do) \u0026 convert to object + offset, treat like normal object reference. i.e., it\u0027s not meaningfully different to `ref T` in the worst case, or `object` once converted.\r\n\r\n\u003e I understand that you want to have single container for both object and free references, but it is still unsafe till you solve given problem\r\n\r\nWhat is there to solve? It\u0027s a low level/unsafe API. Yes, you can use it incorrectly, just like with any other low-level/unsafe API. If/when we get the ability to mark APIs `unsafe`, it would be marked as such (which is why I put it in the `System.Runtime.InteropServices` namespace, which has a bunch of other scary APIs - you wouldn\u0027t stick it straight in `System` for example - it could also go in `CompilerServices` or similar too though, that would be up to API review), along with the likes of `Unsafe`, `MemoryMarshal`, etc. You can use all of these APIs wrong and make everything crash and burn horribly - but you can still build safe APIs on top of them just fine.\r\n\r\n\u003e Of course, there is a point in such tool as well, but it is pretty different from my proposal of `safe ref`, and I don\u0027t think that they can be compared - they have different purposes.\r\n\r\nYour proposal is a language proposal. It doesn\u0027t seem to even address the runtime/GC limitations, which is what my proposal attempts to do. No one is arguing that there should not be a safe c# feature that exists, but what is it going to be built on? This is simply something that cannot work right now (unless you do @huoyaoyuan\u0027s version, which e.g., cannot support these operations that you mention `ref -\u003e safe ref // unsafe, pointer -\u003e safe ref // unsafe` - they would be impossible to implement) due to runtime/GC limitations, and my proposal tries to address that with a potential solution to the problem of byrefs not being allowed on the heap.",
                                           "updatedAt":  "2024-09-26T23:24:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6OQjTR",
                                           "createdAt":  "2024-10-01T18:37:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD1H9_A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ufcpp",
                                                                               "createdAt":  "2024-10-02T00:14:14Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "neon-sunset",
                                                                               "createdAt":  "2024-10-07T16:50:52Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "kg",
                                           "body":  "Thank you for the detailed suggestion and motivation. I\u0027ve written code that does something like this before, so I can see why it\u0027s desirable.\r\n\r\nHowever, I strongly oppose exposing something like this in the BCL or in C# as a built-in, especially if it requires underlying runtime/GC changes. This is primarily for taste/maintainability reasons.\r\n\r\nI think encouraging the use of long-lived interior references pointing at fields of GC objects is bad because it will promote tight coupling between distinct pieces of code, in a way that\u0027s hard to refactor and maintain.\r\n\r\n`Unsafe.XXX`, `ref`, and `out` are ideal for performance-sensitive scenarios where when used carefully they allow stripping away layers of abstraction, removing heap allocations, and removing bounds checks. But they need to be used thoughtfully and sparingly.\r\n\r\nThe main scenarios for this proposal I can think of are all asynchronous, either `async` or a delegate that fills in a field later on. I have personal experience with both, where I implemented it using a target object + a `FieldInfo`.\r\n\r\nIn these scenarios, the performance difference between a managed field reference and invoking a delegate or an interface property setter is basically insignificant compared to the time being spent running async machinery and performing the work in question to shuttle a result around. So I don\u0027t think the possible performance win justifies new functionality for this scenario, especially if it complicates the GC (which would introduce possible regressions in GC pause times).\r\n\r\nTo go in deeper on the coupling situation - most scenarios that call for this are probably better solved using an interface or getter/setter delegates. An interface provides a clean surface where you have a well-named interface and a well-named property, and the requirement to use a property instead of a field makes the code more maintainable because if your internal field layout changes, the property can become an adapter to support the new internal field layout. I\u0027ve personally had to make changes of this sort many times in my career to keep code working, and if I were touching fields directly - or worse, taking long-lived references to them - that maintenance would become much harder. Performance for interfaces on the modern runtime can be quite good, and as mentioned above, the interface property access overhead is not likely to be the hotspot if you\u0027re running async code.\r\n\r\nI am also mildly concerned about how this might interact with `out` scenarios and `readonly` fields. Both are not uncommon, so I can imagine seeing users try to apply this new functionality to both in the wild and cause fun and exciting new problems as a result.\r\n\r\nSome real world scenarios for this proposal might be better solved by `UnsafeAccessor`, as well, if the performance really does matter.\r\n\r\nI would love to see a more \"real\" scenario justifying the need for this functionality if the people advocating for it have one to share, even in the abstract. It can be hard to reason about the advantages of something like this when just looking at a toy example.\r\n\r\nSomething narrowly scoped like \u0027roslyn can turn `obj.FieldName` at compile time into `new FieldReference(obj, fieldof(T, FieldName))`\u0027 could probably pass muster for me but you\u0027d still have to get it into the compiler and BCL, and I\u0027m still not sure I see the value of it even when the risk is reduced like that.",
                                           "updatedAt":  "2024-10-01T18:37:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ZQ0Up",
                                           "createdAt":  "2025-01-04T14:41:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEB0dMQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ShadedBlink",
                                                                               "createdAt":  "2025-01-10T10:48:51Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "timcassell",
                                           "body":  "I think this would be very useful for making async versions of the TryGet pattern. `public bool TryGet(string key, out T value)`\n\nSynchronous version:\n\n```cs\nif (obj.TryGet(key, out var value))\n{\n    // ...\n}\n```\n\nAsynchronous version today:\n\n```cs\nvar (success, value) = await obj.TryGetAsync(key);\nif (success)\n{\n    // ...\n}\n```\n\nNew async version could be:\n\n```cs\nif (await obj.TryGetAsync(key, out var value))\n{\n    // ...\n}\n```",
                                           "updatedAt":  "2025-01-04T14:43:01Z"
                                       }
                                   ],
                         "totalCount":  16
                     },
        "title":  "[API Proposal]: Managed safe references",
        "labels":  [
                       "api-suggestion",
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/108301",
        "createdAt":  "2024-09-26T19:47:06Z",
        "number":  108301,
        "author":  "tmat",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-01T06:37:05Z",
        "body":  "### Description\r\n\r\nThe runtime doesn\u0027t support adding a static field to a struct or class with explicit layout.\r\n\r\nThis is an odd limitation as static field does not affect layout of the object.\r\n\r\nThe operation currently fails on all runtimes: .NET Framework, .NET 9, Mono.\r\n\r\n### Reproduction Steps\r\n\r\nRoslyn currently blocks such an edit but a CLR test can be easily written to demonstrate the issue.\r\nI can also supply private Roslyn build that removes the rude edit.\r\n\r\n### Expected behavior\r\n\r\nAdding static field into a struct should work.\r\n\r\n### Actual behavior\r\n\r\nApplication of EnC delta fails.\r\n\r\n### Regression?\r\n\r\nNo.\r\n\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\n_No response_\r\n\r\n### Other information\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOjks1OA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6Nvtb3",
                                           "createdAt":  "2024-09-26T23:04:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lambdageek",
                                           "body":  "\u003e The runtime doesn\u0027t support adding a static field to a struct or class with explicit layout.\r\n\r\n@tmat auto and sequential layout works?",
                                           "updatedAt":  "2024-09-26T23:04:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6OSzU4",
                                           "createdAt":  "2024-10-02T00:06:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD0b11g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "lambdageek",
                                                                               "createdAt":  "2024-10-02T12:56:45Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tmat",
                                           "body":  "I have not tested all possible layouts. Just structs. \r\nAuto class layout is the default, right? That works fine.",
                                           "updatedAt":  "2024-10-02T00:06:25Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "EnC: adding a static field to a struct fails",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/108416",
        "createdAt":  "2024-09-30T23:51:01Z",
        "number":  108416,
        "author":  "timcassell",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC7xYNA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "inf9144",
                                            "createdAt":  "2024-10-12T10:19:10Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-07-01T06:37:38Z",
        "body":  "Currently, attributes only allow compile-time constants as constructor arguments/properties. If we were allowed to use runtime constants, attributes would become much more powerful.\r\n\r\nWhat is considered a runtime constant? Existing consts, obviously, but also any `static readonly` field (which the tier-1 JIT treats as consts), as well as static pure functions* and properties (e.g. `IntPtr.Size`), and constant expressions (e.g. `IntPtr.Size * 2`).\r\n\r\nThis would enable things like lambdas in attributes (https://github.com/dotnet/csharplang/discussions/343), improved explicit layouts (https://github.com/dotnet/csharplang/discussions/4652), enabling users to do things like \r\n\r\nhttps://github.com/dotnet/runtime/blob/7b1e788c34ee9a44f6dc548c170c153dd7eab559/src/libraries/System.Private.CoreLib/src/System/Collections/Concurrent/ConcurrentQueueSegment.cs#L339-L344\r\n\r\n and more.\r\n\r\n---\r\n\r\nWe don\u0027t currently have a way to declare a pure function. There is an old csharplang discussion about it (https://github.com/dotnet/csharplang/discussions/776), probably it\u0027s a new thing that would require runtime validation of purity.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOk9xLbg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6OKOZs",
                                           "createdAt":  "2024-10-01T07:51:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD0OrNg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Joe4evr",
                                                                               "createdAt":  "2024-10-01T11:14:06Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "\"[Removing `readonly` from a field](https://github.com/dotnet/runtime/blob/e9fa899d9d39d0df0ca539b195ed0304d5ff6ccf/docs/coding-guidelines/breaking-change-rules.md?plain=1#L243)\" would then become a breaking change, if the field is static.",
                                           "updatedAt":  "2024-10-01T07:51:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6OQ93Y",
                                           "createdAt":  "2024-10-01T19:31:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "\u003e \"[Removing `readonly` from a field](https://github.com/dotnet/runtime/blob/e9fa899d9d39d0df0ca539b195ed0304d5ff6ccf/docs/coding-guidelines/breaking-change-rules.md?plain=1#L243)\" would then become a breaking change, if the field is static.\r\n\r\nHm. Personally, I would be ok with that. But I understand how that would be troublesome for the ecosystem. What about annotating a static readonly field such that it will be considered a runtime constant, and removing that annotation will be a breaking change instead (it would be invalid to have the annotation on a non-readonly field)? A similar annotation could be used for the functions/properties as well.",
                                           "updatedAt":  "2024-10-01T19:32:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ORnic",
                                           "createdAt":  "2024-10-01T20:14:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "Or perhaps it could be limited to static fields that are not accessible from outside the assembly; thus `internal`, `private`, or `private protected`.  That way, removing `readonly` could not break third-party assemblies.  Having to define `internal static readonly IntPtrSize = IntPtr.Size;` just for use in attributes would be a bit annoying though.\n\nThen, I wonder about reflection APIs.  For System.Reflection.CustomAttributeTypedArgument, it might suffice if the `object? Value` property just returned the runtime-constant value without indicating how it was obtained.  This would not work with Assembly.ReflectionOnlyLoad (because the initialisation of the static field could not be executed) but .NET Core doesn\u0027t support that anyway.  For System.Reflection.Metadata.CustomAttributeTypedArgument\\\u003cTType\\\u003e though, I think there should be a way to get the expression or at least the metadata token of the field.",
                                           "updatedAt":  "2024-10-01T20:14:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Oy2YY",
                                           "createdAt":  "2024-10-07T00:52:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "Actually, that might be just fine for the runtime to only support internal static readonly fields. The C# compiler doesn\u0027t have to have the same restriction, and could synthesize the field for you.",
                                           "updatedAt":  "2024-10-07T00:52:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6PE9Dz",
                                           "createdAt":  "2024-10-08T17:29:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "acaly",
                                           "body":  "\u003e Or perhaps it could be limited to static fields that are not accessible from outside the assembly; thus internal, private, or private protected. \n\nIMO it\u0027s not a good idea to add new meanings (or implications) to `internal` and others.\n\n\u003e The C# compiler doesn\u0027t have to have the same restriction, and could synthesize the field for you.\n\nThis doesn\u0027t solve the breaking-change problem. The compiler may try to synthesize an `internal static readonly` from a `public static readonly` in another assembly. What if that `readonly` is removed? This will still be a valid program, but may give unpredictable results.",
                                           "updatedAt":  "2024-10-08T17:29:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6PFHZ7",
                                           "createdAt":  "2024-10-08T17:53:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "\u003e \u003e The C# compiler doesn\u0027t have to have the same restriction, and could synthesize the field for you.\r\n\u003e \r\n\u003e This doesn\u0027t solve the breaking-change problem. The compiler may try to synthesize an `internal static readonly` from a `public static readonly` in another assembly. What if that `readonly` is removed? This will still be a valid program, but may give unpredictable results.\r\n\r\nNot having the same restriction doesn\u0027t mean the compiler must have no restrictions. It could have the requirement that used fields and properties be annotated with `[RuntimeConstant]`, for example.\r\n\r\nAlso, even if that were to happen, I don\u0027t think it\u0027s a big deal. It would still be a runtime constant, evaluated only once.",
                                           "updatedAt":  "2024-10-08T18:02:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6PlTIt",
                                           "createdAt":  "2024-10-13T10:24:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "acaly",
                                           "body":  "Having `[RuntimeConstant]` is a much better choice IMO.\n\nThe point is not to allow arbitrary existing `static readonly` fields to be used in attributes (although they are treated as runtime constants by the runtime). This should be an opt-in feature. Only in this way the breaking-change problem can be solved.\n\nIn this case, is it possible to reuse the `const` keyword in C# to allow any type, effectively making them `[RuntimeConstant] static readonly`? This follows the recent trend of extending or redefining existing keywords for broader scenarios.",
                                           "updatedAt":  "2024-10-13T10:26:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6T3Etu",
                                           "createdAt":  "2024-11-16T17:56:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hez2010",
                                           "body":  "\u003e Having `[RuntimeConstant]` is a much better choice IMO.\n\nIt\u0027s not about how the syntax will be; it\u0027s about that this proposal needs to change the metadata of attributes because today all attributes are required to be emitted as literal values in the assembly.",
                                           "updatedAt":  "2024-11-16T17:56:25Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Runtime constants in attributes",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/109451",
        "createdAt":  "2024-11-01T15:03:05Z",
        "number":  109451,
        "author":  "Yoticc",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODLMv6A==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hez2010",
                                            "createdAt":  "2024-11-01T16:00:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "elgonzo",
                                            "createdAt":  "2024-11-01T19:41:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Yoticc",
                                            "createdAt":  "2024-11-01T22:26:32Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dvdvorle",
                                            "createdAt":  "2025-06-12T08:24:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Alluseri",
                                            "createdAt":  "2025-08-14T10:31:02Z"
                                        }
                                    ],
                          "totalCount":  5
                      },
        "updatedAt":  "2025-07-22T17:15:25Z",
        "body":  "### Description\n\nThis code throws the System.TypeLoadException exception: “Could not load type ”{`A` or `B` in this case}\" from assembly {`Assembly`}\":\n```csharp\nA a = new();\n\nstruct G\u003cT\u003e;\n\nstruct B\n{\n    A A;\n}\n\nstruct A\n{\n    G\u003cB\u003e B;\n}\n```\n\nThis occurs in the line `A a = new();`, and it will also occur if replace it with `B b = new();`\nExample of a real exception:\nSystem.TypeLoadException: \u0027Could not load type \u0027A\u0027 from assembly \u0027ConsoleTest, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\u0027.\u0027\n\n\n### Reproduction Steps\n\n```csharp\nA a = new();\n\nstruct G\u003cT\u003e;\n\nstruct B\n{\n    A A;\n}\n\nstruct A\n{\n    G\u003cB\u003e B;\n}\n```\n\n### Expected behavior\n\nthere should be no exception\n\n### Actual behavior\n\nexception thrown\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\nNet 8.0.400. CoreCLR 8.0.824.36612\nWindows 11 24H2\nx64\n\n\n### Other information\n\nI have just discovered a similar problem occurring in C# 6: https://github.com/dotnet/runtime/issues/6924",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOt9LdOw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6SKUnO",
                                           "createdAt":  "2024-11-01T16:31:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "colejohnson66",
                                           "body":  "Possible duplicate of #104511",
                                           "updatedAt":  "2024-11-01T16:32:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc63h0JA",
                                           "createdAt":  "2025-07-16T15:15:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "M0n7y5",
                                           "body":  "I have the same issue when i want to use MEDI on Apple platforms. I am using dotnet 9.",
                                           "updatedAt":  "2025-07-16T15:15:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc630t07",
                                           "createdAt":  "2025-07-17T13:20:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Yoticc",
                                           "body":  "I checked in .NET 9.0.0 and the error persisted. In .NET 10.0-preview6, the application crashed with the exception code: 0xe0434352 without any additional information",
                                           "updatedAt":  "2025-07-17T13:20:25Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Exception System.TypeLoadException in case of recursive generic parameter",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/109585",
        "createdAt":  "2024-11-06T18:05:10Z",
        "number":  109585,
        "author":  "cap5lut",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-01-24T12:13:05Z",
        "body":  "### Description\n\nLooking at the value tuple type `(bool, Nullable\u003cint\u003e)` i expect the following layout:\n\n1 byte for the bool + 3 padding bytes\n1 byte for the bool of the nullable + 3 padding bytes\n4 bytes for the int\n\nwhich would sum up to 12 bytes,\nthis however turns into a 16 bytes struct, because 4 bytes of padding are added at the end.\n\n### Reproduction Steps\n\n```cs\n(bool, Nullable\u003cint\u003e) x = (false, 5);\nInspect.Stack(x);\n\nunsafe\n{\n    Console.WriteLine(sizeof((bool, Nullable\u003cint\u003e)));\n}\n```\n\nI am using sharplab.io to showcase it:\n[sharplab.io link](https://sharplab.io/#v2:EYLgtghglgdgNAFxAJwK4wD4AEBMBGAWAChiAKYAewoBs4ACAOVWuomGoFMAeWBAPgCUdAB50AvHVIAzCNQDOHegFYBAbmIBJGHIAOHAMYIAdAGUEEfQGtSwtcWLo5EKR2IBvYnS90seAJykclAAXhwUUqTkVLSMzKzs3LyCAnZEAL5AA===)\n\n### Expected behavior\n\nThe struct size should be 12 bytes, but has additionally some trailing 4 byte padding.\n\n### Actual behavior\n\nThe struct size is 16 bytes because of the trailing 4 byte padding.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOm7XOYw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6SqMVh",
                                           "createdAt":  "2024-11-06T18:51:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "cap5lut",
                                           "body":  "I tried to mimic the value tuples and how `LayoutKind.Auto` and `LayoutKind.Sequential` affect the size, using the following structs:\n```cs\n[System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]\nstruct S1 {  bool Bool; Nullable\u003cint\u003e Num; }\n\n[System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]\nstruct S2 { bool Bool; Nullable\u003cint\u003e Num; }\n\n[System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]\nstruct S3 { bool Bool; S34 Num; }\n\n[System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]\nstruct S4 { bool Bool; S34 Num; }\n\nstruct S34 { bool Bool; int Num; \n```\n\nthe sequential ones are all 12 bytes, while the auto ones are 16 bytes.",
                                           "updatedAt":  "2024-11-06T18:51:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6SqO-q",
                                           "createdAt":  "2024-11-06T18:57:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "just-ero",
                                           "body":  "For completion, I ran `Console.WriteLine(sizeof((bool, int?)));` on the following configurations with these results:\n\n```\n.NET 8.0 win-x86: 12\n.NET 8.0 win-x64: 16\n.NET 9.0 win-x86: 12\n.NET 9.0 win-x64: 16\n\n.NET 8.0 win-x86 NativeAOT: 12\n.NET 9.0 win-x86 NativeAOT: 12\n.NET 9.0 win-x64 NativeAOT: 16\n```",
                                           "updatedAt":  "2024-11-06T18:57:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6SqYdT",
                                           "createdAt":  "2024-11-06T19:18:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "CC. @jkotas \n\nWe\u0027ve fixed a few issues in the past, related to generics and nullable\u003cT\u003e.\n\nThis one looks to be a general issue with `AutoLayout` and it rounding up to a multiple of 8. Even simply `struct S { int a, b, c; }` causes this to reproduce (or `struct S { int a, b, c, d, e; }` which makes it 24 instead of 20).",
                                           "updatedAt":  "2024-11-06T19:18:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6SqbKI",
                                           "createdAt":  "2024-11-06T19:24:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "This looks completely expected to me. Types are padded up to the nearest word size. x86 is 32-bit platform, with 4-byte word size. 12 is a multiple of 4. x64 is a 64-bit platform with 8-byte word size. 12 is not a multiple of 8, so it rounds up to 16.\n\n32-bit calculation:\n  `Nullable\u003cint\u003e` = 4 (int) + 1 (bool) + 3 (padding) = 8\n  `(bool, Nullable\u003cint\u003e)` = 1 (bool) + 8 (`Nullable\u003cint\u003e`) + 3 (padding) = 12\n\n64-bit calculation:\n  `Nullable\u003cint\u003e` = 4 (int) + 1 (bool) + 3 (padding) = 8\n  `(bool, Nullable\u003cint\u003e)` = 1 (bool) + 8 (`Nullable\u003cint\u003e`) + 7 (padding) = 16\n\n[Edit] I\u0027m actually surprised that the sequential layouts are 12 bytes on 64-bit platform.",
                                           "updatedAt":  "2024-11-06T19:36:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6SqflS",
                                           "createdAt":  "2024-11-06T19:34:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "just-ero",
                                           "body":  "As I see it, `Nullable\u003cint\u003e` would still have an alignment of `4` while having a size of `8`.  \nThat would (should) result in 1 (bool) + 3 (padding) + 4 (int) + 1 (bool) + 3 (padding) = 12.",
                                           "updatedAt":  "2024-11-06T19:35:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6SqhXY",
                                           "createdAt":  "2024-11-06T19:38:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "\u003e As I see it, `Nullable\u003cint\u003e` would still have an alignment of `4` while having a size of `8`. That would (should) result in 1 (bool) + 3 (padding) + 4 (int) + 1 (bool) + 3 (padding) = 12.\n\nThat makes sense. Maybe the auto layout isn\u0027t taking into account the alignment of nested types.",
                                           "updatedAt":  "2024-11-06T19:38:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6SqnAP",
                                           "createdAt":  "2024-11-06T19:50:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD6GdiQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "timcassell",
                                                                               "createdAt":  "2024-11-06T19:58:37Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-11-06T20:48:56Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "omariom",
                                                                               "createdAt":  "2024-11-08T23:00:39Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e This looks completely expected to me. Types are padded up to the nearest word size. x86 is 32-bit platform, with 4-byte word size. 12 is a multiple of 4. x64 is a 64-bit platform with 8-byte word size. 12 is not a multiple of 8, so it rounds up to 16.\n\nThis isn\u0027t correct. Types are padded based on the largest natural alignment of all members.\n\nThe natural alignments are:\n| Type | Size | Natural Alignment | Additional Notes |\n| -- | -- | -- | -- |\n| bool | 1 | 1 | |\n| byte | 1 | 1 | |\n| char | 2 | 2 | |\n| double | 8 | 8 | Some 32-bit platforms use a natural alignment of 4 |\n| short | 2 | 2 | |\n| int | 4 |  4 | |\n| long | 8 | 8 | Some 32-bit platforms use a natural alignment of 4 |\n| nint | 4 or 8 | 4 or 8 | Same size as a pointer |\n| sbyte | 1 | 1 | |\n| float | 4 | 4 | |\n| ushort | 2 | 2 | |\n| uint | 4 |  4 | |\n| ulong | 8 | 8 | Some 32-bit platforms use a natural alignment of 4 |\n| nuint | 4 or 8 | 4 or 8 | Same size as a pointer |\n\nThe designated packing can be overridden to be smaller, but not larger, than the natural packing.\n\nGC tracked types are pointer sized but cannot have the natural packing overridden.\n\nFields that are structs (not primitives) have their own natural alignment based on the members they contain. So `struct S { bool b, int i; }` has a natural packing of `4` and size of `8`. This is impactful when it is a field of another struct, because it means that `struct S2 { bool b; S s; }` and `struct S3 { bool b1; bool b2;, int i; }` have different natural layouts and sizes. -- In particular `S2` is going to be `bool, padding x3, bool, int` and thus have its own natural packing of `4` and size of `12`. While `S3` is also going to have a natural packing of `4` but be size of `8` because it is `bool, bool, padding x2, int`.",
                                           "updatedAt":  "2024-11-06T19:51:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6SqurM",
                                           "createdAt":  "2024-11-06T20:06:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "\u003e GC tracked types are pointer sized but cannot have the natural packing overridden.\n\nIs this possibly related to https://stackoverflow.com/questions/67068942/c-sharp-why-do-class-fields-of-struct-types-take-up-more-space-than-the-size-of and https://stackoverflow.com/questions/24742325/why-does-struct-alignment-depend-on-whether-a-field-type-is-primitive-or-user-de?\n\nStructs that contain reference types, or used as fields in reference types (classes), are padded more than expected. (I\u0027m not sure if there is already a separate issue for those.)",
                                           "updatedAt":  "2024-11-06T20:06:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Sq1jw",
                                           "createdAt":  "2024-11-06T20:21:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "The bug you linked is potentially related to the overall issue here, but it wouldn\u0027t be related to the fact that you cannot override the natural packing/alignment of GC types.\n\n`Auto` layout is meant to pick an \"optimal\" layout and while there are a few potential definitions for that, the default assumption is simply that it minimizes padding.\n\nTypically to achieve this it means you sort fields based on `natural packing`. So you\u0027d always have all fields that are 8-byte packed, then 4-byte packed, then 2-byte, then 1-byte.\n\nYou can optionally also do some sorting within those regions, such as grouping all GC fields together (typically first), or by also sorting by size within a group (so a `struct` that is 4-byte packed but has a size of 16 would come before a struct that is 4-byte packed and has a size of 8, which would come before just a regular `int` field), but this additional level shouldn\u0027t impact the computed size, just the order fields exist. -- This is called out because its typical in C or C++ when optimizing layouts to group same sized fields together, which can enable SIMD or other optimizations to kick in where relevant.\n\n-----\n\nNotably the .NET auto layout algorithm has historically had some quirks and bugs; some of which we\u0027ve fixed over time and others of which we\u0027ve not. I\u0027m not sure where this one in particular falls.",
                                           "updatedAt":  "2024-11-06T20:21:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6btc5j",
                                           "createdAt":  "2025-01-24T12:13:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vmilea",
                                           "body":  "\u003e Notably the .NET auto layout algorithm has historically had some quirks and bugs; some of which we\u0027ve fixed over time and others of which we\u0027ve not. I\u0027m not sure where this one in particular falls.\n\nThe bug isn\u0027t necessarily in field sorting, but rather in overalignment of the struct. How does the alignment of `(byte, int, int)` end up as 8 instead of 4?\n",
                                           "updatedAt":  "2025-01-24T12:13:04Z"
                                       }
                                   ],
                         "totalCount":  10
                     },
        "title":  "Unexpected padding with Auto layout structs",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/109680",
        "createdAt":  "2024-11-10T04:30:41Z",
        "number":  109680,
        "author":  "timcassell",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-11-13T19:41:47Z",
        "body":  "### Description\n\nAdding a struct field to a base class makes the derived class larger than expected.\n\n### Reproduction Steps\n\n```cs\n[Benchmark]\npublic MyClass1\u003cbyte\u003e MyClass1() =\u003e new MyClass1\u003cbyte\u003e();\n\n[Benchmark]\npublic MyClass2\u003cbyte\u003e MyClass2() =\u003e new MyClass2\u003cbyte\u003e();\n```\n\n```cs\npublic class MyBaseClass1\n{\n    private struct ObjectWrapper\n    {\n        internal object _obj;\n    }\n\n    private ObjectWrapper _objectWrapper;\n\n    private short _id;\n    private bool _flag1;\n    private bool _flag2;\n    private bool _flag3;\n    private bool _flag4;\n}\n\npublic class MyBaseClass2\n{\n    internal object _obj;\n\n    private short _id;\n    private bool _flag1;\n    private bool _flag2;\n    private bool _flag3;\n    private bool _flag4;\n}\n\npublic class MyClass1\u003cT\u003e : MyBaseClass1\n{\n    private T _value;\n}\n\npublic class MyClass2\u003cT\u003e : MyBaseClass2\n{\n    private T _value;\n}\n```\n\n### Expected behavior\n\nThe type size should be the same whether the field is a reference type, or a struct wrapper around a reference type.\n\n### Actual behavior\n\n| Method   | Allocated |\n|--------- |----------:|\n| MyClass1 |      40 B |\n| MyClass2 |      32 B |\n\n### Regression?\n\nNo, the behavior is the same on .Net Framework\n\n### Known Workarounds\n\nDon\u0027t use struct fields.\n\nAdd an additional base type above that type to contain the struct field.\n\n### Configuration\n\n```cmd\nBenchmarkDotNet v0.14.1-develop (2024-11-09), Windows 10 (10.0.19045.5011/22H2/2022Update)\nAMD Phenom(tm) II X6 1055T Processor 2.80GHz, 1 CPU, 6 logical and 6 physical cores\n.NET SDK 9.0.100-rc.2.24474.11\n  [Host]   : .NET 8.0.10 (8.0.1024.46610), X64 RyuJIT SSE3\n  ShortRun : .NET 8.0.10 (8.0.1024.46610), X64 RyuJIT SSE3\n```\n\n### Other information\n\nPossibly related to #109585.\n\nAlso possibly related to https://stackoverflow.com/questions/67068942/c-sharp-why-do-class-fields-of-struct-types-take-up-more-space-than-the-size-of and https://stackoverflow.com/questions/24742325/why-does-struct-alignment-depend-on-whether-a-field-type-is-primitive-or-user-de. ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOk387wQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6TCSvp",
                                           "createdAt":  "2024-11-10T19:14:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "Seems like the VM is moving the struct field [to the end of the object](https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA0AXEUCuA7AHwEk8BnABxjAwDoAJGAQ3IAo8YB3AAgFkBPAMIAbRqVIBGADzA+GGAD4WASiUBuALAAoEhSq0GzNp16CRYgEzTZC5Wq1aAAgGYuD8yYBComMNEStAN5aXCFc5FAAlgBujHJcpBi41FwA8sAAVnoA6lDMlFDBoUGaoaVcEXhyUHiMQlwQGXpcAPoN6RoloQC+9p0h4dGxMKmN1Dl5MFAtbdm55Pkdhf2RMXGkABbQGC0RACYdpQOrw8AQEHXNAGYiAObiB6FHQ1yn5y3XjDfmD8uDca8XD43Jw/MIrZ4A963FAdHqaRwuNyeby+CyBJblSqTGp1GbJVoZRZ9MF/YYbLY7fYYp7/M6A273ang2lvK63b5M0kvOlQz4gznHbmsoEwrRwhGudz8VESSQAFXkXBAyNIPjM/k0xUOzOGcpaMSEOBgsN6zklJhllgVSpVar85nRxJpuv1tSNsKAA) for some reason?",
                                           "updatedAt":  "2024-11-10T19:14:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6TM0z_",
                                           "createdAt":  "2024-11-12T04:58:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "A question: is `Auto` layout expected to be observable in non-diagnostic usages? Or is it just an implementation detail?",
                                           "updatedAt":  "2024-11-12T04:58:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6TXOYF",
                                           "createdAt":  "2024-11-13T04:16:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e A question: is `Auto` layout expected to be observable in non-diagnostic usages? Or is it just an implementation detail?\n\nI\u0027m not entirely sure what this means. The [`LayoutKind.Auto` ](https://learn.microsoft.com/dotnet/api/system.runtime.interopservices.layoutkind) represents the algorithm that is used by the runtime to layout the type in the most efficient way it sees fit. Changing the auto layout algorithm isn\u0027t necessarily a task the runtime is likely to attempt unless there is a clear benefit. In this case if `LayoutKind.Auto` is choosing that size, that is the correct size as determined by the runtime. If someone wants more control over the size of a type a value type should be used marking it with `LayoutKind.Sequential`.\n\nNote this doesn\u0027t mean that in the future changes aren\u0027t possible. It does mean that the `LayoutKind.Auto` should be treated as an implementation detail and as the name \"Auto\" implies it is left as an exercise for the runtime to lay the type out in the manner best suited for performance with the VM and JIT.",
                                           "updatedAt":  "2024-11-13T04:16:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6TepUR",
                                           "createdAt":  "2024-11-13T17:28:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kg",
                                           "body":  "From experimenting, StructLayout.Sequential doesn\u0027t impact this, the struct will still get reordered to the end of the class by the runtime (IIRC it has the right to do this; the sequential-ness is only guaranteed at marshaling boundaries? I may be misremembering but this is how it worked on netfx too.)\n\nIf you add an extra uint16 to ObjectWrapper it becomes clearer what might be happening - ObjectWrapper will get rounded up to 2x the size of an object reference, so it gets padding at the end of it before _value appears, and then you potentially have padding after _value.\n\nI think the calculation that determines alignment/packing here is not \u0027seeing through\u0027 the struct as desired. It would be nice if it did but I\u0027m not sure you could actually generalize a rule like that without having nasty consequences in cases where you\u0027re passing `ref`s or pointers around, the size of a struct within a containing type probably needs to always be the same as its size on the heap. Maybe something could be done for the specific case of a struct with a single member where layout decomposes it?\n\nI\u0027d be wary that this could break existing code.\n",
                                           "updatedAt":  "2024-11-13T17:29:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Tfbdz",
                                           "createdAt":  "2024-11-13T19:03:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD6wX4Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kg",
                                                                               "createdAt":  "2024-11-13T19:28:23Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "timcassell",
                                           "body":  "\u003e I think the calculation that determines alignment/packing here is not \u0027seeing through\u0027 the struct as desired.\n\nThat does seem like it could be the case both for this issue and at least 2 of the linked issues.\n\n\u003e I\u0027m not sure you could actually generalize a rule like that without having nasty consequences in cases where you\u0027re passing `ref`s or pointers around\n\nI don\u0027t understand. How would passing refs affect it? The struct itself is always at a fixed offset with a fixed size. I don\u0027t think it should matter whether the struct is at the beginning of the class or the end.\n\n\u003e the size of a struct within a containing type probably needs to always be the same as its size on the heap.\n\nI agree. In fact, the bug described [here](https://stackoverflow.com/questions/67068942/c-sharp-why-do-class-fields-of-struct-types-take-up-more-space-than-the-size-of) seems to violate that.",
                                           "updatedAt":  "2024-11-13T19:03:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6TfrxC",
                                           "createdAt":  "2024-11-13T19:32:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kg",
                                           "body":  "\u003e \u003e I\u0027m not sure you could actually generalize a rule like that without having nasty consequences in cases where you\u0027re passing `ref`s or pointers around\n\u003e \n\u003e I don\u0027t understand. How would passing refs affect it? The struct itself is always at a fixed offset with a fixed size. I don\u0027t think it should matter whether the struct is at the beginning of the class or the end.\n\nThe ideal behavior (without context) would be to have no padding anywhere, but in some cases you would need padding. I.e. you have a struct with an ideal size of 3 bytes; the heap allocation if you box it can\u0027t be 3 bytes, it will get rounded up to some larger allocation size most likely. So at that point the size of it on the heap and the size of it within an enclosing type have become different and you have to be careful not to accidentally over-read or under-write when doing initialization. You\u0027d also potentially run into problems then with people mixing up the different types of sizeof\u0027s, am i using the boxed size when i meant the in-place size? did i mean the marshal size, which might be different from both because it contains a bool? Am I thinking in terms of array layout instead of field layout? etc.\n\nI ran into this previously on netfx writing an InlineArray equivalent specialized for 4 elements. The spacing between fields was not what I expected in some cases depending on the element type, and as a result I observed memory corruption when using `Unsafe.Add`. Mostly a lesson learned but a tricky one since you might naively assume that arrays and sequential fields have the same layout, but they don\u0027t necessarily.",
                                           "updatedAt":  "2024-11-13T19:32:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6TfvvV",
                                           "createdAt":  "2024-11-13T19:37:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD6wc-Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kg",
                                                                               "createdAt":  "2024-11-13T19:37:52Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "timcassell",
                                           "body":  "Considering this is for auto layout, I wouldn\u0027t even consider the implications of unsafe APIs. ",
                                           "updatedAt":  "2024-11-13T19:37:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6TfzvB",
                                           "createdAt":  "2024-11-13T19:41:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD6wgoA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kg",
                                                                               "createdAt":  "2024-11-13T19:44:27Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "`struct wrappers` and primitive fields are not always identical, even for Sequential, interop, and other scenarios. In this particular case they should be, and this is likely similar to https://github.com/dotnet/runtime/issues/109585; but it is an important distinction to call out.",
                                           "updatedAt":  "2024-11-13T19:41:44Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Struct field affects size of derived class",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/110311",
        "createdAt":  "2024-12-02T13:45:01Z",
        "number":  110311,
        "author":  "dt-dominik",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-01T06:46:26Z",
        "body":  "### Description\n\nWhen calling `IMetaDataEmit::GetSaveSize` (either directly or indirectly via the `Save`, `SaveToMemory` or `SaveToStream` methods) previously generated generic param tokens become invalid even if no `IMapToken` is specified, making it near impossible to capture a snapshot of the metadata.\n\n### Reproduction Steps\n\n* Define a new type (`MyTypeA`) using the `IMetaDataEmit::DefineTypeDef` method.\n* Define a new type (`MyTypeB`) using the `IMetaDataEmit::DefineTypeDef` method.\n* Define a new generic parameter (`MyGenericParamB`) for `MyTypeB` using the `IMetaDataEmit2::DefineGenericParam` method.\n* Define a new generic parameter (`MyGenericParamA`) for `MyTypeA` using the `IMetaDataEmit2::DefineGenericParam` method.\n* Call `IMetaDataEmit::GetSaveSize`\n* Use e.g. `IMetaDataImport2::EnumGenericParams` or `IMetaDataImport2::GetGenericParamProps` to see that the tokens for the generic parameters changed.\n\n```cpp\nmdTypeDef myTypeA = mdTypeDefNil;\nIfFailRet(metadataEmit-\u003eDefineTypeDef(L\"MyTypeA\", 0, mdTokenNil, none, \u0026myTypeA));\n\nmdTypeDef myTypeB = mdTypeDefNil;\nIfFailRet(metadataEmit-\u003eDefineTypeDef(L\"MyTypeB\", 0, mdTokenNil, none, \u0026myTypeB));\n\nmdGenericParam myGenericParamB = mdGenericParamNil;\nIfFailRet(metadataEmit-\u003eDefineGenericParam(myTypeB, 0, 0, L\"MyGenericParamB\", 0, none, \u0026myGenericParamB));\n\nmdGenericParam myGenericParamA = mdGenericParamNil;\nIfFailRet(metadataEmit-\u003eDefineGenericParam(myTypeA, 0, 0, L\"MyGenericParamA\", 0, none, \u0026myGenericParamA));\n\n// MyTypeA (0x02000ac9) `1 \u003cMyGenericParamA (0x2a000f17)\u003e\n// MyTypeB (0x02000aca) `1 \u003cMyGenericParamB (0x2a000f16)\u003e\n\nDWORD saveSize = 0;\nIfFailRet(metadataEmit-\u003eGetSaveSize(cssQuick, \u0026saveSize));\n\n// MyTypeA (0x02000ac9) `1 \u003cMyGenericParamA (0x2a0003d1)\u003e\n// MyTypeB (0x02000aca) `1 \u003cMyGenericParamB (0x2a0003d2)\u003e\n```\n\nIn the example above the token for `MyGenericParamA` changed from `0x2a000f17` to `0x2a0003d1`.\n\n### Expected behavior\n\nThe `IMetaDataEmit::GetSaveSize` does not optimize metadata tables unless a `IMapToken` implementation is provided by the caller and can be used to create a snapshot of the current metadata without modifying it.\n\n### Actual behavior\n\nA call to `IMetaDataEmit::GetSaveSize` results in a call to `CMiniMdRW::PreSaveFull` which sorts the GenericParam and other metadata tables:\n\n![Image](https://github.com/user-attachments/assets/2d687ceb-728a-41d6-9ad1-b46434a87533)\n\n```\n\u003e\tcoreclr.dll!CMiniMdRW::MapToken(unsigned int from, unsigned int to, unsigned int tkn) Line 1239\tC++\n \tcoreclr.dll!CQuickSortMiniMdRW::DoMapTokens() Line 389\tC++\n \tcoreclr.dll!CStableSortMiniMdRW::Sort() Line 669\tC++\n \tcoreclr.dll!CMiniMdRW::PreSaveFull() Line 2733\tC++\n \tcoreclr.dll!CMiniMdRW::PreSave(MetaDataReorderingOptions reorderingOptions) Line 3079\tC++\n \tcoreclr.dll!RegMeta::PreSave() Line 707\tC++\n \tcoreclr.dll!RegMeta::GetSaveSize(CorSaveSize fSave, unsigned long * pdwSaveSize) Line 241\tC++\n```\n\nThe screenshot above was taken while debugging a local build of the v9.0.0 runtime using a sample profiler; the callstack shows that  `IMetaDataEmit::GetSaveSize` changes the token value. The *Locals* panel shows that the token for `MyGenericParamA` `0x2a000f17` is re-mapped to `0x2a0003d1`.\n\nWe found the issue while looking into a problem with our profiler where a call to `IMetaDataEmit::SaveToMemory` caused exceptions to be thrown by the profiled application afterwards:\n```\nSystem.Security.VerificationException: Method System.Runtime.Intrinsics.Vector128.AsByte: type argument \u0027System.SByte\u0027 violates the constraint of type parameter \u0027TCaseSensitivity\u0027.\n         at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.StringUtilities.\u003c\u003ec.\u003c.cctor\u003eb__7_0(Span`1 buffer, ValueTuple`3 tuple)\n         at System.String.Create[TState](Int32 length, TState state, SpanAction`2 action)\n         ...\n```\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\nThe behavior could be reproduced using applications targeting .NET Framework 3.5, .NET Framework 4.8.1, .NET 8.0 and .NET 9.0 .\n\n### Other information\n\n* At least the `GenericParam`, `GenericParamConstraint` and `CustomAttribute` tables seem to be modified by `IMetaDataEmit::GetSaveSize`\n* Adding a breakpoint in `CMiniMdRW::MapToken` while debugging the CoreCLR makes it quite easy to detect the changes.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOluHdJA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6W4d0k",
                                           "createdAt":  "2024-12-10T11:56:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dt-dominik",
                                           "body":  "We are currently able to reliably reproduce the issue:\n\n- The target application is instrumented and working as expected\n- We call `IMetaDataEmit::GetSaveSize` and export the metadata. \n- The application throws a `System.TypeLoadException` (or sometimes a `System.Security.VerificationException`, seems to depend on which code is executed at the time).\n- Using a Debug build of the CLR we were able to see that this seems to be related to generics: it seems like the \"old\" GenericParam token value is used instead of the new one:\n\nCLR Logs: [clr-logs.txt](https://github.com/user-attachments/files/18078445/clr-logs.txt) : You can see that the CLR tries to load  \n  * `TwoTaskWhenAnyPromise\u00271[TTask]` (expected)\n  * `TwoTaskWhenAnyPromise\u00271[(00007FFC84434988)+System.__Canon]` (internal stuff I guess, can\u0027t say if this is correct)\n  * `TwoTaskWhenAnyPromise\u00271[T]` (**incorrect**; `T` should be `TTask`)\n\nUsing a Debug build of the CLR we were able to verify that\n* the GenericParam token value `0x2a000b1b` is mapped to `0x2a000c4c` (by adding code at the end of `CMiniMdRW::PreSaveFull()` and inspecting `GetTokenMovementMap()` just before it is discarded) \n* the old GenericParam token value (`0x2a000b1b`) is used to validate the constraint:  \n  ![Image](https://github.com/user-attachments/assets/7e331e29-b633-4bf5-b4ba-9ff0f6f92287)\n\nYou can see in the screenshot that the old GenericParam token value `0x2a000b1b` is used to validate constraints. In the background you can see the original assembly (on the left) and the instrumented assembly after the call to `IMetaDataEmit::GetSaveSize` (on the right) opened in ILSpy; the GenericParam tables clearly show that the wrong GenericParam is used; even the Owner field refers to a different type).\n\n(note that the screenshot and logs are from different runs, but it\u0027s always the same token/type).\n\nJust let me know if you need further information; I\u0027ll happily provide whatever you need.",
                                           "updatedAt":  "2024-12-10T11:56:25Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Calling IMetaDataEmit::GetSaveSize invalidates GenericParam and other tokens",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/111167",
        "createdAt":  "2024-12-20T15:22:22Z",
        "number":  111167,
        "author":  "vzabavnov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-07T17:51:32Z",
        "body":  "The issue is in both net8.0 and net9.0\n\nthe test:\n```C#\nusing Xunit;\n\nnamespace Tests;\n\npublic interface IInterface\u003cTEntity, in TContext\u003e\n    where TEntity : IInterface\u003cTEntity, TContext\u003e\n{\n    public static void Method\u003cTEntityProperty\u003e()\n        where TEntityProperty : IInterface\u003cTEntityProperty, TContext\u003e { }\n}\n\npublic class UnitTests\n{\n    [Fact]\n    public void TheTest() { }\n}\n```\n\nCompiler gives no errors. \nThe test gives error :\n\n```\nERROR Could not load type \u0027Tests.IInterface`2\u0027 from assembly \u0027TheCovariantTests, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\u0027 because a covariant or contravariant type parameter was used illegally in a type parameter constraint in method \u0027\u0027., reason: System.TypeLoadException: Could not load type \u0027Tests.IInterface`2\u0027 from assembly \u0027TheCovariantTests, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\u0027 because a covariant or contravariant type parameter was used illegally in a type parameter constraint in method \u0027\u0027. at System.Reflection.RuntimeAssembly.GetExportedTypes() at Xunit.Sdk.ReflectionAssemblyInfo.GetTypes(Boolean includePrivateTypes) in /_/src/xunit.execution/Sdk/Reflection/ReflectionAssemblyInfo.cs:line 80 at Xunit.Sdk.TestCollectionFactoryHelper.GetTestCollectionDefinitions(IAssemblyInfo assemblyInfo, IMessageSink diagnosticMessageSink) in /_/src/xunit.execution/Sdk/Frameworks/TestCollectionFactoryHelper.cs:line 22 at Xunit.Sdk.CollectionPerClassTestCollectionFactory..ctor(ITestAssembly testAssembly, IMessageSink diagnosticMessageSink) in /_/src/xunit.execution/Sdk/Frameworks/CollectionPerClassTestCollectionFactory.cs:line 27 at Xunit.Sdk.ExtensibilityPointFactory.GetXunitTestCollectionFactory(IMessageSink diagnosticMessageSink, IAttributeInfo collectionBehaviorAttribute, ITestAssembly testAssembly) in /_/src/xunit.execution/Sdk/ExtensibilityPointFactory.cs:line 245 at Xunit.Sdk.XunitTestFrameworkDiscoverer..ctor(IAssemblyInfo assemblyInfo, ISourceInformationProvider sourceProvider, IMessageSink diagnosticMessageSink, IXunitTestCollectionFactory collectionFactory) in /_/src/xunit.execution/Sdk/Frameworks/XunitTestFrameworkDiscoverer.cs:line 45 at Xunit.Sdk.XunitTestFramework.CreateDiscoverer(IAssemblyInfo assemblyInfo) in /_/src/xunit.execution/Sdk/Frameworks/XunitTestFramework.cs:line 21 at Xunit.Sdk.TestFramework.GetDiscoverer(IAssemblyInfo assemblyInfo) in /_/src/xunit.execution/Sdk/Frameworks/TestFramework.cs:line 71 at Xunit.Sdk.TestFrameworkProxy.GetDiscoverer(IAssemblyInfo assembly) in /_/src/xunit.execution/Sdk/Frameworks/TestFrameworkProxy.cs:line 68 at Xunit.Xunit2Discoverer..ctor(AppDomainSupport appDomainSupport, ISourceInformationProvider sourceInformationProvider, IAssemblyInfo assemblyInfo, String assemblyFileName, String xunitExecutionAssemblyPath, String configFileName, Boolean shadowCopy, String shadowCopyFolder, IMessageSink diagnosticMessageSink, Boolean verifyAssembliesOnDisk) in /_/src/xunit.runner.utility/Frameworks/v2/Xunit2Discoverer.cs:line 107 at Xunit.Xunit2Discoverer..ctor(AppDomainSupport appDomainSupport, ISourceInformationProvider sourceInformationProvider, String assemblyFileName, String configFileName, Boolean shadowCopy, String shadowCopyFolder, IMessageSink diagnosticMessageSink, Boolean verifyAssembliesOnDisk) in /_/src/xunit.runner.utility/Frameworks/v2/Xunit2Discoverer.cs:line 63 at Xunit.Xunit2..ctor(AppDomainSupport appDomainSupport, ISourceInformationProvider sourceInformationProvider, String assemblyFileName, String configFileName, Boolean shadowCopy, String shadowCopyFolder, IMessageSink diagnosticMessageSink, Boolean verifyTestAssemblyExists) in /_/src/xunit.runner.utility/Frameworks/v2/Xunit2.cs:line 41 at Xunit.XunitFrontController.CreateInnerController() in /_/src/xunit.runner.utility/Frameworks/XunitFrontController.cs:line 134 at Xunit.XunitFrontController.EnsureInitialized() in /_/src/xunit.runner.utility/Frameworks/XunitFrontController.cs:line 153 at Xunit.XunitFrontController.get_InnerController() in /_/src/xunit.runner.utility/Frameworks/XunitFrontController.cs:line 93 at Xunit.XunitFrontController.Find(Boolean includeSourceInformation, IMessageSink messageSink, ITestFrameworkDiscoveryOptions discoveryOptions) in /_/src/xunit.runner.utility/Frameworks/XunitFrontController.cs:line 163 at TestFrameworkExtensions.Find(ITestFrameworkDiscoverer discoverer, Boolean includeSourceInformation, IMessageSinkWithTypes discoveryMessageSink, ITestFrameworkDiscoveryOptions discoveryOptions) in /_/src/xunit.runner.utility/Extensions/TestFrameworkExtensions.cs:line 22 at JetBrains.ReSharper.TestRunner.Adapters.XUnit.Discoverer.ReportAll() in Z:\\BuildAgent\\work\\1b668fe37ef92293\\ReSharperTestRunner\\src\\Adapters\\TestRunner.Adapters.XUnit\\Discoverer.cs:line 57 at JetBrains.ReSharper.TestRunner.Adapters.XUnit.XUnitRunner.RunTests(TestRunRequest request, ITestDiscoverySink discoverySink, ITestExecutionSink executionSink) in Z:\\BuildAgent\\work\\1b668fe37ef92293\\ReSharperTestRunner\\src\\Adapters\\TestRunner.Adapters.XUnit\\XUnitRunner.cs:line 62 at JetBrains.ReSharper.TestRunner.Implementation.UnitTestRemoteAgent.Execute(TestRunRequest request) at JetBrains.ReSharper.TestRunner.Implementation.ClientEndpoint.\u003c\u003ec__DisplayClass4_1.\u003cTryRegisterHandler\u003eb__1() at System.Threading.Tasks.Task`1.InnerInvoke() at System.Threading.ExecutionContext.RunFromThreadPoolDispatchLoop(Thread threadPoolThread, ExecutionContext executionContext, ContextCallback callback, Object state) --- End of stack trace from previous location --- at System.Threading.ExecutionContext.RunFromThreadPoolDispatchLoop(Thread threadPoolThread, ExecutionContext executionContext, ContextCallback callback, Object state) at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread) --- End of stack trace from previous location --- at JetBrains.ReSharper.TestRunner.Implementation.ClientEndpoint.RunAndLog(Func`2 handler, IAutoRegisterInProtocol message)\n\n--- EXCEPTION dotnet/roslyn#1/2 [RdFault]\nMessage = “\n  Could not load type \u0027Tests.IInterface`2\u0027 from assembly \u0027TheCovariantTests, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\u0027 because a covariant or contravariant type parameter was used illegally in a type parameter constraint in method \u0027\u0027., reason: System.TypeLoadException: Could not load type \u0027Tests.IInterface`2\u0027 from assembly \u0027TheCovariantTests, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\u0027 because a covariant or contravariant type parameter was used illegally in a type parameter constraint in method \u0027\u0027.\n     at System.Reflection.RuntimeAssembly.GetExportedTypes()\n     at Xunit.Sdk.ReflectionAssemblyInfo.GetTypes(Boolean includePrivateTypes) in /_/src/xunit.execution/Sdk/Reflection/ReflectionAssemblyInfo.cs:line 80\n     at Xunit.Sdk.TestCollectionFactoryHelper.GetTestCollectionDefinitions(IAssemblyInfo assemblyInfo, IMessageSink diagnosticMessageSink) in /_/src/xunit.execution/Sdk/Frameworks/TestCollectionFactoryHelper.cs:line 22\n     at Xunit.Sdk.CollectionPerClassTestCollectionFactory..ctor(ITestAssembly testAssembly, IMessageSink diagnosticMessageSink) in /_/src/xunit.execution/Sdk/Frameworks/CollectionPerClassTestCollectionFactory.cs:line 27\n     at Xunit.Sdk.ExtensibilityPointFactory.GetXunitTestCollectionFactory(IMessageSink diagnosticMessageSink, IAttributeInfo collectionBehaviorAttribute, ITestAssembly testAssembly) in /_/src/xunit.execution/Sdk/ExtensibilityPointFactory.cs:line 245\n     at Xunit.Sdk.XunitTestFrameworkDiscoverer..ctor(IAssemblyInfo assemblyInfo, ISourceInformationProvider sourceProvider, IMessageSink diagnosticMessageSink, IXunitTestCollectionFactory collectionFactory) in /_/src/xunit.execution/Sdk/Frameworks/XunitTestFrameworkDiscoverer.cs:line 45\n     at Xunit.Sdk.XunitTestFramework.CreateDiscoverer(IAssemblyInfo assemblyInfo) in /_/src/xunit.execution/Sdk/Frameworks/XunitTestFramework.cs:line 21\n     at Xunit.Sdk.TestFramework.GetDiscoverer(IAssemblyInfo assemblyInfo) in /_/src/xunit.execution/Sdk/Frameworks/TestFramework.cs:line 71\n     at Xunit.Sdk.TestFrameworkProxy.GetDiscoverer(IAssemblyInfo assembly) in /_/src/xunit.execution/Sdk/Frameworks/TestFrameworkProxy.cs:line 68\n     at Xunit.Xunit2Discoverer..ctor(AppDomainSupport appDomainSupport, ISourceInformationProvider sourceInformationProvider, IAssemblyInfo assemblyInfo, String assemblyFileName, String xunitExecutionAssemblyPath, String configFileName, Boolean shadowCopy, String shadowCopyFolder, IMessageSink diagnosticMessageSink, Boolean verifyAssembliesOnDisk) in /_/src/xunit.runner.utility/Frameworks/v2/Xunit2Discoverer.cs:line 107\n     at Xunit.Xunit2Discoverer..ctor(AppDomainSupport appDomainSupport, ISourceInformationProvider sourceInformationProvider, String assemblyFileName, String configFileName, Boolean shadowCopy, String shadowCopyFolder, IMessageSink diagnosticMessageSink, Boolean verifyAssembliesOnDisk) in /_/src/xunit.runner.utility/Frameworks/v2/Xunit2Discoverer.cs:line 63\n     at Xunit.Xunit2..ctor(AppDomainSupport appDomainSupport, ISourceInformationProvider sourceInformationProvider, String assemblyFileName, String configFileName, Boolean shadowCopy, String shadowCopyFolder, IMessageSink diagnosticMessageSink, Boolean verifyTestAssemblyExists) in /_/src/xunit.runner.utility/Frameworks/v2/Xunit2.cs:line 41\n     at Xunit.XunitFrontController.CreateInnerController() in /_/src/xunit.runner.utility/Frameworks/XunitFrontController.cs:line 134\n     at Xunit.XunitFrontController.EnsureInitialized() in /_/src/xunit.runner.utility/Frameworks/XunitFrontController.cs:line 153\n     at Xunit.XunitFrontController.get_InnerController() in /_/src/xunit.runner.utility/Frameworks/XunitFrontController.cs:line 93\n     at Xunit.XunitFrontController.Find(Boolean includeSourceInformation, IMessageSink messageSink, ITestFrameworkDiscoveryOptions discoveryOptions) in /_/src/xunit.runner.utility/Frameworks/XunitFrontController.cs:line 163\n     at TestFrameworkExtensions.Find(ITestFrameworkDiscoverer discoverer, Boolean includeSourceInformation, IMessageSinkWithTypes discoveryMessageSink, ITestFrameworkDiscoveryOptions discoveryOptions) in /_/src/xunit.runner.utility/Extensions/TestFrameworkExtensions.cs:line 22\n     at JetBrains.ReSharper.TestRunner.Adapters.XUnit.Discoverer.ReportAll() in Z:\\BuildAgent\\work\\1b668fe37ef92293\\ReSharperTestRunner\\src\\Adapters\\TestRunner.Adapters.XUnit\\Discoverer.cs:line 57\n     at JetBrains.ReSharper.TestRunner.Adapters.XUnit.XUnitRunner.RunTests(TestRunRequest request, ITestDiscoverySink discoverySink, ITestExecutionSink executionSink) in Z:\\BuildAgent\\work\\1b668fe37ef92293\\ReSharperTestRunner\\src\\Adapters\\TestRunner.Adapters.XUnit\\XUnitRunner.cs:line 62\n     at JetBrains.ReSharper.TestRunner.Implementation.UnitTestRemoteAgent.Execute(TestRunRequest request)\n     at JetBrains.ReSharper.TestRunner.Implementation.ClientEndpoint.\u003c\u003ec__DisplayClass4_1.\u003cTryRegisterHandler\u003eb__1()\n     at System.Threading.Tasks.Task`1.InnerInvoke()\n     at System.Threading.ExecutionContext.RunFromThreadPoolDispatchLoop(Thread threadPoolThread, ExecutionContext executionContext, ContextCallback callback, Object state)\n  --- End of stack trace from previous location ---\n     at System.Threading.ExecutionContext.RunFromThreadPoolDispatchLoop(Thread threadPoolThread, ExecutionContext executionContext, ContextCallback callback, Object state)\n     at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\n  --- End of stack trace from previous location ---\n     at JetBrains.ReSharper.TestRunner.Implementation.ClientEndpoint.RunAndLog(Func`2 handler, IAutoRegisterInProtocol message)\n”\nReasonTypeFqn = System.TypeLoadException\nReasonText = “\n  System.TypeLoadException: Could not load type \u0027Tests.IInterface`2\u0027 from assembly \u0027TheCovariantTests, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\u0027 because a covariant or contravariant type parameter was used illegally in a type parameter constraint in method \u0027\u0027.\n     at System.Reflection.RuntimeAssembly.GetExportedTypes()\n     at Xunit.Sdk.ReflectionAssemblyInfo.GetTypes(Boolean includePrivateTypes) in /_/src/xunit.execution/Sdk/Reflection/ReflectionAssemblyInfo.cs:line 80\n     at Xunit.Sdk.TestCollectionFactoryHelper.GetTestCollectionDefinitions(IAssemblyInfo assemblyInfo, IMessageSink diagnosticMessageSink) in /_/src/xunit.execution/Sdk/Frameworks/TestCollectionFactoryHelper.cs:line 22\n     at Xunit.Sdk.CollectionPerClassTestCollectionFactory..ctor(ITestAssembly testAssembly, IMessageSink diagnosticMessageSink) in /_/src/xunit.execution/Sdk/Frameworks/CollectionPerClassTestCollectionFactory.cs:line 27\n     at Xunit.Sdk.ExtensibilityPointFactory.GetXunitTestCollectionFactory(IMessageSink diagnosticMessageSink, IAttributeInfo collectionBehaviorAttribute, ITestAssembly testAssembly) in /_/src/xunit.execution/Sdk/ExtensibilityPointFactory.cs:line 245\n     at Xunit.Sdk.XunitTestFrameworkDiscoverer..ctor(IAssemblyInfo assemblyInfo, ISourceInformationProvider sourceProvider, IMessageSink diagnosticMessageSink, IXunitTestCollectionFactory collectionFactory) in /_/src/xunit.execution/Sdk/Frameworks/XunitTestFrameworkDiscoverer.cs:line 45\n     at Xunit.Sdk.XunitTestFramework.CreateDiscoverer(IAssemblyInfo assemblyInfo) in /_/src/xunit.execution/Sdk/Frameworks/XunitTestFramework.cs:line 21\n     at Xunit.Sdk.TestFramework.GetDiscoverer(IAssemblyInfo assemblyInfo) in /_/src/xunit.execution/Sdk/Frameworks/TestFramework.cs:line 71\n     at Xunit.Sdk.TestFrameworkProxy.GetDiscoverer(IAssemblyInfo assembly) in /_/src/xunit.execution/Sdk/Frameworks/TestFrameworkProxy.cs:line 68\n     at Xunit.Xunit2Discoverer..ctor(AppDomainSupport appDomainSupport, ISourceInformationProvider sourceInformationProvider, IAssemblyInfo assemblyInfo, String assemblyFileName, String xunitExecutionAssemblyPath, String configFileName, Boolean shadowCopy, String shadowCopyFolder, IMessageSink diagnosticMessageSink, Boolean verifyAssembliesOnDisk) in /_/src/xunit.runner.utility/Frameworks/v2/Xunit2Discoverer.cs:line 107\n     at Xunit.Xunit2Discoverer..ctor(AppDomainSupport appDomainSupport, ISourceInformationProvider sourceInformationProvider, String assemblyFileName, String configFileName, Boolean shadowCopy, String shadowCopyFolder, IMessageSink diagnosticMessageSink, Boolean verifyAssembliesOnDisk) in /_/src/xunit.runner.utility/Frameworks/v2/Xunit2Discoverer.cs:line 63\n     at Xunit.Xunit2..ctor(AppDomainSupport appDomainSupport, ISourceInformationProvider sourceInformationProvider, String assemblyFileName, String configFileName, Boolean shadowCopy, String shadowCopyFolder, IMessageSink diagnosticMessageSink, Boolean verifyTestAssemblyExists) in /_/src/xunit.runner.utility/Frameworks/v2/Xunit2.cs:line 41\n     at Xunit.XunitFrontController.CreateInnerController() in /_/src/xunit.runner.utility/Frameworks/XunitFrontController.cs:line 134\n     at Xunit.XunitFrontController.EnsureInitialized() in /_/src/xunit.runner.utility/Frameworks/XunitFrontController.cs:line 153\n     at Xunit.XunitFrontController.get_InnerController() in /_/src/xunit.runner.utility/Frameworks/XunitFrontController.cs:line 93\n     at Xunit.XunitFrontController.Find(Boolean includeSourceInformation, IMessageSink messageSink, ITestFrameworkDiscoveryOptions discoveryOptions) in /_/src/xunit.runner.utility/Frameworks/XunitFrontController.cs:line 163\n     at TestFrameworkExtensions.Find(ITestFrameworkDiscoverer discoverer, Boolean includeSourceInformation, IMessageSinkWithTypes discoveryMessageSink, ITestFrameworkDiscoveryOptions discoveryOptions) in /_/src/xunit.runner.utility/Extensions/TestFrameworkExtensions.cs:line 22\n     at JetBrains.ReSharper.TestRunner.Adapters.XUnit.Discoverer.ReportAll() in Z:\\BuildAgent\\work\\1b668fe37ef92293\\ReSharperTestRunner\\src\\Adapters\\TestRunner.Adapters.XUnit\\Discoverer.cs:line 57\n     at JetBrains.ReSharper.TestRunner.Adapters.XUnit.XUnitRunner.RunTests(TestRunRequest request, ITestDiscoverySink discoverySink, ITestExecutionSink executionSink) in Z:\\BuildAgent\\work\\1b668fe37ef92293\\ReSharperTestRunner\\src\\Adapters\\TestRunner.Adapters.XUnit\\XUnitRunner.cs:line 62\n     at JetBrains.ReSharper.TestRunner.Implementation.UnitTestRemoteAgent.Execute(TestRunRequest request)\n     at JetBrains.ReSharper.TestRunner.Implementation.ClientEndpoint.\u003c\u003ec__DisplayClass4_1.\u003cTryRegisterHandler\u003eb__1()\n     at System.Threading.Tasks.Task`1.InnerInvoke()\n     at System.Threading.ExecutionContext.RunFromThreadPoolDispatchLoop(Thread threadPoolThread, ExecutionContext executionContext, ContextCallback callback, Object state)\n  --- End of stack trace from previous location ---\n     at System.Threading.ExecutionContext.RunFromThreadPoolDispatchLoop(Thread threadPoolThread, ExecutionContext executionContext, ContextCallback callback, Object state)\n     at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\n  --- End of stack trace from previous location ---\n     at JetBrains.ReSharper.TestRunner.Implementation.ClientEndpoint.RunAndLog(Func`2 handler, IAutoRegisterInProtocol message)\n”\nReasonMessage = “Could not load type \u0027Tests.IInterface`2\u0027 from assembly \u0027TheCovariantTests, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\u0027 because a covariant or contravariant type parameter was used illegally in a type parameter constraint in method \u0027\u0027.”\nStackTraceString = “\n  at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() in Throw.il:line IL_000C mvid BC47\n     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in HandleNonSuccessAndDebuggerNotification.il:line IL_0028 mvid BC47\n     at JetBrains.ReSharper.UnitTestFramework.Execution.TestRunner.Activation.ServerMessageBroker.\u003cSendMessage\u003ed__2.MoveNext() in SendMessage.il:line IL_0077 mvid 42AD\n  --- End of stack trace from previous location where exception was thrown ---\n     at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() in Throw.il:line IL_000C mvid BC47\n     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in HandleNonSuccessAndDebuggerNotification.il:line IL_0028 mvid BC47\n     at JetBrains.ReSharper.UnitTestFramework.Execution.TestRunner.TestRunnerAgentManager.TestRunnerExecutionAgent.\u003c\u003cRunTests\u003eb__8_1\u003ed.MoveNext() in RunTests.il:line IL_00AE mvid 42AD or RunTests.il:line IL_02D6 mvid 42AD\n  --- End of stack trace from previous location where exception was thrown ---\n     at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() in Throw.il:line IL_000C mvid BC47\n     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in HandleNonSuccessAndDebuggerNotification.il:line IL_0028 mvid BC47\n     at JetBrains.ReSharper.UnitTestFramework.Common.Extensions.TaskExtensions.\u003cThrowIf\u003ed__13`1.MoveNext() in ThrowIf.il:line IL_0118 mvid 42AD\n  --- End of stack trace from previous location where exception was thrown ---\n     at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() in Throw.il:line IL_000C mvid BC47\n     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in HandleNonSuccessAndDebuggerNotification.il:line IL_0028 mvid BC47\n     at JetBrains.ReSharper.UnitTestFramework.Common.Extensions.TaskExtensions.\u003cCancelIf\u003ed__15.MoveNext() in CancelIf.il:line IL_0126 mvid 42AD\n  --- End of stack trace from previous location where exception was thrown ---\n     at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() in Throw.il:line IL_000C mvid BC47\n     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in HandleNonSuccessAndDebuggerNotification.il:line IL_0028 mvid BC47\n     at JetBrains.ReSharper.UnitTestFramework.Execution.TestRunner.TestRunnerAgentManager.TestRunnerExecutionAgent.\u003cRunTests\u003ed__8.MoveNext() in RunTests.il:line IL_00AE mvid 42AD or RunTests.il:line IL_02D6 mvid 42AD\n  --- End of stack trace from previous location where exception was thrown ---\n     at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() in Throw.il:line IL_000C mvid BC47\n     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in HandleNonSuccessAndDebuggerNotification.il:line IL_0028 mvid BC47\n     at JetBrains.ReSharper.UnitTestFramework.Execution.TestRunner.TestRunnerRunStrategy.\u003cRun\u003ed__14.MoveNext() in Run.il:line IL_01C8 mvid 42AD\n  --- End of stack trace from previous location where exception was thrown ---\n     at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() in Throw.il:line IL_000C mvid BC47\n     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in HandleNonSuccessAndDebuggerNotification.il:line IL_0028 mvid BC47\n     at JetBrains.ReSharper.UnitTestFramework.Execution.Launch.UnitTestRun.\u003cStartCore\u003ed__37.MoveNext() in StartCore.il:line IL_01E7 mvid 42AD or StartCore.il:line IL_03B3 mvid 42AD\n  --- End of stack trace from previous location where exception was thrown ---\n     at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() in Throw.il:line IL_000C mvid BC47\n     at JetBrains.Util.Special.GeneralUtil.WithNotNull[T](T item, Action`1 F) in WithNotNull.il:line IL_001D mvid 4DEE\n     at JetBrains.ReSharper.UnitTestFramework.Execution.Launch.UnitTestRun.\u003cStartCore\u003ed__37.MoveNext() in StartCore.il:line IL_01E7 mvid 42AD or StartCore.il:line IL_03B3 mvid 42AD\n  --- End of stack trace from previous location where exception was thrown ---\n     at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() in Throw.il:line IL_000C mvid BC47\n     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in HandleNonSuccessAndDebuggerNotification.il:line IL_0028 mvid BC47\n     at JetBrains.ReSharper.UnitTestFramework.Execution.Launch.UnitTestRun.\u003cStart\u003ed__36.MoveNext() in Start.il:line IL_0182 mvid 42AD\n”\nExceptionPath = Root.InnerException\nClassName = JetBrains.Rd.Tasks.RdFault\nHResult = COR_E_EXCEPTION=80131500\nSource = mscorlib\nData.ThreadLocalDebugInfo = “\n  call `ServerSocket-\u003cnoname\u003e.JetBrains.ReSharper.TestRunner.Abstractions.IClientEndpoint.System.Threading.Tasks.Task`1[JetBrains.ReSharper.TestRunner.Abstractions.Objects.IAutoRegisterInProtocol] SendMessage(JetBrains.ReSharper.TestRunner.Abstractions.Objects.IAutoRegisterInProtocol)_proxy` (2763052212960334136), taskId=1000006\n   -\u003e call `ServerSocket-\u003cnoname\u003e.JetBrains.ReSharper.TestRunner.Abstractions.IClientEndpoint.System.Threading.Tasks.Task`1[JetBrains.ReSharper.TestRunner.Abstractions.Objects.IAutoRegisterInProtocol] SendMessage(JetBrains.ReSharper.TestRunner.Abstractions.Objects.IAutoRegisterInProtocol)_proxy` (2763052212960334136), taskId=1000006\n”\n\n--- Outer ---\n\n--- EXCEPTION dotnet/roslyn#2/2 [LoggerException]\nMessage = “\n  Could not load type \u0027Tests.IInterface`2\u0027 from assembly \u0027TheCovariantTests, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\u0027 because a covariant or contravariant type parameter was used illegally in a type parameter constraint in method \u0027\u0027., reason: System.TypeLoadException: Could not load type \u0027Tests.IInterface`2\u0027 from assembly \u0027TheCovariantTests, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\u0027 because a covariant or contravariant type parameter was used illegally in a type parameter constraint in method \u0027\u0027.\n     at System.Reflection.RuntimeAssembly.GetExportedTypes()\n     at Xunit.Sdk.ReflectionAssemblyInfo.GetTypes(Boolean includePrivateTypes) in /_/src/xunit.execution/Sdk/Reflection/ReflectionAssemblyInfo.cs:line 80\n     at Xunit.Sdk.TestCollectionFactoryHelper.GetTestCollectionDefinitions(IAssemblyInfo assemblyInfo, IMessageSink diagnosticMessageSink) in /_/src/xunit.execution/Sdk/Frameworks/TestCollectionFactoryHelper.cs:line 22\n     at Xunit.Sdk.CollectionPerClassTestCollectionFactory..ctor(ITestAssembly testAssembly, IMessageSink diagnosticMessageSink) in /_/src/xunit.execution/Sdk/Frameworks/CollectionPerClassTestCollectionFactory.cs:line 27\n     at Xunit.Sdk.ExtensibilityPointFactory.GetXunitTestCollectionFactory(IMessageSink diagnosticMessageSink, IAttributeInfo collectionBehaviorAttribute, ITestAssembly testAssembly) in /_/src/xunit.execution/Sdk/ExtensibilityPointFactory.cs:line 245\n     at Xunit.Sdk.XunitTestFrameworkDiscoverer..ctor(IAssemblyInfo assemblyInfo, ISourceInformationProvider sourceProvider, IMessageSink diagnosticMessageSink, IXunitTestCollectionFactory collectionFactory) in /_/src/xunit.execution/Sdk/Frameworks/XunitTestFrameworkDiscoverer.cs:line 45\n     at Xunit.Sdk.XunitTestFramework.CreateDiscoverer(IAssemblyInfo assemblyInfo) in /_/src/xunit.execution/Sdk/Frameworks/XunitTestFramework.cs:line 21\n     at Xunit.Sdk.TestFramework.GetDiscoverer(IAssemblyInfo assemblyInfo) in /_/src/xunit.execution/Sdk/Frameworks/TestFramework.cs:line 71\n     at Xunit.Sdk.TestFrameworkProxy.GetDiscoverer(IAssemblyInfo assembly) in /_/src/xunit.execution/Sdk/Frameworks/TestFrameworkProxy.cs:line 68\n     at Xunit.Xunit2Discoverer..ctor(AppDomainSupport appDomainSupport, ISourceInformationProvider sourceInformationProvider, IAssemblyInfo assemblyInfo, String assemblyFileName, String xunitExecutionAssemblyPath, String configFileName, Boolean shadowCopy, String shadowCopyFolder, IMessageSink diagnosticMessageSink, Boolean verifyAssembliesOnDisk) in /_/src/xunit.runner.utility/Frameworks/v2/Xunit2Discoverer.cs:line 107\n     at Xunit.Xunit2Discoverer..ctor(AppDomainSupport appDomainSupport, ISourceInformationProvider sourceInformationProvider, String assemblyFileName, String configFileName, Boolean shadowCopy, String shadowCopyFolder, IMessageSink diagnosticMessageSink, Boolean verifyAssembliesOnDisk) in /_/src/xunit.runner.utility/Frameworks/v2/Xunit2Discoverer.cs:line 63\n     at Xunit.Xunit2..ctor(AppDomainSupport appDomainSupport, ISourceInformationProvider sourceInformationProvider, String assemblyFileName, String configFileName, Boolean shadowCopy, String shadowCopyFolder, IMessageSink diagnosticMessageSink, Boolean verifyTestAssemblyExists) in /_/src/xunit.runner.utility/Frameworks/v2/Xunit2.cs:line 41\n     at Xunit.XunitFrontController.CreateInnerController() in /_/src/xunit.runner.utility/Frameworks/XunitFrontController.cs:line 134\n     at Xunit.XunitFrontController.EnsureInitialized() in /_/src/xunit.runner.utility/Frameworks/XunitFrontController.cs:line 153\n     at Xunit.XunitFrontController.get_InnerController() in /_/src/xunit.runner.utility/Frameworks/XunitFrontController.cs:line 93\n     at Xunit.XunitFrontController.Find(Boolean includeSourceInformation, IMessageSink messageSink, ITestFrameworkDiscoveryOptions discoveryOptions) in /_/src/xunit.runner.utility/Frameworks/XunitFrontController.cs:line 163\n     at TestFrameworkExtensions.Find(ITestFrameworkDiscoverer discoverer, Boolean includeSourceInformation, IMessageSinkWithTypes discoveryMessageSink, ITestFrameworkDiscoveryOptions discoveryOptions) in /_/src/xunit.runner.utility/Extensions/TestFrameworkExtensions.cs:line 22\n     at JetBrains.ReSharper.TestRunner.Adapters.XUnit.Discoverer.ReportAll() in Z:\\BuildAgent\\work\\1b668fe37ef92293\\ReSharperTestRunner\\src\\Adapters\\TestRunner.Adapters.XUnit\\Discoverer.cs:line 57\n     at JetBrains.ReSharper.TestRunner.Adapters.XUnit.XUnitRunner.RunTests(TestRunRequest request, ITestDiscoverySink discoverySink, ITestExecutionSink executionSink) in Z:\\BuildAgent\\work\\1b668fe37ef92293\\ReSharperTestRunner\\src\\Adapters\\TestRunner.Adapters.XUnit\\XUnitRunner.cs:line 62\n     at JetBrains.ReSharper.TestRunner.Implementation.UnitTestRemoteAgent.Execute(TestRunRequest request)\n     at JetBrains.ReSharper.TestRunner.Implementation.ClientEndpoint.\u003c\u003ec__DisplayClass4_1.\u003cTryRegisterHandler\u003eb__1()\n     at System.Threading.Tasks.Task`1.InnerInvoke()\n     at System.Threading.ExecutionContext.RunFromThreadPoolDispatchLoop(Thread threadPoolThread, ExecutionContext executionContext, ContextCallback callback, Object state)\n  --- End of stack trace from previous location ---\n     at System.Threading.ExecutionContext.RunFromThreadPoolDispatchLoop(Thread threadPoolThread, ExecutionContext executionContext, ContextCallback callback, Object state)\n     at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\n  --- End of stack trace from previous location ---\n     at JetBrains.ReSharper.TestRunner.Implementation.ClientEndpoint.RunAndLog(Func`2 handler, IAutoRegisterInProtocol message)\n”\nInnerException = “Exception dotnet/roslyn#1 at Root.InnerException”\nStackTraceString = “\n  at JetBrains.Util.ILoggerEx.LogException(ILogger logger, LoggingLevel level, Exception exception, ExceptionOrigin exceptionOrigin, String comment) in LogException.il:line IL_0025 mvid 4DEE\n     at JetBrains.Util.ILoggerEx.Error(ILogger logger, Exception exception, ExceptionOrigin origin, String comment) in Error.il:line IL_000A mvid 4DEE\n     at JetBrains.ReSharper.UnitTestFramework.Execution.Launch.UnitTestRun.\u003cStart\u003ed__36.MoveNext() in Start.il:line IL_0182 mvid 42AD\n     at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx) in RunInternal.il:line IL_0079 mvid BC47\n     at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx) in Run.il:line IL_0009 mvid BC47 or Run.il:line IL_0034 mvid BC47\n     at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run() in Run.il:line IL_0024 mvid BC47\n     at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task\u0026 currentTask) in RunOrScheduleAction.il:line IL_001C mvid BC47\n     at System.Threading.Tasks.Task.FinishContinuations() in FinishContinuations.il:line IL_0085 mvid BC47 or FinishContinuations.il:line IL_0099 mvid BC47\n     at System.Threading.Tasks.Task.Finish(Boolean bUserDelegateExecuted) in Finish.il:line IL_0085 mvid BC47\n     at System.Threading.Tasks.Task`1.TrySetException(Object exceptionObject) in TrySetException.il:line IL_002A mvid BC47\n     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetException(Exception exception) in SetException.il:line IL_0026 mvid BC47\n     at JetBrains.ReSharper.UnitTestFramework.Execution.Launch.UnitTestRun.\u003cStartCore\u003ed__37.MoveNext() in StartCore.il:line IL_03B3 mvid 42AD\n     at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx) in RunInternal.il:line IL_0079 mvid BC47\n     at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx) in Run.il:line IL_0009 mvid BC47 or Run.il:line IL_0034 mvid BC47\n     at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run() in Run.il:line IL_0024 mvid BC47\n     at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task\u0026 currentTask) in RunOrScheduleAction.il:line IL_001C mvid BC47\n     at System.Threading.Tasks.Task.FinishContinuations() in FinishContinuations.il:line IL_0085 mvid BC47 or FinishContinuations.il:line IL_0099 mvid BC47\n     at System.Threading.Tasks.Task.Finish(Boolean bUserDelegateExecuted) in Finish.il:line IL_0085 mvid BC47\n     at System.Threading.Tasks.Task`1.TrySetException(Object exceptionObject) in TrySetException.il:line IL_002A mvid BC47\n     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetException(Exception exception) in SetException.il:line IL_0026 mvid BC47\n     at JetBrains.ReSharper.UnitTestFramework.Execution.TestRunner.TestRunnerRunStrategy.\u003cRun\u003ed__14.MoveNext() in Run.il:line IL_01C8 mvid 42AD\n     at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx) in RunInternal.il:line IL_0079 mvid BC47\n     at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx) in Run.il:line IL_0009 mvid BC47 or Run.il:line IL_0034 mvid BC47\n     at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run() in Run.il:line IL_0024 mvid BC47\n     at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task\u0026 currentTask) in RunOrScheduleAction.il:line IL_001C mvid BC47\n     at System.Threading.Tasks.Task.FinishContinuations() in FinishContinuations.il:line IL_0085 mvid BC47 or FinishContinuations.il:line IL_0099 mvid BC47\n     at System.Threading.Tasks.Task.Finish(Boolean bUserDelegateExecuted) in Finish.il:line IL_0085 mvid BC47\n     at System.Threading.Tasks.Task`1.TrySetException(Object exceptionObject) in TrySetException.il:line IL_002A mvid BC47\n     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetException(Exception exception) in SetException.il:line IL_0026 mvid BC47\n     at JetBrains.ReSharper.UnitTestFramework.Execution.TestRunner.TestRunnerAgentManager.TestRunnerExecutionAgent.\u003cRunTests\u003ed__8.MoveNext() in RunTests.il:line IL_00AE mvid 42AD or RunTests.il:line IL_02D6 mvid 42AD\n     at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx) in RunInternal.il:line IL_0079 mvid BC47\n     at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx) in Run.il:line IL_0009 mvid BC47 or Run.il:line IL_0034 mvid BC47\n     at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run() in Run.il:line IL_0024 mvid BC47\n     at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task\u0026 currentTask) in RunOrScheduleAction.il:line IL_001C mvid BC47\n     at System.Threading.Tasks.Task.FinishContinuations() in FinishContinuations.il:line IL_0085 mvid BC47 or FinishContinuations.il:line IL_0099 mvid BC47\n     at System.Threading.Tasks.Task.Finish(Boolean bUserDelegateExecuted) in Finish.il:line IL_0085 mvid BC47\n     at System.Threading.Tasks.Task`1.TrySetException(Object exceptionObject) in TrySetException.il:line IL_002A mvid BC47\n     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetException(Exception exception) in SetException.il:line IL_0026 mvid BC47\n     at JetBrains.ReSharper.UnitTestFramework.Common.Extensions.TaskExtensions.\u003cCancelIf\u003ed__15.MoveNext() in CancelIf.il:line IL_0126 mvid 42AD\n     at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx) in RunInternal.il:line IL_0079 mvid BC47\n     at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx) in Run.il:line IL_0009 mvid BC47 or Run.il:line IL_0034 mvid BC47\n     at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run() in Run.il:line IL_0024 mvid BC47\n     at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task\u0026 currentTask) in RunOrScheduleAction.il:line IL_001C mvid BC47\n     at System.Threading.Tasks.Task.FinishContinuations() in FinishContinuations.il:line IL_0085 mvid BC47 or FinishContinuations.il:line IL_0099 mvid BC47\n     at System.Threading.Tasks.Task`1.TrySetResult(TResult result) in TrySetResult.il:line IL_0055 mvid BC47\n     at System.Threading.Tasks.TaskFactory.CompleteOnInvokePromise.Invoke(Task completingTask) in Invoke.il:line IL_004A mvid BC47\n     at System.Threading.Tasks.Task.FinishContinuations() in FinishContinuations.il:line IL_0085 mvid BC47 or FinishContinuations.il:line IL_0099 mvid BC47\n     at System.Threading.Tasks.Task.Finish(Boolean bUserDelegateExecuted) in Finish.il:line IL_0085 mvid BC47\n     at System.Threading.Tasks.Task`1.TrySetException(Object exceptionObject) in TrySetException.il:line IL_002A mvid BC47\n     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetException(Exception exception) in SetException.il:line IL_0026 mvid BC47\n     at JetBrains.ReSharper.UnitTestFramework.Common.Extensions.TaskExtensions.\u003cThrowIf\u003ed__13`1.MoveNext() in ThrowIf.il:line IL_0118 mvid 42AD\n     at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx) in RunInternal.il:line IL_0079 mvid BC47\n     at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx) in Run.il:line IL_0009 mvid BC47 or Run.il:line IL_0034 mvid BC47\n     at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run() in Run.il:line IL_0024 mvid BC47\n     at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task\u0026 currentTask) in RunOrScheduleAction.il:line IL_001C mvid BC47\n     at System.Threading.Tasks.Task.FinishContinuations() in FinishContinuations.il:line IL_0085 mvid BC47 or FinishContinuations.il:line IL_0099 mvid BC47\n     at System.Threading.Tasks.Task`1.TrySetResult(TResult result) in TrySetResult.il:line IL_0055 mvid BC47\n     at System.Threading.Tasks.TaskFactory.CompleteOnInvokePromise.Invoke(Task completingTask) in Invoke.il:line IL_004A mvid BC47\n     at System.Threading.Tasks.Task.FinishContinuations() in FinishContinuations.il:line IL_0085 mvid BC47 or FinishContinuations.il:line IL_0099 mvid BC47\n     at System.Threading.Tasks.Task.Finish(Boolean bUserDelegateExecuted) in Finish.il:line IL_0085 mvid BC47\n     at System.Threading.Tasks.Task`1.TrySetException(Object exceptionObject) in TrySetException.il:line IL_002A mvid BC47\n     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetException(Exception exception) in SetException.il:line IL_0026 mvid BC47\n     at JetBrains.ReSharper.UnitTestFramework.Execution.TestRunner.TestRunnerAgentManager.TestRunnerExecutionAgent.\u003c\u003cRunTests\u003eb__8_1\u003ed.MoveNext() in RunTests.il:line IL_00AE mvid 42AD or RunTests.il:line IL_02D6 mvid 42AD\n     at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx) in RunInternal.il:line IL_0079 mvid BC47\n     at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx) in Run.il:line IL_0009 mvid BC47 or Run.il:line IL_0034 mvid BC47\n     at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run() in Run.il:line IL_0024 mvid BC47\n     at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task\u0026 currentTask) in RunOrScheduleAction.il:line IL_001C mvid BC47\n     at System.Threading.Tasks.Task.FinishContinuations() in FinishContinuations.il:line IL_0085 mvid BC47 or FinishContinuations.il:line IL_0099 mvid BC47\n     at System.Threading.Tasks.Task.Finish(Boolean bUserDelegateExecuted) in Finish.il:line IL_0085 mvid BC47\n     at System.Threading.Tasks.Task`1.TrySetException(Object exceptionObject) in TrySetException.il:line IL_002A mvid BC47\n     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetException(Exception exception) in SetException.il:line IL_0026 mvid BC47\n     at JetBrains.ReSharper.UnitTestFramework.Execution.TestRunner.Activation.ServerMessageBroker.\u003cSendMessage\u003ed__2.MoveNext() in SendMessage.il:line IL_0077 mvid 42AD\n     at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx) in RunInternal.il:line IL_0079 mvid BC47\n     at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx) in Run.il:line IL_0009 mvid BC47 or Run.il:line IL_0034 mvid BC47\n     at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run() in Run.il:line IL_0024 mvid BC47\n     at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task\u0026 currentTask) in RunOrScheduleAction.il:line IL_001C mvid BC47\n     at System.Threading.Tasks.Task.FinishContinuations() in FinishContinuations.il:line IL_0085 mvid BC47 or FinishContinuations.il:line IL_0099 mvid BC47\n     at System.Threading.Tasks.Task.Finish(Boolean bUserDelegateExecuted) in Finish.il:line IL_0085 mvid BC47\n     at System.Threading.Tasks.Task`1.TrySetException(Object exceptionObject) in TrySetException.il:line IL_002A mvid BC47\n     at System.Threading.Tasks.TaskCompletionSource`1.TrySetException(Exception exception) in TrySetException.il:line IL_000E mvid BC47\n     at System.Threading.Tasks.TaskCompletionSource`1.SetException(Exception exception) in SetException.il:line IL_000E mvid BC47\n     at JetBrains.Collections.Viewable.SignalBase`1.Fire(T value) in Fire.il:line IL_0028 mvid 5279\n     at JetBrains.Collections.Viewable.WriteOnceProperty`1.WriteOnceSignal.Fire(T value) in Fire.il:line IL_0000 mvid 5279\n     at JetBrains.Collections.Viewable.WriteOnceProperty`1.SetIfEmpty(T newValue) in SetIfEmpty.il:line IL_0046 mvid 5279\n     at JetBrains.Rd.Tasks.WiredRdTask`2.CallSite.\u003c\u003ec__DisplayClass5_0.\u003cOnWireReceived\u003eb__0() in CallSite.il:line IL_0000 mvid 22C3\n     at JetBrains.Rd.Impl.MessageBroker.RdWireableDispatchHelper.\u003c\u003ec__DisplayClass12_0.\u003cDoDispatch\u003eb__0() in RdWireableDispatchHelper.il:line IL_008B mvid 22C3\n     at JetBrains.Rd.Impl.MessageBroker.RdWireableDispatchHelper.DoDispatch(Lifetime lifetime, IScheduler scheduler, Action action) in DoDispatch.il:line IL_00C2 mvid 22C3\n     at JetBrains.Rd.Tasks.WiredRdTask`2.CallSite.OnWireReceived(IProtocol proto, SerializationCtx ctx, UnsafeReader reader, IRdWireableDispatchHelper dispatchHelper) in OnWireReceived.il:line IL_015C mvid 22C3\n     at JetBrains.Rd.Tasks.WiredRdTask`2.OnWireReceived(UnsafeReader reader, IRdWireableDispatchHelper dispatchHelper) in OnWireReceived.il:line IL_007B mvid 22C3\n     at JetBrains.Rd.Impl.MessageBroker.DispatchImpl(Byte[] msg) in DispatchImpl.il:line IL_0112 mvid 22C3\n     at JetBrains.Rd.Impl.MessageBroker.Dispatch(Byte[] msg) in Dispatch.il:line IL_003F mvid 22C3\n     at JetBrains.Diagnostics.LogEx.Catch(ILog log, Action action) in Catch.il:line IL_0000 mvid 5279\n     at JetBrains.Rd.Impl.SocketWire.Base.ReadMsg() in ReadMsg.il:line IL_00C8 mvid 22C3\n     at JetBrains.Rd.Impl.SocketWire.Base.ReceiverProc(Socket socket) in ReceiverProc.il:line IL_006C mvid 22C3\n     at JetBrains.Rd.Impl.SocketWire.Base.\u003c\u003ec__DisplayClass19_0.\u003c.ctor\u003eb__1(Socket socket) in Base.il:line IL_005C mvid 22C3\n     at JetBrains.Collections.Viewable.SignalBase`1.Fire(T value) in Fire.il:line IL_0028 mvid 5279\n     at JetBrains.Collections.Viewable.ViewableProperty`1.set_Value(T value)\n     at JetBrains.Rd.Impl.SocketWire.Server.\u003c\u003ec__DisplayClass4_0.\u003cStartServerSocket\u003eb__1() in Server.il:line IL_002F mvid 22C3 or Server.il:line IL_00F6 mvid 22C3\n     at JetBrains.Diagnostics.LogEx.Catch(ILog log, Action action) in Catch.il:line IL_0000 mvid 5279\n     at JetBrains.Rd.Impl.SocketWire.Server.\u003c\u003ec__DisplayClass4_0.\u003cStartServerSocket\u003eb__0() in Server.il:line IL_002F mvid 22C3 or Server.il:line IL_00F6 mvid 22C3\n     at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx) in RunInternal.il:line IL_0079 mvid BC47\n     at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx) in Run.il:line IL_0009 mvid BC47 or Run.il:line IL_0034 mvid BC47\n     at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state) in Run.il:line IL_0009 mvid BC47 or Run.il:line IL_0034 mvid BC47\n     at System.Threading.ThreadHelper.ThreadStart() in ThreadStart.il:line IL_002A mvid BC47\n”\nExceptionPath = Root\nClassName = JetBrains.Util.LoggerException\nHResult = COR_E_APPLICATION=80131600\n\n2024.12.20 10:16:10.654    WARN Element \u003cTests.UnitTests.TheTest\u003e was left Pending after its run completion.\n\n```\n\nBy removing the \"in\" in type parameter **TContext** eliminates that error\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOmdj4sw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6Zhpre",
                                           "createdAt":  "2024-12-23T07:34:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "For non-static method, the compiler does report error about constraint:\n\n```csharp\npublic interface IInterface\u003cTEntity, in TContext\u003e\n    where TEntity : IInterface\u003cTEntity, TContext\u003e\n{\n    public void Method\u003cTEntityProperty\u003e() // CS1961\n        where TEntityProperty : IInterface\u003cTEntityProperty, TContext\u003e\n    { }\n}\n```\n\nHowever, there\u0027s no error for a static method with manual `this`;\n\n```csharp\n    public static void Method\u003cTEntityProperty\u003e(IInterface\u003cTEntity, TContext\u003e @this)\n        where TEntityProperty : IInterface\u003cTEntityProperty, TContext\u003e\n    { \n    }\n```",
                                           "updatedAt":  "2024-12-23T07:34:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Zhpro",
                                           "createdAt":  "2025-01-06T22:50:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AlekseyTs",
                                           "body":  "An error is reported for a virtual or abstract static method, but not for a non-virtual one. This is consistent with what the feature spec is saying (https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/static-abstracts-in-interfaces.md#variance-safety-18232):\n \u003e *These restrictions do not apply to occurrences of types within declarations of **non-virtual, non-abstract** static members.*\n\nNeed to confirm whether the spec rules should be tighter or runtime check should be relaxed. ",
                                           "updatedAt":  "2025-01-06T22:50:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Zhprv",
                                           "createdAt":  "2025-01-06T23:51:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AlekseyTs",
                                           "body":  "@trylek, @davidwrighton Is runtime behavior justified? Is there a real variance safety issue around non-virtual static members? Given https://github.com/dotnet/runtime/issues/39612, it looks like the fix might be incomplete, or a change was made with intention to affect only virtual statics, but affected all statics.  ",
                                           "updatedAt":  "2025-01-06T23:51:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Z2Piz",
                                           "createdAt":  "2025-01-09T19:53:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidwrighton",
                                           "body":  "Hmm... maybe. Looking at the source around this faiulre...https://github.com/dotnet/runtime/blob/45155059d0b070e8ac0f6ad8f4909448e7eadd42/src/coreclr/vm/typedesc.cpp#L828   I think there is some sort of explicit check that these are only allowed to be contravariant? although that detail is a thing which may not really apply to non-virtual static methods. This is a separate issue from #39612.",
                                           "updatedAt":  "2025-01-09T19:53:09Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Using Covariance generates not loadable assembly - covariant or contravariant type parameter was used illegally",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/112811",
        "createdAt":  "2025-02-22T06:59:22Z",
        "number":  112811,
        "author":  "Rew",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-01T17:17:19Z",
        "body":  "### Description\n\nEncountered a TypeLoadException on a type in the same assembly.  It seems likely related to circular value type checks during a type layout phase.  It builds fine and throws in main().  This occurs in a project with no external references.\n\n\n### Reproduction Steps\n\nThe below code snippets fail to run when is is the sole source for a Console Application project in Debug build.  Release build needs a few additional lines to prevent optimizing away the type load.\n\nIf Baz is changed to a class (instead of struct) it loads as expected.  If the same pattern is done in a single dependency (ie `Bar\u003cFoo\u003e`) it also loads as expected, it requires the 2 deep layout to trigger.\n\nMinimal Repro:\n```c#\nnamespace Test\n{\n    struct Foo \n    { \n        Bar _bar; \n    }\n\n    struct Bar \n    { \n        Baz\u003cFoo\u003e _baz; \n    }\n\n    struct Baz\u003cT\u003e \n    { \n        int _something; \n    }\n\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            Foo foo = new Foo();\n            Console.WriteLine(\"Hello, World!\");\n        }\n    }\n}\n``` \n\nSource:\n[Test_source.zip](https://github.com/user-attachments/files/18920693/Test_source.zip)\n\nCompiled result:\n[Test.zip](https://github.com/user-attachments/files/18920621/Test.zip)\n\n### Expected behavior\n\nProgram runs successfully with Hello, World!\n\n### Actual behavior\n\n\u003e [!CAUTION]\n\u003e System.TypeLoadException: \u0027Could not load type \u0027Test.Foo\u0027 from assembly ....\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\nWindows 10 x64\n.NET 8.0.406 SDK\n.NET 9.0.103 SDK\n\nOriginally tested it with Visual Studio 2022 17.11.XX and a .NET 8 target.  Updated to VS2022 17.12.5 and also failed on .NET 9 target.\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOpBwhnA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6fgeS9",
                                           "createdAt":  "2025-02-22T08:28:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "Related to #109451",
                                           "updatedAt":  "2025-02-22T08:28:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6kGS44",
                                           "createdAt":  "2025-03-26T02:54:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lindexi",
                                           "body":  "@huoyaoyuan Is this the same issues with https://github.com/dotnet/runtime/issues/104511 ? Thank you.",
                                           "updatedAt":  "2025-03-26T02:54:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6kHCGc",
                                           "createdAt":  "2025-03-26T05:44:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOELeByg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "lindexi",
                                                                               "createdAt":  "2025-03-26T06:07:01Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "I don\u0027t think it\u0027s the same for the main post, but https://github.com/dotnet/runtime/issues/104511#issuecomment-2557099016 . It\u0027s about unused generic parameter encountered for layout recursion.",
                                           "updatedAt":  "2025-03-26T05:44:33Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Unexpected TypeLoadException",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/115451",
        "createdAt":  "2025-05-11T11:16:38Z",
        "number":  115451,
        "author":  "hopperpl",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-17T16:47:36Z",
        "body":  "### Description\n\nThis is somewhat a duplicate of ...\n\nhttps://github.com/dotnet/runtime/issues/85134\nhttps://github.com/dotnet/runtime/issues/6924\n\n... which state that is should be fixed with .NET 8 but the code below crashes with 9.0.4\n\nIs this an oversight? Is this a known issue? \n\nThe **TypeLoadException** thrown is so information-less and it took me some time to track it down. I would really appreciate it if TypeLoadException could give some hint or clue about what went wrong and if it\u0027s just printing the word \"circular\", \"missing\", \"mismatch\" or something. Or the JIT compiler just prints a line via OutputDebugString. At least something more than 🤷.\n\n### Reproduction Steps\n\n```C#\nusing System.Collections.Immutable;\n\n_ = Crash.Me; \n\npublic struct Crash\n{\n  public static readonly ImmutableArray\u003cCrash\u003e Me;\n}\n```\n\n### Expected behavior\n\n```C# \nthrow new TypeLoadException(\"circular reference of type \u0027Crash\u0027 detected which is not supported\")\n```\n\nor\n\n  _no issue anymore, works fine since NET 8_\n\n### Actual behavior\n\n```C# \nthrow new TypeLoadException() + 🤷\n```\n\n### Regression?\n\nno regression\n\n### Known Workarounds\n\n`ImmutableArray\u003cT\u003e --\u003e T[]` works just fine\n\n### Configuration\n\n.NET 9.0.4\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOqxDkEw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6rEOQT",
                                           "createdAt":  "2025-05-11T17:11:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AlgorithmsAreCool",
                                           "body":  "Probable duplicate of https://github.com/dotnet/runtime/issues/104511",
                                           "updatedAt":  "2025-05-11T17:11:34Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Circular struct reference still causing TypeLoadException",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/117852",
        "createdAt":  "2025-07-19T18:49:52Z",
        "number":  117852,
        "author":  "harayuu9",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-21T21:16:40Z",
        "body":  "### Description\n\nOn .NET 9-preview (Windows x64), two value types (`struct`) that reference each other only through an **empty** generic value-type wrapper compile successfully, but the CLR throws `System.TypeLoadException` at runtime.  \nAlthough the wrapper `Test\u003cT\u003e` has **zero instance fields**, its generic argument is still treated as a value-type dependency, so the runtime’s circular-layout checker reports a self-referential cycle and aborts type loading.\n\n### Reproduction Steps\n\n```csharp\npublic struct Test\u003cT\u003e;                 // zero fields\n\npublic struct RelationA\n{\n    public Test\u003cRelationB\u003e RelationB { get; set; }\n}\n\npublic struct RelationB\n{\n    public Test\u003cRelationA\u003e RelationA { get; set; }\n}\n```\n\n### Expected behavior\n\nThe program should execute without throwing, because each struct’s layout is finite:\nTest\u003cT\u003e embeds no actual instance of T.\n(Alternatively, the compiler could emit CS0523 at build-time, as it does for direct field cycles.)\n\n### Actual behavior\n\nRunning the compiled binary terminates immediately with:\n\n```\nUnhandled exception. System.TypeLoadException: Could not load type \u0027RelationA\u0027 from assembly \u0027Repro, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\u0027.\n ---\u003e System.TypeLoadException: Could not load type \u0027RelationB\u0027 from assembly \u0027Repro, Version=1.0.0.0, \nCulture=neutral, PublicKeyToken=null\u0027.\n```\n\nIf either struct is removed or Test\u003cT\u003e is changed from struct to class, the exception disappears.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOuG2FCA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc64bYUI",
                                           "createdAt":  "2025-07-20T08:05:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "#112811 / #109451 / #115451",
                                           "updatedAt":  "2025-07-20T08:05:01Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "TypeLoadException for mutually-referencing generic **struct**s that contain no data fields",
        "labels":  [
                       "area-TypeSystem-coreclr"
                   ]
    }
]
