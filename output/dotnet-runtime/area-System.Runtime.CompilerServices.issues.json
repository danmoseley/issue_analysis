[
    {
        "url":  "https://github.com/dotnet/runtime/issues/30885",
        "createdAt":  "2019-09-18T13:42:41Z",
        "number":  30885,
        "author":  "gbalykov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-10-25T12:20:29Z",
        "body":  "## Rationale and Usage\r\n\r\nThe idea of this API is to allow flushing of PE caches at request, which will allow to reduce memory consumption of the process. \r\n\r\n```cs\r\nType type = typeof(RuntimeHelpers);\r\nMethodInfo method = type.GetMethod(\"FlushPECaches\");\r\nif (method != null)\r\n  method.Invoke(null, new object[]{});\r\n```\r\n\r\nAfter this call Private_Clean and Shared_Clean of the process are reduced, as well as PSS and RSS.\r\n\r\n## Proposed API\r\n```cs\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public static partial class RuntimeHelpers\r\n    {\r\n        [MethodImplAttribute(MethodImplOptions.InternalCall)]\r\n        public static extern void FlushPECaches();\r\n    }\r\n}\r\n```\r\n\r\n## Details\r\n- Internally, FlushPECaches tries to mark all readonly pages of PE images (this considers relocations too) as not needed so that they can be freed. This is done using `madvise` with `MADV_DONTNEED`.\r\n- both dlls and ni.dlls are considered\r\n\r\n## Pull Request\r\n\r\nPR with proposed change is available at https://github.com/dotnet/coreclr/pull/26507\r\n\r\ncc @alpencolt ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOkUtjtg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUzMjc1MjE5OA==",
                                           "createdAt":  "2019-09-18T16:01:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "I think this API should be about flushing all caches that the runtime controls: trimming unnecessary pages in GC heap, etc.",
                                           "updatedAt":  "2019-09-18T16:01:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc59y_w2",
                                           "createdAt":  "2024-05-14T15:22:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ashaurtaev",
                                           "body":  "## Rationale and Usage\r\nAPI that allows you to clear runtime caches on demand, which will reduce the overall memory consumption of the process.\r\n\r\nWe can later expand API and add other types of caches for flushing.\r\n\r\n### Usage\r\n```C#\r\nusing System.Runtime.CompilerServices;\r\n...\r\nFlushCaches(FlushCachesMode.PE); //Flushing PE clean pages\r\n```\r\nAfter this call Private_Clean and Shared_Clean of the process are reduced, as well as PSS and RSS.\r\n\r\nor\r\n```C#\r\nType type = typeof(RuntimeHelpers);\r\nMethodInfo method = type.GetMethod(\"FlushCaches\");\r\nif (method != null)\r\n  method.Invoke(null, new object[]{FlushCachesMode.GC | FlushCachesMode.Jit});\r\n```\r\nAfter this call Private_Dirty of the process is reduced, as well as PSS and RSS.\r\n## Proposed API\r\n```C#\r\n[Flags]\r\nprivate enum FlushCachesMode\r\n{\r\n    All = ~0,\r\n    PE = 1,\r\n    Jit = 2,\r\n    GC = 4,\r\n}\r\n\r\npublic static void FlushCaches(object? mode = null)\r\n{\r\n    mode ??= FlushCachesMode.All;\r\n    var cacheHandlers = new System.Collections.Generic.Dictionary\u003cFlushCachesMode, Action\u003e\r\n    {\r\n        {FlushCachesMode.GC, FlushGCCaches},\r\n        {FlushCachesMode.Jit, FlushJitCaches},\r\n        {FlushCachesMode.PE, FlushPECaches},\r\n    };\r\n    foreach (var item in cacheHandlers)\r\n    {\r\n        if (((FlushCachesMode)mode \u0026 item.Key) == item.Key)\r\n        {\r\n            item.Value.Invoke();\r\n        }\r\n    }\r\n}\r\n\r\nprivate static void FlushGCCaches()\r\n{\r\n    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;\r\n    GC.Collect(2, GCCollectionMode.Forced, true, true);\r\n}\r\n\r\n[MethodImplAttribute(MethodImplOptions.InternalCall)]\r\npublic static extern void FlushJitCaches();\r\n\r\n[MethodImplAttribute(MethodImplOptions.InternalCall)]\r\npublic static extern void FlushPECaches();\r\n\r\n```\r\n## Details\r\n- This API marks all readonly PE Images pages as not needed so that they can be freed, reduces the size of the GC Heap and cleans up arena cache used for internal data during JIT compilation.\r\n- Internally, FlushPECaches tries to mark all readonly pages of PE images, this is done using madvise with MADV_DONTNEED (both dlls and ni.dlls are considered)\r\n- Flush jit calls JitHost::Reclaim()\r\n- Flush GC calls GC for max generation with compaction\r\n\r\n## Pull Request\r\n\r\nFlushPECaches part in https://github.com/dotnet/coreclr/pull/26507 PR\r\n\r\n@jkotas what do you think about this API?\r\n\r\ncc @gbalykov @t-mustafin ",
                                           "updatedAt":  "2024-05-14T15:22:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc590o_S",
                                           "createdAt":  "2024-05-14T19:04:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "For mapped files, I am not convinced that it makes sense to special case PE files. PE files are not that different from other (native) code in the process. Also, parts of the PE files and other code are immediately going to come back since they are referenced even in steady state. This should be implementable outside the runtime by walking all process memory and paging it out.\r\n\r\nFor Jit scratch space cache, this cache is not that big, and there number of similar caches in the core runtime (e.g. ArrayPool) or outside the code runtime in 3rd party libraries. Should all these caches participate somehow?",
                                           "updatedAt":  "2024-05-14T19:04:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-WQbb",
                                           "createdAt":  "2024-05-20T06:33:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ashaurtaev",
                                           "body":  "Thanks for your feedback, let me think about it.",
                                           "updatedAt":  "2024-05-20T06:33:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6AWZng",
                                           "createdAt":  "2024-06-06T20:30:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "anoop331",
                                           "body":  "Will this api be introduced  to net8, and if so, when would it be in place? Or is there a way to get a prelease version otherwise for us to try it out?",
                                           "updatedAt":  "2024-06-06T20:30:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6AWbBl",
                                           "createdAt":  "2024-06-06T20:34:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Will this api be introduced to net8,\r\n\r\nunlikely",
                                           "updatedAt":  "2024-06-06T20:34:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6AWeR0",
                                           "createdAt":  "2024-06-06T20:42:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "anoop331",
                                           "body":  "You mean not in net8 or not ever? Without understanding all the details, at least the intention seems to be a nice hack to bring the resource usage down, especially when the unloading using dlclose() is not supported..",
                                           "updatedAt":  "2024-06-06T20:42:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6AWss1",
                                           "createdAt":  "2024-06-06T21:25:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODm0qag==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "anoop331",
                                                                               "createdAt":  "2024-06-07T06:50:13Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "clamp03",
                                                                               "createdAt":  "2024-06-24T01:23:53Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "jkotas",
                                           "body":  "The milestone is set to Future. It means that it may happen in some future dotnet version. It does not mean never.",
                                           "updatedAt":  "2024-06-06T21:25:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6RS2O2",
                                           "createdAt":  "2024-10-25T12:20:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ThaDaVos",
                                           "body":  "Any update on when this can be expected?",
                                           "updatedAt":  "2024-10-25T12:20:27Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "API proposal: add function to flush caches",
        "labels":  [
                       "area-System.Runtime.CompilerServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/31354",
        "createdAt":  "2019-10-31T02:33:43Z",
        "number":  31354,
        "author":  "GrabYourPitchforks",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC-naxg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "benaadams",
                                            "createdAt":  "2019-10-31T02:38:57Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Wraith2",
                                            "createdAt":  "2019-10-31T08:44:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "gfoidl",
                                            "createdAt":  "2019-10-31T10:23:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "vcsjones",
                                            "createdAt":  "2019-10-31T13:05:09Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "scalablecory",
                                            "createdAt":  "2019-10-31T16:46:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Gnbrkm41",
                                            "createdAt":  "2019-10-31T17:35:18Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Joe4evr",
                                            "createdAt":  "2019-11-02T09:53:06Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MihaZupan",
                                            "createdAt":  "2020-04-17T16:23:04Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Sergio0694",
                                            "createdAt":  "2020-06-06T22:11:18Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "carlreinke",
                                            "createdAt":  "2020-06-13T05:41:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "maxkatz6",
                                            "createdAt":  "2020-07-24T09:04:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "GSPP",
                                            "createdAt":  "2020-09-12T08:57:20Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AmrAlSayed0",
                                            "createdAt":  "2020-11-25T15:00:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "airbreather",
                                            "createdAt":  "2021-03-31T22:25:51Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kostya9",
                                            "createdAt":  "2021-10-25T16:52:42Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "danmoseley",
                                            "createdAt":  "2021-10-29T16:03:52Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "wzchua",
                                            "createdAt":  "2021-11-30T01:46:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "svick",
                                            "createdAt":  "2022-02-22T18:34:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "omariom",
                                            "createdAt":  "2022-04-22T12:11:18Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2022-06-24T14:53:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "thinker227",
                                            "createdAt":  "2022-06-28T11:14:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "curbelo-gonzalo",
                                            "createdAt":  "2022-06-28T12:40:31Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "N0D4N",
                                            "createdAt":  "2022-07-29T08:57:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "IS4Code",
                                            "createdAt":  "2023-01-07T11:44:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2023-03-13T00:49:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jkrejcha",
                                            "createdAt":  "2025-01-24T06:57:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "julealgon",
                                            "createdAt":  "2025-01-30T17:47:16Z"
                                        }
                                    ],
                          "totalCount":  27
                      },
        "updatedAt":  "2025-01-30T17:34:49Z",
        "body":  "Per https://github.com/dotnet/roslyn-analyzers/issues/972, there\u0027s an outstanding feature for a Roslyn analyzer which would require a caller to use an `unsafe` block to make an API call that\u0027s pointer-equivalent dangerous but which doesn\u0027t take pointers.\r\n\r\nFor example:\r\n\r\n```cs\r\npublic static Span\u003cT\u003e ToMutableSpan(ReadOnlySpan\u003cT\u003e span)\r\n{\r\n    // When the Roslyn analyzer is active, the following code will produce a warning\r\n    // unless it is wrapped within an \"unsafe\" block.\r\n\r\n    return MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in MemoryMarshal.GetReference(span)), span.Length);\r\n}\r\n```\r\n\r\nWhether that feature exists as a standalone analyzer or whether it gets moved into Roslyn proper (see https://github.com/dotnet/roslyn/issues/8663), we still need to define the attribute in corefx and apply it to the appropriate methods.\r\n\r\n### API proposal\r\n\r\n```cs\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = false, Inherited = true)]\r\n    public sealed class CallerMustBeUnsafeAttribute : Attribute\r\n    {\r\n    }\r\n}\r\n```\r\n\r\nIn this proposal I\u0027m not applying `AttributeTargets.Class` or `AttributeTargets.Struct` because I don\u0027t want constructs like `Type \r\nt = typeof(SomeType)` to require an `unsafe` block. Technically `AttributeTargets.Property` isn\u0027t needed because the property getter / setter can be annotated (same with events), but allowing it on properties seems like a decent convenience.\r\n\r\nThe prime candidates to annotate are most methods on the `MemoryMarshal` type, some constructor-bypassing logic in `FormatterServices`, and any \"fast\" object factories which allow bypassing normal constructor validation.\r\n\r\nEdit: I suppose since we\u0027ve said that we see `ArrayPool\u003cT\u003e` as a `malloc` equivalent and since it now returns uninitialized memory we should annotate its methods as well, but due to how widely used that type is that risks opening a huge can of worms.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOnHh_tQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0ODMyNjg3NQ==",
                                           "createdAt":  "2019-10-31T11:30:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOA0Belg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Gnbrkm41",
                                                                               "createdAt":  "2019-10-31T17:35:34Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Wraith2",
                                           "body":  "\u003e The prime candidates to annotate are most methods on the MemoryMarshal type, some constructor-bypassing logic in FormatterServices, and any \"fast\" object factories which allow bypassing normal constructor validation.\r\n\r\nAnd some of the Unsafe methods?",
                                           "updatedAt":  "2019-10-31T11:30:01Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0ODUxMzk0OQ==",
                                           "createdAt":  "2019-10-31T18:38:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "\u003e And some of the Unsafe methods?\r\n\r\nMaybe. On one hand the developer already quite literally wrote `Unsafe.\u003csomething\u003e` in their code, so requiring an `unsafe` block seems redundant. But there is something to be said for consistency.",
                                           "updatedAt":  "2019-10-31T18:38:43Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0ODUzMDQxOQ==",
                                           "createdAt":  "2019-10-31T19:21:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "Today, `unsafe` means enable the unsafe syntax. With this analyzer, it will mean \"doing unsafe things\". It may conflict with some analyzer saying \"unnecessary \u0027unsafe\u0027 modifier\".",
                                           "updatedAt":  "2019-10-31T19:21:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0ODUzNTk1MA==",
                                           "createdAt":  "2019-10-31T19:37:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "@huoyaoyuan You raise a good point. We need to set a bar for ourselves on where we want to apply this attribute. If the `unsafe` keyword right now essentially means \"let me do pointer-related stuff,\" then maybe we set the bar to \"apply it to wherever an API allows you do to something that would normally require a pointer.\" This gets a little hairy though, since there are some things that are pointer-esque (e.g., reading uninitialized memory or bypassing normal visibility or type-safety checks), and it\u0027s not immediately clear where things should fall. I\u0027m leaning toward annotating things that would normally require writing unverifiable IL, but feedback is always appreciated.",
                                           "updatedAt":  "2019-10-31T19:37:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0ODUzOTE1Mg==",
                                           "createdAt":  "2019-10-31T19:45:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODuJqjw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "xparadoxical",
                                                                               "createdAt":  "2023-08-29T20:37:30Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-08-14T22:33:45Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "The safety of an API may also varies. For example `Unsafe.As`, it can be super dangerous like `As\u003cT[], SZArrayHelper\u003cT\u003e\u003e`, or super safe like `As\u003cfloat, int\u003e`",
                                           "updatedAt":  "2019-10-31T20:34:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0ODU1NjU2OA==",
                                           "createdAt":  "2019-10-31T20:32:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "BreyerW",
                                           "body":  "I would like to raise a point about forward-compatibility - will this analyzer be optional? And if yes be on or off by default on net 5?\r\n\r\nThese apis may be rarely used by avg developer but many companies develop programs that have at least one bottleneck where good throughput is bare minimum. If this analyzer will be forced in net 5 (via integrating directly to roslyn without ability to disable this particular feature) then upgrading from net core 3 and ealier to net 5 may suddenly be painful enough to put a stop to such endeavor due to errors (even if they will be mere warnings thats still a bit of a problem since it isnt unusual for companies to have warnings as errors by default) popping in many places where performance is critical.\r\n\r\nFor completely new apis developed exclusively for net 5 and later forced unsafe block isnt a problem but for anything ealier it may be problematic. Just my 2 cents.",
                                           "updatedAt":  "2019-10-31T20:32:09Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0ODg5NDUxMg==",
                                           "createdAt":  "2019-11-01T18:12:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "@huoyaoyuan I already have a similar API proposal at https://github.com/dotnet/corefx/issues/42133. One of the downsides is that it might allow an explosion of APIs since there are many different combinations we\u0027d want to allow. As a strawman, I wonder if it might be better to ship an API `Safe.Cast\u003cT, U\u003e(...)` which will allow the conversion only if _T_ and _U_ are primitive numeric types and have the same width. It\u0027d mean the call might fail at runtime, but it should be straightforward to write a code analyzer which could enforce correct usage.",
                                           "updatedAt":  "2019-11-01T18:12:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU1MzMxMDk2NQ==",
                                           "createdAt":  "2019-11-13T09:15:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODFLhZg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "saucecontrol",
                                                                               "createdAt":  "2019-11-19T20:23:55Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "xparadoxical",
                                                                               "createdAt":  "2023-08-29T20:37:39Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "dasMulli",
                                           "body":  "I also think that mixing language-safe/unsafe concepts with API safe/unsafe is not very good.\r\n\r\nThe `unsafe` keyword in C# denotes that you agree to loose promises that the C# language gives you otherwise, thus being able to use additional syntax and language features. It means that the compiler cannot protect you at language level that what you do is okay.\r\n\r\nNow there are a lot of APIs that do things that can break you in recoverable and non-recoverable ways. For methods that shift sanity-checking on the programmer, these have been traditionally called `UnsafeXYZ` or are on the `Unsafe` class. But nearly everything that goes a little bit deeper than traditional safe APIs can end up bad (e.g. function pointers returned by the marshaller with the referenced delegate already been garbage collected).\r\n\r\nMixing the language concern with the API concern is theoretically possible, but then it needs to be done for all sorts of APIs and possibly still can\u0027t protect you from the results of using these APIs outside of unsafe contexts; think modifying a mutable span of a string - you would need an unsafe block to do that casts but if you later on use that mutable span elsewhere to do modifications you might be causing bad things to happen (and hours spent debugging because this will look like spooky action at a difference with interned strings). Many programmers work on the same project and if one opts into some unsafe actions for implementing a safe api, it doesn\u0027t mean that other programmers using safe APIs won\u0027t then be able to run into issues using this safe api in a different way.\r\n\r\nAnother concern of mine is that an \"you need \u0027unsafe\u0027 here\" diagnostic will only make people enable unsafe blocks and use the language feature without thinking too much about it. Because that will be the StackOverflow answer explaining to you how to use that method. No thinking about how that will impact your program involved.",
                                           "updatedAt":  "2019-11-13T09:15:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU1NTY3NTA2NA==",
                                           "createdAt":  "2019-11-19T19:38:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "Would also likely apply to https://github.com/dotnet/corefx/issues/32582.",
                                           "updatedAt":  "2019-11-19T19:38:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY0MzQxNzc1OQ==",
                                           "createdAt":  "2020-06-12T18:14:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "terrajobst",
                                           "body":  "[Video](https://www.youtube.com/watch?v=4sksWrrgXJg\u0026t=0h46m49s)\n\n* The idea is interesting, but we have concerns:\r\n    - Which kind of APIs would we apply this too? Every p/Invoke? `CollectionMarshal.GetSpanForList()`?\r\n    - The name should reflect what the method does, rather than what mechanically has to happen on the call side.\r\n    - Would we turn this on for existing APIs? If so, it seems this analyzer needs to opt-in. If it\u0027s opt-in, is it still useful?\r\n\r\n\r\n```C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    [AttributeUsage(AttributeTargets.Field |\r\n                    AttributeTargets.Method |\r\n                    AttributeTargets.Property,\r\n                    AllowMultiple = false,\r\n                    Inherited = true)]\r\n    public sealed class CallerMustBeUnsafeAttribute : Attribute\r\n    {\r\n    }\r\n}\r\n```",
                                           "updatedAt":  "2020-06-12T19:13:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc46itc9",
                                           "createdAt":  "2021-11-30T00:51:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "/cc @bartonjs @stephentoub\r\n\r\nThis may have non-obvious impact on generated code. There was previously discussion about `[DllImportGenerator]`. But see also this logic from the new regex source generators.\r\n\r\nhttps://github.com/dotnet/runtime/blob/b5bb3c9e5e0cb0ddfe99eec38e66ac1dc8f1b57f/src/libraries/System.Text.RegularExpressions/gen/RegexGenerator.Emitter.cs#L1669-L1677\r\n\r\nHere, `MemoryMarshal.AsBytes\u003cT\u003e(Span\u003cT\u003e)` would likely be annotated as `[CallerMustBeUnsafe]` (see https://github.com/dotnet/runtime/issues/41418). We could probably add an overload `MemoryMarshal.AsBytes(Span\u003cchar\u003e)` _not_ annotated as `[CallerMustBeUnsafe]`, and that would be preferred during overload resolution, but it does merit further thought so that we don\u0027t break these scenarios.\r\n\r\nMaybe a better solution would be to exclude generated code from `[CallerMustBeUnsafe]` enforcement? If we assume that generated code is better tested and won\u0027t generally make the same types of mistakes that human-written code would, then I think even by excluding such code we\u0027d still be within the spirit of this proposal.",
                                           "updatedAt":  "2021-11-30T00:51:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc46it4w",
                                           "createdAt":  "2021-11-30T00:55:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCZiREQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Neme12",
                                                                               "createdAt":  "2022-04-24T11:58:56Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "bartonjs",
                                           "body":  "Either excluding generated code, or just having the generator throw the pragma out saying it promises that it knows what it\u0027s talking about, seem fine.",
                                           "updatedAt":  "2021-11-30T00:55:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc46i0kX",
                                           "createdAt":  "2021-11-30T01:56:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCZiRFg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "GrabYourPitchforks",
                                                                               "createdAt":  "2021-11-30T06:31:24Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Neme12",
                                                                               "createdAt":  "2022-04-24T11:59:05Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e or just having the generator throw the pragma out saying it promises that it knows what it\u0027s talking about\r\n\r\nNote the cited RegexGenerator.Emitter.cs already does that for a few warnings; this would \"just\" be one (or more) more.\r\nhttps://github.com/dotnet/runtime/blob/b5bb3c9e5e0cb0ddfe99eec38e66ac1dc8f1b57f/src/libraries/System.Text.RegularExpressions/gen/RegexGenerator.Emitter.cs#L30-L39\r\n\r\nThat said, I also opened an issue about trying to drive that list to zero :smile:\r\nhttps://github.com/dotnet/runtime/issues/61666",
                                           "updatedAt":  "2021-11-30T01:57:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc46l1_5",
                                           "createdAt":  "2021-11-30T20:35:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODxwNKA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "GSPP",
                                                                               "createdAt":  "2021-12-01T11:16:29Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-09-11T00:05:00Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "dasMulli",
                                           "body":  "Regarding naming: Should this be exclusive to C# or is there an expectation that the presence of a `CallerMustBeUnsafe` attribute has an effect (produces diagnostic) on languages that do not have a language-level concept of „unsafe“ like C#?\r\n\r\nIf not so, then I’d favor naming it agnostic to language constructs - e.g. `[UnsafeOperation]` / `[MemoryUnsafeOperation]` - that could have semantically meaningful diagnostics and resolutions („suppress warning about calling members that perform unsafe operations“) regardless of the language used. So only the C# analyzer would require a `using` block and/or AllowUnsafeBlocks options while analyzers / linters for other languages could use the same message suppression mechanism as they would for any other diagnostic.",
                                           "updatedAt":  "2021-11-30T20:35:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5AbAio",
                                           "createdAt":  "2022-03-28T15:51:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODxwNLg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "DaZombieKiller",
                                                                               "createdAt":  "2022-03-28T15:53:14Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "canton7",
                                                                               "createdAt":  "2022-06-24T10:37:57Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-09-11T00:05:12Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "Joe4evr",
                                           "body":  "Discussion on this topic in Discord just now came up with names like `[RequiresUnsafeContext]` and `[UnsafeCallersOnly]` (the latter having nice parity with the recent `[UnmanagedCallersOnly]`).\r\n\r\nI\u0027m actually liking `[UnsafeCallersOnly]` for that reason, so I\u0027m putting my vote in that hat.",
                                           "updatedAt":  "2022-03-28T15:51:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5B6RrL",
                                           "createdAt":  "2022-04-21T21:51:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCjjgLg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "neon-sunset",
                                                                               "createdAt":  "2022-04-21T22:24:55Z"
                                                                           },
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "Joe4evr",
                                                                               "createdAt":  "2022-06-24T10:03:16Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "How about `[UnsafeToCall]`?",
                                           "updatedAt":  "2022-04-21T21:51:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ceH-1",
                                           "createdAt":  "2025-01-30T17:34:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xtqqczze",
                                           "body":  "@EgorBo should this be included for https://github.com/dotnet/runtime/issues/94941?\n",
                                           "updatedAt":  "2025-01-30T17:34:48Z"
                                       }
                                   ],
                         "totalCount":  17
                     },
        "title":  "Add [CallerMustBeUnsafe] attribute to denote APIs which should be called in an unsafe block",
        "labels":  [
                       "Security",
                       "api-needs-work",
                       "area-System.Runtime.CompilerServices",
                       "code-analyzer"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/43638",
        "createdAt":  "2020-10-20T14:23:26Z",
        "number":  43638,
        "author":  "ssa3512",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC1nG7Q==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Liversage",
                                            "createdAt":  "2020-10-27T20:47:32Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sakno",
                                            "createdAt":  "2020-11-11T12:17:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "nth-commit",
                                            "createdAt":  "2020-11-25T20:42:09Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "khalidabuhakmeh",
                                            "createdAt":  "2020-12-09T19:23:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "alexeyzimarev",
                                            "createdAt":  "2020-12-09T20:32:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "shupoval",
                                            "createdAt":  "2020-12-10T06:38:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "djb7c",
                                            "createdAt":  "2020-12-11T00:05:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "StefanSchoof",
                                            "createdAt":  "2020-12-24T16:11:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jroney",
                                            "createdAt":  "2020-12-28T21:58:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SeeminglyScience",
                                            "createdAt":  "2021-06-25T14:02:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mark-fluehr-esendex",
                                            "createdAt":  "2024-02-02T15:49:47Z"
                                        }
                                    ],
                          "totalCount":  11
                      },
        "updatedAt":  "2025-04-07T04:32:44Z",
        "body":  "After reviewing the record types implementation, it appears that the only component in the framework necessary for record types to work is the `IsExternalInit` class in System.Runtime.CompilerServices. Everything else seems to be handled by the compiler.\r\n\r\nAdding the following code to my project enables the use of record types on net462+ and netcoreapp3.1:\r\n\r\n```cs\r\nusing System.ComponentModel;\r\n\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    /// \u003csummary\u003e\r\n    /// Reserved to be used by the compiler for tracking metadata.\r\n    /// This class should not be used by developers in source code.\r\n    /// \u003c/summary\u003e\r\n    [EditorBrowsable(EditorBrowsableState.Never)]\r\n    public static class IsExternalInit\r\n    {\r\n    }\r\n}\r\n```\r\n\r\nAssuming I am not missing anything and this is all that is needed, would you consider shipping this in a nuget package so record types can be used in netstandard projects?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOpdHRBw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcxMjk0NTc3Ng==",
                                           "createdAt":  "2020-10-20T15:42:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "cc @terrajobst ",
                                           "updatedAt":  "2020-10-20T15:42:46Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc5NDI0MDE2Mg==",
                                           "createdAt":  "2021-03-09T18:00:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "joperezr",
                                           "body":  "FWIW, I think it wasn\u0027t part of our plans to create additional compat packs to bring  new features back to netstandard like we did with HashCode or AsyncInterfaces.",
                                           "updatedAt":  "2021-03-09T18:00:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6l0dEH",
                                           "createdAt":  "2025-04-07T04:32:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dennis-yemelyanov",
                                           "body":  "Is there any officially recommended way to enable support in netstandard2.0?\n\nSome project types, for example, source generators, still only support netstandard2.0, and not being able to use records is less than ideal, especially since it would allow writing more performant cache-friendly generators.\n\nLooks like `System.Text.Json` generator simply includes files like `IsExternalInit.cs`. Is this safe to do in other generators or is there a better way? https://github.com/dotnet/runtime/blob/367e0a8a23e444a94c029fcb72dcb4ac66bd6717/src/libraries/System.Text.Json/gen/System.Text.Json.SourceGeneration.targets#L28C5-L29C1",
                                           "updatedAt":  "2025-04-07T04:32:43Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "netstandard2.0/2.1 record types package",
        "labels":  [
                       "area-System.Runtime.CompilerServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/53671",
        "createdAt":  "2021-06-03T11:27:09Z",
        "number":  53671,
        "author":  "marek-safar",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-08-03T17:21:40Z",
        "body":  "It\u0027s not always possible to make the right choice between size and speed when different implementations exist or are possible. For now, we hardcode that logic based on the runtime pack but that\u0027s not optimal. It\u0027s hard to test and it\u0027s not always the right choice as some scenarios can prefer size over-speed or vice versa based on the developer\u0027s need.\r\n\r\nExamples, where this could apply, are\r\n- LINQ implementation (hardcoded for browser only)\r\n- JSON implementation (not supported right now https://github.com/dotnet/runtime/commit/59c60c6392585dd92b200a13ca55e14d8793a684)\r\n\r\nThe proposed API could like like with AppContext settings and feature switch supported as well.\r\n\r\n```c#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n\tpublic static partial class RuntimeFeature\r\n\t{\r\n\t\tpublic static bool IsSizeOptimized { get; }\r\n\t}\r\n}\r\n```\r\n\r\nNote: There could be a better place/type where to put the property\r\n\r\n@eerhardt ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHON6RMYA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1Mzc5NzU4Mw==",
                                           "createdAt":  "2021-06-03T11:27:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-06-03T11:27:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1MzgxNDYzNw==",
                                           "createdAt":  "2021-06-03T11:59:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e LINQ implementation\r\n\r\nHow would this apply to LINQ? Most of the size savings there come from not implementing certain interfaces in certain builds. Having this be a choice made post-compilation would seem to require having both implementations, with and without the interface implementations, compiled into the assembly? That\u0027s very far from ideal.  Have I misunderstood?",
                                           "updatedAt":  "2021-06-03T11:59:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NDUzNDIyNw==",
                                           "createdAt":  "2021-06-04T09:36:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "marek-safar",
                                           "body":  "\u003e How would this apply to LINQ? Most of the size savings there come from not implementing certain interfaces in certain builds.\r\n\r\nThere are two cases. The first one is I think obvious where both size and speed versions exist (we would compile in both and choose the one based on the property). The second one which you are referring to as interface implementation would work similarly. The interfaces would be always compiled in and we would alter the interface reference to be conditional to allow the linker to remove the implementation. For example, changing https://github.com/dotnet/runtime/blob/01b7e73cd378145264a7cb7a09365b41ed42b240/src/libraries/System.Linq/src/System/Linq/Select.cs#L48 to something like\r\n\r\n```c#\r\nif (!RuntimeFeature.IsSizeOptimized \u0026\u0026 source is IPartition\u003cTSource\u003e partition)\r\n{\r\n\t// existing code\r\n}\r\n```",
                                           "updatedAt":  "2021-06-04T09:36:47Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NDYzMzA5Mw==",
                                           "createdAt":  "2021-06-04T11:27:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Thanks.  So if every interface dispatch is guarded,  the linker will remove the interface and all implementations of it entirely?",
                                           "updatedAt":  "2021-06-04T11:27:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NDY0Njc4OQ==",
                                           "createdAt":  "2021-06-04T11:49:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBtdMhA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "stephentoub",
                                                                               "createdAt":  "2021-06-04T15:31:30Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "marek-safar",
                                           "body":  "\u003e the linker will remove the interface and all implementations of it entirely\r\n\r\nYep, that should be the case (it might decide to keep the type itself due to casts) for any interface method which is never dispatched over the interface.",
                                           "updatedAt":  "2021-06-04T11:49:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NDc3NzM3NA==",
                                           "createdAt":  "2021-06-04T14:36:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Can we experiment with this just in System.Linq?  For example, can we define a property in the System.Linq.csproj that\u0027s then picked up by some internal API, and do something in the linker xml files for System.Linq that teaches the linker what that means?  If nothing else, we can see what kind of impact it has on the code (hopefully making it easier to maintain), see if/how the same pattern can be replicated to other libraries, and at some critical mass of use then decide to expose a switch along the lines of what you mention.",
                                           "updatedAt":  "2021-06-04T14:36:35Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NDk1MjUzNQ==",
                                           "createdAt":  "2021-06-04T19:25:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "eerhardt",
                                           "body":  "\u003e can we define a property in the System.Linq.csproj that\u0027s then picked up by some internal API\r\n\r\nAn issue with that approach is that if we don\u0027t reach \"critical mass of use\" by .NET 6 ships, we would be \"stuck\" maintaining that \"System.Linq\"-specific feature switch.\r\n\r\nThe more immediate benefit here (in my mind) is the usage is System.Text.Json. If we had this switch, we could trim all of Reflection.Emit in a default Blazor WASM app. This slows reflection-based JSON (de)serialization down for the benefit of a slightly smaller app. Users who want to switch back to the faster reflection-based JSON (de)serialization could flip the switch for more speed.\r\n\r\nWe could follow the same approach for JSON by defining a \"JSON-specific\" switch, but then we have the same problem that if we don\u0027t combine them into this larger feature switch before .NET 6 ships, we would need to support it long term.",
                                           "updatedAt":  "2021-06-04T19:25:48Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NDk1NDkxMA==",
                                           "createdAt":  "2021-06-04T19:31:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e An issue with that approach is that if we don\u0027t reach \"critical mass of use\" by .NET 6 ships, we would be \"stuck\" maintaining that \"System.Linq\"-specific feature switch.\r\n\r\nI actually meant as an internal implementation detail of our assembly-level builds, e.g. so that rather than having two sets of files with different implementations, we could consolidate into one and use the linker at assembly build time to produce the right assembly for mobile vs desktop.\r\n\r\nAlso, for feature switches that are purely about reducing size and removing optimizations, are we really signing up to support them forever more?\r\n\r\nI\u0027m not against a larger switch in principal, but I\u0027m also not sure every library should be treated equally, whether a single on/off is the right level of granularity, etc.",
                                           "updatedAt":  "2021-06-04T19:31:02Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NTAxMjU2Mw==",
                                           "createdAt":  "2021-06-04T21:36:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "eerhardt",
                                           "body":  "\u003e Also, for feature switches that are purely about reducing size and removing optimizations, are we really signing up to support them forever more?\r\n\r\nI don\u0027t think we\u0027ve actually written a policy on it. Feature switches use runtimeconfig/AppContext switches, my current working plan has been to treat them just like any other runtimeconfig switch. \r\n\r\nI\u0027m not sure we have a feature switch that has purely been about reducing size and/or speed optimizations, yet. Looking through the [current list](https://github.com/dotnet/runtime/blob/main/docs/workflow/trimming/feature-switches.md), all of them affect behavior in some way.",
                                           "updatedAt":  "2021-06-04T21:36:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43pExg",
                                           "createdAt":  "2021-10-04T13:59:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bartczernicki-msft",
                                           "body":  "It looks like this will not make it into .NET 6, but .NET 7?",
                                           "updatedAt":  "2021-10-04T13:59:09Z"
                                       }
                                   ],
                         "totalCount":  10
                     },
        "title":  "Add feature switch for size optimal output",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.CompilerServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/59454",
        "createdAt":  "2021-09-22T02:33:20Z",
        "number":  59454,
        "author":  "wsq003",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOB9giog==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "InCerryGit",
                                            "createdAt":  "2021-10-08T07:19:17Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-04-29T07:55:15Z",
        "body":  "### Background and motivation\r\n\r\n```C#\r\n[MyCache(DurationSeconds = 5)]\r\npublic string GetUserName(int userID)\r\n{\r\n    //load from db\r\n    return \"Mike\";\r\n}\r\n```\r\n```C#\r\n[MyPerfLog()]\r\npublic bool Login(string userName, string password)\r\n{\r\n    //check with db\r\n    return true;\r\n}\r\n```\r\n\r\nIt is very annoying to add AOP to functions.\r\nFor now, you need to:\r\n1, Create a custom Attribute\r\n2, Create a custom Interceptor to handle your custom Attribute\r\n3,  Register your Interceptor at application startup\r\n\r\nI think there would be a `syntactic sugar` that handling specific attribute.\r\n\r\n\r\n### API Proposal\r\n\r\n```C#\r\n[AttributeUsage(AttributeTargets.Method | AttributeTargets.Class)]\r\npublic abstract class AopAttribute : Attribute\r\n{\r\n\t/// \u003csummary\u003e\r\n\t/// \u003c/summary\u003e\r\n\t/// \u003creturns\u003eif execute the real Method or not\u003c/returns\u003e\r\n\tpublic abstract bool BeforeMethod(MethodInfo info);\r\n\tpublic abstract void AfterMethod(ResultInfo result);\r\n\r\n\tpublic abstract Task\u003cbool\u003e BeforeMethodAsync(MethodInfo info);\r\n\tpublic abstract Task AfterMethodAsync(ResultInfo result);\r\n}\r\n```     \r\nThis is a compile-time attribute, more or less like `System.Diagnostics.ConditionalAttribute`.\r\nCompiler will generate proxy class to wrap the target functions.\r\n\r\n### API Usage\r\n\r\n```C#\r\npublic class MyPerfLogAttribute : AopAttribute\r\n{\r\n\tILogger _logger;\r\n\tDateTime _begin;\r\n\r\n\tpublic MyPerfLogAttribute(ILogger logger)\r\n\t{\r\n\t\t_logger = logger;\r\n\t}\r\n\r\n\tpublic override bool BeforeMethod(MethodInfo info)\r\n\t{\r\n\t\t_begin = DateTime.Now;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tpublic override async Task\u003cbool\u003e BeforeMethodAsync(MethodInfo info)\r\n\t{\r\n\t\t_begin = DateTime.Now;\r\n\t\tawait Task.CompletedTask;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tpublic override void AfterMethod(ResultInfo result)\r\n\t{\r\n\t\tvar span = DateTime.Now - _begin;\r\n\t\t_logger.LogInformation($\"use {span.TotalMilliseconds:0.00}\");\r\n\t}\r\n\r\n\tpublic override async Task AfterMethodAsync(ResultInfo result)\r\n\t{\r\n\t\tvar span = DateTime.Now - _begin;\r\n\t\t_logger.LogInformation($\"use {span.TotalMilliseconds:0.00}\");\r\n\t\tawait Task.CompletedTask;\r\n\t}\r\n}\r\n```     \r\n\r\n```C#\r\n[MyPerfLog()]\r\npublic bool Login(string userName, string password)\r\n{\r\n    //check with db\r\n    return true;\r\n}\r\n```\r\n\r\nThen the compiler will take care the rest.\r\n\r\n\r\n### Risks\r\n\r\n1. Application Performance: should not be affected.\r\n2. Compiler complexity: should be fine.\r\n3. Extensibility: should be fine.\r\n4. Applicability: AOP is a very common requirement. Such compiler supported pre-compile AOP attribute should be very sweet.\r\n\r\n### Alternative\r\n\r\n1. A built-in interceptor can also do such things easily. A built-in interceptor will not need to change compiler, but will slow down the application startup speed. Application startup speed is important in this docker(container) era. \r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOfBo46g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc43NfzK",
                                           "createdAt":  "2021-09-24T01:54:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "acaly",
                                           "body":  "I think it\u0027s probably better to at least sketch how this should be implemented. For example, I can\u0027t figure out how async interceptor methods can be applied on sync methods.\r\n\r\nAnother problem is that this might be too complicated and specific to be a pure runtime feature. It might be better to propose that the runtime only exposes a more general API (for example, to raise an event that allows the program to modify the IL of a method while it is loaded), which the C# compiler can use to make this happen. Again, I think it is necessary to provide more information on how this should be designed and implemented.\r\n\r\nI also want to remind you that C# team are known to have negative attitudes toward AOP. That\u0027s why there are so many third-party tools in this area.",
                                           "updatedAt":  "2021-09-24T03:40:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43NqOB",
                                           "createdAt":  "2021-09-24T04:11:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wsq003",
                                           "body":  "\r\n\u003e I think it\u0027s probably better to at least sketch how this should be implemented. For example, I can\u0027t figure out how async interceptor methods can be applied on sync methods.\r\n\r\nI am not compiler expert. There is a Java IDE plugin called Lombok which can decorate Java code before real compile. I think that would be a good reference.\r\n\r\nSync methods use sync interceptor. Async method use async interceptor. This is why AopAttribute need both sync and async implementation.\r\n\r\n\u003e Another problem is that this might be too complicated and specific to be a pure runtime feature. It might be better to propose that the runtime only exposes a more general API (for example, to raise an event that allows the program to modify the IL of a method while it is loaded), which the C# compiler can use to make this happen. Again, I think it is necessary to provide more information on how this should be designed and implemented.\r\n\r\nI suppose this AopAttribute may be supported in `code-gen` module. There should be a `code-gen` module to handle different kinds of `syntactic sugar` before real compile.\r\nI am not sure where code-gen belong to. Rumetime, compiler or somewhere else.\r\n\r\n\u003e I also want to remind you that C# team are known to have negative attitudes toward AOP. That\u0027s why there are so many third-party tools in this area.\r\n\r\nYeah, more or less I know that. But AOP is a big area and have many types.\r\nhttps://stackoverflow.com/questions/39448543/run-time-aop-vs-compile-time-aop\r\nI believe `Source code weaving` should be sweet and will cause minimal side effect.\r\n",
                                           "updatedAt":  "2021-09-24T04:11:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43NqPE",
                                           "createdAt":  "2021-09-24T04:11:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "Why not use something like https://github.com/vescon/MethodBoundaryAspect.Fody",
                                           "updatedAt":  "2021-09-24T04:11:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43Nxdn",
                                           "createdAt":  "2021-09-24T05:29:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wsq003",
                                           "body":  "\u003e Why not use something like https://github.com/vescon/MethodBoundaryAspect.Fody\r\n\r\nThree reasons:\r\n\r\n1. MethodBoundaryAspect.Fody do not have async version wrapper, while async is very import and common used today.\r\n2. MethodBoundaryAspect.Fody use `Binary weaving` with certain draw back.\r\n3. MethodBoundaryAspect.Fody has too few stars/forks, means it\u0027s maturity is not enough. I would prefer an official implementation which will be more promising.\r\n\r\nEdited: MethodBoundaryAspect.Fody can support async method, but itself do not have async version.\r\nEdited: MethodBoundaryAspect.Fody use `Binary weaving` not `Reflection`",
                                           "updatedAt":  "2021-09-24T06:02:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43Nxsq",
                                           "createdAt":  "2021-09-24T05:32:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "\u003e  I would prefer an official implementation which will be more promising.\r\n\r\nI\u0027m pretty sure we\u0027re not going to build AOP into the runtime. Everyone would prefer everything to be built into the runtime even though they are packages on nuget that can do similar things.",
                                           "updatedAt":  "2021-09-24T05:32:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43Nx7t",
                                           "createdAt":  "2021-09-24T05:35:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "\u003e https://github.com/vescon/MethodBoundaryAspect.Fody#asynchronous-sample\r\n\r\nhttps://github.com/vescon/MethodBoundaryAspect.Fody#asynchronous-sample\r\n\r\n\u003e https://github.com/vescon/MethodBoundaryAspect.Fody#asynchronous-sample\r\n\r\nAre you sure it uses reflection?",
                                           "updatedAt":  "2021-09-24T05:35:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43NyH5",
                                           "createdAt":  "2021-09-24T05:37:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wsq003",
                                           "body":  "\u003e \u003e I would prefer an official implementation which will be more promising.\r\n\u003e \r\n\u003e I\u0027m pretty sure we\u0027re not going to build AOP into the runtime. Everyone would prefer everything to be built into the runtime even though they are packages on nuget that can do similar things.\r\n\r\nI agree that the runetime should not combine with `dynamic-inject style` AOP. \r\n1. That will cause `real action` separated from `source code`. And such separation will make programmer confused.\r\n2. Performance issue.\r\n\r\nBut some kine of `Source code weaving` may be acceptable.\r\n",
                                           "updatedAt":  "2021-09-24T05:37:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43NzO6",
                                           "createdAt":  "2021-09-24T05:52:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wsq003",
                                           "body":  "\u003e \u003e https://github.com/vescon/MethodBoundaryAspect.Fody#asynchronous-sample\r\n\u003e \r\n\u003e https://github.com/vescon/MethodBoundaryAspect.Fody#asynchronous-sample\r\n\r\nMethodBoundaryAspect.Fody can support async method, but the `OnEntry` do not have async version. This would cause sync-over-async if someone want to do some async job in `OnEntry`, which is very possible.\r\n\r\n\u003e \r\n\u003e \u003e https://github.com/vescon/MethodBoundaryAspect.Fody#asynchronous-sample\r\n\u003e \r\n\u003e Are you sure it uses reflection?\r\n\r\nSorry my bad, seems like it uses `Binary weaving` like `PostSharp`.\r\n\r\n",
                                           "updatedAt":  "2021-09-24T05:53:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43N0HT",
                                           "createdAt":  "2021-09-24T06:01:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "acaly",
                                           "body":  "Another reason to avoid Fody related stuff is its strange License.\r\n\r\nActually I think the C# source generator can be a good replacement to Fody in many cases. For example, the async interception can be designed as:\r\n\r\n```c#\r\n//Ask the source generator to generate a method with name \"YourPublicMethod\"\r\n[GenerateInterceptedMethod(\"YourPublicMethod\")]\r\n[Log] //Add anything you want as attributes here.\r\nprivate async Task YourImplementation() //The name of this method is only used by the source generator.\r\n{\r\n  //Actual implementation.\r\n}\r\n```\r\n\r\nThen the generator will generate:\r\n```c#\r\npublic async Task YourPublicMethod()\r\n{\r\n    await Log.BeforeMethod(...);\r\n    await YourImplementation();\r\n    await Log.AfterMethod(...);\r\n}\r\n```",
                                           "updatedAt":  "2021-09-24T06:10:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43N1Q_",
                                           "createdAt":  "2021-09-24T06:11:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wsq003",
                                           "body":  "\u003e Another reason to avoid Fody related stuff is its strange License.\r\n\u003e \r\n\u003e Actually I think the C# source generator can be a good replacement to Fody in many cases. For example, the async interception can be designed as:\r\n\u003e \r\n\u003e ```cs\r\n\u003e //Ask the source generator to generate a method with name \"YourPublicMethod\"\r\n\u003e [GenerateInterceptedMethod(\"YourPublicMethod\")]\r\n\u003e [Log] //Add anything you want as attributes here.\r\n\u003e private async Task YourImplementation() //The name of this method is only used by the source generator.\r\n\u003e {\r\n\u003e   //Actual implementation.\r\n\u003e }\r\n\u003e ```\r\n\u003e \r\n\u003e Then the generator will generate:\r\n\u003e \r\n\u003e ```cs\r\n\u003e public async Task YourPublicMethod()\r\n\u003e {\r\n\u003e     await Log.BeforeMethod(...);\r\n\u003e     await YourImplementation();\r\n\u003e     await Log.AfterMethod(...);\r\n\u003e }\r\n\u003e ```\r\n\r\nYes! Some kind of source code generator before `real compile` would be straightforward and elegant. \r\n",
                                           "updatedAt":  "2021-09-24T06:11:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43N1dT",
                                           "createdAt":  "2021-09-24T06:13:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "acaly",
                                           "body":  "\u003e Yes! Some kind of source code generator before real compile would be straightforward and elegant.\r\n\r\nSource generator is very versatile. The only issue is that it\u0027s still new and you probably have to write your own generator for your specific task, including something like this AOP feature.",
                                           "updatedAt":  "2021-09-24T06:13:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43N1vI",
                                           "createdAt":  "2021-09-24T06:15:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wsq003",
                                           "body":  "\u003e \u003e Yes! Some kind of source code generator before real compile would be straightforward and elegant.\r\n\u003e \r\n\u003e Source generator is very versatile. The only issue is that it\u0027s still new and you probably have to write your own generator for your specific task, including something like this AOP feature.\r\n\r\nThis is why I proposal a `abstract class AopAttribute`: let built-in `code-gen` or `compiler` to do such souce code generator staff in a limited pre-designed way.\r\nThis would be super simple for programmer to understand and use.\r\n",
                                           "updatedAt":  "2021-09-24T06:16:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43N1-O",
                                           "createdAt":  "2021-09-24T06:18:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "Source generators won\u0027t help you as they can\u0027t change the call site. You can experiment with them anyways because this issue isn\u0027t something we plan to do",
                                           "updatedAt":  "2021-09-24T06:18:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43N2HC",
                                           "createdAt":  "2021-09-24T06:19:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "acaly",
                                           "body":  "\u003e Source generators won\u0027t help you as they can\u0027t change the call site.\r\n\r\nYou don\u0027t need to. The actual implementation can be another private method, while all call sites use the generated, public one.",
                                           "updatedAt":  "2021-09-24T06:19:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43N2TP",
                                           "createdAt":  "2021-09-24T06:22:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "acaly",
                                           "body":  "The problem with integrating this into the runtime is that only very few apps can benefit from it. In this case, a third-party library might be a better way to go.",
                                           "updatedAt":  "2021-09-24T06:22:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43N2ur",
                                           "createdAt":  "2021-09-24T06:26:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wsq003",
                                           "body":  "\u003e The problem with integrating this into the runtime is that only very few apps can benefit from it. In this case, a third-party library might be a better way to go.\r\n\r\nAs mentioned in MethodBoundaryAspect.Fody, with AOP:\r\n```\r\nYou can easily write your own aspects for\r\n\r\ntransaction handling\r\nlogging\r\nmeasuring method execution time\r\nexception wrapping\r\ndisplaying wait cursor\r\nand much more ...\r\n```\r\n\r\nTransaction ,logging, caching, is very common in daily programming.\r\nA third-party library can not do `souce code weaving`.\r\n",
                                           "updatedAt":  "2021-09-24T06:27:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43N3nx",
                                           "createdAt":  "2021-09-24T06:35:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wsq003",
                                           "body":  "\u003e Source generators won\u0027t help you as they can\u0027t change the call site. You can experiment with them anyways because this issue isn\u0027t something we plan to do\r\n\r\nMaybe AOP is not a good name for this issue.\r\nWhat we need here is a pre-defined source generator. Just like that compiler will expand `using block` to `try...finally with dispose`.\r\n",
                                           "updatedAt":  "2021-09-24T06:36:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43OIjz",
                                           "createdAt":  "2021-09-24T08:39:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wsq003",
                                           "body":  "Found one another possible alternative https://github.com/pamidur/aspect-injector",
                                           "updatedAt":  "2021-09-24T09:03:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43OLp2",
                                           "createdAt":  "2021-09-24T08:58:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wsq003",
                                           "body":  "\u003e \u003e \u003e https://github.com/vescon/MethodBoundaryAspect.Fody#asynchronous-sample\r\n\u003e \u003e \r\n\u003e \u003e \r\n\u003e \u003e https://github.com/vescon/MethodBoundaryAspect.Fody#asynchronous-sample\r\n\u003e \r\n\u003e MethodBoundaryAspect.Fody can support async method, but the `OnEntry` do not have async version. This would cause sync-over-async if someone want to do some async job in `OnEntry`, which is very possible.\r\n\u003e \r\n\u003e \u003e \u003e https://github.com/vescon/MethodBoundaryAspect.Fody#asynchronous-sample\r\n\u003e \u003e \r\n\u003e \u003e \r\n\u003e \u003e Are you sure it uses reflection?\r\n\u003e \r\n\u003e Sorry my bad, seems like it uses `Binary weaving` like `PostSharp`.\r\n\r\nI strongly against third-party `compile-time weaving` or `binary weaving`. \r\nBecause they are very likely to break things: debugging information, call stack, compile tricks, IL rules, backward compatibility, etc.\r\nI prefer do such things before compile.\r\n",
                                           "updatedAt":  "2021-09-24T10:03:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43O28B",
                                           "createdAt":  "2021-09-24T13:52:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "HaloFour",
                                           "body":  "I\u0027d much rather continuing to lobby the C# team to make source generators handle AOP scenarios better.  Generators themselves might be more difficult to write, but theoretically you could write a general purpose generator that would recognize attributes that follow a specific convention (or implement an interface) and have that generator emit the code to call into those attributes, which would behave similarly to what you\u0027ve proposed here.",
                                           "updatedAt":  "2021-09-24T13:52:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43O5jR",
                                           "createdAt":  "2021-09-24T14:05:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "I don\u0027t know how you\u0027d build this with what source generators offer today but here\u0027s something roslyn based https://github.com/Jishun/RoslynWeave",
                                           "updatedAt":  "2021-09-24T14:05:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43RDR7",
                                           "createdAt":  "2021-09-26T02:29:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wsq003",
                                           "body":  "\u003e I don\u0027t know how you\u0027d build this with what source generators offer today but here\u0027s something roslyn based https://github.com/Jishun/RoslynWeave\r\n\r\nHe is trying to achieve the same goal. He use source code template to create a new wrapper class in another namespace, then all caller need to change their code to call the new class. \r\nHe did not fully accomplish the goal, but he did not have much chioce, because Roslyn  [doesn\u0027t support code-rewritting\r\n](https://github.com/dotnet/roslyn/blob/master/docs/features/source-generators.cookbook.md#code-rewriting).\r\nSo Roslyn may not be our chioce.\r\n\r\nI guess there should already be some code-gen that support code-rewriting, inside or outside compiler.\r\nThis code-gen had processed some `syntactic sugar` such as `using`:\r\n\r\n```C#\r\nusing (var conn = new Connection())\r\n{\r\n}\r\n```\r\nrewrited to\r\n```C#\r\nConnection conn;\r\ntry\r\n{\r\n  conn = new Connection()\r\n}\r\nfinally\r\n{\r\n  conn.Dispose();\r\n}\r\n```\r\n\r\nSo I am thinking if such code-gen can do another similiar rewrite:\r\n```C#\r\n[MyPerfLog()]\r\npublic bool Login(string userName, string password)\r\n{\r\n    //check with db\r\n    return true;\r\n}\r\n```\r\nrewrite to:\r\n```C#\r\npublic bool Login(string userName, string password)\r\n{\r\n    MyPerfLog.BeforeMethod();\r\n    \r\n    var resultInfo = Login_juedhrygjddhdgd(userName, password);\r\n    \r\n    MyPerfLog.AfterMethod();\r\n}\r\n\r\npublic bool Login_juedhrygjddhdgd(string userName, string password)\r\n{\r\n    //check with db\r\n    return true;\r\n}\r\n\r\n```\r\n\r\nIf such `code-gen` is already physically existed, maybe we can do some work there.\r\nIf such `code-gen` is only logically existed, maybe we should extract such functionalities to a dedicate module. This dedicate module can be called \u0027code preprocessing module\u0027 or something.\r\n",
                                           "updatedAt":  "2021-09-26T03:23:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43RGyc",
                                           "createdAt":  "2021-09-26T04:50:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC1o0FQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "RainingNight",
                                                                               "createdAt":  "2022-03-04T02:58:14Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "John0King",
                                                                               "createdAt":  "2023-02-08T03:22:30Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "wsq003",
                                           "body":  "Maybe [JSR 269 Pluggable Annotation Processing API](https://jcp.org/en/jsr/detail?id=269) is what we need.\r\nBased on JSR-269, they created Lombok.",
                                           "updatedAt":  "2021-09-26T04:52:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5KxtsD",
                                           "createdAt":  "2022-09-22T05:28:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wsq003",
                                           "body":  "https://github.com/postsharp/Metalama\r\nLooks interesting. It is designed to `replace or enhance hand-written code`. Just like what I want.",
                                           "updatedAt":  "2022-09-22T05:31:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc58Gjjq",
                                           "createdAt":  "2024-04-29T07:55:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wsq003",
                                           "body":  "https://github.com/dotnet/roslyn/blob/main/docs/features/interceptors.md\r\n\r\nThis looks like what I had wanted.\r\n",
                                           "updatedAt":  "2024-04-29T07:55:13Z"
                                       }
                                   ],
                         "totalCount":  25
                     },
        "title":  "[API Proposal]: Custom attribute for Pre-compile AOP",
        "labels":  [
                       "api-needs-work",
                       "api-suggestion",
                       "area-System.Runtime.CompilerServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/61382",
        "createdAt":  "2021-11-09T20:31:06Z",
        "number":  61382,
        "author":  "cartermp",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC_rvkA==",
                          "nodes":  [
                                        {
                                            "content":  "HEART",
                                            "user":  "lambdageek",
                                            "createdAt":  "2021-11-09T20:46:23Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "bhood-zorus",
                                            "createdAt":  "2021-11-10T01:21:09Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "giladfrid009",
                                            "createdAt":  "2021-11-11T21:51:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Eli-Black-Work",
                                            "createdAt":  "2022-05-31T06:59:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "LWChris",
                                            "createdAt":  "2025-03-04T12:57:51Z"
                                        }
                                    ],
                          "totalCount":  5
                      },
        "updatedAt":  "2025-03-04T12:57:37Z",
        "body":  "### Background and motivation\r\n\r\nThere are a lot of .NET APIs out there that return a value for the purposes of fluent APIs. However, in many cases (probably most?) these values are just ignored and people call APIs imperatively. Two examples of this are ASP.NET Core configuration and OpenTelemetry APIs.\r\n\r\nThis presents an awkward situation for F#, which like the Go language, doesn\u0027t support implicit ignoring of values. The reason is that it can often be a bug when something is implicitly discarded. It\u0027s baked into the language and can\u0027t really be removed.\r\n\r\nHere\u0027s a code sample in F# where you can use the new \"minimal\" APIs to build an instrumented web service with OpenTelemetry:\r\n\r\n```fsharp\r\n//.. some \u0027open\u0027 declarations elided\r\nlet builder = WebApplication.CreateBuilder(Environment.GetCommandLineArgs())\r\n\r\nbuilder.Services.AddHoneycomb(builder.Configuration) |\u003e ignore // 1\r\n\r\nlet rootHandler (tracer: Tracer) =\r\n    task {\r\n        use span = tracer.StartActiveSpan(\"sleep span\")\r\n        span.SetAttribute(\"duration_ms\", 100) |\u003e ignore // 2\r\n\r\n        do! Task.Delay(100)\r\n\r\n        return \"Hello World!\"\r\n    }\r\n\r\nlet app = builder.Build()\r\napp.MapGet(\"/\", Func\u003cTracer, Task\u003cstring\u003e\u003e(rootHandler)) |\u003e ignore // 3\r\n\r\napp.Run()\r\n```\r\n\r\n3 `ignore` calls is annoying, but this is actually pretty good compared to \"real world\" code with lots of routes, lots of instrumentation calls, and lots of wiring up to some other system/API.\r\n\r\nThe F# compiler is unlikely to be taught to know about every API out there that has a \"fluent-like\" API where the usage patterns aren\u0027t typically fluent in nature.\r\n\r\nInstead, an API in the runtime that library authors can sprinkle around a bit could be better. There is precedent for this already, where the F# compiler will respect several attributes (some defined in the runtime, some in FSharp.Core) and either emit or not emit a diagnostic based on the presence of that attribute.\r\n\r\nWith an attribute, API authors can decorate methods they don\u0027t expect to be used in a fluent/builder-like fashion, and the F# compiler will _not_ emit a diagnostic, and thus F# programmers can remove a bunch of explicit `ignore` calls.\r\n\r\n### API Proposal\r\n\r\n```C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    [AttributeUsage(AttributeTargets.ReturnValue)]\r\n    public class SafeToIgnore : Atttribute\r\n    {\r\n    }\r\n}\r\n```     \r\n\r\n\r\n### API Usage\r\n\r\n```C#\r\nusing System.Runtime.CompilerServices;\r\n// ... some code in OpenTelemetry .NET, Span.cs\r\n\r\n[return: SafeToIgnore]\r\npublic Span SetAttribute(string key, string value)\r\n{\r\n    //...\r\n}\r\n```\r\n\r\n### Alternative Designs\r\n\r\nThere are several alternatives I can think of:\r\n\r\n* **Call it `SafeToIgnoreReturnValueAttribute`** - basically the same proposal, just a different name.\r\n* **Define this attribute in FSharp.Core** - The biggest positive here is that it\u0027s easy to land, scoped only to F#, and coming from a source you can trust is \"doing it right\" (FSharp.Core). The biggest downside is that the FSharp.Core package must be added as a dependency to many .NET projects despite not having any F# code in their projects. It\u0027s a rather large binary too (4MB) that I\u0027m sure most package maintainers wouldn\u0027t want to include just for the sake of a single attribute.\r\n* **Define this attribute in some other package** - The biggest positive is that this is the easiest option, since it\u0027s independent of everything, portable everywhere, and small. The biggest downside is that it\u0027s just some random package. If Microsoft were to build and publish it, that could help a problem related to credibility.\r\n* **Make the compiler know about some APIs** - The biggest positive is there\u0027s no API considerations for anyone. The compiler just \"magically\" knows about some common APIs like ASP.NET Core and OpenTelemetry. The downside is that this is probably never going to happen.\r\n* **Don\u0027t warn on implicitly discarded values in F# anymore** - This is not going to happen.\r\n* **Do nothing** - This the status quo.\r\n\r\n### Risks\r\n\r\nI can\u0027t imagine this is much of a lift from an API design and implementation standpoint.\r\n\r\nThe bigger work would be in the F# compiler. It\u0027s relatively straightforward work to do though.\r\n\r\nPutting this attribute in the runtime also means that it won\u0027t be available in a portable manner. So this may disallow OpenTelemetry (one of my examples) from using the attribute. It would be available in ASP.NET Core though, which is where a _lot_ of this annoyance comes from today.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOoMhd1w==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc45fY-q",
                                           "createdAt":  "2021-11-09T20:48:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Sergio0694",
                                           "body":  "Very small question just on the proposed API shape, leaving the other points aside. Is there a specific reason why the attribute is using the whole method as target and not just the return value directly? As in, wouldn\u0027t something like this be more explicit and less verbose:\r\n\r\n```csharp\r\n[return: SafeToIgnore]\r\npublic Span SetAttribute(string key, string value)\r\n{\r\n    //...\r\n}\r\n```",
                                           "updatedAt":  "2021-11-09T20:48:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc45fqAw",
                                           "createdAt":  "2021-11-09T22:22:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "cartermp",
                                           "body":  "@Sergio0694 Not particularly, no. I\u0027m not sure if there\u0027s a preferred convention here, but your suggestion makes sense to me.\r\n\r\nUpdated the proposal with your suggestion.",
                                           "updatedAt":  "2021-11-09T22:47:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc45gCyY",
                                           "createdAt":  "2021-11-10T01:38:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lambdageek",
                                           "body":  "@cartermp  (sorry, I\u0027m not an F# programmer) is `expr |\u003e ignore` idiomatic F#? I would have expected `let _ = expr`.  That matches nicely with what you would do in a computation expression `let! _ = comp`.\r\n\r\nWhich actually brings up my real question: Would it be useful to have a way to ignore the generic parameter of a generic type?  So if you have a function like: \r\n```csharp\r\n[return: SafeToIgnore(GenericParameters = new int[]{0})]\r\nTask\u003cint\u003e DoSomethingAsync(...) { }\r\n```\r\nSo then in C# you\u0027d say\r\n```csharp\r\n  await DoSomethingAsync(...); // ok, the int result is safe to ignore\r\n```\r\nor in F#\r\n```fsharp\r\n  task {\r\n    do! DoSomethingAsync(...); /// also ok - { do! expr in cexpr } desugars to builder.Bind(expr, fun _ -\u003e {| cexpr |}\r\n  }\r\n```\r\n\r\n(I\u0027m going by the desugaring in https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/computation-expressions which seems to suggest that `do!` requires *expr* to have unit type)",
                                           "updatedAt":  "2021-11-10T01:39:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc45jioo",
                                           "createdAt":  "2021-11-10T18:22:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "joperezr",
                                           "body":  "Thanks for the proposal, sounds like we need F# compiler support for this right? In that case, would it make more sense to start the proposal there?",
                                           "updatedAt":  "2021-11-10T18:22:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc45tOdg",
                                           "createdAt":  "2021-11-13T22:25:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "cartermp",
                                           "body":  "@joperezr This would need F# compiler support, yes. But I think this is a good place to keep the proposal for now, since I\u0027d like to get a feeler for if the runtime is the best place for such an attribute. This _could_ be made self-contained in FSharp.Core, but as mentioned, comes with some other drawbacks.",
                                           "updatedAt":  "2021-11-13T22:25:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc45tOjs",
                                           "createdAt":  "2021-11-13T22:29:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "cartermp",
                                           "body":  "@lambdageek \r\n\r\n\u003e is `expr |\u003e ignore` idiomatic F#?\r\n\r\nYep. It\u0027s the most common, followed by `ignore expr`, and then the les-common `let _ = expr`.\r\n\r\n\u003e Would it be useful to have a way to ignore the generic parameter of a generic type? \r\n\r\nHmmm. Perhaps, although I would expect that such a distinction wouldn\u0027t matter much.",
                                           "updatedAt":  "2021-11-13T22:29:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6gyF3X",
                                           "createdAt":  "2025-03-04T12:57:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "LWChris",
                                           "body":  "Semantically I think only `[return: SafeToIgnore]` is sensible, because it\u0027s not the method that\u0027s safe to ignore, just its return value.\n\nI was about to suggest a `[Fluent]` attribute that\u0027s useful for C# as well. It inherently implies the same consequence as a `[return: SafeToIgnore]`, but at the same time gives context _why_ it is safe to ignore.\n\nThis would enable analyzers to offer a refactoring suggestion \"Prefer fluent method calls\" for `// A` but not warn for `// B`.\n\n```c-sharp\nvar sb = new StringBuilder();\n\nsb.Append(\"Working on \"); // A\nsb.Append(path); // B\n\nif (Path.Exists(path))\n{\n    sb.Append(\" (exists)\"); // B\n}\n```\n\n(I know with custom interpolation we can use `StringBuilder.Append` with interpolated string; it\u0027s just an example for a fluent interface used non-fluently).\n\nSomething else I have thought of and don\u0027t know whether it\u0027s relevant: `SafeToIgnore` is the opposite of `Pure`.",
                                           "updatedAt":  "2025-03-04T12:57:36Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "[API Proposal]: Add a \"You can ignore the return value safely\" attribute",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.CompilerServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/62342",
        "createdAt":  "2021-12-03T18:00:17Z",
        "number":  62342,
        "author":  "rickbrew",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCFVfWw==",
                          "nodes":  [
                                        {
                                            "content":  "EYES",
                                            "user":  "Rekkonnect",
                                            "createdAt":  "2021-12-03T18:16:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "NN---",
                                            "createdAt":  "2021-12-05T10:03:03Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "RoboReebos",
                                            "createdAt":  "2021-12-06T10:30:40Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2022-03-23T17:42:05Z",
        "body":  "### Background and motivation\r\n\r\nI\u0027m told that something similar to this has been suggested before but it was decided that it was \"too niche.\" \r\n\r\nWell, I\u0027m finding that I could really use this! Without it, it\u0027s impossible to do certain operations on variables or fields that are pointers. No `Interlocked.Exchange`, no nothing. Generics don\u0027t work with pointers, but they do work with pointer-size structs that simply wrap the pointer (e.g. `Ptr\u003cT\u003e` which is just a `struct { T* p; }` plus all the constraints and casting operators you\u0027d expect).\r\n\r\nFrom what I can tell, this is the key method that\u0027s needed to bridge the gap between pointers and generics. No need for adding many other pieces of support in the language, compiler, runtime, etc. Just let us _temporarily_ reinterpret a `T*` as a `Ptr\u003cT\u003e` or `IntPtr` to enable performing an operation that works fine on that type.\r\n\r\nIn interop code, it\u0027s more idiomatic and less kludgey to _just use pointers_, and it\u0027s unsavory to have to switch _everything_ to pointer-wrapping structs just because pointers aren\u0027t compatible with many things in the compiler or the framework. Once you have a field or variable that\u0027s a `T*` you are completely locked out of important operations that are idiomatic in native/interop code. You just can\u0027t break the pointer out of its jail without some _really weird_ hacks that the JIT optimizer likely doesn\u0027t stand a chance against (someone found a crazy way using function pointers to accomplish this, but because of that it involves a non-inlinable method call).\r\n\r\nWith this I can do `Interlocked` operations on pointers, I can do `Volatile.Read()` and `Volatile.Write()` on pointers, etc. I can reinterpret an `IUnknown*` to a `ComPtr\u003cIUnknown\u003e` (from TerraFX). And as long as the inverse method is available, I can convert back to pointers when needed. Having to sandwich these with `Unsafe` calls is also unsavory, but par for the course when working heavily with interop code and `Unsafe`.\r\n\r\nWith help from others (esp. @jakobbotsch) I was able to get a prototype of this and it does work. Not having this in the runtime is very inconvenient, but not completely blocking, as I could create a nuget package. However, having an assembly and nuget package for the sake of 1 method is a little heavy.\r\n\r\ncc @Sergio0694 @jakobbotsch @tannergooding who were part of the discussion in Discord\r\n\r\n### API Proposal\r\n\r\n```C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public static class Unsafe\r\n    {\r\n        // This name was chosen in part so it does not sort next to other methods like AsRef, \r\n        // therefore less probability it could be accidentally used (via auto-complete or etc.).\r\n        // sizeof(U) must equal sizeof(T*)\r\n        public static ref U AsPtrRef\u003cT, U\u003e(ref T* source)\r\n            where T : unmanaged\r\n            where U : unmanaged\r\n\r\n        // The inverse operation is needed as well, to convert from ref U back to ref T*\r\n        public static ref U* AsPtrRef\u003cT, U\u003e(ref T source)\r\n            where T : unmanaged\r\n            where U : unmanaged\r\n\r\n        // Might want to have `ref T**` versions as well, up to a reasonable arity. `ref T***` perhaps, but `ref T*******` is a bit much. `T***` does _very occasionally_ pop up in native interop code (pointer to 2-dimensional array).\r\n    }\r\n}\r\n```\r\n\r\nThe IL for this is pretty straightforward, it\u0027s just `ldarg.0` and `ret`, along with attributes to tag `T` and `U` as unmanaged. I did manage to get a working version of this with the help of @jakobbotsch \r\n\r\n```\r\n  .method public hidebysig static !!U\u0026  AsPtrRef\u003cvaluetype .ctor (class [System.Runtime]System.ValueType modreq([System.Runtime.InteropServices]System.Runtime.InteropServices.UnmanagedType)) T,valuetype .ctor (class [System.Runtime]System.ValueType modreq([System.Runtime.InteropServices]System.Runtime.InteropServices.UnmanagedType)) U\u003e(!!T*\u0026 p) cil managed\r\n  {\r\n    .param type T \r\n      .custom instance void System.Runtime.CompilerServices.IsUnmanagedAttribute::.ctor() = ( 01 00 00 00 ) \r\n    .param type U \r\n      .custom instance void System.Runtime.CompilerServices.IsUnmanagedAttribute::.ctor() = ( 01 00 00 00 ) \r\n    // Code size       2 (0x2)\r\n    .maxstack  8\r\n    IL_0000:  ldarg.0\r\n    IL_0001:  ret\r\n  } // end of method AsPtrRef\r\n```\r\n\r\n### API Usage\r\n\r\n```\r\npublic static unsafe T* InterlockedExchangeHelper\u003cT\u003e(ref T* p, T* newValue) \r\n    where T : unmanaged\r\n{\r\n    return (T*)Interlocked.Exchange(ref Unsafe.AsPtrRef\u003cT, IntPtr\u003e(ref p), (IntPtr)newValue);\r\n}\r\n\r\npublic class MyComWrapper \r\n    : IDisposable\r\n{\r\n    private IUnknown* pObject;\r\n\r\n    public MyComWrapper(IUnknown* pObject)\r\n    {\r\n        this.pObject = pObject;\r\n        pObject-\u003eAddRef();\r\n    }\r\n\r\n    ~MyComWrapper()\r\n    {\r\n        Dispose(false);\r\n    }\r\n\r\n    public void Dispose()\r\n    {\r\n        Dispose(true);\r\n        GC.SuppressFinalize(this);\r\n    }\r\n\r\n    private void Dispose(bool disposing)\r\n    {\r\n        // can\u0027t do this, as the `T` can\u0027t be a pointer\r\n        //IUnknown* pObject = Interlocked.Exchange(ref this.pUnknown);\r\n\r\n        // but this will work\r\n        IUnknown* pObject = InterlockedExchangeHelper(ref this.pObject, null);\r\n\r\n        if (pObject != null)\r\n        {\r\n            pObject-\u003eRelease();\r\n        }        \r\n    }\r\n}\r\n```\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\nThe naming of the method needs to be chosen very carefully.\r\n\r\nIf the non-pointer type being converted to/from is not at least pointer-sized, bad things can happen. But, this is `Unsafe`.\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOOsaTyg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc46wOOh",
                                           "createdAt":  "2021-12-03T18:00:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-12-03T18:00:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc46wQgP",
                                           "createdAt":  "2021-12-03T18:15:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Sergio0694",
                                           "body":  "I mean of course I like this proposal, a couple of small questions though 😄\r\n\r\n1) Couldn\u0027t the first one just be an `Unsafe.As` overload, given it has a different parameter type?\r\n\r\n```csharp\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public static class Unsafe\r\n    {\r\n        public static ref U As\u003cT, U\u003e(ref T* source)\r\n             where T : unmanaged\r\n             where U : unmanaged;\r\n    }\r\n}\r\n```\r\n\r\n2) I\u0027d argue the second one should be called `AsPointerRef` for consistency:\r\n\r\n```csharp\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public static class Unsafe\r\n    {\r\n        public static ref U* AsPointerRef\u003cT, U\u003e(ref T source)\r\n            where T : unmanaged\r\n            where U : unmanaged;\r\n    }\r\n}\r\n```\r\n\r\nOther than that I agree this would unblock several scenarios while language support isn\u0027t there.\r\nThat said, it\u0027d still be nice to just have language support for pointers as generics in the long run (#13627).\r\n\r\nAdditionally, worth mentioning, @AndyAyersMS is looking into letting the JIT inline function pointer calls, which would allow doing this (or, defining these APIs) entirely in C# with no need for new APIs, with the same final codegen). They\u0027d be:\r\n\r\n```csharp\r\npublic static ref U As\u003cT, U\u003e(ref T* source)\r\n     where T : unmanaged\r\n     where U : unmanaged\r\n {\r\n     return ref\r\n         ((delegate*\u003cref T*, ref U\u003e)\r\n          (delegate*\u003cref byte, ref byte\u003e)\r\n          \u0026Unsafe.As\u003cbyte, byte\u003e)(ref source);\r\n }\r\n\r\npublic static ref U* AsPointerRef\u003cT, U\u003e(ref T source)\r\n    where T : unmanaged\r\n    where U : unmanaged\r\n{\r\n    return ref\r\n         ((delegate*\u003cref T, ref U*\u003e)\r\n          (delegate*\u003cref byte, ref byte\u003e)\r\n          \u0026Unsafe.As\u003cbyte, byte\u003e)(ref source);\r\n}\r\n```",
                                           "updatedAt":  "2021-12-03T18:15:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc46wT_y",
                                           "createdAt":  "2021-12-03T18:39:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rickbrew",
                                           "body":  "@Sergio0694 I\u0027m fine with whatever the chosen name is :)",
                                           "updatedAt":  "2021-12-03T18:39:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc46wcqC",
                                           "createdAt":  "2021-12-03T19:38:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime-compilerservices\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\r\n\r\nI\u0027m told that something similar to this has been suggested before but it was decided that it was \"too niche.\" \r\n\r\nWell, I\u0027m finding that I could really use this! Without it, it\u0027s impossible to do certain operations on variables or fields that are pointers. No `Interlocked.Exchange`, no nothing. Generics don\u0027t work with pointers, but they do work with pointer-size structs that simply wrap the pointer (e.g. `Ptr\u003cT\u003e` which is just a `struct { T* p; }` plus all the constraints and casting operators you\u0027d expect).\r\n\r\nFrom what I can tell, this is the key method that\u0027s needed to bridge the gap between pointers and generics. No need for adding many other pieces of support in the language, compiler, runtime, etc. Just let us _temporarily_ reinterpret a `T*` as a `Ptr\u003cT\u003e` or `IntPtr` to enable performing an operation that works fine on that type.\r\n\r\nIn interop code, it\u0027s more idiomatic and less kludgey to _just use pointers_, and it\u0027s unsavory to have to switch _everything_ to pointer-wrapping structs just because pointers aren\u0027t compatible with many things in the compiler or the framework. Once you have a field or variable that\u0027s a `T*` you are completely locked out of important operations that are idiomatic in native/interop code. You just can\u0027t break the pointer out of its jail without some _really weird_ hacks that the JIT optimizer likely doesn\u0027t stand a chance against (someone found a crazy way using function pointers to accomplish this, but because of that it involves a non-inlinable method call).\r\n\r\nWith this I can do `Interlocked` operations on pointers, I can do `Volatile.Read()` and `Volatile.Write()` on pointers, etc. I can reinterpret an `IUnknown*` to a `ComPtr\u003cIUnknown\u003e` (from TerraFX). And as long as the inverse method is available, I can convert back to pointers when needed. Having to sandwich these with `Unsafe` calls is also unsavory, but par for the course when working heavily with interop code and `Unsafe`.\r\n\r\nWith help from others (esp. @jakobbotsch) I was able to get a prototype of this and it does work. Not having this in the runtime is very inconvenient, but not completely blocking, as I could create a nuget package. However, having an assembly and nuget package for the sake of 1 method is a little heavy.\r\n\r\ncc @Sergio0694 @jakobbotsch @tannergooding who were part of the discussion in Discord\r\n\r\n### API Proposal\r\n\r\n```C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public static class Unsafe\r\n    {\r\n        // This name was chosen in part so it does not sort next to other methods like AsRef, \r\n        // therefore less probability it could be accidentally used (via auto-complete or etc.).\r\n        // sizeof(U) must equal sizeof(T*)\r\n        public static ref U AsPtrRef\u003cT, U\u003e(ref T* source)\r\n            where T : unmanaged\r\n            where U : unmanaged\r\n\r\n        // The inverse operation is needed as well, to convert from ref U back to ref T*\r\n        public static ref U* AsPtrRef\u003cT, U\u003e(ref T source)\r\n            where T : unmanaged\r\n            where U : unmanaged\r\n\r\n        // Might want to have `ref T**` versions as well, up to a reasonable arity. `ref T***` perhaps, but `ref T*******` is a bit much. `T***` does _very occasionally_ pop up in native interop code (pointer to 2-dimensional array).\r\n    }\r\n}\r\n```\r\n\r\nThe IL for this is pretty straightforward, it\u0027s just `ldarg.0` and `ret`, along with attributes to tag `T` and `U` as unmanaged. I did manage to get a working version of this with the help of @jakobbotsch \r\n\r\n```\r\n  .method public hidebysig static !!U\u0026  AsPtrRef\u003cvaluetype .ctor (class [System.Runtime]System.ValueType modreq([System.Runtime.InteropServices]System.Runtime.InteropServices.UnmanagedType)) T,valuetype .ctor (class [System.Runtime]System.ValueType modreq([System.Runtime.InteropServices]System.Runtime.InteropServices.UnmanagedType)) U\u003e(!!T*\u0026 p) cil managed\r\n  {\r\n    .param type T \r\n      .custom instance void System.Runtime.CompilerServices.IsUnmanagedAttribute::.ctor() = ( 01 00 00 00 ) \r\n    .param type U \r\n      .custom instance void System.Runtime.CompilerServices.IsUnmanagedAttribute::.ctor() = ( 01 00 00 00 ) \r\n    // Code size       2 (0x2)\r\n    .maxstack  8\r\n    IL_0000:  ldarg.0\r\n    IL_0001:  ret\r\n  } // end of method AsPtrRef\r\n```\r\n\r\n### API Usage\r\n\r\n```\r\npublic static unsafe T* InterlockedExchangeHelper\u003cT\u003e(ref T* p, T* newValue) \r\n    where T : unmanaged\r\n{\r\n    return (T*)Interlocked.Exchange(ref Unsafe.AsPtrRef\u003cT, IntPtr\u003e(ref p), (IntPtr)newValue);\r\n}\r\n\r\npublic class MyComWrapper \r\n    : IDisposable\r\n{\r\n    private IUnknown* pObject;\r\n\r\n    public MyComWrapper(IUnknown* pObject)\r\n    {\r\n        this.pObject = pObject;\r\n        pObject-\u003eAddRef();\r\n    }\r\n\r\n    ~MyComWrapper()\r\n    {\r\n        Dispose(false);\r\n    }\r\n\r\n    public void Dispose()\r\n    {\r\n        Dispose(true);\r\n        GC.SuppressFinalize(this);\r\n    }\r\n\r\n    private void Dispose(bool disposing)\r\n    {\r\n        // can\u0027t do this, as the `T` can\u0027t be a pointer\r\n        //IUnknown* pObject = Interlocked.Exchange(ref this.pUnknown);\r\n\r\n        // but this will work\r\n        IUnknown* pObject = InterlockedExchangeHelper(ref this.pObject, null);\r\n\r\n        if (pObject != null)\r\n        {\r\n            pObject-\u003eRelease();\r\n        }        \r\n    }\r\n}\r\n```\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\nThe naming of the method needs to be chosen very carefully.\r\n\r\nIf the non-pointer type being converted to/from is not at least pointer-sized, bad things can happen. But, this is `Unsafe`.\r\n\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003erickbrew\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Runtime.CompilerServices`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-12-03T19:38:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc46xJAq",
                                           "createdAt":  "2021-12-04T03:47:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rickbrew",
                                           "body":  "cc @DaZombieKiller who was also part of the discussion in Discord",
                                           "updatedAt":  "2021-12-04T03:47:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc46xpPK",
                                           "createdAt":  "2021-12-04T21:04:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOClNDSw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "ROCKET",
                                                                               "user":  "ltrzesniewski",
                                                                               "createdAt":  "2021-12-05T16:12:01Z"
                                                                           },
                                                                           {
                                                                               "content":  "ROCKET",
                                                                               "user":  "hypeartist",
                                                                               "createdAt":  "2022-07-05T15:17:23Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "rickbrew",
                                           "body":  "For the time being (or longer), I\u0027ve published a NuGet package that enables this sort of thing, https://github.com/rickbrew/PointerToolkit/ . I use [InlineIL.Fody](https://github.com/ltrzesniewski/InlineIL.Fody) to generate the methods.",
                                           "updatedAt":  "2021-12-04T21:04:13Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "[API Proposal]: System.Runtime.CompilerServices.Unsafe.AsPtrRef\u003cT, U\u003e(ref T* source) : ref U",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.CompilerServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/67285",
        "createdAt":  "2022-03-29T09:31:30Z",
        "number":  67285,
        "author":  "gerhard17",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODMx5Xg==",
                          "nodes":  [
                                        {
                                            "content":  "EYES",
                                            "user":  "MihaZupan",
                                            "createdAt":  "2022-03-29T09:47:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "deeprobin",
                                            "createdAt":  "2022-03-29T15:57:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2022-05-25T00:03:32Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "anar-bastanov",
                                            "createdAt":  "2022-08-31T14:30:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2023-04-11T11:59:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jeanbern",
                                            "createdAt":  "2023-06-14T17:28:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hamarb123",
                                            "createdAt":  "2023-08-04T21:23:53Z"
                                        },
                                        {
                                            "content":  "ROCKET",
                                            "user":  "MineCake147E",
                                            "createdAt":  "2023-12-13T04:52:33Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "BladeWise",
                                            "createdAt":  "2024-12-05T23:18:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "exyi",
                                            "createdAt":  "2025-04-05T11:42:04Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "TFlippy",
                                            "createdAt":  "2025-08-18T01:46:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Enderlook",
                                            "createdAt":  "2025-08-27T00:24:07Z"
                                        }
                                    ],
                          "totalCount":  12
                      },
        "updatedAt":  "2025-07-06T16:47:17Z",
        "body":  "### Background and motivation\r\n\r\nRecently two internal IsKnownConstant() overloads in class RuntimeHelpers for char and string? were added.\r\nFor a library developer it would be usefull to consume this API like the framework internaly does.\r\n\r\nSame performance/codegen reasons apply as with the original (internal) proposal. #11484\r\n\r\nAt least one overload for each primitive type (+ the existing string) would be wellcomed.\r\n\r\nSee also: #63734 and #64809\r\n\r\nThis request has similarities with GNU GCC int __builtin_constant_p (exp)\r\n\r\n### API Proposal\r\n\r\n```C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public static partial class RuntimeHelpers\r\n    {\r\n        // The following intrinsics return true if input is a compile-time constant\r\n        // Feel free to add more overloads on demand\r\n\r\n       // CHANGE VISIBILITY\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(string? t) =\u003e false;\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(char t) =\u003e false;\r\n\r\n        // ADD OVERLOADS\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(byte t) =\u003e false;\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(sbyte t) =\u003e false;\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(short t) =\u003e false;\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(ushort t) =\u003e false;\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(int t) =\u003e false;\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(uint t) =\u003e false;\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(long t) =\u003e false;\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(ulong t) =\u003e false;\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(nint t) =\u003e false;\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(nuint t) =\u003e false;\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(float t) =\u003e false;\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(double t) =\u003e false;\r\n\r\n    }\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\nAPI can be public used like the current internal usage inside of the runtime.\r\n\r\n### Alternative Designs\r\n\r\nMaybe a true generic Version can be used.\r\n\r\n```C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public static partial class RuntimeHelpers\r\n    {\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant\u003cT\u003e(T t) =\u003e false;\r\n    }\r\n}\r\n```\r\n\r\n### Risks\r\n\r\n- No breaking change. Not an public API today.\r\n\r\n- Will depend on JIT beyond c# language spec.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOfqLjmg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5AeJcO",
                                           "createdAt":  "2022-03-29T09:31:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-03-29T09:31:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5AeZEO",
                                           "createdAt":  "2022-03-29T10:36:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEfwQVw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "SupinePandora43",
                                                                               "createdAt":  "2022-03-29T11:03:54Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "GSPP",
                                                                               "createdAt":  "2022-04-12T09:39:01Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "anar-bastanov",
                                                                               "createdAt":  "2022-09-14T15:25:46Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2023-04-11T11:59:40Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "redknightlois",
                                                                               "createdAt":  "2024-05-22T11:46:28Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Enderlook",
                                                                               "createdAt":  "2025-08-27T00:24:11Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  6
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "I\u0027m in favor of making it generic.",
                                           "updatedAt":  "2022-03-29T10:36:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5AeZHL",
                                           "createdAt":  "2022-03-29T10:36:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime-compilerservices\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\r\n\r\nRecently two internal IsKnownConstant() overloads in class RuntimeHelpers for char and string? were added.\r\nFor a library developer it would be usefull to consume this API like the framework internaly does.\r\n\r\nSame performance/codegen reasons apply as with the original (internal) proposal. #11484\r\n\r\nAt least one overload for each primitive type (+ the existing string) would be wellcomed.\r\n\r\nSee also: #63734 and #64809\r\n\r\nThis request has similarities with GNU GCC int __builtin_constant_p (exp)\r\n\r\n### API Proposal\r\n\r\n```C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public static partial class RuntimeHelpers\r\n    {\r\n        // The following intrinsics return true if input is a compile-time constant\r\n        // Feel free to add more overloads on demand\r\n\r\n       // CHANGE VISIBILITY\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(string? t) =\u003e false;\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(char t) =\u003e false;\r\n\r\n        // ADD OVERLOADS\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(byte t) =\u003e false;\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(sbyte t) =\u003e false;\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(short t) =\u003e false;\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(ushort t) =\u003e false;\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(int t) =\u003e false;\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(uint t) =\u003e false;\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(long t) =\u003e false;\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(ulong t) =\u003e false;\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(nint t) =\u003e false;\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(nuint t) =\u003e false;\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(float t) =\u003e false;\r\n\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant(double t) =\u003e false;\r\n\r\n    }\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\nAPI can be public used like the current internal usage inside of the runtime.\r\n\r\n### Alternative Designs\r\n\r\nMaybe a true generic Version can be used.\r\n\r\n```C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public static partial class RuntimeHelpers\r\n    {\r\n        [Intrinsic]\r\n        public static bool IsKnownConstant\u003cT\u003e(T t) =\u003e false;\r\n    }\r\n}\r\n```\r\n\r\n### Risks\r\n\r\n- No breaking change. Not an public API today.\r\n\r\n- Will depend on JIT beyond c# language spec.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003egerhard17\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Runtime.CompilerServices`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-03-29T10:36:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Aeemc",
                                           "createdAt":  "2022-03-29T11:04:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "SupinePandora43",
                                           "body":  "\u003e I\u0027m in favor of making it generic.\n\nWill it be able to consume `null` reference types and `default` value types?",
                                           "updatedAt":  "2022-03-29T11:04:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Aeop1",
                                           "createdAt":  "2022-03-29T11:49:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "1) ~~The generic version must be guarded with `: unmanaged` constraint because with ref types it might introduce a runtime lookup that will prevent inlining~~ (no longer relevant, jit can do inlining with lookups now)\n2) Is ` __builtin_constant` popular in the C/C++ world? I\u0027ve never seen it in the wild. Do you have a real-world scenario where it\u0027d help you?\n3) There are unresolved concerns with this API and JIT\u0027s inliner, e.g.:\n\n```csharp\nvoid DoWork(int a)\n{\n    if (RuntimeHelpers.IsKnownConstant(a) \u0026\u0026 a == 42)\n    {\n        // a lot of code\n    }\n    // a lot of code\n}\n```\njit (currently) is not able to give it additional inlining boost only when a == 42 (currently it doesn\u0027t boost at all)",
                                           "updatedAt":  "2025-07-06T16:47:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Ae1_0",
                                           "createdAt":  "2022-03-29T12:46:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gerhard17",
                                           "body":  "@EgorBo \r\n\r\n- I would be fine with restriction unmanaged.\r\n- I found the C/C++ documentation during internet search. I just searched, if the JIT already implements such a thing. I for myself being somehow familiar with C/C++, I never used it in production code. :-)\r\n- Yes, currently I have such a case in an arbitrary presision floating point library. Common numeric constants given like literals would greatly benefit from this.\r\n- Yes this is similar to my use case. Only a little bit longer switch statement like:\r\n\r\n```\r\n[MethodImpl(MethodImplOptions.AggressiveInlining)]\r\nvoid DoWork(int a)\r\n{\r\n    if (RuntimeHelpers.IsKnownConstant(a))\r\n    {\r\n        switch(a) {\r\n        case 42:\r\n          // some code\r\n          return;\r\n        case 43:\r\n          // some code\r\n          return;\r\n         // some more cases with some code\r\n       }\r\n    }\r\n    // a lot of generalized, but slower code\r\n}\r\n\r\n```\r\n\r\nBtw. thanks for all the cool coding I found by you in this repository!\r\n",
                                           "updatedAt":  "2022-03-29T14:43:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Ae2bZ",
                                           "createdAt":  "2022-03-29T12:47:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gerhard17",
                                           "body":  "Could restriction unmanaged be dangerous with large structs?\r\nCopying struct data, when no JIT is involved. \r\nContradicting the performance gain in non JIT environments.",
                                           "updatedAt":  "2022-03-29T12:49:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Ae3jH",
                                           "createdAt":  "2022-03-29T12:52:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "SupinePandora43",
                                           "body":  "\u003e Could restriction unmanaged be dangerous with large structs? Copying struct data, when no JIT is involved. Contradicting the performance gain in non JIT environments.\r\n\r\nWhat about `in` and `ref readonly`?",
                                           "updatedAt":  "2022-03-29T12:52:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5AfFSH",
                                           "createdAt":  "2022-03-29T13:43:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCXnSnw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "GSPP",
                                                                               "createdAt":  "2022-04-12T09:39:53Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e unresolved concerns with this API and JIT\u0027s inliner\r\n\r\nYep, it would be useful to see this API used in libraries in more places to prove that it actually works except for a few trivial carefully crafted cases.\r\n\r\nhttps://github.com/dotnet/runtime/pull/64821 was unsuccessfully in using this API for more complex code.",
                                           "updatedAt":  "2022-03-29T17:14:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5AlCPG",
                                           "createdAt":  "2022-03-30T18:03:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "buyaa-n",
                                           "body":  "Tag @GrabYourPitchforks for triage as he created the [internal API proposal](https://github.com/dotnet/runtime/issues/11484)",
                                           "updatedAt":  "2022-03-30T18:03:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Aocpe",
                                           "createdAt":  "2022-03-31T09:49:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gerhard17",
                                           "body":  "@jkotas \r\nHow does the annotation `[MethodImpl(MethodImplOptions.AggressiveInlining)]` change the inlining behavior?\r\n\r\nWill all code be inlined or is only the budget increased to inline more (but maybe not all) code?\r\n",
                                           "updatedAt":  "2022-03-31T09:49:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Aon-b",
                                           "createdAt":  "2022-03-31T10:31:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODPY_aA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "ROCKET",
                                                                               "user":  "SupinePandora43",
                                                                               "createdAt":  "2022-04-05T11:16:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "ROCKET",
                                                                               "user":  "MineCake147E",
                                                                               "createdAt":  "2023-12-13T04:54:28Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "\u003e @jkotas How does the annotation `[MethodImpl(MethodImplOptions.AggressiveInlining)]` change the inlining behavior?\r\n\u003e \r\n\u003e Will all code be inlined or is only the budget increased to inline more (but maybe not all) code?\r\n\r\nYes, large `AggressiveInlining` calls may eat the inliner budget pretty quickly - that is something we plan to fix eventually - I mean inliner should be smarter and do not take large pieces (branches/blocks) of methods which will be eliminated at the import stage into account, just not sure it will make it to .NET 7.0\r\n\r\nExample: [sharplab.io](https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA0AXEBDAzgWwB8ABAJgEYBYAKGIAYACY8gOgDkBXfGKASzFwBuGvSasAShwB2GXtxYBhCPgAOvADY8AyjwBu/GEJo1eMnlOzqmpMQHYaAbxoMXDAPRuGAEV76AJjAMvLgMUhAYQVLqpjB+kRgQDAAqhhjOrh4MsHgQUgwA5KbRUoEwCGAwsSHAHH4A5jAY+ekuAGbqENgRKbgYABQAajBgCVAAPO2dGAB8DLrkaAxDI9ATHV2zuqQAlAwAvLM+ulpglthQffOLW9vC1K4MLY/3rk9PANoAso0AFhB+AElVOo+t8MH9AcCAPIqWS5XAsACCdTqsFwuF8MABUVMpjq2wAuk9iABmMRIZLeXy8AJjJLTPpJBiaVoYRZMvh1H4YXYAdx+PECTJADGk+GwFgafieTheDxcvFaDD6GAAnioYBBWozdns9gw1RqtX1gKqMDBttsnvLXMRbMqkttBpYODAkuqLSazZ6+hxTDyveanQMXW6PdsWRFPL7/U7TUHnepXe6NdtOdzbtbXIrlYbNdrHft9XnjX4IBxgJpLVmbXaHcHQymfWWK1XE8nw5H3MqW5XPSGk2HU+meXcbQqlSqPcbC3qDdPtbg/lAeVa5eOXHWde2h56l9AA31Y319yuG4OmxGYKzu0eZE7TwGBx3h7wuaOa0FJyWC7riwu71XT8Hi3R0d0vPpAPPF8LS7aNj2fXc0zfDMx3HHMpyNX8i3nLC+g6KR8TXDcQPtbdEIg/DcnxcDO2vKNlQImiKPDEdM3XB4MJ/HUcO47EMAABQwKBqw48dQOgpDIKkBDGzom9o34oSRNo1933YjcuIA2d/zwgBVJThNEkjbTIsCWNTaS/XvVTYPo28DJkZTJMvNi0JtLS8J03D8xPeMLWIkymDMlzwz870nSg8KEwsuyFOVY9cH80K1NQz9PN87zuMmLpjKCiTbMinKnzk1M4OVYqUotNz0u/bS/x840OEfPKTIK2KnWa5dD2sgMuoPKqr3imMbP6s9CpqsSJ1zereIA3rWpI9rSp9BbCvKkaSovViUI/KavxmryGu4jgmMWjdlu2yzfTO9b7OjU7qMGyaN3BKAIF5UIYE+thwi0DgVBUA9YgAUXKGBYV4XI+gAIi0cQkSgOoAH0m1+jB/sB4G/BhjTXAAX2Mdcvl+f4gRUEEwQhcn1BhOEpARZFUUMDFdCxHEZMIwknn9cxLHJSkAHFGhBzRuBkPSGewVoYDpBlTCWYZRjluYlegRZ/UiAIED5AVYEpEVeigDgRn2WZP0l3BpZgJE/D8PpYCVS3raRXAxmWZX6XZBlHYYZ2Zdd8RrzvVWVhE7YNakbW8ZcD4qbJ4FQVJyEKbpqGGaRFE0VZ9nijxbn12kK2ZcpI4TjOcZ6UGNXK9mSNFg91Z6SyXbdcFA3RSkcVJViM3ng3I4aRgPphYwUWYHFjB/dlqv64YcgI4YUfx8n6e5Yd3bFgX9j8aAA)",
                                           "updatedAt":  "2022-03-31T10:32:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DAGvI",
                                           "createdAt":  "2022-05-11T18:01:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC5mmZw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "SupinePandora43",
                                                                               "createdAt":  "2022-05-12T04:16:24Z"
                                                                           },
                                                                           {
                                                                               "content":  "CONFUSED",
                                                                               "user":  "gerhard17",
                                                                               "createdAt":  "2022-05-12T09:01:03Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "GSPP",
                                                                               "createdAt":  "2022-05-19T10:23:33Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pentp",
                                                                               "createdAt":  "2022-09-26T14:55:25Z"
                                                                           },
                                                                           {
                                                                               "content":  "CONFUSED",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2023-04-11T12:00:25Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  5
                                                         },
                                           "author":  "GrabYourPitchforks",
                                           "body":  "\u003e Tag GrabYourPitchforks for triage as he created the internal API proposal\r\n\r\nI agree with Jan\u0027s assessment at https://github.com/dotnet/runtime/issues/67285#issuecomment-1081889927. This is experimental and very temperamental. We need more evidence that it\u0027s widely useful before exposing it publicly. It honestly wouldn\u0027t surprise me if the JIT folks somehow come up with some clever scheme which obviates the utility of _IsKnownConstant_ entirely and we end up removing the API as a result.",
                                           "updatedAt":  "2022-05-11T18:01:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-ouOa",
                                           "createdAt":  "2024-05-22T11:51:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "redknightlois",
                                           "body":  "This code should have a `IsKnownConstant` guard in the size. Currently we do it by code inspection. https://github.com/ravendb/ravendb/blob/c0bbece37e7b3d3afff2010b6b0e108633fd136e/src/Sparrow/Memory.cs#L472\r\n\r\nWe have a few examples on our codebase that could use a generic version. ",
                                           "updatedAt":  "2024-05-22T11:53:33Z"
                                       }
                                   ],
                         "totalCount":  14
                     },
        "title":  "Public API Proposal: Make bool RuntimeHelpers.IsKnownConstant(...) public for all primitive types",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.CompilerServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/69344",
        "createdAt":  "2022-05-13T13:40:28Z",
        "number":  69344,
        "author":  "Neme12",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-07-11T21:03:42Z",
        "body":  "With the new pattern for interpolated strings in C# 10, the canonical way to get the string formatted with invariant culture is to do this:\r\n```c#\r\nvar str = string.Create(CultureInfo.InvariantCulture, $\"hello {1.5}\");\r\n```\r\n\r\nI wanted to write a helper method that would shorten this a bit and let me do this without having to specify the `CultureInfo` every time, because invariant culture is by far the most common and the only one I\u0027ve ever needed to do this with. I wrote a method like this:\r\n```c#\r\nstring Invariant(ref DefaultInterpolatedStringHandler handler)\r\n{\r\n    return string.Create(CultureInfo.InvariantCulture, ref handler);\r\n}\r\n\r\n// usage:\r\nvar str = Invariant($\"hello {1.5}\");\r\n```\r\nWhen I used this method, at first I was confused why it wasn\u0027t working - the string was still formatted with `CurrentCulture`, not `InvariantCulture`. Then I realized - when the method receives a `DefaultInterpolatedStringHandler`, the string is already built by the compiler with current culture. so `string.Create(CultureInfo.InvariantCulture, ref handler)` will have no effect on changing the culture - the culture has to be passed in to the constructor of `DefaultInterpolatedStringHandler`, which the compiler does based on `InterpolatedStringHandlerArgumentAttribute` in the `string.Create` method parameter.  To make this work without having to have the culture as a parameter to the method, I actually had to create a custom interpolated string handler type that wraps a `DefaultInterpolatedStringHandler` and provides the desired culture in the constructor.\r\n\r\nThis is something that\u0027s easy to miss and it\u0027s easy to assume that the method I wrote would just work. I propose that compiler issues a warning when calling a method that has an interpolated string handler parameter with the `InterpolatedStringHandlerArgumentAttribute`, and I\u0027m passing in an existing variable (a fully constructed handler) as opposed to an interpolated string literal, because the compiler knows that the attribute will have no effect. I first thought about making this suggestion in dotnet/runtime as a built-in analyzer, but this is really a language feature - the compiler provides the argument to the constructor of the handler so it makes sense to me that the compiler would issue a warning here when it cannot do that.\r\n\r\n```c#\r\nstring Invariant(ref DefaultInterpolatedStringHandler handler)\r\n{\r\n    return string.Create(CultureInfo.InvariantCulture, ref handler);\r\n                                                       ~~~~~~~~~~~\r\n}\r\n```\r\nIn the example above, the highlighted text span should show a warning that `InterpolatedStringHandlerArgument` will have no effect as the argument can\u0027t be provided because the handler is already constructed.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOQymzBg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5DJtLA",
                                           "createdAt":  "2022-05-13T13:49:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CyrusNajmabadi",
                                           "body":  "Should be moved to Roslyn or Roslyn-analyzers, but I can\u0027t seem to do that. @333fred where do you think this should go?",
                                           "updatedAt":  "2022-05-13T13:49:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DJtLC",
                                           "createdAt":  "2022-05-13T13:51:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "\u003e Should be moved to Roslyn or Roslyn-analyzers, but I can\u0027t seem to do that. @333fred where do you think this should go?\r\n\r\nWhy do you think this shouldn\u0027t be a compiler warning? It seems like incorrect use of a language feature.",
                                           "updatedAt":  "2022-05-13T14:10:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DJtLD",
                                           "createdAt":  "2022-05-13T14:11:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCc0lXQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Neme12",
                                                                               "createdAt":  "2022-05-13T14:13:18Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "CyrusNajmabadi",
                                           "body":  "I didn\u0027t say I thought it shouldn\u0027t be a compiler warning. I said I think this should be moved to Roslyn or Roslyn-analyzers.  I\u0027m leaving it to Fred to state which he thinks would be best :-)",
                                           "updatedAt":  "2022-05-13T14:11:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DJtLE",
                                           "createdAt":  "2022-05-13T14:18:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "Ah, ok, I thought compiler warnings relating to language features were discussed by the LDT. I\u0027ve seen some LDM notes where they decided that certain usages should produce warnings, for example [here](https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-04-25.md#ref-readonly-method-parameters) about using `ref` with an `in` parameter.",
                                           "updatedAt":  "2022-05-13T14:37:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DJtLF",
                                           "createdAt":  "2022-05-13T17:27:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "333fred",
                                           "body":  "I\u0027d be somewhat concerned about making this a compiler warning, though I can see the appeal. My main concern is that if you\u0027re an API author, you might be forwarding implementations from one overload to another, and in those cases it\u0027s perfectly fine to pass a pre-built handler.",
                                           "updatedAt":  "2022-05-13T17:27:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DJtLG",
                                           "createdAt":  "2022-05-13T18:58:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "Hm, that\u0027s true. I hadn\u0027t thought of that. Just to make sure, you\u0027re talking about something like this, right?\r\n\r\n```c#\r\npublic static String Create(\r\n    IFormatProvider? provider,\r\n    [InterpolatedStringHandlerArgument(\"provider\")] ref DefaultInterpolatedStringHandler handler)\r\n{\r\n    return Create(provider, ref handler, \"defaultFoo\");\r\n}\r\n\r\npublic static String Create(\r\n    IFormatProvider? provider,\r\n    [InterpolatedStringHandlerArgument(\"provider\")] ref DefaultInterpolatedStringHandler handler,\r\n    string foo)\r\n{\r\n    // ...\r\n}\r\n```\r\n\r\nI guess an  analyzer would be more appropriate then. An analyzer could detect this case - if I\u0027m providing a pre-built handler, but the pre-built handler is from a method parameter that also has the `InterpolatedStringHandlerArgument` attribute , and the argument I\u0027m passing in (in this case, `provider`) also comes from the corresponding parameter, the analyzer wouldn\u0027t issue a warning. If this is going to be an analyzer, maybe having it in dotnet/runtime as a built-in .NET analyzer would actually be appropriate.\r\n\r\nThe compiler could of course detect this too, but this seems like arbitrary analysis that the compiler would have to do and more importantly, it seems like this is just a heuristic, or a (reasonable) guess as to which usage would be OK, so not really appropriate for the compiler.",
                                           "updatedAt":  "2022-05-13T19:14:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DJtLH",
                                           "createdAt":  "2022-05-13T21:45:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "333fred",
                                           "body":  "Yep, that\u0027s exactly what I was thinking of.",
                                           "updatedAt":  "2022-05-13T21:45:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DJtLI",
                                           "createdAt":  "2022-05-13T22:18:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CyrusNajmabadi",
                                           "body":  "Transferring to roslyn-analyzers.",
                                           "updatedAt":  "2022-05-13T22:18:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DJtLJ",
                                           "createdAt":  "2022-05-14T02:37:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mavasani",
                                           "body":  ".NET API usage analyzer suggestions are triaged by the runtime team, transferring.",
                                           "updatedAt":  "2022-05-14T02:37:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DKIvi",
                                           "createdAt":  "2022-05-14T14:52:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Neme12",
                                           "body":  "@mavasani This also relates to a language feature, though, so it\u0027s not that clear-cut as to whether it should be part of .NET or roslyn-analyzers. You could declare `InterpolatedStringHandlerArgumentAttribute` in your own code as well and it should have the same behavior, it doesn\u0027t have to come from .NET. The shape and effect of the attribute is defined by the compiler.\r\n\r\nEDIT: Oh, I didn\u0027t know that the analyzers shipped with .NET actually *are* those from the roslyn-analyzers repo.",
                                           "updatedAt":  "2022-05-14T15:02:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DKJCK",
                                           "createdAt":  "2022-05-14T15:00:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCc2h2A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Neme12",
                                                                               "createdAt":  "2022-05-14T19:05:01Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "mavasani",
                                           "body":  "Thanks @Neme12. We still prefer to start with a triage from runtime team. It can be moved back to analyzers repo if the triage team feels that would be more appropriate.",
                                           "updatedAt":  "2022-05-14T15:00:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DKbMG",
                                           "createdAt":  "2022-05-14T20:27:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime-compilerservices\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nWith the new pattern for interpolated strings in C# 10, the canonical way to get the string formatted with invariant culture is to do this:\r\n```c#\r\nvar str = string.Create(CultureInfo.InvariantCulture, $\"hello {1.5}\");\r\n```\r\n\r\nI wanted to write a helper method that would shorten this a bit and let me do this without having to specify the `CultureInfo` every time, because invariant culture is by far the most common and the only one I\u0027ve ever needed to do this with. I wrote a method like this:\r\n```c#\r\nstring Invariant(ref DefaultInterpolatedStringHandler handler)\r\n{\r\n    return string.Create(CultureInfo.InvariantCulture, ref handler);\r\n}\r\n\r\n// usage:\r\nvar str = Invariant($\"hello {1.5}\");\r\n```\r\nWhen I used this method, at first I was confused why it wasn\u0027t working - the string was still formatted with `CurrentCulture`, not `InvariantCulture`. Then I realized - when the method receives a `DefaultInterpolatedStringHandler`, the string is already built by the compiler with current culture. so `string.Create(CultureInfo.InvariantCulture, ref handler)` will have no effect on changing the culture - the culture has to be passed in to the constructor of `DefaultInterpolatedStringHandler`, which the compiler does based on `InterpolatedStringHandlerArgumentAttribute` in the `string.Create` method parameter.  To make this work without having to have the culture as a parameter to the method, I actually had to create a custom interpolated string handler type that wraps a `DefaultInterpolatedStringHandler` and provides the desired culture in the constructor.\r\n\r\nThis is something that\u0027s easy to miss and it\u0027s easy to assume that the method I wrote would just work. I propose that compiler issues a warning when calling a method that has an interpolated string handler parameter with the `InterpolatedStringHandlerArgumentAttribute`, and I\u0027m passing in an existing variable (a fully constructed handler) as opposed to an interpolated string literal, because the compiler knows that the attribute will have no effect. I first thought about making this suggestion in dotnet/runtime as a built-in analyzer, but this is really a language feature - the compiler provides the argument to the constructor of the handler so it makes sense to me that the compiler would issue a warning here when it cannot do that.\r\n\r\n```c#\r\nstring Invariant(ref DefaultInterpolatedStringHandler handler)\r\n{\r\n    return string.Create(CultureInfo.InvariantCulture, ref handler);\r\n                                                       ~~~~~~~~~~~\r\n}\r\n```\r\nIn the example above, the highlighted text span should show a warning that `InterpolatedStringHandlerArgument` will have no effect as the argument can\u0027t be provided because the handler is already constructed.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eNeme12\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.CompilerServices`, `untriaged`, `code-analyzer`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-05-14T20:27:29Z"
                                       }
                                   ],
                         "totalCount":  12
                     },
        "title":  "Warn when `InterpolatedStringHandlerArgumentAttribute` would have no effect",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.CompilerServices",
                       "code-analyzer"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/71828",
        "createdAt":  "2022-07-08T11:40:29Z",
        "number":  71828,
        "author":  "pentp",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-07-11T20:59:41Z",
        "body":  "### Background and motivation\n\nNullable\u003cT\u003e arguments for interpolated strings are very inefficient currently because they get boxed and then dynamically checked for `IFormattable`/`ISpanFormattable` (and use interface calls).\r\nCodegen example: https://godbolt.org/z/eGhYTxnYc\r\nThis is a \"pit of failure\" that\u0027s not immediately clear to users.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Runtime.CompilerServices;\r\n\r\npublic ref struct DefaultInterpolatedStringHandler\r\n{\r\n    public void AppendFormatted\u003cT\u003e(T? value) where T : struct;\r\n    public void AppendFormatted\u003cT\u003e(T? value, string? format) where T : struct;\r\n    public void AppendFormatted\u003cT\u003e(T? value, int alignment) where T : struct;\r\n    public void AppendFormatted\u003cT\u003e(T? value, int alignment, string? format) where T : struct;\r\n}\r\n\r\n// same for System.Text.StringBuilder.AppendInterpolatedStringHandler\r\n// same for System.MemoryExtensions.TryWriteInterpolatedStringHandler\r\n```\r\n\n\n### API Usage\n\n```csharp\r\npublic static class C {\r\n    public static string M(int? i) =\u003e $\"Some optional value: {i}\";\r\n}\r\n```\r\n\n\n### Alternative Designs\n\nImprove the JIT to remove all this boxing/indirection: #50915\n\n### Risks\n\nAPI size increase. Does not help already compiled code.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHORluyNw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5GRGkp",
                                           "createdAt":  "2022-07-08T11:40:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-07-08T11:40:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GRHyl",
                                           "createdAt":  "2022-07-08T11:45:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pentp",
                                           "body":  "There\u0027s some discussion about the tradeoffs in `DefaultInterpolatedStringHandler.AppendFormatted`, but the overhead of these API-s could be really minimal:\r\n```c#\r\npublic void AppendFormatted\u003cT\u003e(T? value) where T : struct\r\n{\r\n    if (value != null) AppendFormatted(value.GetValueOrDefault());\r\n    else if (_hasCustomFormatter) AppendCustomFormatterNull(format: null);\r\n    // effectively: else if (_hasCustomFormatter) AppendCustomFormatter((object)null, format: null);\r\n}\r\n```",
                                           "updatedAt":  "2022-07-10T16:17:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GRkJf",
                                           "createdAt":  "2022-07-08T13:47:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "I\u0027d like to avoid adding such new overloads for this.  It was considered in depth, we had multiple debates about it when this was first being designed, with https://github.com/dotnet/runtime/issues/50915 being filed to track the required JIT work (some of which was addressed, some of which remains).  A summary of the decisions that led to the selected set of overloads is at https://github.com/dotnet/runtime/blob/f00c4cb4e633af94d526fdb90b4a3b84ce4928cd/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/DefaultInterpolatedStringHandler.cs#L207-L279",
                                           "updatedAt":  "2022-07-08T13:51:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GSIXp",
                                           "createdAt":  "2022-07-08T16:12:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime-compilerservices\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nNullable\u003cT\u003e arguments for interpolated strings are very inefficient currently because they get boxed and then dynamically checked for `IFormattable`/`ISpanFormattable` (and use interface calls).\r\nCodegen example: https://godbolt.org/z/eGhYTxnYc\r\nThis is a \"pit of failure\" that\u0027s not immediately clear to users.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Runtime.CompilerServices;\r\n\r\npublic ref struct DefaultInterpolatedStringHandler\r\n{\r\n    public void AppendFormatted\u003cT\u003e(T? value) where T : struct;\r\n    public void AppendFormatted\u003cT\u003e(T? value, string? format) where T : struct;\r\n    public void AppendFormatted\u003cT\u003e(T? value, int alignment) where T : struct;\r\n    public void AppendFormatted\u003cT\u003e(T? value, int alignment, string? format) where T : struct;\r\n}\r\n\r\n// same for System.Text.StringBuilder.AppendInterpolatedStringHandler\r\n// same for System.MemoryExtensions.TryWriteInterpolatedStringHandler\r\n```\r\n\n\n### API Usage\n\n```csharp\r\npublic static class C {\r\n    public static string M(int? i) =\u003e $\"Some optional value: {i}\";\r\n}\r\n```\r\n\n\n### Alternative Designs\n\nImprove the JIT to remove all this boxing/indirection: #50915\n\n### Risks\n\nAPI size increase. Does not help already compiled code.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003epentp\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Runtime.CompilerServices`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-07-08T16:12:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GUZDI",
                                           "createdAt":  "2022-07-10T15:38:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pentp",
                                           "body":  "I read the discussion, but I would say that even with the JIT improved to perfectly handle these functions, it might still be better to have `Nullable\u003cT\u003e` overloads because the null check is very likely to be inlined which can enable significant function call overhead reductions (for both null and non-null case).\r\nAnd this could ship for .NET 7 (the JIT improvement is already postponed to 8.0)",
                                           "updatedAt":  "2022-07-10T16:18:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GW5TW",
                                           "createdAt":  "2022-07-11T13:25:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pentp",
                                           "body":  "Additionally, for strings like `$\"Sometext {(condition ? 42 : null)}\"` the compiler selects `AppendFormatted(object? value, int alignment = 0, string? format = null)` as the \"best\" overload and thus the value is boxed already at the callsite and JIT improvements won\u0027t help here.",
                                           "updatedAt":  "2022-07-11T13:25:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GW7I3",
                                           "createdAt":  "2022-07-11T13:31:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e it might still be better\r\n\r\nMaybe.  Maybe not.  I\u0027d rather let the JIT do what it can, help all such uses of nullables, and then if there\u0027s still an important gap, look at addressing it.  From what I\u0027ve seen, though, such use is a minority use case, and once the main costs are addressed by the JIT, fairly negligible and not worth additional surface area.\r\n\r\n\u003e And this could ship for .NET 7\r\n\r\nNot at this point, no.  Other than for really important cases, we\u0027re done adding new runtime APIs for .NET 7 tomorrow.\r\n\r\n\u003e condition ? 42 : null\r\n\u003e  the compiler selects\r\n\r\nThat\u0027d be the case even if there was a nullable overload:\r\nhttps://sharplab.io/#v2:EYLgtghglgdgNAFxFANgHwAICYCMBYAKAwGYACbUgYVIG9DSHyyMAWKiFFACmAHteUpAMa8YAEygIoogJSkAvAD5SAWS4jxk6TFIB+UiyykQpGAFdOMgNz1GJcmxUAeACqKuL/QDcOZgKZyAO4AFn4ATn6kLsakAM4IYWZCCLQAvrYM9qyqXLzAAFZ+yaQ+KP5yNKTpBKlAA",
                                           "updatedAt":  "2022-07-11T13:34:32Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "[API Proposal]: Nullable\u003cT\u003e special casing for interpolated string handlers",
        "labels":  [
                       "api-needs-work",
                       "api-suggestion",
                       "area-System.Runtime.CompilerServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/72337",
        "createdAt":  "2022-07-17T11:53:02Z",
        "number":  72337,
        "author":  "teo-tsirpanis",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-08-03T17:22:02Z",
        "body":  "### Background and motivation\n\nI maintain a library that provides an idiomatic API for both C# and F#. For example if a method accepts a delegate, it will have an overload that accepts an equivalent F# `FSharpFunc` object. However both methods are visible in IntelliSense regardless of the language. It would be nice if the `FSharpFunc` overload was visible only in F# projects and the delegate overload was visible to projects of all languages except F#. I propose an attribute to allow that.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Runtime.CompilerServices;\r\n\r\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Constructor |\r\nSystem.AttributeTargets.Delegate | System.AttributeTargets.Enum | System.AttributeTargets.Event |\r\nSystem.AttributeTargets.Field | System.AttributeTargets.Interface | System.AttributeTargets.Method |\r\nSystem.AttributeTargets.Property | System.AttributeTargets.Struct, AllowMultiple = true)]\r\npublic class LanguageVisibleAttribute : Attribute\r\n{\r\n    public string Language { get; } // \"C#\", \"F#\" or \"VB\"\r\n    public bool IsVisible { get; }\r\n    public LanguageVisibleAttribute(string language, bool isVisible);\r\n}\r\n```\r\n\r\nThis attribute will override `EditorBrowsableAttribute` for a project if `Language` is the same with the project\u0027s language. To make a symbol visible in exclusively a set of languages, users have to also apply `[EditorBrowsable(EditorBrowsableState.Never)]` to hide it from the other languages.\n\n### API Usage\n\n```csharp\r\npublic class MyClass\r\n{\r\n    // This attribute controls the name the symbol will be available in F#.\r\n    // The most sensible method for each language will have the shortest name.\r\n    [Microsoft.FSharp.Core.CompilationSourceName(\"GetValueOrNull\")]\r\n    public object? GetValue();\r\n    [Microsoft.FSharp.Core.CompilationSourceName(\"GetValue\")]\r\n    [EditorBrowsable(EditorBrowsableState.Never), LanguageVisible(\"F#\", true)] // Make it visible only in F#.\r\n    public FSharpValueOption\u003cobject\u003e FSharpGetValue();\r\n\r\n    // Hide it only from F#. A delegate will make sense in any other language.\r\n    [LanguageVisible(\"F#\", false)]\r\n    public void MyMethod(Func\u003cint, int, int\u003e f);\r\n    [EditorBrowsable(EditorBrowsableState.Never), LanguageVisible(\"F#\", true)]\r\n    public void MyMethod(FSharpFunc\u003cint, FSharpFunc\u003cint, int\u003e\u003e f);\r\n}\r\n```\n\n### Alternative Designs\n\n* Extending `EditorBrowsableAttribute` with a `Language` property and allowing it to be applied multiple times is not a good idea for two reasons. First, existing tools will be confused if they see this attribute more than once, and second I would like this attribute to be specified in source and matched by name, to enable using it in earlier frameworks.\r\n* In my examples I used this attribute to special-case visibility only for F#. Since there are only two major and actively evolved languages in .NET, perhaps this attribute should be something F#-specific and maintained by the F# team, but a general solution seems better.\r\n* `VB` could be renamed to `Visual Basic`. The former is recognized by `dotnet new`, and the latter is used by Roslyn\u0027s `LanguageNames`.\n\n### Risks\n\n* There might be some confusion of the recognized values of the language string. Users that didn\u0027t read the documentation might apply `[LanguageVisible(\"FSharp\", true)]` and they would not immediately realize they made a mistake.\r\n* Should we hide all symbols that are not supported in Visual Basic? I wouldn\u0027t say so, features like `ref struct`s are fundamentally not supported in Visual Basic and the IDEs can mechanically find and hide them if they desire. `FSharpFunc` on the other hand is a regular class that could be used from C#; it just feels weird and the experience is not good.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHORrh6pQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5GuHpi",
                                           "createdAt":  "2022-07-17T11:53:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-07-17T11:53:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GuHql",
                                           "createdAt":  "2022-07-17T11:53:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime-compilerservices\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nI maintain a library that provides an idiomatic API for both C# and F#. For example if a method accepts a delegate, it will have an overload that accepts an equivalent F# `FSharpFunc` object. However both methods are visible in IntelliSense regardless of the language. It would be nice if the `FSharpFunc` overload was visible only in F# projects and the delegate overload was visible to projects of all languages except F#. I propose an attribute to allow that.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Runtime.CompilerServices;\r\n\r\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Constructor |\r\nSystem.AttributeTargets.Delegate | System.AttributeTargets.Enum | System.AttributeTargets.Event |\r\nSystem.AttributeTargets.Field | System.AttributeTargets.Interface | System.AttributeTargets.Method |\r\nSystem.AttributeTargets.Property | System.AttributeTargets.Struct, AllowMultiple = true)]\r\npublic class LanguageVisibleAttribute : Attribute\r\n{\r\n    public string Language { get; } // \"C#\", \"F#\" or \"VB\"\r\n    public bool IsVisible { get; }\r\n    public LanguageVisibleAttribute(string language, bool isVisible);\r\n}\r\n```\r\n\r\nThis attribute will override `EditorBrowsableAttribute` for a project if `Language` is the same with the project\u0027s language. To make a symbol visible in exclusively a set of languages, users have to also apply `[EditorBrowsable(EditorBrowsableState.Never)]` to hide it from the other languages.\n\n### API Usage\n\n```csharp\r\npublic class MyClass\r\n{\r\n    // This attribute controls the name the symbol will be available in F#.\r\n    // The most sensible method for each language will have the shortest name.\r\n    [Microsoft.FSharp.Core.CompilationSourceName(\"GetValueOrNull\")]\r\n    public object? GetValue();\r\n    [Microsoft.FSharp.Core.CompilationSourceName(\"GetValue\")]\r\n    [EditorBrowsable(EditorBrowsableState.Never), LanguageVisible(\"F#\", true)] // Make it visible only in F#.\r\n    public FSharpValueOption\u003cobject\u003e FSharpGetValue();\r\n\r\n    // Hide it only from F#. A delegate will make sense in any other language.\r\n    [LanguageVisible(\"F#\", false)]\r\n    public void MyMethod(Func\u003cint, int, int\u003e f);\r\n    [EditorBrowsable(EditorBrowsableState.Never), LanguageVisible(\"F#\", true)]\r\n    public void MyMethod(FSharpFunc\u003cint, FSharpFunc\u003cint, int\u003e\u003e f);\r\n}\r\n```\n\n### Alternative Designs\n\n* Extending `EditorBrowsableAttribute` with a `Language` property and allowing it to be applied multiple times is not a good idea for two reasons. First, existing tools will be confused if they see this attribute more than once, and second I would like this attribute to be specified in source and matched by name, to enable using it in earlier frameworks.\r\n* In my examples I used this attribute to special-case visibility only for F#. Since there are only two major and actively evolved languages in .NET, perhaps this attribute should be something F#-specific and maintained by the F# team, but a general solution seems better.\r\n* `VB` could be renamed to `Visual Basic`. The former is recognized by `dotnet new`, and the latter is used by Roslyn\u0027s `LanguageNames`.\n\n### Risks\n\n* There might be some confusion of the recognized values of the language string. Users that didn\u0027t read the documentation might apply `[LanguageVisible(\"FSharp\", true)]` and they would not immediately realize they made a mistake.\r\n* Should we hide all symbols that are not supported in Visual Basic? I wouldn\u0027t say so, features like `ref struct`s are fundamentally not supported in Visual Basic and the IDEs can mechanically find and hide them if they desire. `FSharpFunc` on the other hand is a regular class that could be used from C#; it just feels weird and the experience is not good.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eteo-tsirpanis\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Runtime.CompilerServices`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-07-17T11:53:21Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[API Proposal]: Customize editor visibility of a symbol based on the language.",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.CompilerServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/79204",
        "createdAt":  "2022-12-05T00:04:44Z",
        "number":  79204,
        "author":  "MichalStrehovsky",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-03-25T16:59:52Z",
        "body":  ".NET Native had size optimizations in the structuring of the BCL code to avoid unnecessary generic expansions in the async infrastructure.\r\n\r\nWe lost these when CoreLibs between the projects were unified. We restored some of it (example: https://github.com/dotnet/corert/pull/6913), but there is likely more that we could do. We could study the old optimizations in the history of the CoreRT repo, or do a new investigation. Not sure how much async changed between then and now.\r\n\r\n@eerhardt saw that in a sample 20 MB app using npgsql package, 3 MB of stuff come from the CompilerServices namespace and that feels still a bit excessive.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOpAdXTA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5PqkQp",
                                           "createdAt":  "2022-12-05T00:04:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime-compilerservices\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n.NET Native had size optimizations in the structuring of the BCL code to avoid unnecessary generic expansions in the async infrastructure.\r\n\r\nWe lost these when CoreLibs between the projects were unified. We restored some of it (example: https://github.com/dotnet/corert/pull/6913), but there is likely more that we could do. We could study the old optimizations in the history of the CoreRT repo, or do a new investigation. Not sure how much async changed between then and now.\r\n\r\n@eerhardt saw that in a sample 20 MB app using npgsql package, 3 MB of stuff come from the CompilerServices namespace and that feels still a bit excessive.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eMichalStrehovsky\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.CompilerServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e8.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-12-05T00:04:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Pr-j7",
                                           "createdAt":  "2022-12-05T08:13:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "Would an API like a `RuntimeFeature.IsSizeOptimized` property help? Then we could do this:\r\n\r\n```csharp\r\nif (!RuntimeFeature.IsDynamicCodeCompiled \u0026\u0026 RuntimeFeature.IsSizeOptimized)\r\n{\r\n    // Use the common interface as generic parameter.\r\n}\r\nelse\r\n{\r\n    // Use the struct as generic parameter.\r\n}\r\n```",
                                           "updatedAt":  "2022-12-05T08:13:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PsSa5",
                                           "createdAt":  "2022-12-05T09:18:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "\u003e Would an API like a `RuntimeFeature.IsSizeOptimized` property help? Then we could do this:\r\n\u003e \r\n\u003e ```cs\r\n\u003e if (!RuntimeFeature.IsDynamicCodeCompiled \u0026\u0026 RuntimeFeature.IsSizeOptimized)\r\n\u003e {\r\n\u003e     // Use the common interface as generic parameter.\r\n\u003e }\r\n\u003e else\r\n\u003e {\r\n\u003e     // Use the struct as generic parameter.\r\n\u003e }\r\n\u003e ```\r\n\r\nI don\u0027t know if any of the optimizations .NET Native had meaningfully affected throughput and would have to be guarded. https://github.com/dotnet/corert/pull/6913 is not something that would really need to be guarded. It helps everywhere (less jitting, less working set).",
                                           "updatedAt":  "2022-12-05T09:18:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PueKX",
                                           "createdAt":  "2022-12-05T15:32:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCw3nYg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "MichalStrehovsky",
                                                                               "createdAt":  "2022-12-06T00:42:22Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "filipnavara",
                                                                               "createdAt":  "2022-12-07T17:51:47Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "eerhardt",
                                           "body":  "Here\u0027s the [MstatDumper](https://gist.github.com/MichalStrehovsky/2c7cb3d623c7f8901541914dab04238d) dump of the npgsql app, in case anyone is interested in the full output.\r\n\r\n[npgsql-aot-size.txt](https://github.com/dotnet/runtime/files/10155474/npgsql-aot-size.txt)\r\n\r\nAnd tweaking that code to just dump what is in the `System.Runtime.CompilerServices` namespace produces:\r\n\r\n[System.Runtime.CompilerServices.txt](https://github.com/dotnet/runtime/files/10155521/System.Runtime.CompilerServices.txt)\r\n",
                                           "updatedAt":  "2022-12-05T15:32:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6j9bWS",
                                           "createdAt":  "2025-03-25T10:25:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "For people internal to Microsoft, there\u0027s bug https://devdiv.visualstudio.com/DevDiv/_workitems/edit/767020 that was filed at the time we picked up the regression from .NET Native times.\n\nThe bug includes logs and a diff for an app exactly at the time of the regression that should make it more easy to zoom in on things that were added/removed and are costing us. The logs are sensitive, can\u0027t post them here. But the regression was from 81,476,061 bytes to 91,252,813 bytes, so quite significant. The bug further claims that https://github.com/dotnet/corert/pull/6913 was able to recover 20% of the regression.",
                                           "updatedAt":  "2025-03-25T10:25:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6kAktC",
                                           "createdAt":  "2025-03-25T15:14:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "We may want to wait for [runtime async](https://github.com/dotnet/runtime/issues/109632) with this one.",
                                           "updatedAt":  "2025-03-25T15:15:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6kB1dM",
                                           "createdAt":  "2025-03-25T16:59:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOELZK4Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "shmuelie",
                                                                               "createdAt":  "2025-03-25T17:56:52Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Sergio0694",
                                           "body":  "Random: I just noticed those logs are from my [OneLocker](https://apps.microsoft.com/detail/9NBLGGH3T7G3) app, the (UWP) world really is small 😆",
                                           "updatedAt":  "2025-03-25T16:59:51Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "[NativeAOT] Investigate AOT size savings opportunities around async",
        "labels":  [
                       "area-System.Runtime.CompilerServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/84333",
        "createdAt":  "2023-04-05T00:16:17Z",
        "number":  84333,
        "author":  "MichalPetryka",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC6pH3Q==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "thatbakamono",
                                            "createdAt":  "2023-04-05T00:32:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Enderlook",
                                            "createdAt":  "2023-05-23T00:15:36Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MineCake147E",
                                            "createdAt":  "2023-12-13T03:33:51Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-05-29T18:10:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hendriklhf",
                                            "createdAt":  "2024-08-30T10:44:07Z"
                                        }
                                    ],
                          "totalCount":  5
                      },
        "updatedAt":  "2024-07-19T16:35:06Z",
        "body":  "### Background and motivation\n\nHaving methods that always perform expensive operations like for example growing methods in growable collections is common in high performance code like the BCL. It\u0027d be useful to be able to mark those with a flag being the reverse of `AggressiveInlining` which would tell the JIT to always treat blocks that end up with a call to it as cold, heavily pessimize inlining it unless a method always ends up calling it and prefer hoisting branches with it to the end of the generated codegen, similar to what Throw Helpers currently do.\r\n\r\nI\u0027ve thought about this while working on #82146 and noticing the JIT placing the call to Grow which is expected to be rare and expensive above a singular mov which is expected to happen in 90% of cases.\r\n\r\nI\u0027m not really sure what the exact name of the flag should be, my ideas include: Cold, Unlikely, Rare, Expensive.\r\n\r\ncc @tannergooding @EgorBo @AndyAyersMS \n\n### API Proposal\n\n```csharp\r\nnamespace System.Runtime.CompilerServices;\r\n\r\npublic enum MethodImplOptions\r\n{\r\n    Cold = 1024\r\n}\r\n```\r\n\n\n### API Usage\n\nThere are quite a few places in the BCL that have \"always cold\" methods that should be marked with it, for example List.Grow that always ends up allocating a new array and copying data to it:\r\nhttps://github.com/dotnet/runtime/blob/e13f0dc1e0327b5d0cd0602b55ee257ef554f0a1/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/List.cs#L447-L455\n\n### Alternative Designs\n\nAlternative designs include relying on PGO to detect such methods, which is less reliable, slows down startup and isn\u0027t as AOT friendly, or using more flexible method intrinsics from #4966 that are however harder to implement and require the library user, not author to mark the code with those.\n\n### Risks\n\nPartial overlap with Assume intrinsics and PGO, more work for the JIT to do.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOWUK18A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5ZNrW7",
                                           "createdAt":  "2023-04-05T00:16:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @JulieLeeMSFT, @jakobbotsch, @kunalspathak\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nHaving methods that always perform expensive operations like for example growing methods in growable collections is common in high performance code like the BCL. It\u0027d be useful to be able to mark those with a flag being the reverse of `AggressiveInlining` which would tell the JIT to always treat blocks that end up with a call to it as cold, heavily pessimize inlining it unless a method always ends up calling it and prefer hoisting branches with it to the end of the generated codegen, similar to what Throw Helpers currently do.\r\n\r\nI\u0027ve thought about this while working on #82146 and noticing the JIT placing the call to Grow which is expected to be rare and expensive above a singular mov which is expected to happen in 90% of cases.\r\n\r\nI\u0027m not really sure what the exact name of the flag should be, my ideas include: Cold, Unlikely, Rare, Expensive.\r\n\r\ncc @tannergooding @EgorBo @AndyAyersMS \n\n### API Proposal\n\n```csharp\r\nnamespace System.Runtime.CompilerServices;\r\n\r\npublic enum MethodImplOptions\r\n{\r\n    Cold = 1024\r\n}\r\n```\r\n\n\n### API Usage\n\nThere are quite a few places in the BCL that have \"always cold\" methods that should be marked with it, for example List.Grow that always ends up allocating a new array and copying data to it:\r\nhttps://github.com/dotnet/runtime/blob/e13f0dc1e0327b5d0cd0602b55ee257ef554f0a1/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/List.cs#L447-L455\n\n### Alternative Designs\n\nAlternative designs include relying on PGO to detect such methods, which is less reliable, slows down startup and isn\u0027t as AOT friendly, or using more flexible method intrinsics from #4966 that are however harder to implement and require the library user, not author to mark the code with those.\n\n### Risks\n\nPartial overlap with Assume intrinsics and PGO, more work for the JIT to do.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eMichalPetryka\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-CodeGen-coreclr`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-04-05T00:16:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZNroD",
                                           "createdAt":  "2023-04-05T00:18:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime-compilerservices\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nHaving methods that always perform expensive operations like for example growing methods in growable collections is common in high performance code like the BCL. It\u0027d be useful to be able to mark those with a flag being the reverse of `AggressiveInlining` which would tell the JIT to always treat blocks that end up with a call to it as cold, heavily pessimize inlining it unless a method always ends up calling it and prefer hoisting branches with it to the end of the generated codegen, similar to what Throw Helpers currently do.\r\n\r\nI\u0027ve thought about this while working on #82146 and noticing the JIT placing the call to Grow which is expected to be rare and expensive above a singular mov which is expected to happen in 90% of cases.\r\n\r\nI\u0027m not really sure what the exact name of the flag should be, my ideas include: Cold, Unlikely, Rare, Expensive.\r\n\r\ncc @tannergooding @EgorBo @AndyAyersMS \n\n### API Proposal\n\n```csharp\r\nnamespace System.Runtime.CompilerServices;\r\n\r\npublic enum MethodImplOptions\r\n{\r\n    Cold = 1024\r\n}\r\n```\r\n\n\n### API Usage\n\nThere are quite a few places in the BCL that have \"always cold\" methods that should be marked with it, for example List.Grow that always ends up allocating a new array and copying data to it:\r\nhttps://github.com/dotnet/runtime/blob/e13f0dc1e0327b5d0cd0602b55ee257ef554f0a1/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/List.cs#L447-L455\n\n### Alternative Designs\n\nAlternative designs include relying on PGO to detect such methods, which is less reliable, slows down startup and isn\u0027t as AOT friendly, or using more flexible method intrinsics from #4966 that are however harder to implement and require the library user, not author to mark the code with those.\n\n### Risks\n\nPartial overlap with Assume intrinsics and PGO, more work for the JIT to do.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eMichalPetryka\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Runtime.CompilerServices`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-04-05T00:18:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZNwnt",
                                           "createdAt":  "2023-04-05T00:52:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Alternative designs include relying on PGO to detect such methods, which is less reliable, slows down startup and isn\u0027t as AOT friendly\r\n\r\nAt scale, PGO is going to be more reliable and cheaper than annotating methods manually. Also, PGO is AOT friendly and does not need to slow down the startup when the data is collected statically ahead of time.",
                                           "updatedAt":  "2023-04-05T00:52:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZNx6v",
                                           "createdAt":  "2023-04-05T01:01:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "PGO can also say that a method is profitable to be inlined, yet `AggressiveInlining` is still being used with it. even in runtime code.\r\n\r\nEven if static PGO can be collected for AOT apps, I doubt most apps will do so, afaik most native projects do not rely on PGO.",
                                           "updatedAt":  "2023-04-05T01:01:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZNyt5",
                                           "createdAt":  "2023-04-05T01:06:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC5PzOA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2023-04-05T01:06:47Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "\u003e PGO can also say that a method is profitable to be inlined, yet `AggressiveInlining` is still being used with it. even in runtime code.\r\n\u003e \r\n\u003e Even if static PGO can be collected for AOT apps, I doubt most apps will do so, afaik most native projects do not rely on PGO.\r\n\r\nFrom my understanding your attribute should just sligtly improve code layout by moving `call method` to a cold section while `AggressiveInlining` can be a perf game changer. In an ideal world we won\u0027t need it too (someday).",
                                           "updatedAt":  "2023-04-05T01:06:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZN1yU",
                                           "createdAt":  "2023-04-05T01:28:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AndyAyersMS",
                                           "body":  "\u003e I\u0027ve thought about this while working on #82146 and noticing the JIT placing the call to Grow which is expected to be rare and expensive above a singular mov which is expected to happen in 90% of cases.\r\n\r\nAs I mentioned offline, if you merge something like this into the BCL, wait a few days for our profiling process to update the data that feeds into `StandardOptimization.mibc` and then take a fresh look at the codegen, it\u0027s quite likely our PGO process will have noticed calls to this method are cold.\r\n\r\nSee eg https://github.com/dotnet/runtime/issues/49520#issuecomment-803169970 where we had similar discussions.\r\n\r\nThis process should work equally well for the library code shared by Native AOT, though I am not sure if the profile data gets fed into that toolchain currently.\r\n\r\nTo see similar effects directly during BCL development you can run a suitable benchmark with TieredPGO enabled and inspect the Tier1 codegen.",
                                           "updatedAt":  "2023-04-05T01:28:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZOCpg",
                                           "createdAt":  "2023-04-05T02:58:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "\u003e From my understanding your attribute should just sligtly improve code layout by moving `call method` to a cold section while `AggressiveInlining` can be a perf game changer. In an ideal world we won\u0027t need it too (someday).\r\n\r\nYou could say the same about throw helpers, reordering them manually is always an option, yet the JIT handles them as cold separately.",
                                           "updatedAt":  "2023-04-05T02:58:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZOFdB",
                                           "createdAt":  "2023-04-05T03:15:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e At scale, PGO is going to be more reliable and cheaper than annotating methods manually. Also, PGO is AOT friendly and does not need to slow down the startup when the data is collected statically ahead of time.\r\n\r\nWhile I agree PGO should be the main choice for most scenarios, there are always going to be scenarios where it is not applicable or where ensuring it gets the \"right\" data is significant effort. Static PGO is entirely dependent on the workloads you process as part of collection. Additionally, while we may someday achieve better parity with the extended optimizations native compilers may provide, I find it extremely unlikely that we will surpass them such that developer provided hints are truly unnecessary.\r\n\r\n------------\r\n\r\n.NET has multiple scenarios to consider, including both JIT and AOT, as well as a range of platforms (Windows, MacOS, Linux, Android, iOS, etc). Not all of our features (such as Dynamic PGO) are available everywhere, nor do we ourselves use some of our functionality everywhere (e.g. Static PGO is still off for MacOS by default, as far as I recall).\r\n\r\nNative compilers, despite having significantly more time to spend doing intraprocedural analysis and optimizations in general still provide multiple types of these \"guided optimizations\". That is, they provide both a type of static PGO and a type of code hints provided via attributes, custom pragma/keywords, or more recently official language features covering features that have long existed across multiple supporting compilers implementations.\r\n\r\nWhile most native code bases do not use these features, perf sensitive code bases and hot paths still do. Some much more extensively than others, particularly where the perf is extremely sensitive. With the introduction of official language features around these attributes, code bases are more likely to adopt them in the future as well. This has been seen repeatedly over the years with other features that have moved from being compiler specific to official features.\r\n-- Microsoft\u0027s own `mimalloc` is one example that uses such hints extensively and where turning them off has a huge impact on the end benchmarks. For reference, `mimalloc` is a native memory allocator, which is used by `Bing`, `Azure`, `Unreal Engine`, and several other extremely perf sensitive applications.\r\n\r\nAllowing developers to provide basic hints around \"hot\" (likely) vs \"cold\" (unlikely) is a natural next step for .NET and meshes nicely with the overall directions we\u0027ve been making. The two biggest issues would be:\r\n1. How do we ensure this is \"pay for play\", particularly as the number of free bits for the specially encoded MethodImpl attribute is reduced\r\n2. How does such \"developer provided PGO\" interact with \"static PGO\" and \"dynamic PGO\"\r\n\r\nFor 1, I think the solution is relatively simple as we have existing prior art. We should simply use one of the remaining free bits to indicate that an \"extended attribute\" exists and should be resolved. This works much like how `DllImport` was upgrade to work with `UnmanagedCallConvAttribute`.\r\n\r\nFor 2, I think we just need to make a decision. In general, I would presume that the intent is \"developer hints\" take precedence over \"static PGO\" but that they are less preferred to \"dynamic PGO\". That is `DPGO \u003e HINT \u003e SPGO`. The exception would be if the developer wants to disable Dynamic PGO which is another feature we don\u0027t have a flag for which is likely desirable long term.",
                                           "updatedAt":  "2023-04-05T03:15:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZOJEA",
                                           "createdAt":  "2023-04-05T03:44:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e How do we ensure this is \"pay for play\", particularly as the number of free bits for the specially encoded MethodImpl attribute is reduced\r\n\r\nThe manual likely/unlikely annotations via [method calls](https://github.com/dotnet/runtime/issues/24593#issuecomment-362141283) are more powerful. If we were to do something here, should we start with those? We do not need multiple mechanisms to do the same thing.",
                                           "updatedAt":  "2023-04-05T03:44:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZQWfL",
                                           "createdAt":  "2023-04-05T13:08:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e If we were to do something here, should we start with those?\r\n\r\nI think that would be reasonable and cover the same general need.",
                                           "updatedAt":  "2023-04-05T13:08:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZQb7b",
                                           "createdAt":  "2023-04-05T13:23:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "\u003e The manual likely/unlikely annotations via [method calls](https://github.com/dotnet/runtime/issues/24593#issuecomment-362141283) are more powerful. If we were to do something here, should we start with those? We do not need multiple mechanisms to do the same thing.\r\n\r\nThe thing is that a flag like this is slightly different:\r\n- it\u0027s declared by the callee, not caller, which reduces code polution and allows usage in library code without interaction from the user\r\n- it has a slightly different intent, it doesn\u0027t fully say something is unlikely, it just says that optimizing for this case won\u0027t matter in practice and it\u0027s better to optimize other case\r\n- a flag like this is simpler to specify exactly and implement afaik\r\n- method intrinsics also leave a bit of uncertainty, for example while they say something is unlikely, they don\u0027t really say something is expensive enough for the jit to for example hoist to the end of the method or for example to separate the branch off via hot-cold splitting.",
                                           "updatedAt":  "2023-04-05T13:23:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZQpcI",
                                           "createdAt":  "2023-04-05T13:59:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC5SteQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tannergooding",
                                                                               "createdAt":  "2023-04-05T14:15:06Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e it\u0027s declared by the callee, not caller, which reduces code polution and allows usage in library code without interaction from the user\r\n\r\nThe annotation via a method call can be the very first thing in a method to achieve the same effect.\r\n\r\n\u003e it has a slightly different intent, it doesn\u0027t fully say something is unlikely, it just says that optimizing for this case won\u0027t matter in practice and it\u0027s better to optimize other case\r\n\r\nYes, there are multiple different variants of cold as you have pointed out. Almost never executed (e.g. throw helper), executed typically once (e.g. static constructor or one time initialization), executed relatively less often (your `CollectionsMarshal.SetCount example`). The optimization strategies are different for each of these cases. We want to be able to differentiate between these.\r\n\r\nWe do not want to have flags like this with overloaded meaning. We have overloaded flag like that today (`MethodImplOptions.AggressiveOptimization`) and the overloaded meaning makes it unusable for most practical purposes.\r\n\r\n\u003e a flag like this is simpler to specify exactly and implement afaik\r\n\r\nIt is not that simple once you address the problem with shortage of MethodImplOptions bits that @tannergooding pointed out. ",
                                           "updatedAt":  "2023-04-05T13:59:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZQrXw",
                                           "createdAt":  "2023-04-05T14:03:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e it\u0027s declared by the callee, not caller, which reduces code polution and allows usage in library code without interaction from the user\r\n\r\nYes, this is potentially a useful distinction. However, it can be problematic particularly for public API surface in that often whether something is \"likely\" or \"unlikely\" is per caller. It\u0027s often only truly declarable by the callee in a few cases such as `throw helpers` or internal methods with a single callsite. In both of these cases, `Unsafe.Likely` and `Unsafe.Unlikely` would fill the same general need without much additional maintenance overhead on the user.\r\n\r\n\u003e it doesn\u0027t fully say something is unlikely\r\n\r\nSaying something is cold is saying it is unlikely to be repeatedly executed and therefore typically won\u0027t show up in the flamegraph of a profile. There are indeed different kinds of cold here from \"never expected\" to \"expected once\" to \"expected rarely\" and that may be worth considering.\r\n\r\n\u003emethod intrinsics also leave a bit of uncertainty, for example while they say something is unlikely, they don\u0027t really say something is expensive enough for the jit to for example hoist to the end of the method or for example to separate the branch off via hot-cold splitting.\r\n\r\nThey aren\u0027t that uncertain. They come with whatever semantics/heuristics we want to give them, much as they do in C/C++. Marking a block as `unlikely` (cold) or `likely` (hot), allows it to participate in the exact same things that PGO already does. The method attr would do the same thing, the difference being that `Unsafe.Unlikely` marks the block entrance where-as the metrhod attr would mark the containing block.\r\n\r\nThere are other complications with the method attr as well, such as determining what happens if the block contains more than just one cold call or if we wanted to expand to also allow annotating hot calls, etc.",
                                           "updatedAt":  "2023-04-05T14:03:04Z"
                                       }
                                   ],
                         "totalCount":  13
                     },
        "title":  "[API Proposal]: `MethodImplOptions.Cold` for marking cold methods for the JIT",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.CompilerServices",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/85014",
        "createdAt":  "2023-04-18T22:43:57Z",
        "number":  85014,
        "author":  "MichalPetryka",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC-6cfA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "EgorBo",
                                            "createdAt":  "2023-04-19T00:13:03Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ufcpp",
                                            "createdAt":  "2023-04-19T14:56:34Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "neon-sunset",
                                            "createdAt":  "2023-04-21T02:56:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pentp",
                                            "createdAt":  "2023-10-13T00:22:55Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MineCake147E",
                                            "createdAt":  "2023-12-13T03:28:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-02-28T13:24:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hez2010",
                                            "createdAt":  "2024-04-24T18:50:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hypeartist",
                                            "createdAt":  "2024-04-24T20:14:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2024-05-17T04:10:45Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "raulsntos",
                                            "createdAt":  "2024-06-06T16:27:16Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ackava",
                                            "createdAt":  "2025-02-09T12:11:51Z"
                                        }
                                    ],
                          "totalCount":  11
                      },
        "updatedAt":  "2024-07-19T16:35:07Z",
        "body":  "### Background and motivation\r\n\r\nRoslyn currently caches lambda delegates in static mutable fields in nested classes and initializes them lazily at the use site (guarded by a null check).\r\nThis pattern is inefficient for current runtimes, being hard to detect and optimize correctly, leading to dead code being left in generated assembly and making optimizations like delegate inlining more tricky.\r\nDiscussion [here](https://github.com/dotnet/csharplang/discussions/6746#discussioncomment-5567157) ended up with two possible solutions: creating a runtime intrinsic that\u0027d create and cache the delegate for Roslyn or caching the delegates in `static readonly` fields which CoreCLR and Native AOT can analyze easily even today but that\u0027d come with some metadata cost.\r\n\r\ncc @jkotas @EgorBo @jaredpar @CyrusNajmabadi \r\n\r\n### API Proposal\r\n\r\nFrom @jkotas in https://github.com/dotnet/csharplang/discussions/6746#discussioncomment-5587815:\r\n```csharp\r\npublic class RuntimeHelpers\r\n{\r\n    [Intrinsic]\r\n    // ldftn instruction must immediately precede call of this method. The target method must\r\n    // match the delegate signature and it must be an instance method on the TScope reference. TScope should\r\n    // have no instance fields. Given function pointer can be only mapped to one delegate type using this method.\r\n    static TDelegate GetLambdaSingleton\u003cTScope, TDelegate\u003e(IntPtr ftn) where TScope: class, new(), TDelegate: delegate\r\n    {\r\n        // This is mock implementation. This method is always going to be expanded as JIT intrinsic.\r\n        lock (s_table)\r\n        {\r\n            MethodInfo mi = MapEntryPointToMethodInfo(typeof(TScope), ftn);\r\n\r\n            if (s_table.TryGetValue(mi, out Delegate del))\r\n                return (TDelegate)del;\r\n\r\n            Delegate ret = typeof(TScope).IsCollectible ? \r\n                 InternalCreateDelegate(typeof(TDelegate), new TScope(), ftn) :\r\n                 InternalCreateFrozenDelegate(typeof(TDelegate), new-frozen TScope(), ftn);\r\n            s_table.Add(mi, ret);\r\n            return (TDelegate)ret;\r\n        }\r\n    }\r\n\r\n    static readonly ConditionalWeakTable\u003cMethodInfo, Delegate\u003e s_table;\r\n}\r\n```\r\n\r\n### API Usage\r\n\r\nThis would be used internally by Roslyn when emitting lambdas.\r\n\r\n### Alternative Designs\r\n\r\nHave Roslyn store delegates in `static readonly` fields - would work with CoreCLR and Native AOT, not require any runtime changes, but it\u0027d introduce either more metadata bloat or more eager delegate object allocation (we\u0027d either need a separate nested class per lambda or calling one lambda would then create delegates for all the lambdas in the nested class).\r\n\r\n### Risks\r\n\r\nAll runtimes including Mono would need to have this implemented.\r\n\r\n----\r\n\r\n## Tasks:\r\n- [ ] Refactor delegates to be immutable (see below)\r\n- [ ] Build a functional-enough prototype\r\n- [ ] Submit an API proposal for review, incorporating learnings from the prototype",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOXWkA9w==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5aO-5e",
                                           "createdAt":  "2023-04-18T22:45:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime-compilerservices\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nRoslyn currently caches lambda delegates in static mutable fields in nested classes and initializes them lazily at the use site (guarded by a null check).\r\nThis pattern is inefficient for current runtimes, being hard to detect and optimize correctly, leading to dead code being left in generated assembly and making optimizations like delegate inlining more tricky.\r\nDiscussion [here](https://github.com/dotnet/csharplang/discussions/6746#discussioncomment-5567157) ended up with two possible solutions: creating a runtime intrinsic that\u0027d create and cache the delegate for Roslyn or caching the delegates in `static readonly` fields which CoreCLR and Native AOT can analyze easily even today but that\u0027d come with some metadata cost.\r\n\r\ncc @jkotas @EgorBo @jaredpar @CyrusNajmabadi \n\n### API Proposal\n\nFrom @jkotas in https://github.com/dotnet/csharplang/discussions/6746#discussioncomment-5587815:\r\n```csharp\r\npublic class RuntimeHelpers\r\n{\r\n    [Intrinsic]\r\n    // ldftn instruction must immediately precede call of this method. The target method must\r\n    // match the delegate signature and it must be an instance method on the TScope reference. TScope should\r\n    // have no instance fields. Given function pointer can be only mapped to one delegate type using this method.\r\n    static TDelegate GetLambdaSingleton\u003cTScope, TDelegate\u003e(IntPtr ftn) where TScope: class, TDelegate: delegate\r\n    {\r\n        // This is mock implementation. This method is always going to be expanded as JIT intrinsic.\r\n        lock (s_table)\r\n        {\r\n            MethodInfo mi = MapEntryPointToMethodInfo(typeof(TScope), ftn);\r\n\r\n            if (s_table.TryGetValue(mi, out Delegate del))\r\n                return (TDelegate)del;\r\n\r\n            Delegate ret = typeof(TScope).IsCollectible ? \r\n                 InternalCreateDelegate(typeof(TDelegate), new TScope(), ftn) :\r\n                 InternalCreateFrozenDelegate(typeof(TDelegate), new-frozen TScope(), ftn);\r\n            s_table.Add(mi, ret);\r\n            return (TDelegate)ret;\r\n        }\r\n    }\r\n\r\n    static readonly ConditionalWeakTable\u003cMethodInfo, Delegate\u003e s_table;\r\n}\r\n```\n\n### API Usage\n\nThis would be used internally by Roslyn when emitting lambdas.\n\n### Alternative Designs\n\nHave Roslyn store delegates in `static readonly` fields - would work with CoreCLR and Native AOT, not require any runtime changes, but it\u0027d introduce either more metadata bloat or more eager delegate object allocation (we\u0027d either need a separate nested class per lambda or calling one lambda would then create delegates for all the lambdas in the nested class).\n\n### Risks\n\nAll runtimes including Mono would need to have this implemented.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eMichalPetryka\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Runtime.CompilerServices`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-04-18T22:45:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5aPI4q",
                                           "createdAt":  "2023-04-18T23:46:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jaredpar",
                                           "body":  "\u003e static TDelegate GetLambdaSingleton\u003cTScope, TDelegate\u003e(IntPtr ftn) where TScope: class,\r\n\r\nNeeds to include the `new()` constraint. ",
                                           "updatedAt":  "2023-04-18T23:46:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5aPJms",
                                           "createdAt":  "2023-04-18T23:51:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jaredpar",
                                           "body":  "This will require a bit of refactoring on Roslyn\u0027s part. Today our emit strategy puts all lambdas for a given scope into the same closure type. That means it mixes capturing and non-capturing lambdas. In order to meet the constraints of this API we\u0027ll need to break up our closures such that non-capturing lambdas are never mixed with capturing ones. \r\n\r\nI _think_ this can be done by having a single closure per method for all of our non-capturing lambdas vs. having up to two per scope. Hopefully that is a bit cheaper given our implementation. \r\n",
                                           "updatedAt":  "2023-04-18T23:52:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5aPLC5",
                                           "createdAt":  "2023-04-19T00:01:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "\u003e Have Roslyn store delegates in static readonly fields - would work with CoreCLR and Native AOT, not require any runtime changes\r\n\r\nThe plan is to allocate them on a frozen (nongc) segment which is not supported for `static readonly` in JIT today (but it can be done, just wanted to point out that there will be some runtime(jit) work any way).",
                                           "updatedAt":  "2023-04-19T00:06:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5aPLGq",
                                           "createdAt":  "2023-04-19T00:02:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "\u003e Today our emit strategy puts all lambdas for a given scope into the same closure type.\r\n\r\n[It doesn\u0027t](https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA+ABATARgLABQGAzAATakDCpA3oaQ6fYxjkuSqQCowDOALjgAUASlIBeAHykAYhAhDRE6awCcQgEQALGABtdEDSJEBuZg3Pk2Hbn35YlU2fMVinazQHdougCZHTRiYCIMtWdgxOOQVWLFIAQzB+AEsIADsRSzoQxgBfQlygA), it emits a type for all methods from the type.",
                                           "updatedAt":  "2023-04-19T00:02:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5aTg5m",
                                           "createdAt":  "2023-04-19T16:54:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jaredpar",
                                           "body":  "\u003e [It doesn\u0027t](https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA+ABATARgLABQGAzAATakDCpA3oaQ6fYxjkuSqQCowDOALjgAUASlIBeAHykAYhAhDRE6awCcQgEQALGABtdEDSJEBuZg3Pk2Hbn35YlU2fMVinazQHdougCZHTRiYCIMtWdgxOOQVWLFIAQzB+AEsIADsRSzoQxgBfQlygA), it emits a type for all methods from the type.\r\n\r\nMy bad. It does look like we implemented that optimization already. I thought we had a number of cases where we still combined them with the capturing lambdas but does not appear so. ",
                                           "updatedAt":  "2023-04-19T16:54:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5av4h_",
                                           "createdAt":  "2023-04-25T22:29:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "This should also be used for creation of delegates from method groups.",
                                           "updatedAt":  "2023-04-25T22:29:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5awJhP",
                                           "createdAt":  "2023-04-26T00:15:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "@jkotas @EgorBo While working on #85349, I\u0027ve accidentally made delegate creation be regarded as slightly cheaper for the inliner, which triggers huge diffs for all the lambdas with the mostly dead initialization branch. This means that changing this will also trigger huge diffs due to removal of that branch.",
                                           "updatedAt":  "2023-04-26T00:15:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5dQr-e",
                                           "createdAt":  "2023-05-26T16:43:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "I\u0027ll leave this open for the time being, but until I get the green light from Jan and Jared, this will remain an `api-suggestion`.",
                                           "updatedAt":  "2023-05-26T16:43:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5dSgsV",
                                           "createdAt":  "2023-05-27T01:20:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "In order to be able to allocate delegates as frozen heap, they must be immutable, or more precisely they cannot point to objects that are not allocated on frozen heap.\r\n\r\nThe delegates are not immutable in CoreCLR today. They contain cached MethodInfo that is initialized lazily: https://github.com/dotnet/runtime/blob/b2edecd5b2c521f2a098940efee324460a79057d/src/coreclr/System.Private.CoreLib/src/System/Delegate.CoreCLR.cs#L159-L207 . So the first step is to figure out what to do about this cache. Is it possible to get rid of it and make delegate objects smaller? It should be fine to make Delegate.Method property slower if it makes Delegate objects smaller.",
                                           "updatedAt":  "2023-05-27T01:20:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5dShgU",
                                           "createdAt":  "2023-05-27T01:28:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "Could the cache maybe use `RuntimeMethodHandle.Value` instead? Then the field will just be an IntPtr.",
                                           "updatedAt":  "2023-05-27T01:29:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5dSojG",
                                           "createdAt":  "2023-05-27T02:24:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Could the cache maybe use RuntimeMethodHandle.Value instead? Then the field will just be an IntPtr.\r\n\r\nIf we are not going to store MethodInfo directly in the delegate, there needs to be a lookup or mapping operation involved. If we are going to pay for a mapping or lookup operation, we can as well get rid of the field and use the existing fields or the delegate instance as the key for the lookup (notice that the existing implementation is able to compute the MethodInfo from existing fields). Some options:\r\n\r\n- Cache it using the method pointer as the key. Skip caching for collectible assemblies.\r\n- Cache it in `ConditionalWeakTable` using delegate instance as the key.\r\n- Do not cache it at all. Declare `Delegate.Method` to be a slow operation.\r\n \r\nNone that the field is overloaded for other purposes, but those other purposes do not look that hard to refactor away.",
                                           "updatedAt":  "2023-05-27T02:24:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5daIeT",
                                           "createdAt":  "2023-05-29T13:17:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "\u003e * Cache it in `ConditionalWeakTable` using delegate instance as the key.\r\n\r\nWould the object that keeps the assembly alive for collectible assemblies also be moved there to keep them alive?",
                                           "updatedAt":  "2023-05-29T13:17:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5daNCf",
                                           "createdAt":  "2023-05-29T13:37:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "\u003e \u003e * Cache it in `ConditionalWeakTable` using delegate instance as the key.\r\n\u003e \r\n\u003e Would the object that keeps the assembly alive for collectible assemblies also be moved there to keep them alive?\r\n\r\ndelegates from collectible assemblies won\u0027t be allocated on frozen segments anyway",
                                           "updatedAt":  "2023-05-29T13:37:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5daQD3",
                                           "createdAt":  "2023-05-29T13:49:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Would the object that keeps the assembly alive for collectible assemblies also be moved there to keep them alive?\r\n\r\nIt should be possible to store the object reference that keeps collectible assemblies alive in `_invocationList` field.",
                                           "updatedAt":  "2023-05-29T13:49:23Z"
                                       }
                                   ],
                         "totalCount":  15
                     },
        "title":  "[API Proposal]: Introduce an intrinsic for more efficient lambda generation",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.CompilerServices",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/85980",
        "createdAt":  "2023-05-09T16:06:41Z",
        "number":  85980,
        "author":  "mattleibow",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCv-Iew==",
                          "nodes":  [
                                        {
                                            "content":  "EYES",
                                            "user":  "Sergio0694",
                                            "createdAt":  "2023-05-09T16:59:24Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-08-06T18:09:26Z",
        "body":  "### Description\r\n\r\nI am working on a PR here: https://github.com/dotnet/maui/pull/14846/files and I see a test failure that is an exception inside ConditionalWeakTable. I am semi-sure that my changes don\u0027t have anything to do with it and the test that is failing does not really use anything that I am working on.\r\n\r\nHowever, since this is an exception inside CWT, I think that there may be an issue there at least:\r\n\r\n\u003e  System.NullReferenceException : Object reference not set to an instance of an object.\r\n\u003e  Stack Trace:\r\n\u003e     at System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(TKey key)\r\n\r\nhttps://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/ConditionalWeakTable.cs#L159\r\n\r\nAs far as I can see, the only things in that Remove method that can be null is _container... Bu that should not be null, so this is scary-ish.\r\n\r\n### Reproduction Steps\r\n\r\nThis is the hard part and I am trying to find something.\r\n\r\n### Expected behavior\r\n\r\nNo exception.\r\n\r\n### Actual behavior\r\n\r\nException.\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\n.NET 7.0.201 on macOS. Seems to work fine on Windows.\r\n\r\nOnlyfailing on CI, cannot reproduce this on local Windows/macOS.\r\n\r\n### Other information\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOh2nfnQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5b3LdP",
                                           "createdAt":  "2023-05-10T02:13:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AustinWise",
                                           "body":  "FYI, `_container` [can become null](https://github.com/dotnet/runtime/blob/bc1175382857c4af11c27b3134fd22dc8377dfb5/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/ConditionalWeakTable.cs#L792-L806C35\r\n) if the `ConditionalWeakTable` is resurrected.\r\n\r\nThe full stack trace from the [test failure](https://dev.azure.com/xamarin/public/_build/results?buildId=86284\u0026view=logs\u0026j=a5d1e472-53dd-5464-3837-a52bb42668f7\u0026t=efae1d8c-5207-5631-052d-3d295dfcab19):\r\n\r\n```\r\n  Failed FooBz54334(False) [15 ms]\r\n  Error Message:\r\n   System.NullReferenceException : Object reference not set to an instance of an object.\r\n  Stack Trace:\r\n     at System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(TKey key)\r\n   at Microsoft.Maui.Controls.Setter.UnApply(BindableObject target, Boolean fromStyle) in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/Setter.cs:line 112\r\n   at Microsoft.Maui.Controls.Style.UnApplyCore(BindableObject bindable, Style basedOn) in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/Style.cs:line 167\r\n   at Microsoft.Maui.Controls.Style.Microsoft.Maui.Controls.IStyle.UnApply(BindableObject bindable) in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/Style.cs:line 109\r\n   at Microsoft.Maui.Controls.MergedStyle.SetStyle(IStyle implicitStyle, IList`1 classStyles, IStyle style) in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/MergedStyle.cs:line 187\r\n   at Microsoft.Maui.Controls.MergedStyle.set_ImplicitStyle(IStyle value) in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/MergedStyle.cs:line 93\r\n   at Microsoft.Maui.Controls.MergedStyle.OnImplicitStyleChanged() in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/MergedStyle.cs:line 132\r\n   at Microsoft.Maui.Controls.MergedStyle.\u003cRegisterImplicitStyles\u003eb__30_0(BindableObject bindable, Object oldvalue, Object newvalue) in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/MergedStyle.cs:line 148\r\n   at Microsoft.Maui.Controls.BindableObject.SetValueActual(BindableProperty property, BindablePropertyContext context, Object value, Boolean currentlyApplying, SetValueFlags attributes, Boolean silent) in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/BindableObject.cs:line 537\r\n   at Microsoft.Maui.Controls.BindableObject.SetValueCore(BindableProperty property, Object value, SetValueFlags attributes, SetValuePrivateFlags privateAttributes) in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/BindableObject.cs:line 469\r\n   at Microsoft.Maui.Controls.BindableObject.SetValueCore(BindableProperty property, Object value, SetValueFlags attributes) in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/BindableObject.cs:line 401\r\n   at Microsoft.Maui.Controls.Element.OnResourceChanged(BindableProperty property, Object value) in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/Element.cs:line 745\r\n   at Microsoft.Maui.Controls.Element.OnResourcesChanged(IEnumerable`1 values) in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/Element.cs:line 601\r\n   at Microsoft.Maui.Controls.Element.OnParentResourcesChanged(IEnumerable`1 values) in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/Element.cs:line 553\r\n   at Microsoft.Maui.Controls.VisualElement.OnParentResourcesChanged(IEnumerable`1 values) in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/VisualElement.cs:line 1178\r\n   at Microsoft.Maui.Controls.Element.OnParentResourcesChanged(Object sender, ResourcesChangedEventArgs e) in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/Element.cs:line 548\r\n   at Microsoft.Maui.Controls.Element.OnResourcesChanged(IEnumerable`1 values) in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/Element.cs:line 579\r\n   at Microsoft.Maui.Controls.Element.OnParentResourcesChanged(IEnumerable`1 values) in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/Element.cs:line 553\r\n   at Microsoft.Maui.Controls.VisualElement.OnParentResourcesChanged(IEnumerable`1 values) in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/VisualElement.cs:line 1178\r\n   at Microsoft.Maui.Controls.Element.OnParentResourcesChanged(Object sender, ResourcesChangedEventArgs e) in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/Element.cs:line 548\r\n   at Microsoft.Maui.Controls.Element.OnResourcesChanged(IEnumerable`1 values) in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/Element.cs:line 579\r\n   at Microsoft.Maui.Controls.Element.OnParentResourcesChanged(IEnumerable`1 values) in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/Element.cs:line 553\r\n   at Microsoft.Maui.Controls.VisualElement.OnParentResourcesChanged(IEnumerable`1 values) in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/VisualElement.cs:line 1178\r\n   at Microsoft.Maui.Controls.Element.OnParentResourcesChanged(Object sender, ResourcesChangedEventArgs e) in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/Element.cs:line 548\r\n   at Microsoft.Maui.Controls.Element.OnResourcesChanged(IEnumerable`1 values) in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/Element.cs:line 579\r\n   at Microsoft.Maui.Controls.Element.OnParentResourcesChanged(IEnumerable`1 values) in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/Element.cs:line 553\r\n   at Microsoft.Maui.Controls.Element.OnParentResourcesChanged(Object sender, ResourcesChangedEventArgs e) in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/Element.cs:line 548\r\n   at Microsoft.Maui.Controls.Element.OnResourcesChanged(IEnumerable`1 values) in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/Element.cs:line 579\r\n   at Microsoft.Maui.Controls.Application.set_Resources(ResourceDictionary value) in /Users/builder/azdo/_work/1/s/src/Controls/src/Core/Application.cs:line 149\r\n   at Microsoft.Maui.Controls.Xaml.UnitTests.Bz54334App.ToggleTheme() in /Users/builder/azdo/_work/1/s/src/Controls/tests/Xaml.UnitTests/Issues/Bz54334.xaml.cs:line 32\r\n   at Microsoft.Maui.Controls.Xaml.UnitTests.Bz54334App.\u003c.ctor\u003eb__1_0(Object s, ContentPage m) in /Users/builder/azdo/_work/1/s/src/Controls/tests/Xaml.UnitTests/Issues/Bz54334.xaml.cs:line 26\r\n   at CommunityToolkit.Mvvm.Messaging.Internals.MessageHandlerDispatcher.For`2.Invoke(Object recipient, Object message)\r\n   at CommunityToolkit.Mvvm.Messaging.WeakReferenceMessenger.SendAll[TMessage](ReadOnlySpan`1 pairs, Int32 i, TMessage message)\r\n   at CommunityToolkit.Mvvm.Messaging.WeakReferenceMessenger.Send[TMessage,TToken](TMessage message, TToken token)\r\n   at Microsoft.Maui.Controls.Xaml.UnitTests.Bz54334.Tests.FooBz54334(Boolean useCompiledXaml) in /Users/builder/azdo/_work/1/s/src/Controls/tests/Xaml.UnitTests/Issues/Bz54334.xaml.cs:line 81\r\n   at InvokeStub_Tests.FooBz54334(Object, Object, IntPtr*)\r\n   at System.Reflection.MethodInvoker.Invoke(Object obj, IntPtr* args, BindingFlags invokeAttr)\r\n```\r\n\r\nBoth the [`Setter` class](https://github.com/dotnet/maui/blob/main/src/Controls/src/Core/Setter.cs) and the [`WeakReferenceMessenger` class](https://github.com/CommunityToolkit/dotnet/blob/main/src/CommunityToolkit.Mvvm/Messaging/WeakReferenceMessenger.cs) use `ConditionalWeakTable`. Probably the `Setter` object was finalized along with the `ConditionalWeakTable` it owns.\r\n\r\nHere is a simplified example of dependent handles exposing finalized objects:\r\n\r\n```c#\r\nusing System.Runtime;\r\nusing System.Runtime.CompilerServices;\r\n\r\nclass Program\r\n{\r\n    static void Main()\r\n    {\r\n        while (true)\r\n        {\r\n            var weak = Allocate();\r\n            GC.Collect();\r\n            Observe(weak);\r\n            weak.Dispose();\r\n        }\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions.NoInlining)]\r\n    static DependentHandle Allocate()\r\n    {\r\n        var obj = new MyClass();\r\n        return new DependentHandle(obj, obj);\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions.NoInlining)]\r\n    static void Observe(DependentHandle refcwt)\r\n    {\r\n        var obj = (MyClass?)refcwt.Target;\r\n        if (obj is null)\r\n            return;\r\n        if (obj._isFinialized)\r\n        {\r\n            throw new Exception(\"Found finialized object.\");\r\n        }\r\n    }\r\n}\r\n\r\nclass MyClass\r\n{\r\n    public bool _isFinialized;\r\n    ~MyClass()\r\n    {\r\n        _isFinialized = true;\r\n    }\r\n}\r\n```\r\n\r\nI think this is expected behavior. If the dependent handle did not keep tracking the object after it become finializable, the conditional weak table would not be readable from finalizers. ",
                                           "updatedAt":  "2023-05-10T02:13:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5b7141",
                                           "createdAt":  "2023-05-10T15:31:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime-compilerservices\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\nI am working on a PR here: https://github.com/dotnet/maui/pull/14846/files and I see a test failure that is an exception inside ConditionalWeakTable. I am semi-sure that my changes don\u0027t have anything to do with it and the test that is failing does not really use anything that I am working on.\r\n\r\nHowever, since this is an exception inside CWT, I think that there may be an issue there at least:\r\n\r\n\u003e  System.NullReferenceException : Object reference not set to an instance of an object.\r\n\u003e  Stack Trace:\r\n\u003e     at System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(TKey key)\r\n\r\nhttps://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/ConditionalWeakTable.cs#L159\r\n\r\nAs far as I can see, the only things in that Remove method that can be null is _container... Bu that should not be null, so this is scary-ish.\r\n\r\n### Reproduction Steps\r\n\r\nThis is the hard part and I am trying to find something.\r\n\r\n### Expected behavior\r\n\r\nNo exception.\r\n\r\n### Actual behavior\r\n\r\nException.\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\n.NET 7.0.201 on macOS. Seems to work fine on Windows.\r\n\r\nOnlyfailing on CI, cannot reproduce this on local Windows/macOS.\r\n\r\n### Other information\r\n\r\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003emattleibow\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.CompilerServices`, `untriaged`, `needs-area-label`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-05-10T15:31:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5cHvai",
                                           "createdAt":  "2023-05-12T10:32:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mattleibow",
                                           "body":  "Thanks for the comments - looking closer, I see a whole tree is being collected/finalized. Not sure why yet as these are direct field references.\r\n\r\nWe probably have something somewhere that is using weak references and our `GC.Collect()` happening in parallel for our GC/memory tests are probably causing this to be collected. This feels like it is back on me to find out why :)",
                                           "updatedAt":  "2023-05-12T10:32:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5cHvyD",
                                           "createdAt":  "2023-05-12T10:34:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mattleibow",
                                           "body":  "But, maybe this should transition into a different error message? Not sure if an exception saying \"The ConditionalWeakTable was finalized\" is a better message because a null ref was unexpected.",
                                           "updatedAt":  "2023-05-12T10:34:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5c_fgK",
                                           "createdAt":  "2023-05-23T21:30:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericstj",
                                           "body":  "@mattleibow it sounds like you suspect a problem in maui here?  Did you want to transfer this to the maui repo, or did you want us to use this issue to track adding an exception message to ConditionalWeakTable to throw when it\u0027s accessed after it\u0027s been https://github.com/dotnet/runtime/blob/1e421670a6456d9c5b924b7ffea14cab8559a2e9/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/ConditionalWeakTable.cs#L457",
                                           "updatedAt":  "2023-05-23T21:30:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5c_fmt",
                                           "createdAt":  "2023-05-23T21:30:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "This issue has been marked `needs-author-action` and may be missing some important information.",
                                           "updatedAt":  "2023-05-23T21:30:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5dAO7l",
                                           "createdAt":  "2023-05-24T01:42:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mattleibow",
                                           "body":  "Both? I already have things in Maui to track this issue, but the runtime repo can also have it as a better exception will probably save days for developers. ",
                                           "updatedAt":  "2023-05-24T01:42:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5jyrI8",
                                           "createdAt":  "2023-08-11T05:27:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericstj",
                                           "body":  "The ask here is to introduce a check of `_finalized` and throw an exception.  We can consider this for 9.0.0 - too late now for 8.0.0.  cc @dotnet/area-system-runtime-compilerservices ",
                                           "updatedAt":  "2023-08-11T05:27:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Had-d",
                                           "createdAt":  "2024-08-06T18:09:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericstj",
                                           "body":  "Again we\u0027re at a place too late for this.  Since we haven\u0027t heard more asks I\u0027ve moved out to future.  @dotnet/area-system-runtime-compilerservices if you feel like this is valuable then move into 10.0 and introduce the change *early*.",
                                           "updatedAt":  "2024-08-06T18:09:25Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "NullReferenceException in ConditionalWeakTable`2.Remove",
        "labels":  [
                       "enhancement",
                       "area-System.Runtime.CompilerServices",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/94975",
        "createdAt":  "2023-11-19T15:36:52Z",
        "number":  94975,
        "author":  "MichalPetryka",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-15T07:39:06Z",
        "body":  "### Background and motivation\r\n\r\nIL has always exposed `ldtoken` instruction, but C# only exposed the type variant of it, making the method and field variants inaccessible. Requests for exposing those have been denied for either [unclear semantics](https://learn.microsoft.com/en-us/archive/blogs/ericlippert/in-foof-we-trust-a-dialogue) or [the language team disliking the fact it\u0027d promote reflection](https://github.com/dotnet/roslyn/issues/128#issuecomment-239907842).\r\nWith the handles being useful for some low level code and exposing things like function pointers, I\u0027d say there\u0027s still value in adding a way for cheaply obtaining them with trimming and AOT friendly, fast and visiblity-ignoring way. `UnsafeAccessor`s from #81741 meets all 3 criteria (unlike reflection or IL weaving without IgnoreAccessChecksTo).\r\n\r\nOne question would be whether those should return `RuntimeXHandle`s or `XInfo`s, since the API is low level and there are existing APIs to get `XInfo`s from handles, I\u0027d suggest it to be the former.\r\n\r\nSince IL exposes return type overloading on methods and fields (the latter is non CLS compliant though), the signature would need to indicate the type of those, for example with a dummy parameter at the end. The issue with this would be methods returning void.\r\n\r\nIf field `Offset` would be exposed on `RuntimeFieldInfo` in #94976, this could supersede #93946.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Runtime.CompilerServices;\r\n\r\npublic enum UnsafeAccessorKind\r\n{\r\n    StaticFieldHandle, // handle to static field on the type (`ldtoken` in IL)\r\n    FieldHandle, // handle to instance field on the type (`ldtoken` in IL)\r\n    StaticMethodHandle, // handle to static method on the type (`ldtoken` in IL)\r\n    MethodHandle, // handle to instance method on the type (`ldtoken` in IL)\r\n    VirtualMethodHandle // same as InstanceMethodHandle but with virtual method resolving on the object instance, let\u0027s you emulate `ldvirtftn`\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\npublic class C\r\n{\r\n    private int i;\r\n    protected virtual string B() =\u003e \"C\";\r\n}\r\n\r\npublic class D : C\r\n{\r\n    protected override void B() =\u003e \"D\";\r\n}\r\n\r\n[UnsafeAccessor(UnsafeAccessorKind.InstanceFieldHandled, Name = \"i\")]\r\npublic static RuntimeFieldHandle GetI(C c = null, int i = 0);\r\n[UnsafeAccessor(UnsafeAccessorKind.InstanceMethodHandled, Name = \"B\")]\r\npublic static RuntimeMethodHandle GetB(C c = null, string s = null);\r\n[UnsafeAccessor(UnsafeAccessorKind.VirtualMethodHandled, Name = \"B\")]\r\npublic static RuntimeMethodHandle GetBVirtual(C c, string s = null);\r\n\r\nConsole.WriteLine(FieldInfo.GetFieldFromHandle(GetI()).Attributes);\r\nConsole.WriteLine(MethodBase.GetMethodFromHandle(GetB())); // prints C.B\r\nConsole.WriteLine(MethodBase.GetMethodFromHandle(GetBVirtual(new D()))); // prints D.B\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nExposing `infoof/methodof/fieldof` and `IgnoreAccessChecksTo` would be a possible alternative but both have already been rejected.\r\n\r\n### Risks\r\n\r\nPopularising reflection use.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOtyHpeQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5sWs5f",
                                           "createdAt":  "2023-11-19T15:36:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-reflection\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nIL has always exposed `ldtoken` instruction, but C# only exposed the type variant of it, making the method and field variants inaccessible. Requests for exposing those have been denied for either [unclear semantics](https://learn.microsoft.com/en-us/archive/blogs/ericlippert/in-foof-we-trust-a-dialogue) or [the language team disliking the fact it\u0027d promote reflection](https://github.com/dotnet/roslyn/issues/128#issuecomment-239907842).\r\nWith the handles being useful for some low level code and exposing things like function pointers, I\u0027d say there\u0027s still value in adding a way for cheaply obtaining them with trimming and AOT friendly, fast and visiblity-ignoring way. `UnsafeAccessor` meets all 3 criteria (unlike reflection or IL weaving without IgnoreAccessChecksTo).\r\n\r\nOne question would be whether those should return `RuntimeXHandle`s or `XInfo`s, since the API is low level and there are existing APIs to get `XInfo`s from handles, I\u0027d suggest it to be the former.\r\n\r\nSince IL exposes return type overloading on methods and fields (the latter is non CLS compliant though), the signature would need to indicate the type of those, for example with a dummy parameter at the end. The issue with this would be methods returning void.\r\n\r\nIf `FieldOffset` would be exposed on `RuntimeFieldInfo`, this could supersede #93946.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Runtime.CompilerServices;\r\n\r\npublic enum UnsafeAccessorKind\r\n{\r\n    StaticFieldHandle, // handle to static field on the type (`ldtoken` in IL)\r\n    InstanceFieldHandle, // handle to instance field on the type (`ldtoken` in IL)\r\n    StaticMethodHandle, // handle to static method on the type (`ldtoken` in IL)\r\n    InstanceMethodHandle, // handle to instance method on the type (`ldtoken` in IL)\r\n    VirtualMethodHandle // same as InstanceMethodHandle but with virtual method resolving on the object instance\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\npublic class C\r\n{\r\n    private int i;\r\n    protected virtual string B() =\u003e \"C\";\r\n}\r\n\r\npublic class D : C\r\n{\r\n    protected override void B() =\u003e \"D\";\r\n}\r\n\r\n[UnsafeAccessor(UnsafeAccessorKind.InstanceFieldHandled, Name = \"i\")]\r\npublic static RuntimeFieldHandle GetI(C c = null, int i = 0);\r\n[UnsafeAccessor(UnsafeAccessorKind.InstanceMethodHandled, Name = \"B\")]\r\npublic static RuntimeMethodHandle GetB(C c = null, string s = null);\r\n[UnsafeAccessor(UnsafeAccessorKind.VirtualMethodHandled, Name = \"B\")]\r\npublic static RuntimeMethodHandle GetBVirtual(C c, string s = null);\r\nConsole.WriteLine(FieldInfo.GetFieldFromHandle(GetI()).Attributes);\r\nConsole.WriteLine(MethodBase.GetMethodFromHandle(GetB())); // prints C.B\r\nConsole.WriteLine(MethodBase.GetMethodFromHandle(GetBVirtual(new D()))); // prints D.B\r\n```\r\n\n\n### Alternative Designs\n\nExposing `infoof/methodof/fieldof` and `IgnoreAccessChecksTo` would be a possible alternative but both have already been rejected.\n\n### Risks\n\nPopularising reflection use.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eMichalPetryka\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Reflection`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-11-19T15:36:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5sW2di",
                                           "createdAt":  "2023-11-19T17:50:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime-compilerservices\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\r\n\r\nIL has always exposed `ldtoken` instruction, but C# only exposed the type variant of it, making the method and field variants inaccessible. Requests for exposing those have been denied for either [unclear semantics](https://learn.microsoft.com/en-us/archive/blogs/ericlippert/in-foof-we-trust-a-dialogue) or [the language team disliking the fact it\u0027d promote reflection](https://github.com/dotnet/roslyn/issues/128#issuecomment-239907842).\r\nWith the handles being useful for some low level code and exposing things like function pointers, I\u0027d say there\u0027s still value in adding a way for cheaply obtaining them with trimming and AOT friendly, fast and visiblity-ignoring way. `UnsafeAccessor`s from #81741 meets all 3 criteria (unlike reflection or IL weaving without IgnoreAccessChecksTo).\r\n\r\nOne question would be whether those should return `RuntimeXHandle`s or `XInfo`s, since the API is low level and there are existing APIs to get `XInfo`s from handles, I\u0027d suggest it to be the former.\r\n\r\nSince IL exposes return type overloading on methods and fields (the latter is non CLS compliant though), the signature would need to indicate the type of those, for example with a dummy parameter at the end. The issue with this would be methods returning void.\r\n\r\nIf field `Offset` would be exposed on `RuntimeFieldInfo` in #94976, this could supersede #93946.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Runtime.CompilerServices;\r\n\r\npublic enum UnsafeAccessorKind\r\n{\r\n    StaticFieldHandle, // handle to static field on the type (`ldtoken` in IL)\r\n    InstanceFieldHandle, // handle to instance field on the type (`ldtoken` in IL)\r\n    StaticMethodHandle, // handle to static method on the type (`ldtoken` in IL)\r\n    InstanceMethodHandle, // handle to instance method on the type (`ldtoken` in IL)\r\n    VirtualMethodHandle // same as InstanceMethodHandle but with virtual method resolving on the object instance, let\u0027s you emulate `ldvirtftn`\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\npublic class C\r\n{\r\n    private int i;\r\n    protected virtual string B() =\u003e \"C\";\r\n}\r\n\r\npublic class D : C\r\n{\r\n    protected override void B() =\u003e \"D\";\r\n}\r\n\r\n[UnsafeAccessor(UnsafeAccessorKind.InstanceFieldHandled, Name = \"i\")]\r\npublic static RuntimeFieldHandle GetI(C c = null, int i = 0);\r\n[UnsafeAccessor(UnsafeAccessorKind.InstanceMethodHandled, Name = \"B\")]\r\npublic static RuntimeMethodHandle GetB(C c = null, string s = null);\r\n[UnsafeAccessor(UnsafeAccessorKind.VirtualMethodHandled, Name = \"B\")]\r\npublic static RuntimeMethodHandle GetBVirtual(C c, string s = null);\r\n\r\nConsole.WriteLine(FieldInfo.GetFieldFromHandle(GetI()).Attributes);\r\nConsole.WriteLine(MethodBase.GetMethodFromHandle(GetB())); // prints C.B\r\nConsole.WriteLine(MethodBase.GetMethodFromHandle(GetBVirtual(new D()))); // prints D.B\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nExposing `infoof/methodof/fieldof` and `IgnoreAccessChecksTo` would be a possible alternative but both have already been rejected.\r\n\r\n### Risks\r\n\r\nPopularising reflection use.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eMichalPetryka\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Runtime.CompilerServices`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-11-19T17:50:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc63Iel5",
                                           "createdAt":  "2025-07-15T07:38:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "If a `Type ReturnType` property were added to UnsafeAccessorAttribute, then `ReturnType = typeof(void)` could be used, but then you\u0027d need another property to distinguish between by-value and `ref` returns.  (IIRC, overloading between `ref` and `ref readonly` is not possible in metadata.)  Unless it were a hybrid scheme in which the return type is taken from a parameter if `ReturnType` is null.\n\nBut if you\u0027d accept a hybrid scheme, then just `bool ReturnsVoid` would suffice and would be simpler.",
                                           "updatedAt":  "2025-07-15T07:39:06Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "[API Proposal]: `UnsafeAccessor` for member handles",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.CompilerServices",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/95361",
        "createdAt":  "2023-11-28T21:35:31Z",
        "number":  95361,
        "author":  "AaronRobinsonMSFT",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-11-30T09:29:19Z",
        "body":  "The `UnsafeAccessorAttribute` feature has some [non-obvious issues](https://learn.microsoft.com/dotnet/api/system.runtime.compilerservices.unsafeaccessorattribute#remarks) in some scenarios. The most recent example is captured in https://github.com/dotnet/runtime/issues/91740.\r\n\r\nExample:\r\n```csharp\r\nusing System.Runtime.CompilerServices;\r\n\r\nclass Program\r\n{\r\n    static void Main()\r\n    {\r\n        // Crashes at runtime with System.MissingMethodException:\r\n        // Method not found: \u0027System.Object.\u003cMain\u003eg__MemberwiseClone|0_0\u0027.\r\n        _ = MemberwiseClone(new object());\r\n\r\n        [UnsafeAccessor(UnsafeAccessorKind.Method)] // Analyzer should warn when applied to local function without defining \"Name\" property.\r\n        static extern object MemberwiseClone(object obj);\r\n    }\r\n}\r\n```\r\n\r\nAdditional cases for analyzer to consider: https://github.com/dotnet/runtime/issues/91740#issuecomment-1710803452",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHObSw0Tw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5tH5YK",
                                           "createdAt":  "2023-11-28T21:35:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime-compilerservices\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nThe `UnsafeAccessorAttribute` feature has some [non-obvious issues](https://learn.microsoft.com/dotnet/api/system.runtime.compilerservices.unsafeaccessorattribute#remarks) in some scenarios. The most recent example is captured in https://github.com/dotnet/runtime/issues/91740.\r\n\r\n```csharp\r\nusing System.Runtime.CompilerServices;\r\n\r\nclass Program\r\n{\r\n    static void Main()\r\n    {\r\n        // Crashes at runtime with System.MissingMethodException:\r\n        // Method not found: \u0027System.Object.\u003cMain\u003eg__MemberwiseClone|0_0\u0027.\r\n        _ = MemberwiseClone(new object());\r\n\r\n        [UnsafeAccessor(UnsafeAccessorKind.Method)] // Analyzer should warn when applied to local function without defining \"Name\" property.\r\n        static extern object MemberwiseClone(object obj);\r\n    }\r\n}\r\n```\r\n\n\n### API Proposal\n\nf\n\n### API Usage\n\nf\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eAaronRobinsonMSFT\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Runtime.CompilerServices`, `help wanted`, `source-generator`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003eFuture\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-11-28T21:35:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5tLDRP",
                                           "createdAt":  "2023-11-29T10:22:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODN9pBA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jnm2",
                                                                               "createdAt":  "2023-11-29T17:53:24Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "DaZombieKiller",
                                           "body":  "Would it make sense to expose an attribute similar to `[CallerMemberName]` for this scenario? If we could just mark `string` parameters and properties of attributes with `[AttributedMemberName]` or something similar, then these scenarios would \"just work\" for local functions without the need of an analyzer.",
                                           "updatedAt":  "2023-11-30T09:29:19Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[Analyzer]: Flagging unexpected `UnsafeAccessorAttribute` usage",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.CompilerServices",
                       "code-analyzer"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/96188",
        "createdAt":  "2023-12-19T15:00:16Z",
        "number":  96188,
        "author":  "cbersch",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-22T16:26:56Z",
        "body":  "### Description\r\n\r\nI was wondering, why writing a custom `InterpolatedStringHandler` is suggested to be done with an inner `StringBuilder` (e.g. https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/interpolated-string-handler) instead of a `DefaultInterpolatedStringHandler`.\r\n\r\nThe following Benchmark code shows that, the `StringBuilder` version is always faster in the \"DoNotLog\" case, which I didn\u0027t expect. Is that reasonable? \r\n\r\n```csharp\r\nusing BenchmarkDotNet.Attributes;\r\nusing BenchmarkDotNet.Jobs;\r\nusing BenchmarkDotNet.Running;\r\nusing System.Reflection;\r\nusing System.Runtime.CompilerServices;\r\nusing System.Text;\r\n\r\nBenchmarkRunner.Run(Assembly.GetExecutingAssembly());\r\n\r\n[MemoryDiagnoser]\r\n[SimpleJob(RuntimeMoniker.Net60)]\r\n[SimpleJob(RuntimeMoniker.Net70)]\r\n[SimpleJob(RuntimeMoniker.Net80)]\r\npublic class Benchmarks\r\n{\r\n    private int i = 27;\r\n\r\n    public string LogStringBuilder(bool condition, [InterpolatedStringHandlerArgument(nameof(condition))] StringBuilderInterpolatedStringHandler builder)\r\n        =\u003e condition ? builder.GetFormattedText() : \"\";\r\n\r\n    public string LogInterpolatedStringHandler(bool condition, [InterpolatedStringHandlerArgument(nameof(condition))] DfltInterpolatedStringHandler builder)\r\n        =\u003e condition ? builder.GetFormattedText() : \"\";\r\n\r\n    [Benchmark]\r\n    public string StringBuilderDoNotLog()\r\n        =\u003e LogStringBuilder(false, $\"{i} * {i} = {i * i}.\");\r\n\r\n    [Benchmark]\r\n    public string StringBuilderDoLog()\r\n        =\u003e LogStringBuilder(true, $\"{i} * {i} = {i * i}.\");\r\n\r\n    [Benchmark]\r\n    public string DefaultInterpolatedStringHandlerDoNotLog()\r\n        =\u003e LogInterpolatedStringHandler(false, $\"{i} * {i} = {i * i}.\");\r\n\r\n    [Benchmark]\r\n    public string DefaultInterpolatedStringHandlerDoLog()\r\n        =\u003e LogInterpolatedStringHandler(true, $\"{i} * {i} = {i * i}.\");\r\n}\r\n\r\n[InterpolatedStringHandler]\r\npublic ref struct StringBuilderInterpolatedStringHandler\r\n{\r\n    private readonly StringBuilder _builder;\r\n\r\n    public StringBuilderInterpolatedStringHandler(int literalLength, int formattedCount, bool condition, out bool isEnabled)\r\n    {\r\n        isEnabled = condition;\r\n        _builder = isEnabled ? new StringBuilder(literalLength) : default!;\r\n    }\r\n\r\n    public void AppendLiteral(string s) =\u003e _builder.Append(s);\r\n    public void AppendFormatted\u003cT\u003e(T t) =\u003e _builder.Append(t);\r\n    internal string GetFormattedText() =\u003e _builder.ToString();\r\n}\r\n\r\n[InterpolatedStringHandler]\r\npublic ref struct DfltInterpolatedStringHandler\r\n{\r\n    private DefaultInterpolatedStringHandler _builder;\r\n\r\n    public DfltInterpolatedStringHandler(int literalLength, int formattedCount, bool condition, out bool isEnabled)\r\n    {\r\n        isEnabled = condition;\r\n        _builder = isEnabled ? new(literalLength, formattedCount) : default!;\r\n    }\r\n\r\n    public void AppendLiteral(string s) =\u003e _builder.AppendLiteral(s);\r\n    public void AppendFormatted\u003cT\u003e(T t) =\u003e _builder.AppendFormatted(t);\r\n    internal string GetFormattedText() =\u003e _builder.ToStringAndClear();\r\n}\r\n```\r\n\r\nThe results are \r\n\r\n```\r\nBenchmarkDotNet v0.13.11, Windows 10 (10.0.19044.3693/21H2/November2021Update)\r\nIntel Xeon Silver 4214 CPU 2.20GHz, 1 CPU, 24 logical and 12 physical cores\r\n.NET SDK 8.0.100\r\n  [Host]   : .NET 8.0.0 (8.0.23.53103), X64 RyuJIT AVX-512F+CD+BW+DQ+VL\r\n  .NET 6.0 : .NET 6.0.25 (6.0.2523.51912), X64 RyuJIT AVX2\r\n  .NET 7.0 : .NET 7.0.14 (7.0.1423.51910), X64 RyuJIT AVX2\r\n  .NET 8.0 : .NET 8.0.0 (8.0.23.53103), X64 RyuJIT AVX-512F+CD+BW+DQ+VL\r\n```\r\n\r\n| Method                                   | Job      | Runtime  | Mean       | Error     | StdDev    | Gen0   | Allocated |\r\n|----------------------------------------- |--------- |--------- |-----------:|----------:|----------:|-------:|----------:|\r\n| StringBuilderDoNotLog                    | .NET 6.0 | .NET 6.0 |   1.026 ns | 0.0861 ns | 0.0763 ns |      - |         - |\r\n| StringBuilderDoLog                       | .NET 6.0 | .NET 6.0 | 204.764 ns | 3.4614 ns | 3.2378 ns | 0.0463 |     400 B |\r\n| DefaultInterpolatedStringHandlerDoNotLog | .NET 6.0 | .NET 6.0 |  11.621 ns | 0.2693 ns | 0.2519 ns |      - |         - |\r\n| DefaultInterpolatedStringHandlerDoLog    | .NET 6.0 | .NET 6.0 | 107.183 ns | 1.4614 ns | 1.2955 ns | 0.0064 |      56 B |\r\n| StringBuilderDoNotLog                    | .NET 7.0 | .NET 7.0 |   2.543 ns | 0.0767 ns | 0.0718 ns |      - |         - |\r\n| StringBuilderDoLog                       | .NET 7.0 | .NET 7.0 | 171.138 ns | 3.4185 ns | 3.3574 ns | 0.0463 |     400 B |\r\n| DefaultInterpolatedStringHandlerDoNotLog | .NET 7.0 | .NET 7.0 |  12.018 ns | 0.2562 ns | 0.2271 ns |      - |         - |\r\n| DefaultInterpolatedStringHandlerDoLog    | .NET 7.0 | .NET 7.0 | 107.755 ns | 1.4457 ns | 1.3523 ns | 0.0064 |      56 B |\r\n| StringBuilderDoNotLog                    | .NET 8.0 | .NET 8.0 |   2.409 ns | 0.0559 ns | 0.0495 ns |      - |         - |\r\n| StringBuilderDoLog                       | .NET 8.0 | .NET 8.0 | 137.700 ns | 2.7340 ns | 3.1485 ns | 0.0389 |     336 B |\r\n| DefaultInterpolatedStringHandlerDoNotLog | .NET 8.0 | .NET 8.0 |  10.520 ns | 0.2821 ns | 0.2897 ns |      - |         - |\r\n| DefaultInterpolatedStringHandlerDoLog    | .NET 8.0 | .NET 8.0 |  81.272 ns | 1.7151 ns | 2.1690 ns | 0.0064 |      56 B |\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHObznu8A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5vC-dn",
                                           "createdAt":  "2023-12-19T16:05:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime-compilerservices\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\nI was wondering, why writing a custom `InterpolatedStringHandler` is suggested to be done with an inner `StringBuilder` (e.g. https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/interpolated-string-handler) instead of a `DefaultInterpolatedStringHandler`.\r\n\r\nThe following Benchmark code shows that, the `StringBuilder` version is always faster, which I didn\u0027t expect. Is that reasonable? \r\n\r\n```csharp\r\nusing BenchmarkDotNet.Attributes;\r\nusing BenchmarkDotNet.Jobs;\r\nusing BenchmarkDotNet.Running;\r\nusing System.Reflection;\r\nusing System.Runtime.CompilerServices;\r\nusing System.Text;\r\n\r\nBenchmarkRunner.Run(Assembly.GetExecutingAssembly());\r\n\r\n[MemoryDiagnoser]\r\n[SimpleJob(RuntimeMoniker.Net60)]\r\n[SimpleJob(RuntimeMoniker.Net70)]\r\n[SimpleJob(RuntimeMoniker.Net80)]\r\npublic class Benchmarks\r\n{\r\n    private int i = 27;\r\n\r\n    public string LogStringBuilder(bool condition, [InterpolatedStringHandlerArgument(nameof(condition))] StringBuilderInterpolatedStringHandler builder)\r\n        =\u003e condition ? builder.GetFormattedText() : \"\";\r\n\r\n    public string LogInterpolatedStringHandler(bool condition, [InterpolatedStringHandlerArgument(nameof(condition))] DfltInterpolatedStringHandler builder)\r\n        =\u003e condition ? builder.GetFormattedText() : \"\";\r\n\r\n    [Benchmark]\r\n    public string StringBuilderDoNotLog()\r\n        =\u003e LogStringBuilder(false, $\"{i} * {i} = {i * i}.\");\r\n\r\n    [Benchmark]\r\n    public string StringBuilderDoLog()\r\n        =\u003e LogStringBuilder(true, $\"{i} * {i} = {i * i}.\");\r\n\r\n    [Benchmark]\r\n    public string DefaultInterpolatedStringHandlerDoNotLog()\r\n        =\u003e LogInterpolatedStringHandler(false, $\"{i} * {i} = {i * i}.\");\r\n\r\n    [Benchmark]\r\n    public string DefaultInterpolatedStringHandlerDoLog()\r\n        =\u003e LogInterpolatedStringHandler(true, $\"{i} * {i} = {i * i}.\");\r\n}\r\n\r\n[InterpolatedStringHandler]\r\npublic ref struct StringBuilderInterpolatedStringHandler\r\n{\r\n    private readonly StringBuilder _builder;\r\n\r\n    public StringBuilderInterpolatedStringHandler(int literalLength, int formattedCount, bool condition, out bool isEnabled)\r\n    {\r\n        isEnabled = condition;\r\n        _builder = isEnabled ? new StringBuilder(literalLength) : default!;\r\n    }\r\n\r\n    public void AppendLiteral(string s) =\u003e _builder.Append(s);\r\n    public void AppendFormatted\u003cT\u003e(T t) =\u003e _builder.Append(t);\r\n    internal string GetFormattedText() =\u003e _builder.ToString();\r\n}\r\n\r\n[InterpolatedStringHandler]\r\npublic ref struct DfltInterpolatedStringHandler\r\n{\r\n    private DefaultInterpolatedStringHandler _builder;\r\n\r\n    public DfltInterpolatedStringHandler(int literalLength, int formattedCount, bool condition, out bool isEnabled)\r\n    {\r\n        isEnabled = condition;\r\n        _builder = isEnabled ? new(literalLength, formattedCount) : default!;\r\n    }\r\n\r\n    public void AppendLiteral(string s) =\u003e _builder.AppendLiteral(s);\r\n    public void AppendFormatted\u003cT\u003e(T t) =\u003e _builder.AppendFormatted(t);\r\n    internal string GetFormattedText() =\u003e _builder.ToString();\r\n}\r\n```\r\n\r\nThe results are \r\n\r\n```\r\nBenchmarkDotNet v0.13.11, Windows 10 (10.0.19044.3693/21H2/November2021Update)\r\nIntel Xeon Silver 4214 CPU 2.20GHz, 1 CPU, 24 logical and 12 physical cores\r\n.NET SDK 8.0.100\r\n  [Host]   : .NET 8.0.0 (8.0.23.53103), X64 RyuJIT AVX-512F+CD+BW+DQ+VL\r\n  .NET 6.0 : .NET 6.0.25 (6.0.2523.51912), X64 RyuJIT AVX2\r\n  .NET 7.0 : .NET 7.0.14 (7.0.1423.51910), X64 RyuJIT AVX2\r\n  .NET 8.0 : .NET 8.0.0 (8.0.23.53103), X64 RyuJIT AVX-512F+CD+BW+DQ+VL\r\n```\r\n\r\n| Method                                   | Job      | Runtime  | Mean       | Error     | StdDev    | Gen0   | Allocated |\r\n|----------------------------------------- |--------- |--------- |-----------:|----------:|----------:|-------:|----------:|\r\n| StringBuilderDoNotLog                    | .NET 6.0 | .NET 6.0 |   1.269 ns | 0.0798 ns | 0.0666 ns |      - |         - |\r\n| StringBuilderDoLog                       | .NET 6.0 | .NET 6.0 | 204.051 ns | 3.2470 ns | 3.0373 ns | 0.0463 |     400 B |\r\n| DefaultInterpolatedStringHandlerDoNotLog | .NET 6.0 | .NET 6.0 |  11.250 ns | 0.2988 ns | 0.3321 ns |      - |         - |\r\n| DefaultInterpolatedStringHandlerDoLog    | .NET 6.0 | .NET 6.0 | 174.782 ns | 3.4713 ns | 3.7143 ns | 0.0684 |     592 B |\r\n| StringBuilderDoNotLog                    | .NET 7.0 | .NET 7.0 |   2.458 ns | 0.0858 ns | 0.0802 ns |      - |         - |\r\n| StringBuilderDoLog                       | .NET 7.0 | .NET 7.0 | 168.577 ns | 3.0412 ns | 2.6960 ns | 0.0463 |     400 B |\r\n| DefaultInterpolatedStringHandlerDoNotLog | .NET 7.0 | .NET 7.0 |  11.135 ns | 0.1951 ns | 0.1629 ns |      - |         - |\r\n| DefaultInterpolatedStringHandlerDoLog    | .NET 7.0 | .NET 7.0 | 178.747 ns | 3.5512 ns | 4.2274 ns | 0.0684 |     592 B |\r\n| StringBuilderDoNotLog                    | .NET 8.0 | .NET 8.0 |   2.325 ns | 0.0792 ns | 0.0741 ns |      - |         - |\r\n| StringBuilderDoLog                       | .NET 8.0 | .NET 8.0 | 132.395 ns | 2.7201 ns | 2.9105 ns | 0.0389 |     336 B |\r\n| DefaultInterpolatedStringHandlerDoNotLog | .NET 8.0 | .NET 8.0 |  10.778 ns | 0.2240 ns | 0.2096 ns |      - |         - |\r\n| DefaultInterpolatedStringHandlerDoLog    | .NET 8.0 | .NET 8.0 | 147.318 ns | 2.8658 ns | 2.9430 ns | 0.0684 |     592 B |\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ecbersch\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.CompilerServices`, `tenet-performance`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-12-19T16:05:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5vDDqI",
                                           "createdAt":  "2023-12-19T16:17:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "Try\r\n```diff\r\n-internal string GetFormattedText() =\u003e _builder.ToString();\r\n+internal string GetFormattedText() =\u003e _builder.ToStringAndClear();\r\n```\r\n\r\n`DefaultInterpolatedStringHandler` is using pooled buffers internally to avoid some of the allocations.\r\nYou are expected to return those buffers by calling `ToStringAndClear` when you are done using it, otherwise, it must always allocate new buffers, which can be worse than just using `StringBuilder`.",
                                           "updatedAt":  "2023-12-19T16:17:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5vDH8S",
                                           "createdAt":  "2023-12-19T16:27:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "andrewjsaid",
                                           "body":  "**Edit: The below is basically wrong. See bottom for proof.**\r\n\r\n`DefaultInterpolatedStringHandler` is a ref struct and in the benchmark code you\u0027re passing it around not as ref. Maybe this is causing loads of copies of the ref? That\u0027s probably a wrong explanation but changing the implementation to\r\n\r\n```\r\n    public string LogInterpolatedStringHandler(bool condition, ref DefaultInterpolatedStringHandler builder)\r\n        =\u003e condition ? builder.ToStringAndClear() : \"\";\r\n```\r\n\r\n```\r\n| Method                                   | Mean      | Error     | StdDev    |\r\n|----------------------------------------- |----------:|----------:|----------:|\r\n| StringBuilderDoNotLog                    |  1.334 ns | 0.0009 ns | 0.0008 ns |\r\n| StringBuilderDoLog                       | 60.631 ns | 0.4909 ns | 0.4351 ns |\r\n| DefaultInterpolatedStringHandlerDoNotLog | 33.833 ns | 0.2562 ns | 0.2397 ns |\r\n| DefaultInterpolatedStringHandlerDoLog    | 41.160 ns | 0.0634 ns | 0.0562 ns |\r\n```\r\n\r\nGives me this benchmark which shows it is indeed faster in the intended use-case. Of course the `condition` no longer works but that\u0027s not the point - it\u0027s not something that `DefaultInterpolatedStringHandler` supports and as it can\u0027t be wrapped in another ref struct (language limitation) then I guess that\u0027s why it\u0027s only intended to be used by the compiler.\r\n\r\n**Proof I was wrong:**\r\n\r\nBenchmarking this handler below gives me equal results to just using the `DefaultInterpolatedStringHandler`. It seems adding the `out bool enabled` does is the biggest factor on my machine which impacts perf. \r\n\r\n```\r\n\r\n[InterpolatedStringHandler]\r\npublic ref struct DfltInterpolatedStringHandlerNoCondition\r\n{\r\n    private DefaultInterpolatedStringHandler _builder;\r\n\r\n    public DfltInterpolatedStringHandlerNoCondition(int literalLength, int formattedCount)\r\n    {\r\n        _builder = new(literalLength, formattedCount);\r\n    }\r\n\r\n    public void AppendLiteral(string s) =\u003e _builder.AppendLiteral(s);\r\n    public void AppendFormatted\u003cT\u003e(T t) =\u003e _builder.AppendFormatted(t);\r\n    internal string GetFormattedText() =\u003e _builder.ToStringAndClear();\r\n}\r\n```",
                                           "updatedAt":  "2023-12-19T17:52:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5vDPBm",
                                           "createdAt":  "2023-12-19T16:44:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "cbersch",
                                           "body":  "@andrewjsaid Thanks for testing this.\r\nBut in your case the \"DoNotLog\" case performs even worse (33ns vs 1.3ns) than in my example (2.3ns vs 10.8ns)",
                                           "updatedAt":  "2023-12-19T16:44:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5vDSCs",
                                           "createdAt":  "2023-12-19T16:52:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "cbersch",
                                           "body":  "\u003e Try\r\n\u003e \r\n\u003e ```diff\r\n\u003e -internal string GetFormattedText() =\u003e _builder.ToString();\r\n\u003e +internal string GetFormattedText() =\u003e _builder.ToStringAndClear();\r\n\u003e ```\r\n\u003e \r\n\u003e `DefaultInterpolatedStringHandler` is using pooled buffers internally to avoid some of the allocations. You are expected to return those buffers by calling `ToStringAndClear` when you are done using it, otherwise, it must always allocate new buffers, which can be worse than just using `StringBuilder`.\r\n\r\nYou are right, this slipped through during testing. \r\n\r\nBut this doesn\u0027t explain the longer runtime in the \"DoNotLog\" case.\r\nI updated the title, code and benchmark results to use `ToStringAndClear`.",
                                           "updatedAt":  "2023-12-19T16:52:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5vDuBk",
                                           "createdAt":  "2023-12-19T18:01:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "andrewjsaid",
                                           "body":  "@cbersch  While I was kinda wrong in my previous comments about the `DoLog` case, I was kinda right about using `ref`. If you change `LogInterpolatedStringHandler` to accept `ref DefaultInterpolatedStringHandler builder` as a parameter then it improves the `DoNotLog` benchmark due to the copies I was referring to.\r\n\r\n```\r\n    private string LogInterpolatedStringRefHandler(bool condition, [InterpolatedStringHandlerArgument(nameof(condition))] ref DfltInterpolatedStringHandler builder)\r\n        =\u003e condition ? builder.GetFormattedText() : \"\";\r\n```\r\n\r\n```\r\n\r\nBenchmarkDotNet v0.13.11, Windows 11 (10.0.22621.2861/22H2/2022Update/SunValley2)\r\nAMD Ryzen 9 5950X, 1 CPU, 32 logical and 16 physical cores\r\n.NET SDK 8.0.100\r\n  [Host]     : .NET 8.0.0 (8.0.23.53103), X64 RyuJIT AVX2\r\n  Job-CFUFJO : .NET 8.0.0 (8.0.23.53103), X64 RyuJIT AVX2\r\n\r\nIterationCount=5  \r\n\r\n```\r\n| Method                                      | Mean      | Error     | StdDev    |\r\n|-------------------------------------------- |----------:|----------:|----------:|\r\n| StringBuilderDoNotLog                       |  1.256 ns | 0.1360 ns | 0.0353 ns |\r\n| DefaultInterpolatedStringHandlerDoNotLog    |  6.682 ns | 0.0431 ns | 0.0067 ns |\r\n| DefaultInterpolatedStringRefHandlerDoNotLog |  3.978 ns | 0.0473 ns | 0.0123 ns |\r\n",
                                           "updatedAt":  "2023-12-19T18:01:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5vKpqP",
                                           "createdAt":  "2023-12-20T20:05:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "That makes sense. Writing a `default` `DefaultInterpolatedStringHandler` is more expensive than writing a `null` `StringBuilder`. The size of the struct is much larger than the size of a reference.\r\n\r\n``` cs\r\nprivate readonly IFormatProvider? _provider;\r\nprivate char[]? _arrayToReturnToPool;\r\nprivate Span\u003cchar\u003e _chars;\r\nprivate int _pos;\r\nprivate readonly bool _hasCustomFormatter;\r\n```",
                                           "updatedAt":  "2023-12-20T20:05:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5vOe7w",
                                           "createdAt":  "2023-12-21T11:08:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "cbersch",
                                           "body":  "@andrewjsaid Thank you, the `ref` improves it indeed. I hadn\u0027t tried that, because I was unsure about the method signature demands for using an `InterpolatedStringHandler`.",
                                           "updatedAt":  "2023-12-21T11:08:32Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Custom InterpolatedStringHandler with a DefaultInterpolatedStringHandler performs worse than one with a StringBuilder when not enabled",
        "labels":  [
                       "question",
                       "area-System.Runtime.CompilerServices",
                       "tenet-performance",
                       "discussion",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/99144",
        "createdAt":  "2024-03-01T03:40:55Z",
        "number":  99144,
        "author":  "hamarb123",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-03-01T00:19:22Z",
        "body":  "There are a number of unnecessary uses of `Unsafe.AsPointer` in this repository (e.g. https://github.com/dotnet/runtime/blob/eaa6f01a11eb39e1f402d8e196680fbf4aa4b054/src/coreclr/System.Private.CoreLib/src/System/GC.CoreCLR.cs#L868) - this is a extra dangerous API that can easily be used wrongly (see https://github.com/dotnet/runtime/pull/99138 as an example that slipped by a number of people). While the current remaining uses seem safe currently at a glance, we might be better off replacing a number of the unnecessary uses with other APIs, and/or adding a comment explaining why it\u0027s safe in this case (like in https://github.com/dotnet/runtime/blob/9863bf17c4abc353b867d1bcb965725384320294/src/libraries/System.Private.CoreLib/src/System/Number.BigInteger.cs#L1237), and disrecommending their use in the future without a very good reason.\r\n\r\nMost of the uses can be broken in to 2 categories:\r\n- Aligning or detecting alignment of a reference (we can introduce helper APIs for this, e.g. https://github.com/dotnet/runtime/blob/eaa6f01a11eb39e1f402d8e196680fbf4aa4b054/src/libraries/System.Private.CoreLib/src/System/Text/Ascii.cs#L144)\r\n- Getting a pointer to something that is known to be pinned (many of these cases could be converted to ref fields instead, using refs/spans directly, or passing by pointer, e.g. https://github.com/dotnet/runtime/blob/eaa6f01a11eb39e1f402d8e196680fbf4aa4b054/src/mono/System.Private.CoreLib/src/System/Reflection/TypeNameParser.Mono.cs#L48)\r\n\r\nThe idea was mentioned by @tannergooding on the discord, and one of the suggested solutions was to create an internal API `bool IsOpportunisticallyAligned(ref T address, nuint aligment)` or similar for the alignment uses.\r\n\r\nI am happy to make PRs for these. @tannergooding suggested that I make one for each area separately. Just making this issue to track it and get support for the general idea from people.\r\n\r\n/cc @stephentoub @jkotas @tannergooding ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOdd4QTw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc51kVf9",
                                           "createdAt":  "2024-03-01T03:51:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "I\u0027m generally supportive of removing unsafe code in favor of safer patterns, particularly where newer features like `ref fields` can be used to avoid the issue or special helpers like some `bool IsOpportunisticallyAligned(ref T address, nuint aligment)` could exist to document the intent and centralize the logic.\r\n\r\nNotably a lot of these places where its being used are fairly core APIs, so there is risk in making changes to them even if to remove unsafe code. It\u0027s something that we need to be extra cautious around and ensure gets the right scrutiny.",
                                           "updatedAt":  "2024-03-01T03:51:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51kY8F",
                                           "createdAt":  "2024-03-01T04:10:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "List of areas with calls to `Unsafe.AsPointer` (tick indicates it\u0027s been reviewed and/or had a PR made for it):\r\n- [x] Common/System.Private.CoreLib\r\n- [x] Runtime.Base (nativeaot)\r\n- [x] System.Private.TypeLoader (nativeaot)\r\n- [x] System.Numerics\r\n- [ ] Microsoft.CSharp\r\n- [ ] Microsoft.Extensions.Logging.EventSource\r\n- [x] System.Memory\r\n- [ ] System.Net.Sockets (tests)\r\n- [ ] System.Diagnostics.Tracing\r\n- [x] System.Globalization\r\n- [x] System.Runtime.CompilerServices\r\n- [x] System.Runtime.InteropServices\r\n- [x] System.Runtime.InteropServices.Marshalling\r\n- [x] System.Text\r\n- [x] System.Text.Unicode\r\n- [ ] System.Threading\r\n- [ ] System.Threading.Tasks\r\n- [ ] System.Runtime.InteropServices.JavaScript\r\n- [ ] System.Security.Cryptography\r\n- [ ] System.Text.Json\r\n- [x] System.Reflection (mono)\r\n- [x] Other code (HostRuntimeContract.cs, MonoSDBHelper.cs, simple-raytracer/Program.cs, poison.cs, classloader/generics/Pointers/Pointers.cs, universal_generics.cs)\r\n- [x] Some regression tests - Runtime_61510.cs, Runtime_92349.cs",
                                           "updatedAt":  "2024-03-05T04:09:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51keEx",
                                           "createdAt":  "2024-03-01T04:40:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e _EnumerateConfigurationValues(Unsafe.AsPointer(ref context), \u0026ConfigCallback); \r\n\r\nWhy do you think that this use is unnecessary? What would you replace it with (while preserving the perf characteristics). I do not see a problem with this one.\r\n\r\n\u003e this is a extra dangerous API that can easily be used wrongly \r\n\r\nNo much different from every other `Unsafe.*` API. You have to know what you are doing when using `Unsafe.*` APIs.\r\n\r\n\u003e IsOpportunisticallyAligned\r\n\r\nSounds good to me. I see ~5 places where this can be used.\r\n\r\n\u003e Getting a pointer to something that is known to be pinned (many of these cases could be converted to ref fields instead\r\n\r\nI am not convinced that it is that easy. Many of these uses have to do with low-level interop. ",
                                           "updatedAt":  "2024-03-01T04:40:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51keRT",
                                           "createdAt":  "2024-03-01T04:41:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime-compilerservices\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThere are a number of unnecessary uses of `Unsafe.AsPointer` in this repository (e.g. https://github.com/dotnet/runtime/blob/eaa6f01a11eb39e1f402d8e196680fbf4aa4b054/src/coreclr/System.Private.CoreLib/src/System/GC.CoreCLR.cs#L868) - this is a extra dangerous API that can easily be used wrongly (see https://github.com/dotnet/runtime/pull/99138 as an example that slipped by a number of people). While the current remaining uses seem safe currently at a glance, we might be better off replacing a number of the unnecessary uses with other APIs, and/or adding a comment explaining why it\u0027s safe in this case (like in https://github.com/dotnet/runtime/blob/9863bf17c4abc353b867d1bcb965725384320294/src/libraries/System.Private.CoreLib/src/System/Number.BigInteger.cs#L1237), and disrecommending their use in the future without a very good reason.\r\n\r\nMost of the uses can be broken in to 2 categories:\r\n- Aligning or detecting alignment of a reference (we can introduce helper APIs for this, e.g. https://github.com/dotnet/runtime/blob/eaa6f01a11eb39e1f402d8e196680fbf4aa4b054/src/libraries/System.Private.CoreLib/src/System/Text/Ascii.cs#L144)\r\n- Getting a pointer to something that is known to be pinned (many of these cases could be converted to ref fields instead, using refs/spans directly, or passing by pointer, e.g. https://github.com/dotnet/runtime/blob/eaa6f01a11eb39e1f402d8e196680fbf4aa4b054/src/mono/System.Private.CoreLib/src/System/Reflection/TypeNameParser.Mono.cs#L48)\r\n\r\nThe idea was mentioned by @tannergooding on the discord, and one of the suggested solutions was to create an internal API `bool IsOpportunisticallyAligned(ref T address, nuint aligment)` or similar for the alignment uses.\r\n\r\nI am happy to make PRs for these. @tannergooding suggested that I make one for each area separately. Just making this issue to track it and get support for the general idea from people.\r\n\r\n/cc @stephentoub @jkotas @tannergooding \n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ehamarb123\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.CompilerServices`, `untriaged`, `needs-area-label`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-03-01T04:41:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51kedw",
                                           "createdAt":  "2024-03-01T04:42:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODY4BNw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "huoyaoyuan",
                                                                               "createdAt":  "2024-03-01T04:44:34Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "\u003e \u003e _EnumerateConfigurationValues(Unsafe.AsPointer(ref context), \u0026ConfigCallback);\r\n\u003e \r\n\u003e Why do you think that this use is unnecessary? What would you replace it with (while preserving the perf characteristics). I do not see a problem with this one.\r\n\r\n`_EnumerateConfigurationValues(\u0026context, \u0026ConfigCallback);`",
                                           "updatedAt":  "2024-03-01T04:42:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51kf--",
                                           "createdAt":  "2024-03-01T04:48:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODY4COg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hamarb123",
                                                                               "createdAt":  "2024-03-01T04:48:40Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e _EnumerateConfigurationValues(\u0026context, \u0026ConfigCallback);\r\n\r\nOk this works but it requires pragma disable.",
                                           "updatedAt":  "2024-03-01T04:48:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51khHB",
                                           "createdAt":  "2024-03-01T04:55:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "\u003e \u003e IsOpportunisticallyAligned\r\n\u003e \r\n\u003e Sounds good to me. I see ~5 places where this can be used.\r\n\r\nWhich file/type should I define this on?",
                                           "updatedAt":  "2024-03-01T04:55:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51khpc",
                                           "createdAt":  "2024-03-01T04:57:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODY4Qhg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hamarb123",
                                                                               "createdAt":  "2024-03-01T04:58:33Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tannergooding",
                                                                               "createdAt":  "2024-03-01T05:29:11Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "jkotas",
                                           "body":  "It can be internal method on `System.Runtime.CompilerServices.Unsafe`",
                                           "updatedAt":  "2024-03-01T04:57:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51nBUm",
                                           "createdAt":  "2024-03-01T13:05:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "\u003e \u003e _EnumerateConfigurationValues(\u0026context, \u0026ConfigCallback);\r\n\u003e \r\n\u003e Ok this works but it requires pragma disable.\r\n\r\nDo we want to disable it globally like it was mentioned in https://github.com/dotnet/runtime/pull/80484#pullrequestreview-1244050291?",
                                           "updatedAt":  "2024-03-01T13:05:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51oFB4",
                                           "createdAt":  "2024-03-01T15:57:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e Do we want to disable it globally like it was mentioned in https://github.com/dotnet/runtime/pull/80484#pullrequestreview-1244050291?\r\n\r\nThis issue is itself about trying to reduce unsafe patterns where unnecessary. Globally suppressing the warning that you\u0027re taking a pointer to a managed object is kind-of counter intuitive to that ;)\r\n\r\nI think we want to be explicit when we\u0027re taking a pointer to a managed object to help reduce risk and make it very apparent we\u0027re taking the necessary approaches to keep the underlying object alive, etc.",
                                           "updatedAt":  "2024-03-01T15:57:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc513djN",
                                           "createdAt":  "2024-03-04T21:18:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sharwell",
                                           "body":  "In my opinion, `Unsafe.AsPointer` is more clear than a disabled CS8500 combined with the `\u0026` operator. One of the reasons why I prefer it is the disabled CS8500 applies to entire lines of code between the disable/restore, while the use of `Unsafe.AsPointer` applies only to the exact call where it was needed.",
                                           "updatedAt":  "2024-03-04T21:18:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc513fyf",
                                           "createdAt":  "2024-03-04T21:23:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sharwell",
                                           "body":  "It\u0027s also not clear to me how the changes proposed here would have prevented the GC hole mentioned in the original post above.",
                                           "updatedAt":  "2024-03-04T21:23:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc513hBP",
                                           "createdAt":  "2024-03-04T21:26:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODZ--Qg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-03-10T02:20:27Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "\u003e In my opinion, `Unsafe.AsPointer` is more clear than a disabled CS8500 combined with the `\u0026` operator. One of the reasons why I prefer it is the disabled CS8500 applies to entire lines of code between the disable/restore, while the use of `Unsafe.AsPointer` applies only to the exact call where it was needed.\r\n\r\nCS8500 is a bit of a silly warning anyway imo. The issue with `Unsafe.AsPointer` is that it will happily allow unsafe cases where the memory is not fixed, whereas `\u0026` will not.\r\n\r\ne.g., consider I have this:\r\n```csharp\r\nSomeType v = ...;\r\n...\r\nCallMethod(\u0026v);\r\n```\r\nif I moved (or otherwise have a) `v` anywhere that\u0027s not obviously on the stack I will get an error, whereas `Unsafe.AsPointer` will happily continue to \"work\" even when not pinned otherwise.\r\n\r\n\u003e It\u0027s also not clear to me how the changes proposed here would have prevented the GC hole mentioned in the original post above.\r\n\r\nIf we avoid using `Unsafe.AsPointer` without a good reason that other alternatives couldn\u0027t work, then it would have been more likely to have been questioned and caught.",
                                           "updatedAt":  "2024-03-04T21:26:59Z"
                                       }
                                   ],
                         "totalCount":  13
                     },
        "title":  "Remove a number of calls to `Unsafe.AsPointer`",
        "labels":  [
                       "area-System.Runtime.CompilerServices",
                       "reduce-unsafe"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/104877",
        "createdAt":  "2024-07-14T23:43:26Z",
        "number":  104877,
        "author":  "timcassell",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC5dj0A==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hamarb123",
                                            "createdAt":  "2024-07-15T00:10:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-07-15T12:34:34Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "KeterSCP",
                                            "createdAt":  "2024-07-15T12:54:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MineCake147E",
                                            "createdAt":  "2024-07-18T02:45:40Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2024-07-18T21:05:29Z",
        "body":  "### Background and motivation\r\n\r\nA JIT intrinsic API that does nothing. Similar to Java\u0027s [Blackhole](https://javadoc.io/doc/org.openjdk.jmh/jmh-core/1.23/org/openjdk/jmh/infra/Blackhole.html). `Blackhole` is used to prevent dead code elimination and out-of-order instructions generated by a compiler (not by the CPU, so it doesn\u0027t emit any barriers). The actual call does nothing, and is stripped out of the assembly.\r\n\r\nThe purpose of this API is to make it easier/possible to benchmark sensitive operations. Without this API, heavier alternatives are required like calling a method with `NoInlining`, or writing to a field ([see Consumer class in BDN](https://github.com/dotnet/BenchmarkDotNet/blob/01d9b7889e13cf756068985275a3997217e4a102/src/BenchmarkDotNet/Engines/Consumer.cs)), which can spoil the results of the measurement. The cost of this has already been observed (#89940) (also credit to @EgorBo for this idea in that issue).\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Runtime.CompilerServices;\r\n\r\npublic static class Blackhole\r\n{\r\n    public static void Consume\u003cT\u003e(scoped T value) where T : allows ref struct;\r\n    public static void Consume\u003cT\u003e(scoped ref readonly T value) where T : allows ref struct;\r\n    public static unsafe void Consume(void* value);\r\n}\r\n```\r\n\r\n### API Usage\r\n\r\nOld code:\r\n\r\n```csharp\r\npublic class HalfCast\r\n{\r\n    private readonly Consumer consumer = new();\r\n    \r\n    // 4 operations per invoke averages the cost of the 4 operations\r\n    [Benchmark(OperationsPerInvoke = 4)]\r\n    [Arguments(6.097555E-05f, 12345.0f, 65520.0f, float.NaN)]\r\n    public void SingleToHalfAverage(float arg1, float arg2, float arg3, float arg4)\r\n    {\r\n        // Oh no, the consumer\u0027s volatile write interferes with the results!\r\n        consumer.Consume((Half) arg1);\r\n        consumer.Consume((Half) arg2);\r\n        consumer.Consume((Half) arg3);\r\n        consumer.Consume((Half) arg4);\r\n    }\r\n}\r\n```\r\n\r\nNew code:\r\n\r\n```csharp\r\npublic class HalfCast\r\n{\r\n    // 4 operations per invoke averages the cost of the 4 operations\r\n    [Benchmark(OperationsPerInvoke = 4)]\r\n    [Arguments(6.097555E-05f, 12345.0f, 65520.0f, float.NaN)]\r\n    public void SingleToHalfAverage(float arg1, float arg2, float arg3, float arg4)\r\n    {\r\n        // Yay, we get accurate results!\r\n        Blackhole.Consume((Half) arg1);\r\n        Blackhole.Consume((Half) arg2);\r\n        Blackhole.Consume((Half) arg3);\r\n        Blackhole.Consume((Half) arg4);\r\n    }\r\n}\r\n```\r\n\r\n### Alternative Designs\r\n\r\nWithout any new APIs - Pass the value to a method with `NoInlining`, or write to a field. Both of these have some overhead.\r\n\r\nAlternative new APIs (discussed in comments below):\r\n\r\n```cs\r\nnamespace System.Runtime.CompilerServices;\r\n\r\npublic static class BlackBox\r\n{\r\n    public static T Identity\u003cT\u003e(scoped T value) where T : allows ref struct;\r\n    public static ref readonly T Identity\u003cT\u003e(scoped ref readonly T value) where T : allows ref struct;\r\n    public static unsafe void* Identity(void* value);\r\n}\r\n```\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOhOMa4w==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6ExUjU",
                                           "createdAt":  "2024-07-14T23:43:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-numerics\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-07-14T23:43:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ExWyR",
                                           "createdAt":  "2024-07-15T00:09:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "I don\u0027t think there\u0027d be any point to a `T*` version if we have a `void*` version (since the conversion is a no-op at IL level). It would also be good to have a version that takes `ref T` though (still with the `where T : allows ref struct`) so we can consume references without having to create a ByRef struct just to pass to this API or similar.",
                                           "updatedAt":  "2024-07-15T00:17:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ExXdy",
                                           "createdAt":  "2024-07-15T00:15:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime-compilerservices\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-07-15T00:15:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ExYFi",
                                           "createdAt":  "2024-07-15T00:20:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "\u003e I don\u0027t think there\u0027d be any point to a `T*` version if we have a `void*` version (since the conversion does not need to be performed at IL level).\r\n\r\n\u003cs\u003eThis is true, but the `T*` version is just more ergonomic. Otherwise you\u0027d have to add the cast to your code.\u003c/s\u003e [Edit] I just tried it, and I was wrong. No cast is necessary. I will update the proposal to remove that.\r\n\r\nIdeally it would just be a single API with an extra `allows pointer` anti-constraint, but that doesn\u0027t exist currently.\u003c/s\u003e\r\n\r\n\u003e It would also be good to have a version that takes `ref T` though (still with the `where T : allows ref struct`) so we can consume references without having to create a ByRef struct just to pass to this API or similar.\r\n\r\nThat\u0027s not necessary.\r\n\r\n```cs\r\nref int target = ref myArray[0];\r\nBlackhole.Consume(target);\r\n```",
                                           "updatedAt":  "2024-07-15T00:23:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ExYvz",
                                           "createdAt":  "2024-07-15T00:25:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODptirA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "timcassell",
                                                                               "createdAt":  "2024-07-15T00:31:28Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "\u003e This is true, but the `T*` version is just more ergonomic. Otherwise you\u0027d have to add the cast to your code. Ideally it would just be a single API with an extra `allows pointer` anti-constraint, but that doesn\u0027t exist currently.\r\n\r\nThat\u0027s not true - you don\u0027t have to explicitly cast to `void*` (it\u0027s an implicit cast in c#).\r\n\r\n\u003e That\u0027s not necessary.\r\n\u003e \r\n\u003e ```cs\r\n\u003e ref int target = ref myArray[0];\r\n\u003e Blackhole.Consume(target);\r\n\u003e ```\r\n\r\nThis is not behaviourally or conceptually the same as `Blackhole.Consume(ref target)` - the former explicitly dereferences the byref (which is not a no-op necessarily, for example it can throw in some cases), and is equivalent to (ignoring array covariance) `Blackhole.Consume(myArray[0])` from the runtime\u0027s perspective. `Blackhole.Consume(ref x)` would consume the by-reference itself, whereas `Blackhole.Consume(x)` just consumes `x`.",
                                           "updatedAt":  "2024-07-15T00:26:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ExZmQ",
                                           "createdAt":  "2024-07-15T00:32:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODptiwQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hamarb123",
                                                                               "createdAt":  "2024-07-15T00:32:32Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "timcassell",
                                           "body":  "You are correct, I updated the proposal.",
                                           "updatedAt":  "2024-07-15T00:32:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ExhyJ",
                                           "createdAt":  "2024-07-15T01:36:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "Should it be `in T` rather than `ref T`? `ref` can go to `in`, but not vice-versa without `Unsafe`.",
                                           "updatedAt":  "2024-07-15T01:36:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ExiU4",
                                           "createdAt":  "2024-07-15T01:40:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "From the runtime\u0027s perspective, `in T` and `ref T` are the same. This may lead to the issue where you pass something by in and expect the method to treat it as if the ref can\u0027t be mutated, but the runtime will most likely not implement it this way (as they\u0027re all just `T\u0026` to it). I would add it to the open questions section, and leave it with `ref` (since it\u0027s technically more correct).\r\n\r\nAlso, `ref readonly` would be better suited for this than `in`.",
                                           "updatedAt":  "2024-07-15T01:42:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Exxcq",
                                           "createdAt":  "2024-07-15T03:23:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e prevent dead code elimination and out-of-order instructions generated by a compiler (not by the CPU\r\n\r\nIs this actually useful if it does not prevent out-of-order execution done by the CPU?\r\n\r\nI think writing the value into a globally visible field to establish data dependency has better fidelity for micro-benchmarking purposes.",
                                           "updatedAt":  "2024-07-15T03:23:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ExznC",
                                           "createdAt":  "2024-07-15T03:37:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODpxEtQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-07-15T12:36:09Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "timcassell",
                                           "body":  "\u003e Is this actually useful if it does not prevent out-of-order execution done by the CPU?\r\n\u003e \r\n\u003e I think writing the value into a globally visible field to establish data dependency has better fidelity for micro-benchmarking purposes.\r\n\r\nThe idea is for this to be zero cost. As I understand it, barriers that prevent cpu instruction reordering are not free. Anyway, I don\u0027t think it\u0027s unrealistic for real-world code to do calculations without barriers (storing results in locals instead of fields), so the micro-benchmarks should be fine, I think.\r\n\r\nAlso, refs and ref structs cannot be written to globally visible fields, so even if we were to have that behavior, the runtime would need to treat them the same. That is currently not possible without runtime support.",
                                           "updatedAt":  "2024-07-15T03:44:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Ex4Yp",
                                           "createdAt":  "2024-07-15T04:08:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e The idea is for this to be zero cost.\r\n\r\nWhy does it matter whether this is zero cost? The benchmarking frameworks typically subtract the setup costs from the absolute number. The cost of establishing the global data dependency can be included in the setup costs.\r\n\r\n\u003e Also, refs and ref structs cannot be written to globally visible fields\r\n\r\nBenchmark.NET can cast ref into a pointer or write the ref struct as raw bytes into a globally visible field to establish the data dependency. Yes, microbenchmarking is hard.",
                                           "updatedAt":  "2024-07-15T04:08:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Ex7z3",
                                           "createdAt":  "2024-07-15T04:30:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "\u003e Why does it matter whether this is zero cost? The benchmarking frameworks typically subtract the setup costs from the absolute number. The cost of establishing the global data dependency can be included in the setup costs.\r\n\r\nBecause this is meant to be used in the benchmark method itself, not just as part of the benchmark framework. I put an example in the OP. Here\u0027s another simple one:\r\n\r\n```cs\r\nforeach (var item in collection)\r\n{\r\n    Blackhole.Consume(item);\r\n}\r\n```\r\n\r\n\u003e Yes, microbenchmarking is hard.\r\n\r\nAnd this API should make it slightly easier.\r\n\r\n\u003e write the ref struct as raw bytes\r\n\r\nHow?",
                                           "updatedAt":  "2024-07-15T04:35:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EyBU3",
                                           "createdAt":  "2024-07-15T05:03:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "What are the chances that the speculative execution done by the processor is going to skew the results a lot if this API is not establishing data dependency? I suspect that the patterns you are proposing would not produce reliable microbenchmarks for modern processors.\r\n\r\n\u003e \u003e write the ref struct as raw bytes\r\n\r\n\u003e How?\r\n\r\nI was originally thinking about taking address of the struct as unmanaged pointer, but it is probably not the best idea. Establishing data dependency for each field of the ref struct is probably a better solution.",
                                           "updatedAt":  "2024-07-15T05:03:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EyFyz",
                                           "createdAt":  "2024-07-15T05:26:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "\u003e What are the chances that the speculative execution done by the processor is going to skew the results a lot if this API is not establishing data dependency? I suspect that the patterns you are proposing would not produce reliable microbenchmarks for modern processors.\r\n\r\nI don\u0027t understand how speculative execution impacts this. In my mind, it\u0027s the same as writing the value to a local instead of a field.\r\n\r\nAnyway, I\u0027m curious what @EgorBo thinks of having a barrier, since this was originally his idea.",
                                           "updatedAt":  "2024-07-15T05:27:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6E1GkT",
                                           "createdAt":  "2024-07-15T13:30:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODpzpnQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jasper-d",
                                                                               "createdAt":  "2024-07-15T17:33:22Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "julealgon",
                                           "body":  "Really dislike this name. Isn\u0027t there something more semantic that could be used instead?",
                                           "updatedAt":  "2024-07-15T13:30:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6E35JC",
                                           "createdAt":  "2024-07-15T19:37:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Windows10CE",
                                           "body":  "For further prior art (and an argument for a different signature) I\u0027d like to point to [Rust\u0027s std::hint::black_box](https://doc.rust-lang.org/std/hint/fn.black_box.html) which has a similar goal of inhibiting some kinds of optimizations while benchmarking.\n\nI think this API doubling as the identity function is very useful, and allows things Blackhole does not, for example `BlackBox(5u / BlackBox(2u));` generates a div instead of being completely optimized away or using a shift, or the more complex example in the Rust docs. (You can also just ignore the return value to get the same effect as the original proposed API)\n\nI also happen to think it\u0027s a better name, but that\u0027s purely subjective.",
                                           "updatedAt":  "2024-07-15T19:51:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6E38__",
                                           "createdAt":  "2024-07-15T19:48:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Windows10CE",
                                           "body":  "I\u0027d also like to mention you can recreate this behavior without using NoInlining as long as the type you\u0027re talking about is supported by Volatile, see [this example](https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA0AXEBDAzgWwB8ABABgAJiBGAOgCUBXAOwwEt8YaBhCfAB1YAbGFADKIgG6swMXAG4AsACgylWgBUAFrGwATVkwDmilQGZKAJnJdyAb2XlHlc9SSUU5ALIAKAJR2HJycAIUFsMABrYIgEbwBWBnIAenJQ8KiY7wsGX18TIIBfQMdi8gBtUQjWPgAZCDBsQVwASSZWDABdUuIXKjcGAwxUsMjo2IGWcgxfUvslIKCAVSZcbAAzTkrq1vbvCAYhiaGMGH480qCANQgwtmEaAHUodphvWDWp0740KfP5hccxAA7ORrrchJw6DA9G8YB8Tmd8k4ikoCkA===)",
                                           "updatedAt":  "2024-07-15T19:48:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6E4u1N",
                                           "createdAt":  "2024-07-15T21:22:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "@Windows10CE That\u0027s interesting, I didn\u0027t think about the effects of constant optimization in the benchmark. Tbh, I think it\u0027s simply better to pass those constants in as arguments to the benchmark method, but I can see the usefulness of that for someone who wants to write their own raw benchmark without using a benchmarking framework.\r\n\r\nWe can\u0027t use global functions in C#, so what should the C# API be? `BlackBox.Identity`?\r\n\r\nAlso, too bad we don\u0027t have `where T : allows pointer` anti-constraint. `T*** Identity\u003cT\u003e(T*** value)`. 😅 \r\n\r\n\u003e I\u0027d also like to mention you can recreate this behavior without using NoInlining as long as the type you\u0027re talking about is supported by Volatile, see [this example](https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA0AXEBDAzgWwB8ABABgAJiBGAOgCUBXAOwwEt8YaBhCfAB1YAbGFADKIgG6swMXAG4AsACgylWgBUAFrGwATVkwDmilQGZKAJnJdyAb2XlHlc9SSUU5ALIAKAJR2HJycAIUFsMABrYIgEbwBWBnIAenJQ8KiY7wsGX18TIIBfQMdi8gBtUQjWPgAZCDBsQVwASSZWDABdUuIXKjcGAwxUsMjo2IGWcgxfUvslIKCAVSZcbAAzTkrq1vbvCAYhiaGMGH480qCANQgwtmEaAHUodphvWDWp0740KfP5hccxAA7ORrrchJw6DA9G8YB8Tmd8k4ikoCkA===)\r\n\r\nCool. I bet we could use the new `Volatile.WriteBarrier()` API when it gets implemented to make it work with any type (#98837).",
                                           "updatedAt":  "2024-07-15T21:22:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6E4xrj",
                                           "createdAt":  "2024-07-15T21:31:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODp1m2A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "timcassell",
                                                                               "createdAt":  "2024-07-15T21:57:19Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Windows10CE",
                                           "body":  "\u003e Cool. I bet we could use the new Volatile.WriteBarrier() API when it gets implemented to make it work with any type\n\nI tried with Interlocked.MemoryBarrier() (which is strictly stronger than WriteBarrier) and it didn\u0027t work, so I\u0027d assume that won\u0027t work either. Even that trick is liable to being optimized out at some point I think, it just works right now for anyone looking for a solution in this issue (and I believe all past versions)\n\nI like BlackBox.Identity with the same three overloads in the original proposal if we\u0027re open to this becoming an intrinsic",
                                           "updatedAt":  "2024-07-15T21:31:47Z"
                                       }
                                   ],
                         "totalCount":  19
                     },
        "title":  "[API Proposal]: Blackhole",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.CompilerServices",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/104909",
        "createdAt":  "2024-07-15T17:30:57Z",
        "number":  104909,
        "author":  "redknightlois",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC_LCmQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "BoyBaykiller",
                                            "createdAt":  "2024-08-20T16:50:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "h3xds1nz",
                                            "createdAt":  "2025-02-17T19:27:33Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2024-07-18T21:02:52Z",
        "body":  "### Background and motivation\n\nThe `Unsafe` class provides various methods for working with references in an unsafe manner for `ref T`. However, there are missing operations for handling `ref readonly` references, such as `AddByteOffset`. Currently, there is a need to use `Unsafe.AsRef` to convert `ref readonly` to `ref`, which adds unnecessary steps.\r\n\r\nProposal:\r\n\r\nI propose the addition of `ref readonly` reference handling operations to the `Unsafe class` where the guarantees are still valid in order to avoid users to use `Unsafe.AsRef` when those guarantees could introduce subtle bugs. Specifically, unless I am missing something, methods such as `AddByteOffset` should directly support `ref readonly` references without requiring a call to `Unsafe.AsRef`.\r\n\r\nExtending the `Unsafe` class to support `ref readonly` aligns with the existing pattern used alongside the `Vector` API which supports the used of both `ref` and `readonly ref` in operations where no side-effects exist.\r\n\n\n### API Proposal\n\n```csharp\r\npublic static ref readonly T AddByteOffset\u003cT\u003e(scoped ref readonly T source, IntPtr byteOffset);\r\npublic static ref readonly T SubstractByteOffset\u003cT\u003e(scoped ref readonly T source, IntPtr byteOffset);\r\npublic static ref readonly T Add\u003cT\u003e(scoped ref readonly T source, int offset);\r\npublic static ref readonly T Substract\u003cT\u003e(scoped ref readonly T source, int offset);\r\n```\r\n\n\n### API Usage\n\nThis is how I do this now:\r\n```csharp\r\ninternal static int CompareAvx256(scoped in byte p1, scoped in byte p2, int size)\r\n{\r\n    ref byte bpx = ref Unsafe.AsRef(in p1);\r\n    ref byte bpy = ref Unsafe.AsRef(in p2);\r\n    ref byte bpxEnd = ref Unsafe.AddByteOffset(ref bpx, size);\r\n    ....    \r\n}\r\n```\r\n\r\nWe should be able to keep the `ref readonly` guarantee on those references.\r\n \r\n```csharp\r\ninternal static int CompareAvx256(scoped in byte p1, scoped in byte p2, int size)\r\n{\r\n    ref readonly byte bpx = ref readonly p1;\r\n    ref readonly byte bpy = ref readonly p2;\r\n    ref readonly byte bpxEnd = ref Unsafe.AddByteOffset(ref readonly bpx, size);\r\n    ....    \r\n}\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOhSg_ww==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6E3FZT",
                                           "createdAt":  "2024-07-15T17:31:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime-compilerservices\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-07-15T17:31:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6E3H5d",
                                           "createdAt":  "2024-07-15T17:37:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e I propose the addition of ref readonly reference handling operations to the Unsafe class\n\nWe can\u0027t overload on ref vs ref readonly, e.g. [SharpLab](https://sharplab.io/#v2:EYLgtghglgdgPgAQEwEYCwAoBBmABM3AYV0wG9NdL88EUA2XAJwFMAzXAFVwEEATXgEIBPAC7MA8q1YBnZiIA8HAHwAKFuy7SA9gFdGAY2YAaXAEkYIgAojGuYKIlTZIgJS4AvEqZtc2vYYBuCiocfHpvdhYIXi0YABshTh5+YTFJGTlFVXVvaNiEpL8DYzMLa1t7NKc5N08I311ioIwAXyA)",
                                           "updatedAt":  "2024-07-15T17:37:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6E5LC3",
                                           "createdAt":  "2024-07-15T22:56:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "redknightlois",
                                           "body":  "Good point that would require changing the public API to `ref readonly` instead.",
                                           "updatedAt":  "2024-07-15T22:56:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6E6VtG",
                                           "createdAt":  "2024-07-16T02:32:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "\u003e Good point that would require changing the public API to `ref readonly` instead.\r\n\r\nIf the return value is `ref readonly`, it can\u0027t be used as `ref`.\r\nGiven it\u0027s already in `Unsafe` space, additional `Unsafe.AsRef` won\u0027t be too dangerous.",
                                           "updatedAt":  "2024-07-16T02:32:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6FCZHw",
                                           "createdAt":  "2024-07-16T23:42:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xtqqczze",
                                           "body":  "\u003e Good point that would require changing the public API to `ref readonly` instead.\r\n\r\nAnd this would be a breaking change.",
                                           "updatedAt":  "2024-07-16T23:42:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6FC3YJ",
                                           "createdAt":  "2024-07-17T01:20:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "Changing inputs to `ref readonly` isn\u0027t a breaking change, actually. We explicitly have compatibility so that migration from `ref -\u003e ref readonly` and `in -\u003e ref readonly` is safe.\r\n\r\nIf this were done it would have to be such that inputs are `ref readonly` and outputs are `ref`, which makes the signatures overall the most usable, but also makes them \"more dangerous\" since every operation works like `ref T Unsafe.As\u003cT\u003e(ref readonly T value)` is implicitly wrapping it.\r\n\r\nThere\u0027s both pros and cons to doing that and I don\u0027t think we\u0027ve had an in-depth discussion on whether that is better or worse; but I imagine it will be contentious discussion to have with people landing on both sides of the coin.",
                                           "updatedAt":  "2024-07-17T01:20:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6FGbko",
                                           "createdAt":  "2024-07-17T11:14:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "redknightlois",
                                           "body":  "I would certainly would be on the side of: \"If it doesn\u0027t return `ref readonly` it defeats the purpose and be dangerous for no reason\". It is clearly an overload situation that would either require support at the language level or entirely new method name. ",
                                           "updatedAt":  "2024-07-17T11:15:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6FKD_D",
                                           "createdAt":  "2024-07-17T18:42:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "We can\u0027t overload like that due to the representation in IL and because we want the transition from `ref` to `ref readonly` to be possible in a non-breaking manner\r\n\r\nIt\u0027s something where it\u0027s either going to stay \"as is\", where we\u0027d have `ref T Add(ref readonly T address, int offset)`, or where we\u0027d need some new \"matched mutability\" language feature so that we could say that the return type has the same mutability as the input type.",
                                           "updatedAt":  "2024-07-17T18:42:35Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "[API Proposal]: Missing `scoped ref readonly` and `in` reference handling at Unsafe reference",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.CompilerServices",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/105400",
        "createdAt":  "2024-07-24T13:36:15Z",
        "number":  105400,
        "author":  "colejohnson66",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC5vIpQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_DOWN",
                                            "user":  "teo-tsirpanis",
                                            "createdAt":  "2024-07-24T13:55:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_DOWN",
                                            "user":  "julealgon",
                                            "createdAt":  "2024-07-24T19:28:18Z"
                                        },
                                        {
                                            "content":  "THUMBS_DOWN",
                                            "user":  "Sin-Shadow-Fox",
                                            "createdAt":  "2024-07-26T22:25:11Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2024-12-27T07:21:56Z",
        "body":  "### Background and motivation\r\n\r\nMany generic types have static, non-generic, classes with a `Create` helper method. This allows the compiler to infer the generic argument. `StrongBox\u003cT\u003e` does not.\r\n\r\nArguably, since `StrongBox\u003cT\u003e` is in `System.Runtime.CompilerServices`, it should not be used by user code. However, it is a useful type in multithreaded code as it allows atomic updates (by nature of being heap allocated), and avoids boxing/unboxing overhead; only an allocation. The unboxing overhead can be eliminated with `Unsafe.Unbox`, but, as the name suggests, it\u0027s an unsafe API.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Runtime.CompilerServices;\r\n\r\npublic static class StrongBox\r\n{\r\n    public static StrongBox\u003cT\u003e Create\u003cT\u003e(T value);\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\nOld code:\r\n\r\n```csharp\r\nInterlocked.Exchange(ref _currentValue, new StrongBox\u003cdecimal\u003e(newValue));\r\n```\r\n\r\nNew code:\r\n\r\n```csharp\r\nInterlocked.Exchange(ref _currentValue, StrongBox.Create(newValue));\r\n```\r\n\r\nSure, target-typed `new` could be used on the old code, but some people disable that lint if the target type is not evident.\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOmMp3xQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6GAmla",
                                           "createdAt":  "2024-07-24T15:27:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime-compilerservices\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-07-24T15:27:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GCTRX",
                                           "createdAt":  "2024-07-24T19:28:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODr8Xjw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "rjgotten",
                                                                               "createdAt":  "2024-07-29T11:29:02Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "julealgon",
                                           "body":  "Why do we keep adding factory methods like this to the public API instead of just adding generic type inference to constructors?\r\n\r\nSeems like such a low-hanging fruit at this point that would increase consistency in the language with not-so-much effort (considering there is already generic type inference in methods), and would finally remove the need for this whole \"class\" of dumbh factory methods that were added just to circumvent the lack of generic type inference in constructors, like `KeyValuePair.Create`, `Tuple.Create` (back then when we still used reference tuples...), etc.\r\n\r\nFactory methods should only be needed when they add valuable semantics to the code IMHO (e.g. `TimeSpan.FromSeconds`). This is not one of those cases.\r\n",
                                           "updatedAt":  "2024-07-24T19:28:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6YynfF",
                                           "createdAt":  "2024-12-27T07:21:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "\u003e adding generic type inference to constructors\n\nThere is a proposal at \u003chttps://github.com/dotnet/csharplang/discussions/281\u003e.\n",
                                           "updatedAt":  "2024-12-27T07:21:55Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "[API Proposal]: `StrongBox.Create`",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.CompilerServices",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/105435",
        "createdAt":  "2024-07-24T23:03:38Z",
        "number":  105435,
        "author":  "AaronRobinsonMSFT",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC8wz6g==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lambdageek",
                                            "createdAt":  "2024-07-25T13:34:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hamarb123",
                                            "createdAt":  "2024-09-28T03:09:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Enderlook",
                                            "createdAt":  "2024-11-18T22:03:52Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2025-07-14T18:19:53Z",
        "body":  "### Background and motivation\r\n\r\nDue to the non-boxing requirment of ByRefLike types, it is complicated to express generic IL instructions for methods where the `allows ref struct` constraint is applied, given existing semantics of certain IL instructions. This is particularly limiting when attempting an \"is-type\" check (that is, `x is Y y`). These APIs will be provided and their semantics defined in coordination with the Roslyn team to help us avoid augmenting the definitions of certain IL instruction, in specific sequences - see option two in the below design notes. ECMA-335 doesn\u0027t dictate details of .NET APIs, so adding APIs avoids any ECMA-335 augmentation with respect to IL instruction semantics.\r\n\r\nSee further design notes in [byreflike-generics.md](https://github.com/dotnet/runtime/blob/main/docs/design/features/byreflike-generics.md).\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public static class RuntimeHelpers\r\n    {\r\n        // Replacement for the [box; isinst; brfalse/true] sequence.\r\n        public static bool IsInstanceOf\u003cTFrom, TTo\u003e(TFrom source)\r\n            where TFrom: allows ref struct\r\n            where TTo: allows ref struct;\r\n\r\n        // Replacement for the [box; isinst; unbox.any] sequence.\r\n        // Would throw InvalidCastException for invalid use at run-time.\r\n        // For example:\r\n        //  TFrom: RS, TTo: object      =\u003e always throws\r\n        //  TFrom: RS, TTo: \u003cinterface\u003e =\u003e always throws\r\n        public static TTo CastTo\u003cTFrom, TTo\u003e(TFrom source)\r\n            where TFrom: allows ref struct\r\n            where TTo: allows ref struct;\r\n    }\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\nThis API is not meant to be used directly by user code. It called by Roslyn generated code to perform \"is-type\" checks involving ByRefLike types.\r\n\r\nInstead of the following IL sequences for \"is-type\":\r\n\r\n```IL\r\n// Type check\r\nldarg.0\r\n    box \u003cSource\u003e\r\n    isinst \u003cTarget\u003e\r\n    brfalse.s NOT_INST\r\n\r\n// Unbox and store unboxed instance\r\nldarg.0\r\n    box \u003cSource\u003e\r\n    isinst \u003cTarget\u003e\r\n    unbox.any \u003cTarget\u003e\r\nstloc.X\r\n\r\nNOT_INST:\r\n```\r\n\r\nThe following C# will now be possible:\r\n\r\n```csharp\r\nTTo result;\r\nif (RuntimeHelpers.IsInstanceOf\u003cTFrom, TTo\u003e(source))\r\n{\r\n    result = RuntimeHelpers.CastTo\u003cTFrom, TTo\u003e(source);\r\n}\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nThe troublesome IL sequences can be identified to support ByRefLike types when detected by the JIT or Interpreter. This requires changing the semantic meaning of some IL instructions, but only in certain sequences and then updating ECMA-335. This was the approach attempted in .NET 9 and has proven to be very difficult to reconcile with the broader ecosystem with the needed language.\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOlBKhjA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6GDYuu",
                                           "createdAt":  "2024-07-24T23:03:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime-compilerservices\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-07-24T23:03:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GDY7U",
                                           "createdAt":  "2024-07-24T23:04:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "/cc @jkotas @jaredpar @AlekseyTs @lambdageek @fanyang-mono @davidwrighton @MichalStrehovsky ",
                                           "updatedAt":  "2024-07-24T23:04:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GIbYi",
                                           "createdAt":  "2024-07-25T13:42:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lambdageek",
                                           "body":  "1. \r\n\r\n```csharp\r\n  public static TTo CastTo\u003cTFrom, TTo\u003e(TFrom source)\r\n            where TFrom: allows ref struct\r\n            where TTo: allows ref struct;\r\n```\r\n\r\nWould it be more helpful to have the same signature as `ref TTo Unsafe.As\u003cTFrom,TTo\u003e(ref TFrom source) where TFrom: allows ref struct where TTo: allows ref struct` ?\r\n\r\n2. Do we need both `IsInstanceOf` and `CastTo`?  would it be ok to just have one intrinsic that either returns `ref source` or a null reference?",
                                           "updatedAt":  "2024-07-25T13:46:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GJBNO",
                                           "createdAt":  "2024-07-25T14:42:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e Would it be more helpful to have the same signature as ref TTo Unsafe.As\u003cTFrom,TTo\u003e(ref TFrom source) where TFrom: allows ref struct where TTo: allows ref struct ?\r\n\r\nAgree, the `ref`s might make more sense.\r\n\r\n\u003e Do we need both IsInstanceOf and CastTo? would it be ok to just have one intrinsic that either returns ref source or a null reference?\r\n\r\nYes, we need both since we can\u0027t return `null` if `TTo` can be ByRefLike. That is basically the fundamental issue with the `isinst` insrtuction.",
                                           "updatedAt":  "2024-07-25T14:42:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GJhWs",
                                           "createdAt":  "2024-07-25T15:15:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Agree, the refs might make more sense.\r\n\r\nI do not think that it works well with `Nullable\u003c\u003e`.",
                                           "updatedAt":  "2024-07-25T15:15:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GLgwe",
                                           "createdAt":  "2024-07-25T18:37:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lambdageek",
                                           "body":  "\u003e Yes, we need both since we can\u0027t return `null` if `TTo` can be ByRefLike. That is basically the fundamental issue with the `isinst` insrtuction.\r\n\r\nI meant if we have a single `TryCastTo` operation that takes a `ref TFrom` and returns `ref TTo`:\r\n\r\n```csharp\r\n  ref TTo TryCastTo\u003cTFrom,TTo\u003e(ref TFrom source);\r\n```\r\n\r\nCan\u0027t we return a null reference on failure?  We have `ref T Unasfe.NullRef\u003cT\u003e() where T : allows ref struct`. So a null reference of a byreflike seems like something we support elsewhere.\r\n\r\nBut I see this won\u0027t work because...\r\n\r\n\u003e I do not think that it works well with Nullable\u003c\u003e\r\n\r\nI see. Because if I have `int? x` then `IsInstanceOf\u003cint?, int\u003e(x)` should be `true` and `CastTo\u003cint?, int\u003e(x)` should do the unboxing. It\u0027s not always an identity like `Unsafe.As`\r\n\r\nIn that case I think these operations need better names.",
                                           "updatedAt":  "2024-07-25T18:37:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GLlEQ",
                                           "createdAt":  "2024-07-25T18:47:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e I see. Because if I have int? x then IsInstanceOf\u003cint?, int\u003e(x) should be true and CastTo\u003cint?, int\u003e(x) should do the unboxing. It\u0027s not always an identity like Unsafe.As\r\n\r\nCan\u0027t we just define the semantics as the Rolsyn team prefers? I don\u0027t see why the `Nullable\u003c\u003e` doesn\u0027t work in this case. Or was that specifically for the `TryCastTo` example?",
                                           "updatedAt":  "2024-07-25T18:47:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GLsbH",
                                           "createdAt":  "2024-07-25T19:04:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODrmnTQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2024-07-25T19:11:51Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2024-07-25T19:51:17Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "lambdageek",
                                           "body":  "\u003e Or was that specifically for the `TryCastTo` example?\r\n\r\nyes, I meant my `TryCastTo` suggestion won\u0027t work with nullables - as Jan pointed out - since in that case we want to actually do an unboxing, not just return the input but with a different type.",
                                           "updatedAt":  "2024-07-25T19:04:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GL-pk",
                                           "createdAt":  "2024-07-25T19:53:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Can\u0027t we just define the semantics as the Roslyn team prefers?\r\n\r\nRight. These APIs are specifically designed to support Roslyn pattern matching. The APIs are not meant to be callable by the ordinary user code (nothing prevents that though). The API proposal should mention that.\r\n\r\nThis:\r\n```csharp\r\nU M\u003cT, U\u003e(T t) where T: allows ref struct where U: allows ref struct\r\n{\r\n    if (t is U u)\r\n        return u;\r\n    return default;\r\n}\r\n```\r\n\r\nis going to be lower by Roslyn into something like this:\r\n\r\n```csharp\r\nU M\u003cT, U\u003e(T t) where T: allows ref struct where U: allows ref struct\r\n{\r\n    if (RuntimeHelpers.IsInstanceOf\u003cT,U\u003e(t))\r\n    {\r\n        U u = RuntimeHelpers.CastTo\u003cT,U\u003e(t);\r\n        return u;\r\n    }\r\n    return default;\r\n}\r\n```\r\n\r\nThe APIs need to maintain the behavior of the existing C# pattern matching that dictates how they need to behave for non-byref like types. It is why it is not feasible to change the arguments to byrefs (consider `RuntimeHelpers.CastTo\u003cint,int?\u003e` with byref arguments).",
                                           "updatedAt":  "2024-07-27T18:28:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GL-5E",
                                           "createdAt":  "2024-07-25T19:53:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODrmqVQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2024-07-25T19:57:36Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e In that case I think these operations need better names.\r\n\r\nI agree we may need better names. Are there names we can borrow from C# spec?",
                                           "updatedAt":  "2024-07-25T19:53:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6N3QE_",
                                           "createdAt":  "2024-09-27T21:17:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "What happened to the \"Special IL sequences\"? Will they still be supported? Will they be emitted on .NET 9 only? Are they going to be added to the ECMA-335 addendum? Thanks!",
                                           "updatedAt":  "2024-09-27T21:17:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6N3Rt7",
                                           "createdAt":  "2024-09-27T21:24:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e What happened to the \"Special IL sequences\"? Will they still be supported? Will they be emitted on .NET 9 only? Are they going to be added to the ECMA-335 addendum? Thanks!\r\n\r\nThe special IL sequences were not implemented and their specification removed. These APIs are designed to avoid the complexity that we faced in trying to special case these IL sequences and reconcile them with higher level language semantics.",
                                           "updatedAt":  "2024-09-27T21:25:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6N3Zj8",
                                           "createdAt":  "2024-09-27T21:42:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "So, presumably you will not be able to write code that would require such constructs in 9, but will be able to in .NET 10 (using these APIs)?",
                                           "updatedAt":  "2024-09-27T21:44:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6N4G4v",
                                           "createdAt":  "2024-09-27T23:55:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODz6ZTA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hamarb123",
                                                                               "createdAt":  "2024-09-28T00:08:01Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "Yes, that is the current plan.",
                                           "updatedAt":  "2024-09-27T23:55:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6T3HCw",
                                           "createdAt":  "2024-11-16T18:12:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hez2010",
                                           "body":  "\u003e What happened to the \"Special IL sequences\"? Will they still be supported?\n\nIt\u0027s already working if you write IL manually: https://godbolt.org/z/rqKP71d6f",
                                           "updatedAt":  "2024-11-16T18:12:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6T3J2g",
                                           "createdAt":  "2024-11-16T18:20:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD7MXbQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2024-11-16T21:21:01Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "The special IL sequences are invalid IL today. Invalid IL has undefined behavior. It may appear to work, but it is not guaranteed to work.",
                                           "updatedAt":  "2024-11-16T18:20:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6UEqGM",
                                           "createdAt":  "2024-11-18T22:16:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Enderlook",
                                           "body":  "Why not include?\n```cs\npublic static bool TryCastTo\u003cTFrom, TTo\u003e(TFrom source, out TTo destination)\n    where TFrom: allows ref struct\n    where TTo: allows ref struct;\n```\nDoing so would save one check, otherwise `IsInstanceOf` does a check, and `CastTo` checks again.\nAnd unlike returning `ref TTo` this would probably have issues no with `Nullable\u003cT\u003e`, right?",
                                           "updatedAt":  "2024-11-18T22:16:59Z"
                                       }
                                   ],
                         "totalCount":  17
                     },
        "title":  "[API Proposal]: Methods to support ByRefLike types in \"is-type\" IL sequences",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.CompilerServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/105586",
        "createdAt":  "2024-07-27T06:03:53Z",
        "number":  105586,
        "author":  "jkotas",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODDFeIQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-07-27T15:47:51Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jaredpar",
                                            "createdAt":  "2024-07-27T19:50:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "adamsitnik",
                                            "createdAt":  "2024-07-29T17:05:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MitchRazga",
                                            "createdAt":  "2025-06-01T09:41:27Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2025-07-14T18:19:54Z",
        "body":  "### Background and motivation\r\n\r\nC# allows an implicit conversion of InlineArray to Span. To perform this implicit conversion, Roslyn emits calls of several unsafe methods today (`Unsafe.As`, `MemoryMarshal.CreateSpan`). \r\n\r\nExample: https://sharplab.io/#v2:CYLg1APgAgTAjAWAFBQAwAIpwHQCUCuAdgC4CWAtgKbYDCA9uQA6kA2lATgMocBupAxpQDOAbmTIoAFnQBZABQBKZAG9k6dQFFSAcwAWxDWyokh6Sjv2HKx4qYC86YJQBmAQ3wtiYpOvSdGroQAPKQkAHzoQgGE6A7megZGlCYivujIAL7iSADaAJKELKGUAILs7K4AnnIAHAoAushCxOz4/MToWglWNkIqar6hHZRJJN4ZQA===\r\n\r\nIn hindsight, we have realized that allowing Roslyn to produce unverifiable IL for safe C# is very slippery slope. Instead, we would like safe C# constructs to always produce IL that is verifiable using verification rules written in the same spirit as the existing ECMA-335 verification rules.\r\n\r\nThe proposed API enables Roslyn to perform the InlineArray to Span conversion without use of unsafe or unverifiable IL.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Runtime.CompilerServices;\r\n\r\npublic class RuntimeHelpers\r\n{\r\n    public static Span\u003cTElement\u003e InlineArrayAsSpan\u003cTInlineArray, TElement\u003e(ref TInlineArray inlineArray) where TInlineArray: allows ref struct;\r\n    public static ReadOnlySpan\u003cTElement\u003e InlineArrayAsReadOnlySpan\u003cTInlineArray, TElement\u003e(ref readonly TInlineArray inlineArray) where TInlineArray: allows ref struct;\r\n\r\n}\r\n```\r\n\r\n### API Usage\r\n\r\nThis API is not meant to be used directly by user code. It called by Roslyn generated code to perform InlineArray to Span conversion.\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\nThe API is intrinsic with non-trivial expansion logic.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOjPOxYQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6GVkiy",
                                           "createdAt":  "2024-07-27T06:04:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-memory\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-07-27T06:04:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GVk0q",
                                           "createdAt":  "2024-07-27T06:04:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Context: https://github.com/dotnet/runtime/pull/104870#discussion_r1684935295",
                                           "updatedAt":  "2024-07-27T06:04:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GVlGZ",
                                           "createdAt":  "2024-07-27T06:05:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime-compilerservices\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-07-27T06:05:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GVmLQ",
                                           "createdAt":  "2024-07-27T06:07:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "cc @jaredpar @AlekseyTs ",
                                           "updatedAt":  "2024-07-27T06:07:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GWqbi",
                                           "createdAt":  "2024-07-27T09:10:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODrztJg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2024-07-27T15:03:11Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "Even though it\u0027s only indended to be used by the compiler, perhaps it\u0027s better to name the generic parameters with a `T` as is the usual convention.\r\n```csharp\r\npublic static Span\u003cTElement\u003e InlineArrayAsSpan\u003cTInlineArray, TElement\u003e(ref TInlineArray inlineArray) where TInlineArray : allows ref struct, TElement : allows ref struct;\r\n```",
                                           "updatedAt":  "2024-07-27T15:03:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GXBRt",
                                           "createdAt":  "2024-07-27T15:39:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hez2010",
                                           "body":  "This API seems too tricky as we don\u0027t have a good way to constraint the inlineArray to be an actual InlineArray. \r\nIn the long term the right move would be allowing constants to be present in type parameters so that we can introduce a generic inline array type `ValueArray\u003cT, int Length\u003e` to serve as a fundamental type for all kinds of purpose. ",
                                           "updatedAt":  "2024-07-27T15:39:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GXBeP",
                                           "createdAt":  "2024-07-27T15:43:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e This API seems too tricky as we don\u0027t have a good way to constraint the inlineArray to be an actual InlineArray.\r\n\r\nThe implementation of the API would throw if `TInlineArray` is not inline array or if the element type does not match.",
                                           "updatedAt":  "2024-07-27T15:43:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GXCXt",
                                           "createdAt":  "2024-07-27T15:59:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "Is there something blocking the verifier from recognizing the pattern and understanding its safe for `InlineArray`?\r\n\r\nThe API proposed here seems fine to me, just noting that I\u0027d expect the verifier could also understand the existing pattern and make it verifiable.\r\n\r\nRoslyn could itself also skip the `Unsafe.As` in the case the backing field of the InlineArray was public, as it could just `MemoryMarshal.CreateSpan(ref buffer.element, 8)` (which should be equally trivial to verify).",
                                           "updatedAt":  "2024-07-27T15:59:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GXDgW",
                                           "createdAt":  "2024-07-27T16:16:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODr0Lhg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tannergooding",
                                                                               "createdAt":  "2024-07-27T18:02:16Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-07-27T18:09:11Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Is there something blocking the verifier from recognizing the pattern and understanding its safe for InlineArray?\r\n\r\nIt is possible, but the verification rule would not be anything like what exists today. All current verification rules are method local. The current pattern used by Roslyn is spread over two methods, so the verification rule would have to talk about multiple method bodies at the same time.",
                                           "updatedAt":  "2024-07-27T16:16:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Gbt7b",
                                           "createdAt":  "2024-07-29T09:14:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODr-XVw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2024-07-29T14:49:31Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "timcassell",
                                           "body":  "\u003e `TElement: allows ref struct`\r\n\r\nI thought `Span\u003cT\u003e` doesn\u0027t support ref struct elements due to issues. Is that changing?",
                                           "updatedAt":  "2024-07-29T14:49:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6MpGvD",
                                           "createdAt":  "2024-09-18T22:48:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AlekseyTs",
                                           "body":  "Here are the helpers that compiler synthesizes to work with inline arrays. Consider adding corresponding intrinsic APIs:\r\n\r\n```\r\nSystem.Span\u003cTElement\u003e InlineArrayAsSpan\u003cTBuffer, TElement\u003e(ref TBuffer buffer, System.Int32 length)\r\n{\r\n  // Code size       13 (0xd)\r\n  .maxstack  2\r\n  IL_0000:  ldarg.0\r\n  IL_0001:  call       \"\"ref TElement System.Runtime.CompilerServices.Unsafe.As\u003cTBuffer, TElement\u003e(ref TBuffer)\"\"\r\n  IL_0006:  ldarg.1\r\n  IL_0007:  call       \"\"System.Span\u003cTElement\u003e System.Runtime.InteropServices.MemoryMarshal.CreateSpan\u003cTElement\u003e(scoped ref TElement, int)\"\"\r\n  IL_000c:  ret\r\n}\r\n```\r\n\r\n```\r\nSystem.ReadOnlySpan\u003cTElement\u003e InlineArrayAsReadOnlySpan\u003cTBuffer, TElement\u003e(in TBuffer buffer, System.Int32 length)\r\n{\r\n  // Code size       18 (0x12)\r\n  .maxstack  2\r\n  IL_0000:  ldarg.0\r\n  IL_0001:  call       \"\"ref TBuffer System.Runtime.CompilerServices.Unsafe.AsRef\u003cTBuffer\u003e(scoped ref readonly TBuffer)\"\"\r\n  IL_0006:  call       \"\"ref TElement System.Runtime.CompilerServices.Unsafe.As\u003cTBuffer, TElement\u003e(ref TBuffer)\"\"\r\n  IL_000b:  ldarg.1\r\n  IL_000c:  call       \"\"System.ReadOnlySpan\u003cTElement\u003e System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan\u003cTElement\u003e(scoped ref readonly TElement, int)\"\"\r\n  IL_0011:  ret\r\n}\r\n```\r\n\r\n```\r\nref TElement InlineArrayElementRef\u003cTBuffer, TElement\u003e(ref TBuffer buffer, System.Int32 index)\r\n{\r\n  // Code size       13 (0xd)\r\n  .maxstack  2\r\n  IL_0000:  ldarg.0\r\n  IL_0001:  call       \"\"ref TElement System.Runtime.CompilerServices.Unsafe.As\u003cTBuffer, TElement\u003e(ref TBuffer)\"\"\r\n  IL_0006:  ldarg.1\r\n  IL_0007:  call       \"\"ref TElement System.Runtime.CompilerServices.Unsafe.Add\u003cTElement\u003e(ref TElement, int)\"\"\r\n  IL_000c:  ret\r\n}\r\n```\r\n\r\n```\r\nref readonly TElement InlineArrayElementRefReadOnly\u003cTBuffer, TElement\u003e(in TBuffer buffer, System.Int32 index)\r\n{\r\n  // Code size       18 (0x12)\r\n  .maxstack  2\r\n  IL_0000:  ldarg.0\r\n  IL_0001:  call       \"\"ref TBuffer System.Runtime.CompilerServices.Unsafe.AsRef\u003cTBuffer\u003e(scoped ref readonly TBuffer)\"\"\r\n  IL_0006:  call       \"\"ref TElement System.Runtime.CompilerServices.Unsafe.As\u003cTBuffer, TElement\u003e(ref TBuffer)\"\"\r\n  IL_000b:  ldarg.1\r\n  IL_000c:  call       \"\"ref TElement System.Runtime.CompilerServices.Unsafe.Add\u003cTElement\u003e(ref TElement, int)\"\"\r\n  IL_0011:  ret\r\n}\r\n```\r\n\r\n```\r\nref TElement InlineArrayFirstElementRef\u003cTBuffer, TElement\u003e(ref TBuffer buffer)\r\n{\r\n  // Code size        7 (0x7)\r\n  .maxstack  1\r\n  IL_0000:  ldarg.0\r\n  IL_0001:  call       \"\"ref TElement System.Runtime.CompilerServices.Unsafe.As\u003cTBuffer, TElement\u003e(ref TBuffer)\"\"\r\n  IL_0006:  ret\r\n}\r\n```\r\n\r\n```\r\nref readonly TElement InlineArrayFirstElementRefReadOnly\u003cTBuffer, TElement\u003e(in TBuffer buffer)\r\n{\r\n  // Code size       12 (0xc)\r\n  .maxstack  1\r\n  IL_0000:  ldarg.0\r\n  IL_0001:  call       \"\"ref TBuffer System.Runtime.CompilerServices.Unsafe.AsRef\u003cTBuffer\u003e(scoped ref readonly TBuffer)\"\"\r\n  IL_0006:  call       \"\"ref TElement System.Runtime.CompilerServices.Unsafe.As\u003cTBuffer, TElement\u003e(ref TBuffer)\"\"\r\n  IL_000b:  ret\r\n}\r\n```\r\n\r\n",
                                           "updatedAt":  "2024-09-18T22:48:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Mpdxj",
                                           "createdAt":  "2024-09-19T00:38:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "@AlekseyTs What do you need `InlineArrayElementRef`/`InlineArrayElementRefReadOnly` and `InlineArrayFirstElementRef`/`InlineArrayFirstElementRefReadOnly` for? Can Roslyn use the Span accessor everywhere and leave the unsafe optimizations to the JIT?",
                                           "updatedAt":  "2024-09-19T00:38:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Mpfaq",
                                           "createdAt":  "2024-09-19T00:44:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e InlineArrayAsReadOnlySpan\r\n\r\nI have added the readonly variant to the proposal:\r\n- Changed the argument type from `in` to `readonly ref`. This method expects ref, without any hidden copies.  \r\n- Omitted the `length` argument. The method is expected to be implemented as intrinsic that figures out length from the type.",
                                           "updatedAt":  "2024-09-19T00:44:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6MpgH7",
                                           "createdAt":  "2024-09-19T00:47:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODyyauw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2024-09-19T04:51:41Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "You need to name it something different as you can\u0027t overload by return type or by ref / ref readonly in c#, as I\u0027m sure you\u0027re aware :)\r\nPresumably just `InlineArrayAsReadOnlySpan`",
                                           "updatedAt":  "2024-09-19T04:52:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Mx2ab",
                                           "createdAt":  "2024-09-19T18:21:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AlekseyTs",
                                           "body":  "```InlineArrayElementRef```/```InlineArrayElementRefReadOnly``` are used by compiler to access inline array elements when the index is known to be within bounds. Either the index is compiler controlled (`foreach`, etc.), or user-specified index is a constant.\r\n\r\nSame for ```InlineArrayFirstElementRef```/```InlineArrayFirstElementRefReadOnly```.\r\n\r\n\u003e Can Roslyn use the Span accessor everywhere and leave the unsafe optimizations to the JIT?\r\n\r\nTechnically it can. But it is not clear what level of optimization JIT is going to provide. Even if it will be able to optimize away span creations, will it be able omit bounds checks on indexing through the span, especially in loop scenarios, etc.?\r\n\r\nIs there a problem with exposing specialized helpers?",
                                           "updatedAt":  "2024-09-19T18:21:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6M0OW4",
                                           "createdAt":  "2024-09-20T00:53:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e will it be able omit bounds checks on indexing through the span, especially in loop scenarios, etc.?\r\n\r\nYes, the JIT has the same optimizations for arrays and spans in general.\r\n\r\n\u003e Is there a problem with exposing specialized helpers?\r\n\r\nYes. The goal of this proposal is to enable Roslyn to generate safe verifiable code for InlineArrays. The specialized helpers are unsafe since they do not perform bounds checks.",
                                           "updatedAt":  "2024-09-20T00:53:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6M8unV",
                                           "createdAt":  "2024-09-20T22:58:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "VSadov",
                                           "body":  "\u003e This API is not meant to be used directly by user code. \r\n\r\nI wonder why? It seems it could be used by user code. ",
                                           "updatedAt":  "2024-09-20T22:58:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6M8vI5",
                                           "createdAt":  "2024-09-20T23:01:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "VSadov",
                                           "body":  "Also, it could be useful to add `Length`\r\n\r\n```cs\r\npublic static int InlineArrayLength\u003cTInlineArray\u003e(ref readonly TInlineArray inlineArray) where TInlineArray: allows ref struct;\r\n```",
                                           "updatedAt":  "2024-09-20T23:01:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6M8vLa",
                                           "createdAt":  "2024-09-20T23:02:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e I wonder why? It seems it could be used by user code.\r\n\r\nIt could be used by user code just like many similar APIs, but it is not meant to.",
                                           "updatedAt":  "2024-09-20T23:02:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6M8vU7",
                                           "createdAt":  "2024-09-20T23:03:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "\u003e \u003e This API is not meant to be used directly by user code. \n\u003e \n\u003e I wonder why? It seems it could be used by user code. \n\nMy reading of it is that it means it\u0027s not designed for end users to use, like with many other RuntimeHelper apis - I don\u0027t think that means you\u0027re necessarily not supposed to use it, I think it\u0027s just more that it\u0027s \"not for you\".\nEdit: lol, just saw the other reply after I sent this one 😅",
                                           "updatedAt":  "2024-09-20T23:04:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6M8wJY",
                                           "createdAt":  "2024-09-20T23:08:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "VSadov",
                                           "body":  "\u003e Also, it could be useful to add Length\r\n\r\nAlthough, I guess one can do `((Span\u003cT\u003e)arr).Length`",
                                           "updatedAt":  "2024-09-20T23:08:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6M8wRN",
                                           "createdAt":  "2024-09-20T23:09:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Although, I guess one can do ((Span\u003cT\u003e)arr).Length\r\n\r\nYep.",
                                           "updatedAt":  "2024-09-20T23:09:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6M8wWl",
                                           "createdAt":  "2024-09-20T23:10:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "\u003e Also, it could be useful to add `Length`\n\u003e \n\u003e ```cs\n\u003e public static int InlineArrayLength\u003cTInlineArray\u003e(ref readonly TInlineArray inlineArray) where TInlineArray: allows ref struct;\n\u003e ```\n\nPresumably the actual parameter is not necessary (just the generic), as this info should be on the type itself.\n\nEdit: I wasn\u0027t trying to comment on the need of this api, just that its shape didn\u0027t make sense.\n",
                                           "updatedAt":  "2024-09-20T23:20:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6M8w9l",
                                           "createdAt":  "2024-09-20T23:14:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Presumably the actual parameter is not necessary (just the generic), as this info should be on the type itself.\r\n\r\nThis proposal is for BCL APIs. These APIs are not methods injected into the type by the C# compiler. ",
                                           "updatedAt":  "2024-09-20T23:14:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6M8xho",
                                           "createdAt":  "2024-09-20T23:18:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODzGBJQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hamarb123",
                                                                               "createdAt":  "2024-09-20T23:19:04Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2024-09-20T23:25:48Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hez2010",
                                                                               "createdAt":  "2024-09-21T08:51:19Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "VSadov",
                                           "body":  "I think @hamarb123 just noticed that the parameter is redundant. Which is correct. \r\nIf we do it at all, it could be:\r\n\r\n```cs\r\npublic static int InlineArrayLength\u003cTInlineArray\u003e() where TInlineArray: allows ref struct;\r\n```\r\n\r\nIt could be used as a clue into the generic type inference, though. \r\nI.E.\r\n\r\n```cs\r\nint len = InlineArrayLength(arr);\r\n```\r\n\r\nAnyways, it does not seem adding all that much if there is a conversion to Span.\r\n\r\n",
                                           "updatedAt":  "2024-09-20T23:23:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6M87Fh",
                                           "createdAt":  "2024-09-21T00:29:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hez2010",
                                           "body":  "Yes. Making it a generic method taking the InlineArray type directly can help the runtime implement an intrinsic for this so that it can get expanded to a constant length value at compile time. As well in ILLink/NativeAOT it can be expanded at compile time and redundant branches can be removed. ",
                                           "updatedAt":  "2024-09-21T00:30:06Z"
                                       }
                                   ],
                         "totalCount":  26
                     },
        "title":  "[API Proposal]: InlineArray to Span conversion without Unsafe.As",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.CompilerServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/106381",
        "createdAt":  "2024-08-14T06:38:06Z",
        "number":  106381,
        "author":  "drewnoakes",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC6LwAQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-08-14T11:11:49Z"
                                        },
                                        {
                                            "content":  "THUMBS_DOWN",
                                            "user":  "julealgon",
                                            "createdAt":  "2024-08-14T14:01:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "martincostello",
                                            "createdAt":  "2024-08-14T16:18:23Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2024-08-19T03:54:46Z",
        "body":  "[sharplab](https://sharplab.io/#v2:C4LghgzgtgPgAgRgGwAI4CYUGECwAoAb3xRJQFMA7AVyhQFEUCUBBFAX2NMVUQAYUAsggAUAShQBeAHwoKYKGQD2AM2F0AdM1EBuTiW5oE/AejGSZG5uoAqigMrAATgEsKAczG68bIA=)\r\n\r\n```c#\r\nstatic class C\r\n{\r\n    enum E { A }\r\n    static string M1() =\u003e nameof(E.A);\r\n    static string M2() =\u003e E.A.ToString();\r\n}\r\n```\r\n\r\n```asm\r\n; Core CLR 8.0.724.31311 on x86\r\n\r\nC.M1()\r\n    L0000: mov eax, [0x1766db7c]\r\n    L0005: ret\r\n\r\nC.M2()\r\n    L0000: mov ecx, 0x2f62c9d0\r\n    L0005: call 0x06b6300c\r\n    L000a: xor ecx, ecx\r\n    L000c: mov [eax+4], ecx\r\n    L000f: mov ecx, eax\r\n    L0011: call dword ptr [0x7046b8c]\r\n    L0017: ret\r\n```\r\n\r\nPotential complications around flags enums.\r\n\r\nThese are not exactly functionally equivalent as they return different object references.\r\n\r\n```c#\r\nReferenceEquals(C.M1(), C.M2()) // false\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOiNRYbQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6IYT9T",
                                           "createdAt":  "2024-08-14T07:47:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODuEXwQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ericstj",
                                                                               "createdAt":  "2024-08-14T14:56:58Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "Related: #57748 #70577\r\n\r\n\u003e These are not exactly functionally equivalent as they return different object references.\r\n\r\nUser should not depend on identity of strings. We may certainly change to return the same instance in the future.\r\n\r\nThe string content may change when two enum members are having same values. However, it\u0027s considered undefined for `ToString` in this case: #95617",
                                           "updatedAt":  "2024-08-14T07:47:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Ia2IY",
                                           "createdAt":  "2024-08-14T13:25:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime-compilerservices\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-08-14T13:25:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6IbRsW",
                                           "createdAt":  "2024-08-14T14:02:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOECgZdg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "leotsarev",
                                                                               "createdAt":  "2025-01-15T05:57:54Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "julealgon",
                                           "body":  "Strongly dislike this being an analyzer and forcing the optimization onto users. I\u0027d rather it was handled by the compiler or the JIT to make the replacement behind the scenes when possible.\r\n\r\nI don\u0027t think it is as intuitive to the general dev to start seeing `nameof` usages like that instead of the much more natural `ToString` call.",
                                           "updatedAt":  "2024-08-14T14:02:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6IbhT9",
                                           "createdAt":  "2024-08-14T14:20:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "am11",
                                           "body":  "\u003e Strongly dislike this being an analyzer and forcing the optimization onto users. I\u0027d rather it was handled by the compiler or the JIT to make the replacement behind the scenes when possible.\r\n\r\nSame can be said for existing analyzers? JIT is very likely not going to handle every case where a better alternative is available in the ecosystem (`nameof` keyword in this case).",
                                           "updatedAt":  "2024-08-14T14:20:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6IboJc",
                                           "createdAt":  "2024-08-14T14:29:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODuDoPA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "julealgon",
                                                                               "createdAt":  "2024-08-14T14:32:59Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "\u003e Class members have the similar behavior, so analyzer may still be helpful (as long as ToString is not overridden):\r\n\u003e \r\n\u003e ```cs\r\n\u003e static class C\r\n\u003e {\r\n\u003e     class E { public static int A; }\r\n\u003e     static string M1() =\u003e nameof(E.A);\r\n\u003e     static string M2() =\u003e E.A.ToString();\r\n\u003e }\r\n\u003e ```\r\n\r\nWould you expect the analyzer to output a diagnostic for that code?  Those methods are not at all equivalent; `C.M1()` returns \"A\" but `C.M2()` returns something like \"0\".",
                                           "updatedAt":  "2024-08-14T14:30:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Ibp0C",
                                           "createdAt":  "2024-08-14T14:31:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "julealgon",
                                           "body":  "@am11 \r\n\u003e Same can be said for existing analyzers?\r\n\r\nMaybe some of them. My gripe here is regarding semantics. To me, something like `nameof` is a \"lower-level construct\" when compared to the `ToString()` method. By forcing devs to make this switch, you are (IMHO) making the code a bit more complex than it needs to be for what appears to be a fairly trivial optimization that could be done elsewhere.\r\n\r\nAdditionally, I don\u0027t think this would cover other similarly trivial cases, such as when the enum is inside of a string interpolation. Would you then have this same analyzer suggest the opimization there as well?\r\n\r\n```diff\r\n-var text = $\"MyEnumValue: {E.A}\";\r\n+var text = $\"MyEnumValue: {nameof(E.A)}\";\r\n```\r\n\r\nIf you don\u0027t, AFAIK, the first option would end up calling `ToString` on `E.A` behind the scenes and suffer from the same penalty as the direct call in the example.\r\n\r\nIf `ToString` itself was optimized, it would handle all such situations seamlessly.\r\n\r\n\u003e JIT is very likely not going to handle every case where a better alternative is available in the ecosystem (`nameof` keyword in this case).\r\n\r\nYou are of course correct. But to me, in this particular case, it would be better to keep the well-known and more natural `ToString()` as the code. And keep in mind we are talking about a _specific_ optimization suggestion here. My take would likely change on a case-by-case basis.",
                                           "updatedAt":  "2024-08-14T14:31:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6IcCKn",
                                           "createdAt":  "2024-08-14T14:58:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODuNZhw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "PaulusParssinen",
                                                                               "createdAt":  "2024-08-15T04:02:08Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "ericstj",
                                           "body":  "The behavior here can actually differ in cases of overlapping enum values.\r\n  https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA0AXEUCuA7NAExAGoAfAAQCYAGAWAChqBGRxi5gTgAoB5ANxhQANgEMADuICWeAOYBRPDgC2AOgCCw8QAtRASgDc7LtzyjlMCADM+gkROlzFKjVt17DxngKFjJMhSU1ACFPJhMzC2tbXwcA5xCYDH0wxhgggAIfe38nIMYAb0YMkoz1DIBeDOY0YtLNHVFK6tqGUozg5qpW9uCkpqqqRgBfIA===\r\n  \r\nThe enum.ToString value is actually pretty lousy performance as was pointed out by @huoyaoyuan --https://github.com/dotnet/runtime/issues/57748.",
                                           "updatedAt":  "2024-08-14T14:58:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6I0fgr",
                                           "createdAt":  "2024-08-19T00:31:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "drewnoakes",
                                           "body":  "\u003e Would you expect the analyzer to output a diagnostic for that code? Those methods are not at all equivalent; `C.M1()` returns \"A\" but `C.M2()` returns something like \"0\".\r\n\r\nThey both return \"A\", but it\u0027s not the same object reference.\r\n\r\nhttps://sharplab.io/#v2:C4LgTgrgdgPgAgJgIwFgBQ65IJwAoCySuAlMQNyY4EInnqV4CiAjhAIYA2AzgUcQDQACfDVJ00WPACUApgDMZYGVADGMlu268SQkbXGUAbIKwAGYX0EBeAHyCobALYyA9nNyMAdAEFxWY2bCotZ2Xt6eACouAMrAYACWUADmJBQYaMoQjoKMggDegt6CAL7oQA==\r\n\r\n\u003e The behavior here can actually differ in cases of overlapping enum values. \r\n\r\nOverlapping and flags enums would both complicate this, but these are both statically identifiable (at a point in time \u0026mdash; future changes to the enum could cause problems).",
                                           "updatedAt":  "2024-08-19T00:31:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6I1Fht",
                                           "createdAt":  "2024-08-19T03:54:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODuuMvg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "drewnoakes",
                                                                               "createdAt":  "2024-08-19T09:00:43Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "\u003e They both return \"A\"\n\nThat\u0027s a different scenario; the code I quoted does not define any enum type:\n\n\u003chttps://sharplab.io/#v2:C4LgTgrgdgPgAgJgIwFgBQ65IGwAJG4DC6A3urhfgrgKK4n4DM+OuAllMLgIIDcuAX3KUseLAAZcAWSQAKAJS4AvAD5cUAIYBbAKYB7AGayaAOm7zewiqJaSpCBcrWnuJgCp6AysDAcA5gqWaJS4VixiACzSGhwKYWTBISJIAJyyMgoWYSFYafaZQSFCaAJAA===\u003e",
                                           "updatedAt":  "2024-08-19T03:54:45Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "[Analyzer proposal]: Replace literal enum member ToString with nameof",
        "labels":  [
                       "area-System.Runtime.CompilerServices",
                       "code-analyzer",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/110305",
        "createdAt":  "2024-12-02T11:14:32Z",
        "number":  110305,
        "author":  "Youssef1313",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC-RNkQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "julealgon",
                                            "createdAt":  "2024-12-02T13:18:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "huoyaoyuan",
                                            "createdAt":  "2024-12-20T06:55:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Peter-Juhasz",
                                            "createdAt":  "2024-12-21T21:26:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "edwardneal",
                                            "createdAt":  "2025-01-19T11:50:58Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2025-05-13T22:07:16Z",
        "body":  "### Background and motivation\n\n`StringSyntaxAttribute` was introduced to support IDE highlighting scenarios, such as Regex.\n\nOften, users have existing helper methods that may be forwarding a parameter to a method (likely a BCL method, e.g Regex.IsMatch) that has the attribute, but the user doesn\u0027t add the attribute.\n\n### API Proposal\n\nAn analyzer is introduced that will analyze invocations and roughly have the following functionality\n\n1. Look at the parameters of the invoked method for a parameter with StringSyntaxAttribute\n2. If found, look at the argument corresponding to that parameter.\n3. If the argument is an IParameterReferenceOperation, look into the attributes of that parameter and require a matching attribute.\n\n### API Usage\n\nN/A\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOldw1zg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6V3DXO",
                                           "createdAt":  "2024-12-03T11:06:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime-compilerservices\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-12-03T11:06:05Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "[Analyzer Proposal]: Propagate StringSyntaxAttribute",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.CompilerServices",
                       "code-analyzer"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/111083",
        "createdAt":  "2025-01-04T08:19:21Z",
        "number":  111083,
        "author":  "huoyaoyuan",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC_v9iA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Wraith2",
                                            "createdAt":  "2025-01-04T11:31:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2025-01-04T17:58:45Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "samsosa",
                                            "createdAt":  "2025-01-04T18:03:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "cklutz",
                                            "createdAt":  "2025-01-05T15:23:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "timcassell",
                                            "createdAt":  "2025-01-18T13:06:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "raulsntos",
                                            "createdAt":  "2025-03-05T22:21:36Z"
                                        }
                                    ],
                          "totalCount":  6
                      },
        "updatedAt":  "2025-07-16T18:48:46Z",
        "body":  "Sometimes, it\u0027s useful to check overridden status of methods to enable specific optimization. For example, `Stream` checks override status of APM methods to skip an extra layer:\n\nhttps://github.com/dotnet/runtime/blob/6045e29bbefa63b58ccd5502f057ae452f3c83af/src/libraries/System.Private.CoreLib/src/System/IO/Stream.cs#L754-L761\n\nA virtual-method based UI framework may also use the pattern to reduce overhead of event handling:\n\n```csharp\nvoid AddChild(Element child)\n{\n    if (__has_overridden(child, OnMouseMove))\n        handlesMouseMove.Add(child);\n}\n\noverride void OnMouseMove(MouseMoveEventArgs args)\n{\n    foreach (var child in handlesMouseMove)\n        child.OnMouseMove(MouseMoveEventArgs args);\n}\n```\n\nCurrently there is no simple way to check if a method is overridden in C#. Using reflection is complicated and not intuitive, with `baseMethod.DeclaringType != derivedMethod.DeclaringType \u0026\u0026 baseMethod.GetBaseDefinition() == derivedMethod.GetBaseDefinition()`. It\u0027s also very inefficient.\n`Stream` is specially handled by CLR, and the approach is not extensible at all. In IL, it\u0027s achievable by comparing method pointers with `ldvirtftn`:\n\nhttps://github.com/dotnet/runtime/blob/0f6c3d862b703528ffff099af40383ddc52853f8/src/coreclr/tools/Common/TypeSystem/IL/Stubs/StreamIntrinsics.cs#L32-L36\n\nShould we introduce an approach available externally to detect overrides? There are two possible approaches I can see:\n\n#### Enable `ldvirtftn` and instance function pointers in C#\n\nBasically it\u0027s allowing to write the aforementioned IL in C#. There\u0027s nothing more to handle for codegen and will just work. However, there may need more effort to ensure the usage of instance function pointers work fine for broad cases.\n\n#### Expose a intrinsic helper for checking overrides\n\nThis enables more opportunities like constant folding when the type is known, and reduces the risk of inappropriate function pointers. However, currently there\u0027s no ideal way to pass a method in C# (lack of `methodof`). The ability to express the method is questionable.\n\nIs there any interest to provide this functionality at all? Would there be more risks about it?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOtwnLGA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6ZOdYJ",
                                           "createdAt":  "2025-01-04T08:20:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-01-04T08:20:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ZOn4L",
                                           "createdAt":  "2025-01-04T08:32:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEBMT0g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "EgorBo",
                                                                               "createdAt":  "2025-01-06T15:28:36Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "Such a feature was discussed in \u003chttps://github.com/dotnet/runtime/issues/12760\u003e.",
                                           "updatedAt":  "2025-01-04T08:32:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ZQ9xC",
                                           "createdAt":  "2025-01-04T17:24:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEBDMfw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MichalPetryka",
                                                                               "createdAt":  "2025-01-04T18:10:37Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e There\u0027s nothing more to handle for codegen and will just work.\n\nThat\u0027s not correct. Function pointers are not guaranteed to be stable across all runtime flavors. This only happens to work for runtime flavors where function pointers are stable (e.g. native AOT).",
                                           "updatedAt":  "2025-01-04T17:24:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ZRBOM",
                                           "createdAt":  "2025-01-04T18:24:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "Would #94975 solve this with `VirtualMethodHandle` while still being friendly to all runtimes?",
                                           "updatedAt":  "2025-01-04T18:24:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ZRCUK",
                                           "createdAt":  "2025-01-04T18:42:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "\u003e Would [#94975](https://github.com/dotnet/runtime/issues/94975) solve this with `VirtualMethodHandle` while still being friendly to all runtimes?\n\nIt should be functional with stable, comparable handles, but may not be as performant as accessing virtual slots directly. Currently in coreclr, function pointer comparison is used as a fast path, then MethodDesc. Further optimizations should be nice to have.",
                                           "updatedAt":  "2025-01-04T18:42:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc63CDVE",
                                           "createdAt":  "2025-07-14T19:50:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "@jkotas is this something you think is worth adding to the runtime?\n\nIf not, I would suggest we close the issue as \"not planned\". I don\u0027t think there\u0027s much that could be done here short of a `RuntimeHelpers` function that compares `MethodInfo`, particularly since C# doesn\u0027t have a way to trivially get method handle or token.",
                                           "updatedAt":  "2025-07-14T19:50:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc63CaiU",
                                           "createdAt":  "2025-07-14T20:21:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEaiMHQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tannergooding",
                                                                               "createdAt":  "2025-07-14T21:08:55Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e I don\u0027t think there\u0027s much that could be done here short of a RuntimeHelpers function that compares MethodInfo\n\nWe have invented `UnsafeAccessor` as a fast reflection equivalent. https://github.com/dotnet/runtime/issues/94975 mentioned above discusses introducing new `UnsafeAccessorKind`s that return RuntimeMethodHandles. It is possible to go even further and introduce `UnsafeAccessorKind` that returns bool indicating whether the given method was overriden. \n\nI am just saying that this may be the best way to build this feature if we decide that it is worth it. I do not think we have enough evidence that building this feature is worth it.\n\n",
                                           "updatedAt":  "2025-07-14T20:21:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc63CcsY",
                                           "createdAt":  "2025-07-14T20:24:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Related to https://github.com/dotnet/runtime/issues/94975 and other potential UnsafeAccessor extensions.",
                                           "updatedAt":  "2025-07-14T20:24:12Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Efficient way to check if a method has been overridden",
        "labels":  [
                       "area-System.Runtime.CompilerServices",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/118897",
        "createdAt":  "2025-08-19T18:40:01Z",
        "number":  118897,
        "author":  "MichalPetryka",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODMIeHA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ovska",
                                            "createdAt":  "2025-08-21T14:25:39Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-08-26T21:06:31Z",
        "body":  "### Background and motivation\n\n`RuntimeHelpers.AllocateTypeAssociatedMemory` is an API that\u0027s very useful for allocating private, permanent buffers for lookup tables and such.\n\nIt doesn\u0027t however provide a way to specify the alignment which makes the users that require it for correctness or performance have to manually ensure that via for example overallocating today.\nAs such, I propose that an overload that allows it to be specified would be added.\n\n### API Proposal\n\n```csharp\nnamespace System.Runtime.CompilerServices;\n\npublic static class RuntimeHelpers\n{\n    public static IntPtr AllocateTypeAssociatedMemory(Type type, int size, int alignment);\n}\n```\n\n\n### API Usage\n\n```csharp\npublic static class SimdAlgorithm\n{\n    public static readonly byte* SimdLookupTable = (byte*)RuntimeHelpers.AllocateTypeAssociatedMemory(typeof(SimdAlgorithm), 4096, 64);\n}\n```\n\n\n### Alternative Designs\n\nThe API could return `void*` instead and take parameters as `nuint`, I decided to match the existing overload for now though.\n\n### Risks\n\nMatching `IntPtr` return might be problematic with the new unsafe guidelines.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOwD4O6Q==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6-2Cfc",
                                           "createdAt":  "2025-08-19T18:46:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime-compilerservices\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-08-19T18:46:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6_LplG",
                                           "createdAt":  "2025-08-20T17:59:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "This seems reasonable, but needs weigh-in from @AaronRobinsonMSFT before being marked ready-for-review.\n\nI\u0027ve needed this a few times and it typically just involves doing the extra step to overallocate and \"align up\". Anyone can do the same via a helper, especially using one of the new `extension members` features (such that you can define static extension APIs). However, the runtime could use a \"proper\" aligned memory allocator internally and be a bit more efficient",
                                           "updatedAt":  "2025-08-20T17:59:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6_Ndyh",
                                           "createdAt":  "2025-08-20T20:22:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "I\u0027m not sure how useful it really is for us to expose relative to people that need the associative/unloading functionality it provides, but it would align with the existing APIs on `NativeMemory`. Since this is allocating memory associated with an type/assembly it is going to use the `LoaderHeap` on `LoaderAllocator`. That does have an existing API for aligned memory, but in practice we are just going to do what @tannergooding stated above:\n\n\u003e just involves doing the extra step to overallocate and \"align up\"\n\n\u003e However, the runtime could use a \"proper\" aligned memory allocator internally and be a bit more efficient\n\nTrue, we could do some additional optimizations in the future here. Admittedly, we do try to minimize the overallocation.\n\nThis was originally exposed for the newer [COM interop scenario](https://github.com/dotnet/runtime/issues/1845) involving `ComWrappers`, so I get there are cases. The native AOT and mono implementations will simply defer to `NativeMemory` anyways since they don\u0027t support unloading. I would like to understand if there is really a need for the unloading angle? It was needed for COM because the new scenario explicitly supports unloading, eventhough in practice probably isn\u0027t all that interesting.\n\nIs there a real interest in the unloadability angle here?",
                                           "updatedAt":  "2025-08-20T20:22:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6_OKIZ",
                                           "createdAt":  "2025-08-20T21:36:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e I\u0027ve needed this a few times and it typically just involves doing the extra step to overallocate\n\nIf possible, could you please share links to real-world examples where this would be useful?\n\nI assume that lookup tables used by System.Runtime.Intririsics.* are the motivating use case for this API. I think it is reasonable that users want to write code compatible with unloading in these scenarios. I do not see a problem with adding the API for symmetry with NativeMemory given that it is trivial to implement.",
                                           "updatedAt":  "2025-08-20T21:36:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6_ORsq",
                                           "createdAt":  "2025-08-20T21:52:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e I assume that lookup tables used by System.Runtime.Intririsics.* are the motivating use case for this API.\n\nRight. This, as well as static buffers used in coordination with a graphics API, VTBLs or IIDs associated with a type, and some cases of helper structs that wrap a pointer where I want a reusable struct (`UnmanagedArray\u003cT\u003e.Empty` being one example)\n\nMost of these weren\u0027t alignment related and were just to be doing the \"right thing\" with regards to an allocation that should live only until the assembly unloaded, so it doesn\u0027t leak. A handful of those scenarios are here: https://github.com/search?q=org%3Aterrafx%20AllocateTypeAssociatedMemory\u0026type=code\n\nI have some local, not yet checked in, code that\u0027s porting some C algorithms like https://github.com/amd/aocl-libm-ose/blob/aocl-5.1/src/optimized/log_data.h as well. Where I\u0027m preserving the alignment C specifies (16) to avoid potential cache line splits for the `log_table` since it\u0027s sometimes used with non-temporal accesses for large data (normally I\u0027d just use the `ROSpan\u003cT\u003e` approach for an RVA static instead).\n\n---------------\n\nLike I said, this is a relatively trivial thing to emulate. This is especially true moving forward with `extension members` since anyone can define an extension method exposing such a helper off `RuntimeHelpers` now.\n\nSo it\u0027s really just a question on if we want to provide that minor convenience in box and potentially allow it to micro-optimize and not overallocate (which realistically is going to be no more than 48 bytes on a typical machine).",
                                           "updatedAt":  "2025-08-20T21:52:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6_OVzB",
                                           "createdAt":  "2025-08-20T22:01:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "\u003e Is there a real interest in the unloadability angle here?\n\nPersonally I never use unloadability but I always try to make my libraries compatible with it so kinda.\n\n\u003e The native AOT and mono implementations will simply defer to `NativeMemory` anyways since they don\u0027t support unloading.\n\nI\u0027ve proposed to @MichalStrehovsky before to have the NAOT cctor interpreter handle `RuntimeHelpers.AllocateTypeAssociatedMemory` specially and emit it into the binary sections at build time, he wasn\u0027t interested in it but if things change the API could become special like that.",
                                           "updatedAt":  "2025-08-20T22:01:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6_OYy5",
                                           "createdAt":  "2025-08-20T22:07:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e A handful of those scenarios are here: https://github.com/search?q=org%3Aterrafx%20AllocateTypeAssociatedMemory\u0026type=code\n\nThanks. I see the pattern here.\n\n\u003e  but I always try to make my libraries compatible with it so kinda.\n\n+1\n\n\u003e RuntimeHelpers.AllocateTypeAssociatedMemory specially and emit it into the binary sections at build time, he wasn\u0027t interested in it but if things change the API could become special like that.\n\nThis is an interesting idea and something that an official API would help enable.",
                                           "updatedAt":  "2025-08-20T22:07:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6_OZWM",
                                           "createdAt":  "2025-08-20T22:08:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "It follows the existing overload pattern. The only real annoyance is that it doesn\u0027t follow the `NativeMemory` pattern for `nint`. However, I would prefer to match the existing API.",
                                           "updatedAt":  "2025-08-20T22:08:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6_Oba2",
                                           "createdAt":  "2025-08-20T22:11:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "@MichalPetryka Can you please give some thought to how you would like the error cases for the `alignment` parameter. Is `0` valid? Can it be negative? I assume it requires a power of 2?",
                                           "updatedAt":  "2025-08-20T22:11:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6_OdPH",
                                           "createdAt":  "2025-08-20T22:14:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEfCLfg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tannergooding",
                                                                               "createdAt":  "2025-08-20T22:29:39Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "I would expect it to be exactly same as `NativeMemory.AlignedAlloc`: https://github.com/dotnet/runtime/blob/80c8bb77ebb1da55b4ebe280a72517764df6aaec/src/libraries/System.Private.CoreLib/src/System/Runtime/InteropServices/NativeMemory.Unix.cs#L26",
                                           "updatedAt":  "2025-08-20T22:14:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6_OeoQ",
                                           "createdAt":  "2025-08-20T22:17:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "\u003e Can you please give some thought to how you would like the error cases for the `alignment` parameter. Is `0` valid? Can it be negative? I assume it requires a power of 2?\n\nI\u0027d say it should match `NativeMemory.AlignedAlloc` or the native `aligned_alloc`.",
                                           "updatedAt":  "2025-08-20T22:17:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6_VWnM",
                                           "createdAt":  "2025-08-21T10:57:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hez2010",
                                           "body":  "Given that it\u0027s unmanaged memory, can we use `nuint` instead of `int` for size?",
                                           "updatedAt":  "2025-08-21T10:57:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6_YsEE",
                                           "createdAt":  "2025-08-21T14:47:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Sergio0694",
                                           "body":  "\u003e \"is an API that\u0027s very useful for allocating private, permanent buffers for lookup tables and such.\"\n\nNot sure I understand the use case scenario. Presumably these lookup tables would be compile time constants anyway, no? Wouldn\u0027t it be better (especially for perf on NAOT as well) to instead define such lookup tables as an RVA field, and then change the proposal to instead be for some kind of attribute to allow explicitly declaring the required alignment of that RVA field?\n\nThe ECMA spec addendum already states that the pack value for RVA fields indicates the alignment. We just don\u0027t have a way today to control that manually from C#.",
                                           "updatedAt":  "2025-08-21T14:47:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6_Y_h_",
                                           "createdAt":  "2025-08-21T15:02:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEfkdng==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2025-08-21T15:15:44Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2025-08-25T23:38:20Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e Given that it\u0027s unmanaged memory, can we use nuint instead of int for size?\n\nThe existing overload takes `int` and you shouldn\u0027t be allocating a buffer that\u0027s over 2 billion bytes anyways (you shouldn\u0027t even be allocating one that\u0027s over a few megabytes). Using `int` keeps it consistent and shouldn\u0027t hinder any real world scenarios.",
                                           "updatedAt":  "2025-08-21T15:02:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6_ZDhC",
                                           "createdAt":  "2025-08-21T15:04:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e Wouldn\u0027t it be better (especially for perf on NAOT as well) to instead define such lookup tables as an RVA field, and then change the proposal to instead be for some kind of attribute to allow explicitly declaring the required alignment of that RVA field?\n\nI think that\u0027d be a language proposal instead, not a runtime one.\n\nNot all lookup tables or the like can be static either, so there\u0027s still benefit to this proposal.",
                                           "updatedAt":  "2025-08-21T15:04:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7APg7p",
                                           "createdAt":  "2025-08-26T18:37:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEf5mZg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2025-08-27T20:17:35Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "bartonjs",
                                           "body":  "[Video](https://www.youtube.com/watch?v=5rKlRoQHCVU\u0026t=1h23m26s)\n\nLooks good as proposed\n\n```C#\nnamespace System.Runtime.CompilerServices;\n\npublic static class RuntimeHelpers\n{\n    public static IntPtr AllocateTypeAssociatedMemory(Type type, int size, int alignment);\n}\n```",
                                           "updatedAt":  "2025-08-26T21:06:31Z"
                                       }
                                   ],
                         "totalCount":  16
                     },
        "title":  "[API Proposal]: `RuntimeHelpers.AllocateTypeAssociatedMemory` overload with alignment",
        "labels":  [
                       "api-approved",
                       "area-System.Runtime.CompilerServices",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/119664",
        "createdAt":  "2025-09-12T19:14:30Z",
        "number":  119664,
        "author":  "pentp",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-13T18:31:53Z",
        "body":  "The initial proposal in #90081 mentioned that the inaccessible type problem applies to both fields and methods, but the implementation skipped support for fields due to type safety issues: https://github.com/dotnet/runtime/pull/114881#issuecomment-2856649342 - having a `ref object` return type for the accessor isn\u0027t memory safe, it would need `TypedReference` support for that.\n\nNeeding it for fields is probably less common, but I just ran into a situation where I need it for .NET 10 (as a replacement for `HttpContent.TryGetBuffer` that\u0027s in older versions):\n```cs\n[UnsafeAccessor(UnsafeAccessorKind.Field)]\n[return: UnsafeAccessorType(\"System.Net.Http.HttpContent+LimitArrayPoolWriteStream, System.Net.Http\")]\nprivate static extern ref object? _bufferedContent(HttpContent content);\n```\nThis ends up throwing `Invalid usage of UnsafeAccessorTypeAttribute`.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOxAXUMA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc7EBdQw",
                                           "createdAt":  "2025-09-13T18:31:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime-compilerservices\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-09-13T18:31:53Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "`UnsafeAccessorTypeAttribute` support for field accessors",
        "labels":  [
                       "area-System.Runtime.CompilerServices",
                       "untriaged"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/119875",
        "createdAt":  "2025-09-19T02:34:00Z",
        "number":  119875,
        "author":  "jnm2",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-19T09:35:59Z",
        "body":  "### Description\n\nThere appears to be no way to use UnsafeAccessor to run a nongeneric method when it has a generic overload with the same signature.\n\nThis fails in .NET 9 and 10, but succeeds in 8.\n\n### Reproduction Steps\n\n```cs\nusing System.Runtime.CompilerServices;\n\nclass Program\n{\n    static void Main()\n    {\n        // Throws System.Reflection.AmbiguousMatchException: \u0027Ambiguity in binding of UnsafeAccessorAttribute.\u0027\n        Example(null);\n    }\n\n    [UnsafeAccessor(UnsafeAccessorKind.StaticMethod)]\n    private static extern void Example(ContainingClass? _);\n}\n\nclass ContainingClass\n{\n    private static void Example() { }\n    private static void Example\u003cT\u003e() { }\n}\n```\n\n### Expected behavior\n\nThe nongeneric method is invoked.\n\n### Actual behavior\n\nThe runtime throws AmbiguousMatchException.\n\n### Regression?\n\nYes, it worked in 8 and fails in 9 and 10.\n\n### Known Workarounds\n\nUse reflection if possible instead of UnsafeAccessor\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOxWDneA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc7FTy1z",
                                           "createdAt":  "2025-09-19T02:34:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime-compilerservices\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-09-19T02:34:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7FYOd4",
                                           "createdAt":  "2025-09-19T09:35:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "@AaronRobinsonMSFT ",
                                           "updatedAt":  "2025-09-19T09:35:59Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "UnsafeAccessor ambiguity failure when a generic overload exists with the same signature",
        "labels":  [
                       "area-System.Runtime.CompilerServices",
                       "untriaged"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/119876",
        "createdAt":  "2025-09-19T03:58:27Z",
        "number":  119876,
        "author":  "MichalPetryka",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODSHcQw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ufcpp",
                                            "createdAt":  "2025-09-19T04:09:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DaZombieKiller",
                                            "createdAt":  "2025-09-19T04:12:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mikernet",
                                            "createdAt":  "2025-09-19T04:17:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hamarb123",
                                            "createdAt":  "2025-09-19T06:00:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SystematicChaos012",
                                            "createdAt":  "2025-09-19T06:53:31Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "JoeTwizzle",
                                            "createdAt":  "2025-09-19T08:33:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "h3xds1nz",
                                            "createdAt":  "2025-09-19T16:38:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "neon-sunset",
                                            "createdAt":  "2025-09-19T20:47:37Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2025-09-20T10:34:46Z"
                                        }
                                    ],
                          "totalCount":  9
                      },
        "updatedAt":  "2025-09-19T04:21:38Z",
        "body":  "### Background and motivation\n\nIn .NET 10 `UnsafeAccessor` got support for inaccessible types with `UnsafeAccessorType`, however that doesn\u0027t help for types used as generic constraints. \n\nAs such, I\u0027d like to request an option for ignoring the constraints, as originally discussed in #99468 to be exposed, since that\u0027d solve this issue and additionally would allow the use of UnsafeAccessor for generic bridging.\n\nThe constraints here would still be resolved lazily, on per instantiation basis, to avoid type safety issues, either at compile time or at runtime when not possible due to shared generics.\n\n### API Proposal\n\n```csharp\nnamespace System.Runtime.CompilerServices;\n\npublic sealed class UnsafeAccessor : Attribute\n{\n    public bool IgnoreGenericConstraints { get; }\n}\n```\n\n\n### API Usage\n\n```csharp\n// assembly A\ninternal IInacessible {}\n\npublic class C\n{\n    internal void A\u003cT\u003e(T val) where T : IInacessible {}\n}\n\n// assembly B\n[UnsafeAccessor(UnsafeAccessorKind.Method, Name = \"A\", IgnoreGenericConstraints = true)]\npublic static extern void A\u003cT\u003e(C c, T val);\n```\n\n\n### Alternative Designs\n\nSince you can\u0027t overload on constraints in both IL and C#, this could be changed to be the only behaviour but it\u0027d be a breaking change.\n\n### Risks\n\nThis would be problematic if overloading by constraints was added in future IL changes, cases that could need runtime checking would have reduced performance.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOxVG8kQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc7FUUCq",
                                           "createdAt":  "2025-09-19T03:59:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime-compilerservices\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-09-19T03:59:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7FUbyR",
                                           "createdAt":  "2025-09-19T04:15:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEjJPsw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ufcpp",
                                                                               "createdAt":  "2025-09-19T07:12:08Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "PaulusParssinen",
                                                                               "createdAt":  "2025-09-20T10:34:43Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2025-09-20T12:55:54Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "DaZombieKiller",
                                           "body":  "This would also allow a developer to work around the lack of ability to bridge generic constraints:\n```cs\nusing System;\nusing System.Numerics;\nusing System.Runtime.InteropServices;\nusing System.Runtime.CompilerServices;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(Number.Add(null, 1, 1));\n    }\n}\n\nstatic class Number\n{\n    private static T AddCore\u003cT\u003e(T x, T y)\n        where T : INumber\u003cT\u003e\n    {\n        return x + y;\n    }\n\n    [UnsafeAccessor(UnsafeAccessorKind.StaticMethod, Name = \"AddCore\", IgnoreGenericConstraints = true)]\n    public static extern T Add\u003cT\u003e([UnsafeAccessorType(\"Number\")] object? _, T x, T y);\n}\n```\nThis actually already works under Mono. It [does not validate the generic constraints](https://github.com/dotnet/runtime/issues/102942) of unsafe accessor methods currently.",
                                           "updatedAt":  "2025-09-19T04:21:38Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[API Proposal]: Support ignoring generic constraints with UnsafeAccessor",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.CompilerServices",
                       "untriaged"
                   ]
    }
]
