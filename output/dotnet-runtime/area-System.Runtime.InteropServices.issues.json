[
    {
        "url":  "https://github.com/dotnet/runtime/issues/8300",
        "createdAt":  "2017-06-06T22:09:19Z",
        "number":  8300,
        "author":  "tannergooding",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODEVimA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "fiigii",
                                            "createdAt":  "2017-06-07T17:29:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jkoritzinsky",
                                            "createdAt":  "2017-06-20T22:09:33Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "4creators",
                                            "createdAt":  "2017-07-12T21:59:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "snboisen",
                                            "createdAt":  "2017-08-01T10:00:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "benaadams",
                                            "createdAt":  "2017-11-20T21:35:05Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pentp",
                                            "createdAt":  "2018-08-20T17:53:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "itsamelambda",
                                            "createdAt":  "2018-10-24T15:47:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "reflectronic",
                                            "createdAt":  "2020-04-23T06:14:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "LifeIsStrange",
                                            "createdAt":  "2020-08-02T18:12:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "andrew-boyarshin",
                                            "createdAt":  "2020-12-05T16:39:06Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MineCake147E",
                                            "createdAt":  "2022-01-12T10:04:31Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Daniel-Svensson",
                                            "createdAt":  "2022-08-24T12:57:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "alexrp",
                                            "createdAt":  "2022-10-16T18:37:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MichalPetryka",
                                            "createdAt":  "2022-10-18T19:04:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2023-08-24T18:10:49Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2024-03-29T10:16:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "tanveerbadar",
                                            "createdAt":  "2024-04-16T13:13:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Const-me",
                                            "createdAt":  "2025-01-17T16:29:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sanamhub",
                                            "createdAt":  "2025-06-20T04:23:59Z"
                                        }
                                    ],
                          "totalCount":  19
                      },
        "updatedAt":  "2025-07-07T20:42:32Z",
        "body":  "### Rationale\r\n\r\nToday, the runtime supports the `__fastcall` calling convention, which not only allows interop with any native code that uses that calling convention but also allows it to take advantage of the additional registers that are available on the underlying architecture.\r\n\r\nHowever, it means that operating with certain data types is still \"sub-optimal\".\r\n\r\nMicrosoft Windows provides the `__vectorcall` calling convention just for this purpose (https://msdn.microsoft.com/en-us/library/dn375768.aspx). It extends the existing `__fastcall` calling convention to additionally allow SIMD vector types and Homogeneous Vector Aggregate values to be passed via register rather than on the stack.\r\n\r\nThe `System V AMD64 ABI` already defines vector sized types (__m128, __m256) and supports passing them in register.\r\n\r\n### Proposal\r\n\r\nThe runtime should add support for the `__vectorcall` calling convention, not only to improve performance, but to also provide better interop with native code that uses it.\r\n\r\n```diff\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n+    public class CallConvVectorCall\r\n+    {\r\n+        // This type has no members and is identical in structure to other `CallConv*` types\r\n+    }\r\n}\r\n```\r\n\r\n### Alternative API proposal\r\n\r\nThe `__vectorcall` calling convention could be exposed on `System.Runtime.InteropServices.CallingConvention` as `VectorCall`.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYSXrkA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMwNjYzMTk0Ng==",
                                           "createdAt":  "2017-06-06T22:09:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "FYI. @mellinoe, who may be interested.",
                                           "updatedAt":  "2017-06-06T22:09:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMwNjYzMjIwOQ==",
                                           "createdAt":  "2017-06-06T22:10:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODv0fzg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "omariom",
                                                                               "createdAt":  "2017-06-06T22:46:15Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "fiigii",
                                                                               "createdAt":  "2017-06-07T17:29:23Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkoritzinsky",
                                                                               "createdAt":  "2017-06-20T22:09:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "4creators",
                                                                               "createdAt":  "2017-07-12T21:59:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "itsamelambda",
                                                                               "createdAt":  "2018-10-24T15:47:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "LifeIsStrange",
                                                                               "createdAt":  "2020-08-02T18:13:18Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pentp",
                                                                               "createdAt":  "2020-08-03T17:47:46Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MineCake147E",
                                                                               "createdAt":  "2022-12-16T06:04:53Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-08-27T12:33:13Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  9
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "This would significantly improve performance for the `System.Numerics.Vector` package, where all of the exposed types could be passed in register rather than passed on stack.",
                                           "updatedAt":  "2017-06-06T22:10:54Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMxOTE1MzA3Nw==",
                                           "createdAt":  "2017-07-31T18:20:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "https://github.com/dotnet/designs/issues/13",
                                           "updatedAt":  "2017-07-31T18:20:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM2NDIxNzIyMw==",
                                           "createdAt":  "2018-02-08T19:12:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sdmaclea",
                                           "body":  "https://docs.microsoft.com/en-us/cpp/cpp/stdcall\r\n\r\n\u003e On ARM and x64 processors, __stdcall is accepted and ignored by the compiler; on ARM and x64 architectures, by convention, arguments are passed in registers when possible, and subsequent arguments are passed on the stack. \r\n\r\nhttps://docs.microsoft.com/en-us/cpp/cpp/vectorcall\r\n\r\n\u003e On ARM machines, __vectorcall is accepted and ignored by the compiler\r\n\r\nFor ARM64 the standard calling convention (ARM64 AAPCS64) passes vectors in registers as Short Vectors or HVA.\r\n\r\nA brief glance at the Vector ABI for ARM64 (VPCS) doc looks like it is similar to the ARM64 AAPCS64 except it changes Callee/Caller register save responsibilities to eliminate some of the issues with preserving/restoring high bits of vector registers.  `__atribute__((aarch64_vector_pcs))`",
                                           "updatedAt":  "2018-02-08T19:12:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM2NDIyNzI4Nw==",
                                           "createdAt":  "2018-02-08T19:48:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sdmaclea",
                                           "body":  "Looks like attribute `aarch64_vector_pcs` is not recognized by gcc 6.3.0.  Tested using latest Arm64 gcc on Compliler Explorer https://godbolt.org/  ",
                                           "updatedAt":  "2018-02-08T19:48:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM3NjIxNjEzNQ==",
                                           "createdAt":  "2018-03-26T15:53:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "With the support for hardware intrinsics in addition to the existing support for things like System.Numerics.Vector, this may be more important.\r\n\r\nThis currently represents a scenario where the Windows ABI actually loses out on performance as compared to the System V ABI.\r\n\r\nThis performance difference is readily measurable in native code, and will become more measurable in managed code as the the CoreCLR System V ABI implementation continues getting improvements.",
                                           "updatedAt":  "2018-03-26T15:53:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM3NjIxNjI2Mw==",
                                           "createdAt":  "2018-03-26T15:54:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "CC. @CarolEidt ",
                                           "updatedAt":  "2018-03-26T15:54:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM3NjIzMTUyNg==",
                                           "createdAt":  "2018-03-26T16:41:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAa3w2A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pentp",
                                                                               "createdAt":  "2018-08-20T17:55:01Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "AndyAyersMS",
                                           "body":  "On a similar note we should explore the custom xmm call convention on x86, at least for invoking our own math helpers, to avoid transitioning in and out of x87 like we do now.\r\n\r\n`__vectorcall` on x86 looks pretty hacky.",
                                           "updatedAt":  "2018-03-26T16:41:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM3NjIzMjk1Mg==",
                                           "createdAt":  "2018-03-26T16:45:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e On a similar note we should explore the custom xmm call convention on x86, at least for invoking our own math helpers, to avoid transitioning in and out of x87 like we do now\r\n\r\n@AndyAyersMS, I thought we removed all the x87 FPU code with RyuJIT? At the very least, I remember doing some work to ensure the System.Math helpers were able to call the CRT implementations (which use SSE/SSE2 when that compiler switch is specified), rather than using the hand-coded assembly.",
                                           "updatedAt":  "2018-03-26T16:45:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM3NjIzMzMxOA==",
                                           "createdAt":  "2018-03-26T16:47:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBMKNcA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "LifeIsStrange",
                                                                               "createdAt":  "2020-08-02T18:17:25Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e __vectorcall on x86 looks pretty hacky.\r\n\r\nHow so? It should just be (roughly speaking) the x86 __fastcall convention plus enabling HVA arguments",
                                           "updatedAt":  "2018-03-26T16:47:04Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM3NjIzNTM1Ng==",
                                           "createdAt":  "2018-03-26T16:53:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODq8_-A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tannergooding",
                                                                               "createdAt":  "2018-03-26T17:13:11Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-07-21T15:40:18Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "mikedn",
                                           "body":  "\u003e I thought we removed all the x87 FPU code with RyuJIT? \r\n\r\nThe standard x86 calling convention returns FP values in `ST(0)`.",
                                           "updatedAt":  "2018-03-26T16:53:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM3NjI2MTk1OQ==",
                                           "createdAt":  "2018-03-26T18:16:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AndyAyersMS",
                                           "body":  "Hmm, maybe I misread the \"spec\" -- it seems like if we made vectorcall the default for all methods it looks like it would give us XMM pass/return for floats on x86. The description [here](https://blogs.msdn.microsoft.com/vcblog/2013/07/11/introducing-vector-calling-convention/) is not all that easy to parse as it also says the convention for floats is not impacted. ",
                                           "updatedAt":  "2018-03-26T18:16:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM3NjI2NTg5Ng==",
                                           "createdAt":  "2018-03-26T18:29:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mikedn",
                                           "body":  "\u003e it seems like if we made vectorcall the default for all methods it looks like it would give us XMM pass/return for floats on x86\r\n\r\nYes, it does that. For example: https://godbolt.org/g/ZsJv5y",
                                           "updatedAt":  "2018-03-26T18:29:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM3NjI2NzQ1OA==",
                                           "createdAt":  "2018-03-26T18:34:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AndyAyersMS",
                                           "body":  "Also it interesting to see that `__fastcall` on x86 has some limited aspects of `__vectorcall`. I am pretty sure the jit doesn\u0027t do this for manged methods with HFA/HVAs.\r\n\r\nMaybe interop knows about it?",
                                           "updatedAt":  "2018-03-26T18:34:43Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM3NjI2NzU4Ng==",
                                           "createdAt":  "2018-03-26T18:35:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mikedn",
                                           "body":  "\u003e The description here is not all that easy to parse as it also says the convention for floats is not impacted.\r\n\r\nThe documentation page (https://msdn.microsoft.com/en-us/library/dn375768.aspx) does say that vector types include FP types:\r\n\r\n\u003e A vector type is either a floating-point type—for example, a float or double—or an SIMD vector type—for example, __m128 or __m256.\r\n\r\nAnd then for x86 it says:\r\n\r\n\u003e Vector type results are returned by value in XMM0 or YMM0, depending on size. HVA results have each data element returned by value in registers XMM0:XMM3 or YMM0:YMM3, depending on element size. Other result types are returned by reference to memory allocated by the caller.",
                                           "updatedAt":  "2018-03-26T18:35:04Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM3NjI3MjUxMQ==",
                                           "createdAt":  "2018-03-26T18:50:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Maybe interop knows about it?\r\n\r\nInterop does not support FastCall calling convention. From https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.callingconvention?view=netcore-2.0 : FastCall This calling convention is not supported.",
                                           "updatedAt":  "2018-03-26T18:50:51Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY2NzcwNzgzOQ==",
                                           "createdAt":  "2020-08-02T18:20:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "LifeIsStrange",
                                           "body":  "Friendly ping as two years passed and I believe it\u0027s an \"easy\" yet probably very significant performance optimization! ",
                                           "updatedAt":  "2020-08-02T18:20:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY2ODE3NTQzOA==",
                                           "createdAt":  "2020-08-03T18:29:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODv0f6g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "LifeIsStrange",
                                                                               "createdAt":  "2020-08-03T20:28:57Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tanveerbadar",
                                                                               "createdAt":  "2024-04-16T13:16:40Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-08-27T12:33:26Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "CarolEidt",
                                           "body":  "@LifeIsStrange - this was something that we had hoped to be able to make progress on for the 5.0 release (starting with supporting the correct standard calling conventions for both Linux and Windows, where the former passes vectors in registers, and both conventions call for returning vectors in registers). However, there was enough complexity between the runtime stubs and the JIT handling, that it didn\u0027t get completed.",
                                           "updatedAt":  "2020-08-03T18:29:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41SJgf",
                                           "createdAt":  "2021-08-06T02:09:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "@tannergooding Any interest in updating this issue with a proposal for leveraging the design in https://github.com/dotnet/runtime/issues/51156?",
                                           "updatedAt":  "2021-08-06T02:09:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5EyzVu",
                                           "createdAt":  "2022-06-13T17:04:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "Moving to 8.0.",
                                           "updatedAt":  "2022-06-13T17:04:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5L0Se_",
                                           "createdAt":  "2022-10-07T19:06:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Rationale\r\n\r\nToday, the runtime supports the `__fastcall` calling convention, which not only allows interop with any native code that uses that calling convention but also allows it to take advantage of the additional registers that are available on the underlying architecture.\r\n\r\nHowever, it means that operating with certain data types is still \"sub-optimal\".\r\n\r\nMicrosoft Windows provides the `__vectorcall` calling convention just for this purpose (https://msdn.microsoft.com/en-us/library/dn375768.aspx). It extends the existing `__fastcall` calling convention to additionally allow SIMD vector types and Homogeneous Vector Aggregate values to be passed via register rather than on the stack.\r\n\r\nThe `System V AMD64 ABI` already defines vector sized types (__m128, __m256) and supports passing them in register.\r\n\r\n### Proposal\r\n\r\nThe runtime should add support for the `__vectorcall` calling convention, not only to improve performance, but to also provide better interop with native code that uses it.\r\n\r\nThe `__vectorcall` calling convention should be exposed on `System.Runtime.InteropServices.CallingConvention` as `VectorCall`.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003etannergooding\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `area-Interop-coreclr`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e8.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-10-07T19:06:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5MdTo0",
                                           "createdAt":  "2022-10-18T17:20:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCuDuqA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2022-10-18T17:33:41Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "bartonjs",
                                           "body":  "[Video](https://www.youtube.com/watch?v=--yp28cKQ_E\u0026t=0h0m0s)\n\n* The existing CallConv types that end in \"conv\" use a lowercase C, so this should as well.\r\n* Do we also need to update System.Reflection.SignatureCallingConvention and/or System.Runtime.InteropServices.CallingConvention?\r\n\r\n```C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n     public class CallConvVectorcall\r\n     {\r\n         // This type has no members and is identical in structure to other `CallConv*` types\r\n     }\r\n}\r\n```\r\n",
                                           "updatedAt":  "2022-10-18T19:11:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5MdXNG",
                                           "createdAt":  "2022-10-18T17:33:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e Do we also need to update System.Reflection.SignatureCallingConvention and/or System.Runtime.InteropServices.CallingConvention?\r\n\r\n@bartonjs Nope. Both of these enums map to metadata encodings and can\u0027t/shouldn\u0027t be updated without updating ECMA-335. We created the [`UnmanagedCallConv`](https://learn.microsoft.com/dotnet/api/system.runtime.interopservices.unmanagedcallconvattribute) specifically to avoid this limitation. All new calling conventions should use the `CallConv*` convention we are employing here.",
                                           "updatedAt":  "2022-10-18T17:33:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5MdYuJ",
                                           "createdAt":  "2022-10-18T17:39:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "/cc @lambdageek We are considering this for .NET 8. Would there be any concerns here on the mono side?",
                                           "updatedAt":  "2022-10-18T17:39:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5MdZvy",
                                           "createdAt":  "2022-10-18T17:41:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lambdageek",
                                           "body":  "Cc @lateralusX ",
                                           "updatedAt":  "2022-10-18T17:41:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Mda1-",
                                           "createdAt":  "2022-10-18T17:45:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lambdageek",
                                           "body":  "@AaronRobinsonMSFT I think we would want to do this together with support for simd ABIs  on non-windows platforms. @fanyang-mono had started the work in net7 for AOT, but we had to revert because it wasn\u0027t usable without JIT or interp support. __vectorcall would probably face many of the same issues.\n\nCc @SamMonoRT ",
                                           "updatedAt":  "2022-10-18T17:45:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5MlmfX",
                                           "createdAt":  "2022-10-20T04:59:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "BruceForstall",
                                           "body":  "Does `CallConvVectorcall` as specified here apply exclusively to the Windows x86/x64, Microsoft-defined, `__vectorcall` convention (https://learn.microsoft.com/en-us/cpp/cpp/vectorcall?redirectedfrom=MSDN\u0026view=msvc-170)?\r\n\r\nDo we need a similar but different one to support the Arm64 Vector Procedure Call Standard (AAVPCS, referenced above https://github.com/dotnet/runtime/issues/8300#issuecomment-364217223, defined here: https://github.com/ARM-software/abi-aa/blob/main/vfabia64/vfabia64.rst)?",
                                           "updatedAt":  "2022-10-20T04:59:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5d6TY1",
                                           "createdAt":  "2023-06-04T13:11:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODr4pVQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pentp",
                                                                               "createdAt":  "2023-06-05T09:52:15Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Daniel-Svensson",
                                                                               "createdAt":  "2023-06-30T16:18:23Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tanveerbadar",
                                                                               "createdAt":  "2024-04-16T13:18:20Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ChaimCL",
                                                                               "createdAt":  "2024-07-29T01:05:54Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "benaadams",
                                           "body":  "Would be a very welcome addition (especially if used internally for parameters and returns) \r\n\r\n1 week to 10 year anniversary of Introducing ‘Vector Calling Convention’ blog post https://devblogs.microsoft.com/cppblog/introducing-vector-calling-convention/",
                                           "updatedAt":  "2023-06-04T13:11:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5hJeuQ",
                                           "createdAt":  "2023-07-10T23:37:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "Moving to .NET 9 as we aren\u0027t going to get to this before feature-complete.",
                                           "updatedAt":  "2023-07-10T23:37:47Z"
                                       }
                                   ],
                         "totalCount":  29
                     },
        "title":  "Runtime should be updated to support the `__vectorcall` calling convention",
        "labels":  [
                       "api-approved",
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/9089",
        "createdAt":  "2017-10-09T09:45:39Z",
        "number":  9089,
        "author":  "xoofx",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODC3prA==",
                          "nodes":  [
                                        {
                                            "content":  "HEART",
                                            "user":  "redknightlois",
                                            "createdAt":  "2017-10-09T14:02:23Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "hexawyz",
                                            "createdAt":  "2018-03-19T12:32:32Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "FrankNiemeyer",
                                            "createdAt":  "2018-04-24T12:49:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "nietras",
                                            "createdAt":  "2018-10-10T09:36:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "nulldatamap",
                                            "createdAt":  "2018-10-12T14:00:42Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "vermorel",
                                            "createdAt":  "2019-02-12T11:17:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "viktor-svub",
                                            "createdAt":  "2019-08-20T05:54:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lostmsu",
                                            "createdAt":  "2019-08-21T00:42:04Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ForNeVeR",
                                            "createdAt":  "2022-05-08T13:54:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "h3xds1nz",
                                            "createdAt":  "2024-12-28T21:06:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ikkentim",
                                            "createdAt":  "2025-03-12T10:34:45Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "levitation",
                                            "createdAt":  "2025-05-27T17:22:09Z"
                                        }
                                    ],
                          "totalCount":  12
                      },
        "updatedAt":  "2024-11-06T22:49:08Z",
        "body":  "Currently with `[StructLayout]` we can define both the size (via `Size` field) and the field packing (via `Pack` field) . Unfortunately, it doesn\u0027t cover the case in C++ where you can have an alignment attribute directly on the struct that indicates how this struct should be aligned when used for example in another struct.\r\n\r\nThis is actually quite a limitation when for example you want to have a struct that maps to a vector SIMD intrinsic as their natural alignment is usually not the alignment of the component. For a `Vector4f`, the align of this struct in C# would be `sizeof(float)`, while it would be `4xsizeof(float)` for the intrinsic.\r\n\r\nThis could also help in regular interop scenarios where this align attribute is actually specified on the C++ struct.\r\n\r\n\u003e Note: As this is an API change but most of the work would be in `coreclr`, not sure if this is the right place to post this instead of `corefx`. Let me know if you can move it there.\r\n\r\n# `StructLayout.Align`\r\n\r\nThe proposal is to add a new property `Align` on `StructLayout`:\r\n\r\n```C#\r\n public sealed class StructLayoutAttribute : Attribute\r\n{\r\n    ...\r\n    public int Align;\r\n    ...\r\n}\r\n```\r\n\r\nBy default, the alignment is 0, meaning that it will take the natural alignment of the struct (which is the default today). Otherwise it will take the alignment specified by this field.\r\n\r\ncc: @jkotas @CarolEidt \r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOkq8cwg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNTExNzMxNw==",
                                           "createdAt":  "2017-10-09T10:18:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "https://github.com/dotnet/coreclr/issues/5195\r\n\r\nSome discussion on https://github.com/dotnet/corefx/issues/22790\r\n\r\nGC seems to be biggest issue",
                                           "updatedAt":  "2017-10-09T10:18:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNTExOTIyMQ==",
                                           "createdAt":  "2017-10-09T10:27:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xoofx",
                                           "body":  "@benaadams oops, thanks! missed that one, will close this one and comment on the original issue then.",
                                           "updatedAt":  "2017-10-09T10:27:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNTExOTUwNQ==",
                                           "createdAt":  "2017-10-09T10:29:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xoofx",
                                           "body":  "Reopening, actually this is slightly different.",
                                           "updatedAt":  "2017-10-09T10:29:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNTExOTg2NA==",
                                           "createdAt":  "2017-10-09T10:31:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xoofx",
                                           "body":  "In this proposal, the alignment doesn\u0027t need to enforce any memory alignment at runtime (as it would be pretty difficult with GC, array of value types...etc.)... but only the field offset of a field which is of a struct type having an align attribute.\r\n\r\nFrom issue [dotnet/corefx#22790](https://github.com/dotnet/corefx/issues/22790#issuecomment-333386626) this is only for the option 1. described by @jkotas \r\n",
                                           "updatedAt":  "2017-10-09T10:35:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNTEyMTM1Nw==",
                                           "createdAt":  "2017-10-09T10:38:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "Ah; Leading padding? Rather than having to set FieldOffset?",
                                           "updatedAt":  "2017-10-09T10:38:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNTEyMjM5Mw==",
                                           "createdAt":  "2017-10-09T10:44:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xoofx",
                                           "body":  "\u003e Ah; Leading padding? Rather than having to set FieldOffset?\r\n\r\nSomewhat, but instead of having to specify it on the field, it is specified on the type, as it can be specified in C++: \r\n- In MSVC, this is specified via the [`align`](https://msdn.microsoft.com/en-us/library/83ythb65.aspx) attribute \r\n- In GCC, clang, this is the [`aligned` attribute](https://gcc.gnu.org/onlinedocs/gcc-4.5.2/gcc/Type-Attributes.html)\r\n",
                                           "updatedAt":  "2017-10-09T10:44:08Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNTEyMjg0Mw==",
                                           "createdAt":  "2017-10-09T10:46:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "I mean rather than having to specify the FieldOffset in the containing type; would also be nice if it applied to `stackalloc` also",
                                           "updatedAt":  "2017-10-09T10:46:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNTEyMzk2MQ==",
                                           "createdAt":  "2017-10-09T10:52:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAu6POA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "lostmsu",
                                                                               "createdAt":  "2019-08-21T00:42:00Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "xoofx",
                                           "body":  "Ideally for example, vector types in `System.Numerics.Vector` (e.g Vector3, Vector4) should have been tagged with this alignment attribute so that they would have matched their SIMD counterpart (and even their GPU counterpart). As it would be a breaking change now, we can\u0027t apply this on them...\r\n\r\nFor alignment in memory (not within field struct), this is a different story, and as @jkotas explained in corefx, it is a pain to achieve considering the transitive/intrusive impact it has to determine the correct alignment of the final pointer (so same would apply to `stackalloc`)\r\n\r\nBut as I said, I\u0027m not really interested in memory alignment (at least not in this proposal). This proposal (of adding align on struct) is anyway a first step before trying to implement full memory alignment of allocated objects. For true memory alignment, we can currently workaround this by using native buffer and control allocation/alignment on our own, so it is less a critical issue.",
                                           "updatedAt":  "2017-10-09T10:59:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNTE4MTYzOA==",
                                           "createdAt":  "2017-10-09T14:50:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "@xoofx, What I don\u0027t understand is how your proposal is different from the other two issues? It seems like, in all three cases, the memory would end up being aligned and you are just proposing one way to go about doing that.\r\n\r\nEven if this only impacts the field offset, that still has to be computed at runtime. That is, to ensure the field of type `X` is always 16-byte aligned, you would need to ensure the containing type is always properly aligned as well, otherwise the offset could change from allocation to allocation (breaks unsafe code and other assumptions) or the field alignment would not be always guaranteed (you say `16`, but you get `4`).",
                                           "updatedAt":  "2017-10-09T14:50:25Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNTE4NzE0Nw==",
                                           "createdAt":  "2017-10-09T15:09:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xoofx",
                                           "body":  "\u003e @xoofx, What I don\u0027t understand is how your proposal is different from the other two issues? It seems like, in all three cases, the memory would end up being aligned and you are just proposing one way to go about doing that.\r\n\r\nHi @tannergooding  On the other issue, you were mostly focused [on option 2](https://github.com/dotnet/corefx/issues/22790#issuecomment-333387107) described by @jkotas \r\n\r\nI\u0027m focused on option 1, which has a lot less runtime implications.\r\n\r\n\u003e Even if this only impacts the field offset, that still has to be computed at runtime. \r\n\r\nYes, but for this issue specifically, this is a very minor change to the runtime (unlike alignment of memory allocations - option 2)\r\n\r\n\u003e That is, to ensure the field of type X is always 16-byte aligned, you would need to ensure the containing type is always properly aligned as well, otherwise the offset could change from allocation to allocation (breaks unsafe code and other assumptions) or the field alignment would not be always guaranteed (you say 16, but you get 4).\r\n\r\nI want correct field offset computed from type alignment, as it is done in C++, to enable correct interop scenarios. I don\u0027t strictly care about the final memory alignment for a particular field.\r\n",
                                           "updatedAt":  "2017-10-09T15:09:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNTE5NDU2Mg==",
                                           "createdAt":  "2017-10-09T15:34:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "So you are just proposing a way to compute field offset without computing alignment?\r\n\r\nThat is, today in C/C++ you might have:\r\n```C++\r\nstruct alignas(16) A    // Align: 16, Explicit\r\n{\r\n    float x;            // Offset: 0\r\n    float y;            // Offset: 4\r\n    float z;            // Offset: 8\r\n    float w;            // Offset: 12\r\n}\r\n\r\nstruct B                // Align: 16, Implicit\r\n{\r\n   int x;               // Offset: 0\r\n   A   y;               // Offset: 16\r\n}\r\n```\r\n\r\nIn C# (today), you have to declare\r\n```C#\r\n[StructLayout(LayoutKind.Sequential)]\r\npublic struct A         // Align: 4\r\n{\r\n    public float x;     // Offset: 0\r\n    public float y;     // Offset: 4\r\n    public float z;     // Offset: 8\r\n    public float w;     // Offset: 12\r\n}\r\n\r\n[StructLayout(LayoutKind.Explicit)]\r\npublic struct B         // Align: 4\r\n{\r\n    [FieldOffset(0)]\r\n    public int x;       // Offset: 0\r\n\r\n    [FieldOffset(16)]\r\n    public A   y;       // Offset: 16\r\n}\r\n```\r\n\r\nYou are proposing we allow:\r\n```C#\r\n[StructLayout(LayoutKind.Sequential, Align=16)]\r\npublic struct A         // Align: 4\r\n{\r\n    public float x;     // Offset: 0\r\n    public float y;     // Offset: 4\r\n    public float z;     // Offset: 8\r\n    public float w;     // Offset: 12\r\n}\r\n\r\n[StructLayout(LayoutKind.Sequential)]\r\npublic struct B         // Align: 4\r\n{\r\n    public int x;       // Offset: 0\r\n    public A   y;       // Offset: 16\r\n}\r\n```\r\n\r\nIs that correct?",
                                           "updatedAt":  "2017-10-09T15:34:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNTIwMDMzOQ==",
                                           "createdAt":  "2017-10-09T15:54:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xoofx",
                                           "body":  "\u003e Is that correct?\r\n\r\nYes 👍 ",
                                           "updatedAt":  "2017-10-09T15:54:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNTIwMTQ3Ng==",
                                           "createdAt":  "2017-10-09T15:58:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAOGHuQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CarolEidt",
                                                                               "createdAt":  "2017-10-09T16:08:12Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e The proposal is to add a new property Align on StructLayout\r\n\r\nStructLayout is pseudo custom attribute (look Pseudo Custom Attributes in ECMA-335). Adding fields to pseudo custom attribute would be a metadata breaking change that resets the ecosystem - no existing runtimes and tools would understand it. I think this would need to be a different attribute.",
                                           "updatedAt":  "2017-10-09T15:58:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzNTIwNDg0OQ==",
                                           "createdAt":  "2017-10-09T16:09:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAu01_g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "viktor-svub",
                                                                               "createdAt":  "2019-08-20T05:56:09Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "xoofx",
                                           "body":  "\u003e  I think this would need to be a different attribute.\r\n\r\nGood to know. So what about having something like a new attribute `StructAlignAttribute(align)`?\r\nIs it going to be a problem to have to fetch this custom attribute on the type when computing the fields offsets? (e.g perf wise)",
                                           "updatedAt":  "2017-10-09T16:09:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5pFiKg",
                                           "createdAt":  "2023-10-14T17:29:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODJyIUQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "2A5F",
                                                                               "createdAt":  "2023-10-15T14:59:00Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "lunafoxfire",
                                           "body":  "I would just like to chime in and say that this is a feature that would be very useful for interop with GPU technologies like Vulkan. I\u0027m doing a lot of compute shader work using C# and GLSL, and it is currently a pain to follow the Vulkan SSBO memory layout spec. As it is, I need to set all the `FieldOffset`s manually for all of my custom data structs. But, if I could instead apply some sort of `StructAlign` attribute to all of my base vector/matrix structs, then I could just define the alignment rules and everything would magically work.",
                                           "updatedAt":  "2023-10-14T17:29:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6SrxzC",
                                           "createdAt":  "2024-11-06T22:49:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kg",
                                           "body":  "Having a way to enforce alignment for structs would also be very useful for vectorized data structures; in my vectorized dictionary prototype, depending on the key/value sizes you can get extremely bimodal performance variance (in a bad way) for BDN measurements. In this scenario at least, alignment/false sharing issues are the only explanation I can come up with, and they only appear on one arch (intel) and not the other. So it would be cool to see array element or struct alignment as a mitigation for this.\n\nTrimmed performance data to show what I mean:\n\n## Ryzen 7950X\n| Type         | Method           | Mean     | Error   | StdDev  | Code Size |\n|------------- |----------------- |---------:|--------:|--------:|----------:|\n| IntLookup    | FindExistingSIMD | 265.4 us | 1.13 us | 1.06 us |     658 B |\n\n## Intel i7-1265U\n\n| Type         | Method           | Mean     | Error    | StdDev   | Code Size |\n|------------- |----------------- |---------:|---------:|---------:|----------:|\n| IntLookup    | FindExistingSIMD | 316.8 us | 16.29 us | 48.03 us |     700 B |\n\n```\n  IntLookup.FindExistingSIMD: Default -\u003e It seems that the distribution is bimodal (mValue = 3.47)\n```",
                                           "updatedAt":  "2024-11-06T22:49:07Z"
                                       }
                                   ],
                         "totalCount":  16
                     },
        "title":  "API Proposal: Add alignment to StructLayout",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/1883",
        "createdAt":  "2020-01-17T22:06:27Z",
        "number":  1883,
        "author":  "isaacabraham",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOBKiWfQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "khellang",
                                            "createdAt":  "2020-01-19T11:40:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "r3econ",
                                            "createdAt":  "2020-07-16T10:42:57Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2021-11-10T14:36:38Z",
        "body":  "You can check the OSPlatform via the `System.Runtime.InteropServices.IsOSPlatform` method, but it would be very useful to have an actual property on the `System.Runtime.InteropServices` in addition to a method.\r\n\r\nThis would lend itself well for features such as pattern matching rather than if / then expressions or statements, which at least have something more in the way of exhaustiveness checks e.g.\r\n\r\n```fsharp\r\nopen System.Runtime\r\n\r\nmatch InteropServices.OSPlatform with\r\n| OSPlatform.Windows -\u003e ...\r\n| OSPlatform.Linux -\u003e ...\r\n| _ -\u003e ...\r\n```\r\n\r\nIn F# you can sort of work around this with active patterns but it\u0027s not ideal, and in C# I suppose it\u0027d be more work.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOOYkcDQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NjA1Mjg3Mw==",
                                           "createdAt":  "2020-01-19T22:09:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vcsjones",
                                           "body":  "The `OSPlatform` type is not an enum - it\u0027s a class with static properties. Even if you do have an instance of an `OSPlatform` it\u0027s still difficult to pattern match on. e.g. this doesn\u0027t work.\r\n\r\n```fsharp\r\nlet plat = OSPlatform.Create \"DOS\"\r\nlet name = match plat with\r\n           | OSPlatform.Linux -\u003e \"Linux\"\r\n           | OSPlatform.Windows -\u003e \"Windows\"\r\n           | _ -\u003e \"Other\"\r\n\r\nprintfn \"Platform: %s\" name\r\n```\r\n\r\nSo I am curious if this is workable, or perhaps I\u0027m too rusty with F# to see how this could pattern match well.",
                                           "updatedAt":  "2020-01-19T22:09:21Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NjE2NTI4Mw==",
                                           "createdAt":  "2020-01-20T08:35:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCCxF9w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Mrxx99",
                                                                               "createdAt":  "2021-11-16T16:29:03Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "isaacabraham",
                                           "body":  "Yep, I know it\u0027s not an enum. And you\u0027re right, it can never be exhaustive without a wildcard handler (even an enum can\u0027t be exhaustive as you can happily cast an int to it). However, there appear to be three \"standard\" values in the library (Windows, Linux and OSX) which I imagine the majority of people will test against.\r\n\r\nThese sorts of tests normally would be done through pattern matching rather than if / thens - it\u0027s just the idiomatic way of doing things - but without a value to match on, it\u0027s a bit awkward.\r\n\r\nI also found it a little unusual (IMHO, but maybe this is more design aesthetics) that I couldn\u0027t ask the runtime \"What OS are you?\". Instead you have to ask \"Are you this OS? Are you that OS? Or the other OS\"?.\r\n\r\nI\u0027d be happy to try and add that property onto the type if there would be interest in accepting such a PR.",
                                           "updatedAt":  "2020-01-20T08:35:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NjI3NDgyNA==",
                                           "createdAt":  "2020-01-20T13:29:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e I\u0027d be happy to try and add that property onto the type if there would be interest in accepting such a PR.\r\n\r\nThe first thing to do is to turn this into a formal API proposal: https://github.com/dotnet/runtime/blob/master/docs/project/api-review-process.md\r\n\r\nAlso, look at the existing proposals in this space, e.g.: https://github.com/dotnet/corefx/issues/27417",
                                           "updatedAt":  "2020-01-20T13:29:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NjMxMDQxNg==",
                                           "createdAt":  "2020-01-20T14:57:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOA5fOcw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "isaacabraham",
                                                                               "createdAt":  "2020-01-20T23:20:55Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "vcsjones",
                                           "body":  "\u003e These sorts of tests normally would be done through pattern matching rather than if / thens - it\u0027s just the idiomatic way of doing things - but without a value to match on, it\u0027s a bit awkward.\r\n\r\nSure, but assuming you _could_ get the OSPlatform - how would the pattern match look in F#? The snippet I posted above does not compile but attempts to match on an OSPlatform. I ask because perhaps that may influence the formal API proposal.",
                                           "updatedAt":  "2020-01-20T14:57:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NjQ1ODM5Mw==",
                                           "createdAt":  "2020-01-20T23:21:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "isaacabraham",
                                           "body":  "Understood. Let me have a bash tomorrow. ",
                                           "updatedAt":  "2020-01-20T23:21:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NjU3MDk4Ng==",
                                           "createdAt":  "2020-01-21T08:26:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "isaacabraham",
                                           "body":  "@vcsjones as you say, as it\u0027s just a property, you can\u0027t directly pattern match against it unless you start using `when` clauses e.g.\r\n\r\n```fsharp\r\nlet name =\r\n    match currentPlatform with\r\n    | _ when currentPlatform = OSPlatform.Linux -\u003e \"Linux\"\r\n    | _ when currentPlatform = OSPlatform.Windows -\u003e \"Windows\"\r\n    | _ -\u003e \"Other\"\r\n```\r\n\r\nBut assuming a single property was made available, with a simple active pattern you can then easily match on the OS:\r\n\r\n```fsharp\r\nlet (|OS|_|) platform dest = if platform = dest then Some() else None\r\nlet name =\r\n    match RuntimeInformation.CurrentPlatform with\r\n    | OS OSPlatform.Linux -\u003e \"Linux\"\r\n    | OS OSPlatform.Windows -\u003e \"Windows\"\r\n    | _ -\u003e \"Other\"\r\n```\r\n\r\nwhere `RuntimeInformation.CurrentPlatform` is the newly added property.\r\n\r\nTo be honest, this isn\u0027t just about F# or pattern matching if I think about it, but simply the ability to ask the application: \"What operating system are you running on?\".",
                                           "updatedAt":  "2020-01-21T08:26:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc45iRwN",
                                           "createdAt":  "2021-11-10T14:36:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCB_k2A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "b4ux1t3",
                                                                               "createdAt":  "2021-11-10T15:35:29Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "AnthonyMastrean",
                                           "body":  "Looks like `System.OperatingSystem` is replacing `System.Runtime.InteropServices.RuntimeInformation` as of #40111. I\u0027m not sure where that leaves `System.Environment.OSVersion`. It doesn\u0027t look like there\u0027s any runtime constants to support pattern matching and switch expressions... and `PlatformID` is on the way out as of #55914?",
                                           "updatedAt":  "2021-11-10T14:36:38Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "Add the ability to \"get\" the OSPlatform",
        "labels":  [
                       "api-needs-work",
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/33802",
        "createdAt":  "2020-03-19T16:43:07Z",
        "number":  33802,
        "author":  "terrajobst",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-10-08T16:24:28Z",
        "body":  "`sizeof` is much more efficient than `Marshal.SizeOf`.  In cases where they\u0027ll produce the same answer, the former should be preferred (it\u0027ll generally require using `unsafe`, though, so this should only fire if `unsafe` is allowed in the project).\n\n**Category**: Performance",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHON-UNlQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYwMTI4NzMwNw==",
                                           "createdAt":  "2020-03-19T16:45:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "How do we determine they will produce the same answer?",
                                           "updatedAt":  "2020-03-19T16:45:46Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYwMTQ2MTgzOA==",
                                           "createdAt":  "2020-03-19T23:25:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "terrajobst",
                                           "body":  "AFAIK @stephentoub wrote this one. I think the idea is that we can know this statically either by having a list of hardcoded types or when the type has the right characteristic based on the data in the reference assembly.",
                                           "updatedAt":  "2020-03-19T23:25:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYwMTYyNDE0Mw==",
                                           "createdAt":  "2020-03-20T10:16:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBlnHnQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "airbreather",
                                                                               "createdAt":  "2021-03-31T22:25:24Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Gnbrkm41",
                                           "body":  "\u003e so this should only fire if unsafe is allowed in the project.\r\n\r\nWhat about the `S.R.CS.Unsafe` alternative? That class, while equally \"unsafe\", does not require the language keyword `unsafe` and relevant settings in the project file.",
                                           "updatedAt":  "2020-03-20T10:16:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYwMTk2ODgyOQ==",
                                           "createdAt":  "2020-03-21T00:53:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "Estimates:\r\n* Analyzer: Medium\r\n* Fixer: Small",
                                           "updatedAt":  "2020-03-21T00:53:22Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYwMjAzMTE5Nw==",
                                           "createdAt":  "2020-03-21T11:32:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Joe4evr",
                                           "body":  "@Gnbrkm41 There\u0027s a proposal to mark methods that do \"unsafe\" things but lack doing things with actual pointers to force that they are called from an `unsafe` context: #31354. Practically all methods in `S.R.CS.Unsafe` also qualify, but as noted in that thread, you\u0027ve already written `Unsafe.\u003csomething\u003e` so it may look a bit redundant. (For the record, I think the redundancy is not enough reason to *not* mark them, mainly because of `using static`.)",
                                           "updatedAt":  "2020-03-21T11:32:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY4NTM0NTMzMw==",
                                           "createdAt":  "2020-09-02T06:35:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Mrnikbobjeff",
                                           "body":  "So we would warn for all primitives used in Marshal.Sizeof() except for char and bool as they differ from sizeof. This could probably also be extended to value types, but then the analyzed would become quite a lot more complicated. I assume the baseline request covers simply known primitives?",
                                           "updatedAt":  "2020-09-02T06:35:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY4NTQ1NzA2MA==",
                                           "createdAt":  "2020-09-02T08:55:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Mrnikbobjeff",
                                           "body":  "Also, which Marshal.SizeOf options to we aim to find with the analyzer? I assume only the invocations with one type argument, as the overloads accepting either a type or an object are already flagged as obsolete?",
                                           "updatedAt":  "2020-09-02T09:02:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43t_Qi",
                                           "createdAt":  "2021-10-05T20:43:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "@Mrnikbobjeff can you please explain how you determined that only `char` and `bool` have a different return value with `sizeof` vs `Marshal.SizeOf()`? Why don\u0027t other primitives have this difference?\r\n\r\n@Gnbrkm41 would you mind sharing examples of `S.R.CS.Unsafe` being flagged by this proposed analyzer?\r\n\r\nWhat is the condition to require unsafe code in the project?\r\n\r\nFor example, these don\u0027t require to enable unsafe code in my project:\r\n```cs\r\nint x = sizeof(char);\r\nint y = sizeof(bool);\r\nint z = sizeof(int);\r\n```\r\n\r\nBut these cases do:\r\n```cs\r\nint w = sizeof(z);\r\nint r = sizeof(5);\r\nint v = 4;\r\nint s = sizeof(v);\r\n```",
                                           "updatedAt":  "2021-10-05T20:43:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43uInb",
                                           "createdAt":  "2021-10-05T21:10:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOB9HL0A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2021-10-05T21:13:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Gnbrkm41",
                                                                               "createdAt":  "2021-10-05T23:57:50Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "carlossanlop",
                                                                               "createdAt":  "2021-10-06T00:47:29Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e For example, these don\u0027t require to enable unsafe code in my project:\r\n\r\n`sizeof` and `Unsafe.SizeOf\u003cT\u003e` are equivalent; they both compile down to the `sizeof` IL instruction and return the size of the managed layout.\r\nC# special cases `sizeof` for primitive types to be a constant (most of the types that have a keyword equivalent). Anything that isn\u0027t constant sized (including say `nint`, `nuint`, or `Guid`) requires `unsafe`.\r\n\r\n`Marshal.SizeOf\u003cT\u003e` returns the unmanaged layout of the type.\r\n\r\nIt\u0027s only safe to replace `Marshal.SizeOf\u003cT\u003e` with `sizeof` when the following conditions are met:\r\n* The type is considered `unmanaged` (contains no reference types, directly or indirectly)\r\n* The type is `Sequential` or `Explicit` layout\r\n* The type is only comprised of `blittable` types\r\n  * `bool` is not blittable, it is always \"normalized\" and defaults to being `4-bytes` for the unmanaged layout, while its `1-byte` in the managed layout\r\n  * `char` is sometimes blittable. By default it is `1-byte` for the unmanaged layout and `2-bytes` for the managed layout. If you force the unmanaged layout to be `2-bytes` (via interop attributes), it will be treated as blittable\r\n \r\nCC. @jkoritzinsky, @AaronRobinsonMSFT ",
                                           "updatedAt":  "2021-10-05T21:10:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc434yzR",
                                           "createdAt":  "2021-10-07T09:51:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Joe4evr",
                                           "body":  "\u003e Anything that isn\u0027t constant sized (including say `nint`, `nuint`, or `Guid`)\r\n\r\nI get `nint` and `nuint`, but why is `Guid` not a constant size of 16, tho? 🤔 ",
                                           "updatedAt":  "2021-10-07T09:51:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc435Q2V",
                                           "createdAt":  "2021-10-07T12:46:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD788rQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alexis-idigo",
                                                                               "createdAt":  "2024-11-21T16:44:30Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e I get nint and nuint, but why is Guid not a constant size of 16, tho\r\n\r\nBecause it isn\u0027t a \"primitive\u0027, its a user-defined struct and the C# language makes no substantial inferences about user-defined structs.\r\n* `decimal` is the one exception here, but its a bit special and has limitations the other primitives don\u0027t have. The language could special-case any number of other user-defined types, but that\u0027s not sustainable overall.\r\n\r\nAs far as the language is concerned, `Guid` is simply some value type that isn\u0027t known by the language and who\u0027s fields could change between when the C# compilation happens and when the IL compilation happens.\r\n\r\nLikewise, in cases of other structs the field contents might stay the same but the actual physical layout could change. For example, `nint`/`nuint` change in size between `32-bit` and `64-bit`. Some other struct such as `struct S { float x; double y; }` could also change (on some platforms, `double` or `long`/`ulong`, have a natural alignment of `4`, in which case the size is `12`, not `16`).\r\n\r\nSo its easiest in those cases to not allow it to be a C# constant and instead make it a JIT time constant instead (`static readonly` of a primitive type effectively works like this today; as does things like `sizeof` in IL, it becomes a JIT time constant).\r\n\r\n\r\n",
                                           "updatedAt":  "2021-10-07T12:46:45Z"
                                       }
                                   ],
                         "totalCount":  11
                     },
        "title":  "Prefer sizeof over Marshal.SizeOf",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.InteropServices",
                       "code-analyzer",
                       "code-fixer"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/37548",
        "createdAt":  "2020-06-06T20:00:23Z",
        "number":  37548,
        "author":  "nattthebear",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC3FMnw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "alexrp",
                                            "createdAt":  "2024-04-08T17:37:21Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2023-06-26T19:48:10Z",
        "body":  "I\u0027m currently working on porting a Windows only application to Linux and the lack of ability to express the equivalent of `__attribute__((ms_abi))` or `__attribute__((sysv_abi))` is a major pain point.  I\u0027m having to write my own custom wrappers around `GetFunctionPointerForDelegate` / `GetDelegateForFunctionPointer` that allocate their own trampolines to switch calling conventions.  The whole thing works, but I feel like a fully functional foreign call interface should support this when targeting amd64.  A lot of the CLR interop stuff feels very slanted towards x86-32 and Windows APIs.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOX9okyw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY0MDM2MjU2NQ==",
                                           "createdAt":  "2020-06-08T04:41:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "@nattthebear With respect to the scenario in question, I was a bit confused as to why anyone would want to use the `ms_abi` on a non-Windows scenarios. I asked some of the other .NET team members and the most common response was having a collection of hand written assembly that was targeted for Windows and is now being ported to a non-Windows platform. Is this the scenario in question? If there is another scenario were this is also common please feel free to share that as well.\r\n\r\nI am interested in the type of code being ported over to infer perhaps how common the scenario is and how many .NET developers would experience the described issue.\r\n\r\n\u003e but I feel like a fully functional foreign call interface should support this when targeting amd64.\r\n\r\nI agree in principle with this notion. The .NET FFI is lacking in some areas and they do need to be improved. For example, support for [`vectorcall`](https://github.com/dotnet/runtime/issues/8300). In this case support for a non-target platform\u0027s calling convention feels like the beginning of a platform emulation layer (e.g. Wine). I am unclear how desirable this is from a .NET runtime point of view since it puts a lot of pressure on the runtime to support precise non-target platform semantics on the target platform. There is no doubt there is value, but this comes down to a cost/benefit debate. Better understanding scenarios like yours would help in that debate.\r\n\r\n\u003eA lot of the CLR interop stuff feels very slanted towards x86-32 and Windows APIs.\r\n\r\nThat is generally true and is of course historical. Specific API suggestions are welcome. The details on how to proceed can be found at [here](https://github.com/dotnet/runtime/blob/master/docs/project/api-review-process.md). The [`CallingConvention.Winapi`](https://docs.microsoft.com/dotnet/api/system.runtime.interopservices.callingconvention) is poorly named, but represents the default calling convention on the OS (e.g. 32-bit Windows `stdcall`, 64-bit Windows `win-x64`, 32-bit Linux `cdecl`, 64-bit Linux `sysv-x86-64`).",
                                           "updatedAt":  "2020-06-08T04:41:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY0MDU5OTkwOA==",
                                           "createdAt":  "2020-06-08T13:23:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "nattthebear",
                                           "body":  "@AaronRobinsonMSFT Thank you for your response!  The more I think about it, I suspect my use case isn\u0027t very common at all.  I have native binaries that are architecture dependent but OS independent:  They\u0027re compiled as x86-64 using the msabi calling convention, but all syscalls are through an abstraction layer.  My C# application hosts those binaries, providing the OS abstraction layer and other related services and then interop to the native code within.\r\n\r\nThe native binaries are under my control and I could recompile them targeting sysv, but I also want memory dumps from them to be sharable cross platform, which means the exact same binaries on all supported systems, so either the Windows host would have to support sysv, or the Linux host would have to support msabi.\r\n\r\nWith a bit of spit and wire it all works, and the custom trampolines code (which is limited to my use case and doesn\u0027t support much beyond what I need right now) is only [a few hundred lines](https://github.com/TASVideos/BizHawk/blob/aa48af9c94d2e832e0a4f457991889d960783b2c/src/BizHawk.BizInvoke/CallingConventionAdapter.cs#L95), so maybe it\u0027s not a \"huge pain point\" for me after all.\r\n\r\n\u003e Specific API suggestions are welcome. \r\n\r\nI don\u0027t think I have the experience and expertise with .NET interop needed to make specific proposals.",
                                           "updatedAt":  "2020-06-08T13:23:08Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY0MDY4MTYwOQ==",
                                           "createdAt":  "2020-06-08T14:55:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e I have native binaries that are architecture dependent but OS independent: They\u0027re compiled as x86-64 using the msabi calling convention, but all syscalls are through an abstraction layer.\r\n\r\nThat is really impressive and sounds like some interesting tech.\r\n\r\n\u003eThe native binaries are under my control and I could recompile them targeting sysv, but I also want memory dumps from them to be sharable cross platform, which means the exact same binaries on all supported systems, so either the Windows host would have to support sysv, or the Linux host would have to support msabi.\r\n\r\nYep, makes sense.\r\n\r\n\u003eWith a bit of spit and wire it all works, and the custom trampolines code (which is limited to my use case and doesn\u0027t support much beyond what I need right now) is only a few hundred lines, so maybe it\u0027s not a \"huge pain point\" for me after all.\r\n\r\nThanks for the links, very informative. I agree this seems like a rather niche scenario. As I mentioned being able to support this does have value, but the cost seems a bit high for the few advanced users that would require the feature.\r\n\r\n\u003eI don\u0027t think I have the experience and expertise with .NET interop needed to make specific proposals.\r\n\r\nProposals can be very simple. In this case suggesting that the `ms_abi` and `sysv_abi` options be added to the `CallingConvention` enum with a list of reasons would be enough. It isn\u0027t expected that the proposer is also the implementer. If the community shows enough interest someone from the .NET team would probably wind up adding support, otherwise someone from the community would need to do the work.\r\n\r\nI\u0027ve marked this for Future and will update the title of the issue. We can leave this open for a while to see if anyone else in the community has thoughts as well.",
                                           "updatedAt":  "2020-06-08T14:55:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg4MDMzOTI1Mw==",
                                           "createdAt":  "2021-07-15T02:25:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "DaZombieKiller",
                                           "body":  "Just commenting to show my support for this feature. My scenario is very similar to the one expressed here, so many of the same factors apply.\r\n\r\nIdeally in addition to adding `ms_abi` and `sysv_abi` to the `CallingConvention` enum, these types could be exposed so they can be used with function pointers:\r\n```cs\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public class CallConvMsabi { }\r\n    public class CallConvSysv { }\r\n}\r\n```",
                                           "updatedAt":  "2021-07-15T02:25:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5SYKRE",
                                           "createdAt":  "2023-01-13T16:08:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCyp8uQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "DaZombieKiller",
                                                                               "createdAt":  "2023-01-13T19:20:05Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Beyley",
                                                                               "createdAt":  "2023-01-14T17:40:43Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "Perksey",
                                           "body":  "We\u0027ve just hit this on [dotnet/Silk.NET](https://github.com/dotnet/Silk.NET) in trying to interoperate with the vkd3d library, which uses ms_abi to mirror the Windows implementation of d3dcompiler. The scenario is we\u0027re trying to enable native portability of applications written against DirectX by using the Vulkan translation layer, and we\u0027re getting a segfault when calling into the library using plain stdcall because of this ms_abi issue.\r\n\r\ncc @tannergooding @Beyley looked like there was an issue for this already",
                                           "updatedAt":  "2023-01-13T16:08:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5fgK7p",
                                           "createdAt":  "2023-06-22T08:57:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Bargest",
                                           "body":  "I\u0027ve just hit the same problem. I have OS-independent code that takes callbacks from caller and invokes them using ms abi. On dotnet side I have an array of delegates and pass them to native code. Since I pass result of `GetFunctionPointerForDelegate()` and on linux the native function generated by dotnet is SYSV-oriented, library crashes trying to invoke the callback. The same problem when calling library callbacks from dotnet using `GetDelegateForFunctionPointer`.\r\nI\u0027ve ended up writing back and forth trampolines on assembly language, converting ABI between MS\u003c-\u003eSYSV, building them into raw byte array and wrapping each `GetFunctionPointerForDelegate()` result with such trampolines. Generating a generic forward trampoline for `GetDelegateForFunctionPointer()` was a great pain and this code does not look stable and secure at all.\r\n\r\nIf `GetFunctionPointerForDelegate` and `GetDelegateForFunctionPointer` could take an extra argument, directly specifying ABI and CallingConvention, it would be very handy. Something like\r\n```c#\r\nvar nativeForDelegate = Marshal.GetFunctionPointerForDelegate\u003cT\u003e(func, CallingConvention.StdCall | CallingConvention.MsAbi);\r\nvar delegateForNative = Marshal.GetDelegateForFunctionPointer\u003cT\u003e(ptr, CallingConvention.StdCall | CallingConvention.MsAbi);\r\n```\r\nImplementing this on dotnet side does not seem to be a big problem. As far as I understand current implementation of delegate marshalling it already uses precompiled native stubs as a kind of trampoline, expands them with info about delegate and stores them into some cache. In this case dotnet could have not just one stub, but one for each specified calling convention and abi combination.\r\n\r\nAnother option is to expand delegate\u0027s UnmanagedFunctionPointerAttribute to include ABI, but this is much less convenient. In case of two instances of OS-independent native code with same interface, one with MS ABI and other with SYSV ABI, if we need dotnet code to support both versions on both platforms, we would have to duplicate all delegate declarations in dotnet application with different attribute sets.",
                                           "updatedAt":  "2023-06-22T09:44:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5f1ilt",
                                           "createdAt":  "2023-06-26T17:00:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "nattthebear",
                                           "body":  "Glad to see there\u0027s still interest in this issue :+1:.\r\n\r\nIn my case, we did switch from ms to sysv for unrelated reasons, but as I detailed in my previous post that just means we need to marshal in the other direction (and since we have callbacks back into managed, still in both directions somewhere.)  These days, we\u0027re handling it with these trampolines written in assembly:  https://github.com/TASEmulators/BizHawk/blob/master/ExternalProjects/LibBizAbiAdapter/msabi_sysv.s#L143-L147.  They include full unwind information so SEH stack scanning can pass through them, and expect a JITed stub to provide the function pointer in `rax` which we do directly in C#.  They don\u0027t handle any more than 6 integer args or 4 fp args, and no mix of the two, so still are much cruder than a real solution.",
                                           "updatedAt":  "2023-06-26T17:00:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5f2iTL",
                                           "createdAt":  "2023-06-26T19:47:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Bargest",
                                           "body":  "Thanks, maybe I\u0027ll use it later. At least this looks more stable than my approach. I don\u0027t have control over native part though.\r\nSince I didn\u0027t need fp args and didn\u0027t want to build a native proxy dll, I compiled the following and saved this just as 3 byte arrays, allocating mem for each .net callback and saving `GetFunctionPointerForDelegate()` result at .dq 0. Trailer was the same for all created callbacks. .netToNative was used directly passing native address as first arg.\r\n```asm\r\nuse64\r\n\r\n; trampoline to call .net sysv callback from msabi native code on linux \r\n.nativeToNet:\r\ndq 0 ;\t\u003cstore trailer addr here\u003e\r\ndq 0 ;\t\u003cstore function addr here\u003e\r\ncall $+5\r\npop rax\r\n; save registers\r\n; SystemV: preserves\t       rbx, rsp, rbp, r12, r13, r14, r15\r\n; MSABI:   preserves rdi, rsi, rbx, rsp, rbp, r12, r13, r14, r15\r\npush rdi\r\npush rsi\r\n; translate arguments\r\n; first save 7th argument to stack\r\nmov rdi, [rsp + 24 + 32 + 8 * 2] ; saved  rsi + rdi + ret + shadow(32)\r\npush rdi\r\n; then all others\r\nmov rdi, rcx\r\nmov rsi, rdx\r\nmov rdx, r8\r\nmov rcx, r9\r\nmov  r8, [rsp + 32 + 32 + 8 * 0] ; saved  arg7 + rsi + rdi + ret + shadow(32)\r\nmov  r9, [rsp + 32 + 32 + 8 * 1]\r\n; call managed handler\r\npushq [rax - 5 - 16]   ; push trailer addr (one for all trampolines)\r\nmov rax, [rax - 5 - 8] ; call handler\r\njmp rax\r\n\r\n.trailer:\r\nadd rsp, 8 ; skip saved arg7\r\n; restore registers\r\npop rsi\r\npop rdi\r\nret\r\n\r\n; trampoline to call msabi callback from sysv .net code on linux\r\n.netToNative:\r\n; translate sysv abi to msabi\r\n; function addr is in first argument (rdi)\r\n; SystemV: preserves\t       rbx, rsp, rbp, r12, r13, r14, r15\r\n; MSABI:   preserves rdi, rsi, rbx, rsp, rbp, r12, r13, r14, r15\r\n; msabi saves everything sysv expects to be saved, so no need to save extras\r\n; translate stack arguments\r\nmov rax, [rsp + 16] ; skip ret, arg7\r\npush rax    ; save arg7\r\nmov rax, [rsp + 16] ; skip ret, saved arg, get arg6\r\npush rax    ; save arg 6\r\npush r9     ; save arg 5\r\nsub rsp, 32 ; allocate shadow space\r\n; translate reg arguments\r\nmov r9, r8\r\nmov r8, rcx\r\nmov rdx, rdx ; just nothing\r\nmov rcx, rsi\r\n; call unmanaged handler\r\ncall rdi\r\nadd rsp, 32 + 24 ; skip shadow and saved args\r\nret\r\n```\r\n",
                                           "updatedAt":  "2023-06-26T19:48:10Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Support setting GCC attributes ms_abi and sysv_abi on x86-64",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/37658",
        "createdAt":  "2020-06-09T18:35:34Z",
        "number":  37658,
        "author":  "AaronRobinsonMSFT",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-08-13T17:30:32Z",
        "body":  "Users in .NET 5.0 have a path for creating custom RCWs - see [`ComWrappers`](https://github.com/dotnet/runtime/issues/33329). The built-in RCW approach could bubble up details to the diagnostic space, but if users are defining their own this approach becomes a problem since debuggers will observe vanilla managed objects.\r\n\r\nCreating an attribute that users can adorn their RCWs with to help diagnostic tools might be useful. What information would be contained in such an attribute is something that diagnostic tool writers would be best to recommend.\r\n\r\n/cc @chuckries @noahfalk @jkoritzinsky @elinor-fung @weltkante ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOJkm4OA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY0MTU5MTU0Mw==",
                                           "createdAt":  "2020-06-09T21:27:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "weltkante",
                                           "body":  "\u003e The built-in RCW approach could bubble up details to the diagnostic space\r\n\r\nDid it do anything beyond perhaps IDispatch/ITypeInfo dynamic property discovery? In my experience RCWs mostly just exposed whatever was on the interface the current variable was typed to and I\u0027d expect that to continue to work. Personally I don\u0027t really care for dynamic/IDispatch type discovery, never worked that well for me anyways since it needed to execute native code which made it relatively brittle in practice.\r\n\r\nWhen I really wanted debugger support in the past to e.g. extract member fields of a COM instance I happened to know the layout of I defined custom a DebuggerTypeProxy attribute on the interface and/or coclass declarations (don\u0027t remember exactly) and that worked really well, but its been years I last wanted to do that (probably VS 2012 or earlier).",
                                           "updatedAt":  "2020-06-09T21:27:54Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY0MjM2NTQ5Ng==",
                                           "createdAt":  "2020-06-11T02:20:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003eDid it do anything beyond perhaps IDispatch/ITypeInfo dynamic property discovery?\r\n\r\nIt permitted a fair bit of diagnostics if sos in WinDBG was used. If VS was the debugger of choice then there wasn\u0027t much that was exposed.",
                                           "updatedAt":  "2020-06-11T02:20:50Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Diagnostic attribute for user defined RCWs",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/40892",
        "createdAt":  "2020-08-15T21:18:11Z",
        "number":  40892,
        "author":  "mjsabby",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC6Dz2A==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "GSPP",
                                            "createdAt":  "2020-08-17T11:45:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "nxrighthere",
                                            "createdAt":  "2020-10-07T01:31:06Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "maxkatz6",
                                            "createdAt":  "2022-05-27T05:18:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "andrei-faber",
                                            "createdAt":  "2022-11-03T21:59:37Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "onyxmaster",
                                            "createdAt":  "2024-04-08T22:04:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lindexi",
                                            "createdAt":  "2024-08-09T06:33:21Z"
                                        }
                                    ],
                          "totalCount":  6
                      },
        "updatedAt":  "2024-08-09T06:34:24Z",
        "body":  "## Background and Motivation\r\n`Marshal.AllocHGlobal` supports allocating native memory via C#. If a user wants to allocate native memory in a more specific way they have to write platform specific code that targets the underlying `VirtualAlloc` (on Windows) or `mmap` on *nix API call.\r\n\r\nThis is not ideal. While the code is not a lot, with proper error handling which are platform specific, not to mention a PInvokes in general is hard to get right with bitness, etc.\r\n\r\n## Proposed API\r\n```cs\r\nnamespace System.Runtime.InteropServices\r\n{\r\n     public class Marshal\r\n     {\r\n         public static IntPtr NativeAlloc(long size, MemoryProtection protection, AllocationOptions options)\r\n         {\r\n         }\r\n     }\r\n\r\n     [Flags]\r\n     public enum MemoryProtection\r\n     {\r\n         Read,\r\n         Write,\r\n         Execute,\r\n         NoAccess\r\n     }\r\n\r\n     [Flags]\r\n     public enum AllocationOptions\r\n     {\r\n         LargePagesAny,\r\n         LargePages2MB,\r\n         LargePages1GB,\r\n         Reserve,\r\n         Commit\r\n     }\r\n}\r\n```\r\n\r\n## Usage Examples\r\n```cs\r\nMarshal.NativeAlloc(2 * 1024 * 1024, MemoryProtection.Read | MemoryProtection.Write, AllocationOptions.LargePagesAny | AllocationOptions.Reserve | AllocationOptions.Commit);\r\n```\r\n\r\n## Other thoughts\r\n\r\nWe would throw `PlatformNotSupportedException` where these options or capability is not supported.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOh7v77Q==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY3NDQ0OTI3NA==",
                                           "createdAt":  "2020-08-15T21:31:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "- There is typically no concept of Reserve vs. Commit on non-Windows OSes. What would Reserve vs. Commit map to on non-Windows?\r\n- Do you also need an API to free the memory that got allocated this way?",
                                           "updatedAt":  "2020-08-15T21:31:34Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY3NDQ0OTQzOA==",
                                           "createdAt":  "2020-08-15T21:33:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "This has a lot of overlap with the existing MemoryMappedFile set of APIs. Would it make sense to piggy back on the existing APIs for this? E.g. https://docs.microsoft.com/en-us/dotnet/api/system.io.memorymappedfiles.memorymappedfilerights overlaps with MemoryProtection, etc.",
                                           "updatedAt":  "2020-08-15T21:33:48Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY3NDQ1ODE3Nw==",
                                           "createdAt":  "2020-08-15T23:40:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mjsabby",
                                           "body":  "@jkotas yes on both your comments. When you say piggy backing on the MemoryMappedFile set of APIs, are you proposing changing the namespace? I agree that the enums are valuable, but is there much more than that?\r\n\r\nPerhaps you\u0027re thinking we could also support MAP_SHARED?",
                                           "updatedAt":  "2020-08-15T23:40:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY3NDQ3MjczOQ==",
                                           "createdAt":  "2020-08-16T03:24:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "This functionality has large overlap with memory mapped files, so I do not see a problem with having it the same namespace as memory mapped files.",
                                           "updatedAt":  "2020-08-16T03:24:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Pg-V3",
                                           "createdAt":  "2022-12-01T16:38:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wasabii",
                                           "body":  "This is still open, but I want to throw another use case.\r\n\r\nI am using VirtualAlloc by hand to generate executable code regions to which I can directly jump to. That use case doesn\u0027t really fit in \u0027memory mapped files\u0027.",
                                           "updatedAt":  "2022-12-01T16:38:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Hu_vt",
                                           "createdAt":  "2024-08-09T06:34:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lindexi",
                                           "body":  "Reference from Avalonia: https://github.com/AvaloniaUI/Avalonia/blob/dcae7568b1080ff69cab40697f8f7647140af340/src/Avalonia.Base/Platform/Internal/UnmanagedBlob.cs#L122-L139",
                                           "updatedAt":  "2024-08-09T06:34:23Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "API Proposal: Marshal.AllocHGlobal like API that map to VirtualAlloc/mmap and support specifying Large Pages",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/42404",
        "createdAt":  "2020-09-17T20:13:36Z",
        "number":  42404,
        "author":  "Mrnikbobjeff",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-06-22T17:55:41Z",
        "body":  "After working on some Interop analyzers I thought about SafeHandle and how known api\u0027s could suggest using the corresponding safehandle, such as SafeFileHandle or SafeWaitHandle. This could also more broadly be applied based on the method name, e.g. methods contains alloc/free could offer a warning when an IntPtr is used instead of a custom safehandle.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOKYFF9A==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5NDQ3NDYwMg==",
                                           "createdAt":  "2020-09-17T20:13:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Dotnet-GitSync-Bot",
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2020-09-17T20:13:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5NjIzOTAwNA==",
                                           "createdAt":  "2020-09-21T16:52:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffschwMSFT",
                                           "body":  "@elinor-fung can you take a look?  ",
                                           "updatedAt":  "2020-09-21T16:52:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5NjMzNTI2Mg==",
                                           "createdAt":  "2020-09-21T19:50:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBRF6NA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2020-09-21T19:53:51Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Mrnikbobjeff",
                                                                               "createdAt":  "2020-09-22T06:30:20Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "elinor-fung",
                                           "body":  "I\u0027d be concerned with false positives with any attempt to use the method name. For known APIs, this seems reasonable, however we have https://github.com/dotnet/runtime/issues/42550, where marshalling `SafeHandle` doesn\u0027t allow null. We would need to address that issue before adding an analyzer like this.\r\n\r\n/cc @AaronRobinsonMSFT @jkoritzinsky ",
                                           "updatedAt":  "2020-09-21T19:50:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5NjMzNzkwOA==",
                                           "createdAt":  "2020-09-21T19:55:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "@elinor-fung Let\u0027s make sure we fold this into https://github.com/dotnet/runtime/issues/37039.",
                                           "updatedAt":  "2020-09-21T19:55:40Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Analyzer suggestion: Prefer SafeHandle over IntPtr",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "code-analyzer"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/45312",
        "createdAt":  "2020-11-29T16:24:32Z",
        "number":  45312,
        "author":  "TheSpydog",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOBYjAaQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "deccer",
                                            "createdAt":  "2020-11-29T16:55:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "flibitijibibo",
                                            "createdAt":  "2020-11-29T17:26:33Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "clarvalon",
                                            "createdAt":  "2020-12-01T20:37:10Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2021-05-09T17:45:16Z",
        "body":  "## Background and Motivation\r\n\r\nFor the FNA project, we have rather strict requirements when it comes to the build toolchain, conditional compilation, and compatibility across .NET runtimes. One of FNA\u0027s key features is its single-assembly portability -- the exact same assembly can be used across desktop, mobile, web, and console platforms, across three different runtimes (.NET Framework, Mono, and BRUTE). No per-platform / per-runtime compiler defines, no fancy build tooling. It just works.™️\r\n\r\nAll of the platform-specific code used by FNA is contained within native libraries. On macOS and Linux, FNA relies on Mono\u0027s dllmap feature for remapping library names (e.g. `SDL2` -\u003e `libSDL2-2.0.0.dylib` on macOS).\r\n\r\nIn .NET Core 3, the `NativeLibrary` API was introduced as the CoreCLR\u0027s replacement/alternative for dllmap, which allows developers to remap names in code rather than via an external XML configuration file. However, as I\u0027m sure many of you are well aware, [this does not satisfy all use cases that dllmap addressed](https://github.com/dotnet/runtime/issues/37213). As a result, we have yet to officially support FNA on the CoreCLR runtime.\r\n\r\nIn order to preserve FNA\u0027s single-assembly portability, we have the following requirements:\r\n1. Any changes to the library source must be compatible with .NET Framework.\r\n2. The library cannot contain any platform/runtime-specific preprocessor directives.\r\n3. The runtime must support library name remapping with ABI-versioned lib names.\r\n4. The library cannot use any NuGet packages or special build tooling.\r\n5. Existing FNA desktop applications must run on all supported runtimes with NO application-side code changes. (Barring exceptional circumstances like hard Windows dependencies, use of deprecated .NET APIs, etc.)\r\n\r\nMono\u0027s dllmap feature satisfies these requirements beautifully:\r\n1. No changes are required to the library code. All the remapping logic happens in the runtime.\r\n2. There are no runtime-specific APIs used to access this functionality, so there is no need for conditional compilation.\r\n3. Appending an ABI suffix to a library name is trivial. Just add an entry for the library and the OS in the .dll.config file and give it the correct name.\r\n4. Again, all the logic is handled in the runtime, with no external tooling necessary.\r\n5. Yet again, the application code doesn’t need to do anything special since the runtime takes care of all the logic.\r\n\r\nBut with .NET 5, there is currently no way to satisfy all of these requirements. Here are some of the solutions we\u0027ve attempted, and why they fail to support our use case:\r\n* Use the NativeLibrary API directly in the library.\r\n    * Breaks Req. 1. The NativeLibrary API is only supported in .NET Core 3.0+, so it can\u0027t work on .NET Framework.\r\n    * We can\u0027t conditionally compile it in, since that would break Req. 2.\r\n    * Even if we _could_ compile it, this would still fail because there\u0027s no single entry point to our library. We have no way of knowing which API a user will call first, so we have to either scatter static constructors throughout the codebase (which hurts performance on Mono and BRUTE) or use a module initializer (which is only available in C# 9, breaking Req. 1, or via build tools like fody, breaking Req. 4).\r\n* Ask the library user to call the NativeLibrary setup functions at the start of their program execution.\r\n    * Breaks Req. 5. This moves the burden of initializing our dependencies to the user. We absolutely don\u0027t want to do that.\r\n* Rely on the default DLL renaming algorithm (`Foo.dll` -\u003e `libFoo.dylib` / `libFoo.so`).\r\n    * Breaks Req. 4. This disregards any ABI versioning in the name of the library, which is essential to have for Linux where (1) users may have separately installed versions of our dependencies from a package manager, and (2) the native linker expects specific symversions, so libraries depending on other libraries in the application could fail to find each other.\r\n* Use fancy dynamic loading tricks to load a standalone .NET Core assembly, which then calls the NativeLibrary methods on our assembly, but only if we\u0027re running under CoreCLR.\r\n    * Besides being a super convoluted workaround, we also run into the exact same entry-point problems that we would using the NativeLibrary API directly.\r\n\r\nAs far as we can tell, there is currently no combination of features or workarounds that both preserve FNA\u0027s single-assembly portability and allow it to work correctly under CoreCLR without application-side intervention.\r\n\r\nHowever, I believe there might be a simple solution that integrates nicely with existing .NET Core idioms, maintains backwards compatibility for existing Core apps, and requires no intrusive code changes to existing applications.\r\n\r\n## Proposed API\r\n\r\nThe runtime could use an extended *.runtimeconfig.json configuration file to automatically remap library names for different operating systems and architectures.\r\n\r\nThis would take the form of a new (and completely optional) configuration array called `nativeLibraries`. Each of its elements is an object representing a single native library, with a `name` string and a `mappings` object. The `mappings` objects consist of platform + libname pairs, like so: `\"linux\": \"libFoo.so.0\"`, where the platform can be any .NET RID (e.g. \"linux\", \"linux-x64\", \"linux-arm\", \"osx\", \"osx-arm64\", etc.)\r\n\r\nAn example config file:\r\n```json\r\n{\r\n  \"runtimeOptions\": {\r\n    \"tfm\": \"net5.0\",\r\n    \"framework\": {\r\n      \"name\": \"Microsoft.NETCore.App\",\r\n      \"version\": \"5.0.0\"\r\n    },\r\n    \"nativeLibraries\": [\r\n      {\r\n        \"name\": \"libFoo\",\r\n        \"mappings\": {\r\n          \"linux\": \"libfoo.so.0\",\r\n          \"osx\": \"libfoo.0.dylib\",\r\n          \"win\": \"foo.dll\"\r\n        }\r\n      },\r\n      {\r\n        \"name\": \"libBar\",\r\n        \"mappings\": {\r\n          \"osx-x64\": \"libBar_x64.dylib\",\r\n          \"osx-arm64\": \"libBar_arm.dylib\"\r\n        }\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\nAt runtime, when calling a method marked with `DllImport(\"foo\")`, the high-level library loading logic will be as follows:\r\n1. If there is a NativeLibrary `DllImportResolver` registered for the assembly, perform the resolver callback.\r\n2. Probe for `foo.dll`, `libfoo.dylib` or `libfoo.so` (depending on the platform).\r\n3. **(NEW)** If there is a mapping in the config file for `foo` and the current OS, then attempt to load the mapped library name.\r\n4. Throw a DllNotFoundException.\r\n\r\nNotice that only a single step is added to the existing logic, and it will only run as a last resort. This ordering is intended to preserve existing CoreCLR behavior; the NativeLibrary API will _always_ override the runtimeconfig mappings, and applications which currently rely on probing will remain unchanged as well. Users could not use this feature to arbitrarily override the native library loading logic of existing applications. This reduces the likelihood of security vulnerabilities, while also allowing developers to opt in to non-intrusive, user-customizable loading logic for their future applications, if they so choose.\r\n\r\n## Usage Examples\r\n\r\nFNA.runtimeconfig.json would look like this:\r\n```json\r\n{\r\n  \"runtimeOptions\": {\r\n    \"tfm\": \"net5.0\",\r\n    \"framework\": {\r\n      \"name\": \"Microsoft.NETCore.App\",\r\n      \"version\": \"5.0.0\"\r\n    },\r\n    \"nativeLibraries\": [\r\n      {\r\n        \"name\": \"SDL2\",\r\n        \"mappings\": {\r\n          \"win\": \"SDL2.dll\",\r\n          \"linux\": \"libSDL2-2.0.so.0\",\r\n          \"osx\": \"libSDL2-2.0.0.dylib\"\r\n        }\r\n      },\r\n      {\r\n        \"name\": \"FAudio\",\r\n        \"mappings\": {\r\n          \"win\": \"FAudio.dll\",\r\n          \"linux\": \"libFAudio.so.0\",\r\n          \"osx\": \"libFAudio.0.dylib\"\r\n        }\r\n      },\r\n      {\r\n        \"name\": \"FNA3D\",\r\n        \"mappings\": {\r\n          \"win\": \"FNA3D.dll\",\r\n          \"linux\": \"libFNA3D.so.0\",\r\n          \"osx\": \"libFNA3D.0.dylib\"\r\n        }\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n(Note that the Windows mappings are provided for completeness, although they\u0027re not actually necessary in this case -- the default probing logic would simply append the .dll suffix to the library names.)\r\n\r\nHow does this proposed solution fare when measured against FNA\u0027s requirements?\r\n\r\n1. **Any changes to the library source must be compatible with .NET Framework:** No code changes required. We just need to export a runtimeconfig.json file and we\u0027re all set.\r\n2. **The library cannot contain any platform/runtime-specific preprocessor directives:** Since there\u0027s no new code involved, there\u0027s no need!\r\n3. **The runtime must support library name remapping with ABI-versioned lib names:** As in the example above, we can simply specify the exact filenames we need for each library on each platform in the configuration settings.\r\n4. **The library cannot use any NuGet packages or special build tooling:** All the logic is handled in the runtime itself, so no additional tooling is required.\r\n5. **Existing FNA desktop applications must run on all supported runtimes with NO application-side code changes:** The application does not need to be modified at all, since all the relevant logic is in the runtime.\r\n\r\n## Alternative Designs\r\n\r\n**Use the old Mono dllmap format with a separate XML configuration file.**\r\n\r\nThis has the advantage of being 100% compatible with non-dotnet Mono, but otherwise there\u0027s no clear reason to take this approach. (And it\u0027s been vetoed pretty consistently in the past anyway.)\r\n\r\n## Risks\r\n\r\n**Feature Ambiguity:** The use case overlap between this feature and NativeLibrary may lead to some confusion among developers about which method they should use for their application. However, I believe there is sufficient difference between the various native library resolution methods that their intended use cases can be clearly communicated:\r\n\r\n* Use the built-in lib/.so/.dylib probing feature when your library names are the same across all platforms.\r\n* Use runtimeconfig when (1) your library names vary across platforms, (2) you have no further need for custom library resolution logic, and (3) you\u0027re OK with the possibility of end-users adding or modifying configurations.\r\n* Use NativeLibrary when you want custom library resolution logic.\r\n\r\n**Performance:** Depending on the implementation, there is the possibility of a minor performance hit when loading a native library for the first time (due to the new lookup logic) and/or when starting the application (from loading the runtime config settings into memory).\r\n\r\n\r\n(cc: @kg @flibitijibibo) ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOMdIVAg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczNTQxOTMzNw==",
                                           "createdAt":  "2020-11-29T16:24:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Dotnet-GitSync-Bot",
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2020-11-29T16:24:35Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczNTQyOTQ1Mw==",
                                           "createdAt":  "2020-11-29T17:39:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Existing FNA desktop applications must run on all supported runtimes with NO application-side code changes\r\n\r\nMaking existing applications that target .NET Framework or Mono to run without any changes on .NET Core is an explicit non-goal for us.",
                                           "updatedAt":  "2020-11-29T17:39:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczNTQzMDExOQ==",
                                           "createdAt":  "2020-11-29T17:44:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "flibitijibibo",
                                           "body":  "\u003e \u003e Existing FNA desktop applications must run on all supported runtimes with NO application-side code changes\r\n\u003e \r\n\u003e Making existing applications that target .NET Framework or Mono to run without any changes on .NET Core is an explicit non-goal for us.\r\n\r\nTo be clear: We are specifically talking about no _code_ changes - we are already aware of the mscorlib/System.Private.CoreLib breakage and are willing to recompile for Framework and Core.",
                                           "updatedAt":  "2020-11-29T17:44:14Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczNTQzMDgzMg==",
                                           "createdAt":  "2020-11-29T17:49:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBYRp4A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkoritzinsky",
                                                                               "createdAt":  "2020-11-29T17:58:14Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "If you are willing to recompile, can your build tooling add module constructor into the app that installs the remapping? Neither the application C# source code nor the library C# source code need to change.",
                                           "updatedAt":  "2020-11-29T18:53:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczNTQzMjc5NA==",
                                           "createdAt":  "2020-11-29T18:05:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "flibitijibibo",
                                           "body":  "Our build tooling is a single csproj:\r\n\r\nhttps://github.com/FNA-XNA/FNA/blob/master/FNA.Core.csproj\r\n\r\nWe would happily accept a patch from the Foundation to this one file to demonstrate such a build process for others to reference, should that be the standard practice going forward.",
                                           "updatedAt":  "2020-11-29T18:05:36Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgzNTg1MDc0Ng==",
                                           "createdAt":  "2021-05-09T17:40:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "leo60228",
                                           "body":  "\u003e are willing to recompile for Framework and Core\r\n\r\nDoesn\u0027t this mean that conditional compilation for CoreCLR-only code would be fine?",
                                           "updatedAt":  "2021-05-09T17:40:25Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgzNTg1MTUyMg==",
                                           "createdAt":  "2021-05-09T17:45:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "leo60228",
                                           "body":  "It seems to me like the solution intended from .NET here would be to add a source file with a module initializer, keep the .NET Framework project the same, and update the .NET Core project to reference that source file and build for C# 9. That seems like it solves FNA\u0027s issues, though it doesn\u0027t meet the letter of requirements 1 or 2.",
                                           "updatedAt":  "2021-05-09T17:45:16Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "Extend runtimeconfig.json to provide native library remapping functionality",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/45737",
        "createdAt":  "2020-12-08T02:58:17Z",
        "number":  45737,
        "author":  "steveisok",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-11-11T22:06:12Z",
        "body":  "The overall list of pinvokes needed to integrate with the Android api\u0027s:\r\n\r\n## Hashing\r\n\r\n#### Interop.EVP.cs\r\n- [x] `extern SafeEvpMdCtxHandle EvpMdCtxCreate(IntPtr type)`\r\n- [x] `extern void EvpMdCtxDestroy(IntPtr ctx)`\r\n- [x] `extern int EvpDigestReset(SafeEvpMdCtxHandle ctx, IntPtr type)`\r\n- [x] `extern int EvpDigestUpdate(SafeEvpMdCtxHandle ctx, ref byte d, int cnt)`\r\n- [x] `extern int EvpDigestFinalEx(SafeEvpMdCtxHandle ctx, ref byte md, ref uint s)`\r\n- [x] `extern int EvpDigestCurrent(SafeEvpMdCtxHandle ctx, ref byte md, ref uint s)`\r\n- [x] `extern int EvpDigestOneShot(IntPtr type, byte* source, int sourceSize, byte* md, ref uint mdSize)`\r\n- [x] `extern int EvpMdSize(IntPtr md)`\r\n- [x] `extern IntPtr EvpMd5()`\r\n- [x] `extern IntPtr EvpSha1()`\r\n- [x] `extern IntPtr EvpSha256()`\r\n- [x] `extern IntPtr EvpSha384()`\r\n- [x] `extern IntPtr EvpSha512()`\r\n- [x] `extern int GetMaxMdSize()`\r\n\r\n#### Interop.Hmac.cs\r\n- [x] `extern SafeHmacCtxHandle HmacCreate(ref byte key, int keyLen, IntPtr md)`\r\n- [x] `extern void HmacDestroy(IntPtr ctx)`\r\n- [x] `extern int HmacReset(SafeHmacCtxHandle ctx)`\r\n- [x] `extern int HmacUpdate(SafeHmacCtxHandle ctx, ref byte data, int len)`\r\n- [x] `extern int HmacFinal(SafeHmacCtxHandle ctx, ref byte data, ref int len)`\r\n- [x] `extern int HmacCurrent(SafeHmacCtxHandle ctx, ref byte data, ref int len)`\r\n\r\n## Misc\r\n\r\n#### Interop.Bignum.cs\r\n- [x] `extern void BigNumDestroy(IntPtr a)`\r\n- [x] `extern IntPtr BigNumFromBinary(byte* s, int len)`\r\n- [x] `extern int BigNumToBinary(SafeBignumHandle a, byte* to)`\r\n- [x] `extern int GetBigNumBytes(SafeBignumHandle a)`\r\n\r\n#### Interop.Initialization.cs\r\n- [x] `extern int EnsureOpenSslInitialized()`\r\n\r\n#### Interop.LookupFriendlyNameByOid.cs\r\n- [ ] `extern int LookupFriendlyNameByOid(string oidValue, ref IntPtr friendlyNamePtr)`\r\n\r\n#### Interop.OpenSslGetProtocolSupport.cs\r\n- [x] `extern int OpenSslGetProtocolSupport(int protocol)`\r\n\r\n#### Interop.OpenSslVersion.cs\r\n- [ ] `extern long OpenSslVersionNumber()`\r\n\r\n#### Interop.RAND.cs\r\n- [x] `extern bool CryptoNative_GetRandomBytes(byte* buf, int num)`\r\n\r\n## Symmetric/Asymmetric\r\n\r\n#### Interop.ASN1.GetIntegerBytes.cs\r\n- [ ] `extern int GetAsn1IntegerDerSize(SafeSharedAsn1IntegerHandle i)`\r\n- [ ] `extern int EncodeAsn1Integer(SafeSharedAsn1IntegerHandle i, byte[] buf)`\r\n\r\n#### Interop.ASN1.Nid.cs\r\n- [ ] `extern int ObjSn2Nid(string sn)`\r\n- [ ] `extern int ObjTxt2Nid(string oid)`\r\n\r\n#### Interop.ASN1.cs\r\n- [ ] `extern SafeAsn1ObjectHandle ObjTxt2Obj(string s)`\r\n- [ ] `extern int ObjObj2Txt(byte* buf, int buf_len, IntPtr a)`\r\n- [ ] `extern IntPtr CryptoNative_GetObjectDefinitionByName(string friendlyName)`\r\n- [ ] `extern IntPtr ObjNid2Obj(int nid)`\r\n- [ ] `extern void Asn1ObjectFree(IntPtr o)`\r\n- [ ] `extern SafeAsn1BitStringHandle DecodeAsn1BitString(byte[] buf, int len)`\r\n- [ ] `extern void Asn1BitStringFree(IntPtr o)`\r\n- [ ] `extern SafeAsn1OctetStringHandle Asn1OctetStringNew()`\r\n- [ ] `extern bool Asn1OctetStringSet(SafeAsn1OctetStringHandle o, byte[] d, int len)`\r\n- [ ] `extern void Asn1OctetStringFree(IntPtr o)`\r\n- [ ] `extern void Asn1StringFree(IntPtr o)`\r\n\r\n#### Interop.BIO.cs\r\n- [ ] `extern SafeBioHandle CreateMemoryBio()`\r\n- [ ] `extern SafeBioHandle BioNewFile(string filename, string mode)`\r\n- [ ] `extern bool BioDestroy(IntPtr a)`\r\n- [ ] `extern int BioGets(SafeBioHandle b, byte[] buf, int size)`\r\n- [ ] `extern int BioRead(SafeBioHandle b, byte[] data, int len)`\r\n- [ ] `extern int BioWrite(SafeBioHandle b, byte[] data, int len)`\r\n- [ ] `extern int BioWrite(SafeBioHandle b, ref byte data, int len)`\r\n- [ ] `extern int GetMemoryBioSize(SafeBioHandle bio)`\r\n- [ ] `extern int BioCtrlPending(SafeBioHandle bio)`\r\n\r\n#### Interop.Dsa.cs\r\n- [ ] `extern bool DsaUpRef(IntPtr dsa)`\r\n- [ ] `extern void DsaDestroy(IntPtr dsa)`\r\n- [ ] `extern bool DsaGenerateKey(out SafeDsaHandle dsa, int bits)`\r\n- [ ] `extern int DsaSizeSignature(SafeDsaHandle dsa)`\r\n- [ ] `extern int DsaSizeQ(SafeDsaHandle dsa)`\r\n- [ ] `extern int DsaSizeP(SafeDsaHandle dsa)`\r\n- [ ] `extern bool DsaSign(SafeDsaHandle dsa, ref byte hash, int hashLength, ref byte refSignature, out int outSignatureLength)`\r\n- [ ] `extern bool DsaVerify(SafeDsaHandle dsa, ref byte hash, int hashLength, ref byte signature, int signatureLength)`\r\n- [ ] `extern bool GetDsaParameters(...)`\r\n- [ ] `extern bool DsaKeyCreateByExplicitParameters(...)`\r\n\r\n#### Interop.EvpPkey.Dsa.cs\r\n- [ ] `extern SafeDsaHandle EvpPkeyGetDsa(SafeEvpPKeyHandle pkey)`\r\n- [ ] `extern bool EvpPkeySetDsa(SafeEvpPKeyHandle pkey, SafeDsaHandle key)`\r\n\r\n#### Interop.ERR.cs\r\n- [x] `extern ulong ErrClearError()`\r\n- [x] `extern ulong ErrGetErrorAlloc([MarshalAs(UnmanagedType.Bool)] out bool isAllocFailure)`\r\n- [x] `extern ulong ErrPeekError()`\r\n- [x] `extern ulong ErrPeekLastError()`\r\n- [x] `extern IntPtr ErrReasonErrorString(ulong error)`\r\n- [x] `extern void ErrErrorStringN(ulong e, byte* buf, int len)`\r\n\r\n#### Interop.EVP.Cipher.cs\r\n- [x] `extern SafeEvpCipherCtxHandle EvpCipherCreate(...)`\r\n- [x] `extern SafeEvpCipherCtxHandle EvpCipherCreatePartial(...)`\r\n- [x] `extern bool EvpCipherSetKeyAndIV(...)`\r\n- [x] `extern bool CryptoNative_EvpCipherSetGcmNonceLength(...)`\r\n- [x] `extern bool CryptoNative_EvpCipherSetCcmNonceLength(...)`\r\n- [x] `extern void EvpCipherDestroy(IntPtr ctx)`\r\n- [x] `extern bool EvpCipherReset(SafeEvpCipherCtxHandle ctx)`\r\n- [x] `extern bool EvpCipherCtxSetPadding(SafeEvpCipherCtxHandle x, int padding)`\r\n- [x] `extern bool EvpCipherUpdate(...)`\r\n- [x] `extern bool EvpCipherFinalEx(...)`\r\n- [x] `extern bool EvpCipherGetGcmTag(...)`\r\n- [x] `extern bool EvpCipherSetGcmTag(...)`\r\n- [x] `extern bool EvpCipherGetCcmTag(...)`\r\n- [x] `extern bool EvpCipherSetCcmTag(...)`\r\n- [x] `extern IntPtr EvpAes128Ecb()`\r\n- [x] `extern IntPtr EvpAes128Cbc()`\r\n- [x] `extern IntPtr EvpAes128Gcm()`\r\n- [x] `extern IntPtr EvpAes128Cfb8()`\r\n- [ ] `extern IntPtr EvpAes128Cfb128()`\r\n- [x] `extern IntPtr EvpAes128Ccm()`\r\n- [x] `extern IntPtr EvpAes192Ecb()`\r\n- [x] `extern IntPtr EvpAes192Cbc()`\r\n- [x] `extern IntPtr EvpAes192Gcm()`\r\n- [x] `extern IntPtr EvpAes192Cfb8()`\r\n- [ ] `extern IntPtr EvpAes192Cfb128()`\r\n- [x] `extern IntPtr EvpAes192Ccm()`\r\n- [x] `extern IntPtr EvpAes256Ecb()`\r\n- [x] `extern IntPtr EvpAes256Cbc()`\r\n- [x] `extern IntPtr EvpAes256Gcm()`\r\n- [ ] `extern IntPtr EvpAes256Cfb128()`\r\n- [x] `extern IntPtr EvpAes256Cfb8()`\r\n- [x] `extern IntPtr EvpAes256Ccm()`\r\n- [x] `extern IntPtr EvpDesCbc()`\r\n- [x] `extern IntPtr EvpDesEcb()`\r\n- [x] `extern IntPtr EvpDesCfb8()`\r\n- [x] `extern IntPtr EvpDes3Cbc()`\r\n- [x] `extern IntPtr EvpDes3Ecb()`\r\n- [x] `extern IntPtr EvpDes3Cfb8()`\r\n- [x] `extern IntPtr EvpDes3Cfb64()`\r\n- [ ] `extern IntPtr EvpRC2Cbc()`\r\n- [ ] `extern IntPtr EvpRC2Ecb()`\r\n\r\n#### Interop.EcDsa.ImportExport.cs\r\n- [ ] `extern int EcKeyCreateByKeyParameters(...)`\r\n- [ ] `extern SafeEcKeyHandle EcKeyCreateByExplicitParameters(...)`\r\n- [ ] `extern int CryptoNative_GetECKeyParameters(...)`\r\n- [ ] `extern int CryptoNative_GetECCurveParameters(...)`\r\n\r\n#### Interop.EcDsa.cs\r\n- [ ] `extern bool EcDsaSign(ref byte dgst, int dlen, ref byte sig, out int siglen, SafeEcKeyHandle ecKey)`\r\n- [ ] `extern int EcDsaVerify(ref byte dgst, int dgst_len, ref byte sigbuf, int sig_len, SafeEcKeyHandle ecKey)`\r\n- [ ] `extern int CryptoNative_EcDsaSize(SafeEcKeyHandle ecKey)`\r\n\r\n#### Interop.EcKey.cs\r\n- [ ] `extern SafeEcKeyHandle CryptoNative_EcKeyCreateByOid(string oid)`\r\n- [ ] `extern void EcKeyDestroy(IntPtr a)`\r\n- [ ] `extern bool EcKeyGenerateKey(SafeEcKeyHandle eckey)`\r\n- [ ] `extern bool EcKeyUpRef(IntPtr r)`\r\n- [ ] `extern int CryptoNative_EcKeyGetSize(SafeEcKeyHandle ecKey, out int keySize)`\r\n- [ ] `extern int CryptoNative_EcKeyGetCurveName(SafeEcKeyHandle ecKey, out int nid)`\r\n\r\n#### Interop.EvpPkey.EcKey.cs\r\n- [ ] `extern SafeEcKeyHandle EvpPkeyGetEcKey(SafeEvpPKeyHandle pkey)`\r\n- [ ] `extern bool EvpPkeySetEcKey(SafeEvpPKeyHandle pkey, SafeEcKeyHandle key)`\r\n\r\n#### Interop.EvpPkey.Ecdh.cs\r\n- [ ] `extern SafeEvpPKeyCtxHandle EvpPKeyCtxCreate(SafeEvpPKeyHandle pkey, SafeEvpPKeyHandle peerkey, out uint secretLength)`\r\n- [ ] `extern int EvpPKeyDeriveSecretAgreement(...)`\r\n- [ ] `extern void EvpPKeyCtxDestroy(IntPtr ctx)`\r\n\r\n#### Interop.EvpPkey.Rsa.cs\r\n- [ ] `extern SafeRsaHandle EvpPkeyGetRsa(SafeEvpPKeyHandle pkey)`\r\n- [ ] `extern bool EvpPkeySetRsa(SafeEvpPKeyHandle pkey, SafeRsaHandle rsa)`\r\n\r\n#### Interop.EvpPkey.cs\r\n- [ ] `extern SafeEvpPKeyHandle EvpPkeyCreate()`\r\n- [ ] `extern void EvpPkeyDestroy(IntPtr pkey)`\r\n- [ ] `extern int UpRefEvpPkey(SafeEvpPKeyHandle handle)`\r\n\r\n#### Interop.Rsa.cs\r\n- [x] `extern SafeRsaHandle RsaCreate()`\r\n- [x] `extern bool RsaUpRef(IntPtr rsa)`\r\n- [x] `extern void RsaDestroy(IntPtr rsa)`\r\n- [x] `extern SafeRsaHandle DecodeRsaPublicKey(ref byte buf, int len)`\r\n- [x] `extern int RsaPublicEncrypt(...)`\r\n- [x] `extern int RsaPrivateDecrypt(...)`\r\n- [x] `extern int RsaSignPrimitive(...)`\r\n- [x] `extern int RsaVerificationPrimitive(...)`\r\n- [x] `extern int RsaSize(SafeRsaHandle rsa)`\r\n- [x] `extern int RsaGenerateKeyEx(SafeRsaHandle rsa, int bits, SafeBignumHandle e)`\r\n- [x] `extern bool RsaSign(int type, ref byte m, int m_len, ref byte sigret, out int siglen, SafeRsaHandle rsa)`\r\n- [x] `extern bool RsaVerify(int type, ref byte m, int m_len, ref byte sigbuf, int siglen, SafeRsaHandle rsa)`\r\n- [x] `extern bool GetRsaParameters(...)`\r\n- [x] `extern bool SetRsaParameters(...)`\r\n\r\n## SSL\r\n\r\n#### Interop.SetProtocolOptions.cs\r\n- [ ] `extern void SetProtocolOptions(IntPtr ctx, SslProtocols protocols)`\r\n\r\n#### Interop.Ssl.cs\r\n- [ ] `extern void EnsureLibSslInitialized()`\r\n- [ ] `extern IntPtr SslV2_3Method()`\r\n- [ ] `extern SafeSslHandle SslCreate(SafeSslContextHandle ctx)`\r\n- [ ] `extern SslErrorCode SslGetError(SafeSslHandle ssl, int ret)`\r\n- [ ] `extern SslErrorCode SslGetError(IntPtr ssl, int ret)`\r\n- [ ] `extern void SslSetQuietShutdown(SafeSslHandle ssl, int mode)`\r\n- [ ] `extern void SslDestroy(IntPtr ssl)`\r\n- [ ] `extern void SslSetConnectState(SafeSslHandle ssl)`\r\n- [ ] `extern void SslSetAcceptState(SafeSslHandle ssl)`\r\n- [ ] `extern IntPtr SslGetVersion(SafeSslHandle ssl)`\r\n- [ ] `extern bool SslSetTlsExtHostName(SafeSslHandle ssl, string host)`\r\n- [ ] `extern void SslGetAlpnSelected(SafeSslHandle ssl, out IntPtr protocol, out int len)`\r\n- [ ] `extern int SslWrite(SafeSslHandle ssl, ref byte buf, int num)`\r\n- [ ] `extern int SslRead(SafeSslHandle ssl, byte* buf, int num)`\r\n- [ ] `extern bool IsSslRenegotiatePending(SafeSslHandle ssl)`\r\n- [ ] `extern int SslShutdown(IntPtr ssl)`\r\n- [ ] `extern int SslShutdown(SafeSslHandle ssl)`\r\n- [ ] `extern void SslSetBio(SafeSslHandle ssl, SafeBioHandle rbio, SafeBioHandle wbio)`\r\n- [ ] `extern int SslDoHandshake(SafeSslHandle ssl)`\r\n- [ ] `extern bool IsSslStateOK(SafeSslHandle ssl)`\r\n- [ ] `extern int BioWrite(SafeBioHandle b, byte* data, int len)`\r\n- [ ] `extern int BioWrite(SafeBioHandle b, ref byte data, int len)`\r\n- [ ] `extern SafeX509Handle SslGetPeerCertificate(SafeSslHandle ssl)`\r\n- [ ] `extern SafeSharedX509StackHandle SslGetPeerCertChain(SafeSslHandle ssl)`\r\n- [ ] `extern int SslGetPeerFinished(SafeSslHandle ssl, IntPtr buf, int count)`\r\n- [ ] `extern int SslGetFinished(SafeSslHandle ssl, IntPtr buf, int count)`\r\n- [ ] `extern bool SslSessionReused(SafeSslHandle ssl)`\r\n- [ ] `extern bool SslAddExtraChainCert(SafeSslHandle ssl, SafeX509Handle x509)`\r\n- [ ] `extern SafeSharedX509NameStackHandle SslGetClientCAList_private(SafeSslHandle ssl)`\r\n- [ ] `extern bool SslGetCurrentCipherId(SafeSslHandle ssl, out int cipherId)`\r\n- [ ] `extern IntPtr GetOpenSslCipherSuiteName(SafeSslHandle ssl, int cipherSuite, out int isTls12OrLower)`\r\n- [ ] `extern bool Tls13SupportedImpl()`\r\n\r\n#### Interop.SslCtx.cs\r\n- [ ] `extern SafeSslContextHandle SslCtxCreate(IntPtr method)`\r\n- [ ] `extern void SslCtxDestroy(IntPtr ctx)`\r\n- [ ] `extern void SslCtxSetCertVerifyCallback(IntPtr ctx, AppVerifyCallback cb, IntPtr arg)`\r\n- [ ] `extern void SslCtxSetClientCertCallback(IntPtr ctx, ClientCertCallback callback)`\r\n- [ ] `extern int SslCtxSetAlpnProtos(SafeSslContextHandle ctx, IntPtr protos, int len)`\r\n- [ ] `extern void SslCtxSetAlpnSelectCb(SafeSslContextHandle ctx, SslCtxSetAlpnCallback callback, IntPtr arg)`\r\n\r\n#### Interop.SslCtxOptions.cs\r\n- [ ] `extern int SslCtxUseCertificate(SafeSslContextHandle ctx, SafeX509Handle certPtr)`\r\n- [ ] `extern int SslCtxUsePrivateKey(SafeSslContextHandle ctx, SafeEvpPKeyHandle keyPtr)`\r\n- [ ] `extern int SslCtxCheckPrivateKey(SafeSslContextHandle ctx)`\r\n- [ ] `extern void SslCtxSetQuietShutdown(SafeSslContextHandle ctx)`\r\n- [ ] `extern void SslCtxSetVerify(SafeSslContextHandle ctx, SslCtxSetVerifyCallback callback)`\r\n- [ ] `extern bool SetCiphers(SafeSslContextHandle ctx, byte* cipherList, byte* cipherSuites)`\r\n- [ ] `extern bool SetEncryptionPolicy(SafeSslContextHandle ctx, EncryptionPolicy policy)`\r\n\r\n## X509\r\n\r\n#### Interop.OCSP.cs\r\n- [ ] `extern void OcspRequestDestroy(IntPtr ocspReq)`\r\n- [ ] `extern int GetOcspRequestDerSize(SafeOcspRequestHandle req)`\r\n- [ ] `extern int EncodeOcspRequest(SafeOcspRequestHandle req, byte[] buf)`\r\n- [ ] `extern SafeOcspResponseHandle CryptoNative_DecodeOcspResponse(ref byte buf, int len)`\r\n- [ ] `extern void OcspResponseDestroy(IntPtr ocspReq)`\r\n- [ ] `extern X509VerifyStatusCode CryptoNative_X509ChainGetCachedOcspStatus(...)`\r\n- [ ] `extern X509VerifyStatusCode CryptoNative_X509ChainVerifyOcsp(...)`\r\n- [ ] `extern SafeOcspRequestHandle CryptoNative_X509ChainBuildOcspRequest(...)`\r\n\r\n#### Interop.Pkcs7.cs\r\n- [ ] `extern SafePkcs7Handle PemReadBioPkcs7(SafeBioHandle bp)`\r\n- [ ] `extern SafePkcs7Handle DecodePkcs7(ref byte buf, int len)`\r\n- [ ] `extern SafePkcs7Handle D2IPkcs7Bio(SafeBioHandle bp)`\r\n- [ ] `extern SafePkcs7Handle Pkcs7CreateCertificateCollection(SafeX509StackHandle certs)`\r\n- [ ] `extern void Pkcs7Destroy(IntPtr p7)`\r\n- [ ] `extern int GetPkcs7Certificates(SafePkcs7Handle p7, out SafeSharedX509StackHandle certs)`\r\n- [ ] `extern int GetPkcs7DerSize(SafePkcs7Handle p7)`\r\n- [ ] `extern int EncodePkcs7(SafePkcs7Handle p7, byte[] buf)`\r\n\r\n#### Interop.Crypto.cs\r\n- [ ] `extern int CryptoNative_BioTell(SafeBioHandle bio)`\r\n- [ ] `extern int BioSeek(SafeBioHandle bio, int pos)`\r\n- [ ] `extern int GetX509Thumbprint(SafeX509Handle x509, byte[]? buf, int cBuf)`\r\n- [ ] `extern int GetX509NameRawBytes(IntPtr x509Name, byte[]? buf, int cBuf)`\r\n- [ ] `extern SafeX509Handle ReadX509AsDerFromBio(SafeBioHandle bio)`\r\n- [ ] `extern IntPtr GetX509NotBefore(SafeX509Handle x509)`\r\n- [ ] `extern IntPtr GetX509NotAfter(SafeX509Handle x509)`\r\n- [ ] `extern IntPtr GetX509CrlNextUpdate(SafeX509CrlHandle crl)`\r\n- [ ] `extern int GetX509Version(SafeX509Handle x509)`\r\n- [ ] `extern IntPtr GetX509SignatureAlgorithm(SafeX509Handle x509)`\r\n- [ ] `extern IntPtr GetX509PublicKeyAlgorithm(SafeX509Handle x509)`\r\n- [ ] `extern int GetX509PublicKeyParameterBytes(SafeX509Handle x509, byte[]? buf, int cBuf)`\r\n- [ ] `extern IntPtr GetX509PublicKeyBytes(SafeX509Handle x509)`\r\n- [ ] `extern int GetX509EkuFieldCount(SafeEkuExtensionHandle eku)`\r\n- [ ] `extern IntPtr GetX509EkuField(SafeEkuExtensionHandle eku, int loc)`\r\n- [ ] `extern SafeBioHandle GetX509NameInfo(SafeX509Handle x509, int nameType, [MarshalAs(UnmanagedType.Bool)] bool forIssuer)`\r\n- [ ] `extern int GetAsn1StringBytes(IntPtr asn1, byte[]? buf, int cBuf)`\r\n- [ ] `extern bool PushX509StackField(SafeX509StackHandle stack, SafeX509Handle x509)`\r\n- [ ] `extern bool PushX509StackField(SafeSharedX509StackHandle stack, SafeX509Handle x509)`\r\n- [ ] `extern IntPtr GetX509RootStorePath_private()`\r\n- [ ] `extern IntPtr GetX509RootStoreFile_private()`\r\n- [ ] `extern int CryptoNative_X509StoreSetVerifyTime(...)`\r\n- [ ] `extern int CheckX509IpAddress(SafeX509Handle x509, [In]byte[] addressBytes, int addressLen, string hostname, int cchHostname)`\r\n- [ ] `extern int CheckX509Hostname(SafeX509Handle x509, string hostname, int cchHostname)`\r\n\r\n#### Interop.X509.cs\r\n- [ ] `extern SafeEvpPKeyHandle GetX509EvpPublicKey(SafeX509Handle x509)`\r\n- [ ] `extern SafeX509CrlHandle DecodeX509Crl(byte[] buf, int len)`\r\n- [ ] `extern SafeX509Handle DecodeX509(ref byte buf, int len)`\r\n- [ ] `extern int GetX509DerSize(SafeX509Handle x)`\r\n- [ ] `extern int EncodeX509(SafeX509Handle x, byte[] buf)`\r\n- [ ] `extern void X509Destroy(IntPtr a)`\r\n- [ ] `extern SafeX509Handle X509Duplicate(IntPtr handle)`\r\n- [ ] `extern SafeX509Handle X509Duplicate(SafeX509Handle handle)`\r\n- [ ] `extern SafeX509Handle X509UpRef(IntPtr handle)`\r\n- [ ] `extern SafeX509Handle X509UpRef(SafeX509Handle handle)`\r\n- [ ] `extern SafeX509Handle PemReadX509FromBio(SafeBioHandle bio)`\r\n- [ ] `extern SafeX509Handle PemReadX509FromBioAux(SafeBioHandle bio)`\r\n- [ ] `extern SafeSharedAsn1IntegerHandle X509GetSerialNumber_private(SafeX509Handle x)`\r\n- [ ] `extern IntPtr X509GetIssuerName(SafeX509Handle x)`\r\n- [ ] `extern IntPtr X509GetSubjectName(SafeX509Handle x)`\r\n- [ ] `extern bool X509CheckPurpose(SafeX509Handle x, int id, int ca)`\r\n- [ ] `extern ulong X509IssuerNameHash(SafeX509Handle x)`\r\n- [ ] `extern SafeSharedAsn1OctetStringHandle CryptoNative_X509FindExtensionData(...)`\r\n- [ ] `extern int X509GetExtCount(SafeX509Handle x)`\r\n- [ ] `extern IntPtr X509GetExt(SafeX509Handle x, int loc)`\r\n- [ ] `extern IntPtr X509ExtensionGetOid(IntPtr ex)`\r\n- [ ] `extern IntPtr X509ExtensionGetData(IntPtr ex)`\r\n- [ ] `extern bool X509ExtensionGetCritical(IntPtr ex)`\r\n- [ ] `extern SafeX509StoreHandle CryptoNative_X509ChainNew(SafeX509StackHandle systemTrust, SafeX509StackHandle userTrust)`\r\n- [ ] `extern void X509StoreDestory(IntPtr v)`\r\n- [ ] `extern bool X509StoreAddCrl(SafeX509StoreHandle ctx, SafeX509CrlHandle x)`\r\n- [ ] `extern bool CryptoNative_X509StoreSetRevocationFlag(SafeX509StoreHandle ctx, X509RevocationFlag revocationFlag)`\r\n- [ ] `extern bool X509StoreCtxInit(...)`\r\n- [ ] `extern int CryptoNative_X509VerifyCert(SafeX509StoreCtxHandle ctx)`\r\n- [ ] `extern X509VerifyStatusCode X509StoreCtxGetError(SafeX509StoreCtxHandle ctx)`\r\n- [ ] `extern int CryptoNative_X509StoreCtxReset(SafeX509StoreCtxHandle ctx)`\r\n- [ ] `extern int CryptoNative_X509StoreCtxRebuildChain(SafeX509StoreCtxHandle ctx)`\r\n- [ ] `extern int X509StoreCtxGetErrorDepth(SafeX509StoreCtxHandle ctx)`\r\n- [ ] `extern void X509StoreCtxSetVerifyCallback(SafeX509StoreCtxHandle ctx, X509StoreVerifyCallback callback)`\r\n- [ ] `extern IntPtr X509VerifyCertErrorString(X509VerifyStatusCode n)`\r\n- [ ] `extern void X509CrlDestroy(IntPtr a)`\r\n- [ ] `extern int PemWriteBioX509Crl(SafeBioHandle bio, SafeX509CrlHandle crl)`\r\n- [ ] `extern SafeX509CrlHandle PemReadBioX509Crl(SafeBioHandle bio)`\r\n- [ ] `extern int GetX509SubjectPublicKeyInfoDerSize(SafeX509Handle x509)`\r\n- [ ] `extern int EncodeX509SubjectPublicKeyInfo(SafeX509Handle x509, byte[] buf)`\r\n\r\n#### Interop.X509Ext.cs\r\n- [ ] `extern SafeX509ExtensionHandle X509ExtensionCreateByObj(...)`\r\n- [ ] `extern int X509ExtensionDestroy(IntPtr x)`\r\n- [ ] `extern bool X509V3ExtPrint(SafeBioHandle buf, SafeX509ExtensionHandle ext)`\r\n- [ ] `extern bool DecodeX509BasicConstraints2Extension(...)`\r\n- [ ] `extern SafeEkuExtensionHandle DecodeExtendedKeyUsage(byte[] buf, int len)`\r\n- [ ] `extern void ExtendedKeyUsageDestory(IntPtr a)`\r\n\r\n#### Interop.X509Name.cs\r\n- [ ] `extern int GetX509NameStackFieldCount(SafeSharedX509NameStackHandle sk)`\r\n- [ ] `extern SafeSharedX509NameHandle GetX509NameStackField_private(SafeSharedX509NameStackHandle sk,...)`\r\n- [ ] `extern int GetX509NameRawBytes(SafeSharedX509NameHandle x509Name, byte[]? buf, int cBuf)`\r\n\r\n#### Interop.X509Stack.cs\r\n- [ ] `extern SafeX509StackHandle NewX509Stack()`\r\n- [ ] `extern void RecursiveFreeX509Stack(IntPtr stack)`\r\n- [ ] `extern int GetX509StackFieldCount(SafeX509StackHandle stack)`\r\n- [ ] `extern int GetX509StackFieldCount(SafeSharedX509StackHandle stack)`\r\n- [ ] `extern IntPtr GetX509StackField(SafeX509StackHandle stack, int loc)`\r\n- [ ] `extern IntPtr GetX509StackField(SafeSharedX509StackHandle stack, int loc)`\r\n- [ ] `extern int CryptoNative_X509StackAddDirectoryStore(SafeX509StackHandle stack, string storePath)`\r\n- [ ] `extern int CryptoNative_X509StackAddMultiple(SafeX509StackHandle dest, SafeX509StackHandle src)`\r\n\r\n#### Interop.X509StoreCtx.cs\r\n- [ ] `extern SafeX509StoreCtxHandle X509StoreCtxCreate()`\r\n- [ ] `extern void X509StoreCtxDestroy(IntPtr v)`\r\n- [ ] `extern SafeX509StackHandle X509StoreCtxGetChain(SafeX509StoreCtxHandle ctx)`\r\n- [ ] `extern SafeX509Handle X509StoreCtxGetCurrentCert(SafeX509StoreCtxHandle ctx)`\r\n- [ ] `extern int CryptoNative_X509StoreCtxCommitToChain(SafeX509StoreCtxHandle ctx)`\r\n- [ ] `extern int CryptoNative_X509StoreCtxResetForSignatureError(...)`\r\n- [ ] `extern SafeSharedX509StackHandle X509StoreCtxGetSharedUntrusted_private(SafeX509StoreCtxHandle ctx)`\r\n- [ ] `extern IntPtr X509StoreCtxGetTargetCert(SafeX509StoreCtxHandle ctx)`",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHONXZlrg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc41dmWu",
                                           "createdAt":  "2021-08-11T16:02:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveisok",
                                           "body":  "We\u0027ve satisfied what we\u0027re going to support for net6.  ",
                                           "updatedAt":  "2021-08-11T16:02:33Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "System.Security.Cryptography.Native.Android PAL Tracking List",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "os-android",
                       "tracking"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/45741",
        "createdAt":  "2020-12-08T03:14:01Z",
        "number":  45741,
        "author":  "steveisok",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCzljiQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "janseris",
                                            "createdAt":  "2022-11-25T12:37:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dotMorten",
                                            "createdAt":  "2023-09-06T19:10:33Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ronnieoverby",
                                            "createdAt":  "2023-10-26T17:44:37Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2024-03-17T01:36:45Z",
        "body":  "Since we\u0027re not able to ship Openssl w/ Android, we need to implement as much as we can with the Android API\u0027s. \r\n\r\n## Implementation\r\n- [x] Ensure all tests pass https://github.com/dotnet/runtime/issues/45740\r\n- [x] CI build + test\r\n  - [ ] Test runs have been running out of memory in runtime-staging builds - haven\u0027t been able to repro locally. Emulator used in CI for x64:\r\n      - Build ID: QPP6.190730.005.B1\r\n      - Image: system-images;android-29;default;x86_64\r\n      - Command line arguments: `-avd \u003cemulatorName\u003e -memory 3072 -wipe-data -delay-adb -skip-adb-auth -no-boot-anim -no-window -no-audio -gpu swiftshader_indirect -logcat-output \u0027/tmp/\u003cemulatorName\u003e-logcat.log\u0027`\r\n\r\n### System.Security.Cryptogaphy\r\n- [x] Fix reading of PEM certificate bytes where the certificate label is not the first bytes.\r\n  - Seems like Android expects the label to be the first thing (doesn\u0027t handle explanatory text or whitespace before the label)\r\n\r\n### System.Net.Security\r\n- [x] Basic SSL stream implementation - #50519\r\n- [ ] SSL configuration options\r\n  - [x] SSL protocols - #50987\r\n  - [x] Application protocols - #51187\r\n    - `HttpClient` sets `ApplicationProtocols` only if intending to use HTTP/2+\r\n  - [ ] Cipher suites\r\n    - `CipherSuitesPolicy` throws PNSE on Windows, so this is nice to have, but not critical\r\n  - [x] Encryption policy - #50987\r\n  - [x] Request client cert (server mode with `RemoteCertRequired`) - #51187\r\n- [x] Implement `SslStreamPal.QueryContextChannelBinding` - #51316\r\n- [ ] Implement `CertificateValidationPal.GetRequestCertificateAuthorities`\r\n  - https://developer.android.com/reference/javax/net/ssl/SSLSession#getLocalCertificates()\r\n- [ ] Automated tests\r\n  - Many existing innerloop e2e scenario tests rely on non-system-default certificate validation, which there isn\u0027t a good way for us to support (see \u0027Not supported\u0027 section below)\r\n  - Test app could be created such that it bundles in a network security configuration file and test root certificates: https://developer.android.com/training/articles/security-config\r\n\r\n## Not supported\r\n\r\nThe following are not supported on Android. They should be documented, marked with `UnsupportedOSPlatform`, and/or throw `PlatformNotSupportedException` as appropriate.\r\n\r\n### System.Security.Cryptogaphy\r\n- [ ] `RC2` algorithm\r\n  - `CreateDecryptor` and `CreateEncryptor` currently throw PNSE, `Create` does not\r\n- [ ] `IncrementalHash.GetCurrentHash` using HMAC\r\n- [ ] Ignoring verification during chain building that can\u0027t be bypassed on Android: `AllowUnknownCertificateAuthority`, `IgnoreInvalidName`, `IgnoreInvalidPolicy`, `IgnoreTimeNotValid`\r\n  - `X509Chain.Build` will return false and have `PartialChain` status with no certificates\r\n- [ ] AIA fetching during chain building\r\n- [ ] Revocation checking options - these intentionally do not throw and are treated as supported options instead\r\n  - `X509RevocationMode`: `Offline` treated as `Online`\r\n  - `X509RevocationFlag`: `EntireChain` treated as `ExcludeRoot`\r\n- [ ] Custom certificate stores (should be possible to do as a future improvement if desired)\r\n- [ ] Revocation checking via OCSP on versions of Android without `PKIXRevocationChecker` (API level \u003c24)\r\n\r\n### System.Net.Security\r\n- [x] Non-system-default certificate validation\r\n  - ~~Any `RemoteCertificateValidationCallback` will only get an opportunity to validate certificates that have already been accepted by the system\u0027s built-in trust manager.~~ - resolved in .NET 8\r\n  - ~~This means that the use cases of the callback for self-signed certificates or custom trust will not work.~~  - resolved in .NET 8\r\n- [ ] Authenticating with `EncryptionPolicy.NoEncryption` (on `SslClientAuthenticationOptions.EncryptionPolicy` or `SslServerAuthenticationOptions.EncryptionPolicy`)\r\n- [ ] Certain protocols (on `HttpClientHandler.SslProtocols`, `SslClientAuthenticationOptions.EnabledSslProtocols`, or `SslServerAuthenticationOptions.EnabledSslProtocols`):\r\n   - `SslProtocols.Ssl2` - not supported\r\n   - `SslProtocols.Ssl3` - not supported\r\n   - `SslProtocols.Tls13` - only on some versions of Android (\u003e= API level 29)\r\n- [ ] Underscores in host name (`SslClientAuthenticationOptions.TargetHost`) \r\n\r\n## Future improvements\r\n\r\nThe following should be considered after the initial implementation. If it is determined they are desired, they can be split into their own issues.\r\n\r\n- [ ] Better error messages\r\n  - All exceptions are just dumped to the Android error log and not propagated to the calling API, so errors just come through as a generic `CryptographicException`.\r\n  - Some concept of storing/getting/clearing last exception at the shim API layer could be introduced in order to get actual error messages\r\n \r\n### System.Security.Cryptogaphy\r\n- [ ] Use Java Pbkdf2 implementations when on available API levels.\r\n- [ ] Use Java PBE implementations when on available API levels.\r\n- [ ] Use Java RSA signature APIs directly when processing data (not hashes). Requires minimum API level 23 (where all padding options are supported in Java) to be worth the cost\r\n- [ ] Custom certificate stores\r\n  - Use some well-known location for loading/storing a `KeyStore`\r\n- [ ] Improve chain error status on versions of Android without `CertPathValidatorException.getReason` (API level \u003c24)\r\n  - Try checking all the wrapped exceptions for specific `CertificateException` types to determine a better status\r\n\r\n### System.Net.Security\r\n- [ ] Investigate using [JNI NIO support](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#NewDirectByteBuffer) for byte buffers in SSL stream implementation - potential perf improvement\r\n- [ ] Investigate handling non-system-default certificate validation\r\n  - Would require implementing a `TrustManager`. Android doesn\u0027t allow defining a class via JNI, so doing this would involve actually creating/shipping a Java class.\r\n  - Possible issues around Android store validation rejecting applications with trust managers deemed insecure\r\n  - If allowed certificates are known ahead of time, it would be possible to load/create `KeyStore` and use `TrustManagerFactory` to create and initialize a trust manager with it. \r\n\r\n## Clean-up\r\n\r\n- [x] Remove OpenSSL as a dependency in the build and all branching based on AndroidCrypto vs. OpenSSL on Android\r\n- [x] Rename native library: https://github.com/dotnet/runtime/blob/f64246ce08fb7a58221b2b7c8e68f69c02522b0d/src/libraries/Native/Unix/System.Security.Cryptography.Native.Android/CMakeLists.txt#L45-L47\r\n- [ ] Cleaner split of Android vs. OpenSSL implementations for ciphers / hashes / HMAC.\r\n  - With the original plan to just implement P/Invokes, the managed side of these were shared. Making a clean split and reworking the shim APIs to align more with Android would simplify things and reduce a bunch of interop calls.\r\n\r\n## Other\r\n\r\n- Implement pinvokes needed to perform a simple https request - https://github.com/dotnet/runtime/issues/45739\r\n- Tracking [status](https://github.com/dotnet/runtime/issues/45737) of pinvokes implemented.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOd1fyCg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2ODMzMTM2Nw==",
                                           "createdAt":  "2021-06-25T08:47:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "JamesNK",
                                           "body":  "\u003e * [ ]  Non-system-default certificate validation\r\n\u003e   \r\n\u003e   * Any `RemoteCertificateValidationCallback` will only get an opportunity to validate certificates that have already been accepted by the system\u0027s built-in trust manager.\r\n\u003e   * This means that the use cases of the callback for self-signed certificates or custom trust will not work.\r\n\r\nThis makes testing against a local ASP.NET Core web app that is using a self-signed development certificate difficult.\r\n\r\nCouldn\u0027t this be supported by creating a custom SSLSocketFactory? If `RemoteCertificateValidationCallback` is configured then there is a factory that trusts all certificates. Cert details are then passed to the callback so it can make a decision about whether the cert is allowed or not.\r\n\r\nSO answer about it - https://stackoverflow.com/a/6378872\r\nBlog post - http://howardism.org/Technical/Java/SelfSignedCerts.html",
                                           "updatedAt":  "2021-06-25T08:54:35Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2ODM3MjA1Mw==",
                                           "createdAt":  "2021-06-25T09:37:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveisok",
                                           "body":  "@JamesNK we made the decision early on to make this a purely JNI integration.  Android doesn\u0027t support creating Java classes out of JNI, which I believe makes a custom trust manager not possible.\n\nThis is something we could look at trying to support in net7.",
                                           "updatedAt":  "2021-06-25T09:37:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2OTEwMTI3Mg==",
                                           "createdAt":  "2021-06-27T05:05:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "JamesNK",
                                           "body":  "There are a number of options suggested in the SO thread that don\u0027t involve creating new Java classes. However, I don\u0027t know Java and Android HTTP APIs so I don\u0027t know what approaches are valid.",
                                           "updatedAt":  "2021-06-27T05:05:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5FCV7s",
                                           "createdAt":  "2022-06-16T23:01:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Eilon",
                                           "body":  "@JamesNK said:\r\n\r\n\u003e This makes testing against a local ASP.NET Core web app that is using a self-signed development certificate difficult.\r\n\r\nI started a discussion topic on how to connect from Android emulators to a local ASP.NET Web API running on Windows: https://github.com/dotnet/maui/discussions/8131\r\n\r\nPlease check that out and let us know if you have any feedback on any of the solutions presented.",
                                           "updatedAt":  "2022-06-16T23:01:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5O6ZfA",
                                           "createdAt":  "2022-11-22T16:24:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCwMisQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "janseris",
                                                                               "createdAt":  "2022-11-25T12:37:41Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "rgroenewoudt",
                                           "body":  "[Using SSLStream or Websockets on Android \u003c 9 is also currently broken, which is a breaking change for people coming from the classic Xamarin](https://github.com/xamarin/xamarin-android/issues/7577)\r\n\r\n[Using HTTPClient SSL also doesn\u0027t work in Android 5-6, which is also a breaking change.](https://github.com/xamarin/xamarin-android/issues/7278#issuecomment-1226964789)",
                                           "updatedAt":  "2022-11-22T16:24:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5P4zic",
                                           "createdAt":  "2022-12-07T02:32:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "awakecoding",
                                           "body":  "Any update on this? We are hard-blocked on this to migrate RDM Android from Xamarin to .NET 6 since it breaks SQL Server connections, and it\u0027s unfortunately a feature that many of our users consider critical. What can we do to help expedite the process? While I don\u0027t particularly like the idea, would it be possible to work around the issue temporarily by building the .NET runtime from source with the changes from this branch? Is there enough implemented to fix the SQL server connection issue?",
                                           "updatedAt":  "2022-12-07T02:32:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5P47s7",
                                           "createdAt":  "2022-12-07T03:30:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveisok",
                                           "body":  "\u003e Any update on this? \r\n\r\nFor https://github.com/dotnet/SqlClient/issues/1656, I suspect https://github.com/dotnet/runtime/pull/78849 would fix things for you. Unfortunately, that fix won\u0027t be available until the February update of .NET 7 and .NET 6.  \r\n\r\nYou could build from source yourself, but I think it\u0027ll be rather painful updating all the places you need to. There isn\u0027t any real guidance on how to do that.",
                                           "updatedAt":  "2022-12-07T03:30:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ioEeH",
                                           "createdAt":  "2023-07-27T22:36:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODF82Jg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "steveisok",
                                                                               "createdAt":  "2023-07-27T22:38:47Z"
                                                                           },
                                                                           {
                                                                               "content":  "CONFUSED",
                                                                               "user":  "dotMorten",
                                                                               "createdAt":  "2023-09-06T20:27:10Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "Marking the remainder of this issue as Future like https://github.com/dotnet/runtime/issues/45737",
                                           "updatedAt":  "2023-07-27T22:36:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5l3H8B",
                                           "createdAt":  "2023-09-06T19:15:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotMorten",
                                           "body":  "I\u0027m hitting an issue with being able to use Android\u0027s Certificate picker (`KeyChain.ChoosePrivateKeyAlias`), and reusing the certificate with SocketsHttpHandler. Since installed certificates can\u0027t export the private key, I can\u0027t really convert it to a .NET certificate.\r\nWith the old Android client handlers, you would override `ConfigureCustomSSLSocketFactory` and returning the SSLSocketFactory to use the chosen certificate. \r\nWould this issue also address this need?",
                                           "updatedAt":  "2023-09-06T19:15:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5r-SX3",
                                           "createdAt":  "2023-11-14T22:26:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "borrrden",
                                           "body":  "Has anything regarding this been done in .NET 8?  Specifically I need to know if I can use a custom TLS certificate verification callback yet.  In .NET 6 / 7 the only way to accomplish this is by having a system trusted certificate setup ahead of time (usually via network_security.config or whatever it is called), but in a P2P model this fails because often certs are generated on the fly purely to get the encryption portion.  This means they are rejected without any remedy to explicitly trust them programmatically (the callback is simply not called and the certs are marked as untrusted)\r\n\r\nWait reading back I see\r\n\r\n\u003e  Non-system-default certificate validation\r\n\r\n    Any RemoteCertificateValidationCallback will only get an opportunity to validate certificates that have already been accepted by the system\u0027s built-in trust manager.\r\n    This means that the use cases of the callback for self-signed certificates or custom trust will not work.\r\n\r\nSo this is never going to be supported?  ",
                                           "updatedAt":  "2023-11-14T22:29:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5sijc-",
                                           "createdAt":  "2023-11-21T14:10:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CedreLo",
                                           "body":  "Any news on this ?\r\n",
                                           "updatedAt":  "2023-11-21T14:10:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5sizzj",
                                           "createdAt":  "2023-11-21T14:45:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "simonrozsival",
                                           "body":  "@borrrden @CedreLo hey! we shipped support for `RemoteCertificateValidationCallback` on Android in .NET 8 (#77386). You should also be able to use `HttpClientHandler. ServerCertificateCustomValidationCallback` and `SocketsHttpHandler.SslOptions.RemoteCertificateValidationCallback`.\r\n\r\n I\u0027ll update this issue to reflect this, sorry for the confusion. Let me know if you run into any issues with the custom certificate validation.",
                                           "updatedAt":  "2023-11-21T14:45:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5sjGDS",
                                           "createdAt":  "2023-11-21T15:24:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODNPdaw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "simonrozsival",
                                                                               "createdAt":  "2023-11-21T16:20:26Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "CedreLo",
                                           "body":  "Great news!\r\n\r\nas soon as visual studio will support ..NET8, i will switch to .NET8\r\n",
                                           "updatedAt":  "2023-11-21T15:24:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5sk8t9",
                                           "createdAt":  "2023-11-21T20:24:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "borrrden",
                                           "body":  "To clarify, will this also work with `SslStream` using the validation callback passed into the constructor?  That is the use case we are currently using.  The linked issue indicates yes.",
                                           "updatedAt":  "2023-11-21T20:25:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5snnU3",
                                           "createdAt":  "2023-11-22T08:37:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODNUffg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CedreLo",
                                                                               "createdAt":  "2023-11-22T09:26:44Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "simonrozsival",
                                           "body":  "@borrrden yes, `SslStream` will now use the validation callback you pass into the constructor.",
                                           "updatedAt":  "2023-11-22T08:37:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5spehj",
                                           "createdAt":  "2023-11-22T13:51:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODNWiPQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CedreLo",
                                                                               "createdAt":  "2023-11-22T14:24:24Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "akoeplinger",
                                           "body":  "\u003e as soon as visual studio will support ..NET8, i will switch to .NET8\r\n\r\n@CedreLo Visual Studio 2022 version 17.8 has full support for .NET8: https://devblogs.microsoft.com/visualstudio/visual-studio-17-8-now-available/",
                                           "updatedAt":  "2023-11-22T13:51:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5srZH-",
                                           "createdAt":  "2023-11-22T18:56:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotMorten",
                                           "body":  "@simonrozsival Will we now also be able to use the certificates installed on the device? Like the ones coming from `KeyChain.ChoosePrivateKeyAlias` ? We can create the X509Certificate with the Java Pointer to the Java certificate just fine, but the private key isn\u0027t directly available for .NET to use, and need to use the underlying Java APIs to authenticate the stream. (So far I\u0027ve only been able to use certificates that are loaded from a file on disk and has full access to the private key, but that\u0027s not generally how customers deploy their PKI certificates, since it creates a risk of exporting the private key).",
                                           "updatedAt":  "2023-11-22T18:57:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5st9eb",
                                           "createdAt":  "2023-11-23T08:40:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "simonrozsival",
                                           "body":  "@dotMorten I think there currently isn\u0027t a good way to access the certificates installed on device without using the Java APIs directly. Have you already opened an issue with the use case? If not, could you please open one? We could then discuss if that\u0027s something to look into in .NET 9.",
                                           "updatedAt":  "2023-11-23T08:40:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53V_IK",
                                           "createdAt":  "2024-03-17T01:36:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotMorten",
                                           "body":  "@simonrozsival For some reason I missed your comment, and for a while thought the issue was the same as this one - I\u0027ve added a separate issue: https://github.com/dotnet/runtime/issues/99874",
                                           "updatedAt":  "2024-03-17T01:36:44Z"
                                       }
                                   ],
                         "totalCount":  19
                     },
        "title":  "Implement System.Security.Cryptography.Native.Android PAL",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "os-android",
                       "tracking"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/46426",
        "createdAt":  "2020-12-28T10:23:28Z",
        "number":  46426,
        "author":  "pgrawehr",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOClO0dA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ProphetLamb",
                                            "createdAt":  "2022-07-05T17:52:43Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2023-05-15T12:33:04Z",
        "body":  "### Description\r\n\r\n`Marshal.SizeOf(typeof(somegenericstruct))` throws `ArgumentException` when T is a closed generic type. It should only throw on open generic types. \r\n\r\nHere\u0027s the implementation\r\n\r\n```C#\r\npublic static int SizeOf(Type t)\r\n        {\r\n            if (t is null)\r\n            {\r\n                throw new ArgumentNullException(nameof(t));\r\n            }\r\n            if (!t.IsRuntimeImplemented())\r\n            {\r\n                throw new ArgumentException(SR.Argument_MustBeRuntimeType, nameof(t));\r\n            }\r\n            if (t.IsGenericType) // This should be changed to IsGenericTypeDefinition, I think\r\n            {\r\n                throw new ArgumentException(SR.Argument_NeedNonGenericType, nameof(t));\r\n            }\r\n\r\n            return SizeOfHelper(t, throwIfNotMarshalable: true);\r\n        }\r\n\r\n```\r\n\r\n### Configuration\r\n\r\nSeen on .NET 5.0\r\n\r\n### Analysis\r\nThe [documentation](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.sizeof?view=net-5.0) says that `ArgumentException` is thrown if t is a generic type definition. The implementation however throws when it is any generic type (including a closed one). The implementation of the similar method\r\n\r\n```C#\r\npublic static int SizeOf\u003cT\u003e(T structure)\r\n```\r\n\r\ndoes not throw this exception - it can be used as workaround. \r\n\r\nHere\u0027s some test code:\r\n\r\n```C#\r\n    public class FrameworkBehaviorTests\r\n    {\r\n        [Fact]\r\n        public void CannotGetSizeOfOpenGenericType()\r\n        {\r\n\t\t\t// This exception is expected\r\n            Assert.Throws\u003cArgumentException\u003e(() =\u003e\r\n            {\r\n                Marshal.SizeOf(typeof(GenericStruct\u003c\u003e));\r\n            });\r\n        }\r\n\r\n        [Fact]\r\n        public void CanGetSizeOfOpenGenericType()\r\n        {\r\n            // This test fails and throws as well\r\n            Assert.Equal(8, Marshal.SizeOf(typeof(GenericStruct\u003cshort\u003e)));\r\n        }\r\n\r\n        [Fact]\r\n        public void CanGetSizeOfOpenGenericTypeViaInstance()\r\n        {\r\n\t\t\t// This test passes, because it uses the SizeOf\u003cT\u003e(T object) overload\r\n            GenericStruct\u003cshort\u003e gs;\r\n            gs._data1 = 2;\r\n            gs._data2 = 10;\r\n            Assert.Equal(8, Marshal.SizeOf(gs));\r\n        }\r\n\r\n        private struct GenericStruct\u003cT\u003e\r\n        {\r\n            public T _data1;\r\n            public int _data2;\r\n        }\r\n    }\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOXEE3vg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc1MTY2Mzk4OA==",
                                           "createdAt":  "2020-12-28T10:23:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Dotnet-GitSync-Bot",
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2020-12-28T10:23:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc1NDk5MDMwNw==",
                                           "createdAt":  "2021-01-06T00:40:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "@pgrawehr This is the expected behavior. This behavior is consistent with .NET Framework and has been this way for quite some time - please let me know if I am missing the scenario. The fact that a Generic type has a closed type or not isn\u0027t a consideration for this API. Relaxing this to permit closed Generic types is possible, but it would require a discussion.\r\n\r\nAt this point I believe the open question is, is this a reported bug in the documentation or is the request to permit this operation?",
                                           "updatedAt":  "2021-01-06T00:40:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc1NTAxNzcxNw==",
                                           "createdAt":  "2021-01-06T01:30:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "It should be noted that the `Marshal.SizeOf` suite of functions are specifically for interop scenarios and not for computing arbitrary type size. With the support for some blittable Generic types in P/Invoke signatures (Issue: https://github.com/dotnet/runtime/issues/4547 PR: https://github.com/dotnet/coreclr/pull/23899) we may want to permit some narrow functionality in this area.\r\n\r\n/cc @jkoritzinsky @elinor-fung @tannergooding ",
                                           "updatedAt":  "2021-01-06T01:30:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc1NTAyMzQ1OQ==",
                                           "createdAt":  "2021-01-06T01:50:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "I believe we had previously discussed updating `S.R.I.Marshal` to handle generics as well but it was decided against. I can\u0027t seem to find the relevant thread at the moment, however (IIRC, enabling generics was one of the migrated PRs from dotnet/coreclr so that might be contributing).",
                                           "updatedAt":  "2021-01-06T01:50:01Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc1NTAyNDI4NQ==",
                                           "createdAt":  "2021-01-06T01:53:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "I might be remembering https://github.com/dotnet/runtime/issues/32963#issuecomment-592609261, which was related to `GetDelegateForFunctionPointer` rather than `SizeOf`...",
                                           "updatedAt":  "2021-01-06T01:53:02Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc1NTEwOTQwOQ==",
                                           "createdAt":  "2021-01-06T06:25:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pgrawehr",
                                           "body":  "@AaronRobinsonMSFT I know that it\u0027s probably a rare scenario that one uses a struct with a generic parameter for blitting, however I see no reason why this shouldn\u0027t work (at least if the generic parameter is by itself blittable). Do note that it works as I would expect with the other overloads of SizeOf(), i.e. given an actual instance of the generic type. The `SizeOf(Type)` overload is the only one checking for this `IsGenericType` condition.",
                                           "updatedAt":  "2021-01-06T06:25:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DkvnY",
                                           "createdAt":  "2022-05-21T17:35:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e The SizeOf(Type) overload is the only one checking for this IsGenericType condition.\r\n\r\nYes and I think that is the point actually. I\u0027ve given this some more thought and rummaged through some interop code bases and I think this API is commonly used for the \"is blittable\" check for a `Type`. This would imply that being more permissible could break existing applications, which is difficult to mitigate on the interop boundary.\r\n\r\nHere are some other related issues to Generics and the `Marshal` class that we should either decide to enable or close.\r\n- https://github.com/dotnet/runtime/issues/43486\r\n- https://github.com/dotnet/runtime/issues/9136\r\n- https://github.com/dotnet/runtime/issues/13197\r\n\r\n",
                                           "updatedAt":  "2022-05-21T17:35:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DlZOw",
                                           "createdAt":  "2022-05-22T11:37:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pgrawehr",
                                           "body":  "@AaronRobinsonMSFT That\u0027s what I\u0027m expecting. I\u0027m expecting Sizeof(Type) to work when Type is blittable. And a generic struct with (defined) generic arguments _is_ blittable. Consider (from the example above):\r\n\r\n```csharp\r\n[StructLayout(LayoutKind.Sequenzial, Pack=1)]\r\nprivate struct GenericStruct\u003cT\u003e\r\n        {\r\n            public T _data1;\r\n            public int _data2;\r\n        }\r\n```\r\nthen the type `GenericStruct\u003cshort\u003e` is blittable, and hence `Marshal.SizeOf(typeof(GenericStruct\u003cshort\u003e))` should succeed and return 6. I\u0027m absolutely fine that `Marshal.SizeOf(typeof(GenericStruct\u003c\u003e))` throws. \r\n\r\nNote that all I\u0027m suggesting is that the condition\r\n\r\n```csharp\r\n            if (t.IsGenericType)\r\n            {\r\n                throw new ArgumentException(SR.Argument_NeedNonGenericType, nameof(t));\r\n            }\r\n```\r\nbe changed to\r\n```\r\n            if (t.IsGenericTypeDefinition)\r\n            {\r\n                throw new ArgumentException(SR.Argument_NeedNonGenericType, nameof(t));\r\n            }\r\n```\r\nThis would also be in line with the documentation, where it says that `ArgumentException` is thrown when \"The t parameter is a generic type **definition**\" (emphasis mine).\r\n\r\nConceptually, the entire test could be left away as well, since the implementation further down would throw anyway on something that is not blittable (only maybe with a less clear message).",
                                           "updatedAt":  "2022-05-22T11:37:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Dln0_",
                                           "createdAt":  "2022-05-22T17:06:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e I\u0027m expecting Sizeof(Type) to work when Type is blittable. And a generic struct with (defined) generic arguments is blittable.\r\n\r\nAgreed, but it isn\u0027t in .NET Framework and that means assumptions are baked into applications for that reason. Changing this would impact those assumptions about how code has evolved and branches.",
                                           "updatedAt":  "2022-05-22T17:06:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Dlq5c",
                                           "createdAt":  "2022-05-22T18:21:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pgrawehr",
                                           "body":  "Code that used to work would still work. I\u0027m actually not expecting anyone to use this method to test whether an object contains generics, as this can be tested directly, not using this method and relying on catching the exception. No code should ever catch ArgumentException. \r\n\r\nAlso, if I understand #43486 and #103 correctly, marshalling generics was not at all supported in .NET Framework. ",
                                           "updatedAt":  "2022-05-22T18:21:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Dlw04",
                                           "createdAt":  "2022-05-22T20:36:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003eAlso, if I understand https://github.com/dotnet/runtime/issues/43486 and https://github.com/dotnet/runtime/pull/103 correctly, marshalling generics was not at all supported in .NET Framework.\r\n\r\nThat is precisely my point. Consider the following for code that was initially ported from .NET Framework in the .NET Core 1.0 timeframe.\r\n\r\n```csharp\r\nbool CanUseType(Type t)\r\n{\r\n    try\r\n    {\r\n        Marshal.SizeOf(t);\r\n        return true;\r\n    }\r\n    catch\r\n    {\r\n        return false;\r\n    }\r\n}\r\n```\r\n\r\nWhatever logic this was blocking included cases when `Type` was a Generic, either open or closed. However, by relaxing the current behavior this code would now permit Generic types in code that quite possibly never expected that. This is very dangerous in the interop domain and it must be considered.\r\n\r\nI referenced the other issues precisely to ensure or at least attempt to verify older code that was ported would continue to work. Opening up this one API could yield failures further down because other APIs haven\u0027t been updated. However, if we update how we think about Generics in all these situations then changing this behavior makes perfect sense. All I am getting at here is a piecewise permissiveness isn\u0027t something the interop team is generally comfortable with because it can expose existing fragile code paths to break in unexpected and dangerous ways.",
                                           "updatedAt":  "2022-05-22T20:36:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DmmUb",
                                           "createdAt":  "2022-05-23T05:16:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pgrawehr",
                                           "body":  "I see your point, and digging a bit further, the problem seems to be larger than what I anticipated. It appears that when generic types where made blittable for .NET core, it was only partially done. I started with being confused that `Marshal.SizeOf(typeof(GenericStruct\u003cshort\u003e))` fails, but `Marshal.Sizeof(new GenericStruct\u003cshort\u003e())` works. Now I just see that `Marshal.StructureToPtr(new GenericStruct\u003cshort\u003e(), ptr, false)` also fails, **despite the documentation saying that it fails only in .NET Framework**. \r\n\r\nI guess we need a bunch of test cases first to test what works and what doesn\u0027t. And probably first a decision what behavior we would like to have and whether we risk taking a possibly breaking change. And then fix the code or update the documentation. The fact that the documentation states what I was expecting is an indication that it was at least _planned_ to do the change at some point.",
                                           "updatedAt":  "2022-05-23T05:19:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DpAB5",
                                           "createdAt":  "2022-05-23T15:29:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCeMUIQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2022-05-23T15:59:22Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "When generic interop types were made possible, it was really just relaxing the restriction in the interop logic so it could cross the managed/native boundary.\r\n\r\nThere wasn\u0027t also work done to update `Marshal.*` to support this and much of that was done based on the feedback @AaronRobinsonMSFT has already given above.\r\n\r\nPut another way, these types must already be blittable and so you don\u0027t want to use any of the `Marshal` APIs. `Unsafe.SizeOf`, `Unsafe.WriteUnaligned`, `NativeMemory.Alloc`, and other APIs are all faster and better for blittable data. The same goes for directly taking/passing `MyStruct\u003cT\u003e*` and using pointer types directly.\r\n\r\nThis is all \"inline\" with an effort to move users off of the built-in marshalling support and onto things like `DllImportGenerator` which generates and works off blittable data behind the scenes.",
                                           "updatedAt":  "2022-05-23T15:29:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DpDkD",
                                           "createdAt":  "2022-05-23T15:42:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pgrawehr",
                                           "body":  "I see, but then I would expect remarks in the documentation of the Marshal class that it is considered legacy and which alternatives should be used. Instead, we have documentation that suggests that `Marshal.*` was updated, which apparently is just not the case. ",
                                           "updatedAt":  "2022-05-23T15:42:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5cA8w1",
                                           "createdAt":  "2023-05-11T10:36:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "genaray",
                                           "body":  "Whats the state of this issue?\r\nI recently stumbled upon the same problem and it would really great to see this one in the future since the Marshal.SizeOf API is kinda limited rn. ",
                                           "updatedAt":  "2023-05-11T10:36:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5cCY-0",
                                           "createdAt":  "2023-05-11T14:50:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "As indicated above, generic types must already be blittable to cross the P/Invoke boundary and so `Unsafe.SizeOf` will compute the correct result and be faster.",
                                           "updatedAt":  "2023-05-11T14:50:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5cQTe-",
                                           "createdAt":  "2023-05-15T12:32:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "genaray",
                                           "body":  "\u003e As indicated above, generic types must already be blittable to cross the P/Invoke boundary and so `Unsafe.SizeOf` will compute the correct result and be faster.\r\n\r\nHowever it does not support common Types, correct? \r\nE.g. : `Unsafe.SizeOf(typeof(MyWrapper\u003cint\u003e));`\r\n\r\nWould be nice to see a Type based API that is capable of determining those sizes. ",
                                           "updatedAt":  "2023-05-15T12:33:04Z"
                                       }
                                   ],
                         "totalCount":  17
                     },
        "title":  "Marshal.SizeOf(Type) is throwing incorrectly on generic types",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/46521",
        "createdAt":  "2021-01-03T13:41:33Z",
        "number":  46521,
        "author":  "Youssef1313",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-07-10T16:31:03Z",
        "body":  "Types that implement `ICustomMarshaler` must have a [`GetInstance`](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.icustommarshaler?view=net-5.0#implementing-the-getinstance-method) method with correct signature.\r\n\r\n@mavasani I opened this here instead of roslyn-analyzers as it\u0027s related to API usage. Feel free to move the issue if this fits more in roslyn-analyzers repo.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  null,
                         "nodes":  [

                                   ],
                         "totalCount":  0
                     },
        "title":  "Analyzer proposal: Missing GetInstance for `ICustomMarshaler`s",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.InteropServices",
                       "code-analyzer"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/48796",
        "createdAt":  "2021-02-26T01:30:10Z",
        "number":  48796,
        "author":  "AaronRobinsonMSFT",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODIcffg==",
                          "nodes":  [
                                        {
                                            "content":  "HEART",
                                            "user":  "tannergooding",
                                            "createdAt":  "2021-02-26T01:47:46Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "tannergooding",
                                            "createdAt":  "2021-02-26T01:47:48Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "saucecontrol",
                                            "createdAt":  "2021-02-26T02:17:39Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "saucecontrol",
                                            "createdAt":  "2021-02-26T02:17:40Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "filipnavara",
                                            "createdAt":  "2021-02-26T13:30:28Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "filipnavara",
                                            "createdAt":  "2021-02-26T13:30:30Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "hez2010",
                                            "createdAt":  "2022-04-09T15:43:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ForNeVeR",
                                            "createdAt":  "2022-06-22T16:06:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "nxrighthere",
                                            "createdAt":  "2022-08-31T08:56:03Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mfkl",
                                            "createdAt":  "2022-10-05T06:44:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "msedi",
                                            "createdAt":  "2022-12-16T09:26:17Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "JaXt0r",
                                            "createdAt":  "2023-04-08T19:10:33Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "JaXt0r",
                                            "createdAt":  "2023-04-08T19:10:37Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "JaXt0r",
                                            "createdAt":  "2023-04-08T19:10:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "TomEdwardsEnscape",
                                            "createdAt":  "2023-06-17T09:33:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "IS4Code",
                                            "createdAt":  "2024-03-17T10:35:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "alexrp",
                                            "createdAt":  "2024-04-15T17:08:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "JackHarckness",
                                            "createdAt":  "2024-04-25T23:18:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ldy985",
                                            "createdAt":  "2024-06-04T20:04:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jwosty",
                                            "createdAt":  "2024-08-20T17:36:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ohroy",
                                            "createdAt":  "2024-09-09T08:16:58Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "raulsntos",
                                            "createdAt":  "2024-12-10T03:36:09Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mriehm",
                                            "createdAt":  "2025-01-15T08:26:25Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MichalPetryka",
                                            "createdAt":  "2025-07-25T00:14:51Z"
                                        }
                                    ],
                          "totalCount":  24
                      },
        "updatedAt":  "2025-07-25T13:21:02Z",
        "body":  "## Background and Motivation\r\n\r\nNative varargs are a complicated interop scenario to support. At present, native varargs are only supported on the Windows platform through the undocumented `__arglist` keyword. Supporting varargs naturally in a P/Invoke scenario would be difficult from the C# language. However, it is possible to compromise by permitting support for the call with a fully specified `DllImport` signature and a hint from the user.\r\n\r\nUser scenario: https://github.com/dotnet/runtime/issues/48752\r\n\r\n## Proposed API\r\n\r\n```diff\r\nnamespace System.Runtime.InteropServices\r\n{\r\n+    [AttributeUsage(AttributeTargets.Method)]\r\n+    public class NativeVarargsAttribute : Attribute\r\n+    {\r\n+        public NativeVarargsAttribute() { VarargBeginIndex = 0; }\r\n+\r\n+        /// \u003csummary\u003e\r\n+        /// Zero-based index of the first variable argument.\r\n+        /// \u003c/summary\u003e\r\n+        public int VarargBeginIndex;\r\n+    }\r\n}\r\n```\r\n\r\n## Usage Examples\r\n\r\nConsider the following native export with varargs:\r\n\r\n```c\r\nvoid Varargs(int n, ...);\r\n```\r\n\r\nThe following P/Invoke declarations would enable users to call and properly forward the arguments in a supported multi-platform manner.\r\n\r\n```csharp\r\n[NativeVarargsAttribute(VarargBeginIndex = 1)]\r\n[DllImport(@\"NativeLibrary.dll\", EntryPoint = \"Varargs\")]\r\nstatic extern void Varargs0(int n);\r\n\r\n[NativeVarargsAttribute(VarargBeginIndex = 1)]\r\n[DllImport(@\"NativeLibrary.dll\", EntryPoint = \"Varargs\")]\r\nstatic extern void Varargs1(int n, int a);\r\n\r\n[NativeVarargsAttribute(VarargBeginIndex = 1)]\r\n[DllImport(@\"NativeLibrary.dll\", EntryPoint = \"Varargs\")]\r\nstatic extern void Varargs2(int n, int a, int b);\r\n```\r\n\r\n## Alternative designs\r\n\r\nEncode the information in the [`CallingConvention`](https://docs.microsoft.com/dotnet/api/system.runtime.interopservices.callingconvention) enum. This approach does remove the overhead of attribute reading, but does miss the added data of knowing where the varargs start - at present doesn\u0027t appear to be needed. This approach also impacts existing metadata tooling (for example, ILDasm, ILAsm, and ILSpy). See https://github.com/dotnet/runtime/issues/48796#issuecomment-786355000.\r\n\r\n```diff\r\npublic enum CallingConvention\r\n{\r\n+    VarArg = 6\r\n}\r\n```\r\n\r\n## Current state\r\n\r\nWithout this feature, calling functions with native varargs isn\u0027t possible on a non-Windows platforms. The proposed workaround is to create native shim libraries and instead P/Invoke into them. Continuing the example above, the shim library would export the following:\r\n\r\n```c\r\nextern void Varargs(int n, ...);\r\n\r\nvoid Varargs0(int n)\r\n{\r\n    Varargs(n);\r\n}\r\nvoid Varargs1(int n, int a)\r\n{\r\n    Varargs(n, a);\r\n}\r\nvoid Varargs2(int n, int a, int b)\r\n{\r\n    Varargs(n, a, b);\r\n}\r\n```\r\n\r\n## References\r\n\r\nSupport on Windows: https://github.com/dotnet/coreclr/pull/18373\r\nJIT details: https://github.com/dotnet/runtime/issues/10478\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHONMJSMw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjM0NzEyNQ==",
                                           "createdAt":  "2021-02-26T01:31:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "/cc @mangod9 @sandreenko @sdmaclea @jkoritzinsky @elinor-fung @lambdageek",
                                           "updatedAt":  "2021-02-26T02:09:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjM0OTg5MA==",
                                           "createdAt":  "2021-02-26T01:40:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sdmaclea",
                                           "body":  "/cc @jkotas @janvorli ",
                                           "updatedAt":  "2021-02-26T01:40:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjM1MDMyNQ==",
                                           "createdAt":  "2021-02-26T01:41:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEFG6rg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "KandariukAO",
                                                                               "createdAt":  "2021-02-26T01:53:13Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "filipnavara",
                                                                               "createdAt":  "2021-02-26T23:44:10Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alexrp",
                                                                               "createdAt":  "2024-04-15T17:12:53Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "geniuszxy",
                                                                               "createdAt":  "2025-01-04T04:57:13Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "BCSharp",
                                                                               "createdAt":  "2025-02-04T01:02:33Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  5
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "The _arglist keyword is supported for interop with P/Invoke on Windows platforms and the JIT already knows how to understand the encoding.\r\n\r\nI think we should just use the _arglist keyword instead of adding a new attribute. The attribute read is much more expensive.",
                                           "updatedAt":  "2021-02-26T01:41:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjM1MDk2Mw==",
                                           "createdAt":  "2021-02-26T01:43:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sdmaclea",
                                           "body":  "Maybe the trick is `undocumented` -\u003e `documented`",
                                           "updatedAt":  "2021-02-26T01:43:09Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjM1MTM0OA==",
                                           "createdAt":  "2021-02-26T01:44:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBhdeJQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "sdmaclea",
                                                                               "createdAt":  "2021-02-26T01:45:58Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003eI think we should just use the _arglist keyword instead of adding a new attribute. The attribute read is much more expensive.\r\n\r\nNot sure the attribute read should be a concern here to be honest. The generation of the stub is likely to be more costly than that. Also that read would be a single time.\r\n\r\nAlso, this is not about supporting varargs as it looks on Windows. This is about supporting the calling of varargs with a fully typed P/Invoke. The keyword would have no where to go and is not a placeholder we are likely to want.",
                                           "updatedAt":  "2021-02-26T01:45:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjM1NDc0NA==",
                                           "createdAt":  "2021-02-26T01:54:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODu8-rQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jwosty",
                                                                               "createdAt":  "2024-08-20T17:37:10Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e Supporting varargs naturally in a P/Invoke scenario would be difficult from the C# language.\r\n\r\nWhat is the difficulty here? Is it not largely just the same as it does today, which is to push the args onto the execution stack and so (other than it being not an official keyword) it would largely just be the runtime handling it correctly for other platforms?",
                                           "updatedAt":  "2021-02-26T01:54:37Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjM1NTAwMA==",
                                           "createdAt":  "2021-02-26T01:55:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e  the attribute read \r\n\r\nThis can be fixed by combining this with adding a new member to `CallingConvention` enum. We would pay the attention to the advanced calling convention attributes only for the Extended calling conventions.\r\n```\r\npublic enum CallingConvention\r\n{\r\n    Extended = 6\r\n}\r\n```\r\n\r\nAlternatively, this can be just a new `CallingConvention` value:\r\n```\r\npublic enum CallingConvention\r\n{\r\n    VarArg = 6\r\n}\r\n```\r\n\r\n\u003e __arglist keyword\r\n\r\nThe `__arglist` keyword is poorly supported corner case. See e.g. https://github.com/dotnet/docs/issues/18714 .\r\n\r\nWe should also think how we would enable this with function pointers. `__arglist` keyword is not supported with function pointers today.\r\n\r\n\u003e varargs as it looks on Windows\r\n\r\nNote that varargs interop on Windows supports both forward and reverse interop, and both `...` and `va_list`. It is what makes it very complex and expensive to just do what we do on Windows accross all platforms.",
                                           "updatedAt":  "2021-02-26T01:55:22Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjM1NzI5Ng==",
                                           "createdAt":  "2021-02-26T02:02:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sdmaclea",
                                           "body":  "\u003e What is the difficulty here?\r\n\r\nABIs vary across platforms.  Some platforms can treat vararg arguments differently than normal arguments.  On Apple Silicon, they are definitely treated differently.\r\n\r\nSo for interop we need to be explicit to support al platforms correctly.",
                                           "updatedAt":  "2021-02-26T02:03:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjM1NzQzMQ==",
                                           "createdAt":  "2021-02-26T02:02:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003eThis can be fixed by combining this with adding a new member to CallingConvention enum.\r\n\r\nI was avoiding that since it would be encoded directly in metadata through `DllImport`. My previous experience was we prefer to avoid that given the impact to tooling.\r\n\r\n",
                                           "updatedAt":  "2021-02-26T02:02:35Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjM2MDg0NQ==",
                                           "createdAt":  "2021-02-26T02:11:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODu9AeQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alexrp",
                                                                               "createdAt":  "2024-04-15T17:14:17Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jwosty",
                                                                               "createdAt":  "2024-08-20T17:40:48Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e ABIs vary across platforms. Some platforms can treat vararg arguments differently than normal arguments.\r\n\r\nSure, but I don\u0027t see why `__arglist` (or a new properly supported keyword) cannot be properly handled by the JIT to be the correct `...` for a given platform. The JIT is entirely stack based and it is free to translate that as appropriate to be registers, stack, or whatever else is appropriate for the ABI. It has to do this for all arguments already.\r\n\r\nA method in native is written as `void method(...)` and is then handled via `va_start`, `va_arg`, `va_copy`, `va_end`, and `va_list`. So one would expect that we could simply have a corresponding concept for `...` in .NET (currently `__arglist` which translates to the ECMA 335 `vararg` convention) and the relevant helpers (currently `ArgIterator`).\r\n\r\nSo I\u0027m not seeing what is blocking the same from working on say Unix or Apple Silicon, other than the JIT not correctly handling these on non-windows. I would expect that if we just simply implemented the ABI defined (https://gitlab.com/x86-psABIs/x86-64-ABI for System V) then both forward and reverse P/Invoke would work (and that this is necessary anyways for whatever new concept is exposed)",
                                           "updatedAt":  "2021-02-26T02:11:55Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjM2MjA2Mg==",
                                           "createdAt":  "2021-02-26T02:15:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003eSure, but I don\u0027t see why __arglist (or a new properly supported keyword) cannot be properly handled by the JIT to be the correct ... for a given platform.\r\n\r\nI don\u0027t think there is any reason other than this proposal is for a non-language impacting update :-) We can also start a conversation with Roslyn about how one would express this in C#.",
                                           "updatedAt":  "2021-02-26T02:15:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjM2MjM3NQ==",
                                           "createdAt":  "2021-02-26T02:16:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBhdqxA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2021-02-26T02:28:22Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e I was avoiding that since it would be encoded directly in metadata through DllImport. My previous experience was we prefer to avoid that given the impact to tooling.\r\n\r\nYes, it has an impact on tooling. My actual concern is that we need a scalable pattern to add new calling conventions for DllImport. Let\u0027s say that we add 10 new calling conventions. What is the pattern we want to follow? Is it going to be 10 different attributes?",
                                           "updatedAt":  "2021-02-26T02:16:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjM2MzE0MA==",
                                           "createdAt":  "2021-02-26T02:18:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODu9A4g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "filipnavara",
                                                                               "createdAt":  "2021-02-26T13:35:01Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "akoeplinger",
                                                                               "createdAt":  "2021-03-09T12:11:40Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jwosty",
                                                                               "createdAt":  "2024-08-20T17:41:46Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e I don\u0027t think there is any reason other than this proposal is for a non-language impacting update \r\n\r\n`__arglist` is a \"reserved\" keyword today, you can\u0027t even name a class with it (at least in Roslyn you get `error CS0190: The __arglist construct is valid only within a variable argument method` if you try). Maybe its as simple as just spec\u0027ing the thing that has always been there and making it an \"official\" keyword? It\u0027s not pretty, but it\u0027s also really only for P/Invoke scenarios, so maybe that isn\u0027t the worst thing.",
                                           "updatedAt":  "2021-02-26T02:19:26Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjM2NDgwOQ==",
                                           "createdAt":  "2021-02-26T02:23:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003eLet\u0027s say that we add 10 new calling conventions. What is the pattern we want to follow? Is it going to be 10 different attributes?\r\n\r\nGreat question. I\u0027ve not spent much time considering that as it relates to `DllImport`. One thing I think we can all agree on is the desire to not have 10 attributes.\r\n\r\n\u003e Maybe its as simple as just spec\u0027ing the thing that has always been there and making it an \"official\" keyword? It\u0027s not pretty, but it\u0027s also really only for P/Invoke scenarios, so maybe that isn\u0027t the worst thing.\r\n\r\nSure, seems like a reasonable perspective. The `__` prefix does have some [implementation/undocumented](https://github.com/dotnet/docs/issues/18714#issuecomment-636917385) semantics associated with it so it would need to be a new keyword for proper support and thus language impacting.",
                                           "updatedAt":  "2021-02-26T02:23:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjM2NTQ1MA==",
                                           "createdAt":  "2021-02-26T02:25:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODeOmog==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2021-02-26T02:27:12Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tannergooding",
                                                                               "createdAt":  "2021-02-26T02:27:18Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "filipnavara",
                                                                               "createdAt":  "2021-02-26T13:34:54Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alexrp",
                                                                               "createdAt":  "2024-04-15T17:14:06Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "jkotas",
                                           "body":  "If we go with some variant of `__arglist` keyword, we should also figure out how it is going to work with the interop source generators that is our forward looking interop story.",
                                           "updatedAt":  "2021-02-26T02:25:20Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjM2ODE3OQ==",
                                           "createdAt":  "2021-02-26T02:32:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e Sure, seems like a reasonable perspective. The __ prefix does have some implementation/undocumented semantics associated with it so it would need to be a new keyword for proper support and thus language impacting.\r\n\r\nI think that\u0027s fine. It might be that they say `__arglist` just becomes official and it could be that they say they now support `...` or `arglist` contextually or something else. But I\u0027d also expect (and hope) its \"less\" work given the existance of `__arglist` already wired fairly end to end (but someone from LDM could confirm).\r\n\r\n\u003e If we go with some variant of __arglist keyword, we should also figure out how it is going to work with the interop source generators that is our forward looking interop story.\r\n\r\nWhat consideration is needed here? Is this exposing a managed helper signature because exposing a managed method which takes `...` is undesirable?\r\n\r\nI had already experimented with having ClangSharp recognize variadic functions and generate `__arglist` but never checked it in because it was Windows only and not officially supported. The pattern seems fairly straightforward...",
                                           "updatedAt":  "2021-02-26T02:33:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjM2OTY3MQ==",
                                           "createdAt":  "2021-02-26T02:37:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBhdtig==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tannergooding",
                                                                               "createdAt":  "2021-02-26T02:38:24Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003eWhat consideration is needed here? Is this exposing a managed helper signature because exposing a managed method which takes ... is undesirable?\r\n\r\nYes basically. Consider how our [prototype source gen](https://github.com/dotnet/runtimelab/blob/feature/DllImportGenerator/DllImportGenerator/Demo/Program.cs) works:\r\n\r\n``` C#\r\n[GeneratedDllImport(NativeExportsNE_Binary, EntryPoint = \"sumi\")]\r\npublic static partial int Sum(int a, \u003c... or __arglist\u003e);\r\n```\r\n\r\nThe above varargs would need to be marshalled in some manner. Which means the variable argument list would need to be inspected in an efficient way at run time to perform that marshalling and forward those arguments.",
                                           "updatedAt":  "2021-02-26T02:42:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjM3NDA5NA==",
                                           "createdAt":  "2021-02-26T02:50:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "Could the source generator not just do the concrete overloads. Say for example you had \r\n```csharp\r\n[GeneratedDllImport(\"msvcrt\", EntryPoint = \"printf\")]\r\npublic static int Print(string format, __arglist);\r\n```\r\n\r\nFor this, the generator would create:\r\n```csharp\r\n[DllImport(\"msvcrt\")]\r\nprivate static extern printf(sbyte* format, __arglist);\r\n```\r\n\r\nAnd for each unique invocation it found, it would generate a helper override that is a more exact match.\r\nFor example, if you did `Print(\"%s%s%s\", \"Hello\", \", \", \"World!\");` and `Print(\"%g\", 100.0f);`\r\n\r\nThe following two helpers would be generated:\r\n```csharp\r\npublic static partial int Print(string format, string arg0, string arg1, string arg2)\r\n{\r\n    fixed (byte* pFormat = Encoding.GetUTF8Bytes(format))\r\n    fixed (byte* pArg0 = Encoding.GetUTF8Bytes(arg0))\r\n    fixed (byte* pArg1 = Encoding.GetUTF8Bytes(arg0))\r\n    fixed (byte* pArg2 = Encoding.GetUTF8Bytes(arg0))\r\n    {\r\n        return printf(pFormat, pArg0, pArg1, pArg2);\r\n    }\r\n}\r\n\r\npublic static partial int Print(string format, float arg0)\r\n{\r\n    fixed (byte* pFormat = Encoding.GetUTF8Bytes(format))\r\n    {\r\n        return printf(pFormat, format);\r\n    }\r\n}\r\n```\r\n\r\nThe only \"loose\" end would be that nothing was generated for the original `public static int Print(string format, __arglist)` and a decision on what to do here would need to be handled.",
                                           "updatedAt":  "2021-02-26T02:50:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjM3NjMwOQ==",
                                           "createdAt":  "2021-02-26T02:57:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003eAnd for each unique invocation it found, it would generate a helper override that is a more exact match.\r\n\r\nYep. Until a library decided to expose the P/Invoke directly at which point it may not observe any concrete calls.",
                                           "updatedAt":  "2021-02-26T02:57:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjM3ODIzMg==",
                                           "createdAt":  "2021-02-26T03:03:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e Yep. Until a library decided to expose the P/Invoke directly at which point it may not observe any concrete calls.\r\n\r\nIsn\u0027t that the same world we already have today if someone does the following on Windows?\r\n```csharp\r\n[DllImport(\"msvcrt\")]\r\npublic static extern printf(sbyte* format, __arglist)\r\n```\r\n\r\nCan we not maintain the same support or can we not just block non-blittable parameters here (like we do for generics and a few other scenarios)?",
                                           "updatedAt":  "2021-02-26T03:03:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjM4MTYwMw==",
                                           "createdAt":  "2021-02-26T03:13:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003eIsn\u0027t that the same world we already have today if someone does the following on Windows?\r\n\r\nI don\u0027t think so. I believe a library can export that signature as is today without issue. But your proposal for the source generator approach wouldn\u0027t work for that case because it won\u0027t see the callsite when the application calls the libraries export.\r\n\r\n\u003eCan we not maintain the same support or can we not just block non-blittable parameters here (like we do for generics and a few other scenarios)?\r\n\r\nI guess we could impose that, but my perspective is it isn\u0027t worth it. The proposed approach makes calling a vararg function possible and will naturally work with source generators in all scenarios since we tell the JIT how to pass the arguments. Supporting the gamut of varargs doesn\u0027t seem to be worth the cost at this point. It would impose a large burden on the source generator because the convention would need to be forwarded properly and the language updated. I\u0027m simply not seeing the value in the cost to make it fully supported.",
                                           "updatedAt":  "2021-02-26T03:13:35Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjM4NTA0NQ==",
                                           "createdAt":  "2021-02-26T03:24:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBhd7OQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "saucecontrol",
                                                                               "createdAt":  "2021-02-26T03:29:23Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e I\u0027m simply not seeing the value in the cost to make it fully supported.\r\n\r\nActually, I think it was also pointed out in https://github.com/dotnet/runtime/issues/48796#issuecomment-786360845 that a lot of the JIT work will be the same - I agree with that. We can view this proposal with its requirement of a precise signature to be a down payment on enabling full support. Since if this proposal was accepted all we would need to do is address two additional issues:\r\n\r\n1) Make it an official scenario in C#.\r\n1) Ensure we have the facilities to make it work with source generators.\r\n\r\nI think this proposal simply starts the journey towards full support in an [MVP](https://en.wikipedia.org/wiki/Minimum_viable_product) manner.",
                                           "updatedAt":  "2021-02-26T03:27:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjM5MTU4NQ==",
                                           "createdAt":  "2021-02-26T03:47:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "So you\u0027re basically thinking something like the following for the minimum viable product and then \"full\" varargs with language support might come later and would also enable the same on function pointers?\r\n```csharp\r\n[NativeVarargsAttribute(VarargBeginIndex = 1)]\r\n[DllImport(@\"NativeLibrary.dll\", EntryPoint = \"Varargs\")]\r\nstatic extern void Varargs1(int n, int a);\r\n```\r\n\r\nThat doesn\u0027t sound terrible, but it seems to me like you still have the problem that the user needs to know all overloads they require up front and that in the future you have two technologies to choose from.\r\nAnd at first thought, it seems like something that could equally be handled by `[GeneratedVarargs(new Type[] { typeof(arg0), typeof(arg1) })]` on the method that has `GeneratedDllImport` for the `__arglist` case.\r\n\r\nThe only unique issues to `...` (at least that I\u0027m seeing) is that:\r\n* if a user publicly exports it (or calls a manual pinvoke without a source generator), what do you do when they pass in `string` or other non-blittable parameters\r\n* can the language commit to supporting `__arglist`, `...`, or some other new keyword syntax within the required timeframe\r\n\r\nIt would seem like the MVP would be to just block the first scenario and ask C# on the second (and fallback to something different if C# can\u0027t commit).\r\nRequiring users to pass blittable parameters for `...` and to use one of the source generator attributes otherwise seems reasonable for an MVP. If that scenario is very important, it could be unblocked in the future.\r\nThen it is functionally no different than the original proposal, including in generating the fixed signatures up front based on the overloads the user indicates they desire, just using the same thing that eventually becomes \"full support\".\r\nHowever, it does enable automatic generation of those fixed signatures in the case the export is not public and also enables power users to explicitly pass in blittable parameters if that is preferred instead.",
                                           "updatedAt":  "2021-02-26T03:55:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjQwMDE2Nw==",
                                           "createdAt":  "2021-02-26T04:17:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sdmaclea",
                                           "body":  "@AaronRobinsonMSFT Instead of adding `NativeVarargsAttribute` could we add a new optional parameter to `DllImport` which did the same thing.  Might have a default not varargs value by default.",
                                           "updatedAt":  "2021-02-26T04:17:26Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjQwNjQ4Mg==",
                                           "createdAt":  "2021-02-26T04:40:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBheXZg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkoritzinsky",
                                                                               "createdAt":  "2021-02-26T05:32:47Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "`DllImport` is a pseudo-custom attribute. It has special non-extensible encoding in metadata (extending the encoding would be file format breaking change.)\r\n\r\nI have been thinking about what would be a design that works for both DllImport and function pointers, without language changes. The simplest design that I was able to come up with is a marker type for start of vararg arguments:\r\n\r\n```\r\npublic struct VarArgSentinel\r\n{\r\n}\r\n```\r\nExample of use:\r\n```\r\n[DllImport(\"msvcrt\")]\r\npublic static extern printf(sbyte* format, VarArgSentinel dummy, int arg1, int arg2);\r\n```",
                                           "updatedAt":  "2021-02-26T04:41:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjQxMzU2NQ==",
                                           "createdAt":  "2021-02-26T05:05:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBnafjw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2021-02-26T05:17:40Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkoritzinsky",
                                                                               "createdAt":  "2021-02-26T05:33:04Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "saucecontrol",
                                                                               "createdAt":  "2021-02-26T05:45:43Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "reflectronic",
                                                                               "createdAt":  "2021-02-26T11:33:20Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "filipnavara",
                                                                               "createdAt":  "2021-02-26T13:40:27Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "PathogenDavid",
                                                                               "createdAt":  "2021-04-16T03:36:19Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  6
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "I had a bit of a chat with Aaron in teams and he suggested I explicitly iterate that my concern here is that we already have `varargs` today specified by ECMA-335 for both managed and native (and function pointers) and so I don\u0027t see the driving need to expose something additional that is basically that, but in many ways covers less (and would likely eventually be added to the spec if we ever rev it). I\u0027d have less concern if this attribute or the `VarArgSentinel` just proposed was recognized by C# and just treated as the `vararg` bit (just like `__arglist` is today): https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA0AXEBLANgHwAEAGAAkIEYA6AJQFcA7DbAWxioEkmYoIAHAMo8AbtjAwAzgG4AsAChCAZnIAmUgGFSAb3mk95ZYRSkAsgAoAlNoC+u/Xb1Lyx8wH1XAQygBzXNgkYVlq2cvqkDqQA2gAiuLgcLHzQGGYARH7AqRYAuhFOlEikMAgYPAzOpABylrKh9nV6MXEJSVAp6diZOXmGFIXFpVDlRlVm7l6+/oG11kA\r\n\r\nIf `__arglist` wasn\u0027t an implementation defined keyword, I don\u0027t think there would even be a discussion here and so if asking Jared/Mads if making `__arglist` official or adding `...` or a new contextual keyword is feasible (even if only for P/Invokes), that seems like goodness to me.",
                                           "updatedAt":  "2021-02-26T05:05:18Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjQxODU2NQ==",
                                           "createdAt":  "2021-02-26T05:21:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e@AaronRobinsonMSFT Instead of adding NativeVarargsAttribute could we add a new optional parameter to DllImport which did the same thing. Might have a default not varargs value by default.\r\n\r\n@sdmaclea Yeah.. I would love that. It is a nice idea, but as @jkotas mentioned `DllImport` isn\u0027t what anyone thinks it is.\r\n",
                                           "updatedAt":  "2021-02-26T05:21:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjQzNDUwMw==",
                                           "createdAt":  "2021-02-26T06:06:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBhegRA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2021-02-26T06:09:27Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e If __arglist wasn\u0027t an implementation defined keyword, I don\u0027t think there would even be a discussion her\r\n\r\nI agree that we would not have this discussion if varargs were a first class citizen in .NET. \r\n\r\nManaged varargs are similar to remoting. Both are mentioned in ECMA, both have been neglected features with many gaps since .NET Framework 1.0, expensive to port, and omitted from .NET Core originally. The only difference is that we were forced to bring varargs in in limited fashion on Windows for managed C++ compatibility.\r\n\r\nI think we should either agree that it is valuable to make varargs first class citizen in modern .NET; or to do the simplest cheapest solution that makes it possible to call varargs method in platform neutral way. Going halfway does not seem useful.",
                                           "updatedAt":  "2021-02-26T06:06:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjYyMjk4MA==",
                                           "createdAt":  "2021-02-26T12:38:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODeOnZg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "filipnavara",
                                                                               "createdAt":  "2021-02-26T13:42:20Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "filipnavara",
                                                                               "createdAt":  "2021-02-26T13:42:23Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alexrp",
                                                                               "createdAt":  "2024-04-15T17:15:42Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "My view here is that `varargs` should get proper support in .NET, even if in an iterative fashion with the MVP for .NET 6 extending what ECMA-335 already supports and specifies.\r\n\r\nMy reasoning is that `varargs` is a part of the ABI, the C language, and the C standard library and is therefore on all platforms .NET will ever run on. It is a fundamental part of the ecosystem that is not going anywhere and will, without a doubt, be supported in any new platforms that exist in the future. It is not restricted to legacy code and is not restricted to only scenarios such as `printf` where the need for interop is \"low\". Additionally, searching for users asks about varargs shows continued interest going back to when we first made .NET cross platform.\r\n\r\nMany major languages have support for varargs (most often via the `...` syntax), particularly when it comes to their mechanism for interop with C. C#/.NET is one of the few where the only support is via their own thing (`params T[]`). Languages with `varargs` support include:\r\n* C\r\n* C++\r\n* Go\r\n* Java\r\n* Javascript\r\n* ObjC\r\n* Python\r\n* Rust\r\n* Swift\r\n* etc\r\n\r\nIn some cases, `varargs` is a fundamental requirement for interop with languages other than C. For example, many of the core APIs exposed for ObjC (such as `objc_msgsend`) require `varargs` to be able to interact with it.\r\nGiven that the other languages also have `varargs` support, there are also potential scenarios where it is required to interact with parts of them as well.\r\n\r\nTo me, this all points to a world where we should be taking the existing `varargs` support and making it first class starting with a minimum viable product that may involve only allowing it in P/Invoke scenarios.",
                                           "updatedAt":  "2021-02-26T12:41:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjYzMTM4NQ==",
                                           "createdAt":  "2021-02-26T12:55:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "In addition to the above, there are clear benefits to proper `varargs` support; such as reduced metadata bloat and decreased surface area for AOT scenarios.\r\n\r\n`varargs` is like generics in that you can have a single metadata signature to support many code patterns. It is unlike generics in that it does not require generic explosion at runtime or during AOT.\r\nHowever, not properly supporting `varargs` means there is an explosion to specify every concrete combination that needs to be supported which increases metadata cost and inevitably the surface area for crossgen, AOT, and even just raw IL.\r\n\r\nThere will likely be some of this \"explosion\" in either scenario due to the need for an object oriented wrapper type (such as for ObjC types), but there is still the difference of a single `objc_msgsend` P/Invoke vs many separate P/Invokes that these wrappers ultimately call.",
                                           "updatedAt":  "2021-02-26T12:57:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjY1OTc3NA==",
                                           "createdAt":  "2021-02-26T13:51:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBhoF3w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "filipnavara",
                                                                               "createdAt":  "2021-02-27T21:47:49Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Languages with varargs support include:\r\n\r\nNumber of the languages in your list do not have first class interop support and they represent varargs internally as array or array-like type that is more similar to C# params keyword.\r\n\r\nFor example, Java https://docs.oracle.com/javase/8/docs/technotes/guides/language/varargs.html : multiple arguments must be passed in an array, but the varargs feature automates and hides the process.\r\n\r\n\u003e  many of the core APIs exposed for ObjC (such as objc_msgsend) require varargs to be able to interact with it.\r\n\r\nvarargs interop does not help with objc_msgsend in general. objc_msgsend uses regular calling convention and you have to [manually specify each shape](https://docs.microsoft.com/en-us/xamarin/ios/internals/objective-c-selectors). It would only help if the target method has literal vararg in the signature. Is there such method in Apple OS APIs?\r\n\r\n\u003e decreased surface area for AOT scenarios.\r\n\r\nvarargs interop is problematic for AOT. ngen/crossgen never fully supported precompiling varargs interop. As you have said, it has similar problem as generics where one metadata item expands to many pieces of code. A whole program analysis is required to find the full set. Fully support AOTing varargs interop requires building a system similar to a system to precompile generics.",
                                           "updatedAt":  "2021-02-26T13:53:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjY1OTgxNw==",
                                           "createdAt":  "2021-02-26T13:51:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "filipnavara",
                                           "body":  "\u003e ...but there is still the difference of a single objc_msgsend P/Invoke vs many separate P/Invokes that these wrappers ultimately call.\r\n\r\nI\u0027d like to reiterate what I stated in the Apple Silicon issue. The problem is not necessary the \"explosion\" caused by having one variation per parameter types. That had been the status quo for Xamarin ObjC interop, or the SQLite wrappers for ages. All the possible prototypes were either manually written (SQLite) or automatically generated (Xamarin). The issue is that with introduction of Apple Silicon the approach no longer works since the current workaround doubles the number of prototypes in this \"explosion\" if you have to account for the different ABIs (eg. x64 passes through registers with reserved stack space and overflow to stack for more parameters; M1 passes all VA on stack, so you have to round to 8 \"dummy\" parameters that occupy the registers and then let the rest overflow to stack to simulate the VA layout).\r\n\r\nFWIW I\u0027d be perfectly happy with having `__arglist` back, even if MVP means supporting it only for P/Invoke scenarios.",
                                           "updatedAt":  "2021-02-26T14:22:40Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjY2MTQ5OQ==",
                                           "createdAt":  "2021-02-26T13:54:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "filipnavara",
                                           "body":  "\u003e varargs interop does not help with objc_msgsend in general. objc_msgsend uses regular calling and you have to manually specify each shape. It would only help if the target method has literal vararg in the signature. Is there such method in Apple OS APIs?\r\n\r\nThe current approach to `objc_msgSend` is driven by the lack of `varargs` interop. The native method uses varargs (https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend).",
                                           "updatedAt":  "2021-02-26T13:54:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjY2NzUzMw==",
                                           "createdAt":  "2021-02-26T14:05:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBhoF8g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2021-02-26T18:08:29Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "filipnavara",
                                                                               "createdAt":  "2021-02-27T21:48:17Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e The current approach to objc_msgSend is driven by the lack of varargs interop. The native method uses varargs\r\n\r\nThe native `objc_msgSend` takes variable number of arguments, but it is not the same mechanism as C vararg. If you define `objc_msgSend` as C method with `...`, it won\u0027t work. \r\n\r\nI went through the list of languages in @tannergooding list. I did not find any languages except C/C++ where C-like varargs are first class citizen (happy to be corrected if I missed anything). Varargs are either shortcut for array or array-like argument passing and/or one-off for interop.",
                                           "updatedAt":  "2021-02-26T14:05:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjY2OTA3Ng==",
                                           "createdAt":  "2021-02-26T14:08:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "filipnavara",
                                           "body":  "\u003e The native objc_msgSend takes variable number of arguments, but it is not the same mechanism as C vararg. If you define objc_msgSend as C method with ..., it won\u0027t work.\r\n\r\nYou could be right on this one, but the C headers do use `...` in there:\r\n\r\nhttps://github.com/phracker/MacOSX-SDKs/blob/ef9fe35d5691b6dd383c8c46d867a499817a01b6/MacOSX10.14.sdk/usr/include/objc/message.h#L84-L86\r\n\r\nUpdate: I am an idiot here reading the `#if !OBJC_OLD_DISPATCH_PROTOTYPES` the other way around. The variadic prototypes would work on x64 for some cases due to how the ABI is implemented but it doesn\u0027t quite work with the ARM64 ABI or more complex calls (eg. floating point parameters).",
                                           "updatedAt":  "2021-02-27T21:49:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjY2OTk5NA==",
                                           "createdAt":  "2021-02-26T14:10:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e Varargs are either shortcut for array or array-like argument passing and/or one-off for interop.\r\n\r\nYes, on the non-interop side these are frequently represented in a slightly better construct (such as `params T[]` in C#) but in almost all cases they use `...` and are largely equivalent to proper varargs from the author\u0027s perspective.\r\n\r\n\u003e For example, Java https://docs.oracle.com/javase/8/docs/technotes/guides/language/varargs.html : multiple arguments must be passed in an array, but the varargs feature automates and hides the process.\r\n\r\nHowever, JNA/JNI have explicit support for handling this as `varargs` in terms of P/Invoke and from the perspective of pure Java code it is `varargs`, not many separate concrete definitions.\r\n\r\n\u003e The native method uses varargs (https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend).\r\n\r\nFor reference, `include\\objc\\message.h` has:\r\n```cpp\r\n#if !OBJC_OLD_DISPATCH_PROTOTYPES\r\n#pragma clang diagnostic push\r\n#pragma clang diagnostic ignored \"-Wincompatible-library-redeclaration\"\r\nOBJC_EXPORT void\r\nobjc_msgSend(void /* id self, SEL op, ... */ )\r\n    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);\r\n\r\nOBJC_EXPORT void\r\nobjc_msgSendSuper(void /* struct objc_super *super, SEL op, ... */ )\r\n    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);\r\n#pragma clang diagnostic pop\r\n#else\r\nOBJC_EXPORT id _Nullable\r\nobjc_msgSend(id _Nullable self, SEL _Nonnull op, ...)\r\n    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);\r\n\r\nOBJC_EXPORT id _Nullable\r\nobjc_msgSendSuper(struct objc_super * _Nonnull super, SEL _Nonnull op, ...)\r\n    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);\r\n#endif\r\n```\r\n\r\nLikewise, `objc-api.h` has:\r\n```cpp\r\n/* OBJC_OLD_DISPATCH_PROTOTYPES == 0 enforces the rule that the dispatch \r\n * functions must be cast to an appropriate function pointer type. */\r\n#if !defined(OBJC_OLD_DISPATCH_PROTOTYPES)\r\n#   if __swift__\r\n        // Existing Swift code expects IMP to be Comparable.\r\n        // Variadic IMP is comparable via OpaquePointer; non-variadic IMP isn\u0027t.\r\n#       define OBJC_OLD_DISPATCH_PROTOTYPES 1\r\n#   else\r\n#       define OBJC_OLD_DISPATCH_PROTOTYPES 0\r\n#   endif\r\n#endif\r\n```",
                                           "updatedAt":  "2021-02-26T14:10:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjY4MTgxMQ==",
                                           "createdAt":  "2021-02-26T14:31:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "I don\u0027t think that giving `varargs` \"first class\" support means that it will become the new standard for code or even recommended for use outside of P/Invoke scenarios.\r\nI think its primary use will be P/Invoke (via `DllImport` and `function pointers`), that there may eventually need to be Reverse P/Invoke support (or at least `UnmanagedCallersOnly` support), and that there may be some performance oriented scenarios for power users or internal methods that allow allocations to be avoided.\r\n\r\nI also believe that the benefits of having a single metadata definition is clear and that it provides a more correct, maintainable, and functional mapping to the underlying code than concrete signatures.\r\n\r\nIn the majority of the languages I listed, this is done via the C `varargs` ABI because that is what is used by `C` and `C` is the common interface between most languages.\r\nThis is true for `imports` (calling an exported C varargs method from that language) and often for `exports` as well (calling an exported method for that language from C).\r\n\r\nPython is another example where some of the core runtime functions used for interop between it and C use `varargs`: https://docs.python.org/3/extending/extending.html#calling-python-functions-from-c, https://docs.python.org/3/c-api/arg.html#c.PyArg_Parse, etc",
                                           "updatedAt":  "2021-02-26T14:32:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjY5MDg5MQ==",
                                           "createdAt":  "2021-02-26T14:46:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBhmecg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MichalStrehovsky",
                                                                               "createdAt":  "2021-02-26T15:11:21Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2021-02-26T18:09:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "lambdageek",
                                                                               "createdAt":  "2021-02-27T02:37:01Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e I think its primary use will be P/Invoke (via DllImport and function pointers),\r\n\r\nYep, I agree that it is best to think about this as one-off for interop and not as a first class construct used everywhere.\r\n\r\n\u003e there may eventually need to be Reverse P/Invoke support\r\n\r\nReverse P/Invoke support for varargs never existed (you cannot define vararg delegate in C#). I do not remember it ever showing up on the radar as a feature request.\r\n\r\n\u003e  a single metadata definition is clear and that it provides a more correct, maintainable, and functional mapping to the underlying code than concrete signatures.\r\n\r\nI see a single metadata definition for C varargs interop as pain to deal with. It has to be special-cased everywhere.",
                                           "updatedAt":  "2021-02-26T14:46:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjY5ODU3Mg==",
                                           "createdAt":  "2021-02-26T14:59:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "webczat",
                                           "body":  "what about the experiments with dllexport? one could have a need to make a c-compatible varargs method that is dllexported. outside of that, callbacks/etc rather don\u0027t have varargs, they at most have some void* userdata pointer, at least those I\u0027ve seen. or similar mechanisms. And this discussion makes me wonder if some way to pass va_list would also be considered even in the case of not reusing/properly implementing dotnet\u0027s varargs support from ecma335?",
                                           "updatedAt":  "2021-02-26T14:59:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NjcwMzYyNA==",
                                           "createdAt":  "2021-02-26T15:07:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e I see a single metadata definition for C varargs interop as pain to deal with. It has to be special-cased everywhere.\r\n\r\nI have the opposite opinion. I see it as something that eases the maintenance burden on P/Invoke generators, reduces metadata bloat, is well understood by the developers who will be using the feature, is already used by C++/CLI, and likely integrates well with what we already have today (minus the missing \"official\" language keyword for C# where seeing if `__arglist` can just become the official keyword seems like a good compromise between \"existing\" and \"future, primarily limited to P/Invoke and power user scenarios\").\r\n\r\nFrom the perspective of a P/Invoke generator, it can process a header exactly 1-to-1.\r\nNew initiatives like `win32metadata` (which will never know the concrete signatures required) can simply define the export once and have it understood by downstream tooling.\r\nSource generators like `CsWin32` (which may know the concrete signatures required and which uses `win32metadata`) have a single method to interact with and can define concrete wrappers over that which do the pinning, marshaling, and calling of the single P/Invoke.\r\nOther generators like `ClangSharp` (which is used by `win32metadata`) can provide a single reusable export for power users or user-defined wrappers where appropriate\r\n\r\nThe work to support `varargs` at the ABI level should largely be the same for both approaches.\r\nThe existing `varargs` support for Windows has to stay for back-compat.\r\nThe logic for checking if parameters are blittable or not already exists in the marshaller and is already used to block certain P/Invoke scenarios.\r\nThe logic for handling the existing `varargs` bit already exists, but is simply blocked on Unix and would be unblocked once the ABI support is added.\r\nThe language is already wired up to emit the `varargs` bit for scenarios like P/Invoke, it just doesn\u0027t have an official keyword.\r\nThe framework already has a type (`System.ArgIterator`) for getting and interacting with `varargs` parameters",
                                           "updatedAt":  "2021-02-26T15:09:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4Njg4ODAzNg==",
                                           "createdAt":  "2021-02-26T20:52:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lambdageek",
                                           "body":  "\u003e ```\r\n\u003e    [DllImport(\"msvcrt\")]\r\n\u003e    public static extern printf(sbyte* format, VarArgSentinel dummy, int arg1, int arg2);\r\n\u003e ```\r\n\r\n@jkotas  why does it need to be a real argument, not an attribute on an existing arg? \r\n```\r\n[DllImport(\"msvcrt\")]\r\npublic static extern printf (sbyte* format, [VarArgStart] int arg1, int arg2);\r\n```\r\n\r\n(also doesn\u0027t using a dummy parameter mean callers have to pass a dummy value for the argument? otherwise I don\u0027t see how this could be done without a language change)",
                                           "updatedAt":  "2021-02-26T20:52:35Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4Njg5MDAyMQ==",
                                           "createdAt":  "2021-02-26T20:57:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBhmeYA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "lambdageek",
                                                                               "createdAt":  "2021-02-27T02:36:30Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e @jkotas why does it need to be a real argument, not an attribute on an existing arg?\r\n\r\nYou cannot have attributes on arguments in function pointers. (As I have said, my goal with this one was to make vararg interop possible for both DllImport and function pointers, without language changes.)\r\n\r\n\u003e  doesn\u0027t using a dummy parameter mean callers have to pass a dummy value for the argument?\r\n\r\nYes, that\u0027s correct. Callers would have to pass a dummy parameter.",
                                           "updatedAt":  "2021-02-26T20:57:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NzcwMjE1MQ==",
                                           "createdAt":  "2021-03-01T06:57:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rolfbjarne",
                                           "body":  "@jkotas \r\n\r\n\u003e It would only help if the target method has literal vararg in the signature. Is there such method in Apple OS APIs?\r\n\r\nYes, here\u0027s an example (they aren\u0027t very common, but they do show up in a few API, some quite important like this one): https://developer.apple.com/documentation/foundation/nsstring/1497301-localizedstringwithformat\r\n\r\nand here\u0027s how we\u0027ve had to bind it due to the lack of varargs:\r\n\r\nhttps://github.com/xamarin/xamarin-macios/blob/effe7dc49986bdafeb3e8c72c8e907908095c7b9/src/Foundation/NSString.cs#L254-L280\r\n",
                                           "updatedAt":  "2021-03-01T06:57:21Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NzcxOTQyOQ==",
                                           "createdAt":  "2021-03-01T07:26:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e https://github.com/xamarin/xamarin-macios/blob/effe7dc49986bdafeb3e8c72c8e907908095c7b9/src/Foundation/NSString.cs#L254-L280\r\n\r\nDoes this work on Apple ARM64 OSes? If it does, the method is not actually using vararg calling convention. It has variable number of arguments, but the arguments are not passed using vararg calling convention, so adding support for vararg calling convention would not help.",
                                           "updatedAt":  "2021-03-01T07:28:53Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NzcyNzM3MA==",
                                           "createdAt":  "2021-03-01T07:39:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBhsQVg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2021-03-01T07:43:12Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "filipnavara",
                                                                               "createdAt":  "2021-03-01T08:28:27Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "rolfbjarne",
                                           "body":  "\u003e \u003e https://github.com/xamarin/xamarin-macios/blob/effe7dc49986bdafeb3e8c72c8e907908095c7b9/src/Foundation/NSString.cs#L254-L280\r\n\u003e \r\n\u003e Does this work on Apple ARM64 OSes? If it does, the method is not actually using vararg calling convention. It has variable number of arguments, but the arguments are not passed using vararg calling convention, so adding support for vararg calling convention would not help.\r\n\r\nThe managed code calls our own native functions (without varargs), which call Apple\u0027s API (with varargs): https://github.com/xamarin/xamarin-macios/blob/effe7dc49986bdafeb3e8c72c8e907908095c7b9/runtime/nsstring-localization.m#L22-L82\r\n\r\nHere\u0027s an example of where we call Apple\u0027s API with varargs directly from managed code: https://github.com/xamarin/xamarin-macios/blob/effe7dc49986bdafeb3e8c72c8e907908095c7b9/src/UIKit/UIAppearance.cs#L134-L163",
                                           "updatedAt":  "2021-03-01T07:39:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc5ODI5NDc2OQ==",
                                           "createdAt":  "2021-03-13T12:32:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBjViUA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "filipnavara",
                                                                               "createdAt":  "2021-03-13T13:02:48Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "vargaz",
                                           "body":  "Not sure if anyone mentioned it above, but the .net spec has a \u0027Sentinel\u0027 bit in method signatures used to mark where the ... arguments begin, so the c# compiler could emit this.\r\n",
                                           "updatedAt":  "2021-03-13T12:32:54Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc5ODM0MTYyOQ==",
                                           "createdAt":  "2021-03-13T13:03:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "filipnavara",
                                           "body":  "For reference, the bit @vargaz talks about is section I.8.6.1.5 in ECMA-335 specification:\r\n\r\nMethod signatures are declared by method definitions. Only one constraint can be added to a \r\nmethod signature in addition to those of parameter signatures: \r\n\r\n- The vararg constraint can be included to indicate that all arguments past this point are \r\noptional. When it appears, the calling convention shall be one that supports variable \r\nargument lists.\r\n\r\nMethod signatures are used in two different ways: as part of a method definition and as a \r\ndescription of a calling site when calling through a function pointer. In the latter case, the method \r\nsignature indicates \r\n- the calling convention (which can include platform-specific calling conventions), \r\n- the types of all the argument values that are being passed, and \r\n- if needed, a vararg marker indicating where the fixed parameter list ends and the \r\nvariable parameter list begins.\r\n\r\nWhen used as part of a method definition, the vararg constraint is represented by the choice of \r\ncalling convention.",
                                           "updatedAt":  "2021-03-13T13:10:55Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg3MDk3NTIxNA==",
                                           "createdAt":  "2021-06-29T23:06:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "With the introduction of https://github.com/dotnet/runtime/issues/51156 this proposal becomes less interesting. It should be replaced with a `CallConv*` type instead.",
                                           "updatedAt":  "2021-06-29T23:06:08Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg3OTAzOTIwNw==",
                                           "createdAt":  "2021-07-13T12:19:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "filipnavara",
                                           "body":  "How does the proposal in #51156 address the scenario? I fail to see it and there is no example in the linked issue.",
                                           "updatedAt":  "2021-07-13T12:19:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc40wlIz",
                                           "createdAt":  "2021-07-22T18:46:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "@filipnavara This proposal is about an attribute for Native Varargs - that approach isn\u0027t a good idea because we can instead use the `UnmanagedCalleeAttribute` which takes a type that indicates multiple calling convention modifiers. The concern is best described in  https://github.com/dotnet/runtime/issues/48796#issuecomment-786362375. As mentioned in my comment the correct replacement for this issue is to follow it up with a `CallConv*` type or perhaps enable the `__arglist` keyword but adding a new attribute is not the correct approach. Feel free to create a new issue if a tracking issue for that is needed.",
                                           "updatedAt":  "2021-07-22T18:46:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc40wljs",
                                           "createdAt":  "2021-07-22T18:49:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "filipnavara",
                                           "body":  "How do you use `UnmanagedCalleeAttribute` to specify where the fixed args end and the varargs start?",
                                           "updatedAt":  "2021-07-22T18:49:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc40woxK",
                                           "createdAt":  "2021-07-22T19:10:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003eHow do you use UnmanagedCalleeAttribute to specify where the fixed args end and the varargs start?\r\n\r\nThat is a UX question we would need to work through but I am not sure that is needed based on a previous conversation - which I may be misremembering. The gist was regardless of where the fixed args or varargs exist the way they are passed is the same for a native varargs signature - I could be misremembering the conversation but that is what I recall. There is also the more fundamental UX question of do we want to support arbitrary native vararg signatures in C# or do we require people to fully specify each signature for each use case. I don\u0027t know the answer to that but this proposal as written isn\u0027t something I think we should do and as the author I felt it should be closed to avoid confusing it as a well-thought out proposal - which in its current form it is not.",
                                           "updatedAt":  "2021-07-22T19:10:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc40wsf4",
                                           "createdAt":  "2021-07-22T19:35:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "filipnavara",
                                           "body":  "\u003e That is a UX question we would need to work through but I am not sure that is needed based on a previous conversation - which I may be misremembering. The gist was regardless of where the fixed args or varargs exist the way they are passed is the same for a native varargs signature - I could be misremembering the conversation but that is what I recall.\r\n\r\nOn x64 you don\u0027t need the information. On arm64 you do, varargs always go to stack, up to 8 fixed args go to registers. You pointed out in the other issue (#51156) that it replaces this proposal but it left out this fundamental issue which was the driving impetus for this proposal and the user scenarios in #48752.\r\n\r\nThe `UnmanagedCalleeAttribute` does not address this problem in any way as far as I can see it and thus it felt flat to just close the proposal with no alternative. There was just a brief mention that it would address varargs too but it didn\u0027t actually address the user scenario or the problem that is address with the attribute in this API proposal.\r\n\r\nThere doesn\u0027t seem to be any mechanism in `UnmanagedCalleeAttribute` to pass the varargs start position and it\u0027s not obvious how would it fit in.\r\n\r\n\u003e There is also the more fundamental UX question of do we want to support arbitrary native vararg signatures in C# or do we require people to fully specify each signature for each use case. \r\n\r\nTrue. That\u0027s also why I think all the discussion here is really valuable because it focused on various reasons why one or the other approach may work in different scenarios (such as NativeAOT).\r\n\r\nThe reality is that binding libraries now have to manually craft each prototype for all possible varargs combinations if they want to work cross-platform. That doubles with additional logic if ARM64 comes into play. `__arglist` is currently supported only on Windows and it\u0027s problematic for AOT scenarios, as stated in the discussion above.\r\n\r\n\u003e I don\u0027t know the answer to that but this proposal as written isn\u0027t something I think we should do and as the author I felt it should be closed to avoid confusing it as a well-thought out proposal - which in its current form it is not.\r\n\r\nFair. However, there was a lot of valuable discussion here in the issue. There\u0027s currently some of the user-side of the problem covered in #48752 but lot of the technical details ended up being discussed here instead. #51156 didn\u0027t address the ARM64 varargs problem in any way nor did it suggest how it could help address it.\r\n\r\n\r\n",
                                           "updatedAt":  "2021-07-22T19:35:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc40wtTC",
                                           "createdAt":  "2021-07-22T19:41:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "filipnavara",
                                           "body":  "Honestly, I think this should stay open with `api-needs-work` tag and explanation of why the approach in the original proposal is not good. Just my $0.02.",
                                           "updatedAt":  "2021-07-22T19:41:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Axvt5",
                                           "createdAt":  "2022-04-03T05:53:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODLtlvw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "CONFUSED",
                                                                               "user":  "LimpingNinja",
                                                                               "createdAt":  "2023-11-03T02:04:14Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "frindler",
                                           "body":  "Is there any progress on supporting varargs in P/Invoke\u0027d native libs? I just patched the padding for varargs to the 9th argument position into Libgit2sharp on OS X arm64, but there should be way to do this without this hack... (which may break again in the future)",
                                           "updatedAt":  "2022-04-03T05:53:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Iyg7I",
                                           "createdAt":  "2022-08-20T01:37:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODiD7HA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "simplexidev",
                                                                               "createdAt":  "2022-08-20T02:49:51Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "mveril",
                                                                               "createdAt":  "2022-09-11T22:01:38Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "workgroupengineering",
                                                                               "createdAt":  "2022-10-03T09:23:59Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "TheLastRar",
                                                                               "createdAt":  "2023-06-17T16:17:33Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Nils12345678901234567",
                                                                               "createdAt":  "2024-05-16T14:30:13Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  5
                                                         },
                                           "author":  "jgcodes2020",
                                           "body":  "Just my two cents:\r\n\r\nC#, F#, and VB.Net all have a feature where variadic arguments can be passed via a specially marked array parameter at the end. Coupled with an attribute to identify it, perhaps you could have:\r\n\r\n```cs\r\n[DllImport(\"libc.so\", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]\r\npublic static extern void printf(string format, \r\n  [MarshalAs(UnmanagedType.VariableArguments)] params object[] args)\r\n```",
                                           "updatedAt":  "2022-08-20T01:37:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Iy13l",
                                           "createdAt":  "2022-08-20T10:42:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODLtlxA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ForNeVeR",
                                                                               "createdAt":  "2022-08-20T12:16:16Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "simplexidev",
                                                                               "createdAt":  "2022-08-20T22:28:51Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jeremyVignelles",
                                                                               "createdAt":  "2022-08-21T07:57:57Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "LimpingNinja",
                                                                               "createdAt":  "2023-11-03T02:04:25Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "webczat",
                                           "body":  "This would probably add overhead which is often not necessary, and \nthat\u0027s probably not the only problem with that.\n\nW dniu 20.08.2022 o 03:38, jgcodes2020 pisze:\n\u003e\n\u003e Just my two cents:\n\u003e\n\u003e C#, F#, and VB.Net all have a feature where variadic arguments can be \n\u003e passed via a specially marked array parameter at the end. Coupled with \n\u003e an attribute to identify it, perhaps you could have:\n\u003e\n\u003e [DllImport(\"libc.so\",CallingConvention  =  CallingConvention.Cdecl,CharSet  =  CharSet.Ansi)]\n\u003e public  static  extern  void  printf(string  format,\n\u003e    [MarshalAs(UnmanagedType.VariableArguments)]params  object[]args)\n\u003e\n\u003e —\n\u003e Reply to this email directly, view it on GitHub \n\u003e \u003chttps://nam12.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Fdotnet%2Fruntime%2Fissues%2F48796%23issuecomment-1221201608\u0026data=05%7C01%7C%7C492e82455ea444aada6008da824c9f96%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C637965562844949661%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C\u0026sdata=P2ymAQ2eBHRnqz96zHdOOzopOw1mlM8DU2KXLlE4Z1Y%3D\u0026reserved=0\u003e, \n\u003e or unsubscribe \n\u003e \u003chttps://nam12.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Fnotifications%2Funsubscribe-auth%2FAANTEOWG72KLBJFMZ6EUKCTV2AZHVANCNFSM4YHRUSTQ\u0026data=05%7C01%7C%7C492e82455ea444aada6008da824c9f96%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C637965562844949661%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C\u0026sdata=TBl7qy3WFKCTumZmhmKTvwCvIVi9AU3nGxCFaVj4XwQ%3D\u0026reserved=0\u003e.\n\u003e You are receiving this because you commented.Message ID: \n\u003e ***@***.***\u003e\n\u003e",
                                           "updatedAt":  "2022-08-20T10:42:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5fHWtq",
                                           "createdAt":  "2023-06-17T13:41:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEDszZg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "frindler",
                                                                               "createdAt":  "2023-06-17T15:23:19Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Nils12345678901234567",
                                                                               "createdAt":  "2024-05-16T14:32:30Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jwosty",
                                                                               "createdAt":  "2024-08-20T17:56:17Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "BCSharp",
                                                                               "createdAt":  "2025-01-23T06:42:21Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "TomEdwardsEnscape",
                                           "body":  "When I read through the history of this issue, I can see a clear case of perfect becoming the enemy of good. Attempts to support declaring variadic parameters in metadata have soaked up time and energy that could have been spent supporting variadic methods on Mac and Linux _at all_.\r\n\r\nI came across this problem when wrapping Apple\u0027s [`objc_msgSend`](https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend), which is one of those \"it does everything\" methods through which a huge number of unrelated calls are routed. (It\u0027s usually unwise to write such a method, but I\u0027ll give Apple a pass in this case since it\u0027s part of the Objective-C runtime and there is supposed to be an entire compiled language sat on top of it.)\r\n\r\nEven if we could write a delegate and specify its variadic parameters, we don\u0027t want to because there are so many different ways to call `objc_msgSend`. Many are unique, at least within the set of methods/properties that we want to use.\r\n\r\n`__arglist` is already the perfect solution for our needs. We don\u0027t care that it\u0027s slower than theoretical alternatives and not type safe. We just want to wrap this one specific call, pass it the appropriate arguments, then move on.\r\n\r\nHere is a trimmed version of the code that I would like to write:\r\n\r\n```C#\r\npublic class NSRunningApplication : NSObject\r\n{\r\n    // 1. Define a variadic native method\r\n    [DllImport(\"/System/Library/Frameworks/AppKit.framework/AppKit\")]\r\n    private static extern nint objc_msgSend(nint receiver, nint selector, __arglist);\r\n\r\n    // 2. Pass an __arglist\r\n    public static NSRunningApplication? RunningApplicationWithProcessIdentifier(int pid) =\u003e \r\n        FromPointer(objc_msgSend(Class, RunningApplicationWithProcessIdentifierSelector, __arglist(pid)));\r\n}\r\n```\r\n\r\nAs we well know, this fails at runtime because `__arglist` is only supported on Windows.\r\n\r\nSince we only need a limited number of Objective-C interop calls, we will proceed with the hack of padding the parameter list on Arm64. This is a very poor solution, but at least it avoids having to compile a new native library full of very specific `objc_msgSend` exports for my team\u0027s otherwise 100% managed codebase.",
                                           "updatedAt":  "2023-06-17T17:23:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5fHjv2",
                                           "createdAt":  "2023-06-17T17:51:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODiD9Qw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkoritzinsky",
                                                                               "createdAt":  "2023-06-17T18:25:01Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ForNeVeR",
                                                                               "createdAt":  "2023-06-17T20:12:58Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "Nils12345678901234567",
                                                                               "createdAt":  "2024-05-16T14:33:44Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e `__arglist` is already the perfect solution for our needs.\r\n\r\nIt doesn\u0027t though. The `__arglist` concept is for native variadic arguments - let\u0027s ignore the platform specific nature of it for now. The `objc_msgSend` suite of APIs aren\u0027t native variadic arguments. The original signature did use `...`, which confused many people, but the use of the API was not using \"varargs\" in most cases, but rather the signature of the target function. Thankfully Apple corrected the signature a few years ago and now removes some of this confusion as it is defined as `void objc_msgSend(void)`. @mikeash wrote a great description of it and I recommend it - see [here](https://www.mikeash.com/pyblog/objc_msgsends-new-prototype.html).\r\n\r\nThis means that even if we decided to support `__arglist` as \"varargs\" it wouldn\u0027t help with the `objc_msgSend` example.\r\n\r\nThere are definitely use cases for native varargs and there is interest, but the statement \"I can see a clear case of perfect becoming the enemy of good\" isn\u0027t an accurate description of the nature of it being lower priority. The lower priority is based on the narrow cases where it is is needed - real varargs. There are the `printf` suite of functions but those really have little utility in a .NET application. Yes, there are cases where people do create and want to call Objective-C or C/C++ varargs functions from .NET and we acknowledge the work around is painful, but the interest just hasn\u0027t pushed this to the place where it is prioritized higher.",
                                           "updatedAt":  "2023-06-17T17:51:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5fHsOp",
                                           "createdAt":  "2023-06-17T20:21:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "TomEdwardsEnscape",
                                           "body":  "I see, so `__arglist` implicitly inserts more than just the arguments passed to it? That is indeed not suitable for `objc_msgSend`, and I can also see the problems that could arise should multiple definitions of \"variadic\" exist on the same platform.\r\n\r\nSolving the problem at its root would require something even lower level than `__arglist`, such as a similar keyword that inserted just the memory of the objects passed to it and left further decoration or padding to the delegate author. But this seems like an even bigger ask than the current proposals.\r\n\r\nMy opening statement wasn\u0027t describing the priority of the issue, I entirely understand why it\u0027s low. I was talking about how high-level parameter attributes were discussed for a long time, instead of starting with a low-level solution which unblocks the functionality and then refining/optimising it later. It was a bit frustrating to watch the years tick by.\r\n\r\n(Aside: I\u0027m interested to know how casting `objc_msgSend` works in native C/C++ on Arm64. Do you also have to insert the padding arguments that we see in C#? If not, how does the compiler know to put the arguments onto the stack instead of into registers?)",
                                           "updatedAt":  "2023-06-17T20:24:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5fHtZ0",
                                           "createdAt":  "2023-06-17T20:40:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC-Osng==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ForNeVeR",
                                                                               "createdAt":  "2023-06-18T09:22:24Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e I see, so __arglist implicitly inserts more than just the arguments passed to it?\r\n\r\nIt doesn\u0027t necessarily insert more, rather it instructs the JIT to pass the arguments in a certain way. That way conforms to the MSVC implementation of varargs and specifically how C++/CLI assumes they work. The details of how to pass floating point values via varargs is particularly treacherous on most platforms.\r\n\r\n\u003e Solving the problem at its root would require something even lower level than __arglist, such as a similar keyword that inserted just the memory of the objects passed to it and left further decoration or padding to the delegate author.\r\n\r\nThat is definitely an option. However, the minimum needed is simply to have an indication for the JIT to know to pass the arguments using the varargs calling convention that is appropriate for the current platform - encoding all of that in the JIT is the real cost. There are some differences of opinion on precisely how one might want to do this. One approach is to provide a \"placeholder\" (that is, `__arglist` in C# or `...` in C/C++). Another approach is to adorn the method with a calling convention that indicates to pass the arguments as they would be passed using varargs. The former makes the feature more natural from a language perspective but the latter is easier to express and handle in the runtime. A concrete example is helpful.\r\n\r\nUsing `__arglist`:\r\n```csharp\r\n[DllImport(@\"...\")]\r\nextern static void printf(string fmt, __arglist);\r\n\r\n// Usage:\r\nprintf(\"%d\", 5);\r\nprintf(\"%f\", 3.14);\r\n```\r\n\r\nUse a new attribute:\r\n```csharp\r\n[NativeVarargsAttribute(VarargBeginIndex = 1)]\r\n[DllImport(@\"...\")]\r\nextern static void printf(string fmt, int a);\r\n[NativeVarargsAttribute(VarargBeginIndex = 1)]\r\n[DllImport(@\"...\")]\r\nextern static void printf(string fmt, double a);\r\n\r\n// Usage:\r\nprintf(\"%d\", 5);\r\nprintf(\"%f\", 3.14);\r\n```\r\n\r\n\u003e I\u0027m interested to know how casting objc_msgSend works in native C/C++ on Arm64.\r\n\r\nThat is the agreed upon ABI for varargs.",
                                           "updatedAt":  "2023-06-17T20:47:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5fIckQ",
                                           "createdAt":  "2023-06-18T09:09:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "TomEdwardsEnscape",
                                           "body":  "The attribute-plus-declared-parameters approach is certainly nice. But as I think `objc_msgSend` demonstrates, it\u0027s overly restrictive for some notable real-world use cases. A means to define the arguments at runtime, as `__arglist` already provides, is valuable.\r\n\r\nUnless I misunderstand, the JIT needs to know not just which parts of the method should be variadic, but also which variadic convention should be used. To pose this as a question: does `__arglist` fail on Windows if the target method was compiled using GCC\u0027s `libc`?\r\n\r\nAssuming yes, how about this proposal: multiple keywords, one per supported variadic convention.\r\n\r\n```C#\r\nextern static void printf(string fmt, argList_raw); // just pass as if normal arguments; would work for objc_msgSend\r\nextern static void printf(string fmt, argList_msvc); // alias for the current __arglist\r\nextern static void printf(string fmt, argList_libc); // other conventions added as deemed appropriate\r\n```\r\n\r\nMSVC support is obvious, and I include \"raw\" partly because it\u0027s what I need, but also because it\u0027s the simplest possible convention. Going further with `libc` etc. is up for debate.\r\n\r\nIf it\u0027s not practical to add multiple keywords, then the variadic convention can instead be declared in a method attribute.\r\n\r\nFully-typed signatures can still be achieved by wrapping the extern in a normal C# method:\r\n\r\n```C#\r\n[DllImport(@\"...\")]\r\nextern static void printf(string fmt, argList_msvc);\r\n\r\nstatic void printf(string fmt, double a) =\u003e printf(fmt, argList_msvc(a));\r\n```\r\n\r\nI\u0027m sure this would be slower to execute than an extern decorated with `NativeVarargsAttribute`, but it\u0027s better to have an optimisation problem than a functionality problem. In this particular example the JIT knows exactly which types are being passed, so could in future use that information to optimise the call.\r\n\r\nThe biggest uncertainty I have is this: how _much_ harder it is to support this approach in the runtime, compared to attributes?\r\n\r\n\u003e That is the agreed upon ABI for varargs.\r\n\r\nGood, so that can be hardcoded on Arm64 regardless of the variadic convention in use. One less language feature required!",
                                           "updatedAt":  "2023-06-18T09:09:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5fIxG0",
                                           "createdAt":  "2023-06-18T12:53:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "TheLastRar",
                                           "body":  "It also looks like the new attribute solution wouldn\u0027t handle the situation of reverse p/invoke well. \r\nthe `argList_*` solution  looks at least at a glance better suited for reverse p/invoke,\r\n\r\nHow well does each solution handle a function defined with `va_list` instead of `...`?\r\nI guess you could just have an `[DllImport(@\"va_list\")]` like you have a `[DllImport(@\"...\")]` in the above example,\r\nor maybe a `[MarshalAs(UnmanagedType.VaList)]` instead of a default of `[MarshalAs(UnmanagedType.VariadicArguments)]` on the `argList_*` type.\r\n\r\n",
                                           "updatedAt":  "2023-06-18T12:53:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6LUh4o",
                                           "createdAt":  "2024-09-09T08:06:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEOTjDg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "ldy985",
                                                                               "createdAt":  "2024-09-09T17:08:27Z"
                                                                           },
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "ohroy",
                                                                               "createdAt":  "2024-09-26T07:34:29Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "joelday",
                                                                               "createdAt":  "2025-03-25T15:45:09Z"
                                                                           },
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "joelday",
                                                                               "createdAt":  "2025-03-25T15:45:09Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "EzeAGB",
                                                                               "createdAt":  "2025-04-15T03:24:25Z"
                                                                           },
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "EzeAGB",
                                                                               "createdAt":  "2025-04-15T03:24:26Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  6
                                                         },
                                           "author":  "ohroy",
                                           "body":  "any update ?",
                                           "updatedAt":  "2024-09-09T08:06:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6THUz6",
                                           "createdAt":  "2024-11-11T13:23:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOELXs2Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "joelday",
                                                                               "createdAt":  "2025-03-25T15:29:46Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "am11",
                                           "body":  "Fun fact: on Windows this works (prints `digit: 42, string: dotnet, character: ~, float: 42.420000`) with net8.0:\n\n```c#\nusing System.Runtime.InteropServices;\n\nclass C\n{\n    static void Main() =\u003e\n        printf(\"digit: %d, string: %s, character: %c, float: %f\", __arglist(42, \"dotnet\", \u0027~\u0027, 42.42));\n\n    [DllImport(\"msvcrt\")]\n    static extern int printf(string format, __arglist);\n}\n```\n\nbut top-level statement generates a compilation error: ` Program.cs(6,41): error CS1669: __arglist is not valid in this context`\n```c#\nusing System.Runtime.InteropServices;\n\nprintf(\"digit: %d, string: %s, character: %c, float: %f\", __arglist(42, \"dotnet\", \u0027~\u0027, 42.42));\n\n[DllImport(\"msvcrt\")]\nstatic extern int printf(string format, __arglist); // CS1669\n```",
                                           "updatedAt":  "2024-11-11T13:23:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc65sNEP",
                                           "createdAt":  "2025-07-25T00:07:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "riverar",
                                           "body":  "Just a friendly ping, would be great to see more progress on this. This came up in a chat with a developer trying to use `ioctl` via C# on Apple silicon and running into:\n\n\u003e Unhandled exception. System.InvalidProgramException: Vararg calling convention not supported\n\nCan the .NET team put the [ABI goop](https://developer.apple.com/documentation/xcode/writing-arm64-code-for-apple-platforms#Update-code-that-passes-arguments-to-variadic-functions) in the `case \u0027macOS\u0027:` backing the `__arglist` implementation and defer on decisions around changes to `__arglist` keyword support? (i.e., leave it as unsupported) I think that would be a great start.",
                                           "updatedAt":  "2025-07-25T03:28:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc651dRB",
                                           "createdAt":  "2025-07-25T13:21:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEcE3pw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "riverar",
                                                                               "createdAt":  "2025-07-25T15:31:46Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nxrighthere",
                                                                               "createdAt":  "2025-07-25T21:11:26Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ldy985",
                                                                               "createdAt":  "2025-07-27T16:34:20Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "rubo",
                                           "body":  "@riverar I hit this issue back in the days when I was doing iOS development with Xamarin. There was a pretty valuable [API](https://developer.apple.com/documentation/foundation/nsstring/init(format:locale:arguments:)?language=objc) that wasn\u0027t directly accessible from Xamarin because of this issue, so I wrote my own [bindings](https://github.com/rubo/missinkit/blob/develop/Interop/VariadicArguments/VariadicArgumentList.cs) for it. I took a straightforward approach, which may also work for your case. Note that it works on ARM64 but not x64 so that I [couldn\u0027t run](https://github.com/rubo/missinkit/issues/1) it on iOS simulators but only on real devices.",
                                           "updatedAt":  "2025-07-25T13:21:02Z"
                                       }
                                   ],
                         "totalCount":  67
                     },
        "title":  "Introduce mechanism to indicate arguments are to be marshalled as native varargs",
        "labels":  [
                       "api-needs-work",
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/54297",
        "createdAt":  "2021-06-16T20:34:14Z",
        "number":  54297,
        "author":  "tannergooding",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCCCEMw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "airbreather",
                                            "createdAt":  "2021-11-10T18:59:39Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2021-06-30T03:16:40Z",
        "body":  "#54006 introduced new NativeMemory APIs that wrap `malloc`, `calloc`, `realloc`, and `aligned_alloc`. We should audit existing usages of `Marshal.AllocHGlobal` for cases where it can be safely replaced with `malloc`.\r\n\r\nNotably cases like `StringToPtrHGlobal` do not qualify as they are documented to be a call to `LocalAlloc` on Windows. However, on Unix and in cases where this is not a definitive contract, it should be safe to replace these calls with faster ones to `NativeMemory`.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOM3sVYg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2MzcwMTQ3Mg==",
                                           "createdAt":  "2021-06-18T02:09:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "reflectronic",
                                           "body":  "I\u0027ll take this one.",
                                           "updatedAt":  "2021-06-18T02:09:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2MzcwNDQxOA==",
                                           "createdAt":  "2021-06-18T02:17:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "Thanks reflectronic. Assigned out.",
                                           "updatedAt":  "2021-06-18T02:17:48Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Audit usages of Marshal.AllocHGlobal for ones that can be replaced with NativeMemory.Alloc",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/55144",
        "createdAt":  "2021-07-04T15:31:25Z",
        "number":  55144,
        "author":  "Sergio0694",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCqCPGw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "gerhard17",
                                            "createdAt":  "2022-04-01T09:53:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DaZombieKiller",
                                            "createdAt":  "2022-04-28T17:08:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ProphetLamb",
                                            "createdAt":  "2022-07-05T17:46:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SupinePandora43",
                                            "createdAt":  "2022-08-09T08:14:41Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2022-04-25T18:18:03Z",
        "body":  "## Background and Motivation\r\n\r\nI recently discovered that `[UnmanagedCallersOnly]` isn\u0027t actually supported in generic methods (or methods within a generic type), even though this doesn\u0027t actually seem to be documented in the API docs. Reading from https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.unmanagedcallersonlyattribute (as well as the original [blog post](https://devblogs.microsoft.com/dotnet/improvements-in-native-code-interop-in-net-5-0/)) I only see remarks about the feature being restricted to static methods, only called by native code, and with all params/returns being blittable. I\u0027m not really seeing a limitation here about generic types, and I\u0027m not actually sure why it\u0027s there (was that to simplify the implementation?). My question is: assuming there isn\u0027t some inherent technical limitation that makes it impossible to enable this, couldn\u0027t the restriction be lifted? I\u0027m thinking the VM could just validate the signature at JIT time anyway, and then throw in case a `T` was used as a parameter, and then it was substituted by a non-blittable type. I could see at least the restriction being reduced so that all generic type parameters involved would have to be unmanaged (so that the VM would have to verify that they\u0027re blittable if used at the ABI boundary, but they\u0027d at least be guaranteed not to be ref types, making the thing somewhat less error prone).\r\n\r\nConsider this use case scenario:\r\n\r\n```csharp\r\nunsafe struct IAction\u003cT\u003e\r\n    where T : unmanaged\r\n{\r\n    // NOTE: simplified code just to illustrate the [UnmanagedCallersOnly] limitation.\r\n\r\n    public void** lpVtbl;\r\n    public GCHandle handle;\r\n    public T state;\r\n\r\n    [UnmanagedCallersOnly]\r\n    public static void Invoke(Foo\u003cT\u003e* @this)\r\n    {\r\n        Unsafe.As\u003cAction\u003cT\u003e\u003e(@this-\u003ehandle.Target)(@this-\u003estate);\r\n    }\r\n}\r\n```\r\n\r\nIn this case the method signature is blittable and the other requirements are respected as well, shouldn\u0027t `[UnmanagedCallersOnly]` be allowed? Same for cases where `T` also partecipates directly in the signature, but is substituted for a blittable type anyway, which should make the whole thing still valid anyway.\r\n\r\nRight now there\u0027s technically a way to work around this, but it involves a **ton** more complexity as you need to setup a whole stub to then jump to the right generic method from a non-generic one, and you also need to store the extra stub function pointer in the type, as that\u0027s needed to be carried around in the native object for the whole thing to work. Here\u0027s an example of what is needed today to work around this limitation (wouldn\u0027t actually recommend doing this ever, way too clunky):\r\n\r\n\u003cdetails\u003e\r\n    \u003csummary\u003e\u003cb\u003eGeneric stub workaround (click to expand):\u003c/b\u003e\u003c/summary\u003e\r\n\u003c/br\u003e\r\n\r\n```csharp\r\npublic static unsafe class IAction\r\n{\r\n    [UnmanagedCallersOnly]\r\n    public static void Invoke(void* @this)\r\n    {\r\n        ((delegate*\u003cvoid*, void\u003e)((void**)@this)[1])(@this);\r\n    }\r\n}\r\n\r\npublic unsafe struct IAction\u003cT\u003e\r\n    where T : unmanaged\r\n{\r\n    public static readonly void** Vtbl = InitVtbl();\r\n\r\n    private static void** InitVtbl()\r\n    {\r\n        void** lpVtbl = (void**)RuntimeHelpers.AllocateTypeAssociatedMemory(typeof(IAction\u003cT\u003e), sizeof(void*));\r\n\r\n        lpVtbl[0] = (delegate* unmanaged\u003cvoid*, void\u003e)\u0026IAction.Invoke;\r\n\r\n        return lpVtbl;\r\n    }\r\n\r\n    public static IAction\u003cT\u003e* Create(Action\u003cT\u003e callback, T state)\r\n    {\r\n        IAction\u003cT\u003e* action = (IAction\u003cT\u003e*)NativeMemory.Alloc((nuint)sizeof(IAction\u003cT\u003e));\r\n\r\n        action-\u003elpVtbl = Vtbl;\r\n        action-\u003estub = (delegate*\u003cvoid*, void\u003e)\u0026IAction\u003cT\u003e.Stub;\r\n        action-\u003ehandle = GCHandle.Alloc(callback);\r\n        action-\u003estate = state;\r\n\r\n        return action;\r\n    }\r\n\r\n    public void** lpVtbl;\r\n    public void* stub;\r\n    public GCHandle handle;\r\n    public T state;\r\n\r\n    public static void Stub(void* @this)\r\n    {\r\n        Unsafe.As\u003cAction\u003cT\u003e\u003e(((IAction\u003cT\u003e*)@this)-\u003ehandle.Target!)(((IAction\u003cT\u003e*)@this)-\u003estate);\r\n    }\r\n}\r\n```\r\n\u003c/details\u003e\r\n\r\n## Proposal\r\n\r\nNo new APIs, just lifting the restrictions from the runtime and Roslyn (CS8895) that prevents `[UnmanagedCallersOnly]` from being used on generic methods or methods in generic types. The same other restrictions should remain, just that they\u0027d be fully validated at runtime in case the method was generic and one or more type parameters were used in the signature.\r\n\r\n## Risks\r\n\r\nNot really seeing any other than the possible runtime crash if a user tried to use this on a generic type that was then substituted for an incompatible type. But the whole feature is incredibly niche and advanced anyway, so wouldn\u0027t really consider that a problem (there\u0027s plenty of other things that could go wrong when dealing with code like this already anyway).\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOQhhVeQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg3MzYxMjI1OQ==",
                                           "createdAt":  "2021-07-04T15:31:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-07-04T15:31:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg3NDQxNzUzNQ==",
                                           "createdAt":  "2021-07-06T02:38:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "This is a doc bug. The original C# 9 function pointer spec has the limitation listed: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/function-pointers#systemruntimeinteropservicesunmanagedcallersonlyattribute\r\n\r\nThis was intentional limitation to keep the runtime implementation simple. Generics and interop are not supported across the board (e.g. generic DllImport is not supported either).",
                                           "updatedAt":  "2021-07-06T02:38:55Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg3NTAwMTQxOA==",
                                           "createdAt":  "2021-07-06T18:50:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "As @jkotas mentioned, we decided to limit the implementation for simplicity.\r\n\r\nWith generics specifically, there\u0027s a few additional issues. Specifically, UnmanagedCallersOnly is incompatible with shared-generics based on the current design. Since UnmanagedCallersOnly is designed to present the minimal overhead for calling a .NET function from native code, it does not provide any wrapper stub. As a result, if an UnmanagedCallersOnly method has a shared generic instantiation, then there\u0027s no mechanism to pass in the generic instantiation arg.\r\n\r\nIf we were to allow UnmanagedCallersOnly on generic methods, we\u0027d have to be extra careful that we don\u0027t end up using a shared instantiation, otherwise users would get unexpected crashes and parameters would seem to not line up correctly. I encountered this while working on C#/WinRT and debugging it was quite messy.\r\n\r\nSince shared instantiations is a performance optimization that we don\u0027t publicly document when it occurs and we currently don\u0027t provide a mechanism to opt-out a method from a shared generic experience, we\u0027ve decided to explicitly not support generic UnmanagedCallersOnly methods as a whole, at least for the initial support.\r\n\r\nAdditionally, generic unmanaged function pointers are explicitly not supported across the board (see #9136), so it would be impossible to take an address of an UnmanagedCallersOnly method that\u0027s instantiated based on a generic parameter in the method it\u0027s in and cast it to its function pointer type, which would make the experience significantly worse than the usual UnmanagedCallersOnly experience.\r\n\r\n\r\nI\u0027ll update the documentation for now, and in the future we can look at this again.\r\n",
                                           "updatedAt":  "2021-07-06T18:50:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc400gnD",
                                           "createdAt":  "2021-07-25T10:31:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Sergio0694",
                                           "body":  "\u003e \"With generics specifically, there\u0027s a few additional issues. Specifically, UnmanagedCallersOnly is incompatible with shared-generics based on the current design. Since UnmanagedCallersOnly is designed to present the minimal overhead for calling a .NET function from native code, it does not provide any wrapper stub. As a result, if an UnmanagedCallersOnly method has a shared generic instantiation, then there\u0027s no mechanism to pass in the generic instantiation arg.\"\r\n\r\nHey @jkoritzinsky, yeah totally agree with that of course. As mentioned on Discord as well, my idea was in fact to only allow this when all substituted type parameters are unmanaged, so eg. the runtime could just throw a `TypeLoadException` or similar when the new type is instantiated (eg. I could see this being checked from `MethodTableBuilder::BuildMethodTableThrowing` maybe?), if it contains an `[UnmanagedCallersOnly]` method and any of the type arguments aren\u0027t unmanaged. This reminds me a bit of #43486, where we had basically a very similar proposal of removing the build-time enforcement of the explicit layout not being allowed on generics, and instead just checking it at runtime to again allow that when all type arguments were unmanaged.\r\n\r\nDoes that seem reasonable and potentially something that would make sense doing? 🙂",
                                           "updatedAt":  "2021-07-25T10:31:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc400tYV",
                                           "createdAt":  "2021-07-25T17:19:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOB65XtA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2021-09-18T22:02:47Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "It would make sense as end-to-end enablement of generics with interop. I do not think relaxing the generics restrictions for `[UnmanagedCallersOnly]` only while keeping it every else in interop makes sense.\r\n\r\nIt would help to have more concrete motivating example: The concrete unmanaged library that you trying to wrap, why source generators are not a viable solution to the problem, etc.\r\n\r\nThe counterexample is https://github.com/microsoft/CsWinRT. It has interop wrappers for WinRT generics and they were able to do without this. I guess that you often also need to marshal the generic types involved and that requires manual specialization based on `T` anyway.",
                                           "updatedAt":  "2021-07-25T17:19:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc401kEc",
                                           "createdAt":  "2021-07-26T07:39:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBz3w1Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkoritzinsky",
                                                                               "createdAt":  "2021-07-26T15:19:19Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "\u003e my idea was in fact to only allow this when all substituted type parameters are unmanaged\r\n\r\nThis would basically hardcode/assume the current implementation details of generic sharing in CoreCLR. E.g. Mono sometimes does generic sharing over valuetypes as well, often when they would be considered unmanaged. Those would need a context argument as well. We shouldn\u0027t assume the current implementation of shared generic code in the design. It might change depending on scenario.",
                                           "updatedAt":  "2021-07-26T07:39:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5BeWGr",
                                           "createdAt":  "2022-04-13T20:47:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Sergio0694",
                                           "body":  "\u003e \"It would help to have more concrete motivating example: The concrete unmanaged library that you trying to wrap, why source generators are not a viable solution to the problem, etc.\"\r\n\r\nSo, I actually have a concrete example of a case where this would\u0027ve been useful to have 😄\r\n\r\nTo very quickly give some context, I have a library, [ComputeSharp](https://github.com/Sergio0694/ComputeSharp), which allows developers to implement DX12 shaders in C# (there\u0027s a source generator that then transpiles them to HLSL and optionally precompiles them and embeds them in .data if needed too). Anyway, recently I\u0027ve been working on adding support for D2D1 pixel shaders, and one thing I wanted to implement was also some API to easily create an `ID2D1Effect` instance from a given pixel shader (which is just an arbitrary C# struct for the user). Long story short, in order to register a D2D1 effect, you need to register it by passing a `delegate* unmanaged\u003cIUnknown**, HRESULT\u003e` factory to [ID2D1Factory1::RegisterEffectFromString](https://docs.microsoft.com/en-us/windows/win32/api/d2d1_1/nf-d2d1_1-id2d1factory1-registereffectfromstring). Now, ideally I wanted something like this:\r\n\r\n```csharp\r\n// Define some shader\r\n[D2DInputCount(1)]\r\n[D2DInputSimple(0)]\r\n[D2DEmbeddedBytecode(D2D1ShaderProfile.PixelShader50)]\r\npublic partial struct MyShader : ID2D1PixelShader\r\n{\r\n    public float4 Execute()\r\n    {\r\n        return D2D1.GetInput(0); // Some arbitrary logic here...\r\n    }\r\n}\r\n```\r\n```csharp\r\nusing ComPtr\u003cID2D1Effect\u003e effect = default;\r\n\r\n// Create the effect\r\nD2D1InteropServices.CreateD2D1Effect\u003cMyShader\u003e(effect.GetAddressOf());\r\n```\r\n\r\nBehind the scenes, I had to implement the actual effect, which means rolling up an implementation of `ID2D1EffectImpl` and `ID2D1DrawTransform`. Ideally, you\u0027d think you\u0027d just do something like this to setup all the per-shader and per-effect state:\r\n\r\n```csharp\r\ninternal unsafe struct D2D1PixelShaderEffect\u003cT\u003e\r\n    where T : unmanaged, ID2D1PixelShader\r\n{\r\n    // Random fields you might need...\r\n    private static readonly Guid shaderId;\r\n    private static readonly byte* bytecode;\r\n    private static readonly int bytecodeSize;\r\n    private static readonly int numberOfInputs;\r\n\r\n    static D2D1PixelShaderEffect()\r\n    {\r\n        // Setup the shared state for all effects...\r\n    }\r\n\r\n    [UnmanagedCallersOnly]\r\n    public static int CreateEffect(IUnknown** effectImpl)\r\n    {\r\n        // Create and initialize the new effect instance\r\n    }\r\n}\r\n```\r\n\r\nAnd then for registration you could just grab a pointer for that factory, use it to register, and go about your day. That _could_ work given that `T` here is constrained to `unmanaged`, so every resolved function pointer would always point to a separate concrete method, but of course as discussed that\u0027s not allowed (small note: as @MichalStrehovsky said there\u0027s also an argument about value type generics never being shared being an implementation detail and not a spec guarantee, as a side note, but for this example let\u0027s just assume that\u0027s always the case). The solution I ended up at to solve this was to... Fallback to actually using a cached delegate, and then using `Marshal.GetFunctionPointerForDelegate`. Not really what I was expecting to find myself using on .NET 6+ for something like this, but alas it did solve the issue and I couldn\u0027t find any other ways around it 😄\r\n\r\nSo I basically ended up with something like this ([see actual code here](https://github.com/Sergio0694/ComputeSharp/blob/6c01e755e0564d3538c27760c2a571115aba40ad/tests/ComputeSharp.D2D1Interop.Tests/Helpers/PixelShaderEffect.cs#L19)):\r\n\r\n```csharp\r\ninternal unsafe partial struct PixelShaderEffect\r\n{\r\n    [UnmanagedFunctionPointer(CallingConvention.Winapi)]\r\n    private delegate int FactoryDelegate(IUnknown** effectImpl);\r\n\r\n    public static class For\u003cT\u003e\r\n        where T : unmanaged, ID2D1PixelShader\r\n    {\r\n        // Random fields you might need...\r\n        private static readonly Guid shaderId;\r\n        private static readonly byte* bytecode;\r\n        private static readonly int bytecodeSize;\r\n        private static readonly int numberOfInputs;\r\n\r\n        private static readonly FactoryDelegate EffectFactory = CreateEffect;\r\n\r\n        static For()\r\n        {\r\n            // Setup the shared state for all effects...\r\n        }\r\n\r\n        public static delegate* unmanaged\u003cIUnknown**, HRESULT\u003e Factory\r\n        {\r\n            get =\u003e (delegate* unmanaged\u003cIUnknown**, HRESULT\u003e)Marshal.GetFunctionPointerForDelegate(EffectFactory);\r\n        }\r\n\r\n        private static int CreateEffect(IUnknown** effectImpl)\r\n        {\r\n            // Create and initialize the new effect instance\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThis works, you\u0027d just get that `Factory` function pointer and use it to register the effect, and you\u0027d still be able to have it access all the `T`-specific shared static state for that shader instance. But, it\u0027s way clunkier and arguably more error prone to setup than just just being able to get a function pointer from that method in a generic type.\r\n\r\nAnyway, I just figured I\u0027d share my findings here since I ended up (by accident) bashing my head again against the current `[UnmanagedCallersOnly]` restriction, and thought this could be a valid (although niche) example of where it could be useful.",
                                           "updatedAt":  "2022-04-14T10:15:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5CGFV5",
                                           "createdAt":  "2022-04-25T18:18:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "DaZombieKiller",
                                           "body":  "\u003e This would basically hardcode/assume the current implementation details of generic sharing in CoreCLR. E.g. Mono sometimes does generic sharing over valuetypes as well, often when they would be considered unmanaged. Those would need a context argument as well. We shouldn\u0027t assume the current implementation of shared generic code in the design. It might change depending on scenario.\r\n\r\nWould it be fine to enforce \"no generic sharing\" just for `UnmanagedCallersOnly` methods? It\u0027s comparable to a `static` field in a generic type, which cannot be shared:\r\n```cs\r\nstatic class C\u003cT\u003e\r\n{\r\n    public static int Value;\r\n}\r\n```\r\nAlternatively, allowing `UnmanagedCallConv` on delegates would at least improve the situation. Right now, you cannot use extensible calling conventions with `GetFunctionPointerForDelegate` as you are limited to the `CallingConvention` enum (meaning you cannot use `CallConvMemberFunction`, for example).",
                                           "updatedAt":  "2022-04-25T18:18:03Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Allow [UnmanagedCallersOnly] on generic methods, when possible",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/59013",
        "createdAt":  "2021-07-21T15:01:03Z",
        "number":  59013,
        "author":  "jnm2",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOBzXtQQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AArnott",
                                            "createdAt":  "2021-07-21T15:13:48Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-08-18T07:00:38Z",
        "body":  "The same reasoning applies as the reasoning for why partial enums wouldn\u0027t make sense. The meaning of a member in a ComImport type changes based on its order within the type.\r\n\r\nThere is currently no warning for a pair of source files like this, but there should be:\r\n\r\n```cs\r\n[ComImport]\r\npartial interface ISomeInterface { void Foo(); }\r\n```\r\n\r\n```cs\r\npartial interface ISomeInterface { void Bar(); }\r\n```\r\n\r\nThere should be no warning for a case like this:\r\n\r\n```cs\r\n[ComImport]\r\npartial interface ISomeInterface { void Foo(); }\r\n```\r\n\r\n```cs\r\n[SomeInterface]\r\npartial interface ISomeInterface\r\n{\r\n    public struct DoesNotAffectVTable { }\r\n}\r\n```\r\n\r\n### Why not warn for partial ComImport interfaces in the first place?\r\n\r\nThe source generator https://github.com/microsoft/CsWin32 is a new official vehicle for consuming Windows platform APIs. It generates most types as partial so that you can add customizations, but it doesn\u0027t do this for ComImport interfaces. @AArnott cited the danger described at the top. The use case for a partial ComImport interface was to add attributes:\r\n\r\n```cs\r\nnamespace Windows.Win32.UI.Shell\r\n{\r\n    [CoClass(typeof(ShellLink))]\r\n    internal partial interface IShellLinkW { }\r\n}\r\n```\r\n\r\nThis is safe, but adding a member would not be safe. Therefore the warning should only apply if more than one type part has members.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOSMPLUA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc40tOdK",
                                           "createdAt":  "2021-07-21T15:14:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AArnott",
                                           "body":  "\u003e The same reasoning applies as the reasoning for why partial enums wouldn\u0027t make sense.\r\n\r\npartial enums are fine if the first enum value declared in each partial explicitly prescribes the value. For example, there\u0027s no problem here:\r\n\r\n```cs\r\npartial enum Foo\r\n{\r\n    A = 1,\r\n    B,\r\n}\r\n\r\npartial enum Foo\r\n{\r\n    C = 3,\r\n    D,\r\n}\r\n```",
                                           "updatedAt":  "2021-07-21T15:14:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc40tUee",
                                           "createdAt":  "2021-07-21T15:48:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jnm2",
                                           "body":  "That will give \"CS0267: The \u0027partial\u0027 modifier can only appear immediately before \u0027class\u0027, \u0027record\u0027, \u0027struct\u0027, \u0027interface\u0027, or a method return type.\" (https://github.com/dotnet/csharplang/discussions/2669) Even if partial enums with explicit ordering were allowed in the future, you\u0027d want errors or warnings if the order wasn\u0027t explicitly given. That error/warning would be analogous to what we\u0027re asking for in ComImport types.",
                                           "updatedAt":  "2021-07-21T15:49:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41HQrh",
                                           "createdAt":  "2021-08-02T14:58:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jaredpar",
                                           "body":  "Moving to roslyn-analyzers as this feels more like an analyzer issue vs. a core compiler one. The reasoning being that `[ComImport]` isn\u0027t really a concept that is understood by the compiler. It exists outside of it. That\u0027s very much in analyzer territory. \r\n",
                                           "updatedAt":  "2021-08-02T14:58:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42tLbF",
                                           "createdAt":  "2021-09-13T03:44:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mavasani",
                                           "body":  "Needs to be triaged/approved by dotnet/runtime.",
                                           "updatedAt":  "2021-09-13T03:44:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42tLcJ",
                                           "createdAt":  "2021-09-13T03:44:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-09-13T03:44:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5IopJb",
                                           "createdAt":  "2022-08-17T23:12:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "elachlan",
                                           "body":  "This is a potential blocker for winforms as we attempt to migrate interop code to CsWin32.\r\n\r\nCC: @JeremyKuhne, @lonitra  ",
                                           "updatedAt":  "2022-08-17T23:12:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5IqRQk",
                                           "createdAt":  "2022-08-18T05:00:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "elachlan",
                                           "body":  "@danmoseley can you please see if you can get this unstuck?",
                                           "updatedAt":  "2022-08-18T05:00:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Iw8tQ",
                                           "createdAt":  "2022-08-19T15:10:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AArnott",
                                           "body":  "@elachlan Can you elaborate on how lack of an analyzer would be a blocker for WinForms? At best it seems to me it would just help you write correct code. But when would WinForms define partial COM interfaces? CsWin32 is being used in WinForms without marshaling, so interfaces aren\u0027t even being generated.",
                                           "updatedAt":  "2022-08-19T15:10:31Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Warning for partial ComImport types with members in more than one type part",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.InteropServices",
                       "code-analyzer"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/60591",
        "createdAt":  "2021-10-18T22:59:46Z",
        "number":  60591,
        "author":  "AaronRobinsonMSFT",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-01-31T21:29:34Z",
        "body":  "The lowest level of the Reflection API stack has many Interop related dependencies. This is a tracking issue for understanding those dependencies, improving code sharing between the coreclr and mono runtimes, and determining opportunities for improvements in .NET 7.\r\n\r\n- [ ] Improve code sharing PRs\r\n    - [x] https://github.com/dotnet/runtime/pull/60270",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOOGZZhg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc44ZlmG",
                                           "createdAt":  "2021-10-18T23:00:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "/cc @jkoritzinsky @elinor-fung ",
                                           "updatedAt":  "2021-10-18T23:00:17Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "[Tracking] Investigate Reflection API interaction at managed/unmanaged boundary",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/63109",
        "createdAt":  "2021-12-23T19:54:40Z",
        "number":  63109,
        "author":  "teo-tsirpanis",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-05-19T20:53:25Z",
        "body":  "When passing `SafeHandle`s by reference, the `DllImportGenerator` needs their types to have an accessible parameterless constructor. If they don\u0027t, it tries to create them by generating a call to `Activator.CreateInstance(typeof(MySafeHandle), nonPublic: true)`. If they don\u0027t have a parameterless constructor at all, the P/Invoke fails at runtime.\r\n\r\nAn analyzer should be added that helps with this situation. If the `SafeHandle` descendant in question does not have an accessible parameterless constructor. If it is in the same assembly with the P/Invoke, it should cause an error, directing the user to add one (or even helping them with a fixer). If it is in a different assembly, it should warn the user that the P/Invoke is not guaranteed to work, and suggest them to contact the `SafeHandle` in question\u0027s author.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOQ3u19w==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc47omQh",
                                           "createdAt":  "2021-12-23T19:54:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-12-23T19:54:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc47opeE",
                                           "createdAt":  "2021-12-23T20:29:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "cc: @AaronRobinsonMSFT @elinor-fung @stephentoub this would be a proposal to add back part of the analyzer/code-fix removed in https://github.com/dotnet/roslyn-analyzers/pull/5308 for being too noisy for SafeHandle-derived types used in non-P/Invoke scenarios. As part of #63085, we hit the exact scenario that the removed functionality was designed to assist.\r\n",
                                           "updatedAt":  "2021-12-23T20:29:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc47osdv",
                                           "createdAt":  "2021-12-23T21:06:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCIY8NQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkoritzinsky",
                                                                               "createdAt":  "2021-12-23T21:12:08Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2022-01-03T17:28:25Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "I\u0027m fine with an analyzer that warns on faulty P/Invokes in general: if we can detect a problem in a DllImport at compile time, a warning makes sense. And a SafeHandle returned from a p/invoke but lacking a ctor that makes that feasible is one such case. My pushback on the previous analyzer was that it was triggered for any SafeHandle, regardless of how it was consumed, regardless of whether it was used in P/Invokes.",
                                           "updatedAt":  "2021-12-23T21:06:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5De7X3",
                                           "createdAt":  "2022-05-19T20:35:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nWhen passing `SafeHandle`s by reference, the `DllImportGenerator` needs their types to have an accessible parameterless constructor. If they don\u0027t, it tries to create them by generating a call to `Activator.CreateInstance(typeof(MySafeHandle), nonPublic: true)`. If they don\u0027t have a parameterless constructor at all, the P/Invoke fails at runtime.\r\n\r\nAn analyzer should be added that helps with this situation. If the `SafeHandle` descendant in question does not have an accessible parameterless constructor. If it is in the same assembly with the P/Invoke, it should cause an error, directing the user to add one (or even helping them with a fixer). If it is in a different assembly, it should warn the user that the P/Invoke is not guaranteed to work, and suggest them to contact the `SafeHandle` in question\u0027s author.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eteo-tsirpanis\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `source-generator`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003eFuture\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-05-19T20:35:56Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "[DllImportGenerator] Warn/fail when passing by reference a `SafeHandle` without an accessible parameterless constructor.",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "code-analyzer",
                       "source-generator"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/63172",
        "createdAt":  "2021-12-28T16:59:51Z",
        "number":  63172,
        "author":  "kant2002",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-01-03T17:25:55Z",
        "body":  "During working on #62921 I debug tests and notice following strange behaviour. \r\n\r\nIf I add `Console.WriteLine` to each method of `OrderTrackingCustomMarshaler` class here (and in MarshalXXX methods too, GetInstance I did not log)\r\nhttps://github.com/dotnet/runtime/blob/da2940fb8508832811385bb45ab6552fc1aa0881/src/tests/Interop/ICustomMarshaler/Primitives/ICustomMarshaler.cs#L213-L224\r\n\r\nthen output during CoreCLR run of tests is following\r\n```\r\nCalled MarshalManagedToNative 64001\r\nCalled MarshalNativeToManaged 64001\r\nCalled CleanUpNativeData 2843593306432\r\nCalled CleanUpNativeData 64001\r\n\r\nCalled MarshalManagedToNative 234\r\nCalled MarshalNativeToManaged 234\r\nCalled CleanUpNativeData 2843593306528\r\nCalled CleanUpNativeData 234\r\n\r\nCalled MarshalManagedToNative 7488\r\nCalled CleanUpManagedData 7488\r\nCalled MarshalNativeToManaged 2843593306464\r\nCalled CleanUpNativeData 2843593306464\r\n\r\nCalled MarshalNativeToManaged 2334\r\nCalled CleanUpNativeData 2334\r\n\r\nCalled MarshalManagedToNative 439\r\nCalled CleanUpManagedData 439\r\nCalled MarshalNativeToManaged 439\r\nCalled CleanUpNativeData 439\r\n\r\nCalled MarshalNativeToManaged 726\r\nCalled CleanUpNativeData 726\r\n```\r\n\r\nFor each method which has return value atributed with `[return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(OrderTrackingCustomMarshaler))]` one call of `CleanUpNativeData`  does not recorded in the tests.\r\n\r\nI think this is rather suspicious, and because I rely on tests to implement NativeAOT variant, this raise eyebrows why this is happening, and how I can capture all calling sequences.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOO9uDLw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc4724Mv",
                                           "createdAt":  "2022-01-03T17:25:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "@kant2002 This is another Interop area that has narrow testing. I agree that adding testing to ensure we have coverage is important. PRs are very much welcome in this area.\r\n\r\n/cc @dotnet/interop-contrib ",
                                           "updatedAt":  "2022-01-03T17:25:54Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "ICustomMarshaler tests seems incomplete",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/63590",
        "createdAt":  "2022-01-10T20:30:58Z",
        "number":  63590,
        "author":  "teo-tsirpanis",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC_YqSg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SupinePandora43",
                                            "createdAt":  "2022-10-01T12:38:42Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lambdageek",
                                            "createdAt":  "2022-12-19T19:56:55Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DaZombieKiller",
                                            "createdAt":  "2023-10-11T06:27:44Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ceztko",
                                            "createdAt":  "2024-03-05T09:47:51Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "raulsntos",
                                            "createdAt":  "2025-02-24T02:25:18Z"
                                        }
                                    ],
                          "totalCount":  5
                      },
        "updatedAt":  "2025-07-31T20:16:47Z",
        "body":  "### Background and motivation\r\n\r\nThe upcoming `DllImport` source generator will decouple the job of marshalling P/Invoke calls from the runtime, but in its current form it can\u0027t do much when native code is invoked via `Marshal.GetDelegateForFunctionPointer`. Function pointers can be used to call unmanaged code, but the built-in marshaller cannot be avoided if their arguments and return type are not blittable.\r\n\r\nI propose a counterpart attribute to `LibraryImportAttribute` that instructs the generator to only marshal the parameters and the return type of the function, and call a user-specified function pointer instead of a P/Invoke. This attribute will provide the source-generated successor of `Marshal.GetDelegateForFunctionPointer`.\r\n\r\n### API Proposal\r\n\r\n_Updated to match the approved shape of `LibraryImportAttribute`._\r\n\r\n```C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]\r\n    public sealed class NativeFunctionMarshalAttribute : Attribute\r\n    {\r\n        /// \u003csummary\u003e\r\n        /// Constructor.\r\n        /// \u003c/summary\u003e\r\n        public NativeFunctionMarshalAttribute();\r\n\r\n        /// \u003csummary\u003e\r\n        /// Indicates how to marshal string parameters to the method.\r\n        /// \u003c/summary\u003e\r\n        /// \u003cremarks\u003e\r\n        /// If this field is specified, \u003csee cref=\"StringMarshallingCustomType\" /\u003e must not be specified.\r\n        /// \u003c/remarks\u003e\r\n        public StringMarshalling StringMarshalling { get; set; }\r\n\r\n        /// \u003csummary\u003e\r\n        /// Indicates how to marshal string parameters to the method.\r\n        /// \u003c/summary\u003e\r\n        /// \u003cremarks\u003e\r\n        /// If this field is specified, \u003csee cref=\"StringMarshalling\" /\u003e must not be specified.\r\n        /// The type should be one that conforms to usage with the attributes:\r\n        /// \u003csee cref=\"System.Runtime.InteropServices.MarshalUsingAttribute\"/\u003e\r\n        /// \u003csee cref=\"System.Runtime.InteropServices.NativeMarshallingAttribute\"/\u003e\r\n        /// \u003c/remarks\u003e\r\n        public Type? StringMarshallingCustomType { get; set; }\r\n\r\n        /// \u003csummary\u003e\r\n        /// Indicates whether the callee sents an error (SetLastError on Windows or errorno\r\n        /// on other platforms) before returning from the attributed method.\r\n        /// \u003c/summary\u003e\r\n        /// \u003csee cref=\"System.Runtime.InteropServices.DllImportAttribute.SetLastError\"/\u003e\r\n        public bool SetLastError { get; set; }\r\n    }\r\n}\r\n```\r\n\r\nThe attribute resembles `LibraryImportAttribute`, with the difference that it lacks the constructor parameter for the library name and the `EntryPoint` property.\r\n\r\nWhen it is applied to a `partial` method, the method\u0027s first parameter must be an `IntPtr` (otherwise it is an error) and is not passed to the native call; instead it contains the pointer to the unmanaged function; the generated method casts the `IntPtr` to the appropriate function pointer type and marshals and passes the other parameters to it.\r\n\r\nIn all cases that don\u0027t involve importing a DLL, the samantics of `NativeFunctionMarshalAttribute` are identical with `LibraryImportAttribute` and these two attributes will evolve in tandem. If `LibraryImportAttribute` gets a relevant new property or behavior, this attribute will get it as well.\r\n\r\n### API Usage\r\n\r\n```C#\r\n[NativeFunctionMarshal]\r\n[UnmanagedCallConv(CallConvs = new[] {typeof(CallConvSuppressGCTransition)})]\r\npublic partial int QueryPerformanceCounter_wrapper(IntPtr nativeFunc, out long counter);\r\n\r\nvar kernel32 = NativeLibrary.Load(\"kernel32.dll\");\r\nvar qpc_func = NativeLibrary.GetExport(kernel32, \"QueryPerformanceCounter\");\r\n\r\n_ = QueryPerformanceCounter_wrapper(qpc_func, out long counter);\r\n\r\nConsole.WriteLine($\"QPC returned {counter}\");\r\n```\r\n\r\n### Alternative Designs\r\n\r\n* We could use a different attribute name.\r\n* Instead of adding one function pointer argument to the method at the beginning, we could create source-generated specializations of `Marshal.GetDelegateFromFunctionPointer\u003cTDelegate\u003e`, for various `TDelegate`s. While it would ease migration, it is less efficient and less flexible. And if somebody wants to create such delegates they can still be done with the proposed API.\r\n* The first parameter could have been either of `UIntPtr`, `nint`, `nuint` and `void*` but there is no reason to be and it would be better to keep things simple. The functions in the `NativeLibrary` function return an `IntPtr` either way.\r\n\r\n### Risks\r\n\r\nThis attribute brings a conceptual change when dealing with P/Invokes; not all arguments on the managed function correspond to arguments on the native function. There might be some confusion, but this API is not intended for everyday use either way.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOdiFWeg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc48Z8Bw",
                                           "createdAt":  "2022-01-14T19:54:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "We talked over this in the interop team meeting, and we think the idea is interesting and the scenario is something we want to support. We\u0027re unsure about the proposed attribute shape as we want to keep it in sync with `GeneratedDllImport`, which is still in flux.\r\n\r\nWe\u0027ll tentatively mark this for .NET 7 in the case that we have time, but it\u0027s likely that the implementation might slip to .NET 8.",
                                           "updatedAt":  "2022-01-14T19:54:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48aF6D",
                                           "createdAt":  "2022-01-14T21:05:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "Thanks for the feedback. I forgot to explicitly mention it, but the new attribute\u0027s shape will evolve _in tandem_ with `GeneratedDllImportAttribute`, except for the properties that have to do with importing a DLL (for now the library name, `EntryPoint` and `ExactSpelling`). I will update the proposal to make it more clear, and once `GeneratedDllImportAttribute`\u0027s shape gets finalized, feel free to update this one\u0027s, to move the proposal forward.\r\n\r\nAs for the release it will land, I won\u0027t have a problem with either .NET 7 or 8; it\u0027s not an API I am expecting to use myself.",
                                           "updatedAt":  "2022-01-14T21:05:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49O5yY",
                                           "createdAt":  "2022-02-01T21:44:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "While working on #64279, I\u0027ve found a few places where this would be useful in dotnet/runtime:\r\n\r\n- https://github.com/dotnet/runtime/blob/main/src/libraries/System.Net.Sockets/src/System/Net/Sockets/DynamicWinsockMethods.cs\r\n- https://github.com/dotnet/runtime/blob/main/src/libraries/System.Data.OleDb/src/OleDbWrapper.cs\r\n- https://github.com/dotnet/runtime/blob/main/src/libraries/System.Management/src/System/Management/ManagementScope.cs \r\n- https://github.com/dotnet/runtime/blob/main/src/libraries/System.Net.Quic/src/System/Net/Quic/Implementations/MsQuic/Internal/MsQuicApi.cs",
                                           "updatedAt":  "2022-02-11T19:04:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5De5_d",
                                           "createdAt":  "2022-05-19T20:29:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "Good suggestion. This isn\u0027t something we are going to get to in 7. Moving to Future.",
                                           "updatedAt":  "2022-05-19T20:29:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DfBon",
                                           "createdAt":  "2022-05-19T21:04:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "I don\u0027t see how that would help Reverse P/Invokes. There could be a generator mode that creates `UnmanagedCallersOnly` wrappers that unmarshal arguments and call a normal method but this is unrelated to what I proposed.",
                                           "updatedAt":  "2022-05-19T21:04:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DfDa5",
                                           "createdAt":  "2022-05-19T21:14:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e I don\u0027t see how that would help Reverse P/Invokes. There could be a generator mode that creates `UnmanagedCallersOnly` wrappers that unmarshal arguments and call a normal method but this is unrelated to what I proposed.\r\n\r\nOops. My mistake. I completely misread this proposal. I will revert the title.",
                                           "updatedAt":  "2022-05-19T21:14:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5G-80F",
                                           "createdAt":  "2022-07-21T00:37:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCn6zuw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkoritzinsky",
                                                                               "createdAt":  "2022-07-21T04:48:42Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "joperezr",
                                                                               "createdAt":  "2022-07-21T18:30:15Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "@jkoritzinsky and @elinor-fung I think we should reprioritize this proposal for .NET 8. There is a scenario in the runtime that would benefit from this feature.\r\n\r\n/cc @joperezr ",
                                           "updatedAt":  "2022-07-21T00:37:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5hJdgl",
                                           "createdAt":  "2023-07-10T23:31:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "We aren\u0027t going to get to this before feature-complete in .NET 8. Moving to .NET 9.",
                                           "updatedAt":  "2023-07-10T23:31:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc52IVZ6",
                                           "createdAt":  "2024-03-06T22:11:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ceztko",
                                           "body":  "Recently we [discussed](https://github.com/dotnet/runtime/issues/35017#issuecomment-1928635819) about common interop scenarios for `[UnmanagedFunctionPointer]` delegates that could be handled better in case of managed exceptions throwing. @jkotas suggested that implementing the API in this issue may be instrumental to plug a managed exception handler for methods that get marshaled to native code as native function pointers. This would remove the need for boiler plate code, like trivial repetitive `try-catch` blocks, like in my [example](https://github.com/dotnet/runtime/issues/35017#issuecomment-1928003283). Looking at the API here I can\u0027t see anything that would help for that specific use case. Unless I\u0027m missing something I would like to suggest how it could be done. Basically `NativeFunctionMarshalAttribute` could also provide the following property:\r\n\r\n```\r\n/// \u003csummary\u003e\r\n/// Specify how to handle exceptions when the method\r\n/// gets wrapped to be marshaled to native code\r\n/// \u003c/summary\u003e\r\n/// \u003cremarks\u003e\r\n/// The type must supply a single static function with\r\n/// signature \"void HandleException(Exception ex)\"\r\n/// \u003c/remarks\u003e\r\npublic Type? UnmanagedFunctionPointerExceptionHandlerType { get; set; }\r\n```\r\n\r\nThis would not cover more complex scenarios, like surrounding the method call with custom code: it would just handle the exception. I could not grasp if you Jan was thinking something more flexibile, but for me handling exceptions would be more than enough. Do you think this can happen for the .NET 9/10 timeframe as well?",
                                           "updatedAt":  "2024-03-06T22:11:01Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "[LibraryImport] Support generating static Marshalling stub for unmanaged function pointer calls.",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/66674",
        "createdAt":  "2022-03-15T19:10:38Z",
        "number":  66674,
        "author":  "jkoritzinsky",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODIj2mg==",
                          "nodes":  [
                                        {
                                            "content":  "HOORAY",
                                            "user":  "AaronRobinsonMSFT",
                                            "createdAt":  "2022-03-15T19:31:54Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "rogihee",
                                            "createdAt":  "2022-03-15T19:51:20Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "ThadHouse",
                                            "createdAt":  "2022-03-15T22:14:17Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "NN---",
                                            "createdAt":  "2022-03-16T02:07:07Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "hez2010",
                                            "createdAt":  "2022-03-16T03:30:10Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "hoyosjs",
                                            "createdAt":  "2022-03-16T06:21:09Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "saucecontrol",
                                            "createdAt":  "2022-03-17T02:00:09Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "petarpetrovt",
                                            "createdAt":  "2022-03-17T08:15:09Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "elinor-fung",
                                            "createdAt":  "2022-03-25T07:18:21Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "AlgorithmsAreCool",
                                            "createdAt":  "2022-04-21T21:57:49Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "NKnusperer",
                                            "createdAt":  "2022-06-17T07:49:03Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2022-08-15T17:33:21Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "ptasev",
                                            "createdAt":  "2022-09-04T04:36:26Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "dhrdlicka",
                                            "createdAt":  "2022-09-10T21:15:37Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "sbomer",
                                            "createdAt":  "2022-09-14T20:41:33Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "vitek-karas",
                                            "createdAt":  "2022-09-14T21:07:22Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "govert",
                                            "createdAt":  "2022-11-11T18:04:52Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "DevSelchow",
                                            "createdAt":  "2023-01-10T13:54:47Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "marklechtermann",
                                            "createdAt":  "2023-02-06T12:50:55Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2023-02-24T13:43:43Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "JasonWei512",
                                            "createdAt":  "2023-03-17T08:55:11Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "lindexi",
                                            "createdAt":  "2023-04-05T10:00:30Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "rgwood",
                                            "createdAt":  "2023-07-19T00:58:31Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "hughbe",
                                            "createdAt":  "2023-08-29T09:52:26Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "RichiCoder1",
                                            "createdAt":  "2023-09-04T19:35:30Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "tomap",
                                            "createdAt":  "2023-09-18T19:24:29Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "MineCake147E",
                                            "createdAt":  "2023-11-05T04:14:31Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "ShreyasJejurkar",
                                            "createdAt":  "2023-11-11T06:24:42Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "thorntonryan",
                                            "createdAt":  "2024-01-16T20:51:38Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "bizouarn",
                                            "createdAt":  "2024-01-30T21:59:11Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "martin-cernil",
                                            "createdAt":  "2024-04-05T11:25:57Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "lauxjpn",
                                            "createdAt":  "2024-05-15T11:57:51Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "JS-X-Visual",
                                            "createdAt":  "2025-01-13T12:32:27Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "s341507",
                                            "createdAt":  "2025-03-07T09:25:46Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "andrew-boyarshin",
                                            "createdAt":  "2025-06-01T12:22:47Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "DavidHollman",
                                            "createdAt":  "2025-07-25T18:25:26Z"
                                        }
                                    ],
                          "totalCount":  36
                      },
        "updatedAt":  "2025-04-24T20:59:28Z",
        "body":  "We plan to provide a COM source generator to enable developers to interoperate with unmanaged COM interfaces without using the built-in COM Interop subsystem as per our [Source Generator COM design](https://github.com/dotnet/runtime/blob/main/docs/design/features/source-generator-com.md).\n\nThis issue tracks the various tasks that implementing this source generator will require. Not all of these tasks will be completed in .NET 7 (in fact this list intentionally includes significantly more work than we will do in .NET 7 to provide a roadmap over a few versions).\n\n## Checkpoint 1: MCG-replacement\n\n- [x] Implement a `ComObject` type that implements any required infrastructure to provide implementations of a COM interface.\n  - Lifetime management, QI storage\n  - discovery of the interface implementations (likely `IDynamicInterfaceCastable`-related)\n- [x] Create a `ComObject` instance that wraps a native `IUnknown*` through a user-defined `partial` `ComWrappers`-derived type.\n- [x] Implement support for calling a native COM interface from managed code through a `ComObject` using the above functionality.\n- [x] Implement creating an `IUnknown*` that represents a managed non-`ComObject` object through a user-defined `partial` `ComWrappers`-derived type.\n- [x] Implement support for calling methods defined in a COM interface on a managed object from unmanaged code through an `IUnknown*` wrapper using the above functionality\n\n## Checkpoint 2: WinForms compatibility\n\nWinForms is primarily `IUnknown`-based COM, but there is some usage of `IDispatch`-based COM, primarily in the accessibility space. We would like to help support making WinForms trim-friendly, so we want to provide these features in the generator to support them.\n\n- [x] Implement marshalling support for `BSTR` strings. https://github.com/dotnet/runtime/pull/69213\n- [X] Implement support for marshalling various types to Win32 `VARIANT`s without typelib related support (no user-defined record types): #93635 \n- [ ] Implement support for marshalling arrays of various types to `SAFEARRAY`s\n  - The minimum required support for WinForms\u0027 accessibility usage is defined here: https://docs.microsoft.com/en-us/windows/win32/winauto/variant-structure\n- [ ] Optional: Implement stubbed-out support for `IDispatch`, or provide guidance for implementing stubbed-out support.\n  - Per the documentation on Microsoft Active Accessibility, the `IDispatch` implementation can be stubbed out with `E_NOTIMPL` errors: https://docs.microsoft.com/en-us/windows/win32/winauto/dual-interfaces--iaccessible-and-idispatch\n\n## Checkpoint 3: Activation support\n\nFor parity with the built-in system, providing an easy mechanism for activating a COM object is desireable, if lower priority.\n\n- [ ] Provide a mechanism to easily activate a new COM object with a gesture similar to creating a new .NET object in C#. https://github.com/dotnet/runtime/issues/111616\n- [ ] Provide a mechanism to easily expose .NET objects for creation through COM activation, similar to the `EnableComHosting` switch in the SDK for built-in COM.\n\n## Checkpoint 4: IDispatch support\n\nIf we find enough demand, we should consider providing more extensive `IDispatch` support (excluding TLB-related dependencies)\n\n- [ ] Implement support for explicit `IDispatch`-based interfaces with well-defined `DispId` values\n- [ ] Add support for explicit `IDispatch`-based interfaces with generator-defined `DispId` values\n- [ ] Stretch/Out-of-scope: Add `dynamic` compatibility for `IDispatch`-based COM object wrappers.\n\n## Checkpoint 5: TLB support\n \n- [ ] TLBImp replacement: Provide a mechanism for generating the C# source that is consumed by the source-generator from a TLB (COM type library)\n- [ ] TLBExp replacement: Provide a mechanism for generating an TLB from the C# source generator and using the existing TLB embedding support to embed the TLB in the COM host when the COM host is enabled.\n- [ ] Provide guidance for using TLB information in `VARIANT` or `IDispatch`-related scenarios.\n\n## Features to consider\n\n- Callouts for unmanaged \u003c--\u003e managed transitions. See https://github.com/dotnet/runtime/issues/45118\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOqJzEmg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc4_reoa",
                                           "createdAt":  "2022-03-15T19:10:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nWe plan to provide a COM source generator to enable developers to interoperate with unmanaged COM interfaces without using the built-in COM Interop subsystem as per our [Source Generator COM design](https://github.com/dotnet/runtime/blob/main/docs/design/features/source-generator-com.md).\r\n\r\nThis issue tracks the various tasks that implementing this source generator will require. Not all of these tasks will be completed in .NET 7 (in fact this list intentionally includes significantly more work than we will do in .NET 7 to provide a roadmap over a few versions).\r\n\r\nCheckpoint 1: MCG-replacement\r\n\r\n- [ ] Implement a `ComObject` type that implements any required infrastructure to provide implementations of a COM interface.\r\n  - Lifetime management, QI storage\r\n  - discovery of the interface implementations (likely `IDynamicInterfaceCastable`-related)\r\n- [ ] Create a `ComObject` instance that wraps a native `IUnknown*` through a user-defined `partial` `ComWrappers`-derived type.\r\n- [ ] Implement support for calling a native COM interface from managed code through a `ComObject` using the above functionality.\r\n- [ ] Implement creating an `IUnknown*` that represents a managed non-`ComObject` object through a user-defined `partial` `ComWrappers`-derived type.\r\n- [ ] Implement support for calling methods defined in a COM interface on a managed object from unmanaged code through an `IUnknown*` wrapper using the above functionality\r\n\r\nCheckpoint 2: WinForms compatibility\r\n\r\nWinForms is primarily `IUnknown`-based COM, but there is some usage of `IDispatch`-based COM, primarily in the accessibility space. We would like to help support making WinForms trim-friendly, so we want to provide these features in the generator to support them.\r\n\r\n- [ ] Implement marshalling support for `BSTR` strings.\r\n- [ ] Implement support for marshalling various types to Win32 `VARIANT`s without typelib related support (no user-defined record types)\r\n- [ ] Implement support for marshalling arrays of various types to `SAFEARRAY`s\r\n  - The minimum required support for WinForms\u0027 accessibility usage is defined here: https://docs.microsoft.com/en-us/windows/win32/winauto/variant-structure\r\n- [ ] Optional: Implement stubbed-out support for `IDispatch`, or provide guidance for implementing stubbed-out support.\r\n  - Per the documentation on Microsoft Active Accessibility, the `IDispatch` implementation can be stubbed out with `E_NOTIMPL` errors: https://docs.microsoft.com/en-us/windows/win32/winauto/dual-interfaces--iaccessible-and-idispatch\r\n\r\nCheckpoint 3: Activation support\r\n\r\nFor parity with the built-in system, providing an easy mechanism for activating a COM object is desireable, if lower priority.\r\n\r\n- [ ] Provide a mechanism to easily activate a new COM object with a gesture similar to creating a new .NET object in C#.\r\n\r\nCheckpoint 4: IDispatch support\r\n\r\nIf we find enough demand, we should consider providing more extensive `IDispatch` support (excluding TLB-related dependencies)\r\n\r\n- [ ] Implement support for explicit `IDispatch`-based interfaces with well-defined `DispId` values\r\n- [ ] Add support for explicit `IDispatch`-based interfaces with generator-defined `DispId` values\r\n- [ ] Stretch/Out-of-scope: Add `dynamic` compatibility for `IDispatch`-based COM object wrappers.\r\n\r\nCheckpoint 5: TLB support\r\n \r\n- [ ] TLBImp replacement: Provide a mechanism for generating the C# source that is consumed by the source-generator from a TLB (COM type library)\r\n- [ ] TLBExp replacement: Provide a mechanism for generating an TLB from the C# source generator and using the existing TLB embedding support to embed the TLB in the COM host when the COM host is enabled.\r\n- [ ] Provide guidance for using TLB information in `VARIANT` or `IDispatch`-related scenarios.\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejkoritzinsky\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`Epic`, `area-System.Runtime.InteropServices`, `Bottom Up Work`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-03-15T19:10:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5BeuSG",
                                           "createdAt":  "2022-04-13T23:30:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODPW3Aw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "damian-666",
                                                                               "createdAt":  "2023-12-12T20:56:32Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "alexrp",
                                           "body":  "I\u0027m currently writing a managed library that wraps the COM interfaces that CoreCLR supports for diagnostics (`clrdata`, `cordebug`, `corprof`) so I have some questions:\r\n\r\n1. I see the idea is for the generated `ComObject` to hold pointers to every potential COM interface supported by the project\u0027s `ComWrappers` type. This is probably fine for small-to-medium sized COM interop scenarios, but in my case, I\u0027m looking at some 400+ interfaces. I\u0027d rather not have `ComObject`s that huge. The strategy I\u0027m currently using is to have a cache of QI\u0027d pointers sitting on my `ComObject` equivalent, which I lazily populate on casts. (I *think* this is kind of similar to what CsWinRT is doing.) Could this strategy, or something like it, be supported?\r\n2. With C# interfaces being the source of truth, how much support would there be for high-level constructs like spans instead of pointer/length pairs, `HRESULT` exception translation, `ref`/`out`/`in` modifiers, passing an `out` parameter as return value where sensible, etc?\r\n3. Is checkpoint 1 likely to be done in the .NET 7 time frame? I\u0027m currently writing a project-specific generator that handles just enough for my needs, but even that is a fair amount of work. If it\u0027s likely to be wasted effort in a matter of months anyway, perhaps I should just put my project on ice until the official generator is available.",
                                           "updatedAt":  "2022-04-13T23:30:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Beu0W",
                                           "createdAt":  "2022-04-13T23:35:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCX-_7w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2022-04-13T23:49:13Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alexrp",
                                                                               "createdAt":  "2022-04-13T23:49:38Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "\u003e I\u0027m currently writing a managed library that wraps the COM interfaces that CoreCLR supports for diagnostics (`clrdata`, `cordebug`, `corprof`) so I have some questions:\r\n\u003e \r\n\u003e 1. I see the idea is for the generated `ComObject` to hold pointers to every potential COM interface supported by the project\u0027s `ComWrappers` type. This is probably fine for small-to-medium sized COM interop scenarios, but in my case, I\u0027m looking at some 400+ interfaces. I\u0027d rather not have `ComObject`s that huge. The strategy I\u0027m currently using is to have a cache of QI\u0027d pointers sitting on my `ComObject` equivalent, which I lazily populate on casts. (I _think_ this is kind of similar to what CsWinRT is doing.) Could this strategy, or something like it, be supported?\r\n\r\nWe\u0027ve considered such a strategy, but we want to get some performance numbers before we decide to go one direction or the other (or a blend of both).\r\n\r\n\u003e 2. With C# interfaces being the source of truth, how much support would there be for high-level constructs like spans instead of pointer/length pairs, `HRESULT` exception translation, `ref`/`out`/`in` modifiers, passing an `out` parameter as return value where sensible, etc?\r\n\r\nYes, we plan to support the same features we support with `LibraryImportGenerator` plus a small number of COM-specific ones like `HRESULT` exception translation.\r\n\r\n\u003e 3. Is checkpoint 1 likely to be done in the .NET 7 time frame? I\u0027m currently writing a project-specific generator that handles just enough for my needs, but even that is a fair amount of work. If it\u0027s likely to be wasted effort in a matter of months anyway, perhaps I should just put my project on ice until the official generator is available.\r\n\r\nWe\u0027re hoping to get checkpoint 1 done in the .NET 7 time frame, but I don\u0027t want to make any promises.",
                                           "updatedAt":  "2022-04-13T23:35:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Bew37",
                                           "createdAt":  "2022-04-13T23:57:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "alexrp",
                                           "body":  "\u003e Yes, we plan to support the same features we support with `LibraryImportGenerator` plus a small number of COM-specific ones like `HRESULT` exception translation.\r\n\r\nHow would this look in practice, by the way? E.g. if I define\r\n\r\n```csharp\r\n[GeneratedComInterface(typeof(MyComWrappers))]\r\n[Guid(\"4b69d271-5c99-4f95-b1eb-381e6e689f1a\")]\r\npartial interface IMyComInterface\r\n{\r\n    void Foo();\r\n}\r\n```\r\n\r\nand `Foo` actually has a `HRESULT` return on the native side? Would I need to attach `[return: MarshalAs(UnmanagedType.Error)]` to communicate that to the generator?\r\n\r\nI\u0027m not familiar with the exact set of constructs supported by `LibraryImportGenerator`. Does it include spans (where the native side expects pointer and length in separate parameters)?\r\n\r\n\u003e We\u0027re hoping to get checkpoint 1 done in the .NET 7 time frame, but I don\u0027t want to make any promises.\r\n\r\nThat\u0027s fine, I was just wondering what the plan was, with the understanding that plans can change.",
                                           "updatedAt":  "2022-04-13T23:57:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5BexaI",
                                           "createdAt":  "2022-04-14T00:02:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODUuv5Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2022-04-14T00:05:23Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alexrp",
                                                                               "createdAt":  "2022-04-14T07:15:52Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2023-10-10T02:09:11Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "bizouarn",
                                                                               "createdAt":  "2024-01-30T21:59:18Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "\u003e \u003e Yes, we plan to support the same features we support with `LibraryImportGenerator` plus a small number of COM-specific ones like `HRESULT` exception translation.\r\n\u003e \r\n\u003e How would this look in practice, by the way? E.g. if I define\r\n\u003e \r\n\u003e ```cs\r\n\u003e [GeneratedComInterface(typeof(MyComWrappers))]\r\n\u003e [Guid(\"4b69d271-5c99-4f95-b1eb-381e6e689f1a\")]\r\n\u003e partial interface IMyComInterface\r\n\u003e {\r\n\u003e     void Foo();\r\n\u003e }\r\n\u003e ```\r\n\u003e \r\n\u003e and `Foo` actually has a `HRESULT` return on the native side? Would I need to attach `[return: MarshalAs(UnmanagedType.Error)]` to communicate that to the generator?\r\n\r\nThis is still under discussion. The current prevailing idea is to match the built-in system where we do HRESULT checking by default unless the user provides the `[PreserveSig]` attribute on the method.\r\n\r\n\u003e I\u0027m not familiar with the exact set of constructs supported by `LibraryImportGenerator`. Does it include spans (where the native side expects pointer and length in separate parameters)?\r\n\r\nWe have some custom marshallers for `Span\u003cT\u003e` that marshal them to a pointer, and the length still needs to be passed as a separate parameter. These custom marshallers still need to go through API review.\r\n\r\nAdditional ideas (like synthesizing a length parameter into the native signature) have not been proposed or implemented yet. If you\u0027re interested in that feature, I think it\u0027s worthwhile filing a separate issue for the team to discuss it.\r\n\r\n\u003e \u003e We\u0027re hoping to get checkpoint 1 done in the .NET 7 time frame, but I don\u0027t want to make any promises.\r\n\u003e \r\n\u003e That\u0027s fine, I was just wondering what the plan was, with the understanding that plans can change.\r\n\r\n:+1:",
                                           "updatedAt":  "2022-04-14T00:02:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5FZwUy",
                                           "createdAt":  "2022-06-23T13:00:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "obiwanjacobi",
                                           "body":  "Is there an ETA for the ComWrappers source generator?\r\n(say\u0027s \u0027future\u0027 in the project?)",
                                           "updatedAt":  "2022-06-23T13:00:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5FaPsy",
                                           "createdAt":  "2022-06-23T14:50:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCjZbFA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "obiwanjacobi",
                                                                               "createdAt":  "2022-06-23T16:03:01Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "We are working on a prototype now that might be used for some internal parts of the dotnet/runtime repo. The plan would be to iterate early .NET 8 and hopefully have something in one of the later .NET 8 previews for public consumption.",
                                           "updatedAt":  "2022-06-23T14:50:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5H_mam",
                                           "createdAt":  "2022-08-08T08:59:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Molinarius",
                                           "body":  "I\u0027d appreciate if this was usable for creating an out-of-process COM server.",
                                           "updatedAt":  "2022-08-08T08:59:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RBwvL",
                                           "createdAt":  "2022-12-20T14:05:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODUPPNg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "marklechtermann",
                                                                               "createdAt":  "2023-02-06T12:48:48Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "rgwood",
                                                                               "createdAt":  "2023-07-19T00:58:52Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "lukedays",
                                                                               "createdAt":  "2023-08-30T12:53:50Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-01-26T14:21:02Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "govert",
                                           "body":  "I have a question about the [Source Generator COM design doc](https://github.com/dotnet/runtime/blob/main/docs/design/features/source-generator-com.md), and the intended scope of the COM wrappers for `IDispatch` interfaces when integrating with C#.\r\nIn the design doc under **Checkpoint 4: IDispatch compatibility** is stated (my emphasis): \r\n\u003e We do not plan on supporting IDispatch integration with C# dynamic, at least for the first release of the COM source generator. Although the built-in system currently supports it, the integration is primarily used with the PIAs provided for Office, **_which we do not plan on regenerating with this tooling_**.\r\n\r\nThis is the scenario I\u0027m concerned with - creating NativeAOT outputs (add-in libraries or standalone programs) that call Office COM APIs.\r\n\r\nThe problem with a lack of `IDispatch` / `dynamic` integration is not about _regenerating the Office PIA assemblies_ with new tooling, but in _consuming_ them in the same way they are currently used, particularly with the enhanced \u0027embedded PIA\u0027 C# support. This is similar in motivation to an [earlier discussion about the need for `IDispatch` / `dynamic` support](https://github.com/dotnet/runtime/issues/12587) which was then implemented for .NET 5. Is this a limitation of the source generator, the COM Wrappers code or the `dynamic` runtime support infrastructure?\r\n\r\nEven when using a pre-compiled PIA, there are common code patterns that require the `IDispatch` / `dynamic` support in C# to work as expected. For example, will we be able to make this code work in a NativeAOT setting?\r\n```\r\nusing Microsoft.Office.Interop.Excel;\r\n\r\nclass Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        Application app = new Application();\r\n        app.Visible = true;\r\n\r\n        Workbook wb = app.Workbooks.Add();\r\n        wb.Sheets[1].Name = \"FirstSheet\"; \r\n        //        ^^^^ The code in the PIA for the indexed property wb.Sheets[...] returns \"object\"\r\n        //             Under current compiler, with PIA embedding, this compiles and runs as \u0027dynamic\u0027\r\n        //             since that kicks in the dynamic /  IDispatch support.\r\n    }\r\n}\r\n```\r\n\r\nThe one part I can\u0027t see yet (and have not tried myself) is how to fill in, by source generation or extra wrapper code, a way to make calls like the above work when changing to NativeAOT. There are some related quirks around the PIA code and how it is called from C# - for example related to indexed properties (which appear in PIA code and can be called from C# for embedded PIA scenarios but can\u0027t be authored in normal (or source generated) C# code).\r\n\r\nDue to the [.NET versioning limitations for in-process add-ins](https://github.com/dotnet/runtime/issues/49686), we will be stuck on .NET 6 (together with .NET Framework) for making Office add-ins until we have a viable NativeAOT approach. From the discussion around COM Wrappers, and the source generators here, it looks like we will have a comprehensive approach for exposing COM objects from NativeAOT libraries (perhaps with third-party tools like [dscom](https://github.com/dspace-group/dscom) for type library generation). Hence, I want to campaign for a higher priority also for supporting existing C# code that calls COM libraries, unlocked by some plan for `IDispatch` / `dynamic` support.\r\n\r\n",
                                           "updatedAt":  "2022-12-20T19:48:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Ul_dM",
                                           "createdAt":  "2023-02-06T15:14:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carstencodes",
                                           "body":  "Speaking of [dscom](https://github.com/dspace-group/dscom), there is currently the issue, that there is no support for Serializable and Exception, which introduces a strange behavior at runtime even if a COM serializable Exception is thrown. \r\n\r\nThis is due to the fact, that the exception types and serializable implementations in the runtime are not exposed to COM as they were in .NET FullFramework.  ",
                                           "updatedAt":  "2023-02-06T15:14:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5hJeFT",
                                           "createdAt":  "2023-07-10T23:34:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODJHGoA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "CONFUSED",
                                                                               "user":  "PhantomGamers",
                                                                               "createdAt":  "2023-07-10T23:35:44Z"
                                                                           },
                                                                           {
                                                                               "content":  "CONFUSED",
                                                                               "user":  "dacabdi",
                                                                               "createdAt":  "2023-08-18T00:10:14Z"
                                                                           },
                                                                           {
                                                                               "content":  "CONFUSED",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2023-10-10T02:11:23Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "We have completed the features we plan to complete in the .NET 8 timeframe. Moving this Epic to .NET 9 to track any future work we do in this space.",
                                           "updatedAt":  "2023-07-10T23:34:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5lz7RC",
                                           "createdAt":  "2023-09-06T10:48:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD2CNFA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "lukedays",
                                                                               "createdAt":  "2023-09-06T14:36:04Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "expcat",
                                                                               "createdAt":  "2023-09-07T16:24:27Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "Pinox",
                                                                               "createdAt":  "2023-09-08T22:09:34Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "andrewkittredge",
                                                                               "createdAt":  "2023-09-18T13:26:11Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tomap",
                                                                               "createdAt":  "2023-09-18T19:24:15Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "dariuszskwarek",
                                                                               "createdAt":  "2023-10-12T07:47:05Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-01-26T14:22:18Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "StarRiver123",
                                                                               "createdAt":  "2024-10-14T18:20:26Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "StarRiver123",
                                                                               "createdAt":  "2024-10-14T18:20:30Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  9
                                                         },
                                           "author":  "govert",
                                           "body":  "@AaronRobinsonMSFT @jkoritzinsky Could you please help me understand the intended scope of the COM / AOT support in .NET 8 and in near future versions relating to the Office applications (particularly Excel). If I intend for an AOT compiled library to talk to Excel via COM, my current understanding is that\r\n* the ComWrappers helpers provide the only mechanism for interacting with a COM object model when AOT compiled.\r\n* the ComWrappers helpers themselves are rich enough to implement marshalling for all COM scenarios, in both directions - consuming COM object via RCW, and exposing CCW from an AOT .NET library\r\n* there is no support for C# \u0027dynamic\u0027 types under AOT, so even with a manual implementation using ComWrappers, one could not implement the dynamic-style IDispatch integration introduced with the PIA embedding work in .NET 4.0. I.e. there is no way to make a \"MyComDispatch\" type that will be able to implement the PIA embedding style code. Or is the IDispatch / dynamic limitation mentioned here just relating to the source generator?\r\n* for simple COM interface models, the COM source generator could take type definitions that look like those inside a PIA interop assembly, and generate ComWrapper-based marshaling code under .NET 8\r\n* for complicated COM interface models, including those that are IDispatch-rich and with COM Events (like the Office COM models) the .NET 8 generator will provide no or minimal help\r\n* to support the Excel COM object model with .NET 8, we would need to write our own ComWrapper based wrapper library, either by hand or with our own PIA -\u003e ComWrappers code generation implementation\r\n* future versions of .NET are likely to improve the COM source generator scope\r\n\r\nIf we want to do Office interop with .NET 8 AOT, how do you recommend we approach this?\r\n",
                                           "updatedAt":  "2023-09-06T10:48:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5m-mXu",
                                           "createdAt":  "2023-09-20T13:03:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODXK90Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "newonejoe",
                                                                               "createdAt":  "2024-02-18T00:27:19Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "lukedays",
                                           "body":  "@AaronRobinsonMSFT @jkoritzinsky, we\u0027re trying to build wrappers around Excel C/COM APIs ([example project](https://github.com/lukedays/ExcelNativeAot)) it would be very helpful to shed some light on @govert\u0027s questions. Thanks in advance!",
                                           "updatedAt":  "2023-09-20T13:03:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5m_DtV",
                                           "createdAt":  "2023-09-20T14:06:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODinPQg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "govert",
                                                                               "createdAt":  "2023-09-27T09:41:28Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-05-21T15:48:41Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e * the ComWrappers helpers provide the only mechanism for interacting with a COM object model when AOT compiled.\r\n\u003e * the ComWrappers helpers themselves are rich enough to implement marshalling for all COM scenarios, in both directions - consuming COM object via RCW, and exposing CCW from an AOT .NET library\r\n\r\nCorrect.\r\n\r\n\u003e * there is no support for C# \u0027dynamic\u0027 types under AOT, so even with a manual implementation using ComWrappers, one could not implement the dynamic-style IDispatch integration introduced with the PIA embedding work in .NET 4.0. I.e. there is no way to make a \"MyComDispatch\" type that will be able to implement the PIA embedding style code. Or is the IDispatch / dynamic limitation mentioned here just relating to the source generator?\r\n\r\nThere is no built-in support, but one could imagine an AOT scenario where all the known `IDispatch` based interfaces were known and retain them. This isn\u0027t something the .NET team is keen to support at present and we are deferring to the community and up-stack teams to add the appropriate marshallers. For example, WinForms will need some support here, but they are in the process of determining how they want to express that. The .NET team is looking at providing a in-box [`VARIANT` marshaller](https://github.com/dotnet/runtime/issues/89543). Something like `SAFEARRAY` or `IRecordInfo` though is going to be much harder to justify from the runtime side. Both are possible, but we need a substantial business case to take on that effort. We are very open to community proposed marshallers though, feel free to propose needed APIs.\r\n\r\n\u003e * for simple COM interface models, the COM source generator could take type definitions that look like those inside a PIA interop assembly, and generate ComWrapper-based marshaling code under .NET 8\r\n\r\nYes.\r\n\r\n\u003e * for complicated COM interface models, including those that are IDispatch-rich and with COM Events (like the Office COM models) the .NET 8 generator will provide no or minimal help\r\n\r\nYes.\r\n\r\n\u003e * to support the Excel COM object model with .NET 8, we would need to write our own ComWrapper based wrapper library, either by hand or with our own PIA -\u003e ComWrappers code generation implementation\r\n\r\nThe interfaces would currently need to be redefined using [`GeneratedComInterface`](https://learn.microsoft.com/dotnet/api/system.runtime.interopservices.marshalling.generatedcominterfaceattribute). If these are `IDispatch` based, a definition of `IDispatch` would also need to be defined.\r\n\r\n\u003e * future versions of .NET are likely to improve the COM source generator scope\r\n\r\nYes, but narrowly. Support for `IDispatch` in-box will likely be a very low priority for the .NET interop team. We want to provide the tools we can, but providing a full solution is incredibly expensive and Office\u0027s focus on .NET has shifted considerably so has become lower priority.\r\n\r\n\u003e If we want to do Office interop with .NET 8 AOT, how do you recommend we approach this?\r\n\r\nRedefine the needed interfaces using `GeneratedComInterface` and start implementing them.\r\n\r\n",
                                           "updatedAt":  "2023-09-20T14:06:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5n1iY4",
                                           "createdAt":  "2023-10-01T13:47:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODUTZQQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "FelipeCostaGualberto",
                                                                               "createdAt":  "2024-01-27T11:43:26Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "govert",
                                           "body":  "@AaronRobinsonMSFT Thank you very much for the reply and setting our expectations for the current COM / AOT support.\r\n\r\nFor the COM objects we need to expose as CCWs to Excel (e.g. to support Ribbon extensions or real-time data sources) we would need to implement the `IDispatch` support, but only for classes known at compile time and relatively friendly signatures. Consuming the Office object models, including events, seems more daunting, especially if we want to end up in the post-.NET 4.0 world where COM worked easily from C# due to the improved compiler integration.\r\n\r\nCould you please clarify the status of the C# \u0027dynamic\u0027 infrastructure under Native AOT?\r\nExpression trees seem to work under AOT. However, adding simple \u0027dynamic\u0027 expressions compiles to a larger binary, but then crashes when called. Is this a trimming problem, or totally unsupported? (I do recall some post-RC2 issue that might be related but can\u0027t find it again.)\r\n\r\nI\u0027m trying to understand whether one might revisit the work from https://github.com/dotnet/runtime/pull/33060 (which implements the COM / dynamic binder support), but replace the built-in COM features with ComWrappers. It might help to focus on the (hopefully) simpler cases that the Office COM model requires. But this would still need to the C# dynamic binder to work under AOT against the user-code implemented \u0027RCW\u0027s.\r\n\r\nFor reference (please redirect if this is off-topic), here\u0027s a snippet where runtime expression trees work, but `dynamic` fails:\r\n```c#\r\nusing System.Linq.Expressions;\r\n\r\nConsole.WriteLine(\"Hello, World!\");\r\n\r\n// This works under NativeAOT\r\nvar lambda2 = Expression.Lambda(\r\n    Expression.Add(\r\n        Expression.Constant(1.3, typeof(double)),\r\n        Expression.Constant(2.7, typeof(double))\r\n    )\r\n);\r\nFunc\u003cdouble\u003e getResult = (Func\u003cdouble\u003e)lambda2.Compile();\r\nConsole.WriteLine(getResult());\r\n\r\n// This crashes under NativeAOT\r\ndynamic d1 = 1.3;\r\ndynamic d2 = 2.7;\r\ndouble d = (double)(d1 + d2); // \u003c\u003c\u003c\u003c\u003c NRE or access violation here\r\nConsole.WriteLine(d);\r\n```\r\n\r\n![image](https://github.com/dotnet/runtime/assets/414659/1335c8d3-bab6-421c-b6b9-4abdd9384087)\r\n",
                                           "updatedAt":  "2023-10-01T13:47:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5n1zwX",
                                           "createdAt":  "2023-10-01T18:18:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "```\r\n// This crashes under NativeAOT\r\ndynamic d1 = 1.3;\r\ndynamic d2 = 2.7;\r\ndouble d = (double)(d1 + d2); // \u003c\u003c\u003c\u003c\u003c NRE or access violation here\r\nConsole.WriteLine(d);\r\n```\r\n\r\n`dynamic` does not work with trimming and AOT. You should see warnings like this when building this snippet. \r\n\r\n```\r\nC:\\repro\\Program.cs(4): Trim analysis warning IL2026: Program.\u003cMain\u003e$(String[]): Using member \u0027Microsoft.CSharp.Runtime\r\nBinder.Binder.Convert(CSharpBinderFlags,Type,Type)\u0027 which has \u0027RequiresUnreferencedCodeAttribute\u0027 can break functionali\r\nty when trimming application code. Using dynamic types might cause types or members to be removed by trimmer. [C:\\repro\r\n\\repro.csproj]\r\nC:\\repro\\Program.cs(4): Trim analysis warning IL2026: Program.\u003cMain\u003e$(String[]): Using member \u0027Microsoft.CSharp.Runtime\r\nBinder.Binder.BinaryOperation(CSharpBinderFlags,ExpressionType,Type,IEnumerable`1\u003cCSharpArgumentInfo\u003e)\u0027 which has \u0027Requ\r\niresUnreferencedCodeAttribute\u0027 can break functionality when trimming application code. Using dynamic types might cause\r\ntypes or members to be removed by trimmer. [C:\\repro\\repro.csproj]\r\n```",
                                           "updatedAt":  "2023-10-01T18:18:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5n11lj",
                                           "createdAt":  "2023-10-01T18:49:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "govert",
                                           "body":  "@jkotas Indeed I do get such warnings, both for the `dynamic` code that fails at runtime, and also for the expression trees that work (in this case). Evidently the add method we\u0027re trying to invoke is not trimmed, nor is (all of) the binder infrastructure.\r\n\r\nI suppose my question is whether `dynamic` is completely unsupported under AOT, or could one somehow give trimming hints to make it work? In our COM case we might know what binders and related code would be needed, so could generate hints if there is a way.",
                                           "updatedAt":  "2023-10-01T18:49:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5n12V2",
                                           "createdAt":  "2023-10-01T19:01:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "You can make it work by providing trimming and AOT hints, but it is very error prone. We do not recommend it.",
                                           "updatedAt":  "2023-10-01T19:01:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5n17uO",
                                           "createdAt":  "2023-10-01T20:24:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "govert",
                                           "body":  "To confuse things more, the `dynamic` code runs fine with \u0027full\u0027 trimming, single file, but no AOT, using these settings:\r\n\r\n```\r\n    \u003cPublishAot\u003efalse\u003c/PublishAot\u003e\r\n    \u003cPublishSingleFile\u003etrue\u003c/PublishSingleFile\u003e\r\n    \u003cPublishTrimmed\u003etrue\u003c/PublishTrimmed\u003e\r\n    \u003cSelfContained\u003etrue\u003c/SelfContained\u003e\r\n    \u003cTrimMode\u003efull\u003c/TrimMode\u003e\r\n    \u003cDynamicCodeSupport\u003efalse\u003c/DynamicCodeSupport\u003e\r\n    \u003cEventSourceSupport\u003efalse\u003c/EventSourceSupport\u003e\r\n        \r\n```\r\n\r\nShould we expect code to fail with AOT when it is working with this configuration?\r\n\r\n",
                                           "updatedAt":  "2023-10-01T20:24:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5n1_TF",
                                           "createdAt":  "2023-10-01T21:23:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Trim warnings indicate that some code may not work as expected after trimming. The trimmed app can work today and start failing after next .NET SDK update. It can work with JIT and fail with native AOT. This unpredictable behavior is by-design.",
                                           "updatedAt":  "2023-10-01T21:23:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5uoWmx",
                                           "createdAt":  "2023-12-14T15:35:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD8GDhg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "thenextman",
                                                                               "createdAt":  "2023-12-14T15:39:07Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "snechaev",
                                                                               "createdAt":  "2023-12-14T15:42:42Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "TheBestTvarynka",
                                                                               "createdAt":  "2023-12-14T16:16:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-05-21T15:57:06Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "StarRiver123",
                                                                               "createdAt":  "2024-11-22T14:12:18Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  5
                                                         },
                                           "author":  "awakecoding",
                                           "body":  "Hi! I\u0027d like to add to this list of work items [the need to properly support ActiveX interop bindings](https://twitter.com/jkortech/status/1735115229233893455) - the ones generated by aximp.exe on top of the COM interop bindings generated by tlbimp.exe in current .NET build tooling.\r\n\r\nWe need this in [Remote Desktop Manager](https://devolutions.net/remote-desktop-manager/) for the [Microsoft RDP ActiveX control](https://learn.microsoft.com/en-us/windows/win32/termserv/remote-desktop-activex-control) on Windows, the *only* exhaustive interface for third-party integration of the first-party RDP client. Even if we integrate FreeRDP, a project which I have created years ago, it will likely never reach 100% feature parity with the original, so customers really want the option to use official RDP client. For this reason, continued support for the RDP ActiveX control in .NET is business critical to us, as RDP is the most important protocol we support in our product.\r\n\r\nThis being said, we still ship .NET with regular JIT assemblies, so we\u0027re not in a rush to try Native AOT. However, the Remote Desktop Manager application startup time is an annoyance we\u0027ve had since forever, so I would be lying if I didn\u0027t at least have my eye on experimenting with Native AOT for Remote Desktop Manager at some point in the future. I\u0027m just looking at what would be blocking it, and lack of RDP ActiveX support would be a non-starter for us for the reasons listed above.\r\n\r\nEnough of the business aspect of things: when it comes to the RDP ActiveX, [I maintain MsRdpEx](https://github.com/Devolutions/MsRdpEx), a project which extends the original RDP ActiveX with additional features our customers need, but Microsoft doesn\u0027t provide. The RDP ActiveX is probably the most widely used ActiveX component in .NET today, and you\u0027ll find AxMSTSCLib.dll, MSTSCLib.dll in a lot of Windows .NET applications that use RDP.\r\n\r\nWe ship [a code signed nuget package](https://www.nuget.org/packages/Devolutions.MsRdpEx) with everything needed to load and use the Microsoft RDP ActiveX component from .NET, which includes the ability [for manual COM activation of the ActiveX DLL by path](https://github.com/Devolutions/MsRdpEx/blob/master/dotnet/AxInterop.MSTSCLib/RdpAxHost.cs). COM Activation is mentioned earlier - we need manual COM Active by DLL path to load rdclientax.dll from MSRDC, which contains an unregistered RDP ActiveX interface compatible with the one from mstscax.dll. Even then, being able to load COM interfaces without registration is a huge plus, and in this case, it allows us to load *both* mstscax.dll and rdclientax.dll on a per-session basis inside Remote Desktop Manager, based on connection preferences.\r\n\r\nAs for the build tooling, I took notes on how to [regenerate everything from the type library for both C# and C/C++](https://github.com/Devolutions/MsRdpEx/tree/master/com). This should come in handy when comparing the old tooling with the new for experimentation. While aximp.exe has a way to generate source code, tlbimp.exe only generates an assembly straight as MSIL, which unfortunately doesn\u0027t decompile to clean C# code with tools like ILSpy. This currently limits the ability to control how the assembly is built, and it has annoying things like [a hardcoded reference to net40 as the target framework](https://twitter.com/awakecoding/status/1483474374241959941). It doesn\u0027t break the build, but it does cause build warnings, even if the assembly is in fact compatible with modern .NET.\r\n\r\nAs for the ActiveX interop method, one can do [dynamic calls through IDispatch, or call the vtable functions directly](https://learn.microsoft.com/en-us/previous-versions/windows/desktop/automat/activex-client-and-object-interaction). In the case of the RDP ActiveX, I am fairly certainly that the calls are always done through vtable with the generated interop bindings. I don\u0027t know of an ActiveX component that would not support the vtable calls, and even then, it would still be possible to generate stubs wrapping IDispatch if it\u0027s ever needed. However, for our needs, we are more than happy to use the vtable calls without the runtime calling through IDispatch, it\u0027s much faster anyway.\r\n\r\nLast but not least: the ActiveX bindings are meant to be consumed by WinForms. We\u0027re WinForms users, and we\u0027d like to keep using WinForms in the future. I don\u0027t mind if the new build tooling can generate ActiveX bindings for other .NET UI frameworks, but it would be important to coordinate with the WinForms team to ensure compatibility of the newer bindings.\r\n\r\nOne last thing: when adding ActiveX components in WinForms from Visual Studio, it generates a .resx with a serialized BinaryFormatter [OcxState object](https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.axhost.ocxstate?view=windowsdesktop-8.0) which is then loaded in the designer-generated source code. Needless to say that this causes deprecation warnings in .NET 8 as this kind of object serialization is scheduled to be entirely removed in .NET 9. I manually deleted those resources and set OcxState to null in the designer-generated source code, it didn\u0027t seem to cause problems. However, someone from the Visual Studio team should definitely look into fixing this issue in the WinForms designer. I have no idea what this OcxState object is used for, and how to create it dynamically instead of deserializing it from a resource.\r\n\r\nI hope this clarifies the need for modernized ActiveX support in .NET! Feel free to reach out for any assistance, I\u0027ll be happy to help.",
                                           "updatedAt":  "2023-12-14T15:41:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5uodP9",
                                           "createdAt":  "2023-12-14T15:51:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODPndCA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "awakecoding",
                                                                               "createdAt":  "2023-12-14T15:54:03Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "weltkante",
                                           "body":  "\u003e I have no idea what this OcxState object is used for, and how to create it dynamically instead of deserializing it from a resource.\r\n\r\nIts serialized state of the ActiveX control, basically a binary blob for the control to store whatever designer state it wants to preserve to runtime thats not configurable through control properties. More complex ActiveX controls may have custom UI to configure things instead of just using properties. If you don\u0027t provide one when instantiating it the control implicitely uses default state, which should work fine as long as you didn\u0027t configure anything in the designer of the ActiveX control that affected its internal state.\r\n\r\nIt should be possible for the new designer to just store it as a byte array or something along those lines.",
                                           "updatedAt":  "2023-12-14T15:53:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5uol0g",
                                           "createdAt":  "2023-12-14T16:12:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "weltkante",
                                           "body":  "@awakecoding I took a look at the TLB through the oleview tool (shows the IDL source for a TLB, is part of the Windows SDK installed by VS) and it doesn\u0027t look very complicated, should be possible to write the interop manually for me. Is there an open source example for Desktop Framework using that ActiveX control? I\u0027d consider doing a proof of concept port if you want to see how well it works in .NET 8 - I\u0027ve been working with the WinForms project in the past to improve interop support and having another ActiveX control thats used in practice could help interop quality, we\u0027ve been struggling to find relevant usecases to test the ActiveX support against last I worked with them.\r\n\r\nPS: feel free to take the conversation about a PoC to somewhere else on git (if you have a project), or to mail (see my git profile), to not get offtopic on this one",
                                           "updatedAt":  "2023-12-14T16:12:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5uopna",
                                           "createdAt":  "2023-12-14T16:21:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODPnpiQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "weltkante",
                                                                               "createdAt":  "2023-12-14T16:22:39Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "awakecoding",
                                           "body":  "@weltkante I have a sample .NET application just to test the .NET interop, it\u0027s nothing fancy [but it\u0027s there in the MsRdpEx repository](https://github.com/Devolutions/MsRdpEx/tree/master/dotnet/MsRdpEx_App). I have build instructions for MsRdpEx, it\u0027s not too difficult to get started, and I\u0027d be happy to assist with experiments on that repository if you want to take the discussion there. I would welcome an experimentation branch from you if you have an idea how to try it! You can also [reach me on Twitter/X](https://twitter.com/awakecoding).",
                                           "updatedAt":  "2023-12-14T16:21:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5v6VBd",
                                           "createdAt":  "2024-01-04T18:21:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "weltkante",
                                           "body":  "It is a bit disappointing that properties aren\u0027t supported at all by COM source generators. This makes it impossible to use generated interop as a (mostly) source-compatible drop-in replacement. It would definitely be desireable to consider property support for the future, maybe annotate the property methods with an attribute if you need it to define VTable position. [I saw something](https://github.com/dotnet/runtime/blob/main/docs/design/libraries/ComInterfaceGenerator/VTableStubs.md#defined-types) about a `VirtualMethodIndexAttribute` but it doesn\u0027t seem to be available in .NET 8 so I suppose its a .NET 9 thing, or am I missing something? Maybe that kind of attribute could be used for property support if its not possible to automatically order the setter/getter in order of source as the old interop did? (Whether you write `{ set; get; }` or `{ get; set; }` is significant for the old interop since it generates methods in different vtable order.)",
                                           "updatedAt":  "2024-01-04T18:25:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5v6Whs",
                                           "createdAt":  "2024-01-04T18:26:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD7NdpA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "weltkante",
                                                                               "createdAt":  "2024-01-04T18:28:19Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "StarRiver123",
                                                                               "createdAt":  "2024-11-17T04:56:43Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e It is a bit disappointing that properties aren\u0027t supported at all by COM source generators.\r\n\r\nAll part of a V1 release. I think it is worth having the conversation in .NET 9. I don\u0027t think we have an issue for property support, @jkoritzinsky?",
                                           "updatedAt":  "2024-01-04T18:26:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5v6XPI",
                                           "createdAt":  "2024-01-04T18:29:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD2CQIA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "StarRiver123",
                                                                               "createdAt":  "2024-10-14T18:28:29Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "I don\u0027t think we have one yet. I\u0027ll open one today.\r\n\r\nEdit: Opened at https://github.com/dotnet/runtime/issues/96502",
                                           "updatedAt":  "2024-01-04T18:55:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6T3_LC",
                                           "createdAt":  "2024-11-17T05:02:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEPLOKw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "snechaev",
                                                                               "createdAt":  "2024-11-17T05:07:56Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-11-17T14:38:57Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "StarRiver123",
                                                                               "createdAt":  "2024-11-17T15:23:56Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "expcat",
                                                                               "createdAt":  "2024-11-20T02:22:37Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kingcomxu",
                                                                               "createdAt":  "2024-12-27T02:21:08Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "OptiStrat",
                                                                               "createdAt":  "2024-12-27T11:05:12Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "mdeme",
                                                                               "createdAt":  "2025-01-09T17:15:20Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "teta2k",
                                                                               "createdAt":  "2025-01-13T11:45:24Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "peaceshi",
                                                                               "createdAt":  "2025-01-13T12:27:04Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "bizouarn",
                                                                               "createdAt":  "2025-01-22T16:57:32Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CamusGao",
                                                                               "createdAt":  "2025-04-22T06:52:18Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  11
                                                         },
                                           "author":  "StarRiver123",
                                           "body":  "Many developers have a lot of demands for using tlb lib import  in AOT ,  but it is not supported in Net9.  I believe  this will  be popular when it is supported.   Is there  a plan  to support it  in .Net10?  @jkoritzinsky? @alexrp @awakecoding @lukedays @govert @agocke ",
                                           "updatedAt":  "2024-12-01T16:21:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6aL0F3",
                                           "createdAt":  "2025-01-13T10:57:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEDSZYA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "snechaev",
                                                                               "createdAt":  "2025-01-13T11:00:00Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "moormaster",
                                                                               "createdAt":  "2025-01-13T11:39:40Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "teta2k",
                                                                               "createdAt":  "2025-01-13T11:45:25Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "peaceshi",
                                                                               "createdAt":  "2025-01-13T12:27:04Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2025-01-13T19:00:22Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "StarRiver123",
                                                                               "createdAt":  "2025-01-14T10:00:20Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "expcat",
                                                                               "createdAt":  "2025-01-20T17:26:13Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  7
                                                         },
                                           "author":  "StarRiver123",
                                           "body":  "Checkpoint 4 and 5  is very important and it can be more efficient for developing desktop app .   Can it be  completed in  Net10?",
                                           "updatedAt":  "2025-01-14T09:08:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6bAmXP",
                                           "createdAt":  "2025-01-19T05:41:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "StarRiver123",
                                           "body":  "\u003e \u003e It is a bit disappointing that properties aren\u0027t supported at all by COM source generators.\n\u003e \n\u003e All part of a V1 release. I think it is worth having the conversation in .NET 9. I don\u0027t think we have an issue for property support, [@jkoritzinsky](https://github.com/jkoritzinsky)?\n\nyes ,it is worthy",
                                           "updatedAt":  "2025-01-19T05:41:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6bBnC8",
                                           "createdAt":  "2025-01-19T14:44:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEDmNHA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "bizouarn",
                                                                               "createdAt":  "2025-01-22T16:57:47Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "colejohnson66",
                                           "body":  "The fact that one *still* can’t use Excel COM interop out-of-the-box in .NET Core/modern .NET, despite being the successor to .NET Framework for almost half a decade, is quite illogical.\n\nTo avoid having to use .NET Framework MSBuild every time, we had to hack out the three interop DLLs (Excel, `stdole.dll`, and something else), then manually reference them in the project.\n\nThe fact that .NET’s MSBuild is the same code as .NET Framework’s, but has COM TLB support compiled out is also annoying.",
                                           "updatedAt":  "2025-01-19T14:51:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6cKm7Q",
                                           "createdAt":  "2025-01-28T20:48:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "govert",
                                           "body":  "@colejohnson66 \nFor the Excel COM Interop you can reference the \u0027ExcelDna.Interop\u0027 NuGet package.\nThis gives you the right references and works fine from SDK-style project files that target .NET core.\nIt contains the Excel 15.0 PIA assemblies, and a .targets file to sort out the build.",
                                           "updatedAt":  "2025-01-28T20:48:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6oYzL8",
                                           "createdAt":  "2025-04-23T17:49:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEbIpiQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "snechaev",
                                                                               "createdAt":  "2025-04-23T19:09:45Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2025-07-18T18:45:00Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "f-rich",
                                           "body":  "Where do I \u0027vote\u0027 for IDispatch (to enable late binding) support ;-)",
                                           "updatedAt":  "2025-04-23T17:49:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6onMSa",
                                           "createdAt":  "2025-04-24T20:59:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEV1YQw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "govert",
                                                                               "createdAt":  "2025-06-08T17:03:56Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "mqudsi",
                                           "body":  "Is there a plan to add event support to `[ComGeneratedInterface]` source generators? I couldn\u0027t find an open ticket tracking that feature.\n\nWhile property support is still not in .NET 9, it can be worked around *fairly* trivially by using `FooType get_Foo()` and `void set_Foo(FooType value)` in its place in your `[GeneratedComInterface]`-annotated interface interop definitions. However manually generating the equivalent code to expose events for COM interop is much more gnarly and requires defining a separate COM interfaces for each event and setting up the connection point machinery.",
                                           "updatedAt":  "2025-04-24T20:59:27Z"
                                       }
                                   ],
                         "totalCount":  34
                     },
        "title":  "Provide a COM source generator",
        "labels":  [
                       "Epic",
                       "area-System.Runtime.InteropServices",
                       "tracking",
                       "Bottom Up Work"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/68926",
        "createdAt":  "2022-05-05T18:12:01Z",
        "number":  68926,
        "author":  "tannergooding",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-04T20:34:31Z",
        "body":  "### Rationale\r\n\r\nIn https://github.com/dotnet/runtime/issues/13788 we exposed some new interchange types `CLong`, `CULong`, and `NFloat` to help ensure interop with underlying runtimes could be done in a stable and cross platform manner.\r\n\r\nWe initially decided that these should not expose more complex support such as operators, parsing, or formatting. However, we then backtracked on this decision for `NFloat` with https://github.com/dotnet/runtime/issues/63801 so Xamarin would no longer need to maintain their own type.\r\n\r\n`CLong` and `CULong` are used in many similar scenarios and so deserve similar treatment. Likewise, this fits in with the general `generic-math` theme and treats them as first class number types that can play into users existing code and algorithms.\r\n\r\n### Proposal\r\n\r\nThis was extracted out of https://github.com/dotnet/designs/pull/262 and covers the generic-math interfaces and whether they are implicitly or explicitly implemented\r\n\r\n```csharp\r\nnamespace System.Runtime.InteropServices;\r\n\r\npublic struct CLong\r\n    : IBinaryInteger\u003cCLong\u003e,\r\n      IMinMaxValue\u003cCLong\u003e,\r\n      ISignedNumber\u003cCLong\u003e\r\n{\r\n    // Explicitly implemented interfaces\r\n    // * IAdditiveIdentity\r\n    //   * TSelf AdditiveIdentity { get; }\r\n    // * IMultiplicativeIdentity\r\n    //   * TSelf MultiplicativeIdentity { get; }\r\n    // * INumberBase\r\n    //   * One { get; }\r\n    //   * Zero { get; }\r\n    // * ISignedNumber\r\n    //   * TSelf NegativeOne { get; }\r\n\r\n    // Implicitly Implemented interfaces\r\n    // * IMinMaxValue\r\n    //   * TSelf MaxValue { get; }\r\n    //   * TSelf MinValue { get; }\r\n    //\r\n    // * IAdditionOperators\r\n    //   * TSelf operator +(TSelf, TSelf)\r\n    //   * TSelf operator checked +(TSelf, TSelf)\r\n    // * IBitwiseOperators\r\n    //   * TSelf operator \u0026(TSelf, TSelf)\r\n    //   * TSelf operator |(TSelf, TSelf)\r\n    //   * TSelf operator ^(TSelf, TSelf)\r\n    //   * TSelf operator ~(TSelf)\r\n    // * IComparisonOperators\r\n    //   * bool operator \u003c(TSelf, TSelf)\r\n    //   * bool operator \u003c=(TSelf, TSelf)\r\n    //   * bool operator \u003e(TSelf, TSelf)\r\n    //   * bool operator \u003e=(TSelf, TSelf)\r\n    // * IDecrementOperators\r\n    //   * TSelf operator --(TSelf)\r\n    //   * TSelf operator checked --(TSelf)\r\n    // * IDivisionOperators\r\n    //   * TSelf operator /(TSelf, TSelf)\r\n    //   * TSelf operator checked /(TSelf, TSelf)\r\n    // * IIncrementOperators\r\n    //   * TSelf operator ++(TSelf)\r\n    //   * TSelf operator checked ++(TSelf)\r\n    // * IModulusOperators\r\n    //   * TSelf operator %(TSelf, TSelf)\r\n    // * IMultiplyOperators\r\n    //   * TSelf operator *(TSelf, TSelf)\r\n    //   * TSelf operator checked *(TSelf, TSelf)\r\n    // * IShiftOperators\r\n    //   * TSelf operator \u003c\u003c(TSelf, int)\r\n    //   * TSelf operator \u003e\u003e(TSelf, int)\r\n    //   * TSelf operator \u003e\u003e\u003e(TSelf, int)\r\n    // * ISubtractionOperators\r\n    //   * TSelf operator -(TSelf, TSelf)\r\n    //   * TSelf operator checked -(TSelf, TSelf)\r\n    // * IUnaryNegationOperators\r\n    //   * TSelf operator -(TSelf)\r\n    //   * TSelf operator checked -(TSelf)\r\n    // * IUnaryPlusOperators\r\n    //   * TSelf operator +(TSelf)\r\n    //\r\n    // * IBinaryInteger\r\n    //   * (TSelf, TSelf) DivRem(TSelf, TSelf)\r\n    //   * int GetShortestByteCount()                                                   // ? Explicit\r\n    //   * long GetShortestBitLength()                                                  // ? Explicit\r\n    //   * TSelf LeadingZeroCount(TSelf)\r\n    //   * TSelf PopCount(TSelf)\r\n    //   * TSelf RotateLeft(TSelf, int)\r\n    //   * TSelf RotateRight(TSelf, int)\r\n    //   * TSelf TrailingZeroCount(TSelf)\r\n    //   * bool TryWriteLittleEndian(byte[], out int)                                   // ? Explicit\r\n    //   * int WriteLittleEndian(byte[])                                                // ? Explicit\r\n    //   * int WriteLittleEndian(byte[], int)                                           // ? Explicit\r\n    //   * int WriteLittleEndian(Span\u003cbyte\u003e)                                            // ? Explicit\r\n    // * IBinaryNumber\r\n    //   * bool IsPow2(TSelf)\r\n    //   * TSelf Log2(TSelf)\r\n    // * IComparable\r\n    //   * int CompareTo(object?)\r\n    //   * int CompareTo(TSelf)\r\n    // * IEqualityOperators\r\n    //   * bool operator ==(TSelf, TSelf)                                               // * Existing\r\n    //   * bool operator !=(TSelf, TSelf)                                               // * Existing\r\n    // * IEquatable                                                                     // Existing\r\n    //   * bool Equals(TSelf)                                                           // * Existing\r\n    // * IFormattable\r\n    //   * string ToString(string?, IFormatProvider?)\r\n    // * INumber\r\n    //   * TSelf Abs(TSelf)\r\n    //   * TSelf Clamp(TSelf, TSelf, TSelf)\r\n    //   * TSelf CopySign(TSelf, TSelf)\r\n    //   * TSelf CreateChecked(TOther)\r\n    //   * TSelf CreateSaturating(TOther)\r\n    //   * TSelf CreateTruncating(TOther)\r\n    //   * bool IsFinite(TSelf)                                                         // ? Explicit\r\n    //   * bool IsInfinity(TSelf)                                                       // ? Explicit\r\n    //   * bool IsNaN(TSelf)                                                            // ? Explicit\r\n    //   * bool IsNegative(TSelf)\r\n    //   * bool IsNegativeInfinity(TSelf)                                               // ? Explicit\r\n    //   * bool IsNormal(TSelf)                                                         // ? Explicit\r\n    //   * bool IsPositive(TSelf)\r\n    //   * bool IsPositiveInfinity(TSelf)                                               // ? Explicit\r\n    //   * bool IsSubnormal(TSelf)                                                      // ? Explicit\r\n    //   * TSelf Max(TSelf, TSelf)\r\n    //   * TSelf MaxMagnitude(TSelf, TSelf)\r\n    //   * TSelf MaxMagnitudeNumber(TSelf, TSelf)                                       // ? Explicit\r\n    //   * TSelf MaxNumber(TSelf, TSelf)                                                // ? Explicit\r\n    //   * TSelf Min(TSelf, TSelf)\r\n    //   * TSelf MinMagnitude(TSelf, TSelf)\r\n    //   * TSelf MinMagnitudeNumber(TSelf, TSelf)                                       // ? Explicit\r\n    //   * TSelf MinNumber(TSelf, TSelf)                                                // ? Explicit\r\n    //   * TSelf Parse(string, NumberStyles, IFormatProvider?)\r\n    //   * TSelf Parse(ReadOnlySpan\u003cchar\u003e, NumberStyles, IFormatProvider?)\r\n    //   * int Sign(TSelf)\r\n    //   * bool TryCreate(TOther, out TSelf)\r\n    //   * bool TryParse(string?, NumberStyles, IFormatProvider?, out TSelf)\r\n    //   * bool TryParse(ReadOnlySpan\u003cchar\u003e, NumberStyles, IFormatProvider?, out TSelf)\r\n    // * IParsable\r\n    //   * TSelf Parse(string, IFormatProvider?)\r\n    //   * bool TryParse(string?, IFormatProvider?, out TSelf)\r\n    // * ISpanFormattable\r\n    //   * bool TryFormat(Span\u003cchar\u003e, out int, ReadOnlySpan\u003cchar\u003e, IFormatProvider?)\r\n    // * ISpanParsable\r\n    //   * TSelf Parse(ReadOnlySpan\u003cchar\u003e, IFormatProvider?)\r\n    //   * bool TryParse(ReadOnlySpan\u003cchar\u003e, IFormatProvider?, out TSelf)\r\n}\r\n\r\npublic struct CULong\r\n    : IBinaryInteger\u003cCULong\u003e,\r\n      IMinMaxValue\u003cCULong\u003e,\r\n      IUnsignedNumber\u003cCULong\u003e\r\n{\r\n    // Explicitly implemented interfaces\r\n    // * IAdditiveIdentity\r\n    //   * TSelf AdditiveIdentity { get; }\r\n    // * IMultiplicativeIdentity\r\n    //   * TSelf MultiplicativeIdentity { get; }\r\n    // * INumberBase\r\n    //   * One { get; }\r\n    //   * Zero { get; }\r\n\r\n    // Implicitly Implemented interfaces\r\n    // * IMinMaxValue\r\n    //   * TSelf MaxValue { get; }\r\n    //   * TSelf MinValue { get; }\r\n    //\r\n    // * IAdditionOperators\r\n    //   * TSelf operator +(TSelf, TSelf)\r\n    //   * TSelf operator checked +(TSelf, TSelf)\r\n    // * IBitwiseOperators\r\n    //   * TSelf operator \u0026(TSelf, TSelf)\r\n    //   * TSelf operator |(TSelf, TSelf)\r\n    //   * TSelf operator ^(TSelf, TSelf)\r\n    //   * TSelf operator ~(TSelf)\r\n    // * IComparisonOperators\r\n    //   * bool operator \u003c(TSelf, TSelf)\r\n    //   * bool operator \u003c=(TSelf, TSelf)\r\n    //   * bool operator \u003e(TSelf, TSelf)\r\n    //   * bool operator \u003e=(TSelf, TSelf)\r\n    // * IDecrementOperators\r\n    //   * TSelf operator --(TSelf)\r\n    //   * TSelf operator checked --(TSelf)\r\n    // * IDivisionOperators\r\n    //   * TSelf operator /(TSelf, TSelf)\r\n    //   * TSelf operator checked /(TSelf, TSelf)\r\n    // * IIncrementOperators\r\n    //   * TSelf operator ++(TSelf)\r\n    //   * TSelf operator checked ++(TSelf)\r\n    // * IModulusOperators\r\n    //   * TSelf operator %(TSelf, TSelf)\r\n    // * IMultiplyOperators\r\n    //   * TSelf operator *(TSelf, TSelf)\r\n    //   * TSelf operator checked *(TSelf, TSelf)\r\n    // * IShiftOperators\r\n    //   * TSelf operator \u003c\u003c(TSelf, int)\r\n    //   * TSelf operator \u003e\u003e(TSelf, int)\r\n    //   * TSelf operator \u003e\u003e\u003e(TSelf, int)\r\n    // * ISubtractionOperators\r\n    //   * TSelf operator -(TSelf, TSelf)\r\n    //   * TSelf operator checked -(TSelf, TSelf)\r\n    // * IUnaryNegationOperators\r\n    //   * TSelf operator -(TSelf)\r\n    //   * TSelf operator checked -(TSelf)\r\n    // * IUnaryPlusOperators\r\n    //   * TSelf operator +(TSelf)\r\n    //\r\n    // * IBinaryInteger\r\n    //   * (TSelf, TSelf) DivRem(TSelf, TSelf)\r\n    //   * int GetByteCount()                                                           // ? Explicit\r\n    //   * long GetShortestBitLength()                                                  // ? Explicit\r\n    //   * TSelf LeadingZeroCount(TSelf)\r\n    //   * TSelf PopCount(TSelf)\r\n    //   * TSelf RotateLeft(TSelf, int)\r\n    //   * TSelf RotateRight(TSelf, int)\r\n    //   * TSelf TrailingZeroCount(TSelf)\r\n    //   * bool TryWriteLittleEndian(byte[], out int)                                   // ? Explicit\r\n    //   * int WriteLittleEndian(byte[])                                                // ? Explicit\r\n    //   * int WriteLittleEndian(byte[], int)                                           // ? Explicit\r\n    //   * int WriteLittleEndian(Span\u003cbyte\u003e)                                            // ? Explicit\r\n    // * IBinaryNumber\r\n    //   * bool IsPow2(TSelf)\r\n    //   * TSelf Log2(TSelf)\r\n    // * IComparable\r\n    //   * int CompareTo(object?)\r\n    //   * int CompareTo(TSelf)\r\n    // * IEqualityOperators\r\n    //   * bool operator ==(TSelf, TSelf)                                               // * Existing\r\n    //   * bool operator !=(TSelf, TSelf)                                               // * Existing\r\n    // * IEquatable                                                                     // Existing\r\n    //   * bool Equals(TSelf)                                                           // * Existing\r\n    // * IFormattable\r\n    //   * string ToString(string?, IFormatProvider?)\r\n    // * INumber\r\n    //   * TSelf Abs(TSelf)                                                             // ? Explicit\r\n    //   * TSelf Clamp(TSelf, TSelf, TSelf)\r\n    //   * TSelf CopySign(TSelf, TSelf)                                                 // ? Explicit\r\n    //   * TSelf CreateChecked(TOther)\r\n    //   * TSelf CreateSaturating(TOther)\r\n    //   * TSelf CreateTruncating(TOther)\r\n    //   * bool IsFinite(TSelf)                                                         // ? Explicit\r\n    //   * bool IsInfinity(TSelf)                                                       // ? Explicit\r\n    //   * bool IsNaN(TSelf)                                                            // ? Explicit\r\n    //   * bool IsNegative(TSelf)                                                       // ? Explicit\r\n    //   * bool IsNegativeInfinity(TSelf)                                               // ? Explicit\r\n    //   * bool IsNormal(TSelf)                                                         // ? Explicit\r\n    //   * bool IsPositive(TSelf)                                                       // ? Explicit\r\n    //   * bool IsPositiveInfinity(TSelf)                                               // ? Explicit\r\n    //   * bool IsSubnormal(TSelf)                                                      // ? Explicit\r\n    //   * TSelf Max(TSelf, TSelf)\r\n    //   * TSelf MaxMagnitude(TSelf, TSelf)                                             // ? Explicit\r\n    //   * TSelf MaxMagnitudeNumber(TSelf, TSelf)                                       // ? Explicit\r\n    //   * TSelf MaxNumber(TSelf, TSelf)                                                // ? Explicit\r\n    //   * TSelf Min(TSelf, TSelf)\r\n    //   * TSelf MinMagnitude(TSelf, TSelf)                                             // ? Explicit\r\n    //   * TSelf MinMagnitudeNumber(TSelf, TSelf)                                       // ? Explicit\r\n    //   * TSelf MinNumber(TSelf, TSelf)                                                // ? Explicit\r\n    //   * TSelf Parse(string, NumberStyles, IFormatProvider?)\r\n    //   * TSelf Parse(ReadOnlySpan\u003cchar\u003e, NumberStyles, IFormatProvider?)\r\n    //   * int Sign(TSelf)\r\n    //   * bool TryCreate(TOther, out TSelf)\r\n    //   * bool TryParse(string?, NumberStyles, IFormatProvider?, out TSelf)\r\n    //   * bool TryParse(ReadOnlySpan\u003cchar\u003e, NumberStyles, IFormatProvider?, out TSelf)\r\n    // * IParsable\r\n    //   * TSelf Parse(string, IFormatProvider?)\r\n    //   * bool TryParse(string?, IFormatProvider?, out TSelf)\r\n    // * ISpanFormattable\r\n    //   * bool TryFormat(Span\u003cchar\u003e, out int, ReadOnlySpan\u003cchar\u003e, IFormatProvider?)\r\n    // * ISpanParsable\r\n    //   * TSelf Parse(ReadOnlySpan\u003cchar\u003e, IFormatProvider?)\r\n    //   * bool TryParse(ReadOnlySpan\u003cchar\u003e, IFormatProvider?, out TSelf)\r\n}\r\n```\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOtQgXBg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5CsQoE",
                                           "createdAt":  "2022-05-05T18:12:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Rationale\r\n\r\nIn https://github.com/dotnet/runtime/issues/13788 we exposed some new interchange types `CLong`, `CULong`, and `NFloat` to help ensure interop with underlying runtimes could be done in a stable and cross platform manner.\r\n\r\nWe initially decided that these should not expose more complex support such as operators, parsing, or formatting. However, we then backtracked on this decision for `NFloat` with https://github.com/dotnet/runtime/issues/63801 so Xamarin would no longer need to maintain their own type.\r\n\r\n`CLong` and `CULong` are used in many similar scenarios and so deserve similar treatment. Likewise, this fits in with the general `generic-math` theme and treats them as first class number types that can play into users existing code and algorithms.\r\n\r\n### Proposal\r\n\r\nThis was extracted out of https://github.com/dotnet/designs/pull/262 and covers the generic-math interfaces and whether they are implicitly or explicitly implemented\r\n\r\n```csharp\r\nnamespace System.Runtime.InteropServices;\r\n\r\npublic struct CLong\r\n    : IBinaryInteger\u003cCLong\u003e,\r\n      IMinMaxValue\u003cCLong\u003e,\r\n      ISignedNumber\u003cCLong\u003e\r\n{\r\n    // Explicitly implemented interfaces\r\n    // * IAdditiveIdentity\r\n    //   * TSelf AdditiveIdentity { get; }\r\n    // * IMultiplicativeIdentity\r\n    //   * TSelf MultiplicativeIdentity { get; }\r\n    // * INumberBase\r\n    //   * One { get; }\r\n    //   * Zero { get; }\r\n    // * ISignedNumber\r\n    //   * TSelf NegativeOne { get; }\r\n\r\n    // Implicitly Implemented interfaces\r\n    // * IMinMaxValue\r\n    //   * TSelf MaxValue { get; }\r\n    //   * TSelf MinValue { get; }\r\n    //\r\n    // * IAdditionOperators\r\n    //   * TSelf operator +(TSelf, TSelf)\r\n    //   * TSelf operator checked +(TSelf, TSelf)\r\n    // * IBitwiseOperators\r\n    //   * TSelf operator \u0026(TSelf, TSelf)\r\n    //   * TSelf operator |(TSelf, TSelf)\r\n    //   * TSelf operator ^(TSelf, TSelf)\r\n    //   * TSelf operator ~(TSelf)\r\n    // * IComparisonOperators\r\n    //   * bool operator \u003c(TSelf, TSelf)\r\n    //   * bool operator \u003c=(TSelf, TSelf)\r\n    //   * bool operator \u003e(TSelf, TSelf)\r\n    //   * bool operator \u003e=(TSelf, TSelf)\r\n    // * IDecrementOperators\r\n    //   * TSelf operator --(TSelf)\r\n    //   * TSelf operator checked --(TSelf)\r\n    // * IDivisionOperators\r\n    //   * TSelf operator /(TSelf, TSelf)\r\n    //   * TSelf operator checked /(TSelf, TSelf)\r\n    // * IIncrementOperators\r\n    //   * TSelf operator ++(TSelf)\r\n    //   * TSelf operator checked ++(TSelf)\r\n    // * IModulusOperators\r\n    //   * TSelf operator %(TSelf, TSelf)\r\n    // * IMultiplyOperators\r\n    //   * TSelf operator *(TSelf, TSelf)\r\n    //   * TSelf operator checked *(TSelf, TSelf)\r\n    // * IShiftOperators\r\n    //   * TSelf operator \u003c\u003c(TSelf, int)\r\n    //   * TSelf operator \u003e\u003e(TSelf, int)\r\n    //   * TSelf operator \u003e\u003e\u003e(TSelf, int)\r\n    // * ISubtractionOperators\r\n    //   * TSelf operator -(TSelf, TSelf)\r\n    //   * TSelf operator checked -(TSelf, TSelf)\r\n    // * IUnaryNegationOperators\r\n    //   * TSelf operator -(TSelf)\r\n    //   * TSelf operator checked -(TSelf)\r\n    // * IUnaryPlusOperators\r\n    //   * TSelf operator +(TSelf)\r\n    //\r\n    // * IBinaryInteger\r\n    //   * (TSelf, TSelf) DivRem(TSelf, TSelf)\r\n    //   * int GetShortestByteCount()                                                   // ? Explicit\r\n    //   * long GetShortestBitLength()                                                  // ? Explicit\r\n    //   * TSelf LeadingZeroCount(TSelf)\r\n    //   * TSelf PopCount(TSelf)\r\n    //   * TSelf RotateLeft(TSelf, int)\r\n    //   * TSelf RotateRight(TSelf, int)\r\n    //   * TSelf TrailingZeroCount(TSelf)\r\n    //   * bool TryWriteLittleEndian(byte[], out int)                                   // ? Explicit\r\n    //   * int WriteLittleEndian(byte[])                                                // ? Explicit\r\n    //   * int WriteLittleEndian(byte[], int)                                           // ? Explicit\r\n    //   * int WriteLittleEndian(Span\u003cbyte\u003e)                                            // ? Explicit\r\n    // * IBinaryNumber\r\n    //   * bool IsPow2(TSelf)\r\n    //   * TSelf Log2(TSelf)\r\n    // * IComparable\r\n    //   * int CompareTo(object?)\r\n    //   * int CompareTo(TSelf)\r\n    // * IEqualityOperators\r\n    //   * bool operator ==(TSelf, TSelf)                                               // * Existing\r\n    //   * bool operator !=(TSelf, TSelf)                                               // * Existing\r\n    // * IEquatable                                                                     // Existing\r\n    //   * bool Equals(TSelf)                                                           // * Existing\r\n    // * IFormattable\r\n    //   * string ToString(string?, IFormatProvider?)\r\n    // * INumber\r\n    //   * TSelf Abs(TSelf)\r\n    //   * TSelf Clamp(TSelf, TSelf, TSelf)\r\n    //   * TSelf CopySign(TSelf, TSelf)\r\n    //   * TSelf CreateChecked(TOther)\r\n    //   * TSelf CreateSaturating(TOther)\r\n    //   * TSelf CreateTruncating(TOther)\r\n    //   * bool IsFinite(TSelf)                                                         // ? Explicit\r\n    //   * bool IsInfinity(TSelf)                                                       // ? Explicit\r\n    //   * bool IsNaN(TSelf)                                                            // ? Explicit\r\n    //   * bool IsNegative(TSelf)\r\n    //   * bool IsNegativeInfinity(TSelf)                                               // ? Explicit\r\n    //   * bool IsNormal(TSelf)                                                         // ? Explicit\r\n    //   * bool IsPositive(TSelf)\r\n    //   * bool IsPositiveInfinity(TSelf)                                               // ? Explicit\r\n    //   * bool IsSubnormal(TSelf)                                                      // ? Explicit\r\n    //   * TSelf Max(TSelf, TSelf)\r\n    //   * TSelf MaxMagnitude(TSelf, TSelf)\r\n    //   * TSelf MaxMagnitudeNumber(TSelf, TSelf)                                       // ? Explicit\r\n    //   * TSelf MaxNumber(TSelf, TSelf)                                                // ? Explicit\r\n    //   * TSelf Min(TSelf, TSelf)\r\n    //   * TSelf MinMagnitude(TSelf, TSelf)\r\n    //   * TSelf MinMagnitudeNumber(TSelf, TSelf)                                       // ? Explicit\r\n    //   * TSelf MinNumber(TSelf, TSelf)                                                // ? Explicit\r\n    //   * TSelf Parse(string, NumberStyles, IFormatProvider?)\r\n    //   * TSelf Parse(ReadOnlySpan\u003cchar\u003e, NumberStyles, IFormatProvider?)\r\n    //   * int Sign(TSelf)\r\n    //   * bool TryCreate(TOther, out TSelf)\r\n    //   * bool TryParse(string?, NumberStyles, IFormatProvider?, out TSelf)\r\n    //   * bool TryParse(ReadOnlySpan\u003cchar\u003e, NumberStyles, IFormatProvider?, out TSelf)\r\n    // * IParsable\r\n    //   * TSelf Parse(string, IFormatProvider?)\r\n    //   * bool TryParse(string?, IFormatProvider?, out TSelf)\r\n    // * ISpanFormattable\r\n    //   * bool TryFormat(Span\u003cchar\u003e, out int, ReadOnlySpan\u003cchar\u003e, IFormatProvider?)\r\n    // * ISpanParsable\r\n    //   * TSelf Parse(ReadOnlySpan\u003cchar\u003e, IFormatProvider?)\r\n    //   * bool TryParse(ReadOnlySpan\u003cchar\u003e, IFormatProvider?, out TSelf)\r\n}\r\n\r\npublic struct CULong\r\n    : IBinaryInteger\u003cCULong\u003e,\r\n      IMinMaxValue\u003cCULong\u003e,\r\n      IUnsignedNumber\u003cCULong\u003e\r\n{\r\n    // Explicitly implemented interfaces\r\n    // * IAdditiveIdentity\r\n    //   * TSelf AdditiveIdentity { get; }\r\n    // * IMultiplicativeIdentity\r\n    //   * TSelf MultiplicativeIdentity { get; }\r\n    // * INumberBase\r\n    //   * One { get; }\r\n    //   * Zero { get; }\r\n\r\n    // Implicitly Implemented interfaces\r\n    // * IMinMaxValue\r\n    //   * TSelf MaxValue { get; }\r\n    //   * TSelf MinValue { get; }\r\n    //\r\n    // * IAdditionOperators\r\n    //   * TSelf operator +(TSelf, TSelf)\r\n    //   * TSelf operator checked +(TSelf, TSelf)\r\n    // * IBitwiseOperators\r\n    //   * TSelf operator \u0026(TSelf, TSelf)\r\n    //   * TSelf operator |(TSelf, TSelf)\r\n    //   * TSelf operator ^(TSelf, TSelf)\r\n    //   * TSelf operator ~(TSelf)\r\n    // * IComparisonOperators\r\n    //   * bool operator \u003c(TSelf, TSelf)\r\n    //   * bool operator \u003c=(TSelf, TSelf)\r\n    //   * bool operator \u003e(TSelf, TSelf)\r\n    //   * bool operator \u003e=(TSelf, TSelf)\r\n    // * IDecrementOperators\r\n    //   * TSelf operator --(TSelf)\r\n    //   * TSelf operator checked --(TSelf)\r\n    // * IDivisionOperators\r\n    //   * TSelf operator /(TSelf, TSelf)\r\n    //   * TSelf operator checked /(TSelf, TSelf)\r\n    // * IIncrementOperators\r\n    //   * TSelf operator ++(TSelf)\r\n    //   * TSelf operator checked ++(TSelf)\r\n    // * IModulusOperators\r\n    //   * TSelf operator %(TSelf, TSelf)\r\n    // * IMultiplyOperators\r\n    //   * TSelf operator *(TSelf, TSelf)\r\n    //   * TSelf operator checked *(TSelf, TSelf)\r\n    // * IShiftOperators\r\n    //   * TSelf operator \u003c\u003c(TSelf, int)\r\n    //   * TSelf operator \u003e\u003e(TSelf, int)\r\n    //   * TSelf operator \u003e\u003e\u003e(TSelf, int)\r\n    // * ISubtractionOperators\r\n    //   * TSelf operator -(TSelf, TSelf)\r\n    //   * TSelf operator checked -(TSelf, TSelf)\r\n    // * IUnaryNegationOperators\r\n    //   * TSelf operator -(TSelf)\r\n    //   * TSelf operator checked -(TSelf)\r\n    // * IUnaryPlusOperators\r\n    //   * TSelf operator +(TSelf)\r\n    //\r\n    // * IBinaryInteger\r\n    //   * (TSelf, TSelf) DivRem(TSelf, TSelf)\r\n    //   * int GetByteCount()                                                           // ? Explicit\r\n    //   * long GetShortestBitLength()                                                  // ? Explicit\r\n    //   * TSelf LeadingZeroCount(TSelf)\r\n    //   * TSelf PopCount(TSelf)\r\n    //   * TSelf RotateLeft(TSelf, int)\r\n    //   * TSelf RotateRight(TSelf, int)\r\n    //   * TSelf TrailingZeroCount(TSelf)\r\n    //   * bool TryWriteLittleEndian(byte[], out int)                                   // ? Explicit\r\n    //   * int WriteLittleEndian(byte[])                                                // ? Explicit\r\n    //   * int WriteLittleEndian(byte[], int)                                           // ? Explicit\r\n    //   * int WriteLittleEndian(Span\u003cbyte\u003e)                                            // ? Explicit\r\n    // * IBinaryNumber\r\n    //   * bool IsPow2(TSelf)\r\n    //   * TSelf Log2(TSelf)\r\n    // * IComparable\r\n    //   * int CompareTo(object?)\r\n    //   * int CompareTo(TSelf)\r\n    // * IEqualityOperators\r\n    //   * bool operator ==(TSelf, TSelf)                                               // * Existing\r\n    //   * bool operator !=(TSelf, TSelf)                                               // * Existing\r\n    // * IEquatable                                                                     // Existing\r\n    //   * bool Equals(TSelf)                                                           // * Existing\r\n    // * IFormattable\r\n    //   * string ToString(string?, IFormatProvider?)\r\n    // * INumber\r\n    //   * TSelf Abs(TSelf)                                                             // ? Explicit\r\n    //   * TSelf Clamp(TSelf, TSelf, TSelf)\r\n    //   * TSelf CopySign(TSelf, TSelf)                                                 // ? Explicit\r\n    //   * TSelf CreateChecked(TOther)\r\n    //   * TSelf CreateSaturating(TOther)\r\n    //   * TSelf CreateTruncating(TOther)\r\n    //   * bool IsFinite(TSelf)                                                         // ? Explicit\r\n    //   * bool IsInfinity(TSelf)                                                       // ? Explicit\r\n    //   * bool IsNaN(TSelf)                                                            // ? Explicit\r\n    //   * bool IsNegative(TSelf)                                                       // ? Explicit\r\n    //   * bool IsNegativeInfinity(TSelf)                                               // ? Explicit\r\n    //   * bool IsNormal(TSelf)                                                         // ? Explicit\r\n    //   * bool IsPositive(TSelf)                                                       // ? Explicit\r\n    //   * bool IsPositiveInfinity(TSelf)                                               // ? Explicit\r\n    //   * bool IsSubnormal(TSelf)                                                      // ? Explicit\r\n    //   * TSelf Max(TSelf, TSelf)\r\n    //   * TSelf MaxMagnitude(TSelf, TSelf)                                             // ? Explicit\r\n    //   * TSelf MaxMagnitudeNumber(TSelf, TSelf)                                       // ? Explicit\r\n    //   * TSelf MaxNumber(TSelf, TSelf)                                                // ? Explicit\r\n    //   * TSelf Min(TSelf, TSelf)\r\n    //   * TSelf MinMagnitude(TSelf, TSelf)                                             // ? Explicit\r\n    //   * TSelf MinMagnitudeNumber(TSelf, TSelf)                                       // ? Explicit\r\n    //   * TSelf MinNumber(TSelf, TSelf)                                                // ? Explicit\r\n    //   * TSelf Parse(string, NumberStyles, IFormatProvider?)\r\n    //   * TSelf Parse(ReadOnlySpan\u003cchar\u003e, NumberStyles, IFormatProvider?)\r\n    //   * int Sign(TSelf)\r\n    //   * bool TryCreate(TOther, out TSelf)\r\n    //   * bool TryParse(string?, NumberStyles, IFormatProvider?, out TSelf)\r\n    //   * bool TryParse(ReadOnlySpan\u003cchar\u003e, NumberStyles, IFormatProvider?, out TSelf)\r\n    // * IParsable\r\n    //   * TSelf Parse(string, IFormatProvider?)\r\n    //   * bool TryParse(string?, IFormatProvider?, out TSelf)\r\n    // * ISpanFormattable\r\n    //   * bool TryFormat(Span\u003cchar\u003e, out int, ReadOnlySpan\u003cchar\u003e, IFormatProvider?)\r\n    // * ISpanParsable\r\n    //   * TSelf Parse(ReadOnlySpan\u003cchar\u003e, IFormatProvider?)\r\n    //   * bool TryParse(ReadOnlySpan\u003cchar\u003e, IFormatProvider?, out TSelf)\r\n}\r\n```\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003etannergooding\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `api-ready-for-review`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-05-05T18:12:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5C7KAX",
                                           "createdAt":  "2022-05-10T19:57:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCcZkBw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2022-05-12T01:54:49Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "We reviewed this alongside generic math and the feedback was that this needs more explicit community feedback as to the need and scenarios before it can go forward.\r\n\r\n@perksey requested it here: \u003chttps://github.com/dotnet/runtime/issues/63801#issuecomment-1013301341\u003e (someone else may have thumbed up my response, but GitHub won\u0027t show who)\r\n\r\nA few users asked for it in the original (lengthy) discussion here: https://github.com/dotnet/runtime/issues/13788\r\n\r\nI myself have run into needs for it around `ClangSharp` and `LLVMSharp` (which wrap `libClang` and `libLLVM` respectively). I also maintain several Unix interop libraries that use it, but many of those are currently Unix only (a few are xplat, however).",
                                           "updatedAt":  "2022-05-10T20:00:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc61BjXb",
                                           "createdAt":  "2025-07-04T19:08:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AlexandreEXFO",
                                           "body":  "It is necessary to check whether CULong is equal to its maximum possible value (all bits set to 1) as part of the development of an architecturally simplified version of this library (https://github.com/Pkcs11Interop/Pkcs11Interop). After creating a simplified version (using native .NET capabilities such as CULong and NativeLibrary.Load), the intention is to support the recent version ([PKCS11 v3.2](https://docs.oasis-open.org/pkcs11/pkcs11-spec/v3.2/csd01/pkcs11-spec-v3.2-csd01.html)) of the PKCS11 interface.\n\nIn particular, the verification is performed here: https://github.com/Pkcs11Interop/Pkcs11Interop/blob/master/src/Pkcs11Interop/Common/CK.cs#L53\n\nSupport for a newer version of PKCS11 adds support for Post-Quantum algorithms. PKCS11 makes extensive use of C ULong as very described here (https://github.com/Pkcs11Interop/Pkcs11Interop/blob/master/doc/04_ARCHITECTURE.md) and in the specification.\n\n@tannergooding : Hope this helps for a use case.",
                                           "updatedAt":  "2025-07-04T19:08:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc61B6Ve",
                                           "createdAt":  "2025-07-04T20:13:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEZZReQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AlexandreEXFO",
                                                                               "createdAt":  "2025-07-04T20:34:18Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "CC. @AaronRobinsonMSFT on the above.\n\nNotably this isn\u0027t \"required\". The user can do something like `if (OperatingSystem.IsWindows()) { uint.MaxValue } else { nuint.MaxValue }`\n\nBut it is a real world case where some modern interop library is using C `unsigned long` and having the relevant numeric APIs directly on the primitive would make it simpler for users to get things correct.",
                                           "updatedAt":  "2025-07-04T20:13:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc61B_X1",
                                           "createdAt":  "2025-07-04T20:28:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AlexandreEXFO",
                                           "body":  "@tannergooding : Does \u0027nuint\u0027 return the correct size depending on the architecture? I\u0027m not very familiar with this type.\n\nCULong is either UInt32 or a UIntPtr.\n\nhttps://github.com/dotnet/runtime/blob/fab69a4a64c78f15e392a1b264d70f492251a5d9/src/libraries/System.Private.CoreLib/src/System/Runtime/InteropServices/CULong.cs#L8\n\nThe UIntPtr type is also variable depending on the architecture. (https://github.com/dotnet/runtime/blob/fab69a4a64c78f15e392a1b264d70f492251a5d9/src/libraries/System.Private.CoreLib/src/System/UIntPtr.cs#L15)\n\nI understand that it can be done differently, but it\u0027s pretty ugly to do something like this in code when there could be a way to do the same thing in a much cleaner way and without asking ourselves if we have managed all the cases well related to the operating system and the architecture.\n\n```csharp\npublic static readonly CULong CK_UNAVAILABLE_INFORMATION = new CULong(0).Value.GetType() switch\n  {\n      Type t when t == typeof(UInt32) =\u003e new CULong(UInt32.MaxValue),\n      _ =\u003e new CULong(UIntPtr.MaxValue)\n  };\n```",
                                           "updatedAt":  "2025-07-04T20:29:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc61CBcG",
                                           "createdAt":  "2025-07-04T20:34:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEZZWKg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AlexandreEXFO",
                                                                               "createdAt":  "2025-07-04T20:34:53Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2025-07-04T20:58:23Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "`nuint` is the language keyword for `UIntPtr`, it is 32-bits on 32-bit platforms and 64-bits on 64-bit platforms.\n\nHence `CULong maxValue = OperatingSystem.IsWindows() ? new CULong(uint.MaxValue) : new CULong(nuint.MaxValue);` will get you the right value for Windows vs Unix.",
                                           "updatedAt":  "2025-07-04T20:34:31Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "Extend System.Runtime.InteropServices.CLong and CULong to match nfloat ",
        "labels":  [
                       "api-needs-work",
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/73008",
        "createdAt":  "2022-07-28T16:11:28Z",
        "number":  73008,
        "author":  "steveisok",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-16T13:37:55Z",
        "body":  "[StructureToPtr_Flat_And_Nested_NonBlittableStructure_Success](https://github.com/dotnet/runtime/blob/aac729ff906a31f327823587748687c0308a4043/src/libraries/System.Runtime.InteropServices/tests/System.Runtime.InteropServices.UnitTests/System/Runtime/InteropServices/Marshal/StructureToPtrTests.cs#L261) fails when using `Marshal.StructureToPtr` fails in AOT mode with the following message:\r\n\r\n```\r\nSystem.ExecutionEngineException: Attempting to JIT compile method \u0027(wrapper other) void System.Runtime.InteropServices.Tests.PtrToStructureTests/SequentialClass:StructureToPtr (object,intptr,bool)\u0027 while running in aot-only mode. See https://docs.microsoft.com/xamarin/ios/internals/limitations for more information.\r\n\r\n   at System.Runtime.InteropServices.Marshal.StructureToPtr[SequentialClass](SequentialClass structure, IntPtr ptr, Boolean fDeleteOld)\r\n```\r\n\r\nThe test is being skipped for now.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOSQRMXQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5HbXee",
                                           "createdAt":  "2022-07-28T16:11:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n`Marshal.StructureToPtr` fails in AOT mode with a variation of this message:\r\n\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003esteveisok\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-07-28T16:11:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HbYDa",
                                           "createdAt":  "2022-07-28T16:13:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to \u0027os-ios\u0027: @steveisok, @akoeplinger\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n`Marshal.StructureToPtr` fails in AOT mode with a variation of this message:\r\n\r\n```\r\nSystem.ExecutionEngineException: Attempting to JIT compile method \u0027(wrapper other) void System.Runtime.InteropServices.Tests.PtrToStructureTests/SequentialClass:StructureToPtr (object,intptr,bool)\u0027 while running in aot-only mode. See https://docs.microsoft.com/xamarin/ios/internals/limitations for more information.\r\n\r\n   at System.Runtime.InteropServices.Marshal.StructureToPtr[SequentialClass](SequentialClass structure, IntPtr ptr, Boolean fDeleteOld)\r\n```\r\n\r\nThe following tests are impacted:\r\n\r\n- [ ] StructureToPtr_NonGenericType_ReturnsExpected\r\n- [ ] StructureToPtr_NonGenericObject_ReturnsExpected\r\n- [ ] StructureToPtr_GenericObject_ReturnsExpected\r\n- [ ] PtrToStructure_GenericLayoutClass_Generic\r\n- [ ] PtrToStructure_GenericLayoutClass\r\n- [ ] StructureToPtr_Flat_And_Nested_NonBlittableStructure_Success\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003esteveisok\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003evargaz\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `untriaged`, `os-ios`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-07-28T16:13:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Ht5pa",
                                           "createdAt":  "2022-08-02T21:07:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveisok",
                                           "body":  "@vargaz These are still failing because it\u0027s trying to JIT:\r\n\r\nhttps://github.com/dotnet/runtime/blob/aac729ff906a31f327823587748687c0308a4043/src/libraries/System.Runtime.InteropServices/tests/System.Runtime.InteropServices.UnitTests/System/Runtime/InteropServices/Marshal/PtrToStructureTests.cs#L153-L160\r\n\r\nhttps://github.com/dotnet/runtime/blob/aac729ff906a31f327823587748687c0308a4043/src/libraries/System.Runtime.InteropServices/tests/System.Runtime.InteropServices.UnitTests/System/Runtime/InteropServices/Marshal/PtrToStructureTests.cs#L164-L171\r\n\r\nhttps://github.com/dotnet/runtime/blob/aac729ff906a31f327823587748687c0308a4043/src/libraries/System.Runtime.InteropServices/tests/System.Runtime.InteropServices.UnitTests/System/Runtime/InteropServices/Marshal/StructureToPtrTests.cs#L261-L282",
                                           "updatedAt":  "2022-08-02T21:07:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5I3BvD",
                                           "createdAt":  "2022-08-22T13:44:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lambdageek",
                                           "body":  "I don\u0027t think this was supposed to be closed? @steveisok ?",
                                           "updatedAt":  "2022-08-22T13:44:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5I4DuW",
                                           "createdAt":  "2022-08-22T17:11:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "akoeplinger",
                                           "body":  "Interesting, it looks like it was closed because it had the `Fixes https://github.com/dotnet/runtime/issues/73008` in the commit message and since @MichalStrehovsky has write permissions it got closed when the commit was merged into the default branch of https://github.com/bflattened/runtime/pull/12",
                                           "updatedAt":  "2022-08-22T17:11:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5I4EuD",
                                           "createdAt":  "2022-08-22T17:14:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveisok",
                                           "body":  "\u003e I don\u0027t think this was supposed to be closed? @steveisok ?\r\n\r\nNo, it was not supposed to be closed.  There\u0027s one test left that is failing.",
                                           "updatedAt":  "2022-08-22T17:15:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JBExd",
                                           "createdAt":  "2022-08-24T00:21:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "\u003e Interesting, it looks like it was closed because it had the Fixes https://github.com/dotnet/runtime/issues/73008 in the commit message and since @MichalStrehovsky has write permissions it got closed when the commit was merged into the default branch of https://github.com/bflattened/runtime/pull/12\r\n\r\nWow, thanks Github :(. Sorry about that.",
                                           "updatedAt":  "2022-08-24T00:21:50Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "[iOS] StructureToPtr_Flat_And_Nested_NonBlittableStructure_Success fails in System.Runtime.InteropServices.UnitTests",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "disabled-test",
                       "runtime-mono",
                       "os-ios"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/76974",
        "createdAt":  "2022-10-12T22:04:40Z",
        "number":  76974,
        "author":  "dancojocaru2000",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODAo4aQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MitchRazga",
                                            "createdAt":  "2023-09-20T07:28:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ShortDevelopment",
                                            "createdAt":  "2024-02-10T18:22:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MrScautHD",
                                            "createdAt":  "2024-04-25T17:34:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "OronDF343",
                                            "createdAt":  "2024-05-20T14:37:42Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lunarcloud",
                                            "createdAt":  "2024-05-29T21:18:05Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DominicMaas",
                                            "createdAt":  "2024-07-02T19:26:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MrJul",
                                            "createdAt":  "2024-11-14T14:01:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Sharpe49",
                                            "createdAt":  "2025-02-27T07:07:58Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "vanka78bg",
                                            "createdAt":  "2025-03-29T11:49:28Z"
                                        }
                                    ],
                          "totalCount":  9
                      },
        "updatedAt":  "2023-03-17T08:33:24Z",
        "body":  "### Background and motivation\n\nMany libraries automatically free strings returned (for example, on the next call).\r\n\r\nWithout this feature, an `IntPtr` type must be returned, and then the extern function must be wrapped in a C# function that properly converts the `IntPtr` to a `string` without calling free.\n\n### API Proposal\n\nAdd a `bool FreeString` (or similar) property to `DllImportAttribute` and/or `LibraryImportAttribute`, with a default true value to preserve the current behaviour.\n\n### API Usage\n\n```csharp\r\n[DllImport(\"library\", FreeString = false)]\r\npublic static extern string ExampleFunction();\r\n```\r\n\r\nand/or\r\n\r\n\r\n```csharp\r\n[LibraryImport(\"library\", FreeString = false)]\r\npublic static partial string ExampleFunction();\r\n```\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOV9I2wQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5MGiTk",
                                           "createdAt":  "2022-10-12T22:04:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nMany libraries automatically free strings returned (for example, on the next call).\r\n\r\nWithout this feature, an `IntPtr` type must be returned, and then the extern function must be wrapped in a C# function that properly converts the `IntPtr` to a `string` without calling free.\n\n### API Proposal\n\nAdd a `bool FreeString` (or similar) property to `DllImportAttribute` and/or `LibraryImportAttribute`, with a default true value to preserve the current behaviour.\n\n### API Usage\n\n```csharp\r\n[DllImport(\"library\", FreeString = false)]\r\npublic static extern string ExampleFunction();\r\n```\r\n\r\nand/or\r\n\r\n\r\n```csharp\r\n[LibraryImport(\"library\", FreeString = false)]\r\npublic static partial string ExampleFunction();\r\n```\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003edancojocaru2000\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-10-12T22:04:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5MGjM1",
                                           "createdAt":  "2022-10-12T22:10:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "You can achieve this with a custom marshaller.",
                                           "updatedAt":  "2022-10-12T22:10:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5MGkIz",
                                           "createdAt":  "2022-10-12T22:16:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dancojocaru2000",
                                           "body":  "The documentation for writing custom marshallers is kind of lacking. Even so, there is little benefit to writing a custom marshaller as opposed to just returning `IntPtr` and then writing an extension method like the following:\r\n\r\n```csharp\r\npublic static class IntPtrToStr {\r\n\tpublic static unsafe string? ToUTF8String(this IntPtr ptr) {\r\n\t\treturn Utf8StringMarshaller.ConvertToManaged((byte*)ptr.ToPointer());\r\n\t}\r\n}\r\n```\r\n\r\nHowever, I think that having the library free a string instead of passing the responsibility to the caller is common enough that this should be a supported use case by the built in marshaller, as opposed to having someone copy-paste that extension method in all their projects.",
                                           "updatedAt":  "2022-10-12T22:16:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5MGkhF",
                                           "createdAt":  "2022-10-12T22:18:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCtv8KA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "dancojocaru2000",
                                                                               "createdAt":  "2022-10-12T22:18:58Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "(small nit on the snippet you sent; you can directly do `(byte*)ptr`)",
                                           "updatedAt":  "2022-10-12T22:18:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5MGq6e",
                                           "createdAt":  "2022-10-12T23:00:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e Add a bool FreeString (or similar) property to DllImportAttribute\r\n\r\nThe `DllImportAttribute` is a pseudo attribute and is baked into metadata. It isn\u0027t possible to add new fields to it without reving the ECMA-335 specification. We would need to add a new attribute that the built-in marshaller respects. However, we aren\u0027t interested in adding new features into the built-in marshaller. All new feature work is focused on the `LibraryImport` source generator.\r\n\r\nAs far as adding this to `LibraryImport`, I am with @teo-tsirpanis and this should be accomplished through a custom marshaller for the string type. See [`CustomMarshallerAttribute`](https://learn.microsoft.com/dotnet/api/system.runtime.interopservices.marshalling.custommarshallerattribute) and the [code sample](https://github.com/dotnet/samples/tree/main/core/interop/source-generation/custom-marshalling).\r\n\r\nAt present, I don\u0027t see a lot of value, but I\u0027m open to seeing if the community thinks otherwise. But do note, this is only an option for `LibraryImport`, adding this feature to the `DllImport` scenario is a non-starter.",
                                           "updatedAt":  "2023-01-01T21:27:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5MGrSj",
                                           "createdAt":  "2022-10-12T23:02:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dancojocaru2000",
                                           "body":  "If I\u0027m not mistaken, `LibraryImport` uses source generation. Therefore, would adding this to `LibraryImport` make it a C# only feature? ",
                                           "updatedAt":  "2022-10-12T23:09:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5MGt6I",
                                           "createdAt":  "2022-10-12T23:19:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e If I\u0027m not mistaken, `LibraryImport` uses source generation. Therefore, would adding this to `LibraryImport` make it a C# only feature?\r\n\r\nYes. Are you interested in this feature for a non-C# scenario? If so, what one?",
                                           "updatedAt":  "2022-10-12T23:19:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Rg7cP",
                                           "createdAt":  "2022-12-29T21:09:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEf7EQg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jeremy-visionaid",
                                                                               "createdAt":  "2023-03-26T21:37:09Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Jonax",
                                                                               "createdAt":  "2023-08-17T05:40:44Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "solari23",
                                                                               "createdAt":  "2025-08-28T00:54:30Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "lf73",
                                           "body":  "I ran into what I believe is caused by this issue related to constant string return when trying to upgrade to LibraryImport.  Currently using DLLImport, the return is an IntPtr and then in a wrapper method it is converted to a string via Marshal.PtrToStringAnsi(myIntPtr). \r\n\r\nC Library\r\n```C\r\nconst char *rtlsdr_get_device_name(uint32_t index)\r\n```\r\n\r\nC# Attempt at using LibraryImport\r\n```C#\r\n        [LibraryImport(\"librtlsdr\",\r\n            EntryPoint = \"rtlsdr_get_device_name\",\r\n            StringMarshalling = StringMarshalling.Custom,\r\n            StringMarshallingCustomType = typeof(AnsiStringMarshaller))]\r\n        internal static partial string GetDeviceName(uint index);\r\n```\r\n\r\nWhen called the process just crashes. No exception. No memory violation error. Having the LibraryImport generated code was very beneficial in tracking down the problem. Stepping into the Finally clause is a call to  Free the memory where it just aborts.\r\n\r\nIn this situation a LibraryImport optional parameter as suggested would fix the issue. Until then, I will look into making a Custom Marshaller.",
                                           "updatedAt":  "2022-12-29T21:16:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Rinvi",
                                           "createdAt":  "2022-12-30T17:48:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "@lf73  I\u0027m not an interop person but just curious why you are using ANSI string marshaling for what is presumably a Linux lib, rather then the usual Utf8.",
                                           "updatedAt":  "2022-12-30T17:48:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RipW_",
                                           "createdAt":  "2022-12-30T18:07:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lf73",
                                           "body":  "\u003e @lf73 I\u0027m not an interop person but just curious why you are using ANSI string marshaling for what is presumably a Linux lib, rather then the usual Utf8.\r\n\r\n@danmoseley   I\u0027m not an expert on C string, so mostly just guessing and trying. The library is using NULL terminated strings. Which I hear is not a great thing security wise, now a days. But this is limited to pulling details about a hardware device, so it\u0027s probably okay. Also the hardware device itself may be limited on the string type. If I use UTF-8 then I have to replace a bunch of 0\u0027s  ( \\0 ) with null.  Using the ANSI string marshalling, it just works perfectly with no additional string manipulation.  This is mostly around where I first have to create a buffer, of say 256 bytes, and let the C library fill it. That\u0027s another call than what is above, shared below.  That part has been another really big pain point as really the LibraryImport is not able to provide any coding and I seem to be stuck just using IntPtr\u0027s... which under the hood just generates an identical DLLImport statement!  If I do the signature with Out string parameters, I get an Access Violation error as it\u0027s obviously not making any effort to create a byte array first.\r\n\r\n```c\r\nint rtlsdr_get_device_usb_strings(uint32_t index, char *manufact, char *product, char *serial)\r\n```\r\n\r\n```c#\r\n        [LibraryImport(\"librtlsdr\", EntryPoint = \"rtlsdr_get_device_usb_strings\")]\r\n        internal static unsafe partial int GetDeviceUsbStrings(uint index,\r\n            nint manufact, nint product, nint serial);\r\n\r\n        internal static unsafe int GetTest2(uint index, out string manufact, out string product, out string serial)\r\n        {\r\n            fixed (byte* aptr = new byte[256], bptr = new byte[256], cptr = new byte[256])\r\n            {\r\n                var r = GetDeviceUsbStrings(index, (IntPtr)aptr, (IntPtr)bptr, (IntPtr)cptr);\r\n                manufact = Marshal.PtrToStringAnsi((IntPtr)aptr) ?? \"\";\r\n                product = Marshal.PtrToStringAnsi((IntPtr)bptr) ?? \"\";\r\n                serial = Marshal.PtrToStringAnsi((IntPtr)cptr) ?? \"\";\r\n                return r;\r\n            }\r\n        }\r\n```\r\n\r\n\r\n",
                                           "updatedAt":  "2022-12-30T18:13:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Ri3ca",
                                           "createdAt":  "2022-12-30T21:23:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "@lf73 Given the following unmanaged signature:\r\n\r\n```c\r\nconst char *rtlsdr_get_device_name(uint32_t index)\r\n```\r\n\r\nI would define the P/Invoke using `LibraryImport` as follows:\r\n```csharp\r\n[LibraryImport(\"librtlsdr\")]\r\ninternal static partial void* rtlsdr_get_device_name(uint index);\r\n```\r\n\r\nI would then create a simple wrapper for this scenario.\r\n\r\n```csharp\r\nstatic unsafe string GetDeviceName(uint index)\r\n{\r\n    void* s = rtlsdr_get_device_name(index);\r\n    // Handle null as a special case or just pass it on.\r\n    return Marshal.PtrToStringUTF8((IntPtr)s) ?? \"\";\r\n}\r\n```\r\n\r\n\u003e If I use UTF-8 then I have to replace a bunch of 0\u0027s ( \\0 ) with null.\r\n\r\nOn .NET, a null terminator for a UTF-8 or ANSI string are the same value, `\\0`. ANSI and UTF-8 are treated the same for .NET on non-Windows platforms.\r\n\r\n",
                                           "updatedAt":  "2022-12-30T21:23:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RjAEe",
                                           "createdAt":  "2022-12-31T00:07:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "\u003e Which I hear is not a great thing security wise, now a days.\r\n\r\nnull-terminated strings aren\u0027t an issue in and of themselves.\r\nIt\u0027s the (improper) use of various library functions that do/don\u0027t take that into account, or writing your own code that forgets that too.",
                                           "updatedAt":  "2022-12-31T00:07:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RjdUx",
                                           "createdAt":  "2022-12-31T16:34:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lf73",
                                           "body":  "@AaronRobinsonMSFT Thank you very much for the feedback. At first glance I dismissed **void** as either unwanted or nothing expected. After review, I see that **void*** has a special role in returning a pointer that could be of any type. I also appreciate the confirmation that there is no way around having to make a wrapper.\r\n\r\n@Clockwork-Muse Thank you for the feedback as well.",
                                           "updatedAt":  "2022-12-31T16:34:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5X0jbB",
                                           "createdAt":  "2023-03-17T08:33:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEf7ErQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jeremy-visionaid",
                                                                               "createdAt":  "2023-03-26T21:41:52Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "dogguts",
                                                                               "createdAt":  "2023-11-03T12:20:11Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ShortDevelopment",
                                                                               "createdAt":  "2024-02-10T18:22:41Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "JungerBoyo",
                                                                               "createdAt":  "2024-04-19T20:20:03Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "OronDF343",
                                                                               "createdAt":  "2024-05-20T14:37:39Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Sharpe49",
                                                                               "createdAt":  "2025-02-27T07:07:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nilsgeib",
                                                                               "createdAt":  "2025-04-28T14:01:42Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "solari23",
                                                                               "createdAt":  "2025-08-28T00:55:50Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  8
                                                         },
                                           "author":  "cyraid",
                                           "body":  "Having a \u0027without free\u0027 option would be nice. I\u0027m using a library which returns arrays and other things that you don\u0027t have to free, so it\u0027d be nice to have that option.",
                                           "updatedAt":  "2023-03-17T08:33:23Z"
                                       }
                                   ],
                         "totalCount":  14
                     },
        "title":  "[API Proposal]: String return from P/Invoke without free",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/77738",
        "createdAt":  "2022-11-01T18:25:59Z",
        "number":  77738,
        "author":  "AaronRobinsonMSFT",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCrawDw==",
                          "nodes":  [
                                        {
                                            "content":  "HEART",
                                            "user":  "filipnavara",
                                            "createdAt":  "2022-11-01T20:28:52Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "Sergio0694",
                                            "createdAt":  "2022-11-02T13:10:41Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "govert",
                                            "createdAt":  "2022-11-11T18:16:55Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2023-01-20T16:00:05Z",
        "body":  "The `ComWrappers` infrastructure is written entirely in C++, much of this can be ported to use the [NativeAOT version](https://github.com/dotnet/runtime/blob/main/src/coreclr/nativeaot/System.Private.CoreLib/src/System/Runtime/InteropServices/ComWrappers.NativeAot.cs). However, the NativeAOT version is going to require some improvements to match the lower memory use in the C++ version and the support for the `IReferenceTracker` support.\r\n\r\nThis work would also enable mono to support `ComWrappers`. Note that the needed native code for `ComWrappers`, GC interaction, will need to be written in pure C if mono support is a goal.\r\n\r\nImplementation differences\r\n- https://github.com/dotnet/runtime/pull/80402#discussion_r1081883530\r\n\r\n/cc @dotnet/interop-contrib \r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOTWwzSA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5NbDNI",
                                           "createdAt":  "2022-11-01T18:26:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThe `ComWrappers` infrastructure is written entirely in C++, much of this can be ported to use the [NativeAOT version](https://github.com/dotnet/runtime/blob/main/src/coreclr/nativeaot/System.Private.CoreLib/src/System/Runtime/InteropServices/ComWrappers.NativeAot.cs). However, the NativeAOT version is going to require some improvements to match the lower memory use in the C++ version and the support for the `IReferenceTracker` support.\r\n\r\nThis work would also enable mono to support `ComWrappers`. Note that the needed native code for `ComWrappers`, GC interaction, will need to be written in pure C if mono support is a goal.\r\n\r\n/cc @dotnet/interop-contrib \r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eAaronRobinsonMSFT\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003eFuture\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-11-01T18:26:06Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Replace native `ComWrappers` implementation with NativeAOT version",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/78302",
        "createdAt":  "2022-11-14T02:14:19Z",
        "number":  78302,
        "author":  "bmitc",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-05-05T20:32:10Z",
        "body":  "### Description\r\n\r\nI am writing a console application in F# using .NET 7. I am wanting to intercept and prevent console exit signals, such as `PosixSignal.SIGTSTP` and `PosixSignal.SIGINT`. These [enums are defined here](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.posixsignal?view=net-7.0). To ignore them, I create and register a handler using [`PosixSignalRegistration.Create`](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.posixsignalregistration.create?view=net-7.0) and then write `true` to the `Cancel` property inside the handler. This should cancel the signal, to my understanding, as it does for `PosixSignal.SIGINT`. However, that doesn\u0027t seem to be the case for `PosixSignal.SIGTSTP`.\r\n\r\n### Reproduction Steps\r\n\r\nThese steps were executed on Ubuntu 20 running in WSL2 on Windows 11.\r\n\r\n1. Save the following code into an F# script named `posix.fsx`.\r\n    \r\n    ```fsharp\r\n    // posix.fsx\r\n    open System\r\n    open System.Runtime.InteropServices\r\n\r\n    PosixSignalRegistration.Create(PosixSignal.SIGINT,\r\n        fun context -\u003e\r\n            printfn \"Prevented Posix SIGINT\"\r\n            context.Cancel \u003c- true)\r\n    |\u003e ignore\r\n\r\n    if System.OperatingSystem.IsLinux() then\r\n        printfn \"System is Linux\"\r\n        PosixSignalRegistration.Create(PosixSignal.SIGTSTP,\r\n            fun context -\u003e\r\n                printfn \"Prevented Posix SIGTSTP\"\r\n                context.Cancel \u003c- true)\r\n        |\u003e ignore\r\n\r\n    let mutable cont = true\r\n\r\n    while cont do\r\n        let key = Console.ReadKey(intercept = true)\r\n        let keyChar = key.KeyChar\r\n        let keyModifiers = key.Modifiers\r\n        printfn \"key: %A, modifiers: %A\" keyChar keyModifiers\r\n        if keyChar = \u0027q\u0027 then\r\n            cont \u003c- false\r\n    ```\r\n\r\n2. Run the script with `dotnet fsi posix.fsx`\r\n3. Type any character except `\u0027q\u0027`. The key information will be printed out.\r\n4. Enter `Ctrl + C` and note that `\"Prevented Posix SIGINT\"` is printed out to the screen but that the process is still running, which can be verified by entering in other characters (again, besides `\u0027q\u0027`).\r\n5. Enter `Ctrl + Z` and note that:\r\n    * `[3]+  Stopped                 dotnet fsi posix.fsx` is printed to the screen\r\n    * The process is stopped, but then `\"Prevented Posix SIGTSTP\"` is printed out afterwards, after the new prompt is shown.\r\n    * However, the process *seems* to be restarted or still going, as it will respond to a key entry but usually only for one, and the process will end when `Enter` is entered. This behavior is a little inconsistent.\r\n\r\n### Expected behavior\r\n\r\nWhen `Ctrl + Z` is entered, `\"Prevented Posix SIGTSTP\"` should be printed to the console without the program being stopped.\r\n\r\n### Actual behavior\r\n\r\n```bash\r\n$ dotnet fsi posix.fsx\r\nSystem is Linux\r\nkey: \u0027a\u0027, modifiers: 0\r\nkey: \u0027\\013\u0027, modifiers: 0\r\nPrevented Posix SIGINT\r\nkey: \u0027a\u0027, modifiers: 0\r\n\r\n[2]+  Stopped                 dotnet fsi posix.fsx\r\n$ Prevented Posix SIGTSTP\r\nkey: \u0027a\u0027, modifiers: 0\r\n\r\n$ \r\n```\r\n\r\n### Regression?\r\n\r\nNot sure.\r\n\r\n### Known Workarounds\r\n\r\nNone that I know of.\r\n\r\n### Configuration\r\n\r\n```bash\r\n$ dotnet --version\r\n7.0.100\r\n\r\n$ lsb_release -a\r\nNo LSB modules are available.\r\nDistributor ID: Ubuntu\r\nDescription:    Ubuntu 20.04.5 LTS\r\nRelease:        20.04\r\nCodename:       focal\r\n```\r\n\r\nThe architecture is x64.\r\n\r\n### Other information\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOhgz0xw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5OQf-5",
                                           "createdAt":  "2022-11-14T02:14:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-11-14T02:14:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5OROIU",
                                           "createdAt":  "2022-11-14T06:02:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\nI am writing a console application in F# using .NET 7. I am wanting to intercept and prevent console exit signals, such as `PosixSignal.SIGTSTP` and `PosixSignal.SIGINT`. These [enums are defined here](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.posixsignal?view=net-7.0). To ignore them, I create and register a handler using [`PosixSignalRegistration.Create`](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.posixsignalregistration.create?view=net-7.0) and then write `true` to the `Cancel` property inside the handler. This should cancel the signal, to my understanding, as it does for `PosixSignal.SIGINT`. However, that doesn\u0027t seem to be the case for `PosixSignal.SIGTSTP`.\r\n\r\n### Reproduction Steps\r\n\r\nThese steps were executed on Ubuntu 20 running in WSL2 on Windows 11.\r\n\r\n1. Save the following code into an F# script named `posix.fsx`.\r\n    \r\n    ```fsharp\r\n    // posix.fsx\r\n    open System\r\n    open System.Runtime.InteropServices\r\n\r\n    PosixSignalRegistration.Create(PosixSignal.SIGINT,\r\n        fun context -\u003e\r\n            printfn \"Prevented Posix SIGINT\"\r\n            context.Cancel \u003c- true)\r\n    |\u003e ignore\r\n\r\n    if System.OperatingSystem.IsLinux() then\r\n        printfn \"System is Linux\"\r\n        PosixSignalRegistration.Create(PosixSignal.SIGTSTP,\r\n            fun context -\u003e\r\n                printfn \"Prevented Posix SIGTSTP\"\r\n                context.Cancel \u003c- true)\r\n        |\u003e ignore\r\n\r\n    let mutable cont = true\r\n\r\n    while cont do\r\n        let key = Console.ReadKey(intercept = true)\r\n        let keyChar = key.KeyChar\r\n        let keyModifiers = key.Modifiers\r\n        printfn \"key: %A, modifiers: %A\" keyChar keyModifiers\r\n        if keyChar = \u0027q\u0027 then\r\n            cont \u003c- false\r\n    ```\r\n\r\n2. Run the script with `dotnet fsi posix.fsx`\r\n3. Type any character except `\u0027q\u0027`. The key information will be printed out.\r\n4. Enter `Ctrl + C` and note that `\"Prevented Posix SIGINT\"` is printed out to the screen but that the process is still running, which can be verified by entering in other characters (again, besides `\u0027q\u0027`).\r\n5. Enter `Ctrl + Z` and note that:\r\n    * `[3]+  Stopped                 dotnet fsi posix.fsx` is printed to the screen\r\n    * The process is stopped, but then `\"Prevented Posix SIGTSTP\"` is printed out afterwards, after the new prompt is shown.\r\n    * However, the process *seems* to be restarted or still going, as it will respond to a key entry but usually only for one, and the process will end when `Enter` is entered. This behavior is a little inconsistent.\r\n\r\n### Expected behavior\r\n\r\nWhen `Ctrl + Z` is entered, `\"Prevented Posix SIGTSTP\"` should be printed to the console without the program being stopped.\r\n\r\n### Actual behavior\r\n\r\n```bash\r\n$ dotnet fsi posix.fsx\r\nSystem is Linux\r\nkey: \u0027a\u0027, modifiers: 0\r\nkey: \u0027\\013\u0027, modifiers: 0\r\nPrevented Posix SIGINT\r\nkey: \u0027a\u0027, modifiers: 0\r\n\r\n[2]+  Stopped                 dotnet fsi posix.fsx\r\n$ Prevented Posix SIGTSTP\r\nkey: \u0027a\u0027, modifiers: 0\r\n\r\n$ \r\n```\r\n\r\n### Regression?\r\n\r\nNot sure.\r\n\r\n### Known Workarounds\r\n\r\nNone that I know of.\r\n\r\n### Configuration\r\n\r\n```bash\r\n$ dotnet --version\r\n7.0.100\r\n\r\n$ lsb_release -a\r\nNo LSB modules are available.\r\nDistributor ID: Ubuntu\r\nDescription:    Ubuntu 20.04.5 LTS\r\nRelease:        20.04\r\nCodename:       focal\r\n```\r\n\r\nThe architecture is x64.\r\n\r\n### Other information\r\n\r\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ebmitc\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-11-14T06:02:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5OSPI5",
                                           "createdAt":  "2022-11-14T09:59:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e This should cancel the signal\r\n\r\nThe semantics of `Cancel` depend on the signal and what use-case we want to enable.\r\n\r\n`SIGTSTP` was added on request of @alexrp (https://github.com/dotnet/runtime/issues/50527#issuecomment-812840192).\r\nWe didn\u0027t diverge much into his specific use-case when including it.\r\n\r\nWe should look at the use-case and see what is the meaningful behavior when `Cancel` is `true`/`false`.\r\n\r\nLooking at the code, I think they currently both do the same thing: prevent `SIGTSTP` from stopping the app.",
                                           "updatedAt":  "2022-11-14T09:59:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5OSb1a",
                                           "createdAt":  "2022-11-14T10:38:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "alexrp",
                                           "body":  "My understanding (and reason for bringing it up back then) is that the common use case for handling `SIGTSTP` is to save any critical program state before it\u0027s suspended. I would expect a program to do that in the event handler, so no need to set `Cancel = true`.\r\n\r\nI can\u0027t really think of why one would want to completely block `SIGTSTP`. Seeing as `SIGSTOP` can\u0027t be blocked anyway, there\u0027s no way to \u0027opt out\u0027 of suspension altogether. In any case, I would expect `Cancel` to do the intuitive thing: `true` blocks the signal, `false` lets it go through (so the program gets suspended).",
                                           "updatedAt":  "2022-11-14T10:38:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5OTH7-",
                                           "createdAt":  "2022-11-14T12:46:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e I would expect Cancel to do the intuitive thing: true blocks the signal, false lets it go through (so the program gets suspended).\r\n\r\nWe can change it to do that, which is a breaking change, but probably the desired behavior.\r\n\r\nWhen at its default value of `Cancel = false`, the process will then be stopped. (by sending `SIGSTOP` to it after the handler ran).\r\nWhen set to `Cancel = true`, the process will keep running.\r\n\r\n@bmitc how does that sound to you?",
                                           "updatedAt":  "2022-11-14T12:46:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RkA42",
                                           "createdAt":  "2023-01-01T09:12:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bmitc",
                                           "body":  "I apologize for getting back to this so late. This is a side project that got pushed aside. Thank you @tmds and @alexrp for responding so quickly to this, and I\u0027m again sorry for the delay.\r\n\r\nMy use case was using pure F# to implement the modified Kilo text editor described in [Build Your Own Text Editor](https://viewsourcecode.org/snaptoken/kilo/index.html). Specifically, it was in implementing the section [Turn off `Ctrl-C` and `Ctrl-Z` signals](https://viewsourcecode.org/snaptoken/kilo/02.enteringRawMode.html#turn-off-ctrl-c-and-ctrl-z-signals) where I came across this issue. The tutorial uses the C library [termios](https://man7.org/linux/man-pages/man3/termios.3.html) to accomplish disabling `SIGINT` and `SIGTSTP`. For reference (also in the above link):\r\n\r\n\u003e By default, `Ctrl-C` sends a `SIGINT` signal to the current process which causes it to terminate, and `Ctrl-Z` sends a `SIGTSTP` signal to the current process which causes it to suspend. Let’s turn off the sending of both of these signals.\r\n\r\nBut to do this behavior in pure F#/.NET, I was needing the `PosixSignal.SIGINT` and `PosixSignal.SIGTSTP` signals actually canceled when doing `context.Cancel \u003c- true`. I think a terminal text editor is probably a legitimate use case for canceling these, although admittedly is probably a rare one.\r\n\r\nHowever, I am not remotely close to an expert on terminal implementations, which is one reason why I was working through this tutorial, so it\u0027s possible I misunderstand something here.",
                                           "updatedAt":  "2023-01-01T09:12:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5SLm9r",
                                           "createdAt":  "2023-01-11T13:44:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e Specifically, it was in implementing the section [Turn off Ctrl-C and Ctrl-Z signals](https://viewsourcecode.org/snaptoken/kilo/02.enteringRawMode.html#turn-off-ctrl-c-and-ctrl-z-signals) where I came across this issue. The tutorial uses the C library [termios](https://man7.org/linux/man-pages/man3/termios.3.html) to accomplish disabling SIGINT and SIGTSTP. For reference (also in the above link):\r\n\r\nBesides adding the `PosixSignalRegistration`, you should also set `Console.TreatControlCAsInput` to `true`.\r\n\r\nThen you\u0027ll be able to read the Ctrl-C and Ctrl-Z combinations.\r\n\r\n`KeyChar` will be the raw control value as mentioned in the article (_Now Ctrl-C can be read as a 3 byte and Ctrl-Z can be read as a 26 byte._). `ConsoleKey` will be set based on that.",
                                           "updatedAt":  "2023-01-11T13:44:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iZCL5",
                                           "createdAt":  "2023-07-26T00:08:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "Moving this to .NET 9 as the likely fix is a breaking change and we\u0027re pretty late into .NET 8 for breaking changes.",
                                           "updatedAt":  "2023-07-26T00:08:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GDPTH",
                                           "createdAt":  "2024-07-24T22:23:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "Sadly we didn\u0027t get to this in .NET 9 and it is likely still a breaking change, so moving to .NET 10.",
                                           "updatedAt":  "2024-07-24T22:23:08Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "Canceling the `PosixSignal.SIGTSTP` does not seem to be handled correctly",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/78846",
        "createdAt":  "2022-11-25T12:22:21Z",
        "number":  78846,
        "author":  "IS4Code",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-12-09T04:09:53Z",
        "body":  "### Background and motivation\r\n\r\nThis is a broader counterpart to #45232 for delegates. As far as I know, there is no supported way to get the managed function pointer from a delegate in a fashion that would make it callable through `delegate*` in C# (for static methods, you can obtain it via reflection from `_methodPtrAux` or `interp_method` on Mono).\r\n\r\nI suggest a method like `System.Runtime.CompilerServices.RuntimeHelpers.GetFunctionPointer(Delegate)`, returning `IntPtr` or perhaps `void*` to make it more \"unsafe\". For delegates without a target, it should be equivalent to obtaining the inner pointer.\r\n\r\nFor delegates with a target, there are three options here:\r\n\r\n* Obtain \"`_methodPtr`\", ignoring the target and assuming that the user provides it when calling the delegate.\r\n* Throw an exception, since the first option would mean that the result depends on something usually irrelevant when calling a delegate. The user would have to re-bind the method without a target first.\r\n* Generate a \"thunk\" in a fashion similar to `Marshal.GetFunctionPointerForDelegate`, wrapping the target and the function pointer. I am most in favour of this option, since it is consistent with calling the actual delegate normally, even though it is non-trivial to implement. This would give it a considerable advantage over `RuntimeMethodHandle.GetFunctionPointer` (other than this working for dynamic methods).\r\n\r\nThe resulting pointer should be valid at least for as long as the delegate exists (comparable to the lifetime of an interior pointer to an object). This would come in handy as a general method to efficiently handle all situations and improve interoperability between function pointers and delegates (dotnet/csharplang#3680) without having to deal with all the peculiarities.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Runtime.CompilerServices;\r\n\r\npublic static class RuntimeHelpers\r\n{\r\n    public static void* GetFunctionPointer(Delegate function);\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\nAction\u003cstring\u003e func = Console.WriteLine;\r\nvar ptr = (delegate*\u003cstring, void\u003e)System.Runtime.CompilerServices.RuntimeHelpers.GetFunctionPointer(func);\r\nptr(\"Hello world!\");\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nAnother option is to make `RuntimeMethodHandle.GetFunctionPointer` work for dynamic methods, which would at least fix the existing issues, but being able to obtain the pointer for *any* delegate would still be useful (considering that\u0027s something generally impossible to do in languages like C or C++).\r\n\r\n### Risks\r\n\r\nThere are potential issues with the lifetime of the pointer which are similar to `Marshal.GetFunctionPointerForDelegate`, however I think that since the user has to use unsafe context in the first place anyway, this is something to be expected.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOT1E0rA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5PHqaR",
                                           "createdAt":  "2022-11-25T12:22:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-11-25T12:22:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PHyId",
                                           "createdAt":  "2022-11-25T12:55:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCwND8Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "IS4Code",
                                                                               "createdAt":  "2022-11-25T13:10:07Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "HighPerfDotNet",
                                                                               "createdAt":  "2022-11-25T15:13:13Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "DaZombieKiller",
                                           "body":  "The `MethodHandle` property is currently disallowed on `DynamicMethod` because it supposedly cannot be tracked by the GC, but I\u0027m skeptical of this still being the case. The current CoreCLR implementation of `RuntimeMethodHandle` just stores an `IRuntimeMethodInfo` instance, which should be capable of keeping the `DynamicMethod` instance alive.\r\n\r\nOnce the `RuntimeMethodHandle` is converted to an `IntPtr` or a function pointer, it can no longer be tracked, but that is no different to the behavior you get with any other kind of method handle.\r\n\r\nMaybe someone from the .NET team can clear up whether or not this is still a problem for `DynamicMethod`?\r\n\r\nNote that for pointers to instance methods, there is currently no safe way to directly invoke such a function pointer from C# because we cannot declare managed function pointers with the `HasThis` calling convention. So even if you could use `GetFunctionPointer`, that doesn\u0027t mean you would be able to actually call it without additional work.\r\n\r\nThe theoretical syntax to allow that would be along the lines of:\r\n```cs\r\ndelegate* managed[HasThis]\u003cobject, int\u003e fp = \u0026obj.GetHashCode;\r\n```\r\n\r\nOn CoreCLR there is an internal [GetMethodDescriptor](https://github.com/dotnet/runtime/blob/4832236b4820ca83bbc9ce96003c2029b85c6ce2/src/coreclr/System.Private.CoreLib/src/System/Reflection/Emit/DynamicMethod.CoreCLR.cs#L82-L104) method that you can invoke through reflection to get a `RuntimeMethodHandle` for a `DynamicMethod`, but that is of course entering unsupported territory.",
                                           "updatedAt":  "2022-11-25T12:55:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PH77U",
                                           "createdAt":  "2022-11-25T13:28:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "IS4Code",
                                           "body":  "\u003e Note that for pointers to instance methods, there is currently no safe way to directly invoke such a function pointer from C# because we cannot declare managed function pointers with the HasThis calling convention. So even if you could use GetFunctionPointer, that doesn\u0027t mean you would be able to actually call it without additional work.\r\n\r\nYeah, that would be more complicated, hence I was thinking more about using a thunk that removes `HasThis` in such a case. It seems `_methodPtrAux` actually already contains such a thunk, so it\u0027s just a matter of exposing it like I suggested.",
                                           "updatedAt":  "2022-11-25T13:28:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PLDt7",
                                           "createdAt":  "2022-11-27T17:20:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\r\n\r\nThis is a broader counterpart to #45232 for delegates. As far as I know, there is no supported way to get the managed function pointer from a delegate in a fashion that would make it callable through `delegate*` in C# (for static methods, you can obtain it via reflection from `_methodPtrAux` or `interp_method` on Mono).\r\n\r\nI suggest a method like `System.Runtime.CompilerServices.RuntimeHelpers.GetFunctionPointer(Delegate)`, returning `IntPtr` or perhaps `void*` to make it more \"unsafe\". For delegates without a target, it should be equivalent to obtaining the inner pointer.\r\n\r\nFor delegates with a target, there are three options here:\r\n\r\n* Obtain \"`_methodPtr`\", ignoring the target and assuming that the user provides it when calling the delegate.\r\n* Throw an exception, since the first option would mean that the result depends on something usually irrelevant when calling a delegate. The user would have to re-bind the method without a target first.\r\n* Generate a \"thunk\" in a fashion similar to `Marshal.GetFunctionPointerForDelegate`, wrapping the target and the function pointer. I am most in favour of this option, since it is consistent with calling the actual delegate normally, even though it is non-trivial to implement. This would give it a considerable advantage over `RuntimeMethodHandle.GetFunctionPointer` (other than this working for dynamic methods).\r\n\r\nThe resulting pointer should be valid at least for as long as the delegate exists (comparable to the lifetime of an interior pointer to an object). This would come in handy as a general method to efficiently handle all situations and improve interoperability between function pointers and delegates (dotnet/csharplang#3680) without having to deal with all the peculiarities.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Runtime.CompilerServices;\r\n\r\npublic static class RuntimeHelpers\r\n{\r\n    public static void* GetFunctionPointer(Delegate function);\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\nAction\u003cstring\u003e func = Console.WriteLine;\r\nvar ptr = (delegate*\u003cstring, void\u003e)System.Runtime.CompilerServices.RuntimeHelpers.GetFunctionPointer(func);\r\nptr(\"Hello world!\");\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nAnother option is to make `RuntimeMethodHandle.GetFunctionPointer` work for dynamic methods, which would at least fix the existing issues, but being able to obtain the pointer for *any* delegate would still be useful (considering that\u0027s something generally impossible to do in languages like C or C++).\r\n\r\n### Risks\r\n\r\nThere are potential issues with the lifetime of the pointer which are similar to `Marshal.GetFunctionPointerForDelegate`, however I think that since the user has to use unsafe context in the first place anyway, this is something to be expected.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eIllidanS4\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Runtime.InteropServices`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-11-27T17:20:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PUTSs",
                                           "createdAt":  "2022-11-29T14:20:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCw973A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2022-11-29T15:05:48Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MichalStrehovsky",
                                                                               "createdAt":  "2022-11-29T21:12:20Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2022-12-09T04:09:00Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "lambdageek",
                                           "body":  "One additional consideration for this API proposal is that it may not be very AOT friendly.  Specifically, if we have to generate a thunk (ie the third option for methods with a target), it\u0027s unclear that we will know at AOT time that one is required.  Mono previously solved this by adding a `[MonoPInvokeCallback(typeof(Action\u003cint\u003e))]` attribute on methods - specifying the delegate that the method would be wrapped in and giving a hint to the AOT compiler that a thunk will be needed.\r\n\r\nI think even options 1 and 2 may need some runtime code gen on some calling conventions to adopt between the caller (expected to pass a target object) and the callee (expecting a `this` pointer), which is also not AOT friendly.",
                                           "updatedAt":  "2022-11-29T14:20:35Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "[API Proposal]: GetFunctionPointer for delegates",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/79413",
        "createdAt":  "2022-12-08T19:36:34Z",
        "number":  79413,
        "author":  "AaronRobinsonMSFT",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCuOGTw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DaZombieKiller",
                                            "createdAt":  "2022-12-09T07:32:25Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "tdecroyere",
                                            "createdAt":  "2023-02-03T14:55:34Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2022-12-08T19:42:35Z",
        "body":  "The [XGBoost API](https://xgboost.readthedocs.io/en/stable/c.html) contains several APIs where memory management is internally handled and callers are assumed to ignore the lifetime concern. For example, consider the possible projection of the [`XGDMatrixGetFloatInfo `](https://xgboost.readthedocs.io/en/stable/c.html#_CPPv421XGDMatrixGetFloatInfoK13DMatrixHandlePKcP9bst_ulongPPKf) API.\r\n\r\n```csharp\r\npublic static partial int XGDMatrixGetFloatInfo(\r\n    IntPtr handle,\r\n    string field,\r\n    out ulong len,\r\n    [MarshalUsing(CountElementName = \"len\")] out Span\u003cfloat\u003e result);\r\n```\r\n\r\nThe above API suffers from two deficiencies. The first is the returned length is a `ulong` (64-bit), but `Span\u003cT\u003e` only supports lengths of `int`, the other is the returned pointer will be copied into managed memory by source generated and the unmanaged pointer freed by the `Span\u003cT\u003e` marshaller. The semantics of the C API dictate the unmanaged memory shouldn\u0027t be freed, so when it is heap corruption will ensue.\r\n\r\nWe should consider a mechanism for indicating returned unmanaged memory isn\u0027t to be freed. Note this particular API would still be broken due to the `int` vs `ulong` length conflict.\r\n\r\nRelated: https://github.com/dotnet/runtime/issues/76974",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOUBCaBw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5QEIPZ",
                                           "createdAt":  "2022-12-08T19:36:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThe [XGBoost API](https://xgboost.readthedocs.io/en/stable/c.html) contains several APIs where memory management is internally handled and callers are assumed to ignore the lifetime concern. For example, consider the possible projection of the [`XGDMatrixGetFloatInfo `](https://xgboost.readthedocs.io/en/stable/c.html#_CPPv421XGDMatrixGetFloatInfoK13DMatrixHandlePKcP9bst_ulongPPKf) API.\r\n\r\n```csharp\r\npublic static partial int XGDMatrixGetFloatInfo(\r\n    IntPtr handle,\r\n    string field,\r\n    out ulong len,\r\n    [MarshalUsing(CountElementName = \"len\")] out Span\u003cfloat\u003e result);\r\n```\r\n\r\nThe above API suffers from two deficiencies. The first is the returned length is a `ulong` (64-bit), but `Span\u003cT\u003e` only supports lengths of `int`, the other is the returned pointer will be copied into managed memory by source generated and the unmanaged pointer freed by the `Span\u003cT\u003e` marshaller. The semantics of the C API dictate the unmanaged memory shouldn\u0027t be freed so when it is heap corruption will ensue.\r\n\r\nWe should consider a mechanism for indicating returned unmanaged memory isn\u0027t to be freed. Note this particular API would still be broken due to the `int` vs `ulong` length conflict.\r\n\r\nRelated: https://github.com/dotnet/runtime/issues/76974\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eAaronRobinsonMSFT\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003eFuture\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-12-08T19:36:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5QEJoH",
                                           "createdAt":  "2022-12-08T19:42:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC1ZvCQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2022-12-09T03:16:08Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Zintom",
                                                                               "createdAt":  "2022-12-09T09:35:33Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tdecroyere",
                                                                               "createdAt":  "2023-02-03T14:55:30Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "elinor-fung",
                                           "body":  "Same deal for array:\r\n```csharp\r\npublic static partial int XGDMatrixGetFloatInfo(\r\n    IntPtr handle,\r\n    string field,\r\n    out ulong len,\r\n    [MarshalUsing(CountElementName = \"len\")] out float[] result);\r\n```",
                                           "updatedAt":  "2022-12-08T19:42:35Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Returning `Span\u003cT\u003e` assumes memory management",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/79702",
        "createdAt":  "2022-12-15T13:56:15Z",
        "number":  79702,
        "author":  "Tan90909090",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-18T07:00:48Z",
        "body":  "### Description\n\nLibraryImportGenerator generate a source that calls statefull-marshaller-with-caller-allocated-buffer\u0027s FromManaged method for value parameters and in parameters. But the source does not call statefull-marshaller\u0027s FromManaged for ref parameters\n\n### Reproduction Steps\n\nWrite a following code:\r\n```cs\r\nusing System;\r\nusing System.Runtime.CompilerServices;\r\nusing System.Runtime.InteropServices;\r\nusing System.Runtime.InteropServices.Marshalling;\r\n\r\nnamespace N;\r\n\r\ninternal struct Managed { }\r\ninternal struct Unmanaged { }\r\n\r\n[CustomMarshaller(typeof(Managed), MarshalMode.Default, typeof(CustomMarshaller))]\r\ninternal struct CustomMarshaller\r\n{\r\n    public static int BufferSize =\u003e 16;\r\n    public void FromManaged(Managed managed, Span\u003cbyte\u003e buffer) { }\r\n    public Unmanaged ToUnmanaged() =\u003e new();\r\n    public void FromUnmanaged(Unmanaged unmanaged) { }\r\n    public Managed ToManaged() =\u003e new();\r\n    public void Free() { }\r\n}\r\n\r\ninternal static partial class NativeMethods\r\n{\r\n    [LibraryImport(\"Sample\")]\r\n    internal static partial void Sample(\r\n        [MarshalUsing(typeof(CustomMarshaller))] Managed valueParam,\r\n        [MarshalUsing(typeof(CustomMarshaller))] in Managed inParam,\r\n        [MarshalUsing(typeof(CustomMarshaller))] ref Managed refParam);\r\n}\r\n```\n\n### Expected behavior\n\nLibraryImportGenerator generates a code that calls `FromManaged` and `ToUnmanaged` for value parameters, in parameters, and ref parameters.\n\n### Actual behavior\n\nLibraryImportGenerator generates a following code:\r\n```cs\r\n// \u003cauto-generated/\u003e\r\nnamespace N\r\n{\r\n    internal static unsafe partial class NativeMethods\r\n    {\r\n        [System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.Interop.LibraryImportGenerator\", \"7.0.7.1805\")]\r\n        [System.Runtime.CompilerServices.SkipLocalsInitAttribute]\r\n        internal static partial void Sample(global::N.Managed valueParam, in global::N.Managed inParam, ref global::N.Managed refParam)\r\n        {\r\n            global::N.Unmanaged __valueParam_native = default;\r\n            global::N.Unmanaged __inParam_native = default;\r\n            global::N.Unmanaged __refParam_native = default;\r\n            // Setup - Perform required setup.\r\n            global::N.CustomMarshaller __valueParam_native__marshaller = new();\r\n            global::N.CustomMarshaller __inParam_native__marshaller = new();\r\n            global::N.CustomMarshaller __refParam_native__marshaller = new();\r\n            try\r\n            {\r\n                // Marshal - Convert managed data to native data.\r\n                byte* __valueParam_native__stackptr = stackalloc byte[global::N.CustomMarshaller.BufferSize];\r\n                __valueParam_native__marshaller.FromManaged(valueParam, new System.Span\u003cbyte\u003e(__valueParam_native__stackptr, global::N.CustomMarshaller.BufferSize));\r\n                byte* __inParam_native__stackptr = stackalloc byte[global::N.CustomMarshaller.BufferSize];\r\n                __inParam_native__marshaller.FromManaged(inParam, new System.Span\u003cbyte\u003e(__inParam_native__stackptr, global::N.CustomMarshaller.BufferSize));\r\n                {\r\n                    // PinnedMarshal - Convert managed data to native data that requires the managed data to be pinned.\r\n                    __valueParam_native = __valueParam_native__marshaller.ToUnmanaged();\r\n                    __inParam_native = __inParam_native__marshaller.ToUnmanaged();\r\n                    __refParam_native = __refParam_native__marshaller.ToUnmanaged();\r\n                    __PInvoke(__valueParam_native, \u0026__inParam_native, \u0026__refParam_native);\r\n                }\r\n\r\n                // UnmarshalCapture - Capture the native data into marshaller instances in case conversion to managed data throws an exception.\r\n                __refParam_native__marshaller.FromUnmanaged(__refParam_native);\r\n                // Unmarshal - Convert native data to managed data.\r\n                refParam = __refParam_native__marshaller.ToManaged();\r\n            }\r\n            finally\r\n            {\r\n                // Cleanup - Perform required cleanup.\r\n                __valueParam_native__marshaller.Free();\r\n                __inParam_native__marshaller.Free();\r\n                __refParam_native__marshaller.Free();\r\n            }\r\n\r\n            // Local P/Invoke\r\n            [System.Runtime.InteropServices.DllImportAttribute(\"Sample\", EntryPoint = \"Sample\", ExactSpelling = true)]\r\n            static extern unsafe void __PInvoke(global::N.Unmanaged valueParam, global::N.Unmanaged* inParam, global::N.Unmanaged* refParam);\r\n        }\r\n    }\r\n}\r\n```\r\nThe above code calls `ToUnmanaged` but does not call `FromManaged` for ref parameter `refParam`.\n\n### Regression?\n\nNo\n\n### Known Workarounds\n\nI don\u0027t know\n\n### Configuration\n\n- .NET 7\r\n- Windows 10 Pro 10.0.19045 N/A Build 19045\r\n- Build target is x86\r\n\n\n### Other information\n\nIf I use stateless-marshaller-with-caller-allocated-buffer then LibraryImportGenerator generates a code that calls `ConvertToUnmanaged(Managed managed)` instead of `ConvertToUnmanaged(Managed managed, Span\u003cbyte\u003e callerAllocatedBuffer)` for ref parameter:\r\n```cs\r\nusing System;\r\nusing System.Runtime.CompilerServices;\r\nusing System.Runtime.InteropServices;\r\nusing System.Runtime.InteropServices.Marshalling;\r\n\r\nnamespace N;\r\n\r\ninternal struct Managed { }\r\ninternal struct Unmanaged { }\r\n\r\n[CustomMarshaller(typeof(Managed), MarshalMode.Default, typeof(CustomMarshaller))]\r\ninternal static class CustomMarshaller\r\n{\r\n    public static int BufferSize =\u003e 16;\r\n    public static Unmanaged ConvertToUnmanaged(Managed managed) =\u003e new();\r\n    public static Unmanaged ConvertToUnmanaged(Managed managed, Span\u003cbyte\u003e callerAllocatedBuffer) =\u003e new();\r\n    public static Managed ConvertToManaged(Unmanaged unmanaged) =\u003e new();\r\n}\r\n\r\ninternal static partial class NativeMethods\r\n{\r\n    [LibraryImport(\"Sample\")]\r\n    internal static partial void Sample(\r\n        [MarshalUsing(typeof(CustomMarshaller))] Managed valueParam,\r\n        [MarshalUsing(typeof(CustomMarshaller))] in Managed inParam,\r\n        [MarshalUsing(typeof(CustomMarshaller))] ref Managed refParam);\r\n}\r\n```\r\n```cs\r\nnamespace N\r\n{\r\n    internal static unsafe partial class NativeMethods\r\n    {\r\n        [System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.Interop.LibraryImportGenerator\", \"7.0.7.1805\")]\r\n        [System.Runtime.CompilerServices.SkipLocalsInitAttribute]\r\n        internal static partial void Sample(global::N.Managed valueParam, in global::N.Managed inParam, ref global::N.Managed refParam)\r\n        {\r\n            global::N.Unmanaged __valueParam_native;\r\n            global::N.Unmanaged __inParam_native;\r\n            global::N.Unmanaged __refParam_native;\r\n            // Marshal - Convert managed data to native data.\r\n            System.Span\u003cbyte\u003e __valueParam_native__buffer = stackalloc byte[global::N.CustomMarshaller.BufferSize];\r\n            __valueParam_native = global::N.CustomMarshaller.ConvertToUnmanaged(valueParam, __valueParam_native__buffer);\r\n            System.Span\u003cbyte\u003e __inParam_native__buffer = stackalloc byte[global::N.CustomMarshaller.BufferSize];\r\n            __inParam_native = global::N.CustomMarshaller.ConvertToUnmanaged(inParam, __inParam_native__buffer);\r\n            __refParam_native = global::N.CustomMarshaller.ConvertToUnmanaged(refParam);\r\n            {\r\n                __PInvoke(__valueParam_native, \u0026__inParam_native, \u0026__refParam_native);\r\n            }\r\n\r\n            // Unmarshal - Convert native data to managed data.\r\n            refParam = global::N.CustomMarshaller.ConvertToManaged(__refParam_native);\r\n            // Local P/Invoke\r\n            [System.Runtime.InteropServices.DllImportAttribute(\"Sample\", EntryPoint = \"Sample\", ExactSpelling = true)]\r\n            static extern unsafe void __PInvoke(global::N.Unmanaged valueParam, global::N.Unmanaged* inParam, global::N.Unmanaged* refParam);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nIs this an expected behavior?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOWEBpgQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5QpxxR",
                                           "createdAt":  "2022-12-15T13:56:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nLibraryImportGenerator generate a source that calls statefull-marshaller-with-caller-allocated-buffer\u0027s FromManaged method for value parameters and in parameters. But the source does not call statefull-marshaller\u0027s FromManaged for ref parameters\n\n### Reproduction Steps\n\nWrite a following code:\r\n```cs\r\nusing System;\r\nusing System.Runtime.CompilerServices;\r\nusing System.Runtime.InteropServices;\r\nusing System.Runtime.InteropServices.Marshalling;\r\n\r\nnamespace N;\r\n\r\ninternal struct Managed { }\r\ninternal struct Unmanaged { }\r\n\r\n[CustomMarshaller(typeof(Managed), MarshalMode.Default, typeof(CustomMarshaller))]\r\ninternal struct CustomMarshaller\r\n{\r\n    public static int BufferSize =\u003e 16;\r\n    public void FromManaged(Managed managed, Span\u003cbyte\u003e buffer) { }\r\n    public Unmanaged ToUnmanaged() =\u003e new();\r\n    public void FromUnmanaged(Unmanaged unmanaged) { }\r\n    public Managed ToManaged() =\u003e new();\r\n    public void Free() { }\r\n}\r\n\r\ninternal static partial class NativeMethods\r\n{\r\n    [LibraryImport(\"Sample\")]\r\n    internal static partial void Sample(\r\n        [MarshalUsing(typeof(CustomMarshaller))] Managed valueParam,\r\n        [MarshalUsing(typeof(CustomMarshaller))] in Managed inParam,\r\n        [MarshalUsing(typeof(CustomMarshaller))] ref Managed refParam);\r\n}\r\n```\n\n### Expected behavior\n\nLibraryImportGenerator generates a code that calls `FromManaged` and `ToUnmanaged` for value parameters, in parameters, and ref parameters.\n\n### Actual behavior\n\nLibraryImportGenerator generates a following code:\r\n```cs\r\n// \u003cauto-generated/\u003e\r\nnamespace N\r\n{\r\n    internal static unsafe partial class NativeMethods\r\n    {\r\n        [System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.Interop.LibraryImportGenerator\", \"7.0.7.1805\")]\r\n        [System.Runtime.CompilerServices.SkipLocalsInitAttribute]\r\n        internal static partial void Sample(global::N.Managed valueParam, in global::N.Managed inParam, ref global::N.Managed refParam)\r\n        {\r\n            global::N.Unmanaged __valueParam_native = default;\r\n            global::N.Unmanaged __inParam_native = default;\r\n            global::N.Unmanaged __refParam_native = default;\r\n            // Setup - Perform required setup.\r\n            global::N.CustomMarshaller __valueParam_native__marshaller = new();\r\n            global::N.CustomMarshaller __inParam_native__marshaller = new();\r\n            global::N.CustomMarshaller __refParam_native__marshaller = new();\r\n            try\r\n            {\r\n                // Marshal - Convert managed data to native data.\r\n                byte* __valueParam_native__stackptr = stackalloc byte[global::N.CustomMarshaller.BufferSize];\r\n                __valueParam_native__marshaller.FromManaged(valueParam, new System.Span\u003cbyte\u003e(__valueParam_native__stackptr, global::N.CustomMarshaller.BufferSize));\r\n                byte* __inParam_native__stackptr = stackalloc byte[global::N.CustomMarshaller.BufferSize];\r\n                __inParam_native__marshaller.FromManaged(inParam, new System.Span\u003cbyte\u003e(__inParam_native__stackptr, global::N.CustomMarshaller.BufferSize));\r\n                {\r\n                    // PinnedMarshal - Convert managed data to native data that requires the managed data to be pinned.\r\n                    __valueParam_native = __valueParam_native__marshaller.ToUnmanaged();\r\n                    __inParam_native = __inParam_native__marshaller.ToUnmanaged();\r\n                    __refParam_native = __refParam_native__marshaller.ToUnmanaged();\r\n                    __PInvoke(__valueParam_native, \u0026__inParam_native, \u0026__refParam_native);\r\n                }\r\n\r\n                // UnmarshalCapture - Capture the native data into marshaller instances in case conversion to managed data throws an exception.\r\n                __refParam_native__marshaller.FromUnmanaged(__refParam_native);\r\n                // Unmarshal - Convert native data to managed data.\r\n                refParam = __refParam_native__marshaller.ToManaged();\r\n            }\r\n            finally\r\n            {\r\n                // Cleanup - Perform required cleanup.\r\n                __valueParam_native__marshaller.Free();\r\n                __inParam_native__marshaller.Free();\r\n                __refParam_native__marshaller.Free();\r\n            }\r\n\r\n            // Local P/Invoke\r\n            [System.Runtime.InteropServices.DllImportAttribute(\"Sample\", EntryPoint = \"Sample\", ExactSpelling = true)]\r\n            static extern unsafe void __PInvoke(global::N.Unmanaged valueParam, global::N.Unmanaged* inParam, global::N.Unmanaged* refParam);\r\n        }\r\n    }\r\n}\r\n```\r\nThe above code calls `ToUnmanaged` but does not call `FromManaged` for ref parameter `refParam`.\n\n### Regression?\n\nNo\n\n### Known Workarounds\n\nI don\u0027t know\n\n### Configuration\n\n- .NET 7\r\n- Windows 10 Pro 10.0.19045 N/A Build 19045\r\n- Build target is x86\r\n\n\n### Other information\n\nIf I use stateless-marshaller-with-caller-allocated-buffer then LibraryImportGenerator generates a code that calls `ConvertToUnmanaged(Managed managed)` instead of `ConvertToUnmanaged(Managed managed, Span\u003cbyte\u003e callerAllocatedBuffer)` for ref parameter:\r\n```cs\r\nusing System;\r\nusing System.Runtime.CompilerServices;\r\nusing System.Runtime.InteropServices;\r\nusing System.Runtime.InteropServices.Marshalling;\r\n\r\nnamespace N;\r\n\r\ninternal struct Managed { }\r\ninternal struct Unmanaged { }\r\n\r\n[CustomMarshaller(typeof(Managed), MarshalMode.Default, typeof(CustomMarshaller))]\r\ninternal static class CustomMarshaller\r\n{\r\n    public static int BufferSize =\u003e 16;\r\n    public static Unmanaged ConvertToUnmanaged(Managed managed) =\u003e new();\r\n    public static Unmanaged ConvertToUnmanaged(Managed managed, Span\u003cbyte\u003e callerAllocatedBuffer) =\u003e new();\r\n    public static Managed ConvertToManaged(Unmanaged unmanaged) =\u003e new();\r\n}\r\n\r\ninternal static partial class NativeMethods\r\n{\r\n    [LibraryImport(\"Sample\")]\r\n    internal static partial void Sample(\r\n        [MarshalUsing(typeof(CustomMarshaller))] Managed valueParam,\r\n        [MarshalUsing(typeof(CustomMarshaller))] in Managed inParam,\r\n        [MarshalUsing(typeof(CustomMarshaller))] ref Managed refParam);\r\n}\r\n```\r\n```cs\r\nnamespace N\r\n{\r\n    internal static unsafe partial class NativeMethods\r\n    {\r\n        [System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.Interop.LibraryImportGenerator\", \"7.0.7.1805\")]\r\n        [System.Runtime.CompilerServices.SkipLocalsInitAttribute]\r\n        internal static partial void Sample(global::N.Managed valueParam, in global::N.Managed inParam, ref global::N.Managed refParam)\r\n        {\r\n            global::N.Unmanaged __valueParam_native;\r\n            global::N.Unmanaged __inParam_native;\r\n            global::N.Unmanaged __refParam_native;\r\n            // Marshal - Convert managed data to native data.\r\n            System.Span\u003cbyte\u003e __valueParam_native__buffer = stackalloc byte[global::N.CustomMarshaller.BufferSize];\r\n            __valueParam_native = global::N.CustomMarshaller.ConvertToUnmanaged(valueParam, __valueParam_native__buffer);\r\n            System.Span\u003cbyte\u003e __inParam_native__buffer = stackalloc byte[global::N.CustomMarshaller.BufferSize];\r\n            __inParam_native = global::N.CustomMarshaller.ConvertToUnmanaged(inParam, __inParam_native__buffer);\r\n            __refParam_native = global::N.CustomMarshaller.ConvertToUnmanaged(refParam);\r\n            {\r\n                __PInvoke(__valueParam_native, \u0026__inParam_native, \u0026__refParam_native);\r\n            }\r\n\r\n            // Unmarshal - Convert native data to managed data.\r\n            refParam = global::N.CustomMarshaller.ConvertToManaged(__refParam_native);\r\n            // Local P/Invoke\r\n            [System.Runtime.InteropServices.DllImportAttribute(\"Sample\", EntryPoint = \"Sample\", ExactSpelling = true)]\r\n            static extern unsafe void __PInvoke(global::N.Unmanaged valueParam, global::N.Unmanaged* inParam, global::N.Unmanaged* refParam);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nIs this an expected behavior?\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eTan90909090\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-12-15T13:56:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5YQGmB",
                                           "createdAt":  "2023-03-23T05:18:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "/cc @jkoritzinsky @elinor-fung ",
                                           "updatedAt":  "2023-03-23T05:18:01Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "LibraryImportGenerator should generate a source that calls statefull-marshaller-with-caller-allocated-buffer\u0027s FromManaged for ref parameter",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/79786",
        "createdAt":  "2022-12-17T10:46:21Z",
        "number":  79786,
        "author":  "am11",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC0QBZg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kasperk81",
                                            "createdAt":  "2022-12-21T20:35:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "RReverser",
                                            "createdAt":  "2023-11-27T14:43:53Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2025-03-20T12:33:08Z",
        "body":  "### Background and motivation\r\n\r\nIn .NET 7 we have:\r\n\r\n* `[JSImport]` and `[JSExport]` to import and export JavaScript entrypoints\r\n* `[LibraryImport]` and `[UnmanagedCallersOnly]` to import and export native entrypoints with specified calling convention\r\n\r\nFrom this outlook, `[UnmanagedCallersOnly]` name is unsymmetrical and the odd one out. \r\n\r\n`LibraryExport` as attribute name would have been much cleaner, especially for AOT scenarios. Aside from the naming:\r\n\r\n* \"exporting native entrypiont\" is not the only use-case of `UnmanagedCallersOnlyAttribute`; it was originally added for  roslyn to support `unmanaged` semantics.\r\n* it has a non-intuitive restriction for \"exporting native entrypoint\" that it doesn\u0027t work  without the explicit `EntryPoint` value.\r\n\r\nThere is a room to add a dedicated `LibraryExportAttribute` with a single intent, similar to `JSExportAttribute`.\r\n\r\nThis may also give a chance for runtimes to perform targeted optimizations (reduce # of frames around these calls in coreclr) with a slight ease than it is today.\r\n\r\n### API Proposal\r\n\r\n```c#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    [AttributeUsage(AttributeTargets.Method, Inherited = false)]\r\n    public class LibraryExportAttribute : Attribute\r\n    {\r\n        public LibraryExportAttribute() { }\r\n        public Type[]? CallConvs; // optional; defaults to current platform\u0027s calling convention\r\n        public string? EntryPoint; // unlike UnmanagedCallersOnly, this is optional for native export\r\n    }\r\n}\r\n```\r\n\r\n### API Usage\r\n\r\n```c#\r\n    [LibraryExport]\r\n    public static int GetDotnetMajorVersion() =\u003e Environment.Version.Major;\r\n```\r\n\r\ntest.c\r\n```c\r\n#include\u003cstdio.h\u003e\r\n\r\nextern int GetDotnetMajorVersion(void);\r\n\r\nint main()\r\n{\r\n  printf(\".NET major version is: %d\\n\", GetDotnetMajorVersion());\r\n  return GetDotnetMajorVersion();\r\n}\r\n```\r\n\r\n```sh\r\n$ dotnet publish -r linux-x64 -p:PublishAot=true -p:NativeLib=Shared\r\n$ cc test.c bin/Debug/net7.0/linux-x64/publish/mynativelib1.so\r\n\r\n$ ./a.out\r\n.NET major version is: 7\r\n\r\n$ echo $?\r\n7\r\n```\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\nConfuse the consumers who have made their peace with `UnmanagedCallersOnly(EntryPoint=\"mandatory_name\")`.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOo1XOCg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5Q1YaV",
                                           "createdAt":  "2022-12-17T10:46:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nIn .NET 7 we have:\r\n\r\n* `[JSImport]` and `[JSExport]` to import and export JavaScript entrypoints\r\n* `[LibraryImport]` and `[UnmanagedCallersOnly]` to import and export native entrypoints with specified calling convention\r\n\r\nFrom this outlook, `[UnmanagedCallersOnly]` name is unsymmetrical and the odd one out. \r\n\r\n`LibraryExport` as attribute name would have been much cleaner, especially for AOT scenarios. Aside from the naming:\r\n\r\n* \"exporting native entrypiont\" is not the only use-case of `UnmanagedCallersOnlyAttribute`; it was originally added for  roslyn to support `unmanaged` semantics.\r\n* it has a non-intuitive restriction for \"exporting native entrypoint\" that it doesn\u0027t work  without the explicit `EntryPoint` value.\r\n\r\nThere is a room to add a dedicated `LibraryExportAttribute` with a single intent, similar to `JSExportAttribute`.\r\n\r\nThis may also give a chance for runtimes to perform targeted optimizations (reduce # of frames around these calls in coreclr) with a slight ease than it is today.\n\n### API Proposal\n\n```c#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    [AttributeUsage(AttributeTargets.Method, Inherited = false)]\r\n    public class LibraryExportAttribute : Attribute\r\n    {\r\n        public LibraryExportAttribute() { }\r\n        public Type[]? CallConvs; // optional; defaults to current platform\u0027s calling convention\r\n        public string? EntryPoint; // unlike UnmanagedCallersOnly, this is optional for native export\r\n    }\r\n}\r\n```\n\n### API Usage\n\n```c#\r\n    [LibraryExport()]\r\n    public static int GetDotnetMajorVersion() =\u003e Environment.Version.Major;\r\n```\r\n\r\ntest.c\r\n```c\r\n#include\u003cstdio.h\u003e\r\n\r\nextern int GetDotnetMajorVersion(void);\r\n\r\nint main()\r\n{\r\n  printf(\".NET major version is: %d\\n\", GetDotnetMajorVersion());\r\n  return GetDotnetMajorVersion();\r\n}\r\n```\r\n\r\n```sh\r\n$ dotnet publish -r linux-x64 -p:PublishAot=true -p:NativeLib=Shared\r\n$ cc test.c bin/Debug/net7.0/linux-x64/publish/mynativelib1.so\r\n\r\n$ ./a.out\r\n.NET major version is: 7\r\n\r\n$ echo $?\r\n7\r\n```\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\nConfuse the consumers who have made their peace of with `UnmanagedCallersOnly(EntryPoint=\"mandatory_name\")`.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eam11\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Runtime.InteropServices`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-12-17T10:46:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Q1pwg",
                                           "createdAt":  "2022-12-17T12:43:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCxqdkw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kasperk81",
                                                                               "createdAt":  "2022-12-22T02:21:24Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "For symmetry with `LibraryImport`, `LibraryExport` should not have a `CallConvs` property and instead rely on the `UnmanagedCallConvAttribute` if exists.\r\n\r\nAnother thing to consider is to incorporate marshalling in the design of `LibraryExport`, and support exposing the generated blittable `UnmanagedCallersOnly` function to the user, so that we would be able to write something like this:\r\n\r\n```csharp\r\npublic unsafe partial class MyClass\r\n{\r\n    // GenerateNativeThunk to true would cause the source generator to emit a Callback_native\r\n    // method with UnmanagedCallersOnly inside the declaring class, instead of a file class\r\n    // to be seen by just NativeAOT.\r\n    [LibraryExport(StringMarshalling = StringMarshalling.Utf16, GenerateNativeThunk = true)]\r\n    private static void Callback(string s)\r\n    {\r\n        Console.WriteLine(s);\r\n    }\r\n\r\n    [LibraryImport(\"mylibrary\")]\r\n    private static void MyPInvoke(delegate* unmanaged\u003cchar*, void\u003e callback);\r\n\r\n    static void Main()\r\n    {\r\n        MyPInvoke(\u0026Callback_native);\r\n    }\r\n}\r\n```",
                                           "updatedAt":  "2022-12-17T12:43:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Q1wsz",
                                           "createdAt":  "2022-12-17T13:53:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "am11",
                                           "body":  "\u003e `LibraryExport` should not have a `CallConvs` property and instead rely on the `UnmanagedCallConvAttribute` if exists.\r\n\r\nSounds reasonable. I haven\u0027t put much thought into `CallConvs` and source generator, but if we can seamlessly resolve the user intent in source generator without `CallConvs` property, that would be a preferred shape for this attribute.\r\n\r\nThough I\u0027m not sure if lowering `LibraryExportAttribute` to `UnmanagedCallConvAttribute`  in source generator is what we would ultimately want in a long run, as these models are relatively new and runtimes can recognize `LibraryExport` directly (e.g. its support in Mono AOT is under development https://github.com/dotnet/runtime/issues/79377).",
                                           "updatedAt":  "2022-12-20T09:15:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Q19rR",
                                           "createdAt":  "2022-12-17T16:22:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCxh_FQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2022-12-20T01:30:11Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "As I\u0027m imagining it, `[LibraryExport]` would be the high-level equivalent of `[UnmanagedCallersOnly]` just like `[LibraryImport]` is the high-level equivalent of `[DllImport]`. The former would support source-generated marshalling and the latter wouldn\u0027t.",
                                           "updatedAt":  "2022-12-17T22:47:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Q2pIW",
                                           "createdAt":  "2022-12-17T23:48:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "I appreciate the symmetrically argument but I don\u0027t think this is appropriate. This is unfortunately an area where there isn\u0027t a clean separation and we would like to not introduce yet more confusion. The history here is tangled up in NativeAOT as well where we had an attribute that was similar - that is why we added the `EntryPoint` to `UnmanagedCallersOnly`. The `UnmanagedCallersOnly` already handles all needed scenarios, both internal and exporting and I don\u0027t see a lot of value in adding another just for symmetry sake. I will keep this on 8 for consideration but will likely close this toward the end of the release without a reason more compelling than \"symmetry\".",
                                           "updatedAt":  "2022-12-20T01:27:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Q8pxp",
                                           "createdAt":  "2022-12-19T18:34:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCxh_2A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2022-12-20T01:35:57Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "I think this would be a good feature to add and I would put this in a similar category as #63590.\r\n\r\nToday, we don\u0027t have a good mechanism for both providing unmanaged-callable functions and allowing marshalling without using the built-in marshalling system. This feature could be used as a counterpart to #63590 to enable implementing a fully-source-generated interop story for \"delegate marshalling\"-style scenarios.\r\n\r\nAdditionally, I think this feature actually fits well with our COM source-generation direction work, although possibly not the work that will make it into .NET 8 in particular. With the COM generator, we\u0027ll have support for both managed-\u003eunmanaged and unmanaged-\u003emanaged stubs for implementing source-generated CCW/RCW implementations that support all of the goodness of the new source-generation marshalling model we produced in .NET 7. However, to implement a COM server (a la comhost but for source-generated COM interop) entirely with source-generated code, a developer would still have to manually write out the marshalling for any parameters in the API the COM server must implement. This would be a weird corner where we\u0027d have a hole in our abstraction model.",
                                           "updatedAt":  "2022-12-19T18:34:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Q_Fuz",
                                           "createdAt":  "2022-12-20T01:35:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e As I\u0027m imagining it, [LibraryExport] would be the high-level equivalent of [UnmanagedCallersOnly] just like [LibraryImport] is the high-level equivalent of [DllImport]. The former would support source-generated marshalling and the latter wouldn\u0027t.\r\n\r\nI missed this statement. Using `LibraryExport` as a marshalling supported entry that would then be entered into via an exported `UnmanagedCallersOnly` does make sense. I was missing the notion of having the marshalling code generated as the original example:\r\n\r\n```csharp\r\n    [LibraryExport]\r\n    public static int GetDotnetMajorVersion() =\u003e Environment.Version.Major;\r\n```\r\n\r\nwould/could just be exported directly since there is no marshalling. This is similar to how when we detect a `LibraryImport` is fully blittable and create a forwarder `DllImport` that can be inlined instead of source generating anything.\r\n\r\n```csharp\r\n    [UnmanagedCallersOnly(EntryPoint = \"GetDotnetMajorVersion\")]\r\n    public static int GetDotnetMajorVersion() =\u003e GetDotnetMajorVersion();\r\n```\r\n\r\n",
                                           "updatedAt":  "2022-12-20T01:41:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Q_HAa",
                                           "createdAt":  "2022-12-20T01:45:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e `GenerateNativeThunk = true`\r\n\r\n@teo-tsirpanis I don\u0027t get this scenario. For the \"export\" scenario, under what circumstances would we not generate the `UnmanagedCallersOnly`?",
                                           "updatedAt":  "2022-12-20T01:45:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Q_Oiv",
                                           "createdAt":  "2022-12-20T02:23:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "\u003e \u003e `GenerateNativeThunk = true`\r\n\u003e \r\n\u003e @teo-tsirpanis I don\u0027t get this scenario. For the \"export\" scenario, under what circumstances would we not generate the `UnmanagedCallersOnly`?\r\n\r\nThe idea is when `GenerateNativeThunk=false`, the generated method is in a `file`-scoped class and is only exposed via a mechanism that supports projecting an `UnmanagedCallersOnlyAttribute` with the `EntryPoint` property set as a native export (i.e. DNNE, NativeAOT, MonoAOT starting in .NET 8). In this case, the user wouldn\u0027t be able to access the stub directly, but it would be exposed to native callers.\r\n\r\nWhen `GenerateNativeThunk=true`, the generated method would be in a type that is accessible from user-written code, so the user could write `\u0026ManagedMethod_UnmanagedWrapper` in their C# and get the unmanaged function pointer to the method.\r\n\r\nI don\u0027t know if this scenario is compelling enough to provide the two different options, and I think the `GenerateNativeThunk=true` scenario is more compelling at first glance.",
                                           "updatedAt":  "2022-12-20T02:23:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RAhPR",
                                           "createdAt":  "2022-12-20T09:47:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC1tY-A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kasperk81",
                                                                               "createdAt":  "2022-12-21T20:36:11Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "neon-sunset",
                                                                               "createdAt":  "2023-02-08T22:34:02Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "am11",
                                           "body":  "`UnmanagedCallersOnly` to me looks like a multi-purpose attribute; started off as a compiler support attribute and ended up supporting other scenarios like NativeAOT exports. I was particularly looking at the poor codegen around the exported entrypoints (which are probably hard to optimize with the current `UnmanagedCallersOnly` machinery). With `LibraryExport` new surface area, I was hoping if it could be designed in a way that the final codegen would shave off _some_ of the instructions in blittable / primitive scenarios (pertaining to GC, P/Invoke transitions etc.).\r\n\r\n\u003e I don\u0027t know if this scenario is compelling enough to provide the two different options, and I think the `GenerateNativeThunk=true` scenario is more compelling at first glance.\r\n\r\nProvided generator will emit linker-friendly code, linker will drop the unused code from wrapping type for export-only usages. With that in mind, I agree that an additional switch might not be necessary.",
                                           "updatedAt":  "2022-12-20T09:47:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RHWcI",
                                           "createdAt":  "2022-12-21T05:40:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCxoX4w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkoritzinsky",
                                                                               "createdAt":  "2022-12-21T07:36:17Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2022-12-21T14:00:45Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Where do you see inefficiencies in the existing `UnmanagedCallersOnly` that can be optimized? `UnmanagedCallersOnly` optimization should be independent on this proposal.",
                                           "updatedAt":  "2022-12-21T05:40:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RIKkT",
                                           "createdAt":  "2022-12-21T09:52:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC1tZDw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kasperk81",
                                                                               "createdAt":  "2022-12-21T20:36:07Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "neon-sunset",
                                                                               "createdAt":  "2023-02-08T22:34:27Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "am11",
                                           "body":  "@jkotas, agreed. This discussion has evolved to source generator which will emit `UnmanagedCallersOnly` under the hood and no longer an independent / parallel API to `UnmanagedCallersOnly`.\r\n\r\n\u003e Where do you see inefficiencies in the existing `UnmanagedCallersOnly` that can be optimized?\r\n\r\nI was initially looking at simple exports (involving primitive constructs and constants), e.g. with:\r\n```c#\r\nusing System.Runtime.InteropServices;\r\npublic class C\r\n{\r\n    [UnmanagedCallersOnly(EntryPoint = nameof(M))]\r\n    public static int M() =\u003e 42;\r\n}\r\n```\r\non linux-arm64, we get:\r\n```asm\r\n// function con42_C__M\r\n\r\nstp\tx29, x30, [sp, #-48]!\r\nstr\tx19, [sp, #40]\r\nmov\tx29, sp\r\nadd\tx0, x29, #0x18\r\nbl\t0x15d40 \u003cRhpReversePInvoke(ReversePInvokeFrame*)\u003e\r\nmov\tw19, #0x2a                  \t// #42\r\nadd\tx0, x29, #0x18\r\nbl\t0x15e14 \u003cRhpReversePInvokeReturn(ReversePInvokeFrame*)\u003e\r\nmov\tw0, w19\r\nldr\tx19, [sp, #40]\r\nldp\tx29, x30, [sp], #48\r\nret\r\n```\r\n\r\nI was thinking perhaps for simple cases like this one, it is possible to skip `ReversePInvokeFrame` and optimize it to inlineable `return 42`.",
                                           "updatedAt":  "2022-12-21T09:52:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RJLAn",
                                           "createdAt":  "2022-12-21T14:10:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCxpwsQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "kasperk81",
                                                                               "createdAt":  "2022-12-21T20:38:17Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e When GenerateNativeThunk=true, the generated method would be in a type that is accessible from user-written code, so the user could write \u0026ManagedMethod_UnmanagedWrapper in their C# and get the unmanaged function pointer to the method.\r\n\r\nI see. That seems like we are getting into more and more bespoke scenarios. However, the mechanism I believe would be simply to not set the `EntryPoint` field, right? If so, the cost would be quite small to provide the mechanism and avoid creating an \"export\". I could be mistaken but I though creating an \"export\" required setting the `EntryPoint`, so creating a file-scoped declaration wouldn\u0027t be needed.\r\n\r\n\u003e I don\u0027t know if this scenario is compelling enough to provide the two different options, and I think the GenerateNativeThunk=true scenario is more compelling at first glance.\r\n\r\nAgree.\r\n\r\n\u003e I was thinking perhaps for simple cases like this one, it is possible to skip ReversePInvokeFrame and optimize it to inlineable return 42.\r\n\r\nI think that is minor overhead all things considered. I say that because it is why the example with a blittable signature was so distracting. When factoring in the cost of marshalling non-trivial types, the transition and frames would become far less interesting relatively speaking. If we can see it under a profiler though that would be worth understanding.\r\n\r\nThe overhead you mention though is related to https://github.com/dotnet/runtime/issues/54107, in the sense of having a way to indicate an `UnmanagedCallersOnly` can skip boilerplate transition with something like `SuppressGCTransition`. This would only make sense in cases where it was a purely blittable API _and_ didn\u0027t reference any managed memory. Perhaps there is a better way to express this though or the JIT could compute those cases.",
                                           "updatedAt":  "2022-12-21T14:10:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RJ65h",
                                           "createdAt":  "2022-12-21T15:57:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC2Uyxw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2022-12-21T16:25:05Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "am11",
                                                                               "createdAt":  "2023-02-18T11:11:55Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "jkotas",
                                           "body":  "I agree with @AaronRobinsonMSFT that the optimizations of the reverse PInvoke transitions is same problem as #54107. It is something for JIT to do when it is safe. I do not think we would want to make it expressible in public surface.\r\n\r\n\u003e This would only make sense in cases where it was a purely blittable API and didn\u0027t reference any managed memory.\r\n\r\nThis also includes calls to any methods, including helpers that the JIT may choose to insert or that may run as side-effect of code execution. \r\n\r\nAlso, the code where this optimization kicked in would be impossible to debug with .NET managed debuggers. .NET managed debuggers expect that the thread transitions to cooperative mode before any code runs.",
                                           "updatedAt":  "2022-12-21T15:57:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5hJdU6",
                                           "createdAt":  "2023-07-10T23:30:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "We aren\u0027t going to get to this in .NET 8, moving to .NET 9.",
                                           "updatedAt":  "2023-07-10T23:30:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6jVc4K",
                                           "createdAt":  "2025-03-20T12:33:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEKvYCw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hexawyz",
                                                                               "createdAt":  "2025-03-20T15:28:53Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "ThaDaVos",
                                           "body":  "Curious if there are any updates on this since 2023",
                                           "updatedAt":  "2025-03-20T12:33:06Z"
                                       }
                                   ],
                         "totalCount":  16
                     },
        "title":  "[API Proposal]: `[LibraryExport]` analogous to `[JSExport]`",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/80204",
        "createdAt":  "2023-01-04T22:05:00Z",
        "number":  80204,
        "author":  "jkoritzinsky",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-03-22T23:44:57Z",
        "body":  "### Background and motivation\r\n\r\nAs part of our COM interop source generator work, we decided to start with implementing support first for the general concept of virtual function tables. Many native APIs, including JNI, MSQuic, and COM are either implemented or presented to users using tables of function pointers, either explicitly like MSQuic or implicitly through abstract member functions like JNI or COM. Providing this source generator would enable developers to use native APIs like these ones with user-friendly types using the new source-generated marshalling model instead of being forced to use the built-in marshalling model with `Marshal.GetDelegateForFunctionPointer` to manually marshal back a virtual method table or dropping down to manual marshalling with function pointers to get decent performance.\r\n\r\nThis source generator would enable generating code to call an unmanaged API projected to a managed interface and call a managed interface projected to an unmanaged table of function pointers.\r\n\r\nWe plan on providing guidance directing users to use these APIs to override behavior from the COM source generator (they will integrate cleanly)\r\n\r\n### API Proposal\r\n\r\nThese APIs fall into two categories:\r\n\r\n1. APIs that allow developers to define managed APIs that represent unmanaged virtual method tables (such as COM, JNI, MsQuic).\r\n2. APIs that represent concepts that the COM source generator could use as building blocks that are also designed to be seamlessly integrated with the APIs in the first category.\r\n\r\n```csharp\r\n// Types that are only needed for the VTable source generator or to provide abstract concepts that the COM generator would use under the hood.\r\n// These are types that we can exclude from the API proposals and either inline into the generated code, provide as file-scoped types, or not provide publicly (indicated by comments on each type).\r\n\r\nusing System.Numerics;\r\n\r\nnamespace System.Runtime.InteropServices.Marshalling;\r\n\r\n/// \u003csummary\u003e\r\n/// A factory to create an unmanaged \"this pointer\" from a managed object and to get a managed object from an unmanaged \"this pointer\".\r\n/// \u003c/summary\u003e\r\n/// \u003cremarks\u003e\r\n/// This interface would be used by the VTable source generator to enable users to indicate how to get the managed object from the \"this pointer\".\r\n/// We can hard-code the ComWrappers logic here if we don\u0027t want to ship this interface.\r\n/// \u003c/remarks\u003e\r\npublic unsafe interface IUnmanagedObjectUnwrapper\r\n{\r\n    /// \u003csummary\u003e\r\n    /// Get the object wrapped by \u003cparamref name=\"ptr\"/\u003e.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cparam name=\"ptr\"\u003eA an unmanaged \"this pointer\".\u003c/param\u003e\r\n    /// \u003creturns\u003eThe object wrapped by \u003cparamref name=\"ptr\"/\u003e.\u003c/returns\u003e\r\n    public static abstract object GetObjectForUnmanagedWrapper(void* ptr);\r\n}\r\n\r\n// This attribute provides the mechanism for the VTable source generator to know which type to use to get the managed object\r\n// from the unmanaged \"this\" pointer. If we decide to not expose VirtualMethodIndexAttribute, we don\u0027t need to expose this.\r\n[AttributeUsage(AttributeTargets.Interface)]\r\npublic class UnmanagedObjectUnwrapperAttribute\u003cTMapper\u003e : Attribute\r\n    where TMapper : IUnmanagedObjectUnwrapper\r\n{\r\n}\r\n\r\n// This type implements the logic to get the managed object from the unmanaged \"this\" pointer.\r\n// If we decide to not expose the VTable source generator, we don\u0027t need to expose this and we can just inline the logic\r\n// into the generated code in the source generator.\r\npublic sealed unsafe class ComWrappersUnwrapper : IUnmanagedObjectUnwrapper\r\n{\r\n    public static object GetObjectForUnmanagedWrapper(void* ptr)\r\n    {\r\n        return ComWrappers.ComInterfaceDispatch.GetInstance\u003cobject\u003e((ComWrappers.ComInterfaceDispatch*)ptr);\r\n    }\r\n}\r\n\r\n/// \u003csummary\u003e\r\n/// Marshals an exception object to the value of its \u003csee cref=\"Exception.HResult\"/\u003e converted to \u003ctypeparamref name=\"T\"/\u003e.\r\n/// \u003c/summary\u003e\r\n/// \u003ctypeparam name=\"T\"\u003eThe unmanaged type to convert the HResult to.\u003c/typeparam\u003e\r\n/// \u003cremarks\u003e\r\n/// This type is used by the COM source generator to enable marshalling exceptions to the HResult of the exception.\r\n/// We can skip the exposing the exception marshallers if we decide to not expose the VTable source generator.\r\n/// In that case, we\u0027d hard-code the implementations of these marshallers into the COM source generator.\r\n/// \u003c/remarks\u003e\r\n[CustomMarshaller(typeof(Exception), MarshalMode.UnmanagedToManagedOut, typeof(ExceptionHResultMarshaller\u003c\u003e))]\r\npublic static class ExceptionHResultMarshaller\u003cT\u003e\r\n    where T : unmanaged, INumber\u003cT\u003e\r\n{\r\n    /// \u003csummary\u003e\r\n    /// Marshals an exception object to the value of its \u003csee cref=\"Exception.HResult\"/\u003e converted to \u003ctypeparamref name=\"T\"/\u003e.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cparam name=\"e\"\u003eThe exception.\u003c/param\u003e\r\n    /// \u003creturns\u003eThe HResult of the exception, converted to \u003ctypeparamref name=\"T\"/\u003e.\u003c/returns\u003e\r\n    public static T ConvertToUnmanaged(Exception e);\r\n}\r\n\r\n[CustomMarshaller(typeof(Exception), MarshalMode.UnmanagedToManagedOut, typeof(ExceptionNaNMarshaller\u003c\u003e))]\r\npublic static class ExceptionNaNMarshaller\u003cT\u003e\r\n    where T : unmanaged, IFloatingPointIeee754\u003cT\u003e\r\n{\r\n    /// \u003csummary\u003e\r\n    /// Marshals an exception object to \u003csee cref=\"T.NaN\"/\u003e.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cparam name=\"e\"\u003eThe exception.\u003c/param\u003e\r\n    /// \u003creturns\u003e\u003ctypeparamref name=\"T.NaN\"/\u003e.\u003c/returns\u003e\r\n    public static T ConvertToUnmanaged(Exception e);\r\n}\r\n\r\n[CustomMarshaller(typeof(Exception), MarshalMode.UnmanagedToManagedOut, typeof(ExceptionDefaultMarshaller\u003c\u003e))]\r\npublic static class ExceptionDefaultMarshaller\u003cT\u003e\r\n    where T : unmanaged\r\n{\r\n    /// \u003csummary\u003e\r\n    /// Marshals an exception object to the default value of \u003ctypeparamref name=\"T\"/\u003e.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cparam name=\"e\"\u003eThe exception.\u003c/param\u003e\r\n    /// \u003creturns\u003eThe default value of \u003ctypeparamref name=\"T\"/\u003e.\u003c/returns\u003e\r\n    public static T ConvertToUnmanaged(Exception e);\r\n}\r\n\r\n[CustomMarshaller(typeof(Exception), MarshalMode.UnmanagedToManagedOut, typeof(SwallowExceptionMarshaller))]\r\npublic static class SwallowExceptionMarshaller\r\n{\r\n    /// \u003csummary\u003e\r\n    /// Swallows the exception.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cparam name=\"e\"\u003eThe exception.\u003c/param\u003e\r\n    public static void ConvertToUnmanaged(Exception e);\r\n}\r\n\r\npublic enum ExceptionMarshalling\r\n{\r\n    Custom = 0,\r\n    Com = 1\r\n}\r\n\r\n    public enum MarshalDirection\r\n    {\r\n        ManagedToUnmanaged = 0,\r\n        UnmanagedToManaged = 1,\r\n        Bidirectional = 2\r\n    }\r\n\r\n// This is the trigger attribute for the VTable source generator.\r\n// If we decide we want to only expose the COM source generator, then we would keep this attribute internal.\r\n// The current plan is to use this attribute to provide the \"don\u0027t use the defaults, use this custom logic\" options\r\n// for the COM source generator, so if we decide to not expose this, we should provide a different mechanism.\r\n[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\r\npublic class VirtualMethodIndexAttribute : Attribute\r\n{\r\n    public VirtualMethodIndexAttribute(int index);\r\n\r\n    public int Index { get; }\r\n\r\n    public bool ImplicitThisParameter { get; set; } = true;\r\n\r\n    /// \u003csummary\u003e\r\n    /// Gets or sets how to marshal string arguments to the method.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cremarks\u003e\r\n    /// If this field is set to a value other than \u003csee cref=\"StringMarshalling.Custom\" /\u003e,\r\n    /// \u003csee cref=\"StringMarshallingCustomType\" /\u003e must not be specified.\r\n    /// \u003c/remarks\u003e\r\n    public StringMarshalling StringMarshalling { get; set; }\r\n\r\n    /// \u003csummary\u003e\r\n    /// Gets or sets the \u003csee cref=\"Type\"/\u003e used to control how string arguments to the method are marshalled.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cremarks\u003e\r\n    /// If this field is specified, \u003csee cref=\"StringMarshalling\" /\u003e must not be specified\r\n    /// or must be set to \u003csee cref=\"StringMarshalling.Custom\" /\u003e.\r\n    /// \u003c/remarks\u003e\r\n    public Type? StringMarshallingCustomType { get; set; }\r\n\r\n    /// \u003csummary\u003e\r\n    /// Gets or sets whether the callee sets an error (SetLastError on Windows or errno\r\n    /// on other platforms) before returning from the attributed method.\r\n    /// \u003c/summary\u003e\r\n    public bool SetLastError { get; set; }\r\n    \r\n    public MarshalDirection Direction { get; set; } = MarshalDirection.Bidirectional;\r\n\r\n    public ExceptionMarshalling ExceptionMarshalling { get; set; }\r\n\r\n    /// \u003csummary\u003e\r\n    /// Gets or sets the \u003csee cref=\"Type\"/\u003e used to control how an exception is marshalled to the return value.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cremarks\u003e\r\n    /// If this field is specified, \u003csee cref=\"ExceptionMarshalling\" /\u003e must not be specified\r\n    /// or must be set to \u003csee cref=\"ExceptionMarshalling.Custom\" /\u003e.\r\n    /// \u003c/remarks\u003e\r\n    public Type? ExceptionMarshallingType { get; set; }\r\n}\r\n\r\n```\r\n\r\n### API Usage\r\n\r\n```csharp\r\n\r\n[UnmanagedObjectUnwrapper\u003cMyObjectUnwrapper\u003e]\r\npartial interface INativeAPI : IUnmanagedInterfaceType\r\n{\r\n       [VirtualMethodIndex(0)]\r\n        void Method(string param);\r\n}\r\n\r\n[UnmanagedObjectUnwrapper\u003cMyObjectUnwrapper\u003e]\r\nunsafe partial interface INativeAPI2 : IUnmanagedInterfaceType\r\n{\r\n\t\tprivate static void* _table;\r\n\t\tpublic static void* IUnmanagedInterface.VirtualMethodTableManagedImplementation =\u003e _table;\r\n\r\n\t\tstatic INativeAPI2()\r\n       {\r\n              _table = RuntimeHelpers.AllocateTypeAssociatedMemory(typeof(INativeAPI2), sizeof(void*));\r\n\t\t\t Native.FillManagedVirtualMethodTableImplementation(_table);\r\n       }\r\n\r\n       [VirtualMethodIndex(0)]\r\n        void Method(string param);\r\n}\r\n\r\nclass NativeAPI : IUnmanagedVirtualMethodTableProvider, INativeAPI.Native\r\n{\r\n\t\tprivate void* _this;\r\n\r\n        public NativeAPI(void* thisPtr) { _this = thisPtr; }\r\n\r\n        VirtualMethodTableInfo IUnmanagedVirtualMethodTableProvider.GetVirtualMethodTableInfoForKey(Type type)\r\n        {\r\n\t\t\t\tDebug.Assert(type == typeof(INativeAPI));\r\n                return new(_this, *(void***)_this);\r\n        }\r\n}\r\n\r\nsealed unsafe class MyObjectUnwrapper : IUnmanagedObjectUnwrapper\r\n{\r\n    public static object GetObjectForUnmanagedWrapper(void* ptr)\r\n    {\r\n        throw new NotImplementedException();\r\n    }\r\n}\r\n```\r\n\r\nGenerated code shape:\r\n\r\n```csharp\r\n\r\npartial interface INativeAPI\r\n{\r\n\t\tpublic static void* IUnmanagedInterface.VirtualMethodTableManagedImplementation =\u003e /* implementation */ throw null;\r\n\r\n        internal partial interface Native : INativeAPI\r\n        {\r\n               // DIM implementations for every method in INativeAPI with a [VirtualMethodIndexAttribute] attribute.\r\n        }\r\n}\r\n\r\npartial interface INativeAPI2\r\n{\r\n        internal partial interface Native : INativeAPI2\r\n        {\r\n               // DIM implementations for every method in INativeAPI with a [VirtualMethodIndexAttribute] attribute.\r\n\r\n               // Provided only when the user provides their own implementation of IUnmanagedInterface.VirtualMethodTableManagedImplementation.\r\n               // It\u0027s extremely annoying to have to know the unmanaged function pointer signatures to take the address of the\r\n              // implemented stubs, so provide this method to fill the table so users don\u0027t need to.\r\n               internal static void FillManagedVirtualMethodTableImplementation(void* vtable) {} \r\n        }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n\u003cdetails\u003e\r\n\u003csummary\u003eOriginal API Proposal (kept for history to match to comments)\u003c/summary\u003e\r\n\r\n```csharp\r\nnamespace System.Runtime.InteropServices.Marshalling;\r\n\r\n/// \u003csummary\u003e\r\n/// Information about a virtual method table and the unmanaged instance pointer.\r\n/// \u003c/summary\u003e\r\npublic readonly ref struct VirtualMethodTableInfo\r\n{\r\n    /// \u003csummary\u003e\r\n    /// Construct a \u003csee cref=\"VirtualMethodTableInfo\"/\u003e from a given instance pointer and table memory.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cparam name=\"thisPointer\"\u003eThe pointer to the instance.\u003c/param\u003e\r\n    /// \u003cparam name=\"virtualMethodTable\"\u003eThe block of memory that represents the virtual method table.\u003c/param\u003e\r\n    public VirtualMethodTableInfo(IntPtr thisPointer, ReadOnlySpan\u003cIntPtr\u003e virtualMethodTable)\r\n    {\r\n        ThisPointer = thisPointer;\r\n        VirtualMethodTable = virtualMethodTable;\r\n    }\r\n\r\n    /// \u003csummary\u003e\r\n    /// The unmanaged instance pointer\r\n    /// \u003c/summary\u003e\r\n    public IntPtr ThisPointer { get; }\r\n\r\n    /// \u003csummary\u003e\r\n    /// The virtual method table.\r\n    /// \u003c/summary\u003e\r\n    public ReadOnlySpan\u003cIntPtr\u003e VirtualMethodTable { get; }\r\n\r\n    /// \u003csummary\u003e\r\n    /// Deconstruct this structure into its two fields.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cparam name=\"thisPointer\"\u003eThe \u003csee cref=\"ThisPointer\"/\u003e result\u003c/param\u003e\r\n    /// \u003cparam name=\"virtualMethodTable\"\u003eThe \u003csee cref=\"VirtualMethodTable\"/\u003e result\u003c/param\u003e\r\n    public void Deconstruct(out IntPtr thisPointer, out ReadOnlySpan\u003cIntPtr\u003e virtualMethodTable)\r\n    {\r\n        thisPointer = ThisPointer;\r\n        virtualMethodTable = VirtualMethodTable;\r\n    }\r\n}\r\n\r\n/// \u003csummary\u003e\r\n/// This interface allows an object to provide information about a virtual method table for a managed interface that implements \u003csee cref=\"IUnmanagedInterfaceType{TInterface}\"/\u003e to enable invoking methods in the virtual method table.\r\n/// \u003c/summary\u003e\r\n/// \u003ctypeparam name=\"T\"\u003eThe type to use to represent the the identity of the unmanaged type.\u003c/typeparam\u003e\r\npublic unsafe interface IUnmanagedVirtualMethodTableProvider\r\n{\r\n    /// \u003csummary\u003e\r\n    /// Get the information about the virtual method table for a given unmanaged interface type represented by \u003cparamref name=\"type\"/\u003e.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cparam name=\"type\"\u003eThe managed type for the unmanaged interface.\u003c/param\u003e\r\n    /// \u003creturns\u003eThe virtual method table information for the unmanaged interface.\u003c/returns\u003e\r\n    protected VirtualMethodTableInfo GetVirtualMethodTableInfoForKey(Type type);\r\n\r\n    /// \u003csummary\u003e\r\n    /// Get the information about the virtual method table for the given unmanaged interface type.\r\n    /// \u003c/summary\u003e\r\n    /// \u003ctypeparam name=\"TUnmanagedInterfaceType\"\u003eThe managed interface type that represents the unmanaged interface.\u003c/typeparam\u003e\r\n    /// \u003creturns\u003eThe virtual method table information for the unmanaged interface.\u003c/returns\u003e\r\n    public sealed VirtualMethodTableInfo GetVirtualMethodTableInfoForKey\u003cTUnmanagedInterfaceType\u003e()\r\n        where TUnmanagedInterfaceType : IUnmanagedInterfaceType\u003cTUnmanagedInterfaceType\u003e\r\n    {\r\n        return GetVirtualMethodTableInfoForKey(typeof(TUnmanagedInterfaceType));\r\n    }\r\n\r\n    /// \u003csummary\u003e\r\n    /// Get the length of the virtual method table for the given unmanaged interface type.\r\n    /// \u003c/summary\u003e\r\n    /// \u003ctypeparam name=\"TUnmanagedInterfaceType\"\u003eThe managed interface type that represents the unmanaged interface.\u003c/typeparam\u003e\r\n    /// \u003creturns\u003eThe length of the virtual method table for the unmanaged interface.\u003c/returns\u003e\r\n    public static int GetVirtualMethodTableLength\u003cTUnmanagedInterfaceType\u003e()\r\n        where TUnmanagedInterfaceType : IUnmanagedInterfaceType\u003cTUnmanagedInterfaceType\u003e\r\n    {\r\n        return TUnmanagedInterfaceType.VirtualMethodTableLength;\r\n    }\r\n\r\n    /// \u003csummary\u003e\r\n    /// Get a pointer to the virtual method table  of managed implementations of the unmanaged interface type.\r\n    /// \u003c/summary\u003e\r\n    /// \u003ctypeparam name=\"TUnmanagedInterfaceType\"\u003eThe managed interface type that represents the unmanaged interface.\u003c/typeparam\u003e\r\n    /// \u003creturns\u003eA pointer to the virtual method table  of managed implementations of the unmanaged interface type\u003c/returns\u003e\r\n    public static void* GetVirtualMethodTableManagedImplementation\u003cTUnmanagedInterfaceType\u003e()\r\n        where TUnmanagedInterfaceType : IUnmanagedInterfaceType\u003cTUnmanagedInterfaceType\u003e\r\n    {\r\n        return TUnmanagedInterfaceType.VirtualMethodTableManagedImplementation;\r\n    }\r\n\r\n    /// \u003csummary\u003e\r\n    /// Get a pointer that wraps a managed implementation of an unmanaged interface that can be passed to unmanaged code.\r\n    /// \u003c/summary\u003e\r\n    /// \u003ctypeparam name=\"TUnmanagedInterfaceType\"\u003eThe managed type that represents the unmanaged interface.\u003c/typeparam\u003e\r\n    /// \u003cparam name=\"obj\"\u003eThe managed object that implements the unmanaged interface.\u003c/param\u003e\r\n    /// \u003creturns\u003eA pointer-sized value that can be passed to unmanaged code that represents \u003cparamref name=\"obj\"/\u003e\u003c/returns\u003e\r\n    public static void* GetUnmanagedWrapperForObject\u003cTUnmanagedInterfaceType\u003e(TUnmanagedInterfaceType obj)\r\n        where TUnmanagedInterfaceType : IUnmanagedInterfaceType\u003cTUnmanagedInterfaceType\u003e\r\n    {\r\n        return TUnmanagedInterfaceType.GetUnmanagedWrapperForObject(obj);\r\n    }\r\n\r\n    /// \u003csummary\u003e\r\n    /// Get the object wrapped by \u003cparamref name=\"ptr\"/\u003e.\r\n    /// \u003c/summary\u003e\r\n    /// \u003ctypeparam name=\"TUnmanagedInterfaceType\"\u003eThe managed type that represents the unmanaged interface.\u003c/typeparam\u003e\r\n    /// \u003cparam name=\"ptr\"\u003eA pointer-sized value returned by \u003csee cref=\"GetUnmanagedWrapperForObject{TUnmanagedInterfaceType}(TUnmanagedInterfaceType)\"/\u003e or \u003csee cref=\"IUnmanagedInterfaceType{TInterface, TKey}.GetUnmanagedWrapperForObject(TInterface)\"/\u003e.\u003c/param\u003e\r\n    /// \u003creturns\u003eThe object wrapped by \u003cparamref name=\"ptr\"/\u003e.\u003c/returns\u003e\r\n    public static TUnmanagedInterfaceType GetObjectForUnmanagedWrapper\u003cTUnmanagedInterfaceType\u003e(void* ptr)\r\n        where TUnmanagedInterfaceType : IUnmanagedInterfaceType\u003cTUnmanagedInterfaceType\u003e\r\n    {\r\n        return TUnmanagedInterfaceType.GetObjectForUnmanagedWrapper(ptr);\r\n    }\r\n}\r\n\r\n/// \u003csummary\u003e\r\n/// This interface allows another interface to define that it represents a managed projection of an unmanaged interface from some unmanaged type system.\r\n/// \u003c/summary\u003e\r\n/// \u003ctypeparam name=\"TInterface\"\u003eThe managed interface.\u003c/typeparam\u003e\r\n/// \u003ctypeparam name=\"TKey\"\u003eThe type of a value that can represent types from the corresponding unmanaged type system.\u003c/typeparam\u003e\r\npublic unsafe interface IUnmanagedInterfaceType\u003cTInterface\u003e\r\n    where TInterface : IUnmanagedInterfaceType\u003cTInterface\u003e\r\n{\r\n    /// \u003csummary\u003e\r\n    /// Get the length of the virtual method table for the given unmanaged interface type.\r\n    /// \u003c/summary\u003e\r\n    /// \u003creturns\u003eThe length of the virtual method table for the unmanaged interface.\u003c/returns\u003e\r\n    public static abstract int VirtualMethodTableLength { get; }\r\n\r\n    /// \u003csummary\u003e\r\n    /// Get a pointer to the virtual method table  of managed implementations of the unmanaged interface type.\r\n    /// \u003c/summary\u003e\r\n    /// \u003creturns\u003eA pointer to the virtual method table  of managed implementations of the unmanaged interface type\u003c/returns\u003e\r\n    public static abstract void* VirtualMethodTableManagedImplementation { get; }\r\n\r\n    /// \u003csummary\u003e\r\n    /// Get a pointer that wraps a managed implementation of an unmanaged interface that can be passed to unmanaged code.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cparam name=\"obj\"\u003eThe managed object that implements the unmanaged interface.\u003c/param\u003e\r\n    /// \u003creturns\u003eA pointer-sized value that can be passed to unmanaged code that represents \u003cparamref name=\"obj\"/\u003e\u003c/returns\u003e\r\n    public static abstract void* GetUnmanagedWrapperForObject(TInterface obj);\r\n\r\n    /// \u003csummary\u003e\r\n    /// Get the object wrapped by \u003cparamref name=\"ptr\"/\u003e.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cparam name=\"ptr\"\u003eA pointer-sized value returned by \u003csee cref=\"IUnmanagedVirtualMethodTableProvider{TKey}.GetUnmanagedWrapperForObject{IUnmanagedInterfaceType{TInterface, TKey}}(IUnmanagedInterfaceType{TInterface, TKey})\"/\u003e or \u003csee cref=\"GetUnmanagedWrapperForObject(TInterface)\"/\u003e.\u003c/param\u003e\r\n    /// \u003creturns\u003eThe object wrapped by \u003cparamref name=\"ptr\"/\u003e.\u003c/returns\u003e\r\n    public static abstract TInterface GetObjectForUnmanagedWrapper(void* ptr);\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\n\r\npartial interface INativeAPI : IUnmanagedInterfaceType\u003cINativeAPI\u003e\r\n{\r\n       static int IUnmanagedInterfaceType\u003cINativeAPI\u003e.VirtualMethodTableLength =\u003e 1;\r\n\r\n                private static void** s_vtable = (void**)RuntimeHelpers.AllocateTypeAssociatedMemory(typeof(INativeAPI), sizeof(void*) * IUnmanagedVirtualMethodTableProvider.GetVirtualMethodTableLength\u003cINativeAPI\u003e());\r\n                static void* IUnmanagedInterfaceType\u003cINativeAPI\u003e.VirtualMethodTableManagedImplementation\r\n                {\r\n                    get\r\n                    {\r\n                        if (s_vtable[0] == null)\r\n                        {\r\n                            Native.PopulateUnmanagedVirtualMethodTable(new Span\u003cIntPtr\u003e(s_vtable, IUnmanagedVirtualMethodTableProvider.GetVirtualMethodTableLength\u003cINativeAPI\u003e()));\r\n                        }\r\n                        return s_vtable;\r\n                    }\r\n                }\r\n\r\n       static void* IUnmanagedInterfaceType\u003cINativeAPI\u003e.GetUnmanagedWrapperForObject(INativeAPI api) =\u003e throw new NotImplementedException();\r\n\r\n        static INativeAPI IUnmanagedInterfaceType\u003cINativeAPI\u003e.GetObjectForUnmanagedWrapper(void* ptr) =\u003e throw new NotImplementedException();\r\n\r\n       static INativeAPI()\r\n       {\r\n\t\t\t\r\n       }\r\n\r\n       [VirtualMethodIndex(0)]\r\n        void Method(string param);\r\n}\r\n\r\nclass NativeAPI : IUnmanagedVirtualMethodTableProvider, INativeAPI.Native\r\n{\r\n\t\tprivate void* _this;\r\n\r\n        public NativeAPI(void* thisPtr) { _this = thisPtr; }\r\n\r\n        VirtualMethodTableInfo IUnmanagedVirtualMethodTableProvider.GetVirtualMethodTableInfoForKey(Type type)\r\n        {\r\n\t\t\t\tDebug.Assert(type == typeof(INativeAPI));\r\n                return new((IntPtr)_this, new ReadOnlySpan\u003cIntPtr\u003e(*(void**)_this,  IUnmanagedVirtualMethodTableProvider.GetVirtualMethodTableLength\u003cINativeAPI\u003e()));\r\n        }\r\n}\r\n```\r\n\r\nGenerated code shape:\r\n\r\n```csharp\r\n\r\npartial interface INativeAPI\r\n{\r\n        internal partial interface Native : INativeAPI\r\n        {\r\n               // DIM implementations for every method in INativeAPI with a [VirtualMethodIndexAttribute] attribute.\r\n               internal static PopulateUnmanagedVirtualMethodTable(Span\u003cnint\u003e vtable) { /* fill the vtable with function pointers for the unmanaged-\u003emanaged stubs */\r\n        }\r\n}\r\n\r\n````\r\n\r\n\u003c/details\u003e\r\n\r\n### Alternative Designs\r\n\r\n### Risks\r\n\r\nThe DIM-implemented methods aren\u0027t visible when using the implementing types directly; they\u0027re only visible through the interface. As a result, the user experience is a little weird for the cases where only one interface is implemented, as the interface methods can only be called on an object wrapping the native API through the interface, not through the wrapping class.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOWD0G2Q==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5Rvy14",
                                           "createdAt":  "2023-01-04T22:05:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nAs part of our COM interop source generator work, we decided to start with implementing support first for the general concept of virtual function tables. Many native APIs, including JNI, MSQuic, and COM are either implemented or presented to users using tables of function pointers, either explicitly like MSQuic or implicitly through abstract member functions like JNI or COM. Providing this source generator would enable developers to use native APIs like these ones with user-friendly types using the new source-generated marshalling model instead of being forced to use the built-in marshalling model with `Marshal.GetDelegateForFunctionPointer` to manually marshal back a virtual method table or dropping down to manual marshalling with function pointers to get decent performance.\r\n\r\nThis source generator would enable generating code to call an unmanaged API projected to a managed interface and call a managed interface projected to an unmanaged table of function pointers.\r\n\r\nWe plan on providing guidance directing users to use these APIs to override behavior from the COM source generator (they will integrate cleanly)\n\n### API Proposal\n\n```csharp\r\nnamespace System.Runtime.InteropServices.Marshalling;\r\n\r\n/// \u003csummary\u003e\r\n/// Information about a virtual method table and the unmanaged instance pointer.\r\n/// \u003c/summary\u003e\r\npublic readonly ref struct VirtualMethodTableInfo\r\n{\r\n    /// \u003csummary\u003e\r\n    /// Construct a \u003csee cref=\"VirtualMethodTableInfo\"/\u003e from a given instance pointer and table memory.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cparam name=\"thisPointer\"\u003eThe pointer to the instance.\u003c/param\u003e\r\n    /// \u003cparam name=\"virtualMethodTable\"\u003eThe block of memory that represents the virtual method table.\u003c/param\u003e\r\n    public VirtualMethodTableInfo(IntPtr thisPointer, ReadOnlySpan\u003cIntPtr\u003e virtualMethodTable)\r\n    {\r\n        ThisPointer = thisPointer;\r\n        VirtualMethodTable = virtualMethodTable;\r\n    }\r\n\r\n    /// \u003csummary\u003e\r\n    /// The unmanaged instance pointer\r\n    /// \u003c/summary\u003e\r\n    public IntPtr ThisPointer { get; }\r\n\r\n    /// \u003csummary\u003e\r\n    /// The virtual method table.\r\n    /// \u003c/summary\u003e\r\n    public ReadOnlySpan\u003cIntPtr\u003e VirtualMethodTable { get; }\r\n\r\n    /// \u003csummary\u003e\r\n    /// Deconstruct this structure into its two fields.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cparam name=\"thisPointer\"\u003eThe \u003csee cref=\"ThisPointer\"/\u003e result\u003c/param\u003e\r\n    /// \u003cparam name=\"virtualMethodTable\"\u003eThe \u003csee cref=\"VirtualMethodTable\"/\u003e result\u003c/param\u003e\r\n    public void Deconstruct(out IntPtr thisPointer, out ReadOnlySpan\u003cIntPtr\u003e virtualMethodTable)\r\n    {\r\n        thisPointer = ThisPointer;\r\n        virtualMethodTable = VirtualMethodTable;\r\n    }\r\n}\r\n\r\n/// \u003csummary\u003e\r\n/// This interface allows an object to provide information about a virtual method table for a managed interface that implements \u003csee cref=\"IUnmanagedInterfaceType{TInterface}\"/\u003e to enable invoking methods in the virtual method table.\r\n/// \u003c/summary\u003e\r\n/// \u003ctypeparam name=\"T\"\u003eThe type to use to represent the the identity of the unmanaged type.\u003c/typeparam\u003e\r\npublic unsafe interface IUnmanagedVirtualMethodTableProvider\r\n{\r\n    /// \u003csummary\u003e\r\n    /// Get the information about the virtual method table for a given unmanaged interface type represented by \u003cparamref name=\"type\"/\u003e.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cparam name=\"type\"\u003eThe managed type for the unmanaged interface.\u003c/param\u003e\r\n    /// \u003creturns\u003eThe virtual method table information for the unmanaged interface.\u003c/returns\u003e\r\n    protected VirtualMethodTableInfo GetVirtualMethodTableInfoForKey(Type type);\r\n\r\n    /// \u003csummary\u003e\r\n    /// Get the information about the virtual method table for the given unmanaged interface type.\r\n    /// \u003c/summary\u003e\r\n    /// \u003ctypeparam name=\"TUnmanagedInterfaceType\"\u003eThe managed interface type that represents the unmanaged interface.\u003c/typeparam\u003e\r\n    /// \u003creturns\u003eThe virtual method table information for the unmanaged interface.\u003c/returns\u003e\r\n    public sealed VirtualMethodTableInfo GetVirtualMethodTableInfoForKey\u003cTUnmanagedInterfaceType\u003e()\r\n        where TUnmanagedInterfaceType : IUnmanagedInterfaceType\u003cTUnmanagedInterfaceType\u003e\r\n    {\r\n        return GetVirtualMethodTableInfoForKey(typeof(TUnmanagedInterfaceType));\r\n    }\r\n\r\n    /// \u003csummary\u003e\r\n    /// Get the length of the virtual method table for the given unmanaged interface type.\r\n    /// \u003c/summary\u003e\r\n    /// \u003ctypeparam name=\"TUnmanagedInterfaceType\"\u003eThe managed interface type that represents the unmanaged interface.\u003c/typeparam\u003e\r\n    /// \u003creturns\u003eThe length of the virtual method table for the unmanaged interface.\u003c/returns\u003e\r\n    public static int GetVirtualMethodTableLength\u003cTUnmanagedInterfaceType\u003e()\r\n        where TUnmanagedInterfaceType : IUnmanagedInterfaceType\u003cTUnmanagedInterfaceType\u003e\r\n    {\r\n        return TUnmanagedInterfaceType.VirtualMethodTableLength;\r\n    }\r\n\r\n    /// \u003csummary\u003e\r\n    /// Get a pointer to the virtual method table  of managed implementations of the unmanaged interface type.\r\n    /// \u003c/summary\u003e\r\n    /// \u003ctypeparam name=\"TUnmanagedInterfaceType\"\u003eThe managed interface type that represents the unmanaged interface.\u003c/typeparam\u003e\r\n    /// \u003creturns\u003eA pointer to the virtual method table  of managed implementations of the unmanaged interface type\u003c/returns\u003e\r\n    public static void* GetVirtualMethodTableManagedImplementation\u003cTUnmanagedInterfaceType\u003e()\r\n        where TUnmanagedInterfaceType : IUnmanagedInterfaceType\u003cTUnmanagedInterfaceType\u003e\r\n    {\r\n        return TUnmanagedInterfaceType.VirtualMethodTableManagedImplementation;\r\n    }\r\n\r\n    /// \u003csummary\u003e\r\n    /// Get a pointer that wraps a managed implementation of an unmanaged interface that can be passed to unmanaged code.\r\n    /// \u003c/summary\u003e\r\n    /// \u003ctypeparam name=\"TUnmanagedInterfaceType\"\u003eThe managed type that represents the unmanaged interface.\u003c/typeparam\u003e\r\n    /// \u003cparam name=\"obj\"\u003eThe managed object that implements the unmanaged interface.\u003c/param\u003e\r\n    /// \u003creturns\u003eA pointer-sized value that can be passed to unmanaged code that represents \u003cparamref name=\"obj\"/\u003e\u003c/returns\u003e\r\n    public static void* GetUnmanagedWrapperForObject\u003cTUnmanagedInterfaceType\u003e(TUnmanagedInterfaceType obj)\r\n        where TUnmanagedInterfaceType : IUnmanagedInterfaceType\u003cTUnmanagedInterfaceType\u003e\r\n    {\r\n        return TUnmanagedInterfaceType.GetUnmanagedWrapperForObject(obj);\r\n    }\r\n\r\n    /// \u003csummary\u003e\r\n    /// Get the object wrapped by \u003cparamref name=\"ptr\"/\u003e.\r\n    /// \u003c/summary\u003e\r\n    /// \u003ctypeparam name=\"TUnmanagedInterfaceType\"\u003eThe managed type that represents the unmanaged interface.\u003c/typeparam\u003e\r\n    /// \u003cparam name=\"ptr\"\u003eA pointer-sized value returned by \u003csee cref=\"GetUnmanagedWrapperForObject{TUnmanagedInterfaceType}(TUnmanagedInterfaceType)\"/\u003e or \u003csee cref=\"IUnmanagedInterfaceType{TInterface, TKey}.GetUnmanagedWrapperForObject(TInterface)\"/\u003e.\u003c/param\u003e\r\n    /// \u003creturns\u003eThe object wrapped by \u003cparamref name=\"ptr\"/\u003e.\u003c/returns\u003e\r\n    public static TUnmanagedInterfaceType GetObjectForUnmanagedWrapper\u003cTUnmanagedInterfaceType\u003e(void* ptr)\r\n        where TUnmanagedInterfaceType : IUnmanagedInterfaceType\u003cTUnmanagedInterfaceType\u003e\r\n    {\r\n        return TUnmanagedInterfaceType.GetObjectForUnmanagedWrapper(ptr);\r\n    }\r\n}\r\n\r\n/// \u003csummary\u003e\r\n/// This interface allows another interface to define that it represents a managed projection of an unmanaged interface from some unmanaged type system.\r\n/// \u003c/summary\u003e\r\n/// \u003ctypeparam name=\"TInterface\"\u003eThe managed interface.\u003c/typeparam\u003e\r\n/// \u003ctypeparam name=\"TKey\"\u003eThe type of a value that can represent types from the corresponding unmanaged type system.\u003c/typeparam\u003e\r\npublic unsafe interface IUnmanagedInterfaceType\u003cTInterface\u003e\r\n    where TInterface : IUnmanagedInterfaceType\u003cTInterface\u003e\r\n{\r\n    /// \u003csummary\u003e\r\n    /// Get the length of the virtual method table for the given unmanaged interface type.\r\n    /// \u003c/summary\u003e\r\n    /// \u003creturns\u003eThe length of the virtual method table for the unmanaged interface.\u003c/returns\u003e\r\n    public static abstract int VirtualMethodTableLength { get; }\r\n\r\n    /// \u003csummary\u003e\r\n    /// Get a pointer to the virtual method table  of managed implementations of the unmanaged interface type.\r\n    /// \u003c/summary\u003e\r\n    /// \u003creturns\u003eA pointer to the virtual method table  of managed implementations of the unmanaged interface type\u003c/returns\u003e\r\n    public static abstract void* VirtualMethodTableManagedImplementation { get; }\r\n\r\n    /// \u003csummary\u003e\r\n    /// Get a pointer that wraps a managed implementation of an unmanaged interface that can be passed to unmanaged code.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cparam name=\"obj\"\u003eThe managed object that implements the unmanaged interface.\u003c/param\u003e\r\n    /// \u003creturns\u003eA pointer-sized value that can be passed to unmanaged code that represents \u003cparamref name=\"obj\"/\u003e\u003c/returns\u003e\r\n    public static abstract void* GetUnmanagedWrapperForObject(TInterface obj);\r\n\r\n    /// \u003csummary\u003e\r\n    /// Get the object wrapped by \u003cparamref name=\"ptr\"/\u003e.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cparam name=\"ptr\"\u003eA pointer-sized value returned by \u003csee cref=\"IUnmanagedVirtualMethodTableProvider{TKey}.GetUnmanagedWrapperForObject{IUnmanagedInterfaceType{TInterface, TKey}}(IUnmanagedInterfaceType{TInterface, TKey})\"/\u003e or \u003csee cref=\"GetUnmanagedWrapperForObject(TInterface)\"/\u003e.\u003c/param\u003e\r\n    /// \u003creturns\u003eThe object wrapped by \u003cparamref name=\"ptr\"/\u003e.\u003c/returns\u003e\r\n    public static abstract TInterface GetObjectForUnmanagedWrapper(void* ptr);\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\n\r\npartial interface INativeAPI : IUnmanagedInterfaceType\u003cINativeAPI\u003e\r\n{\r\n       static int IUnmanagedInterfaceType\u003cINativeAPI\u003e.VirtualMethodTableLength =\u003e 1;\r\n\r\n                private static void** s_vtable = (void**)RuntimeHelpers.AllocateTypeAssociatedMemory(typeof(INativeAPI), sizeof(void*) * IUnmanagedVirtualMethodTableProvider.GetVirtualMethodTableLength\u003cINativeAPI\u003e());\r\n                static void* IUnmanagedInterfaceType\u003cINativeAPI\u003e.VirtualMethodTableManagedImplementation\r\n                {\r\n                    get\r\n                    {\r\n                        if (s_vtable[0] == null)\r\n                        {\r\n                            Native.PopulateUnmanagedVirtualMethodTable(new Span\u003cIntPtr\u003e(s_vtable, IUnmanagedVirtualMethodTableProvider.GetVirtualMethodTableLength\u003cINativeAPI\u003e()));\r\n                        }\r\n                        return s_vtable;\r\n                    }\r\n                }\r\n\r\n       static void* IUnmanagedInterfaceType\u003cINativeAPI\u003e.GetUnmanagedWrapperForObject(INativeAPI api) =\u003e throw new NotImplementedException();\r\n\r\n        static INativeAPI IUnmanagedInterfaceType\u003cINativeAPI\u003e.GetObjectForUnmanagedWrapper(void* ptr) =\u003e throw new NotImplementedException();\r\n\r\n       static INativeAPI()\r\n       {\r\n\t\t\t\r\n       }\r\n\r\n       [VirtualMethodIndex(0)]\r\n        void Method(string param);\r\n}\r\n\r\nclass NativeAPI : IUnmanagedVirtualMethodTableProvider, INativeAPI.Native\r\n{\r\n\t\tprivate void* _this;\r\n\r\n        public NativeAPI(void* thisPtr) { _this = thisPtr; }\r\n\r\n        VirtualMethodTableInfo IUnmanagedVirtualMethodTableProvider.GetVirtualMethodTableInfoForKey(Type type)\r\n        {\r\n\t\t\t\tDebug.Assert(type == typeof(INativeAPI));\r\n                return new((IntPtr)_this, new ReadOnlySpan\u003cIntPtr\u003e(*(void**)_this,  IUnmanagedVirtualMethodTableProvider.GetVirtualMethodTableLength\u003cINativeAPI\u003e()));\r\n        }\r\n}\r\n```\r\n\r\nGenerated code shape:\r\n\r\n```csharp\r\n\r\npartial interface INativeAPI\r\n{\r\n        internal partial interface Native : INativeAPI\r\n        {\r\n               // DIM implementations for every method in INativeAPI with a [VirtualMethodIndexAttribute] attribute.\r\n               internal static PopulateUnmanagedVirtualMethodTable(Span\u003cnint\u003e vtable) { /* fill the vtable with function pointers for the unmanaged-\u003emanaged stubs */\r\n        }\r\n}\r\n\r\n````\r\n\n\n### Alternative Designs\n\nWe could keep these APIs for testing and only expose the COM source generator APIs for the opinionated COM source generator and provide more options on those APIs (still to be proposed) instead of providing a lower-level tool like these APIs.\n\n### Risks\n\nThe DIM-implemented methods aren\u0027t visible when using the implementing types directly; they\u0027re only visible through the interface. As a result, the user experience is a little weird for the cases where only one interface is implemented, as the interface methods can only be called on an object wrapping the native API through the interface, not through the wrapping class.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejkoritzinsky\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Runtime.InteropServices`, `source-generator`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e8.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-01-04T22:05:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RwIoV",
                                           "createdAt":  "2023-01-05T00:17:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCyL_fg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkoritzinsky",
                                                                               "createdAt":  "2023-01-05T00:20:01Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Sergio0694",
                                                                               "createdAt":  "2023-01-05T00:26:55Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tannergooding",
                                                                               "createdAt":  "2023-01-06T01:13:01Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "```csharp\r\n    /// \u003csummary\u003e\r\n    /// The unmanaged instance pointer\r\n    /// \u003c/summary\u003e\r\n    public IntPtr ThisPointer { get; }\r\n```\r\n\r\nWe should just use `void*` in these kinds of places. In VS these will all revert to `nint` which isn\u0027t all that helpful as it really is a `void*`.",
                                           "updatedAt":  "2023-01-05T00:17:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RwJHC",
                                           "createdAt":  "2023-01-05T00:20:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "We can\u0027t update the `ReadOnlySpan\u003cIntPtr\u003e` because you can\u0027t put pointers in generics, but we can update the `ThisPointer` property and the like.",
                                           "updatedAt":  "2023-01-05T00:20:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RwKGU",
                                           "createdAt":  "2023-01-05T00:25:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e We can\u0027t update the ReadOnlySpan\u003cIntPtr\u003e because you can\u0027t put pointers in generics,\r\n\r\nUnsure if using `ReadOnlySpan\u003cIntPtr\u003e` is all that helpful though. The first thing people will do is check the length and then ignore the niceties the span provides. Instead, we could have a property for the length and return `void*`. I assume the use case here is going to be all generated so I don\u0027t see the span providing a lot of value other than using a type to capture two values - pointer and length. Something to consider as an alternative.",
                                           "updatedAt":  "2023-01-05T00:25:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RwPgM",
                                           "createdAt":  "2023-01-05T00:47:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCyHzCg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkoritzinsky",
                                                                               "createdAt":  "2023-01-05T01:02:32Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e public unsafe interface IUnmanagedInterfaceType\u003cTInterface\u003e\r\n\r\nI think this interface needs to be broken apart. The mapping logic is likely to be identical to the vast majority of types for a generator. This pattern seems like it would create a lot of unnecessary metadata that couldn\u0027t be removed.",
                                           "updatedAt":  "2023-01-05T00:48:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RwRpX",
                                           "createdAt":  "2023-01-05T01:03:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "I\u0027m fine splitting it, but I\u0027m at a loss on what to name the one that has the unmanaged-\u003emanaged logic.",
                                           "updatedAt":  "2023-01-05T01:03:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Ryntn",
                                           "createdAt":  "2023-01-05T13:36:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Sergio0694",
                                           "body":  "Sharing some thoughts here after discussing this with @jkoritzinsky as well. I think this might overlap at least in part with what @AaronRobinsonMSFT said as well. My concern is that the current proposal results in a UX that\u0027s rather cumbersome and error prone for developers, specifically around the setup code to initialize vtables. Jeremy explained that the point of initializing a vtable explicitly and not in a static field initializer is that this allows the linker to potentially trim everything if the type is not used. This is fine, but I feel like we could have something that\u0027s at least a little bit more ergonomic to use. Consider this:\r\n\r\n```csharp\r\npartial interface INativeAPI : IUnmanagedInterfaceType\u003cINativeAPI\u003e\r\n{\r\n    static int IUnmanagedInterfaceType\u003cINativeAPI\u003e.VirtualMethodTableLength =\u003e 1;\r\n\r\n    private static void** s_vtable = (void**)RuntimeHelpers.AllocateTypeAssociatedMemory(typeof(INativeAPI), sizeof(void*) * IUnmanagedVirtualMethodTableProvider.GetVirtualMethodTableLength\u003cINativeAPI\u003e());\r\n    static void* IUnmanagedInterfaceType\u003cINativeAPI\u003e.VirtualMethodTableManagedImplementation\r\n    {\r\n        get\r\n        {\r\n            if (s_vtable[0] == null)\r\n            {\r\n                Native.PopulateUnmanagedVirtualMethodTable(new Span\u003cIntPtr\u003e(s_vtable, IUnmanagedVirtualMethodTableProvider.GetVirtualMethodTableLength\u003cINativeAPI\u003e()));\r\n            }\r\n            return s_vtable;\r\n        }\r\n    }\r\n\r\n    static void* IUnmanagedInterfaceType\u003cINativeAPI\u003e.GetUnmanagedWrapperForObject(INativeAPI api) =\u003e throw new NotImplementedException();\r\n\r\n    static INativeAPI IUnmanagedInterfaceType\u003cINativeAPI\u003e.GetObjectForUnmanagedWrapper(void* ptr) =\u003e throw new NotImplementedException();\r\n\r\n    static INativeAPI()\r\n    {\r\n        \r\n    }\r\n\r\n    [VirtualMethodIndex(0)]\r\n    void Method(string param);\r\n}\r\n```\r\n\r\nThat\u0027s a lot of relatively non obvious code, and writing that check manually every time seems a bit awkward, not to mention it\u0027s one more thing developers could get wrong. One possible solution could be to consider the way the vtable is allocated to just be the \"de-fact right way\" to do it, and as such move that initialization using `RuntimeHelpers.AllocateTypeAssociatedMemory` in some shared stub (eg. in a DIM), as well as the check, and then only ask developers implementing the interface to write the code to fill in the pre-allocated vtable, and nothing more. Something like:\r\n\r\n```csharp\r\npartial interface INativeAPI : IUnmanagedInterfaceType\u003cINativeAPI\u003e\r\n{\r\n    static int IUnmanagedInterfaceType\u003cINativeAPI\u003e.VirtualMethodTableLength =\u003e 1;\r\n\r\n    static void IUnmanagedInterfaceType\u003cINativeAPI\u003e.InitializeVirtualMethodTableManagedImplementation(void** vtable)\r\n    {\r\n        // Fill vtable here\r\n    }\r\n}\r\n```\r\n\r\nThe allocation + initialization check could all be moved to a static DIM in the base interface. Authors would just indicate the length of the vtable, and provide the logic to fill in an allocated vtable, and nothing else 🙂",
                                           "updatedAt":  "2023-01-05T13:36:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5R1eQ6",
                                           "createdAt":  "2023-01-06T00:27:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "Here\u0027s a revised API proposal. The \"create a wrapper\" and \"retrieve an object from within a wrapper\" APIs have been extracted into another interface and the methods on `IUnmanagedInterfaceType\u003cTInterfaceType, TUnmanagedObjectWrapperFactory\u003e` that deal with wrappers just forward to the wrapper factory implmentation and add nice casts based on @AaronRobinsonMSFT\u0027s feedback and splits the interface into two copies (one for consumption and one for consumption + production). It also encapsulates the allocation/initialization pattern for the managed vtable as per @Sergio0694\u0027s feedback.\r\n\r\nLet me know what you think!\r\n\r\n```csharp\r\nnamespace System.Runtime.InteropServices.Marshalling;\r\n\r\n/// \u003csummary\u003e\r\n/// Information about a virtual method table and the unmanaged instance pointer.\r\n/// \u003c/summary\u003e\r\npublic readonly unsafe struct VirtualMethodTableInfo\r\n{\r\n    /// \u003csummary\u003e\r\n    /// Construct a \u003csee cref=\"VirtualMethodTableInfo\"/\u003e from a given instance pointer and table memory.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cparam name=\"thisPointer\"\u003eThe pointer to the instance.\u003c/param\u003e\r\n    /// \u003cparam name=\"virtualMethodTable\"\u003eThe block of memory that represents the virtual method table.\u003c/param\u003e\r\n    public VirtualMethodTableInfo(void* thisPointer, void** virtualMethodTable)\r\n    {\r\n        ThisPointer = thisPointer;\r\n        VirtualMethodTable = virtualMethodTable;\r\n    }\r\n\r\n    /// \u003csummary\u003e\r\n    /// The unmanaged instance pointer\r\n    /// \u003c/summary\u003e\r\n    public void* ThisPointer { get; }\r\n\r\n    /// \u003csummary\u003e\r\n    /// The virtual method table.\r\n    /// \u003c/summary\u003e\r\n    public void** VirtualMethodTable { get; }\r\n\r\n    /// \u003csummary\u003e\r\n    /// Deconstruct this structure into its two fields.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cparam name=\"thisPointer\"\u003eThe \u003csee cref=\"ThisPointer\"/\u003e result\u003c/param\u003e\r\n    /// \u003cparam name=\"virtualMethodTable\"\u003eThe \u003csee cref=\"VirtualMethodTable\"/\u003e result\u003c/param\u003e\r\n    public void Deconstruct(out void* thisPointer, out void** virtualMethodTable)\r\n    {\r\n        thisPointer = ThisPointer;\r\n        virtualMethodTable = VirtualMethodTable;\r\n    }\r\n}\r\n\r\n/// \u003csummary\u003e\r\n/// This interface allows an object to provide information about a virtual method table for a managed interface that implements \u003csee cref=\"IUnmanagedInterfaceType{TInterface}\"/\u003e to enable invoking methods in the virtual method table.\r\n/// \u003c/summary\u003e\r\n/// \u003ctypeparam name=\"T\"\u003eThe type to use to represent the the identity of the unmanaged type.\u003c/typeparam\u003e\r\npublic unsafe interface IUnmanagedVirtualMethodTableProvider\r\n{\r\n    /// \u003csummary\u003e\r\n    /// Get the information about the virtual method table for a given unmanaged interface type represented by \u003cparamref name=\"type\"/\u003e.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cparam name=\"type\"\u003eThe managed type for the unmanaged interface.\u003c/param\u003e\r\n    /// \u003creturns\u003eThe virtual method table information for the unmanaged interface.\u003c/returns\u003e\r\n    protected VirtualMethodTableInfo GetVirtualMethodTableInfoForKey(Type type);\r\n\r\n    /// \u003csummary\u003e\r\n    /// Get the information about the virtual method table for the given unmanaged interface type.\r\n    /// \u003c/summary\u003e\r\n    /// \u003ctypeparam name=\"TUnmanagedInterfaceType\"\u003eThe managed interface type that represents the unmanaged interface.\u003c/typeparam\u003e\r\n    /// \u003creturns\u003eThe virtual method table information for the unmanaged interface.\u003c/returns\u003e\r\n    public sealed VirtualMethodTableInfo GetVirtualMethodTableInfoForKey\u003cTUnmanagedInterfaceType\u003e()\r\n        where TUnmanagedInterfaceType : IUnmanagedInterfaceType\r\n    {\r\n        return GetVirtualMethodTableInfoForKey(typeof(TUnmanagedInterfaceType));\r\n    }\r\n}\r\n\r\n/// \u003csummary\u003e\r\n/// This interface allows another interface to define that it represents a managed projection of an unmanaged interface from some unmanaged type system.\r\n/// \u003c/summary\u003e\r\npublic unsafe interface IUnmanagedInterfaceType\r\n{\r\n    /// \u003csummary\u003e\r\n    /// Get the length of the virtual method table for the given unmanaged interface type.\r\n    /// \u003c/summary\u003e\r\n    /// \u003creturns\u003eThe length of the virtual method table for the unmanaged interface.\u003c/returns\u003e\r\n    public static abstract int VirtualMethodTableLength { get; }\r\n}\r\n\r\n/// \u003csummary\u003e\r\n/// A factory to create an unmanaged \"this pointer\" from a managed object and to get a managed object from an unmanaged \"this pointer\".\r\n/// \u003c/summary\u003e\r\npublic unsafe interface IUnmanagedObjectWrapperFactory\r\n{\r\n    /// \u003csummary\u003e\r\n    /// Get a pointer that wraps a managed implementation of an unmanaged interface that can be passed to unmanaged code.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cparam name=\"obj\"\u003eThe managed object that implements the unmanaged interface.\u003c/param\u003e\r\n    /// \u003creturns\u003eA unmanaged \"this pointer\" that can be passed to unmanaged code that represents \u003cparamref name=\"obj\"/\u003e\u003c/returns\u003e\r\n    public static abstract void* GetUnmanagedWrapperForObject(object obj);\r\n\r\n    /// \u003csummary\u003e\r\n    /// Get the object wrapped by \u003cparamref name=\"ptr\"/\u003e.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cparam name=\"ptr\"\u003eA an unmanaged \"this pointer\".\u003c/param\u003e\r\n    /// \u003creturns\u003eThe object wrapped by \u003cparamref name=\"ptr\"/\u003e.\u003c/returns\u003e\r\n    public static abstract object GetObjectForUnmanagedWrapper(void* ptr);\r\n}\r\n\r\n/// \u003csummary\u003e\r\n/// This interface allows another interface to define that it represents a managed projection of an unmanaged interface from some unmanaged type system and supports passing managed implementations of unmanaged interfaces to unmanaged code.\r\n/// \u003c/summary\u003e\r\n/// \u003ctypeparam name=\"TInterface\"\u003eThe managed interface.\u003c/typeparam\u003e\r\n/// \u003ctypeparam name=\"TUnmanagedObjectWrapperFactory\"\u003eThe factory to create an unmanaged \"this pointer\" from a managed object and to get a managed object from an unmanaged \"this pointer\".\u003c/typeparam\u003e\r\npublic unsafe interface IUnmanagedInterfaceType\u003cTInterface, TUnmanagedObjectWrapperFactory\u003e : IUnmanagedInterfaceType\r\n    where TInterface : IUnmanagedInterfaceType\u003cTInterface, TUnmanagedObjectWrapperFactory\u003e\r\n    where TUnmanagedObjectWrapperFactory: IUnmanagedObjectWrapperFactory, new()\r\n{\r\n    /// \u003csummary\u003e\r\n    /// Get a pointer to the virtual method table of managed implementations of the unmanaged interface type.\r\n    /// \u003c/summary\u003e\r\n    /// \u003creturns\u003eA pointer to the virtual method table of managed implementations of the unmanaged interface type\u003c/returns\u003e\r\n    public static void* VirtualMethodTableManagedImplementation { get; }\r\n    \r\n    /// \u003csummary\u003e\r\n    /// Fill the entries in the virtual method table of managed implementations of the unmanaged interface type\r\n    /// \u003c/summary\u003e\r\n    protected static virtual void FillVirtualMethodTableMangedImplementation(void** vtable);\r\n\r\n    /// \u003csummary\u003e\r\n    /// Get a pointer that wraps a managed implementation of an unmanaged interface that can be passed to unmanaged code.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cparam name=\"obj\"\u003eThe managed object that implements the unmanaged interface.\u003c/param\u003e\r\n    /// \u003creturns\u003eA unmanaged \"this pointer\" that can be passed to unmanaged code that represents \u003cparamref name=\"obj\"/\u003e\u003c/returns\u003e\r\n    public static void* GetUnmanagedWrapperForObject(TInterface obj);\r\n\r\n    /// \u003csummary\u003e\r\n    /// Get the object wrapped by \u003cparamref name=\"ptr\"/\u003e.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cparam name=\"ptr\"\u003eA an unmanaged \"this pointer\".\u003c/param\u003e\r\n    /// \u003creturns\u003eThe object wrapped by \u003cparamref name=\"ptr\"/\u003e.\u003c/returns\u003e\r\n    public static TInterface GetObjectForUnmanagedWrapper(void* ptr);\r\n}\r\n```\r\n",
                                           "updatedAt":  "2023-01-06T00:27:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5R1lML",
                                           "createdAt":  "2023-01-06T01:05:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Sergio0694",
                                           "body":  "Looks much better! I love how the vtable setup is way easier for authors now 🙂\r\n\r\nA few random notes:\r\n\r\n1) \r\n```csharp\r\npublic sealed VirtualMethodTableInfo GetVirtualMethodTableInfoForKey\u003cTUnmanagedInterfaceType\u003e()\r\n    where TUnmanagedInterfaceType : IUnmanagedInterfaceType\r\n{\r\n    return GetVirtualMethodTableInfoForKey(typeof(TUnmanagedInterfaceType));\r\n}\r\n```\r\n\r\nI understand this is meant to be a convenience method, but it being a DIM feels like it might make codegen worse. Couldn\u0027t this be an extension method instead targeting `IUnmanagedVirtualMethodTableProvider`, so the interface would just have the one method that developers are meant to implement?\r\n\r\n2. It\u0027s not entirely clear to me why the convenience helper is public, but the non-generic one is protected 🤔\r\n3. The name \"VirtualMethodTable**Managed**Implementation\" seems a bit confusing to me. I get that it\u0027s pointing to managed method implementations, but the function pointers in that vtable are unmanaged (I mean, they\u0027re using an unmanaged call conv)... I don\u0027t really have a better name suggestion, just figured I\u0027d throw this note out too while at it 😄",
                                           "updatedAt":  "2023-01-06T01:05:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5R38yF",
                                           "createdAt":  "2023-01-06T13:24:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e We could keep these APIs for testing and only expose the COM source generator APIs for the opinionated COM source generator and provide more options on those APIs (still to be proposed) instead of providing a lower-level tool like these APIs.\r\n\r\nI\u0027m inclined to go with this for now. I would prefer to keep these as implementation/testing details until we have a full end to end for our P1 COM scenario. I am thinking of the late changes that occurred around the marshaller design and the annoyance it was to update them all. This design also permits a level of extensibility that isn\u0027t obviously beneficial beyond the current goal of the COM source generator. Once we have the COM source generator working for our stakeholders, let\u0027s revisit this API proposal and see where we\u0027ve landed.",
                                           "updatedAt":  "2023-01-06T13:24:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5SBjHu",
                                           "createdAt":  "2023-01-09T19:03:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "\r\n\u003e Looks much better! I love how the vtable setup is way easier for authors now 🙂\r\n\u003e \r\n\u003e A few random notes:\r\n\u003e \r\n\u003e \r\n\u003e ```cs\r\n\u003e public sealed VirtualMethodTableInfo GetVirtualMethodTableInfoForKey\u003cTUnmanagedInterfaceType\u003e()\r\n\u003e     where TUnmanagedInterfaceType : IUnmanagedInterfaceType\r\n\u003e {\r\n\u003e     return GetVirtualMethodTableInfoForKey(typeof(TUnmanagedInterfaceType));\r\n\u003e }\r\n\u003e ```\r\n\u003e \r\n\u003e I understand this is meant to be a convenience method, but it being a DIM feels like it might make codegen worse. Couldn\u0027t this be an extension method instead targeting `IUnmanagedVirtualMethodTableProvider`, so the interface would just have the one method that developers are meant to implement?\r\n\u003e \r\n\u003e 2. It\u0027s not entirely clear to me why the convenience helper is public, but the non-generic one is protected 🤔\r\n\u003e 3. The name \"VirtualMethodTable**Managed**Implementation\" seems a bit confusing to me. I get that it\u0027s pointing to managed method implementations, but the function pointers in that vtable are unmanaged (I mean, they\u0027re using an unmanaged call conv)... I don\u0027t really have a better name suggestion, just figured I\u0027d throw this note out too while at it 😄\r\n\r\nSince the method is sealed, it\u0027s the same performance as a regular method. In any case, the generated code that will use this type will already have to cast the `this` pointer to the interface anyway, so the extra cost of having to cast to the interface to see the method doesn\u0027t matter. Additionally, having the method on the interface instead of as an extension method ensures that we don\u0027t bleed this name into the public API of the implementing types ([SharpLab](https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA0AXEBLANgHwAEAmARgFgAoKgNwEMoACMRgXkYDsYB3RgYQAUASgDcVKmAB0AOWFjqlbBwwwoAMzpgYjAJKMA3o0IBmRgGcYdXDAAmRlI1lCDAX0YvxlE0eL8QugypGYKNTQgcAWWFAyhD3KhcgA)).\r\n\r\nThe generic method is public as it can have type constraints to ensure that only valid types are passed. The protected method is non-generic to avoid the cost of generic virtual method resolution.\r\n\r\nI agree, the name of `VirtualMethodTable**Managed**Implementation` is a little wordy and odd. I\u0027ll try to think of a better name.\r\n\r\n\u003e \u003e We could keep these APIs for testing and only expose the COM source generator APIs for the opinionated COM source generator and provide more options on those APIs (still to be proposed) instead of providing a lower-level tool like these APIs.\r\n\u003e \r\n\u003e I\u0027m inclined to go with this for now. I would prefer to keep these as implementation/testing details until we have a full end to end for our P1 COM scenario. I am thinking of the late changes that occurred around the marshaller design and the annoyance it was to update them all. This design also permits a level of extensibility that isn\u0027t obviously beneficial beyond the current goal of the COM source generator. Once we have the COM source generator working for our stakeholders, let\u0027s revisit this API proposal and see where we\u0027ve landed.\r\n\r\nI think I may have misstated that alternative. The COM source generator will still use the `IUnmanagedVirtualMethodTableProvider` and `IUnmanagedInterfaceType` types, but not the `VirtualMethodIndexAttribute`. We\u0027ll still need either these interfaces or some replacements for the same functionality for the COM source generator (and I\u0027d highly prefer to use the same APIs for the COM case and the general vtable case).\r\n",
                                           "updatedAt":  "2023-01-09T19:03:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ThnrD",
                                           "createdAt":  "2023-01-24T02:35:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC0uUcA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2023-01-24T15:46:34Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "@AaronRobinsonMSFT @dotnet/interop-contrib @Sergio0694 I\u0027ve updated the API proposal based on the interop team\u0027s experimenting and feedback. I\u0027ve split the API proposal section into two in case API review approves the first part and sends the second back for redesign so we can keep moving the COM source generator forward.",
                                           "updatedAt":  "2023-01-24T02:35:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TyyX0",
                                           "createdAt":  "2023-01-26T23:46:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "Moved the \"VTable + COM\" APIs into #79121 so we hit the APIs in order based on API review\u0027s scheduling algorithm.",
                                           "updatedAt":  "2023-01-26T23:46:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5UuLti",
                                           "createdAt":  "2023-02-07T20:21:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC1n5ag==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkoritzinsky",
                                                                               "createdAt":  "2023-02-07T21:19:41Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "Was discussed in [today\u0027s API review](https://www.youtube.com/watch?v=nbVCa-b7qrk).",
                                           "updatedAt":  "2023-02-07T20:21:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5U7DeP",
                                           "createdAt":  "2023-02-09T20:25:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "Marking as non-blocking for now as we might not need this for .NET 8, but keeping the milestone as we might still make it blocking again.",
                                           "updatedAt":  "2023-02-09T20:25:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5YHqVd",
                                           "createdAt":  "2023-03-21T18:35:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "[Video](https://www.youtube.com/watch?v=hyyNUh4s3Qo\u0026t=0h59m22s)\n\nFrom #79121,\r\n\r\n```csharp\r\n/// \u003csummary\u003e\r\n/// This interface allows another interface to define that it represents a managed projection of an unmanaged interface from some unmanaged type system and supports passing managed implementations of unmanaged interfaces to unmanaged code.\r\n/// \u003c/summary\u003e\r\npublic interface IUnmanagedInterfaceType\u003cTSelf\u003e where TSelf: IUnmanagedInterfaceType\u003cTSelf\u003e\r\n{\r\n    /// \u003csummary\u003e\r\n    /// Get a pointer to the virtual method table of managed implementations of the unmanaged interface type.\r\n    /// \u003c/summary\u003e\r\n    /// \u003creturns\u003eA pointer to the virtual method table of managed implementations of the unmanaged interface type\u003c/returns\u003e\r\n    /// \u003cremarks\u003e\r\n    /// Implementation will be provided by a source generator if not explicitly implemented.\r\n    /// This property can return \u003cc\u003enull\u003c/c\u003e. If it does, then the interface is not supported for passing managed implementations to unmanaged code.\r\n    /// \u003c/remarks\u003e\r\n    public abstract static unsafe void** ManagedVirtualMethodTable { get; }\r\n}\r\n````",
                                           "updatedAt":  "2023-03-21T18:55:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5YHve2",
                                           "createdAt":  "2023-03-21T18:53:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "terrajobst",
                                           "body":  "* The default is `ExceptionMarshalling.Custom`\r\n    - If the developer doesn\u0027t specify a behavior, should we give a warning?\r\n    - If the developer doesn\u0027t specify a behavior, what\u0027s the default? Swallow seems problematic. It seems a clean crash would be preferable.\r\n* Should we have a `ExceptionFailFastMarshaller`?\r\n    - Or should this be an enum member? If that\u0027s the default (`0` member) then this would nicely answer \"what\u0027s the default behavior\".\r\n* Should we add an SEH marshaller for Windows?\r\n* We should rename the marshallers by adding `As`\r\n* @AaronRobinsonMSFT would prefer to wait a bit to see whether we actually need it\r\n\r\n```C#\r\nnamespace System.Runtime.InteropServices.Marshalling;\r\n\r\npublic interface IUnmanagedObjectUnwrapper\r\n{\r\n    public static abstract object GetObjectForUnmanagedWrapper(void* ptr);\r\n}\r\n\r\npublic interface IUnmanagedInterfaceType\u003cTSelf\u003e\r\n    where TSelf: IUnmanagedInterfaceType\u003cTSelf\u003e\r\n{\r\n    public abstract static unsafe void** ManagedVirtualMethodTable { get; }\r\n}\r\n\r\n[AttributeUsage(AttributeTargets.Interface)]\r\npublic class UnmanagedObjectUnwrapperAttribute\u003cTMapper\u003e : Attribute\r\n    where TMapper : IUnmanagedObjectUnwrapper\r\n{\r\n}\r\n\r\npublic sealed unsafe class ComWrappersUnwrapper : IUnmanagedObjectUnwrapper\r\n{\r\n    public static object GetObjectForUnmanagedWrapper(void* ptr);\r\n}\r\n\r\n[CustomMarshaller(typeof(Exception), MarshalMode.UnmanagedToManagedOut, typeof(ExceptionHResultMarshaller\u003c\u003e))]\r\npublic static class ExceptionAsHResultMarshaller\u003cT\u003e\r\n    where T : unmanaged, INumber\u003cT\u003e\r\n{\r\n    public static T ConvertToUnmanaged(Exception e);\r\n}\r\n\r\n[CustomMarshaller(typeof(Exception), MarshalMode.UnmanagedToManagedOut, typeof(ExceptionNaNMarshaller\u003c\u003e))]\r\npublic static class ExceptionAsNaNMarshaller\u003cT\u003e\r\n    where T : unmanaged, IFloatingPointIeee754\u003cT\u003e\r\n{\r\n    public static T ConvertToUnmanaged(Exception e);\r\n}\r\n\r\n[CustomMarshaller(typeof(Exception), MarshalMode.UnmanagedToManagedOut, typeof(ExceptionDefaultMarshaller\u003c\u003e))]\r\npublic static class ExceptionAsDefaultMarshaller\u003cT\u003e\r\n    where T : unmanaged\r\n{\r\n    public static T ConvertToUnmanaged(Exception e);\r\n}\r\n\r\n[CustomMarshaller(typeof(Exception), MarshalMode.UnmanagedToManagedOut, typeof(SwallowExceptionMarshaller))]\r\npublic static class ExceptionAsVoidMarshaller\r\n{\r\n    public static void ConvertToUnmanaged(Exception e);\r\n}\r\n\r\npublic enum ExceptionMarshalling\r\n{\r\n    Custom = 0,\r\n    Com = 1\r\n}\r\n\r\npublic enum MarshalDirection\r\n{\r\n    ManagedToUnmanaged = 0,\r\n    UnmanagedToManaged = 1,\r\n    Bidirectional = 2\r\n}\r\n\r\n[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\r\npublic sealed class VirtualMethodIndexAttribute : Attribute\r\n{\r\n    public VirtualMethodIndexAttribute(int index);\r\n\r\n    public int Index { get; }\r\n\r\n    public bool ImplicitThisParameter { get; set; } = true;\r\n    public StringMarshalling StringMarshalling { get; set; }\r\n    public Type? StringMarshallingCustomType { get; set; }\r\n    public bool SetLastError { get; set; }\r\n    \r\n    public MarshalDirection Direction { get; set; } = MarshalDirection.Bidirectional;\r\n\r\n    public ExceptionMarshalling ExceptionMarshalling { get; set; }\r\n    public Type? ExceptionMarshallingCustomType { get; set; }\r\n}\r\n```\r\n",
                                           "updatedAt":  "2023-03-21T18:53:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5YPQbZ",
                                           "createdAt":  "2023-03-22T23:44:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e * Should we have a ExceptionFailFastMarshaller?\r\n\u003e     * Or should this be an enum member? If that\u0027s the default (0 member) then this would nicely answer \"what\u0027s the default behavior\".\r\n\u003e * Should we add an SEH marshaller for Windows?\r\n\r\nNeither of these apply for the COM scenario so we can defer them. We are most interested in the below to satisfy the existing COM interop semantics for now.\r\n\r\n\u003e * @AaronRobinsonMSFT would prefer to wait a bit to see whether we actually need it\r\n\r\n@terrajobst Had to step out, sorry. The below subset from above makes perfect sense for .NET 8. Since this subset was approved, we can remove it from above and revisit the remaining APIs once we get more experience from the community in .NET 9.\r\n\r\n```csharp\r\n[CustomMarshaller(typeof(Exception), MarshalMode.UnmanagedToManagedOut, typeof(ExceptionHResultMarshaller\u003c\u003e))]\r\npublic static class ExceptionAsHResultMarshaller\u003cT\u003e\r\n    where T : unmanaged, INumber\u003cT\u003e\r\n{\r\n    public static T ConvertToUnmanaged(Exception e);\r\n}\r\n\r\n[CustomMarshaller(typeof(Exception), MarshalMode.UnmanagedToManagedOut, typeof(ExceptionNaNMarshaller\u003c\u003e))]\r\npublic static class ExceptionAsNaNMarshaller\u003cT\u003e\r\n    where T : unmanaged, IFloatingPointIeee754\u003cT\u003e\r\n{\r\n    public static T ConvertToUnmanaged(Exception e);\r\n}\r\n\r\n[CustomMarshaller(typeof(Exception), MarshalMode.UnmanagedToManagedOut, typeof(ExceptionDefaultMarshaller\u003c\u003e))]\r\npublic static class ExceptionAsDefaultMarshaller\u003cT\u003e\r\n    where T : unmanaged\r\n{\r\n    public static T ConvertToUnmanaged(Exception e);\r\n}\r\n\r\n[CustomMarshaller(typeof(Exception), MarshalMode.UnmanagedToManagedOut, typeof(SwallowExceptionMarshaller))]\r\npublic static class ExceptionAsVoidMarshaller\r\n{\r\n    public static void ConvertToUnmanaged(Exception e);\r\n}\r\n```\r\n",
                                           "updatedAt":  "2023-03-22T23:44:56Z"
                                       }
                                   ],
                         "totalCount":  18
                     },
        "title":  "[API Proposal]: APIs for source generating interop stubs for unmanaged virtual function tables",
        "labels":  [
                       "api-needs-work",
                       "area-System.Runtime.InteropServices",
                       "source-generator"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/81193",
        "createdAt":  "2023-01-25T22:52:38Z",
        "number":  81193,
        "author":  "Mooshua",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCuE9EQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DaZombieKiller",
                                            "createdAt":  "2023-01-26T06:06:19Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2023-01-27T19:46:42Z",
        "body":  "### Background and motivation\n\nNot all strings will follow native norms such as not containing null bytes or properly terminating themselves.\r\n\r\nWe already handle most of these situations with Native -\u003e CLR Marshal methods, but we don\u0027t handle as many going from CLR -\u003e Native.\r\n\r\nI am proposing that `ref`/`out` parameters are added to marshal string methods that declare the exact byte length of the unmanaged copy of the string.\r\n\r\nIn fact, it\u0027s explicit behavior declared in `StringToHGlobal____` to copy null bytes embedded in the string. In some scenarios this has no impact (we can calculate the amount of memory copied fairly easily anyways), but we should still provide APIs that minimize the chances for subtle bugs (especially subtle buffer overrun attacks) to appear in what should otherwise be safe unmanaged code.\r\n\r\nOn top of reducing bugs, this would enable developers to confidently use length-based API functions provided by some unmanaged wrappers to avoid `strlen` calls and drastically increase the performance of unmanaged API invocations--especially in string-laden scenarios.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Runtime.InteropServices.Marshal\r\n\r\npublic class Marshal\r\n{\r\n    // Note: existing string marshal methods use \"s\" instead of \"buffer\" here.\r\n    public IntPtr StringToHGlobalAnsi(string? buffer, out int length);\r\n    public IntPtr StringToHGlobalAuto(string? buffer, out int length);\r\n    public IntPtr StringToHGlobalUni(string? buffer, out int length);\r\n    // Why this method is private, I do not know. But it shouldn\u0027t be excluded.\r\n    private IntPtr StringToHGlobalUTF8(string? buffer, out int length);\r\n\r\n    public IntPtr StringToBSTR(string? buffer, out int length);\r\n\r\n    public IntPtr StringToCoTaskMemAnsi(string? buffer, out int length);\r\n    public IntPtr StringToCoTaskMemAuto(string? buffer, out int length);\r\n    public IntPtr StringToCoTaskMemUni(string? buffer, out int length);\r\n    public IntPtr StringToCoTaskMemUTF8(string? buffer, out int length);\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\n//  ================================================================\r\n//  Scenario: Sending string to API that requires length information\r\n//  fetch string\r\nstring myString = GetMyString();\r\n\r\n//  allocate native copy\r\nvar pointer = Marshal.StringToHGlobalAuto(myString, out var length);\r\nvar result = NativeAPI.DoWork(pointer, length);\r\n\r\n//  ===============================================\r\n//  Scenario: Sending string to API-managed memory.\r\n//  We want to copy the entire buffer using NativeMemory, but NativeMemory and our NativeAPI requires a length parameter.\r\n//  Yes, we can do this by calculating the UTF-16 length, but this introduces less potential for buggy (or insecure) implementations.\r\nstring hostileString = GetStringWithNullByte();\r\n\r\n//  prepare native version\r\nvar unmanagedString = Marshal.StringToHGlobalAuto(hostileString, out var length);\r\n//  the native API now uses our length instead of strlen to avoid falling into the null-byte trap.\r\nvar internalString = NativeAPI.AllocateInternalString(length);\r\n//  copy to the API\u0027s memory\r\nNativeMemory.Copy(unmanagedString, internalString, length);\r\n//  do work with internal memory\r\nNativeAPI.DoWorkWithInternalString(internalString);\r\n```\n\n### Alternative Designs\n\nAlternatively, APIs that calculate a maximum bound for a native string\u0027s length could be provided.\r\n\r\nFor example, this snippet from `StringToHGlobalAnsi` could be provided as a method `StringToAnsiLength`:\r\n```cs\r\nlong lnb = (s.Length + 1) * (long)SystemMaxDBCSCharSize;\r\nint nb = (int)lnb;\r\n\r\n// Overflow checking\r\nif (nb != lnb)\r\n{\r\n    ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.s);\r\n}\r\n```\n\n### Risks\n\nI do not believe any performance regressions should be caused by these changes. This should break binary compatibility, so new methods should be created instead of modifying the existing methods to keep compatibility.\r\n\r\nAdditionally, I understand how `out` parameters are heavily discouraged in modern C# APIs. However, I believe the compactness of the syntax (eg, `out var bufflen`), minimal interference, and already unsafe context make it ideal over other solutions.\r\n\r\nFor example, the changes required for `StringToHGlobalAnsi`:\r\n\r\n```cs\r\n//public static unsafe IntPtr StringToHGlobalAnsi(string? s)\r\npublic static unsafe IntPtr StringToHGlobalAnsi(string? buffer, out int length)\r\n{\r\n    // ...\r\n    long lnb = (buffer.Length + 1) * (long)SystemMaxDBCSCharSize;\r\n    //int nb = (int)lnb;\r\n    length = (int)lnb;\r\n    // ... Refactor rest of file, replacing \"nb\" with \"length\"\r\n}\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOU90eOQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5TtFv_",
                                           "createdAt":  "2023-01-25T22:52:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2023-01-25T22:52:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TtuYj",
                                           "createdAt":  "2023-01-26T02:36:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nNot all strings will follow native norms such as not containing null bytes or properly terminating themselves.\r\n\r\nWe already handle most of these situations with Native -\u003e CLR Marshal methods, but we don\u0027t handle as many going from CLR -\u003e Native.\r\n\r\nI am proposing that `ref`/`out` parameters are added to marshal string methods that declare the exact byte length of the unmanaged copy of the string.\r\n\r\nIn fact, it\u0027s explicit behavior declared in `StringToHGlobal____` to copy null bytes embedded in the string. In some scenarios this has no impact (we can calculate the amount of memory copied fairly easily anyways), but we should still provide APIs that minimize the chances for subtle bugs (especially subtle buffer overrun attacks) to appear in what should otherwise be safe unmanaged code.\r\n\r\nOn top of reducing bugs, this would enable developers to confidently use length-based API functions provided by some unmanaged wrappers to avoid `strlen` calls and drastically increase the performance of unmanaged API invocations--especially in string-laden scenarios.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Runtime.InteropServices.Marshal\r\n\r\npublic class Marshal\r\n{\r\n    // Note: existing string marshal methods use \"s\" instead of \"buffer\" here.\r\n    public IntPtr StringToHGlobalAnsi(string? buffer, out int length);\r\n    public IntPtr StringToHGlobalAuto(string? buffer, out int length);\r\n    public IntPtr StringToHGlobalUni(string? buffer, out int length);\r\n    // Why this method is private, I do not know. But it shouldn\u0027t be excluded.\r\n    private IntPtr StringToHGlobalUTF8(string? buffer, out int length);\r\n\r\n    public IntPtr StringToBSTR(string? buffer, out int length);\r\n\r\n    public IntPtr StringToCoTaskMemAnsi(string? buffer, out int length);\r\n    public IntPtr StringToCoTaskMemAuto(string? buffer, out int length);\r\n    public IntPtr StringToCoTaskMemUni(string? buffer, out int length);\r\n    public IntPtr StringToCoTaskMemUTF8(string? buffer, out int length);\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\n//  ================================================================\r\n//  Scenario: Sending string to API that requires length information\r\n//  fetch string\r\nstring myString = GetMyString();\r\n\r\n//  allocate native copy\r\nvar pointer = Marshal.StringToHGlobalAuto(myString, out var length);\r\nvar result = NativeAPI.DoWork(pointer, length);\r\n\r\n//  ===============================================\r\n//  Scenario: Sending string to API-managed memory.\r\n//  We want to copy the entire buffer using NativeMemory, but NativeMemory and our NativeAPI requires a length parameter.\r\n//  Yes, we can do this by calculating the UTF-16 length, but this introduces less potential for buggy (or insecure) implementations.\r\nstring hostileString = GetStringWithNullByte();\r\n\r\n//  prepare native version\r\nvar unmanagedString = Marshal.StringToHGlobalAuto(hostileString, out var length);\r\n//  the native API now uses our length instead of strlen to avoid falling into the null-byte trap.\r\nvar internalString = NativeAPI.AllocateInternalString(length);\r\n//  copy to the API\u0027s memory\r\nNativeMemory.Copy(unmanagedString, internalString, length);\r\n//  do work with internal memory\r\nNativeAPI.DoWorkWithInternalString(internalString);\r\n```\n\n### Alternative Designs\n\nAlternatively, APIs that calculate a maximum bound for a native string\u0027s length could be provided.\r\n\r\nFor example, this snippet from `StringToHGlobalAnsi` could be provided as a method `StringToAnsiLength`:\r\n```cs\r\nlong lnb = (s.Length + 1) * (long)SystemMaxDBCSCharSize;\r\nint nb = (int)lnb;\r\n\r\n// Overflow checking\r\nif (nb != lnb)\r\n{\r\n    ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.s);\r\n}\r\n```\n\n### Risks\n\nI do not believe any performance regressions should be caused by these changes. This should break binary compatibility, so new methods should be created instead of modifying the existing methods to keep compatibility.\r\n\r\nAdditionally, I understand how `out` parameters are heavily discouraged in modern C# APIs. However, I believe the compactness of the syntax (eg, `out var bufflen`), minimal interference, and already unsafe context make it ideal over other solutions.\r\n\r\nFor example, the changes required for `StringToHGlobalAnsi`:\r\n\r\n```cs\r\n//public static unsafe IntPtr StringToHGlobalAnsi(string? s)\r\npublic static unsafe IntPtr StringToHGlobalAnsi(string? buffer, out int length)\r\n{\r\n    // ...\r\n    long lnb = (buffer.Length + 1) * (long)SystemMaxDBCSCharSize;\r\n    //int nb = (int)lnb;\r\n    length = (int)lnb;\r\n    // ... Refactor rest of file, replacing \"nb\" with \"length\"\r\n}\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eMooshua\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Runtime.InteropServices`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-01-26T02:36:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TwyB5",
                                           "createdAt":  "2023-01-26T16:48:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Mooshua",
                                           "body":  "Hi @AaronRobinsonMSFT! Thank you for the quick response.\r\n\r\nAt the moment, do you fully approve of the API changes above as-is? If so I believe I can contribute a pull request with these changes.\r\n\r\nThanks.",
                                           "updatedAt":  "2023-01-26T16:48:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Tw9Cx",
                                           "createdAt":  "2023-01-26T17:21:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC04lBw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Mooshua",
                                                                               "createdAt":  "2023-01-26T17:27:02Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e At the moment, do you fully approve of the API changes above as-is? If so I believe I can contribute a pull request with these changes.\r\n\r\n@Mooshua Nope, that isn\u0027t my responsibility. I just moved it from \"untriaged\" to a milestone. In this case, there is no need for the APIs so I simply moved it to Future. I am one of the owners of the interop area and the API seems reasonable. I will say that some of these APIs are very old and newer code should be using tools like [`LibraryImport`](https://learn.microsoft.com/dotnet/standard/native-interop/pinvoke-source-generation) so updating them is less of priority for us. \r\n\r\n\u003e If so I believe I can contribute a pull request with these changes.\r\n\r\nAfter we get consensus, the interop team and community, we will add the \"api-ready-for-review\" tag and go through an official API review. If the APIs are then approved work can begin. We would welcome the contribution if these are approved though.\r\n\r\nNext steps are understanding the full extent of your scenario so we can see how these APIs are needed. For example, why is manually marshalling needed?",
                                           "updatedAt":  "2023-01-26T17:21:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TxJ2G",
                                           "createdAt":  "2023-01-26T18:04:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Mooshua",
                                           "body":  "Ah, I see.\r\n\r\nA more specific scenario where this change would be useful is binding code to other languages/runtimes:\r\nThe motivating example on my end was this export in the Lua API:\r\n```c\r\n//  Internalizes buffer \"s\" with length \"l\" and places it on the lua stack.\r\nLUA_API void lua_pushlstring(lua_State* L, const char* s, size_t l);\r\n```\r\nLua strings can contain *any* data, including null bytes, as they are terminated by a set length, not by a null byte. For this reason, there is no `strlen` version of this function (only a C macro, which is heavily discouraged against using).\r\n\r\n**Why not just use a `byte[]`?** \r\nBecause in that case I would be performing an unnecessary copy on arbitrarily sized data. I would much rather move it to and from Lua without having to use an intermediary array copy.\r\n\r\nThe best thing I can do to calculate the length now is to study the behavior of the specific `HGlobal` string helper function I use and copy it, which does not protect me against breaking changes to this behavior.\r\n\r\nThe reverse method is already fully supported by the Marshal class:\r\n```c\r\nLUA_API const char* lua_tolstring(lua_State* L, int idx, size_t* len);\r\n```\r\n```cs\r\n// Under the hood, creates ReadOnlySpan\u003cbyte\u003e(result, length);\r\n// and feeds that into Encoding.GetString()\r\nvalue = Marshal.PtrToStringAnsi(result, (int) length);\r\n```\r\n\r\n\r\n\r\n\r\n\r\n",
                                           "updatedAt":  "2023-01-26T18:04:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TxU2q",
                                           "createdAt":  "2023-01-26T18:40:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC05D0A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "Mooshua",
                                                                               "createdAt":  "2023-01-26T19:28:27Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e A more specific scenario where this change would be useful is binding code to other languages/runtimes:\r\n\u003e The motivating example on my end was this export in the Lua API:\r\n\r\nAh. This is important to us. Thank you for such a concrete example.\r\n\r\nIn order to ensure I understand this scenario a current solution here would be to perform something akin to:\r\n\r\n```csharp\r\nstring dataToSend = \"the quick brown fox jumped over the lazy dog\";\r\nvar buffer = new Span\u003cbyte\u003e(NativeMemory.Alloc(1024), 1024);\r\nint encodedLen = Encoding.UTF8.GetBytes(dataToSend.AsSpan(), buffer);\r\n```\r\n\r\nThe `encodedLen` represents the length of the data that was written into `buffer` and represents a single allocation for the encoding. I _think_ the above is likely what I would recommend since the `Marshal` APIs above dictate the allocator, whereas the above permits the marshalling implementer to decide. This seems far more useful for arbitrary binding code for other languages/runtimes.",
                                           "updatedAt":  "2023-01-26T18:40:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5T3R45",
                                           "createdAt":  "2023-01-27T19:46:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC09xYQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2023-01-27T19:59:22Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Mooshua",
                                           "body":  "That is a neat trick with `GetBytes` that I didn’t know existed—thank you! \r\n\r\nThis solves my motivating scenarios for this API request. Nonetheless I encourage that you still consider it.\r\n\r\nThanks 😄 ",
                                           "updatedAt":  "2023-01-27T19:46:42Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "[API Proposal]: Marshalling strings to unmanaged memory should provide a buffer length",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/81656",
        "createdAt":  "2023-02-05T10:44:25Z",
        "number":  81656,
        "author":  "Symbai",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCuPUBg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "am11",
                                            "createdAt":  "2023-02-05T11:50:11Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-06-12T20:22:12Z",
        "body":  "With a .NET 7 project we can convert existing `DllImport` into `LibraryImport`, see screenshot below. This is a great feature. Unfortunately it does not convert structs into [custom marshaller structs](https://learn.microsoft.com/en-us/dotnet/standard/native-interop/tutorial-custom-marshaller). As @AaronRobinsonMSFT [mentioned](https://github.com/dotnet/runtime/issues/45100#issuecomment-1416063626) those would provide the most ideal performance instead of using `Marshal.PtrToStructure` but also fixing errors we get after the conversion when a struct is used as parameter. Not everyone knows about custom marshaller structs or that they perform better. And not everyone knows how to rewrite their structs. It would be superior, just as with `LibraryImport`, if Visual Studio can do this for us. I was getting told to file out an issue here to requesting it. Background: #45100\r\n\r\n\u003cdetails\u003e \r\n  \u003csummary\u003eScreenshots \u003c/summary\u003e\r\n\r\n![image](https://user-images.githubusercontent.com/14368203/216813957-125687c5-8d7e-4c63-8c4e-67305f7438b2.png)\r\n\r\n![image](https://user-images.githubusercontent.com/14368203/216814284-e26582dd-a78b-4eef-88d5-4f764c02cf56.png)\r\n\r\n\u003c/details\u003e\r\n\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYSX0iA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5UfAOV",
                                           "createdAt":  "2023-02-05T10:44:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nWith a .NET 7 project we can convert existing `DllImport` into `LibraryImport`, see screenshot below. This is a great feature. Unfortunately it does not convert structs into [custom marshaller structs](https://learn.microsoft.com/en-us/dotnet/standard/native-interop/tutorial-custom-marshaller). As @AaronRobinsonMSFT [mentioned](https://github.com/dotnet/runtime/issues/45100#issuecomment-1416063626) those would provide the most ideal performance instead of using `Marshal.PtrToStructure` but also fixing errors we get after the conversion when a struct is used as parameter. Not everyone knows about custom marshaller structs or that they perform better. And not everyone knows how to rewrite their structs. It would be superior, just as with `LibraryImport`, if Visual Studio can do this for us. I was getting told to file out an issue here to requesting it. Background: #45100\r\n\r\n\u003cdetails\u003e \r\n  \u003csummary\u003eScreenshots \u003c/summary\u003e\r\n\r\n![image](https://user-images.githubusercontent.com/14368203/216813957-125687c5-8d7e-4c63-8c4e-67305f7438b2.png)\r\n\r\n![image](https://user-images.githubusercontent.com/14368203/216814284-e26582dd-a78b-4eef-88d5-4f764c02cf56.png)\r\n\r\n\u003c/details\u003e\r\n\r\n\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eSymbai\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-02-05T10:44:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5UiB-H",
                                           "createdAt":  "2023-02-05T18:21:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC1dzvw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkoritzinsky",
                                                                               "createdAt":  "2023-02-05T21:02:34Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "Marking this as .NET 8 so it doesn\u0027t get lost, but this is likely a longer term deliverable.",
                                           "updatedAt":  "2023-02-05T18:21:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5hJfSI",
                                           "createdAt":  "2023-07-10T23:40:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "Moving to .NET 9 as we didn\u0027t have time for this in .NET 8.",
                                           "updatedAt":  "2023-07-10T23:40:46Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Add support for converting structs into custom marshallers structs in Visual Studio",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "source-generator"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/81778",
        "createdAt":  "2023-02-07T19:56:48Z",
        "number":  81778,
        "author":  "thaystg",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-02-08T00:59:20Z",
        "body":  "I think that the user don\u0027t want to step into the generated code if JustMyCode setting is enabled.\r\n\r\nWe implemented it on JSImport and JSExport generators:\r\nhttps://github.com/dotnet/runtime/pull/81715/\r\n\r\nBut maybe this should be done also on `LibraryImport` or maybe this should be implemented by roslyn?\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOVLun4g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5UuED2",
                                           "createdAt":  "2023-02-07T19:56:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nI think that the user don\u0027t want to step into the generated code if JustMyCode setting is enabled.\r\n\r\nWe implemented it on JSImport and JSExport generators:\r\nhttps://github.com/dotnet/runtime/pull/81715/\r\n\r\nBut maybe this should be done also on `LibraryImport` or maybe this should be implemented by roslyn?\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ethaystg\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-02-07T19:56:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5UuEOp",
                                           "createdAt":  "2023-02-07T19:57:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "thaystg",
                                           "body":  "@stephentoub @jkoritzinsky @lewing ",
                                           "updatedAt":  "2023-02-07T19:57:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5UuFLY",
                                           "createdAt":  "2023-02-07T20:00:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e I think that the user don\u0027t want to step into the generated code if JustMyCode setting is enabled.\r\n\r\nDo we have specific users asking to avoid stepping in for this scenario? If so, that would be helpful to know. If we did this without customer asks it might be a bit premature.",
                                           "updatedAt":  "2023-02-07T20:00:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5UuFf4",
                                           "createdAt":  "2023-02-07T20:01:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC2hgkg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2023-02-07T20:05:17Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "elinor-fung",
                                                                               "createdAt":  "2023-02-07T21:12:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "gfoidl",
                                                                               "createdAt":  "2023-02-08T16:53:04Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "w3lld0ne",
                                                                               "createdAt":  "2023-02-22T07:00:19Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e I think that the user don\u0027t want to step into the generated code if JustMyCode setting is enabled.\r\n\r\nI\u0027m not sure that\u0027s the case in general.  One of the benefits of a source generator is it makes the source part of the project just like any other code in the project.  A developer can easily step through it and debug it, and I know folks have done so.  Maybe for some generators we think they\u0027re so low level that folks won\u0027t want to consider that generated code part of the project / wouldn\u0027t want to step through it, but I don\u0027t think we can make that statement in general.",
                                           "updatedAt":  "2023-02-07T20:01:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Uucp9",
                                           "createdAt":  "2023-02-07T21:15:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "elinor-fung",
                                           "body":  "At least for `LibraryImport`, diagnostics (particularly the ability to step through the marshalling code) was intended as one of the nice features of switching to a source generator.",
                                           "updatedAt":  "2023-02-07T21:15:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Uu1K-",
                                           "createdAt":  "2023-02-07T22:33:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lewing",
                                           "body":  "Understood, I guess it boils down to what the semantics of JustMyCode are intended to imply and that is fine to leave up to the generator author.  DebuggerNonUserCode doesn\u0027t prevent debugging.",
                                           "updatedAt":  "2023-02-07T22:33:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Uu3-I",
                                           "createdAt":  "2023-02-07T22:45:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC1oMGg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "lewing",
                                                                               "createdAt":  "2023-02-07T22:57:43Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "An important note is that you can still step into code marked with `DebuggerNonUserCode` if you turn off Just-My-Code, which is a really easy switch to change and (I think at least) semi-common to do for non-beginner developers. This is in comparison to `DebuggerStepThrough`, which makes it impossible to step into the attributed function.",
                                           "updatedAt":  "2023-02-07T22:45:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Uu6fi",
                                           "createdAt":  "2023-02-07T22:57:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC2hgyQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "lewing",
                                                                               "createdAt":  "2023-02-07T22:58:28Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkoritzinsky",
                                                                               "createdAt":  "2023-02-08T00:12:14Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "w3lld0ne",
                                                                               "createdAt":  "2023-02-22T07:01:23Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e Understood, I guess it boils down to what the semantics of JustMyCode are intended to imply and that is fine to leave up to the generator author. DebuggerNonUserCode doesn\u0027t prevent debugging.\r\n\r\n\u003e An important note is that you can still step into code marked with DebuggerNonUserCode if you turn off Just-My-Code, which is a really easy switch to change and (I think at least) semi-common to do for non-beginner developers. \r\n\r\nAll very fair. The guiding thought for me is interop is a complex enough scenario that guessing what people want is going to be very hard in practice. Unless we hear from customers or users that it is annoying or distracting, I am inclined to leave it as-is rather than hide code that we injected into the user\u0027s assembly.",
                                           "updatedAt":  "2023-02-07T22:57:41Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "[question] Methods generated by generator should have DebuggerNonUserCode attribute",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/83870",
        "createdAt":  "2023-03-24T02:44:56Z",
        "number":  83870,
        "author":  "jkoritzinsky",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-06-12T20:22:36Z",
        "body":  "In the interop source generators, we root the syntax tree with our Location objects we propagate for diagnostic reporting. We should use the tricks used in #83868 to create Location objects that don\u0027t root SyntaxTree objects to reduce the places we root Roslyn object inputs.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOWHd0yA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5YWDFu",
                                           "createdAt":  "2023-03-24T02:46:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nIn the interop source generators, we root the syntax tree with our Location objects we propagate for diagnostic reporting. We should use the tricks used in #83868 to create Location objects that don\u0027t root SyntaxTree objects to reduce the places we root Roslyn object inputs.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejkoritzinsky\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `tenet-performance`, `source-generator`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-03-24T02:46:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Yd3TI",
                                           "createdAt":  "2023-03-26T21:04:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Sergio0694",
                                           "body":  "Related: could we consider trying to push to get https://github.com/dotnet/roslyn/issues/63776 implemented, especially since you also mentioned you\u0027d be able to contribute the feature yourself assuming it got approved? Using those APIs would completely solve this issue while also allowing both these source generators and the regex ones to be simplified quite a bit, due to no longer having to maintain that very awkward tuple-return-and-branch pattern to return diagnostics and immediately redirect them to an output node before getting just the incremental models to continue down the pipeline.\r\n\r\nAs a nice side benefit, they\u0027d also be a set of APIs that\u0027d greatly benefit a ton of other generators out there and not just the ones in the runtime (eg. ours in the MVVM Toolkit, as well as those in ComputeSharp, etc.), which is also nice on its own.\r\n\r\nWhat do you think? 🙂",
                                           "updatedAt":  "2023-03-26T21:04:27Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Remove SyntaxTree rooting from interop source generators",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "tenet-performance",
                       "source-generator"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/84441",
        "createdAt":  "2023-04-06T19:17:24Z",
        "number":  84441,
        "author":  "jkoritzinsky",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-05-01T08:03:48Z",
        "body":  "Now that the majority of the new interop features are based on source-generators, we plan on improving our testing story. Our existing tests around diagnostics we issue from the source generators is pretty bare-bones, and there\u0027s some places where we can end up in a bad state when working on new features. We also want to improve our test coverage. Below is a list of improvements we plan to make in our test suites.\r\n\r\n## Improvements to existing test infrastructure\r\n\r\n- [ ] Change our general compilation tests to use the Source Generator testing SDK from dotnet/roslyn-sdk (without the generated sources matching)\r\n- [ ] Provide a mechanism to conditionally reference Ancillary.Interop in the compilation tests, to ensure that we ship all of the types we need to compile the various test cases that we expect to work in the shipping product.\r\n- [ ] Refactor out some of the incremental testing infrastructure to be more easily reused from our various different generator tests (and possibly usable from other non-interop generator testing as well)\r\n\r\n## Additional testing for the COM source generators\r\n\r\n- [ ] Add tests around the attributes we place on the generated code and expect to be placed on the generated code.\r\n- [ ] Add tests for incrementality to ensure that we\u0027re only re-generating code when expected.\r\n\r\n## Testing for Microsoft.Interop.SourceGeneration\r\n\r\nWe have a lot of shared code in this library that we have aspirations to ship separately in the future. Currently, all testing of this library is done through our end-to-end testing of our interop source generators. We plan to add unit tests for the various components in this library.\r\n\r\n- [ ] Add unit tests for `MarshallingInfoParser` and related types.\r\n- [ ] Add unit tests for our in-box `IMarshallingGeneratorFactory` implementations.\r\n- [ ] Add unit tests for our various helper methods.\r\n- [ ] Add unit tests for `BoundGenerators`\r\n- [ ] Add unit tests for `VariableDeclarations`\r\n- [ ] Add unit tests for `SignatureContext` and related types.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOWWECAg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5ZYL7j",
                                           "createdAt":  "2023-04-06T19:22:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sharwell",
                                           "body":  "\u003e Add tests for incrementality to ensure that we\u0027re only re-generating code when expected.\r\n\r\nI\u0027d love to add support for this somewhere in the testing library. In theory, the test would be structured like this:\r\n\r\n* As input, the test provides the original project state (same as we have today) and a delegate to apply a transformation to that project\r\n* The infrastructure somehow returns a `GeneratorRunResult` for the incremental update after applying the transformation\r\n* The test writes assertions surrounding `TrackedSteps` and/or `TrackedOutputSteps`\r\n\r\nIn practice it\u0027s not exactly trivial so still trying to build a proof of concept.",
                                           "updatedAt":  "2023-04-06T19:22:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZYMUE",
                                           "createdAt":  "2023-04-06T19:24:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nNow that the majority of the new interop features are based on source-generators, we plan on improving our testing story. Our existing tests around diagnostics we issue from the source generators is pretty bare-bones, and there\u0027s some places where we can end up in a bad state when working on new features. We also want to improve our test coverage. Below is a list of improvements we plan to make in our test suites.\r\n\r\n## Improvements to existing test infrastructure\r\n\r\n- [ ] Change our general compilation tests to use the Source Generator testing SDK from dotnet/roslyn-sdk (without the generated sources matching)\r\n- [ ] Provide a mechanism to conditionally reference Ancillary.Interop in the compilation tests, to ensure that we ship all of the types we need to compile the various test cases that we expect to work in the shipping product.\r\n- [ ] Refactor out some of the incremental testing infrastructure to be more easily reused from our various different generator tests (and possibly usable from other non-interop generator testing as well)\r\n\r\n## Additional testing for the COM source generators\r\n\r\n- [ ] Add tests around the attributes we place on the generated code and expect to be placed on the generated code.\r\n- [ ] Add tests for incrementality to ensure that we\u0027re only re-generating code when expected.\r\n\r\n## Testing for Microsoft.Interop.SourceGeneration\r\n\r\nWe have a lot of shared code in this library that we have aspirations to ship separately in the future. Currently, all testing of this library is done through our end-to-end testing of our interop source generators. We plan to add unit tests for the various components in this library.\r\n\r\n- [ ] Add unit tests for `MarshallingInfoParser` and related types.\r\n- [ ] Add unit tests for our in-box `IMarshallingGeneratorFactory` implementations.\r\n- [ ] Add unit tests for our various helper methods.\r\n- [ ] Add unit tests for `BoundGenerators`\r\n- [ ] Add unit tests for `VariableDeclarations`\r\n- [ ] Add unit tests for `SignatureContext` and related types.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejkoritzinsky\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `test-enhancement`, `source-generator`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-04-06T19:24:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZYQIC",
                                           "createdAt":  "2023-04-06T19:40:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Sergio0694",
                                           "body":  "+1 on some tooling support for testing incrementality across incremental runs, would love to use that in the MVVM Toolkit and ComputeSharp 😄",
                                           "updatedAt":  "2023-04-06T19:40:34Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Interop source generator testing improvements",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "test-enhancement",
                       "source-generator"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/84499",
        "createdAt":  "2023-04-07T22:01:32Z",
        "number":  84499,
        "author":  "jtschuster",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-08-19T15:41:15Z",
        "body":  "The ComInterfaceGenerator does not support protected interface methods, but will still emit code for them (which does not compile) and doesn\u0027t warn. The generator should warn on the method definition.\r\n\r\nShould private and protected methods be allowed on a partial definition not attributed with [GeneratedComInterface]?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOWXLCdw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5ZcpGB",
                                           "createdAt":  "2023-04-07T22:01:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThe ComInterfaceGenerator does not support protected interface methods, but will still emit code for them (which does not compile) and doesn\u0027t warn. The generator should warn on the method definition.\r\n\r\nShould private and protected methods be allowed on a partial definition not attributed with [GeneratedComInterface]?\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejtschuster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-04-07T22:01:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZcsJ3",
                                           "createdAt":  "2023-04-07T22:21:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "We currently don\u0027t allow non-static interface methods on partial definitions of `[GeneratedComInterface]` interfaces without the `[GeneratedComInterface]` attribute, and I\u0027d rather we be firm/consistent on that rule. Using non-`public` modifiers on instance interface members is pretty rare, so I don\u0027t think we\u0027d be blocking many people if anyone.",
                                           "updatedAt":  "2023-04-07T22:21:04Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "ComInterfaceGenerator should warn on protected methods",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/87059",
        "createdAt":  "2023-06-02T14:09:48Z",
        "number":  87059,
        "author":  "DavidHollman",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-08-24T22:29:43Z",
        "body":  "**This logic should be remembered when adding an export scenario for COM source generators (that is, .NET Assembly -\u003e TLB)**\r\n\r\n### Background and motivation\r\n\r\nIf I have a class such as the following:\r\n\r\n```csharp\r\n[ComVisible(true)]\r\npublic class Sample\r\n{\r\n    public event EventHandler\u003cEventArgs\u003e SampleEvent;\r\n\r\n    private void RaiseSampleEvent() =\u003e SampleEvent?.Invoke(this, EventArgs.Empty);\r\n\r\n    ... // other code with valid COMVisible items\r\n}\r\n```\r\n\r\nI\u0027ll get the following compile-time warnings:\r\n\r\n\u003e Type library exporter warning processing \u0027SampleNamespace.Sample.add_SampleEvent(value), SampleAssembly\u0027. Warning: Type library exporter encountered a generic type instance in a signature. Generic code may not be exported to COM.\r\n\u003e \r\n\u003e Type library exporter warning processing \u0027SampleNamespace.Sample.remove_SampleEvent(value), SampleAssembly\u0027. Warning: Type library exporter encountered a generic type instance in a signature. Generic code may not be exported to COM.\r\n\u003e \r\n\r\nTo remove those warnings it would be nice to do this:\r\n\r\n```csharp\r\n    ...\r\n    [ComVisible(false)]\r\n    public event EventHandler\u003cEventArgs\u003e SampleEvent;\r\n    ....\r\n```\r\n\r\nBut this is illegal, generating the error:\r\n\r\n\u003e Error\tCS0592\tAttribute \u0027ComVisible\u0027 is not valid on this declaration type. It is only valid on \u0027assembly, class, struct, enum, method, property, indexer, field, interface, delegate\u0027 declarations. ...\r\n\r\nSo instead to clear the warning you have to do this:\r\n\r\n\r\n```csharp\r\n[ComVisible(true)]\r\npublic class Sample\r\n{\r\n    event EventHandler\u003cEventArgs\u003e sampleEvent;\r\n\r\n    public event EventHandler\u003cEventArgs\u003e SampleEvent\r\n    {\r\n        [ComVisible(false)]\r\n        add { sampleEvent += value; }\r\n\r\n        [ComVisible(false)]\r\n        remove { sampleEvent -= value; }\r\n    }\r\n\r\n    private void RaiseSampleEvent() =\u003e\r\n        sampleEvent?.Invoke(this, EventArgs.Empty);\r\n}\r\n```\r\n\r\nThis works but its a lot more boilerplate code. Generally I prefer not to have to change the main code just for COM export reasons but it would be even worse to write a wrapper class etc.  Its also not a great choice to ignore the warning since there are many other cases where the warning is valuable.\r\n\r\nIncidentally, the text \"It is only valid on \u0027assembly, class, struct, enum, method, property, indexer, field, interface, delegate\u0027 declarations\" is incomplete because event accessors are also supported.\r\n\r\n\r\n### API Proposal\r\n\r\nIn the definition of [`ComVisibleAttribute`](https://github.com/dotnet/runtime/blob/71660b634753bd097c83aa500faf792872dfdc26/src/libraries/System.Private.CoreLib/src/System/Runtime/InteropServices/ComVisibleAttribute.cs#L7) the flag [`AttributeTargets.Event`](https://learn.microsoft.com/en-us/dotnet/api/system.attributetargets) has to be added.\r\n\r\nBut beyond that I\u0027m not sure what other changes would be needed to actually implement this.\r\n\r\n### API Usage\r\n\r\nSame as above example:\r\n\r\n```csharp\r\n    ...\r\n    [ComVisible(false)]\r\n    public event EventHandler\u003cEventArgs\u003e SampleEvent;\r\n    ....\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOZOF1Tg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5dzzJm",
                                           "createdAt":  "2023-06-02T14:48:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nIf I have a class such as the following:\r\n\r\n```\r\n[ComVisible(true)]\r\npublic class Sample\r\n{\r\n    public event EventHandler\u003cEventArgs\u003e SampleEvent;\r\n\r\n    private void RaiseSampleEvent() =\u003e SampleEvent?.Invoke(this, EventArgs.Empty);\r\n\r\n    ... // other code with valid COMVisible items\r\n}\r\n```\r\n\r\nI\u0027ll get the following compile-time warnings:\r\n\r\n\u003e Type library exporter warning processing \u0027SampleNamespace.Sample.add_SampleEvent(value), SampleAssembly\u0027. Warning: Type library exporter encountered a generic type instance in a signature. Generic code may not be exported to COM.\r\n\u003e \r\n\u003e Type library exporter warning processing \u0027SampleNamespace.Sample.remove_SampleEvent(value), SampleAssembly\u0027. Warning: Type library exporter encountered a generic type instance in a signature. Generic code may not be exported to COM.\r\n\u003e \r\n\r\nTo remove those warnings it would be nice to do this:\r\n\r\n```\r\n    ...\r\n    [ComVisible(false)]\r\n    public event EventHandler\u003cEventArgs\u003e SampleEvent;\r\n    ....\r\n```\r\n\r\nBut this is illegal, generating the error:\r\n\r\n\u003e Error\tCS0592\tAttribute \u0027ComVisible\u0027 is not valid on this declaration type. It is only valid on \u0027assembly, class, struct, enum, method, property, indexer, field, interface, delegate\u0027 declarations. ...\r\n\r\nSo instead to clear the warning you have to do this:\r\n\r\n\r\n```\r\n[ComVisible(true)]\r\npublic class Sample\r\n{\r\n    event EventHandler\u003cEventArgs\u003e sampleEvent;\r\n\r\n    public event EventHandler\u003cEventArgs\u003e SampleEvent\r\n    {\r\n        [ComVisible(false)]\r\n        add { sampleEvent += value; }\r\n\r\n        [ComVisible(false)]\r\n        remove { sampleEvent -= value; }\r\n    }\r\n\r\n    private void RaiseSampleEvent() =\u003e\r\n        sampleEvent?.Invoke(this, EventArgs.Empty);\r\n}\r\n```\r\n\r\nThis works but its a lot more boilerplate code. Generally I prefer not to have to change the main code just for COM export reasons but it would be even worse to write a wrapper class etc.  Its also not a great choice to ignore the warning since there are many other cases where the warning is valuable.\r\n\r\nIncidentally, the text \"It is only valid on \u0027assembly, class, struct, enum, method, property, indexer, field, interface, delegate\u0027 declarations\" is incomplete because event accessors are also supported.\r\n\n\n### API Proposal\n\nNot sure what is expected here.\n\n### API Usage\n\nSame as above example:\r\n\r\n```\r\n    ...\r\n    [ComVisible(false)]\r\n    public event EventHandler\u003cEventArgs\u003e SampleEvent;\r\n    ....\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eDaveInCaz\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Runtime.InteropServices`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-06-02T14:48:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5dz-Nt",
                                           "createdAt":  "2023-06-02T15:17:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "@DaveInCaz Thanks for the suggestion. Given this is around uses of TlbExp, I assume this is a .NET Framework issue. Filing this here is okay from a visibility standpoint because the .NET Framework team is mostly a subset of the .NET Core team. However, for actual work to be done on .NET Framework the most appropriate place for requests/bugs is [Visual Studio Developer Community](https://developercommunity.visualstudio.com/dotnet).\r\n\r\nBefore filing the above issue for .NET Framework, let me offer a quick take on this suggestion. New features or affordances in .NET Framework are unlikely to be accepted, particularly in something as sensitive as COM interop. If this comes across the desk of anyone involved in .NET Framework, my included, this issue is likely to be closed as \"by design\" since there is a workaround and it has been this way since .NET Framework 1.1. If your primary interest for COM interop is on .NET Framework, I am sorry to say there is no chance this is going to be accepted.\r\n\r\nHowever, this issue is something we can fold into the .NET Core COM interop work we are doing with source generators - see [here](https://github.com/dotnet/runtime/issues/66674). As far as TlbExp is concerned that is a tool we are looking at in the future for .NET Core and having a more fine grained way of exporting certain APIs to COM makes a lot of sense. I\u0027m not sure we would change the `ComVisible` API but that is an option.",
                                           "updatedAt":  "2023-06-02T15:17:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5d1MVI",
                                           "createdAt":  "2023-06-02T19:40:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "DavidHollman",
                                           "body":  "Hi @AaronRobinsonMSFT, thanks for your comments \u0026 providing context. I think keeping this open for .NET Core would be a good idea.\r\n\r\nI\u0027m somewhat agnostic as to whether this is handled through `ComVisible` or some other mechanism, though all else being equal having to do less rework when moving COM interop code from Framework to Core would be \"ideal\".",
                                           "updatedAt":  "2023-06-02T19:40:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5k4XVO",
                                           "createdAt":  "2023-08-24T22:29:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "zachcwillson",
                                           "body":  "Adding a +1 to this for .Net Core. We have a WebView2 app were we have a host object that we want to expose events from. The recommended way from the WebView2 team requires us to disable `CA1003` warnings, as we cannot have EventArgs be COMVisible.\r\n\r\nWe see an `InvalidOperationException` with a message like `Some.Namepsace.CustomEventArgs\u0027 has a ComVisible(false) parent \u0027System.EventArgs\u0027 in its hierarchy, therefore QueryInterface calls for IDispatch or class interfaces are disallowed.`\r\n",
                                           "updatedAt":  "2023-08-24T22:29:43Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "[API Proposal]: Allow use of ComVisibleAttribute directly on events",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.InteropServices",
                       "source-generator"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/87236",
        "createdAt":  "2023-06-07T23:06:06Z",
        "number":  87236,
        "author":  "jkoritzinsky",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCwj9dw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "noseratio",
                                            "createdAt":  "2023-06-07T23:11:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rjschnorenberg",
                                            "createdAt":  "2023-06-08T01:51:21Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2025-08-02T22:03:05Z",
        "body":  "We suggest a suffix based on the provided CharSet if the user did not specify ExactSpelling, but we don\u0027t use any source of truth to know if the EntryPoint name is correct.\r\n\r\nThis is okay on the individual fix case as the user can pick which one they want, but this can cause issues when the user does a Fix-All operation, as the P/Invokes can be changed to use an invalid suffix from a distance and there\u0027s not a good mechanism to know which P/Invokes are broken until runtime.\r\n\r\nThis is the only scenario where the ConvertToLibraryImport code-fix would cause a runtime failure without warning. All other scenarios either work right away or show the user a warning and then causes a compile error.\r\n\r\nWe\u0027d have to pull in something like the Win32Metadata project or some other source of truth if we only want to suggest the suffix when it exists for Win32 APIs (and assume that no non-Win32 use the suffix).\r\n            ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOXkWtxg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5eRa3G",
                                           "createdAt":  "2023-06-07T23:06:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nWe suggest a suffix based on the provided CharSet if the user did not specify ExactSpelling, but we don\u0027t use any source of truth to know if the EntryPoint name is correct.\r\n\r\nThis is okay on the individual fix case as the user can pick which one they want, but this can cause issues when the user does a Fix-All operation, as the P/Invokes can be changed to use an invalid suffix from a distance and there\u0027s not a good mechanism to know which P/Invokes are broken until runtime.\r\n\r\nThis is the only scenario where the ConvertToLibraryImport code-fix would cause a runtime failure without warning. All other scenarios either work right away or show the user a warning and then causes a compile error.\r\n\r\nWe\u0027d have to pull in something like the Win32Metadata project or some other source of truth if we only want to suggest the suffix when it exists for Win32 APIs (and assume that no non-Win32 use the suffix).\r\n            \n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejkoritzinsky\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-06-07T23:06:32Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Offer only \"valid\" suffix-appending fixes for ConvertToLibraryImport",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/87347",
        "createdAt":  "2023-06-09T20:59:04Z",
        "number":  87347,
        "author":  "jkoritzinsky",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-01T18:19:07Z",
        "body":  "While trying out the new source-generated-COM adoption analyzers/fixes, I discovered the following usability issues:\r\n\r\n- A warning annotation was not reported to the user for interfaces that would require additional work.\r\n- COM interfaces that can only be converted without additional work by converting other COM interfaces is a common scenario, and our handling of \"only convert interfaces that won\u0027t require additional work\" doesn\u0027t handle this case well (effectively requires multiple phases of fix-all until all cases are converted over)",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYV7-1g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5eew2S",
                                           "createdAt":  "2023-06-09T20:59:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nWhile trying out the new source-generated-COM adoption analyzers/fixes, I discovered the following usability issues:\r\n\r\n- A warning annotation was not reported to the user for interfaces that would require additional work.\r\n- COM interfaces that can only be converted without additional work by converting other COM interfaces is a common scenario, and our handling of \"only convert interfaces that won\u0027t require additional work\" doesn\u0027t handle this case well (effectively requires multiple phases of fix-all until all cases are converted over)\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejkoritzinsky\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-06-09T20:59:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5hXrou",
                                           "createdAt":  "2023-07-13T05:57:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lordmilko",
                                           "body":  "An additional \"UX deficiency\" with the COM source generators is that COM interface methods marked as `[Obsolete]` trigger `CS0612` warnings during compilation (please advise if this should be filed as a separate issue)",
                                           "updatedAt":  "2023-07-13T05:58:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5hXv7W",
                                           "createdAt":  "2023-07-13T06:16:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODAjsxQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "lordmilko",
                                                                               "createdAt":  "2023-07-13T06:38:21Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "@lordmilko do you mean methods on a GeneratedComInterface interface? If so, can you file a separate issue? That an issue we\u0027d want to fix with the generator, not the conversion code fix.",
                                           "updatedAt":  "2023-07-13T06:16:09Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Fix-all for ConvertComImportToGeneratedComInterface experience UX deficiencies",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/87350",
        "createdAt":  "2023-06-09T21:53:13Z",
        "number":  87350,
        "author":  "jkoritzinsky",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-06-15T14:16:47Z",
        "body":  "We recently tested out the \"convert to source-generated COM experience\" on System.Transactions.Local and we found that the existing analyzers/fixers have a few holes that can make adoption more difficult and cause runtime errors.\r\n\r\nIn particular, it is really easy to end up in a state where some, but not all, interfaces have been (or can be) converted over from built-in COM to source-generated COM.\r\n\r\nWe feel that this scenario will be decently common due to the following reasons:\r\n\r\n- Changing a `[ComImport]` interface that is part of public surface area to `[GeneratedComInterface]` is a runtime breaking change.\r\n  - For example, `System.Transactions.IDtcTransaction` is a public interface, but the rest of the COM surface area in System.Transactions.Local is internal only. We can use `Marshal.Get/SetComObjectData` to bridge the two systems, but it\u0027s ugly and easy to mess up and means that there are two different managed objects to represent the same COM object in the same library.\r\n- Developers may want to use source-generated COM in their code, but they consume COM interface definitions from somewhere else that owns them but has not provided source-generated versions.\r\n  - For example, someone writing a VS extension and using their own COM interfaces and VS\u0027s COM interfaces.\r\n- Developers may already be using APIs from the `System.Runtime.InteropServices.ComTypes` namespace. This namespace has standard COM types that we cannot move to being source-generated due to the prior mentioned breaking change issues.\r\n  - For example, `System.Transactions.Local` uses `IConnectionPointContainer` and related connection point sinks, so one of the internal interfaces (and the corresponding implementing C# class) to use built-in COM for that scenario. We can reuse the `Marshal.Get/SetComObjectData` trick we used above to work around this.\r\n\r\nWe discussed this issue offline and determined that a multi-pronged approach here would be best. Each of these steps can be done gradually or not at all. They\u0027re listed in increasing cost/complexity.\r\n\r\n- [x] Update the \"using Runtime-implemented COM APIs with source-generated COM types\" analyzer to also warn for cases where a source-generated COM type is cast to or from a runtime-implemented COM type. Currently, these cases do not report a diagnostic but will always fail at runtime.\r\n- [ ] Provide a runtime configuration option for the following opt-in, not trimming/AOT compliant set of adoption features:\r\n  - [ ] At runtime, detect when a source-generated COM object wrapper is cast to a `[ComImport]` interface, and reflection-emit a type that will enable us to shim the `[ComImport]` interface to the underlying managed object using the built-in marshalling rules (RCW interop).\r\n  - [ ] At compile time, add an implementation of `ICustomQueryInterface` to all `[GeneratedComClass]` types that do not already implement the interface, as well as new implementations of. At runtime, this interface implementation will check if the feature flag is enabled, and if so, get a pointer to a compatible interface implementation that does source-generated marshalling for parameters and gets the `this` managed object from the runtime-based COM interop system.\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOXnu5lw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5ee7mX",
                                           "createdAt":  "2023-06-09T21:53:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nWe recently tested out the \"convert to source-generated COM experience\" on System.Transactions.Local and we found that the existing analyzers/fixers have a few holes that can make adoption more difficult and cause runtime errors.\r\n\r\nIn particular, it is really easy to end up in a state where some, but not all, interfaces have been (or can be) converted over from built-in COM to source-generated COM.\r\n\r\nWe feel that this scenario will be decently common due to the following reasons:\r\n\r\n- Changing a `[ComImport]` interface that is part of public surface area to `[GeneratedComInterface]` is a runtime breaking change.\r\n  - For example, `System.Transactions.IDtcTransaction` is a public interface, but the rest of the COM surface area in System.Transactions.Local is internal only. We can use `Marshal.Get/SetComObjectData` to bridge the two systems, but it\u0027s ugly and easy to mess up and means that there are two different managed objects to represent the same COM object in the same library.\r\n- Developers may want to use source-generated COM in their code, but they consume COM interface definitions from somewhere else that owns them but has not provided source-generated versions.\r\n  - For example, someone writing a VS extension and using their own COM interfaces and VS\u0027s COM interfaces.\r\n- Developers may already be using APIs from the `System.Runtime.InteropServices.ComTypes` namespace. This namespace has standard COM types that we cannot move to being source-generated due to the prior mentioned breaking change issues.\r\n  - For example, `System.Transactions.Local` uses `IConnectionPointContainer` and related connection point sinks, so one of the internal interfaces (and the corresponding implementing C# class) to use built-in COM for that scenario. We can reuse the `Marshal.Get/SetComObjectData` trick we used above to work around this.\r\n\r\nWe discussed this issue offline and determined that a multi-pronged approach here would be best. Each of these steps can be done gradually or not at all. They\u0027re listed in increasing cost/complexity.\r\n\r\n- [ ] Update the \"using Runtime-implemented COM APIs with source-generated COM types\" analyzer to also warn for cases where a source-generated COM type is cast to or from a runtime-implemented COM type. Currently, these cases do not report a diagnostic but will always fail at runtime.\r\n- [ ] Provide a runtime configuration option for the following opt-in, not trimming/AOT compliant set of adoption features:\r\n  - [ ] At runtime, detect when a source-generated COM object wrapper is cast to a `[ComImport]` interface, and reflection-emit a type that will enable us to shim the `[ComImport]` interface to the underlying managed object using the built-in marshalling rules (RCW interop).\r\n  - [ ] At compile time, add an implementation of `ICustomQueryInterface` to all `[GeneratedComClass]` types that do not already implement the interface, as well as new implementations of. At runtime, this interface implementation will check if the feature flag is enabled, and if so, get a pointer to a compatible interface implementation that does source-generated marshalling for parameters and gets the `this` managed object from the runtime-based COM interop system.\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejkoritzinsky\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `tenet-compatibility`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-06-09T21:53:23Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Provide a clean migration experience from built-in COM to source-generated COM",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "tenet-compatibility"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/87443",
        "createdAt":  "2023-06-13T00:07:48Z",
        "number":  87443,
        "author":  "jtschuster",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-08-19T15:38:17Z",
        "body":  "ComInterfaceGenerator will produce code that doesn\u0027t compile if the type passed to MarshalUsingAttribute is not at least `internal` accessibility. The generator should error with a helpful message in this case.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOXqsiow==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5eqyKj",
                                           "createdAt":  "2023-06-13T00:07:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nComInterfaceGenerator will produce code that doesn\u0027t compile if the type passed to MarshalUsingAttribute is not at least `internal` accessibility. The generator should error with a helpful message in this case.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejtschuster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003ejtschuster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-06-13T00:07:56Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "ComInterfaceGenerator should warn if a type passed to MarshalUsing is not accessible from the generated code.",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/88111",
        "createdAt":  "2023-06-27T22:07:34Z",
        "number":  88111,
        "author":  "jtschuster",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCw-LtA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AaronRobinsonMSFT",
                                            "createdAt":  "2023-06-28T00:24:12Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-08-11T21:27:47Z",
        "body":  "If a native COM method fails, the generated code will still attempt to clean up the return value and out parameters. The expected behavior is that a failing `HRESULT` means that out parameters and return values are not valid and any allocation of resources from the callee was cleaned up by the callee. It also means the callee is not expected to clean up any values passed to it, and they should be cleaned up by the caller. Generally, on a failure HRESULT no resources have changed ownership and all memory should be cleaned up by the entity that allocated them (caller or callee).\r\n\r\nThe issue with the generated code it that the UnmanagedToManaged callee methods with by reference parameters take ownership of the passed values after the managed interface method call succeeds, so if the generated code throws when marshalling the value back to native, the callee method will still cleanup the original and return a failing HRESULT. This goes against the expectation that the caller must clean up the passed in value if the return value is a failure.\r\n\r\nSince the marshalling stubs may fail, the generated stubs must follow these rules as well. If the ManagedToUnmanaged wrapper sees a failure HRESULT, it should not try to clean up any of the out parameters or return values.\r\n\r\nThe UnamanagedToManaged wrapper may cause a failure HRESULT during marshalling and unmarshalling, so it must follow the rules for the parameters passed in. If it returns a failing HRESULT, it should not also clean up any of the memory passed by the parameters (though it doesn\u0027t need to worry about the memory it allocates; the GC will handle that).",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOX_r62g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5f-vra",
                                           "createdAt":  "2023-06-27T22:07:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nIf a native COM method fails, the generated code will still attempt to cleanup the return value and out parameters. The expected behavior is that a non-zero HRESULT means that out parameters and return values are cleaned up by the callee and should not be cleaned up by the caller.\r\n\r\nThe generated code should instead set a flag after the UnmarshalCapture stage and check that flag before cleaning up out parameters and return values.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejtschuster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003ejtschuster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-06-27T22:07:44Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "ComInterfaceGenerator does not properly handle lifetimes for return values and \u0027out\u0027 parameters in failing COM methods ",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/88253",
        "createdAt":  "2023-06-30T16:02:47Z",
        "number":  88253,
        "author":  "AaronRobinsonMSFT",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-06-12T20:23:32Z",
        "body":  "Consider, as an example, the [`IEnumUnknown`](https://learn.microsoft.com/windows/win32/api/objidl/nn-objidl-ienumunknown). This interface represents the canonical enumerator pattern using `IUnknown`. The [`Next()`](https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ienumunknown-next) method is the primary concern.\r\n\r\n```c++\r\nHRESULT Next(\r\n  [in]  ULONG    celt,\r\n  [out] IUnknown **rgelt,\r\n  [out] ULONG    *pceltFetched\r\n);\r\n```\r\n\r\nA potential projection of this method/scenario in C# is defined as follows:\r\n\r\n```csharp\r\n[GeneratedComInterface]\r\n[Guid(\"2CEFFE8E-8CA9-4575-A1C8-DA9DFE0BB476\")]\r\npublic partial interface IElement\r\n{ }\r\n\r\n[GeneratedComInterface]\r\n[Guid(\"BA0050D3-4BE1-4DFF-8130-705412C858E6\")]\r\npublic partial interface IEnum\r\n{\r\n    void Next(int a, [MarshalAs(UnmanagedType.LPArray)] IElement[] b, out int bc);\r\n}\r\n```\r\n\r\nThe above works for as an \"in\" parameter, but not for the enumerator use case where `b` is considered a preallocated buffer, `a` is the input length and `bc` is the number of elements added to `b` upon success. We want the `b` array to have \"in\" semantics but its contents to have \"out\". The following are issues faced and the update signature of `Next()` tried.\r\n\r\n### `void Next(int a, [MarshalAs(UnmanagedType.LPArray)] ref IElement[] b, out int bc);`\r\n\r\nThis is likely wrong (i.e., the `ref`) but results in source that will always fail.\r\n\r\n```csharp\r\nSystem.GC.KeepAlive(this);\r\n// Unmarshal - Convert native data to managed data.\r\nSystem.Runtime.InteropServices.Marshal.ThrowExceptionForHR(__invokeRetVal);\r\n/* FAILURE */ __b_native__numElements = -1; // Note that this is initialized to -1 and immediately used below.\r\nb = global::System.Runtime.InteropServices.Marshalling.ArrayMarshaller\u003cglobal::Demo.IElement, System.IntPtr\u003e.AllocateContainerForManagedElements(__b_native, __b_native__numElements);\r\n```\r\n\r\n### `void Next(int a, [Out, MarshalAs(UnmanagedType.LPArray)] IElement[] b, out int bc);`\r\n\r\nThis is what would be expected to work (i.e., `OutAttribute`) but results in a build failure:\r\n\r\n```\r\n..\\runtime\\src\\samples\\LibraryImportGeneratorSample\\Microsoft.Interop.ComInterfaceGenerator\\Microsoft.Interop.ComInterfaceGenerator\\Demo.IEnum.cs(96,68): error CS0266: Cannot implicit \r\nly convert type \u0027nint\u0027 to \u0027void*\u0027. An explicit conversion exists (are you missing a cast?) [..\\runtime\\src\\samples\\LibraryImportGeneratorSample\\LibraryImportGeneratorSample.csproj]    \r\n    0 Warning(s)\r\n    1 Error(s)\r\n```\r\n\r\n### The \"in\" length is different from \"out\" length argument\r\n\r\nThere is no present way to make this dictinction for the Enumerator pattern. One possible way would be to mark the `out` as `ref` and initialize it to input value so the semantics work, but that is unintuitive and violates our goals of making COM more reliable. See `SizeParamIndex` and `CountElementName` for options.\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYR-cMw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5gQOu9",
                                           "createdAt":  "2023-06-30T16:02:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nConsider, as an example, the [`IEnumUnknown`](https://learn.microsoft.com/windows/win32/api/objidl/nn-objidl-ienumunknown). This interface represents the canonical enumerator pattern using `IUnknown`. The [`Next()`](https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ienumunknown-next) method is the primary concern.\r\n\r\n```c++\r\nHRESULT Next(\r\n  [in]  ULONG    celt,\r\n  [out] IUnknown **rgelt,\r\n  [out] ULONG    *pceltFetched\r\n);\r\n```\r\n\r\nA potential projection of this method/scenario in C# is defined as follows:\r\n\r\n```csharp\r\n[GeneratedComInterface]\r\n[Guid(\"2CEFFE8E-8CA9-4575-A1C8-DA9DFE0BB476\")]\r\npublic partial interface IElement\r\n{ }\r\n\r\n[GeneratedComInterface]\r\n[Guid(\"BA0050D3-4BE1-4DFF-8130-705412C858E6\")]\r\npublic partial interface IEnum\r\n{\r\n    void Next(int a, [MarshalAs(UnmanagedType.LPArray)] IElement[] b, out int bc);\r\n}\r\n```\r\n\r\nThe above works for as an \"in\" parameter, but not for the enumerator use case where `b` is considered a preallocated buffer, `a` is the input length and `bc` is the number of elements added to `b` upon success. We want the `b` array to have \"in\" semantics but its contents to have \"out\". The following are issues faced and the update signature of `Next()` tried.\r\n\r\n### `void Next(int a, [MarshalAs(UnmanagedType.LPArray)] ref IElement[] b, out int bc);`\r\n\r\nThis is likely wrong (i.e., the `ref`) but results in source that will always fail.\r\n\r\n```csharp\r\nSystem.GC.KeepAlive(this);\r\n// Unmarshal - Convert native data to managed data.\r\nSystem.Runtime.InteropServices.Marshal.ThrowExceptionForHR(__invokeRetVal);\r\n/* FAILURE */ __b_native__numElements = -1; // Note that this is initialized to -1 and immediately used below.\r\nb = global::System.Runtime.InteropServices.Marshalling.ArrayMarshaller\u003cglobal::Demo.IElement, System.IntPtr\u003e.AllocateContainerForManagedElements(__b_native, __b_native__numElements);\r\n```\r\n\r\n### `void Next(int a, [Out, MarshalAs(UnmanagedType.LPArray)] IElement[] b, out int bc);`\r\n\r\nThis is what would be expected to work (i.e., `OutAttribute`) but results in a build failure:\r\n\r\n```\r\n..\\runtime\\src\\samples\\LibraryImportGeneratorSample\\Microsoft.Interop.ComInterfaceGenerator\\Microsoft.Interop.ComInterfaceGenerator\\Demo.IEnum.cs(96,68): error CS0266: Cannot implicit \r\nly convert type \u0027nint\u0027 to \u0027void*\u0027. An explicit conversion exists (are you missing a cast?) [..\\runtime\\src\\samples\\LibraryImportGeneratorSample\\LibraryImportGeneratorSample.csproj]    \r\n    0 Warning(s)\r\n    1 Error(s)\r\n```\r\n\r\n### The \"in\" length is different from \"out\" length argument\r\n\r\nThere is no present way to make this dictinction for the Enumerator pattern. One possible way would be to mark the `out` as `ref` and initialize it to input value so the semantics work, but that is unintuitive and violates our goals of making COM more reliable. See `SizeParamIndex` and `CountElementName` for options.\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eAaronRobinsonMSFT\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `source-generator`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e8.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-06-30T16:02:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5gQVoP",
                                           "createdAt":  "2023-06-30T16:29:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC_iKgA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2023-06-30T18:04:30Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "\u003e `void Next(int a, [Out, MarshalAs(UnmanagedType.LPArray)] IElement[] b, out int bc);`\r\n\r\nWe should make this work.\r\n\r\n\u003e The \"in\" length is different from \"out\" length argument\r\n\r\nIn MIDL, the corresponding attribute for this concept is [`length_is`](https://learn.microsoft.com/en-us/windows/win32/midl/length-is). The existing `SizeParamIndex` (and `CountElementName`) correspond to [`size_is`](https://learn.microsoft.com/en-us/windows/win32/midl/size-is).\r\n\r\nIn SAL, this concept corresponds to the `_Out_writes_to_(in_length, *out_length)` annotation.\r\n\r\nThis is definitely an interesting area for us to look at supporting.",
                                           "updatedAt":  "2023-06-30T16:29:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5hH5wz",
                                           "createdAt":  "2023-07-10T18:10:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "Moving to .NET 9 so we can have enough design time for the \"The \u0027in\u0027 length is different from \u0027out\u0027 length argument\" concept.",
                                           "updatedAt":  "2023-07-10T18:10:32Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "COM source generator Enumerator pattern",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "source-generator"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/88347",
        "createdAt":  "2023-07-03T18:03:09Z",
        "number":  88347,
        "author":  "AaronRobinsonMSFT",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-07-03T18:09:26Z",
        "body":  "### Background and motivation\r\n\r\nThis proposal would be to audit all types under `System.Runtime.InterfopServices.ComTypes` and update or define new types that are compatible with COM source generators.\r\n\r\nFor example, the [`IStream`](https://learn.microsoft.com/dotnet/api/system.runtime.interopservices.comtypes.istream) type has been defined in the `System.Runtime.InterfopServices.ComTypes` namespace since .NET Framework 2.0. With the creation of the COM source generator it seems appropriate to have a definition of this interface so it is compatible with the new source generator.\r\n\r\nThe most relevant types would be those types related to `IStream`, but a general audit should be performed.\r\n\r\n### API Proposal\r\n\r\nNotes on the below are an example for `IStream`.\r\n1) Pointers are used when appropriate.\r\n2) Unsigned types are not used due to the cumbersome nature of the them in the .NET ecosystem.\r\n3) The full details of `STATSTG` and `STATSTGMarshaller` flow from the pattern established in other marshallers and so are elided.\r\n4) The API surface area has divated from `ComTypes.IStream` to be more .NET friendly. It is possible the signatures should be compatible with the existing definition to make multi-targeting easier. See \"ALT\" below.\r\n5) It would probably be appropriate to define a simple extension method for to/from a normal .NET [`Stream`](https://learn.microsoft.com/dotnet/api/system.io.stream) type.\r\n\r\n```csharp\r\nnamespace System.Runtime.InteropServices.Marshalling;\r\n\r\n[GeneratedComInterface]\r\n[Guid(\"0000000c-0000-0000-C000-000000000046\")]\r\ninternal unsafe interface IStream\r\n{\r\n    // ISequentialStream portion\r\n    // ALT: void Read(byte* pv, int cb, out int pcbRead);\r\n    int Read(byte* pv, int cb);\r\n    // ALT: void Write(byte* pv, int cb, out int pcbWritten);\r\n    int Write(byte* pv, int cb);\r\n\r\n    // IStream portion\r\n    // ALT: void Seek(long dlibMove, int dwOrigin, out long plibNewPosition);\r\n    long Seek(long dlibMove, int dwOrigin);\r\n    void SetSize(long libNewSize);\r\n    void CopyTo(IStream pstm, long cb, out long pcbRead, out long pcbWritten);\r\n    void Commit(int grfCommitFlags);\r\n    void Revert();\r\n    void LockRegion(long libOffset, long cb, int dwLockType);\r\n    void UnlockRegion(long libOffset, long cb, int dwLockType);\r\n    void Stat(out STATSTG pstatstg, int grfStatFlag);\r\n    // ALT: void Clone(out IStream ppstm);\r\n    IStream Clone();\r\n}\r\n\r\n[NativeMarshalling(typeof(STATSTGMarshaller))]\r\nstruct STATSTG\r\n{\r\n// ...\r\n}\r\n\r\n[CustomMarshaller(typeof(STATSTG), MarshalMode.Default, typeof(STATSTGMarshaller))]\r\npublic class STATSTGMarshaller\r\n{\r\n// ...\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\nAny API utilizing source generated COM interop and the relevant types.\r\n\r\n### Alternative Designs\r\n\r\nLet users define these types themselves.\r\n\r\n### Risks\r\n\r\nConfusion about when and why to use these new definitions.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYH9RWQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5gf1FZ",
                                           "createdAt":  "2023-07-03T18:03:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nThis proposal would be to audit all types under `System.Runtime.InterfopServices.ComTypes` and update or define new types that are compatible with COM source generators.\r\n\r\nFor example, the [`IStream`](https://learn.microsoft.com/dotnet/api/system.runtime.interopservices.comtypes.istream) type has been defined in the `System.Runtime.InterfopServices.ComTypes` namespace since .NET Framework 2.0. With the creation of the COM source generator it seems appropriate to have a definition of this interface so it is compatible with the new source generator.\r\n\r\nThe most relevant types would be those types related to `IStream`, but a general audit should be performed.\n\n### API Proposal\n\nNotes on the below are an example for `IStream`.\r\n1) Pointers are used when appropriate.\r\n2) Unsigned types are not used due to the cumbersome nature of the them in the .NET ecosystem.\r\n3) The full details of `STATSTG` and `STATSTGMarshaller` flow from the pattern established in other marshallers and so are elided.\r\n4) It would probably be appropriate to define a simple extension method for to/from a normal .NET [`Stream`](https://learn.microsoft.com/dotnet/api/system.io.stream) type.\r\n\r\n```csharp\r\nnamespace System.Runtime.InteropServices.Marshalling;\r\n\r\n[GeneratedComInterface]\r\n[Guid(\"0000000c-0000-0000-C000-000000000046\")]\r\ninternal unsafe interface IStream\r\n{\r\n    // ISequentialStream portion\r\n    void Read(byte* pv, int cb, out int pcbRead);\r\n    void Write(byte* pv, int cb, out int pcbWritten);\r\n\r\n    // IStream portion\r\n    void Seek(long dlibMove, int dwOrigin, out long plibNewPosition);\r\n    void SetSize(long libNewSize);\r\n    void CopyTo(IStream pstm, long cb, out long pcbRead, out long pcbWritten);\r\n    void Commit(int grfCommitFlags);\r\n    void Revert();\r\n    void LockRegion(long libOffset, long cb, int dwLockType);\r\n    void UnlockRegion(long libOffset, long cb, int dwLockType);\r\n    void Stat(out STATSTG pstatstg, int grfStatFlag);\r\n    IStream Clone();\r\n}\r\n\r\n[NativeMarshalling(typeof(STATSTGMarshaller))]\r\nstruct STATSTG\r\n{\r\n// ...\r\n}\r\n\r\n[CustomMarshaller(typeof(STATSTG), MarshalMode.Default, typeof(STATSTGMarshaller))]\r\npublic class STATSTGMarshaller\r\n{\r\n// ...\r\n}\r\n```\r\n\n\n### API Usage\n\nAny API utilizing source generated COM interop and the relevant types.\n\n### Alternative Designs\n\nLet users define these types themselves.\n\n### Risks\n\nConfusion about when and why to use these new definitions.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eAaronRobinsonMSFT\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003eFuture\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-07-03T18:03:15Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "[API Proposal]: Make `System.Runtime.InteropServices.ComTypes` compatible with COM source generator",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/88431",
        "createdAt":  "2023-07-05T17:04:03Z",
        "number":  88431,
        "author":  "agocke",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-01T17:59:34Z",
        "body":  "This causes the enum members to be hidden from VS completion. Some of these members appear to still be in use and documented (see https://learn.microsoft.com/en-us/dotnet/standard/native-interop/customize-struct-marshalling for UnmanagedType.Struct). ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYT8eug==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5gsCZa",
                                           "createdAt":  "2023-07-05T17:04:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThis causes the enum members to be hidden from VS completion. Some of these members appear to still be in use and documented (see https://learn.microsoft.com/en-us/dotnet/standard/native-interop/customize-struct-marshalling for UnmanagedType.Struct). \n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eagocke\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-07-05T17:04:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5hPx66",
                                           "createdAt":  "2023-07-11T21:19:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "Many of the hidden options are only used in COM scenarios (or only specify non-default behavior in COM scenarios) and were hidden when .NET Core was trying to not include COM support. As a result, many of these options will likely only be used in scenarios where tlbimp is used to generate an interop assembly, so they won\u0027t be used from C# directly.\r\n\r\nIt may be worthwhile to remove the `EB(Never)` attribute for a few options like `Struct` which still have a minor use case, but I\u0027d rather wait until we have use cases for these options in source-generated interop than remove them now.",
                                           "updatedAt":  "2023-07-11T21:19:36Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Multiple documented members of System.Runtime.InteropServices.UnmanagedType are marked EditorBrowsable(Never)",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/88438",
        "createdAt":  "2023-07-05T19:33:17Z",
        "number":  88438,
        "author":  "jtschuster",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-11T21:27:21Z",
        "body":  "See https://github.com/dotnet/runtime/issues/88111 for how the current generated code doesn\u0027t follow the rules.\r\n## Motivation:\r\nTo follow the ownership and lifetime expectations for COM, the generator pipeline should only assign to parameters and return values at the end of the method after unmarshalling / marshalling all parameters has succeeded. The generally recommended way to achieve this is to avoid modifying any parameters until the last basic block that returns a successful HRESULT. For our generator pipeline, this could look like an additional stage where local variables holding the final values of parameters are assigned to the parameters.\r\n\r\n## Proposal:\r\nThe new list of stages would be:\r\n1. Setup\r\n2. Marshal\r\n3. Pin\r\n4. PinnedMarshal\r\n5. Invoke\r\n6. NotifyForSuccessfulInvoke\r\n7. UnmarshalCapture\r\n8. Unmarshal\r\n9. GuaranteedUnmarshal\r\n10. Cleanup\r\n11. AssignOut\r\n\r\n```C#\r\n\u003c\u003c Variable Declarations \u003e\u003e\r\n\u003c\u003c Setup \u003e\u003e\r\ntry\r\n{\r\n    \u003c\u003c Marshal \u003e\u003e\r\n    \u003c\u003c Pin \u003e\u003e (fixed)\r\n    {\r\n        \u003c\u003c Pinned Marshal \u003e\u003e\r\n        \u003c\u003c Invoke \u003e\u003e\r\n    }\r\n    \u003c\u003c Notify For Successful Invoke \u003e\u003e\r\n    \u003c\u003c Unmarshal Capture \u003e\u003e\r\n    \u003c\u003c Unmarshal \u003e\u003e\r\n}\r\nfinally\r\n{\r\n    \u003c\u003c GuaranteedUnmarshal \u003e\u003e\r\n    \u003c\u003c Cleanup \u003e\u003e\r\n}\r\n\u003c\u003c AssignOut \u003e\u003e\r\nreturn \u003creturnValue\u003e;\r\n```\r\n\r\n## Issues:\r\nThis causes slightly unexpected behavior for arrays of blittable elements that are pinned in the ManagedToUnmanaged stubs. These values could be modified if the pInvoke succeeds, but unmarshalling throws an exception. However, this may be more of a minor issue since this doesn\u0027t lead to a memory leak or double free, and can be fixed by allocating and copying all the values to a new temporary array to pass to the Unmanaged COM method.\r\n\r\n## Examples:\r\nAssign out would look like the following for the following scenarios for ManagedToUnmanaged.\r\n\r\n- struct, blittable type / primitive: Not applicable. These values cannot pass ownership back to the caller.\r\n- reference to struct, blittable type / primitive (`ref StructType parameter`): \\\u003cparameter\\\u003e = \\\u003cUnmarshalledValue\\\u003e\r\n  - `ref StructType parameter`:\r\n    ```C#\r\n    // Unmarshal\r\n    StructType _parameter_managed = StructTypeMarshaller.ConvertToManaged((*_parameter_native));\r\n    ...\r\n    // Assign out\r\n    parameter = _parameterManaged;\r\n    ```\r\n- Arrays: \\\u003cSpanOfUnmarshalledValues\\\u003e.CopyTo(parameter)\r\n  - `ClassType[] array`:\r\n    ```C#\r\n    // Unmarshal\r\n    Span\u003cClassType\u003e _array_managed = ...;\r\n    ...\r\n    // Assign Out\r\n    _array_managed.CopyTo(array);\r\n    ```\r\n- References to reference type: \u003cref parameter\u003e = \\\u003cUnmarshalledValue\\\u003e\r\n  - `ref ClassType parameter`:\r\n    ```C#\r\n    // Unmarshal\r\n    ClassType _parameter_managed = ClassTypeMarshaller.ConvertToManaged((*_parameter_native));\r\n    ...\r\n    // Assign out\r\n    parameter = _parameterManaged;\r\n    ```\r\n\r\nAnd like the following for UnmanagedToManaged:\r\n- struct, blittable type / primitive: Not applicable. These values cannot pass ownership back to the caller.\r\n- reference to struct, blittable type / primitive (`StructType* parameter`): (*\\\u003cparameter\\\u003e) = \\\u003cMarshalledValue\\\u003e\r\n  - `StructType* value`\r\n    ```C#\r\n    // Marshal\r\n    StructType _value_native = StructTypeMarshaller.ConvertToUnmanaged(_value_managed);\r\n    ...\r\n    // Assign out\r\n    (*value) = _value_native;\r\n    ```\r\n- Arrays: \\\u003cSpanOfMarshalledValues\\\u003e.CopyTo(parameterUnmanagedValuesDestination)\r\n  - `int* array, int length`: \r\n    ```C#\r\n    // Marshal\r\n    Span\u003cint\u003e _array_native_nativeSpan = ...;\r\n    ...\r\n    // Assign out\r\n    Span\u003cint\u003e _array_native_parameterSpan = ArrayMarshaller\u003cint, int\u003e.GetUnmanagedValuesDestination(array, length);\r\n    _array_native_nativeSpan.CopyTo(_array_native_parameterSpan);\r\n     ```\r\n- References to references: (*\u003cparameter\u003e) = \u003cMarshalledValue\u003e\r\n  - `int[]* array` /  `int[]* array`\r\n    ```C#\r\n    // Marshal\r\n    int* array_native_nativeSpan = ...;\r\n    ...\r\n    // Assign out\r\n    (*array) = _array_native_nativeSpan;`\r\n    ```\r\n- SafeHandles\r\n  - `nint* handle`\r\n    ```C#\r\n    // Marshal\r\n    nint _handle = _handleMarshaller.ToUnmanaged(_handle_managed);\r\n    ...\r\n    // Assign out\r\n    (*handle) = _handle_native;\r\n    ```\r\n\r\n## Drawbacks:\r\nThis could be a significant amount of work and may only be necessary for a few edge cases that are left.\r\n\r\n## Benefits:\r\nThis would make our lifetime issues much less likely and generated code would follow general COM guidance.\r\nThis also would allow us to remove ownership tracking marshalling generators like `UnmanagedToManagedOwnershipTrackingStrategy`\r\n\r\n## Todo:\r\n- [ ] Generate a local `param_native_out` variable to hold the marshalled value.\r\n- [ ] #89483\r\n- [ ] Generate a free of the old parameter in the assign out stage\r\n- [ ] Properly clean up each element of [Out] contents marshalling in unmanaged to managed stubs\r\n- [ ] #89463\r\n- [ ] ~~#89462~~ https://github.com/dotnet/runtime/issues/89465\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYLNCRA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5gs0JE",
                                           "createdAt":  "2023-07-05T19:33:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nSee https://github.com/dotnet/runtime/issues/88111 for how the current generated code doesn\u0027t follow the rules.\r\n## Motivation:\r\nTo follow the ownership and lifetime expectations for COM, the generator pipeline should only assign to parameters and return values at the end of the method after unmarshalling / marshalling all parameters has succeeded. The generally recommended way to achieve this is to avoid modifying any parameters until the last basic block that returns a successful HRESULT. For our generator pipeline, this could look like an additional stage where local variables holding the final values of parameters are assigned to the parameters.\r\n\r\n## Proposal:\r\nThe new list of stages would be:\r\n1. Setup\r\n2. Marshal\r\n3. Pin\r\n4. PinnedMarshal\r\n5. Invoke\r\n6. NotifyForSuccessfulInvoke\r\n7. UnmarshalCapture\r\n8. Unmarshal\r\n9. GuaranteedUnmarshal\r\n10. Cleanup\r\n11. AssignOut\r\n\r\n```C#\r\n\u003c\u003c Variable Declarations \u003e\u003e\r\n\u003c\u003c Setup \u003e\u003e\r\ntry\r\n{\r\n    \u003c\u003c Marshal \u003e\u003e\r\n    \u003c\u003c Pin \u003e\u003e (fixed)\r\n    {\r\n        \u003c\u003c Pinned Marshal \u003e\u003e\r\n        \u003c\u003c Invoke \u003e\u003e\r\n    }\r\n    \u003c\u003c Notify For Successful Invoke \u003e\u003e\r\n    \u003c\u003c Unmarshal Capture \u003e\u003e\r\n    \u003c\u003c Unmarshal \u003e\u003e\r\n}\r\nfinally\r\n{\r\n    \u003c\u003c GuaranteedUnmarshal \u003e\u003e\r\n    \u003c\u003c Cleanup \u003e\u003e\r\n}\r\n\u003c\u003c AssignOut \u003e\u003e\r\nreturn \u003creturnValue\u003e;\r\n```\r\n\r\n## Issues:\r\nThis causes slightly unexpected behavior for arrays of blittable elements that are pinned in the ManagedToUnmanaged stubs. These values could be modified if the pInvoke succeeds, but unmarshalling throws an exception. However, this may be more of a minor issue since this doesn\u0027t lead to a memory leak or double free, and can be fixed by allocating and copying all the values to a new temporary array to pass to the Unmanaged COM method.\r\n\r\n## Examples:\r\nAssign out would look like the following for the following scenarios for ManagedToUnmanaged.\r\n\r\n- struct, blittable type / primitive: Not applicable. These values cannot pass ownership back to the caller.\r\n- reference to struct, blittable type / primitive (`ref StructType parameter`): \\\u003cparameter\\\u003e = \\\u003cUnmarshalledValue\\\u003e\r\n- Arrays: \\\u003cSpanOfUnmarshalledValues\\\u003e.CopyTo(parameter)\r\n- References to reference type: ref \u003cparameter\u003e = ref \\\u003cUnmarshalledValue\\\u003e\r\n\r\nAnd like the following for UnmanagedToManaged:\r\n- struct, blittable type / primitive: Not applicable. These values cannot pass ownership back to the caller.\r\n- reference to struct, blittable type / primitive (`StructType* parameter`): (*\\\u003cparameter\\\u003e) = \\\u003cMarshalledValue\\\u003e\r\n  - `StructType* value`\r\n    ```C#\r\n    _value_native = StructTypeMarshaller.ConvertToManaged(...);\r\n    ...\r\n    (*value) = _value_native;\r\n    ```\r\n- Arrays: \\\u003cSpanOfMarshalledValues\\\u003e.CopyTo(parameterUnmanagedValuesDestination)\r\n  - `int* array, int length`: \r\n    ```C#\r\n    Span\u003cint\u003e _array_native_parameterSpan = ArrayMarshaller\u003cint, int\u003e.GetUnmanagedValuesDestination(array, length);\r\n    ...\r\n    _array_native_nativeSpan.CopyTo(_array_native_parameterSpan);\r\n     ```\r\n- References to references: (*\u003cparameter\u003e) = \u003cMarshalledValue\u003e\r\n  - `int** array`\r\n    ```C#\r\n    int* array_native_nativeSpan = ...;\r\n    ...\r\n    (*array) = _array_native_nativeSpan;`\r\n    ```\r\n\r\n## Drawbacks:\r\nThis could be a significant amount of work and may only be necessary for a few edge cases that are left.\r\n\r\n## Benefits:\r\nThis would make our lifetime issues much less likely and generated code would follow general COM guidance.\r\nThis also would allow us to remove ownership tracking marshalling generators like `UnmanagedToManagedOwnershipTrackingStrategy`\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejtschuster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003ejtschuster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-07-05T19:33:27Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Marshalling generator pipeline should unmarshal / marshal parameters into local variables and assign just before return",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/88617",
        "createdAt":  "2023-07-10T17:57:07Z",
        "number":  88617,
        "author":  "jtschuster",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-08-19T15:41:22Z",
        "body":  "LibraryImportGenerator and ComInterfaceGenerator allow `[Out]` on a `string`, which implies the native method will modify the string, which can lead to runtime corruption. The interop generators should error if they see this and suggest a `char` array or a `ref`/`out` parameter instead.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYR-mJg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5hH1mX",
                                           "createdAt":  "2023-07-10T17:57:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nLibraryImportGenerator and ComInterfaceGenerator allow `[Out]` on a `string`, which implies the native method will modify the string, which can lead to runtime corruption. The interop generators should warn if they see this and suggest a `char` array or a `ref`/`out` parameter instead.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejtschuster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003ejtschuster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `source-generator`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-07-10T17:57:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5hH6CS",
                                           "createdAt":  "2023-07-10T18:11:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODASBUQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkoritzinsky",
                                                                               "createdAt":  "2023-07-10T18:11:37Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jtschuster",
                                                                               "createdAt":  "2023-07-10T18:11:48Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e  The interop generators should warn if they see this\r\n\r\nI think we might just want an error. I can\u0027t recall if this is one of those things that warning/error are the same thing, but I would argue this should be a hard fail as it is wrong.",
                                           "updatedAt":  "2023-07-10T18:11:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5hH6Ym",
                                           "createdAt":  "2023-07-10T18:12:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "I agree with @AaronRobinsonMSFT here. This should be an error as it can lead to runtime corruption. It\u0027s only a warning for P/Invokes because we couldn\u0027t make it an error.",
                                           "updatedAt":  "2023-07-10T18:12:33Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Source Generated interop should warn when a user puts `[OutAttribute]` on a `string` and suggest `[Out] char[]`",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "source-generator"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/88701",
        "createdAt":  "2023-07-11T21:23:03Z",
        "number":  88701,
        "author":  "buyaa-n",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-01T17:59:13Z",
        "body":  "## Fix warnings found with RS1038 analyzer\r\n\r\nRecent analyzer updates flown to the runtime repo having build failures related to `RS1038: Compiler extensions should be implemented in assemblies with compiler-provided references`. The warnings looks valid and needs a proper fix, for now they are suppressed.\r\n\r\nSample log:\r\n```log\r\nwarning RS1038: This compiler extension should not be implemented in an assembly containing a reference to Microsoft.CodeAnalysis.Workspaces. The Microsoft.CodeAnalysis.Workspaces assembly is not provided during command line compilation scenarios, so references to it could cause the compiler extension to behave unpredictably.\r\n```\r\n\r\nRelated to https://github.com/dotnet/runtime/pull/87768\r\nCC @jkoritzinsky ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYUA56A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5hPy2L",
                                           "createdAt":  "2023-07-11T21:23:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n## Fix warnings found with RS1038 analyzer\r\n\r\nRecent analyzer updates flown to the runtime repo having build failures related to `RS1038: Compiler extensions should be implemented in assemblies with compiler-provided references`. The warnings looks valid and needs a proper fix, for now they are suppressed.\r\n\r\nSample log:\r\n```log\r\nwarning RS1038: This compiler extension should not be implemented in an assembly containing a reference to Microsoft.CodeAnalysis.Workspaces. The Microsoft.CodeAnalysis.Workspaces assembly is not provided during command line compilation scenarios, so references to it could cause the compiler extension to behave unpredictably.\r\n```\r\n\r\nRelated to https://github.com/dotnet/runtime/pull/87768\r\nCC @jkoritzinsky \n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ebuyaa-n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-07-11T21:23:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5hQDno",
                                           "createdAt":  "2023-07-11T22:40:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "This is due to the interop analyzers putting analyzers and code fixes into the same assembly. It looks like we need to split them into separate assemblies for the re-written RS1038 rule to be satisfied. Moving to .NET 9 as this is more infra work than anything else (as we\u0027re careful to not use the workspaces APIs in the analyzer or generator code).",
                                           "updatedAt":  "2023-07-11T22:40:39Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Fix RS1038 related warnings found in Interop source generators",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/88956",
        "createdAt":  "2023-07-15T22:40:13Z",
        "number":  88956,
        "author":  "lordmilko",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-02T22:03:38Z",
        "body":  "Attempting to marshal a struct containing a `bool` generates an error that runtime marshalling must be disabled.\r\n\r\n```c#\r\npublic struct s\r\n{\r\n    [MarshalAs(UnmanagedType.Bool)]\r\n    public bool a;\r\n}\r\n\r\n[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\r\n[ComConversionLoss]\r\n[Guid(\"28B5557D-3F3F-48B4-90B2-5F9EEA2F6C48\")]\r\n[GeneratedComInterface]\r\npublic partial interface foo\r\n{\r\n    //Error: Runtime marshalling must be disabled\r\n    void Bar(out s value);\r\n\r\n    //Error: Runtime marshalling must be disabled\r\n    void MarshalAsArray(\r\n        int count,\r\n        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)]\r\n        s[] array);\r\n\r\n    //Error: Runtime marshalling must be disabled\r\n    void MarshalUsingArray(\r\n        int count,\r\n        [MarshalUsing(typeof(ArrayMarshaller\u003c,\u003e), CountElementName = nameof(count))]\r\n        s[] array);\r\n}\r\n```\r\nAs per the [compatibility](https://github.com/dotnet/runtime/blob/main/docs/design/libraries/LibraryImportGenerator/Compatibility.md#bool-marshalling) document, you can \"solve\" this by applying `DisableRuntimeMarshallingAttribute` to the assembly.\r\n\r\nWhen runtime marshalling is disabled, no error is given if your `bool` field is missing `MarshalAsAttribute`. As per the compatibility document\r\n\r\n\u003e As a result, when a value type that has a bool field is passed to native code through source-generated marshalling, the bool field is treated as a 1-byte value and is not normalized. Since this default is a little odd and unlikely to be the majority use case, we\u0027re going to generally take a stance that all bool marshalling must be explicitly specified via MarshalAs or other mechanisms.\r\n\r\nBased on the current behavior of structs containing `bool` fields, this raises the following questions\r\n\r\n* Should Visual Studio be throwing an error that `bool` fields should have a `MarshalAsAttribute`?\r\n* Will a `bool` field missing a `MarshalAsAttribute` be marshalled as `U1` by default (since `MarshalAsAttribute` is not currently being enforced)?\r\n* Would applying a `MarshalAsAttribute` even *do anything* in this case, since the built-in runtime marshalling system is disabled, and no \"native\" struct declaration has been provided?\r\n\r\nCurrently, this is quite confusing, and if there\u0027s actually no way to make your `bool` in a struct be `U4` without writing your own \"native\" struct + custom marshaller, the advice to disable runtime marshalling would create quite a \"gotcha\" when your `bool` fields need to be `U4` (the common case).\r\n\r\nIn addition, if you don\u0027t want to actually disable the built-in runtime marshalling system, it would seem your only option would be to declare a \"native\" struct + custom marshaller anyway. In that sense, this would seem to tie in with #88284 wherein I would present there should be a system you can leverage to automatically generate \"native\" representations of structs based on their `MarshalAs`/`native types-pointed-to-by-MarshalUsing` attributes.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYZFG-g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5hkS8f",
                                           "createdAt":  "2023-07-15T22:40:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nAttempting to marshal a struct containing a `bool` generates an error that runtime marshalling must be disabled.\r\n\r\n```c#\r\npublic struct s\r\n{\r\n    [MarshalAs(UnmanagedType.Bool)]\r\n    public bool a;\r\n}\r\n\r\n[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\r\n[ComConversionLoss]\r\n[Guid(\"28B5557D-3F3F-48B4-90B2-5F9EEA2F6C48\")]\r\n[GeneratedComInterface]\r\npublic partial interface foo\r\n{\r\n    //Error: Runtime marshalling must be disabled\r\n    void MarshalAs(\r\n        int count,\r\n        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)]\r\n        s[] array);\r\n\r\n    //Error: Runtime marshalling must be disabled\r\n    void MarshalUsing(\r\n        int count,\r\n        [MarshalUsing(typeof(ArrayMarshaller\u003c,\u003e), CountElementName = nameof(count))]\r\n        s[] array);\r\n}\r\n```\r\nAs per the [compatibility](https://github.com/dotnet/runtime/blob/main/docs/design/libraries/LibraryImportGenerator/Compatibility.md#bool-marshalling) document, you can \"solve\" this by applying `DisableRuntimeMarshallingAttribute` to the assembly.\r\n\r\nWhen runtime marshalling is disabled, no error is given if your `bool` field is missing `MarshalAsAttribute`. As per the compatibility document\r\n\r\n\u003e As a result, when a value type that has a bool field is passed to native code through source-generated marshalling, the bool field is treated as a 1-byte value and is not normalized. Since this default is a little odd and unlikely to be the majority use case, we\u0027re going to generally take a stance that all bool marshalling must be explicitly specified via MarshalAs or other mechanisms.\r\n\r\nBased on the current behavior of structs containing `bool` fields, this raises the following questions\r\n\r\n* Should Visual Studio be throwing an error that `bool` fields should have a `MarshalAsAttribute`?\r\n* Will a `bool` field missing a `MarshalAsAttribute` be marshalled as `U1` by default?\r\n* Would applying a `MarshalAsAttribute` even *do anything* in this case, since the built-in runtime marshalling system is disabled, and no \"native\" struct declaration has been provided?\r\n\r\nCurrently, this is quite confusing, and if there\u0027s actually no way to make your `bool` in a struct be `U4` without writing your own \"native\" struct + custom marshaller, the advice to disable runtime marshalling would create quite a \"gotcha\" when your `bool` fields need to be `U4` (the common case).\r\n\r\nIn addition, if you don\u0027t want to actually disable the built-in runtime marshalling system, it would seem your only option would be to declare a \"native\" struct + custom marshaller anyway. In that sense, this would seem to tie in with #88284 wherein I would present there should be a system you can leverage to automatically generate \"native\" representations of structs based on their `MarshalAs`/`MarshalUsing` attributes.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003elordmilko\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-07-15T22:40:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5hkUb6",
                                           "createdAt":  "2023-07-15T23:10:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "The currently supported struct marshalling logic is either define the struct as blittable or implement a custom marshaller with [CustomMarshallerAttribute](https://learn.microsoft.com/dotnet/api/system.runtime.interopservices.marshalling.custommarshallerattribute).",
                                           "updatedAt":  "2023-07-15T23:10:12Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[ComInterfaceGenerator] Marshalling structs containing bool fields",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/89389",
        "createdAt":  "2023-07-24T15:16:39Z",
        "number":  89389,
        "author":  "mveril",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-07-28T10:11:15Z",
        "body":  "Hello\r\nHow to implement a marshalller for a null terminated contiguous collection on .NET 7 using [LibraryImport](https://learn.microsoft.com/dotnet/standard/native-interop/pinvoke-source-generation) and [ContiguousCollectionMarshallerAttribute](https://learn.microsoft.com/dotnet/api/system.runtime.interopservices.marshalling.contiguouscollectionmarshallerattribute?view=net-7.0) ? I currently work on a wrapper around [libimobiledevice](https://libimobiledevice.org) called [MobileDeviceSharp](https://github.com/mveril/MobileDeviceSharp) the aim of this project is to implement a fully object-oriented wrapper around this C library in order to work with it as a standard .NET way. For many collections returned by the C library we don\u0027t have any out parameter to know the size of the returned collection. The count is intended to be determined at runtime using the null terminated beaviour of the returned collection exactly like the string marshaller do for strings. So, I cannot use [CountElementName](https://learn.microsoft.com/dotnet/api/system.runtime.interopservices.marshalling.marshalusingattribute.countelementname?view=net-7.0). For DllImport I found a workaround using generic [ICustomMarshaller](https://learn.microsoft.com/dotnet/api/system.runtime.interopservices.icustommarshaler?view=net-6.0) that take another  [ICustomMarshaller](https://learn.microsoft.com/dotnet/api/system.runtime.interopservices.icustommarshaler?view=net-6.0) as type parameter in order to use it for marshalling elements.\r\nSo what is the good way to work with Null terminated array? If this behaviors is not currently handled by .NET ContiguousCollectionMarshaller it should be interesting to handle this case.\r\nHere an example of method with a null terminated array of string I need to marshal, https://github.com/libimobiledevice/libimobiledevice/blob/6fc41f57fc607df9b07446ca45bdf754225c9bd9/include/libimobiledevice/afc.h#L147-L158 Here on this `afc_read_directory` method the `directory_information` parameter is a null terminated array of strings with no extra information for size. So, to treat it we need to loop until null pointer.\r\nThank you in advance for your answers.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYqvmgQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5iPD5B",
                                           "createdAt":  "2023-07-24T15:16:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nHow to implement a marshalller for a null terminated contiguous collection on .NET 7 using [LibraryImport](https://learn.microsoft.com/dotnet/standard/native-interop/pinvoke-source-generation) and [ContiguousCollectionMarshallerAttribute](https://learn.microsoft.com/dotnet/api/system.runtime.interopservices.marshalling.contiguouscollectionmarshallerattribute?view=net-7.0) ? I currently work on a wrapper around [libimobiledevice](https://libimobiledevice.org called [MobileDeviceSharp](https://github.com/mveril/MobileDeviceSharp) the aim of this project is to implement a fully object-oriented wrapper around this C library in order to work with it as a standard .NET way. For many collections returned by the C library we don\u0027t have any out parameter to know the size of the returned collection. The count is intended to be determined at runtime using the null terminated beaviour of the returned collection exactly like the string marshaller do for strings. So, I cannot use [CountElementName](https://learn.microsoft.com/dotnet/api/system.runtime.interopservices.marshalling.marshalusingattribute.countelementname?view=net-7.0] For DllImport I found a workaround using generic [ICustomMarshaller](https://learn.microsoft.com/dotnet/api/system.runtime.interopservices.icustommarshaler?view=net-6.0) that take another  [ICustomMarshaller](https://learn.microsoft.com/dotnet/api/system.runtime.interopservices.icustommarshaler?view=net-6.0) as type parameter in order to use it for marshalling elements.\r\nSo what is the good way to work with Null terminated array? If this behaviors is not currently handled by .NET ContiguousCollectionMarshaller it should be interesting to handle this case.\r\nHere an example of method with a null terminated array of string I need to marshal, https://github.com/libimobiledevice/libimobiledevice/blob/6fc41f57fc607df9b07446ca45bdf754225c9bd9/include/libimobiledevice/afc.h#L147-L158 Here on this `afc_read_directory` method the `directory_information` parameter is a null terminated array of strings with no extra information for size. So, to treat it we need to loop until null pointer.\r\nThank you by advance for your answers.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003emveril\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-07-24T15:16:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iYKu9",
                                           "createdAt":  "2023-07-25T20:23:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "@mveril, the `ContiguousCollectionMarshaller` shape doesn\u0027t support this shape of a collection (null terminated instead of a specified length). I\u0027d recommend writing a non-collection marshaller that handles collections of your particular element and manually marshalling the elements. I know it isn\u0027t as smooth of a solution, but it\u0027s the best solution I can offer today.\r\n\r\nWe\u0027ll investigate implementing a marshaller model for this in the future, but I\u0027m not sure when we\u0027ll get to it.",
                                           "updatedAt":  "2023-07-25T20:23:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iq-aB",
                                           "createdAt":  "2023-07-28T10:10:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mveril",
                                           "body":  "Hello @jkoritzinsky thanks for your reponse.\r\nOk I will do ad hoc CustomMarshaller for it.\r\nI see two possible solutions for this issue for a future version of .NET.\r\n\r\n1. By analogy with\r\n\r\n``` csharp\r\n public static TNative AllocateContainerForUnmanagedElements(TCollection managed, Span\u003cTOther\u003e buffer, out int numElements);\r\n```\r\nand its statefull equivalent we can think about a \r\n``` csharp\r\npublic static TCollection AllocateContainerForManagedElements(TNative unmanaged, out int numElements);\r\n```\r\nThat give the number of elements to the pinvoke code. to allow to marshal ContiguousCollection with specific counting rules. \r\n\r\n2. A specific `NullTerminatedCountiguousCollectionMarshallerAttribute` attribute with the counting fully handled by the pinvoke source generator.\r\n\r\nIn each of these solutions`ConstantElementCount` or `CountElementName` should not be set.",
                                           "updatedAt":  "2023-07-28T10:11:15Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "How to marshall null terminated array on .NET 7 using LibraryImport and ContiguousCollectionMarshaller",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/89462",
        "createdAt":  "2023-07-25T19:00:57Z",
        "number":  89462,
        "author":  "jtschuster",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-11-07T16:14:16Z",
        "body":  "In order to be able to free each element in an array, the generated code should store stateful element marshallers in an array to free them in the AssignOut stage after marshalling.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOaztiow==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5iXrw_",
                                           "createdAt":  "2023-07-25T19:01:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nnull\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejtschuster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-07-25T19:01:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iXy2M",
                                           "createdAt":  "2023-07-25T19:22:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "We don’t support stateful marshallers for element marshallers, so this is out of scope for now. Marking this as Future",
                                           "updatedAt":  "2023-07-25T19:22:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iXzz1",
                                           "createdAt":  "2023-07-25T19:25:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jtschuster",
                                           "body":  "\u003e We don’t support stateful marshallers for element marshallers\r\n\r\nI don\u0027t think we warn for these, I\u0027ll make an issue to add a warning",
                                           "updatedAt":  "2023-07-25T19:25:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iX1F3",
                                           "createdAt":  "2023-07-25T19:30:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODBxMxg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jtschuster",
                                                                               "createdAt":  "2023-07-25T19:30:35Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "We warn in the analyzer for CustomMarshallerAttribute usage, which isn\u0027t referenced in the source generator tests",
                                           "updatedAt":  "2023-07-25T19:30:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5rO2Kj",
                                           "createdAt":  "2023-11-07T16:12:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jwosty",
                                           "body":  "Is there an issue tracking stateful marshaling of collection elements? Or is this that issue now?\r\n\r\nI would really like this. Without this, I currently have to resort to manual boilerplate to pass `SafeHandle[]` and `Span\u003cSafeHandle\u003e` to native code.",
                                           "updatedAt":  "2023-11-07T16:14:16Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "Track stateful marshallers for each element in unmanaged to managed stubs",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/89463",
        "createdAt":  "2023-07-25T19:01:02Z",
        "number":  89463,
        "author":  "jtschuster",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-08-19T15:42:06Z",
        "body":  "Marshal structs (which managed the out value) should be freed in the catch block if the method will return failure. Unmarshal structs (which manage the in value) should free in the assign out stage.\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYmCS7w==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5iXrz1",
                                           "createdAt":  "2023-07-25T19:01:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nnull\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejtschuster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-07-25T19:01:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iYJLv",
                                           "createdAt":  "2023-07-25T20:18:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "Using different stateful marshaller instances in the `UnmanagedToManagedRef` case concerns me a little bit, as that\u0027s a significant change in design. In particular, sometimes it\u0027s important to have the same unmanaged value returned (like a pointer to an object) if the managed object hasn\u0027t changed. The inverse scenario (`ManagedToUnmanagedRef`) definitely has this case for `SafeHandle`s. I think we should (if possible) require marshaller authors to handle this scenario for `UnmanagedToManagedRef`-mode marshallers instead of using separate instances for the `in` and `out`.\r\n\r\nI could see a use case in saying \"If there is no `*Ref` marshaller defined and no default, we will use the `*In` and `*Out` marshallers to provide the marshalling and handle the lifetime,\" but that would definitely be .NET 9 work.",
                                           "updatedAt":  "2023-07-25T20:18:47Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Different marshaller structs should be used for unmarshalling and marshalling elements in UnmanagedToManaged stubs",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/89483",
        "createdAt":  "2023-07-25T23:40:39Z",
        "number":  89483,
        "author":  "jtschuster",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-02T22:04:12Z",
        "body":  "",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYmPxyw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5iY_HL",
                                           "createdAt":  "2023-07-25T23:51:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nnull\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejtschuster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `untriaged`, `source-generator`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-07-25T23:51:05Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "ComInterfaceGenerator should generate a free of the local variable in the catch clause of unmanagedToManaged stubs, and free the old parameter value in the AssignOut stage",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "source-generator"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/89514",
        "createdAt":  "2023-07-26T17:34:09Z",
        "number":  89514,
        "author":  "jtschuster",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-28T06:11:31Z",
        "body":  "The code fixer for the ContiguousCollectionMarshaller automatically filled in GetManagedValuesDestination and GetManagedValuesSource as returnin Span\u003cnint\u003e. The element marshaller I was using also returned nint for the native type, so the generated code just copied the ManagedValuesSource span to the UnmanagedValuesDestination, which was unexpected. I would expect the default should return a Span\u003cT\u003e if the parameter type is Collection\u003cT\u003e.\r\n\r\nThis is the output:\r\n```C#\r\n    [NativeMarshalling(typeof(StatelessCollectionMarshaller\u003c,\u003e))]\r\n    internal class StatelessCollection\u003cT\u003e\r\n    {\r\n    }\r\n\r\n    [ContiguousCollectionMarshaller]\r\n    [CustomMarshaller(typeof(StatelessCollection\u003c\u003e), MarshalMode.Default, typeof(StatelessCollectionMarshaller\u003c,\u003e.Default))]\r\n    internal static unsafe class StatelessCollectionMarshaller\u003cT, TUnmanagedElement\u003e where TUnmanagedElement : unmanaged\r\n    {\r\n        internal static class Default\r\n        {\r\n            public static nint AllocateContainerForUnmanagedElements(StatelessCollection\u003cT\u003e managed, out int numElements)\r\n            {\r\n                throw new System.NotImplementedException();\r\n            }\r\n\r\n            public static StatelessCollection\u003cT\u003e AllocateContainerForManagedElements(nint unmanaged, int numElements)\r\n            {\r\n                throw new System.NotImplementedException();\r\n            }\r\n\r\n            // ??\r\n            public static System.ReadOnlySpan\u003cnint\u003e GetManagedValuesSource(StatelessCollection\u003cT\u003e managed)\r\n            {\r\n                throw new System.NotImplementedException();\r\n            }\r\n\r\n            public static System.Span\u003cTUnmanagedElement\u003e GetUnmanagedValuesDestination(nint unmanaged, int numElements)\r\n            {\r\n                throw new System.NotImplementedException();\r\n            }\r\n\r\n            public static System.ReadOnlySpan\u003cTUnmanagedElement\u003e GetUnmanagedValuesSource(nint unmanaged, int numElements)\r\n            {\r\n                throw new System.NotImplementedException();\r\n            }\r\n            // ??\r\n            public static System.Span\u003cnint\u003e GetManagedValuesDestination(StatelessCollection\u003cT\u003e managed)\r\n            {\r\n                throw new System.NotImplementedException();\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\nWhen I expected: \r\n```C#\r\n    [ContiguousCollectionMarshaller]\r\n    [CustomMarshaller(typeof(StatelessCollection\u003c\u003e), MarshalMode.Default, typeof(StatelessCollectionMarshaller\u003c,\u003e.Default))]\r\n    internal static unsafe class StatelessCollectionMarshaller\u003cT, TUnmanagedElement\u003e where TUnmanagedElement : unmanaged\r\n    {\r\n        internal static class Default\r\n        {\r\n            ...\r\n            public static System.ReadOnlySpan\u003cT\u003e GetManagedValuesSource(StatelessCollection\u003cT\u003e managed)\r\n            {\r\n                throw new System.NotImplementedException();\r\n            }\r\n\r\n            public static System.Span\u003cT\u003e GetManagedValuesDestination(StatelessCollection\u003cT\u003e managed)\r\n            {\r\n                throw new System.NotImplementedException();\r\n            }\r\n        }\r\n    }\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYnxzdQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5iexNE",
                                           "createdAt":  "2023-07-26T17:34:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThe code fixer for the ContiguousCollectionMarshaller automatically filled in GetManagedValuesDestination and GetManagedValuesSource as returnin Span\u003cnint\u003e. The element marshaller I was using also returned nint for the native type, so the generated code just copied the ManagedValuesSource span to the UnmanagedValuesDestination, which was unexpected. I would expect the default should return a Span\u003cT\u003e if the parameter type is Collection\u003cT\u003e.\r\n\r\n\r\n```C#\r\n    [NativeMarshalling(typeof(StatelessCollectionMarshaller\u003c,\u003e))]\r\n    internal class StatelessCollection\u003cT\u003e\r\n    {\r\n    }\r\n\r\n    [ContiguousCollectionMarshaller]\r\n    [CustomMarshaller(typeof(StatelessCollection\u003c\u003e), MarshalMode.Default, typeof(StatelessCollectionMarshaller\u003c,\u003e.Default))]\r\n    internal static unsafe class StatelessCollectionMarshaller\u003cT, TUnmanagedElement\u003e where TUnmanagedElement : unmanaged\r\n    {\r\n        internal static class Default\r\n        {\r\n            public static nint AllocateContainerForUnmanagedElements(StatelessCollection\u003cT\u003e managed, out int numElements)\r\n            {\r\n                throw new System.NotImplementedException();\r\n            }\r\n\r\n            public static StatelessCollection\u003cT\u003e AllocateContainerForManagedElements(nint unmanaged, int numElements)\r\n            {\r\n                throw new System.NotImplementedException();\r\n            }\r\n\r\n            public static System.ReadOnlySpan\u003cnint\u003e GetManagedValuesSource(StatelessCollection\u003cT\u003e managed)\r\n            {\r\n                throw new System.NotImplementedException();\r\n            }\r\n\r\n            public static System.Span\u003cTUnmanagedElement\u003e GetUnmanagedValuesDestination(nint unmanaged, int numElements)\r\n            {\r\n                throw new System.NotImplementedException();\r\n            }\r\n\r\n            public static System.ReadOnlySpan\u003cTUnmanagedElement\u003e GetUnmanagedValuesSource(nint unmanaged, int numElements)\r\n            {\r\n                throw new System.NotImplementedException();\r\n            }\r\n\r\n            public static System.Span\u003cnint\u003e GetManagedValuesDestination(StatelessCollection\u003cT\u003e managed)\r\n            {\r\n                throw new System.NotImplementedException();\r\n            }\r\n        }\r\n    }\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejtschuster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `code-fixer`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-07-26T17:34:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ifHN1",
                                           "createdAt":  "2023-07-26T18:49:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "We can implement some heuristics here to guess the collection element type. For example, we could detect if the managed type implements `IEnumerable\u003cT\u003e` and use the `T` as the element type.",
                                           "updatedAt":  "2023-07-26T18:49:31Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "CollectionMarshaller code fixer provides implementation with Span\u003cnint\u003e for GetManagedValuesDestination and -Source",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "code-fixer"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/89866",
        "createdAt":  "2023-08-02T18:22:40Z",
        "number":  89866,
        "author":  "jtschuster",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-08-19T15:41:30Z",
        "body":  "No warning is issued when the custom marshaller uses different types as the native type in the marshalling methods. This leads to compilation errors in the generated code.\r\n\r\n```C#\r\n    [CustomMarshaller(typeof(StatelessFinallyType), MarshalMode.Default, typeof(StatelessFinallyTypeMarshaller))]\r\n    internal static class StatelessFinallyTypeMarshaller\r\n    {\r\n        public static int FreeCount { get; private set; }\r\n        public static StatelessFinallyNative ConvertToUnmanaged(StatelessFinallyType managed) =\u003e new StatelessFinallyNative() { i = managed.I };\r\n\r\n        public static StatelessFinallyType ConvertToManagedFinally(StatelessFinallyNative unmanaged) =\u003e new StatelessFinallyType { I = unmanaged.i };\r\n\r\n        // Should be StatelessFinallyNative, or all StatelessFinallyNative should be nint\r\n        public static void Free(nint unmanaged) =\u003e FreeCount++;\r\n    }\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYxtGiA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5jG0KQ",
                                           "createdAt":  "2023-08-02T18:22:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nNo warning is issued when the custom marshaller uses different types as the native type in the marshalling methods. This leads to compilation errors in the generated code.\r\n\r\n```C#\r\n    [CustomMarshaller(typeof(StatelessFinallyType), MarshalMode.Default, typeof(StatelessFinallyTypeMarshaller))]\r\n    internal static class StatelessFinallyTypeMarshaller\r\n    {\r\n        public static int FreeCount { get; private set; }\r\n        public static StatelessFinallyNative ConvertToUnmanaged(StatelessFinallyType managed) =\u003e new StatelessFinallyNative() { i = managed.I };\r\n\r\n        public static StatelessFinallyType ConvertToManagedFinally(StatelessFinallyNative unmanaged) =\u003e new StatelessFinallyType { I = unmanaged.i };\r\n\r\n        // Should be StatelessFinallyNative, or all StatelessFinallyNative should be nint\r\n        public static void Free(nint unmanaged) =\u003e FreeCount++;\r\n    }\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejtschuster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-08-02T18:22:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5jG0aI",
                                           "createdAt":  "2023-08-02T18:23:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODCiiSw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkoritzinsky",
                                                                               "createdAt":  "2023-08-02T20:08:53Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jtschuster",
                                           "body":  "This actually might be an issue of not using the Marshalling analyzer in ComInterfaceGenerator.Tests.",
                                           "updatedAt":  "2023-08-02T18:23:33Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Custom Marshaller analyzers don\u0027t warn when different native types are used for each marshalling method",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/90042",
        "createdAt":  "2023-08-04T18:31:32Z",
        "number":  90042,
        "author":  "jtschuster",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-25T21:47:23Z",
        "body":  "These definitions\r\n```C#\r\n// interface\r\n    [GeneratedComInterface]\r\n    [Guid(\"3BBB0C99-7D6C-4AD1-BE4C-ACB4C2127F02\")]\r\n    internal partial interface IStatelessPinnableCollectionBlittableElements\r\n    {\r\n        void Method(\r\n            [MarshalUsing(CountElementName = nameof(size))] StatelessPinnableCollection\u003cint\u003e p,\r\n            int size);\r\n    }\r\n\r\n// Marshaller\r\n        internal static class ManagedToUnmanaged\r\n        {\r\n            public static StatelessPinnableCollectionNative\u003cT\u003e AllocateContainerForUnmanagedElements(StatelessPinnableCollection\u003cT\u003e managed, out int numElements)\r\n            {\r\n                throw new NotImplementedException();\r\n            }\r\n\r\n            public static ReadOnlySpan\u003cT\u003e GetManagedValuesSource(StatelessPinnableCollection\u003cT\u003e managed)\r\n            {\r\n                throw new NotImplementedException();\r\n            }\r\n\r\n            public static Span\u003cTUnmanagedElement\u003e GetUnmanagedValuesDestination(StatelessPinnableCollectionNative\u003cT\u003e unmanaged, int numElements)\r\n            {\r\n                throw new NotImplementedException();\r\n            }\r\n\r\n            public static ref StatelessPinnableCollectionNative\u003cT\u003e GetPinnableReference(StatelessPinnableCollection\u003cT\u003e managed)\r\n            {\r\n                throw new NotImplementedException();\r\n            }\r\n\r\n            public static void Free(StatelessPinnableCollectionNative\u003cT\u003e unmanaged) =\u003e throw new NotImplementedException();\r\n        }\r\n```\r\nGenerate this method:\r\n```C#\r\n    void global::SharedTypes.ComInterfaces.IStatelessPinnableCollectionBlittableElements.Method(global::SharedTypes.ComInterfaces.StatelessPinnableCollection\u003cint\u003e p, int size)\r\n    {\r\n        var(__this, __vtable_native) = ((System.Runtime.InteropServices.Marshalling.IUnmanagedVirtualMethodTableProvider)this).GetVirtualMethodTableInfoForKey(typeof(global::SharedTypes.ComInterfaces.IStatelessPinnableCollectionBlittableElements));\r\n        int __invokeRetVal;\r\n        // Pin - Pin data in preparation for calling the P/Invoke.\r\n        fixed (void* __p_native = \u0026global::SharedTypes.ComInterfaces.StatelessPinnableCollectionMarshaller\u003cint, int\u003e.ManagedToUnmanaged.GetPinnableReference(p))\r\n        {\r\n            __invokeRetVal = ((delegate* unmanaged[MemberFunction]\u003cvoid*, global::SharedTypes.ComInterfaces.StatelessPinnableCollectionNative\u003cint\u003e, int, int\u003e )__vtable_native[3])(__this, (global::SharedTypes.ComInterfaces.StatelessPinnableCollectionNative\u003cint\u003e)__p_native, size);\r\n        }\r\n\r\n        // NotifyForSuccessfulInvoke - Keep alive any managed objects that need to stay alive across the call.\r\n        System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(__invokeRetVal);\r\n        System.GC.KeepAlive(this);\r\n    }\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOY1A-kA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5jTYH5",
                                           "createdAt":  "2023-08-04T18:31:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThese definitions\r\n```C#\r\n// interface\r\n    [GeneratedComInterface]\r\n    [Guid(\"3BBB0C99-7D6C-4AD1-BE4C-ACB4C2127F02\")]\r\n    internal partial interface IStatelessPinnableCollectionBlittableElements\r\n    {\r\n        void Method(\r\n            [MarshalUsing(CountElementName = nameof(size))] StatelessPinnableCollection\u003cint\u003e p,\r\n            int size);\r\n    }\r\n\r\n// Marshaller\r\n        internal static class ManagedToUnmanaged\r\n        {\r\n            public static StatelessPinnableCollectionNative\u003cT\u003e AllocateContainerForUnmanagedElements(StatelessPinnableCollection\u003cT\u003e managed, out int numElements)\r\n            {\r\n                throw new NotImplementedException();\r\n            }\r\n\r\n            public static ReadOnlySpan\u003cT\u003e GetManagedValuesSource(StatelessPinnableCollection\u003cT\u003e managed)\r\n            {\r\n                throw new NotImplementedException();\r\n            }\r\n\r\n            public static Span\u003cTUnmanagedElement\u003e GetUnmanagedValuesDestination(StatelessPinnableCollectionNative\u003cT\u003e unmanaged, int numElements)\r\n            {\r\n                throw new NotImplementedException();\r\n            }\r\n\r\n            public static ref StatelessPinnableCollectionNative\u003cT\u003e GetPinnableReference(StatelessPinnableCollection\u003cT\u003e managed)\r\n            {\r\n                throw new NotImplementedException();\r\n            }\r\n\r\n            public static void Free(StatelessPinnableCollectionNative\u003cT\u003e unmanaged) =\u003e throw new NotImplementedException();\r\n        }\r\n```\r\nGenerate this method:\r\n```C#\r\n    void global::SharedTypes.ComInterfaces.IStatelessPinnableCollectionBlittableElements.Method(global::SharedTypes.ComInterfaces.StatelessPinnableCollection\u003cint\u003e p, int size)\r\n    {\r\n        var(__this, __vtable_native) = ((System.Runtime.InteropServices.Marshalling.IUnmanagedVirtualMethodTableProvider)this).GetVirtualMethodTableInfoForKey(typeof(global::SharedTypes.ComInterfaces.IStatelessPinnableCollectionBlittableElements));\r\n        int __invokeRetVal;\r\n        // Pin - Pin data in preparation for calling the P/Invoke.\r\n        fixed (void* __p_native = \u0026global::SharedTypes.ComInterfaces.StatelessPinnableCollectionMarshaller\u003cint, int\u003e.ManagedToUnmanaged.GetPinnableReference(p))\r\n        {\r\n            __invokeRetVal = ((delegate* unmanaged[MemberFunction]\u003cvoid*, global::SharedTypes.ComInterfaces.StatelessPinnableCollectionNative\u003cint\u003e, int, int\u003e )__vtable_native[3])(__this, (global::SharedTypes.ComInterfaces.StatelessPinnableCollectionNative\u003cint\u003e)__p_native, size);\r\n        }\r\n\r\n        // NotifyForSuccessfulInvoke - Keep alive any managed objects that need to stay alive across the call.\r\n        System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(__invokeRetVal);\r\n        System.GC.KeepAlive(this);\r\n    }\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejtschuster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-08-04T18:31:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5jUD6Q",
                                           "createdAt":  "2023-08-04T21:35:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "We used to have coverage for this in the `CustomMarshallerAttributeAnalyzer`, by requiring that the marshaller type must be explicitly castable-to from `void*`, but it looks like it was lost during the marshaller shape rewrite before .NET 7. I\u0027ll take a look at fixing this and making that diagnostic a warning instead of an error (now that we\u0027ve shipped for almost a year with it).",
                                           "updatedAt":  "2023-08-04T21:35:38Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "ManagedToUnmanaged stubs always pin the GetPinnableReference as `void*`, which might not be castable to TNative",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/90112",
        "createdAt":  "2023-08-07T20:31:06Z",
        "number":  90112,
        "author":  "jtschuster",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-08-19T15:42:23Z",
        "body":  "These lines make it seem like there should be some kind of warning.\r\n\r\nhttps://github.com/dotnet/runtime/blob/dd43febd533ff740a5941701239bac904279d9f8/src/libraries/System.Runtime.InteropServices/gen/Microsoft.Interop.SourceGeneration/ManualTypeMarshallingHelper.cs#L216-L225\r\n\r\nThese lines require that the non-caller-allocated-buffer method is present for bidirectional.\r\n\r\nhttps://github.com/dotnet/runtime/blob/dd43febd533ff740a5941701239bac904279d9f8/src/libraries/System.Runtime.InteropServices/gen/Microsoft.Interop.SourceGeneration/ManualTypeMarshallingHelper.cs#L549-L551",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOY3XkHg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5jc-Ug",
                                           "createdAt":  "2023-08-07T20:31:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThese lines make it seem like there should be some kind of warning.\r\n\r\nhttps://github.com/dotnet/runtime/blob/dd43febd533ff740a5941701239bac904279d9f8/src/libraries/System.Runtime.InteropServices/gen/Microsoft.Interop.SourceGeneration/ManualTypeMarshallingHelper.cs#L216-L225\r\n\r\nThese lines require that the non-caller-allocated-buffer method is present for bidirectional.\r\n\r\nhttps://github.com/dotnet/runtime/blob/dd43febd533ff740a5941701239bac904279d9f8/src/libraries/System.Runtime.InteropServices/gen/Microsoft.Interop.SourceGeneration/ManualTypeMarshallingHelper.cs#L549-L551\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejtschuster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e9.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-08-07T20:31:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5jdVO8",
                                           "createdAt":  "2023-08-07T22:00:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "Looks like this is another case in the analyzer that got lost in the refactor. We used to warn for this case. I think it\u0027s too late in .NET 8 to add the warning given that the snap is tomorrow and I probably won\u0027t get to it today, but we can add a notice in 8 and make it a warning in 9.",
                                           "updatedAt":  "2023-08-07T22:00:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5jdWWX",
                                           "createdAt":  "2023-08-07T22:06:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "Actually, it looks like the stateless and stateful code should handle this case as long as the marshaller isn\u0027t `MarshalMode.Default`, at least at usage time. We should probably add a check in the analyzer as well.\r\n\r\nhttps://github.com/dotnet/runtime/blob/dd43febd533ff740a5941701239bac904279d9f8/src/libraries/System.Runtime.InteropServices/gen/Microsoft.Interop.SourceGeneration/ManualTypeMarshallingHelper.cs#L503-L505\r\n\r\nhttps://github.com/dotnet/runtime/blob/dd43febd533ff740a5941701239bac904279d9f8/src/libraries/System.Runtime.InteropServices/gen/Microsoft.Interop.SourceGeneration/ManualTypeMarshallingHelper.cs#L583-L585",
                                           "updatedAt":  "2023-08-07T22:06:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5jdeQe",
                                           "createdAt":  "2023-08-07T22:46:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jtschuster",
                                           "body":  "\u003e Actually, it looks like the stateless and stateful code should handle this case as long as the marshaller isn\u0027t `MarshalMode.Default`, at least at usage time. We should probably add a check in the analyzer as well.\r\n\r\nYes, sorry, I forgot to clarify, it will warn when someone tries to use a ref parameter, but everything else indicates that the marshaller should be okay. There\u0027s still a `[CustomMarshaller(typeof(Managed), MarshalMode.XRef, typeof(Bidirectional))]` with no warnings, but when used in a method the analyzer says there isn\u0027t a marshaller for `MarshalMode.XRef`.",
                                           "updatedAt":  "2023-08-07T22:47:03Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Custom Marshaller analyzers don\u0027t warn that bidirectional marshallers require a non-caller allocated buffer method, but ComInterfaceGenerator requires it",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/90259",
        "createdAt":  "2023-08-09T17:40:20Z",
        "number":  90259,
        "author":  "jtschuster",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-08-19T15:41:39Z",
        "body":  "The following code should probably warn that the MarshalUsing.CountElementName is unnecessary if the marshaller is not a collection marshaller.\r\n\r\n```C#\r\ninterface IFoo\r\n{\r\n  void Method([MarshalUsing(CountElementName=nameof(size))] CustomType p, int size);\r\n}\r\n```\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOY6a0bA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5jprRs",
                                           "createdAt":  "2023-08-09T17:40:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThe following code should probably warn that the MarshalUsing.CountElementName is unnecessary if the marshaller is not a collection marshaller.\r\n\r\n```C#\r\ninterface IFoo\r\n{\r\n  void Method([MarshalUsing(CountElementName=nameof(size))] CustomType p, int size);\r\n}\r\n```\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejtschuster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e9.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-08-09T17:40:28Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Custom Marshaller analyzers don\u0027t warn when MarshalUsing.CountElementName is set on a parameter that isn\u0027t a collection",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/90271",
        "createdAt":  "2023-08-09T20:59:51Z",
        "number":  90271,
        "author":  "jtschuster",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-08-19T15:41:46Z",
        "body":  "The analyzers will warn if the marshaller uses MarshalMode.ElementX, but will allow a statefully marshalled type with Default marshalling be an element of a collection parameter.\r\n\r\n```C#\r\ninterface IFoo\r\n{\r\n  // Below should warn\r\n  void Method(StatelessCollection\u003cStatefulDefaultType\u003e param, int size);\r\n}\r\n\r\n    [NativeMarshalling(typeof(StatefulDefaultMarshaller))]\r\n    internal class StatefulDefaultType\r\n    {\r\n    }\r\n\r\n    [CustomMarshaller(typeof(StatefulDefaultType), MarshalMode.Default, typeof(StatefulDefaultMarshaller))]\r\n    internal struct StatefulDefaultMarshaller\r\n    {\r\n        public void FromManaged(StatefulDefaultType managed)\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public nint ToUnmanaged()\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public void FromUnmanaged(nint unmanaged)\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public StatefulDefaultType ToManaged()\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public void Free()\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n    }\r\n\r\n    [NativeMarshalling(typeof(StatelessCollectionMarshaller\u003c,\u003e))]\r\n    internal class StatelessCollection\u003cT\u003e\r\n    {\r\n    }\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOY6rc3g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5jqtze",
                                           "createdAt":  "2023-08-09T20:59:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThe analyzers will warn if the marshaller uses MarshalMode.ElementX, but will allow a statefully marshalled type with Default marshalling be an element of a collection parameter.\r\n\r\n```C#\r\ninterface IFoo\r\n{\r\n  // Below should warn\r\n  void Method(StatelessCollection\u003cStatefulDefaultType\u003e param, int size);\r\n}\r\n\r\n    [NativeMarshalling(typeof(StatefulDefaultMarshaller))]\r\n    internal class StatefulDefaultType\r\n    {\r\n    }\r\n\r\n    [CustomMarshaller(typeof(StatefulDefaultType), MarshalMode.Default, typeof(StatefulDefaultMarshaller))]\r\n    internal struct StatefulDefaultMarshaller\r\n    {\r\n        public void FromManaged(StatefulDefaultType managed)\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public nint ToUnmanaged()\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public void FromUnmanaged(nint unmanaged)\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public StatefulDefaultType ToManaged()\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public void Free()\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n    }\r\n\r\n    [NativeMarshalling(typeof(StatelessCollectionMarshaller\u003c,\u003e))]\r\n    internal class StatelessCollection\u003cT\u003e\r\n    {\r\n    }\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejtschuster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e9.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-08-09T20:59:56Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Custom Marshalling analyzers do not warn when an element uses a stateful marshaller with MarshalMode.Default",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/90618",
        "createdAt":  "2023-08-15T17:51:38Z",
        "number":  90618,
        "author":  "jtschuster",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-08-19T15:41:57Z",
        "body":  "Parameters with marshallers that have both ConvertToManaged and ConvertToManagedFinally will call both methods.\r\n\r\nExample:\r\n\r\n```C#\r\n    void global::SharedTypes.ComInterfaces.IMarshallerShapeTests.MethodOut(out global::SharedTypes.ComInterfaces.MarshalledType param)\r\n    {\r\n        var(__this, __vtable_native) = ((System.Runtime.InteropServices.Marshalling.IUnmanagedVirtualMethodTableProvider)this).GetVirtualMethodTableInfoForKey(typeof(global::SharedTypes.ComInterfaces.IMarshallerShapeTests));\r\n        bool __invokeSucceeded = default;\r\n        System.Runtime.CompilerServices.Unsafe.SkipInit(out param);\r\n        nint __param_native = default;\r\n        int __invokeRetVal = default;\r\n        try\r\n        {\r\n            {\r\n                __invokeRetVal = ((delegate* unmanaged[MemberFunction]\u003cvoid*, nint*, int\u003e )__vtable_native[5])(__this, \u0026__param_native);\r\n            }\r\n\r\n            // NotifyForSuccessfulInvoke - Keep alive any managed objects that need to stay alive across the call.\r\n            System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(__invokeRetVal);\r\n            __invokeSucceeded = true;\r\n            System.GC.KeepAlive(this);\r\n            // Unmarshal - Convert native data to managed data.\r\n            param = global::SharedTypes.ComInterfaces.PinnedMarshaller.ConvertToManaged(__param_native);\r\n        }\r\n        finally\r\n        {\r\n            if (__invokeSucceeded)\r\n            {\r\n                // GuaranteedUnmarshal - Convert native data to managed data even in the case of an exception during the non-cleanup phases.\r\n                param = global::SharedTypes.ComInterfaces.PinnedMarshaller.ConvertToManagedFinally(__param_native);\r\n                // CleanupCalleeAllocated - Perform cleanup of callee allocated resources.\r\n                global::SharedTypes.ComInterfaces.PinnedMarshaller.Free(__param_native);\r\n            }\r\n        }\r\n    }\r\n\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOZBnC6A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5kGcLo",
                                           "createdAt":  "2023-08-15T18:32:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nParameters with marshallers that have both ConvertToManaged and ConvertToManagedFinally will call both methods.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejtschuster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `source-generator`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e9.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-08-15T18:32:11Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "[ComInterfaceGenerator] Generated methods will call both ConvertToManaged and ConvertToManagedFinally if present",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "source-generator"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/90876",
        "createdAt":  "2023-08-21T16:47:09Z",
        "number":  90876,
        "author":  "jtschuster",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-08-19T15:44:41Z",
        "body":  "In particular, the differences of default / implicit [In] and [Out] behaviors.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOZIiwmg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5kiLCa",
                                           "createdAt":  "2023-08-21T16:47:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nIn particular, the differences of default / implicit [In] and [Out] behaviors.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejtschuster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`documentation`, `area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e8.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-08-21T16:47:14Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "ComInterfaceGenerator docs should be very clear about changed in marshalling behavior between built in COM",
        "labels":  [
                       "documentation",
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/92222",
        "createdAt":  "2023-09-18T14:19:16Z",
        "number":  92222,
        "author":  "Sergio0694",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-28T21:37:43Z",
        "body":  "### Description\r\n\r\nIt seems like there\u0027s no warning from the COM generator when declaring a P/Invoke returning a COM object through an interface that\u0027s using `ComInterfaceOptions.ManagedObjectWrapper`, despite the fact the marshalling will never possibly work.\r\n\r\ncc. @jkoritzinsky\r\n\r\n### Reproduction Steps\r\n\r\nPaste the following code and build:\r\n\r\n```csharp\r\npublic static partial class DXGI1_3\r\n{\r\n    [LibraryImport(\"dxgi\")]\r\n    public static partial void CreateDXGIFactory2(uint flags, in Guid riid, out IDXGIFactory6 ppFactory);\r\n}\r\n\r\n[Guid(\"C1B6694F-FF09-44A9-B03C-77900A0A1D17\")]\r\n[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\r\n[GeneratedComInterface(Options = ComInterfaceOptions.ManagedObjectWrapper)]\r\npublic partial interface IDXGIFactory6\r\n{\r\n}\r\n```\r\n\r\n### Expected behavior\r\n\r\nSome warning on the `[LibraryImport]` parameter, saying the interface is using invalid marshalling options.\r\n\r\n### Actual behavior\r\n\r\nNo warning, but the generated code will just never work.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOZrrjiw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5muuOL",
                                           "createdAt":  "2023-09-18T14:19:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nIt seems like there\u0027s no warning from the COM generator when declaring a P/Invoke returning a COM object through an interface that\u0027s using `ComInterfaceOptions.ManagedObjectWrapper`, despite the fact the marshalling will never possibly work.\r\n\r\ncc. @jkoritzinsky\n\n### Reproduction Steps\n\nPaste the following code and build:\r\n\r\n```csharp\r\npublic static partial class DXGI1_3\r\n{\r\n    [LibraryImport(\"dxgi\")]\r\n    public static partial void CreateDXGIFactory2(uint flags, in Guid riid, out IDXGIFactory6 ppFactory);\r\n}\r\n\r\n[Guid(\"C1B6694F-FF09-44A9-B03C-77900A0A1D17\")]\r\n[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\r\n[GeneratedComInterface(Options = ComInterfaceOptions.ManagedObjectWrapper)]\r\npublic partial interface IFoo\r\n{\r\n}\r\n```\n\n### Expected behavior\n\nSome warning on the `[LibraryImport]` parameter, saying the interface is using invalid marshalling options.\n\n### Actual behavior\n\nNo warning, but the generated code will just never work.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eSergio0694\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-09-18T14:19:23Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "No warning for [LibraryImport] returning a [GeneratedComInterface] with CCW options",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "source-generator"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/92291",
        "createdAt":  "2023-09-19T17:59:11Z",
        "number":  92291,
        "author":  "Sergio0694",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-08-19T15:47:32Z",
        "body":  "### Description\r\n\r\nI\u0027ve been playing around with the COM generator, and specifically with `[GeneratedComInterface]`, and noticed that after toggling the options for a bit, you can see the generated code in the output file being incorrect. It seems like the internal state for the various parts of the generated tree get \"out of sync\", so eg. you can end up with an RCW having a vtable for ABI methods, which shouldn\u0027t be there, or a CCW not having a vtable at all.\r\n\r\ncc. @jkoritzinsky\r\n\r\n### Reproduction Steps\r\n\r\n- Create a new project\r\n- Add this interface (but I think any would do the same):\r\n\r\n```csharp\r\n[Guid(\"C1B6694F-FF09-44A9-B03C-77900A0A1D17\")]\r\n[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\r\n[GeneratedComInterface]\r\npublic partial interface IFoo\r\n{\r\n    void Bar();\r\n}\r\n```\r\n\r\n- Open the generated file in split screen in VS\r\n- Change the options to RCW only, CCW only, back and forth for a while\r\n- You should eventually see the generated code being invalid\r\n\r\n### Expected behavior\r\n\r\nThe code should just be the one you\u0027d expect from the options you\u0027re setting.\r\n\r\n### Actual behavior\r\n\r\nI noticed two examples of it breaking.\r\n\r\n**Default options, but missing vtable**\r\n\r\n![image](https://github.com/dotnet/runtime/assets/10199417/87a9cb5f-dffc-417b-91ec-b9b46667fd2f)\r\n\r\n**RCW option, but CCW vtable still being constructed (but the methods don\u0027t exist)**\r\n\r\n![image](https://github.com/dotnet/runtime/assets/10199417/c3f73793-ec38-402c-8876-24fa8877f535)\r\n\r\n![image](https://github.com/dotnet/runtime/assets/10199417/6d3c13b9-b0ed-47a5-a0a1-2e4bee7775fe)\r\n\r\n### Regression?\r\n\r\nNo, this is all new stuff in .NET 8.\r\n\r\n### Configuration\r\n\r\n- VS 17.8.0 Preview 2.0\r\n- Roslyn 4.8.0-2.23429.7 (44555193)",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOZuSDdA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5m5IN0",
                                           "createdAt":  "2023-09-19T18:12:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\nI\u0027ve been playing around with the COM generator, and specifically with `[GeneratedComInterface]`, and noticed that after toggling the options for a bit, you can see the generated code in the output file being incorrect. It seems like the internal state for the various parts of the generated tree get \"out of sync\", so eg. you can end up with an RCW having a vtable for ABI methods, which shouldn\u0027t be there, or a CCW not having a vtable at all.\r\n\r\ncc. @jkoritzinsky\r\n\r\n### Reproduction Steps\r\n\r\n- Create a new project\r\n- Add this interface (but I think any would do the same):\r\n\r\n```csharp\r\n[Guid(\"C1B6694F-FF09-44A9-B03C-77900A0A1D17\")]\r\n[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\r\n[GeneratedComInterface]\r\npublic partial interface IFoo\r\n{\r\n    void Bar();\r\n}\r\n```\r\n\r\n- Open the generated file in split screen in VS\r\n- Change the options to RCW only, CCW only, back and forth for a while\r\n- You should eventually see the generated code being invalid\r\n\r\n### Expected behavior\r\n\r\nThe code should just be the one you\u0027d expect from the options you\u0027re setting.\r\n\r\n### Actual behavior\r\n\r\nI noticed two examples of it breaking.\r\n\r\n**Default options, but missing vtable**\r\n\r\n![image](https://github.com/dotnet/runtime/assets/10199417/87a9cb5f-dffc-417b-91ec-b9b46667fd2f)\r\n\r\n**RCW option, but CCW vtable still being constructed (but the methods don\u0027t exist)**\r\n\r\n![image](https://github.com/dotnet/runtime/assets/10199417/c3f73793-ec38-402c-8876-24fa8877f535)\r\n\r\n![image](https://github.com/dotnet/runtime/assets/10199417/6d3c13b9-b0ed-47a5-a0a1-2e4bee7775fe)\r\n\r\n### Regression?\r\n\r\nNo, this is all new stuff in .NET 8.\r\n\r\n### Configuration\r\n\r\n- VS 17.8.0 Preview 2.0\r\n- Roslyn 4.8.0-2.23429.7 (44555193)\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eSergio0694\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `untriaged`, `needs-area-label`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-09-19T18:12:28Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "COM generator seemingly generates invalid code when toggling [GeneratedComInterface] options",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/92361",
        "createdAt":  "2023-09-20T18:12:31Z",
        "number":  92361,
        "author":  "bgrainger",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC0-l6Q==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ThadHouse",
                                            "createdAt":  "2024-01-05T08:58:56Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-08-06T21:37:31Z",
        "body":  "Many C APIs that process UTF-8 string data take parameters of the form `const char * text, const size_t textLength` and assume that the caller will provide the length of the string (in UTF-8 bytes).\r\n\r\nAn example is [`sqlite3_bind_text`](https://www.sqlite.org/capi3ref.html#sqlite3_bind_blob), which might be declared as:\r\n\r\n```csharp\r\n// int sqlite3_bind_text(sqlite3_stmt*,int,const char*,int,void(*)(void*));\r\n\r\n[LibraryImport(\"sqlite3.dll\", StringMarshalling = StringMarshalling.Utf8)]\r\nprivate static partial int sqlite3_bind_text(IntPtr stmt, int index, string text, int textLength, IntPtr destructor);\r\n```\r\n\r\nWhen `[LibraryImport(\"X.dll\", StringMarshalling.Utf8)]` is used with a `string` parameter, the `string` is efficiently converted to UTF-8 bytes (by the generated marshalling code), but the length of the converted string is not available to the application (to pass as the `textLength` parameter).\r\n\r\nTo pass the byte length of the UTF-8 data passed to native code, the application either has to:\r\n\r\n1. Call `Encoding.UTF8.GetByteCount(text)` and recalculate the length of the converted bytes (which is inefficient)\r\n2. Declare the parameter type as `Span\u003cbyte\u003e` and write custom marshalling code that performs the conversion in one pass (which is a lot of extra code to write and get right, and defeats the point of using `[LibraryImport]` to do the heavy lifting); example below\r\n3. Pass `-1` as the value for `textLength` if the C API supports that as a sentinel value meaning to calculate the length of `NULL`-terminated input with `strlen` or similar (which is inefficient)\r\n\r\nAn example of (2) might be:\r\n\r\n```csharp\r\nbyte[]? temp = null;\r\ntry\r\n{\r\n\tconst int maxStackLength = 1024;\r\n\tSpan\u003cbyte\u003e utf8Bytes = text.Length \u003c maxStackLength ? stackalloc byte[maxStackLength * 3] : (temp = ArrayPool\u003cbyte\u003e.Shared.Rent(text.Length * 3)).AsSpan();\r\n\tutf8Bytes = utf8Bytes[..Encoding.UTF8.GetBytes(text, utf8Bytes)];\r\n\r\n\treturn sqlite3_bind_text(_stmt, 0, utf8Bytes, utf8Bytes.Length, IntPtr.Zero);\r\n}\r\nfinally\r\n{\r\n\tif (temp is not null)\r\n\t\tArrayPool\u003cbyte\u003e.Shared.Return(temp);\r\n}\r\n\r\n[LibraryImport(\"sqlite3.dll\")]\r\nprivate static partial int sqlite3_bind_text(IntPtr stmt, int index, Span\u003cbyte\u003e text, int textLength, IntPtr destructor);\r\n```\r\n\r\nIt would be nice if there was some way in the native method signature (`MarshalAs.SizeParamIndex`??) to indicate that an integer parameter should be set to the value of `Encoding.UTF8.GetBytes` that is already calculated by `Utf8StringMarshaller.ManagedToUnmanagedIn.FromManaged` for an associated `string`.\r\n\r\nIt might then be odd that the `[LibraryImport]` native method signature declares an `int textLength` parameter that the application doesn\u0027t use (because the marshalling code always provides a value for it). Perhaps one might want to have an attribute on the `string` parameter that indicates it will be marshalled as two values: a pointer to data and its length. Such a thing could also be generally useful for marshalling `Span\u003cT\u003e` to native code. However, if changing the number of parameters of a native method is outside the design scope of `[LibraryImport]` then I can understand not wanting to do this.\r\n\r\nOne final reason to support this is that it could avoid subtle bugs:\r\n\r\n```csharp\r\n// !! WRONG Passes the number of UTF-16 code units, not UTF-8 bytes !!\r\nsqlite3_bind_text(_stmt, 0, text, text.Length, IntPtr.Zero);\r\n\r\n[LibraryImport(\"sqlite3.dll\", StringMarshalling = StringMarshalling.Utf8)]\r\nprivate static partial int sqlite3_bind_text(IntPtr stmt, int index, string text, int textLength, IntPtr destructor);\r\n```\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOcAgtZg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5nAn-t",
                                           "createdAt":  "2023-09-20T18:12:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nMany C APIs (that process UTF-8) string data take parameters of the form `const char * text, const size_t textLength` and assume that the caller will provide the length of the string (in UTF-8 bytes).\r\n\r\nAn example is [`sqlite3_bind_text`](https://www.sqlite.org/capi3ref.html#sqlite3_bind_blob), which might be declared as:\r\n\r\n```csharp\r\n// int sqlite3_bind_text(sqlite3_stmt*,int,const char*,int,void(*)(void*));\r\n\r\n[LibraryImport(\"sqlite3.dll\", StringMarshalling = StringMarshalling.Utf8)]\r\nprivate static partial int sqlite3_bind_text(IntPtr stmt, int index, string text, int textLength, IntPtr destructor);\r\n```\r\n\r\nWhen `[LibraryImport(\"cld2.dll\", StringMarshalling.Utf8)]` is used with a `string` parameter, the `string` is efficiently converted to UTF-8 bytes (by the generated marshalling code), but the length of the converted string is not available to the application (to pass as the `textLength` parameter).\r\n\r\nTo pass the byte length of the UTF-8 data passed to native code, the application either has to:\r\n\r\n1. Call `Encoding.UTF8.GetByteCount(text)` and recalculate the length of the converted bytes (which is inefficient)\r\n2. Declare the parameter type as `Span\u003cbyte\u003e` and write custom marshalling code that performs the conversion in one pass (which is a lot of extra code to write and get right, and defeats the point of using `[LibraryImport]` to do the heavy lifting); example below\r\n3. Pass `-1` as the value for `textLength` if the C API supports that as a sentinel value meaning to calculate the length of `NULL`-terminated input with `strlen` or similar (which is inefficient)\r\n\r\nAn example of (2) might be:\r\n\r\n```csharp\r\nbyte[]? temp = null;\r\ntry\r\n{\r\n\tconst int maxStackLength = 1024;\r\n\tSpan\u003cbyte\u003e utf8Bytes = text.Length \u003c maxStackLength ? stackalloc byte[maxStackLength * 3] : (temp = ArrayPool\u003cbyte\u003e.Shared.Rent(text.Length * 3)).AsSpan();\r\n\tutf8Bytes = utf8Bytes[..Encoding.UTF8.GetBytes(text, utf8Bytes)];\r\n\r\n\treturn sqlite3_bind_text(_stmt, 0, utf8Bytes, utf8Bytes.Length, IntPtr.Zero);\r\n}\r\nfinally\r\n{\r\n\tif (temp is not null)\r\n\t\tArrayPool\u003cbyte\u003e.Shared.Return(temp);\r\n}\r\n\r\n[LibraryImport(\"sqlite3.dll\")]\r\nprivate static partial int sqlite3_bind_text(IntPtr stmt, int index, Span\u003cbyte\u003e text, int textLength, IntPtr destructor);\r\n```\r\n\r\nIt would be nice if there was some way in the native method signature (`MarshalAs.SizeParamIndex`??) to indicate that an integer parameter should be set to the value of `Encoding.UTF8.GetBytes` that is already calculated by `Utf8StringMarshaller.ManagedToUnmanagedIn.FromManaged` for an associated `string`.\r\n\r\nIt might then be odd that the `[LibraryImport]` native method signature declares an `int textLength` parameter that the application doesn\u0027t use (because the marshalling code always provides a value for it). Perhaps one might want to have an attribute on the `string` parameter that indicates it will be marshalled as two values: a pointer to data and its length. Such a thing could also be generally useful for marshalling `Span\u003cT\u003e` to native code. However, if changing the number of parameters of a native method is outside the design scope of `[LibraryImport]` then I can understand not wanting to do this.\r\n\r\nOne final reason to support this is that it could avoid subtle bugs:\r\n\r\n```csharp\r\n// !! WRONG Passes the number of UTF-16 code units, not UTF-8 bytes !!\r\nsqlite3_bind_text(_stmt, 0, text, text.Length, IntPtr.Zero);\r\n\r\n[LibraryImport(\"sqlite3.dll\", StringMarshalling = StringMarshalling.Utf8)]\r\nprivate static partial int sqlite3_bind_text(IntPtr stmt, int index, string text, int textLength, IntPtr destructor);\r\n```\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ebgrainger\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-09-20T18:12:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5nAo1Y",
                                           "createdAt":  "2023-09-20T18:15:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODHVjyw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "bgrainger",
                                                                               "createdAt":  "2023-09-20T18:16:26Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "@jkoritzinsky This is similar to our thoughts on making `Span\u003cT\u003e` nice in the common pointer + length arguments convention.",
                                           "updatedAt":  "2023-09-20T18:15:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5nApVG",
                                           "createdAt":  "2023-09-20T18:17:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODHVpsQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "bgrainger",
                                                                               "createdAt":  "2023-09-20T18:18:20Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2023-09-20T18:34:42Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "I agree. @bgrainger thanks for filing this issue! Having external customer requests makes it easier to justify the work.",
                                           "updatedAt":  "2023-09-20T18:17:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5nAqVJ",
                                           "createdAt":  "2023-09-20T18:20:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bgrainger",
                                           "body":  "As an extension of the above idea, it would also be nice to marshal a single `ReadOnlySpan\u003cchar\u003e` parameter to native code as two values: a pointer to automatically-converted UTF-8 bytes, and the size of those converted bytes.",
                                           "updatedAt":  "2023-09-20T18:20:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5nDRLZ",
                                           "createdAt":  "2023-09-21T06:06:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "The major issue is that we can\u0027t declare the length parameter in managed signature, namely for its order in parameters and its type (`int` vs `nint`).\r\n\r\nA possible approach is introducing an attribute on the span/string parameter to specify and index and type.",
                                           "updatedAt":  "2023-09-21T06:06:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5uxGPV",
                                           "createdAt":  "2023-12-15T19:09:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bgrainger",
                                           "body":  "A somewhat related issue from earlier this year: https://github.com/dotnet/runtime/issues/81193.",
                                           "updatedAt":  "2023-12-15T19:09:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5v9R24",
                                           "createdAt":  "2024-01-05T08:59:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ThadHouse",
                                           "body":  "Adding my hand to upvote this. Our library has a mix of null terminated vs data and length string data (Yes bad design, but hard to change), and it\u0027d be nice to get automated marshalling for all of these cases.",
                                           "updatedAt":  "2024-01-05T08:59:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wCC1m",
                                           "createdAt":  "2024-01-06T07:39:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ThadHouse",
                                           "body":  "To add on, the return scenario would also be extremely nice to support. \r\n\r\nWe have the following native API.\r\n\r\n```\r\nchar* NT_GetEntryName(NT_Entry entry, size_t* name_len);\r\n```\r\n\r\nI have to do a very convoluted source generator to make this work, it\u0027d be nice to be built in supported.",
                                           "updatedAt":  "2024-01-06T08:06:32Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Allow `LibraryImport` `StringMarshalling.Utf8` to provide UTF-8 byte count to native code",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/92507",
        "createdAt":  "2023-09-22T21:47:22Z",
        "number":  92507,
        "author":  "jtschuster",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-25T21:43:35Z",
        "body":  "`TryGetOrCreateObjectForComInstanceInternal` will only unwrap if the `UniqueInstance` flag is not set, but this is not documented. UniqueComInterfaceMarshaller uses both flags, which makes it seem like the behavior of `UniqueInstance | Unwrap` is different than just `UniqueInstance`, but it is the same.\r\n\r\nSee the implementation of [TryGetOrCreateObjectForComInstanceInternal](https://github.com/dotnet/runtime/blob/8bcd03c650a85d523d542715e4e2543251f1dfa5/src/coreclr/vm/interoplibinterface_comwrappers.cpp#L863) and [UniqueComInterfaceMarshaller](https://github.com/dotnet/runtime/blob/8bcd03c650a85d523d542715e4e2543251f1dfa5/src/libraries/System.Runtime.InteropServices/src/System/Runtime/InteropServices/Marshalling/UniqueComInterfaceMarshaller.cs#L58)",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOZz051g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5nPTnW",
                                           "createdAt":  "2023-09-22T21:47:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n`TryGetOrCreateObjectForComInstanceInternal` will only unwrap if the `UniqueInstance` flag is not set, but this is not documented. UniqueComInterfaceMarshaller uses both flags, which makes it seem like the behavior of `UniqueInstance | Unwrap` is different than just `UniqueInstance`, but it is the same.\r\n\r\nSee the implementation of [TryGetOrCreateObjectForComInstanceInternal](https://github.com/dotnet/runtime/blob/8bcd03c650a85d523d542715e4e2543251f1dfa5/src/coreclr/vm/interoplibinterface_comwrappers.cpp#L863) and [UniqueComInterfaceMarshaller](https://github.com/dotnet/runtime/blob/8bcd03c650a85d523d542715e4e2543251f1dfa5/src/libraries/System.Runtime.InteropServices/src/System/Runtime/InteropServices/Marshalling/UniqueComInterfaceMarshaller.cs#L58)\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejtschuster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-09-22T21:47:28Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "CreateObjectFlags.UniqueInstance overrides CreateObjectFlags.Unwrap but this behavior is not documented",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/93423",
        "createdAt":  "2023-10-12T21:57:20Z",
        "number":  93423,
        "author":  "jtschuster",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-18T07:07:09Z",
        "body":  "The marshalling generators always use the length of the managed collection if it is only marshalled to unmanaged (and not unmarshalled to managed). However, during cleanup, they default to using 0 as the length when cleaning up an inner array of a 2D array. This causes the marshallers to not free any elements of the inner array on successful calls\r\n\r\nJagged arrays are technically an unsupported scenario, but this can cause a memory leak on successful calls to COM methods or LibraryImport methods. This issue is also present in .Net 7.\r\n\r\nThe fix for this would be to either require length parameters for parameters that are marshalled with marshallers that have a `Free` method (and use them -- we won\u0027t use them if they\u0027re provided now), or set length to `__arrayMarshaller.GetManagedValuesSource().Length` in these specific scenarios.\r\n\r\n@jkoritzinsky @AaronRobinsonMSFT Should we try to get a fix in 8? I think it\u0027s probably okay since the behavior has been here since 7 with no issues, but what are your thoughts?\r\n\r\n\r\nSource:\r\n```C#\r\nusing System.Runtime.InteropServices;\r\nusing System.Runtime.InteropServices.Marshalling;\r\n\r\npublic static partial class PInvoke\r\n{\r\n    [LibraryImport(\"asdfasdf\")]\r\n    public static partial int Method(\r\n        [MarshalUsing(typeof(MyClassMarshaller), ElementIndirectionDepth = 2)]\r\n        [MarshalUsing(CountElementName = nameof(length))]\r\n        [MarshalUsing(CountElementName = nameof(widths), ElementIndirectionDepth =1)]\r\n        MyClass[][] arg,\r\n        int length,\r\n        int[] widths);\r\n\r\n    public class MyClass\r\n    {\r\n    }\r\n\r\n    [CustomMarshaller(typeof(MyClass), MarshalMode.Default, typeof(MyClassMarshaller))]\r\n    public static class MyClassMarshaller\r\n    {\r\n        public static nint ConvertToUnmanaged(MyClass myClass) =\u003e throw null;\r\n        public static MyClass ConverToManaged(nint nativeValue) =\u003e throw null;\r\n        public static void Free(nint unmaanged) =\u003e throw null;\r\n\r\n    }\r\n}\r\n\r\n```\r\nGenerated:\r\n```C#\r\n    public static partial int Method(global::PInvoke.MyClass[][] arg, int length, int[] widths)\r\n    {\r\n        ...\r\n        finally {\r\n            ...\r\n            // CleanupCallerAllocated - Perform cleanup of caller allocated resources.\r\n            {\r\n                global::System.ReadOnlySpan\u003cglobal::System.IntPtr\u003e __arg_native__nativeSpan = __arg_native__marshaller.GetUnmanagedValuesDestination();\r\n                for (int __i0 = 0; __i0 \u003c __arg_native__lastIndexMarshalled; ++__i0)\r\n                {\r\n                    int __arg_native__nativeSpan____i0__numElements;\r\n                    global::System.Runtime.CompilerServices.Unsafe.SkipInit(out __arg_native__nativeSpan____i0__numElements);\r\n                    __arg_native__nativeSpan____i0__numElements = 0; // Issue\r\n                    {\r\n                        global::System.ReadOnlySpan\u003cnint\u003e __arg_native__nativeSpan____i0__nativeSpan = global::System.Runtime.InteropServices.Marshalling.ArrayMarshaller\u003cglobal::PInvoke.MyClass, nint\u003e.GetUnmanagedValuesDestination((nint*)__arg_native__nativeSpan[__i0], __arg_native__nativeSpan____i0__numElements);\r\n                        for (int __i1 = 0; __i1 \u003c __arg_native__nativeSpan____i0__nativeSpan.Length; ++__i1)\r\n                        {\r\n                            // Will never execute\r\n                            global::PInvoke.MyClassMarshaller.Free(__arg_native__nativeSpan____i0__nativeSpan[__i1]);\r\n                        }\r\n                    }\r\n\r\n                    __arg_native__nativeSpan____i0__numElements = 0;\r\n                    global::System.Runtime.InteropServices.Marshalling.ArrayMarshaller\u003cglobal::PInvoke.MyClass, nint\u003e.Free((nint*)__arg_native__nativeSpan[__i0]);\r\n                }\r\n            }\r\n\r\n            __arg_native__marshaller.Free();\r\n        }\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOaO3xNA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5o7fE0",
                                           "createdAt":  "2023-10-12T21:57:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThe marshalling generators always use the length of the managed collection if it is only marshalled to unmanaged (and not unmarshalled to managed). However, during cleanup, they default to using 0 as the length when cleaning up an inner array of a 2D array. This causes the marshallers to not free any elements of the inner array on successful calls\r\n\r\nJagged arrays are technically an unsupported scenario, but this can cause a memory leak on successful calls to COM methods or LibraryImport methods. This issue is also present in .Net 7.\r\n\r\nThe fix for this would be to either require length parameters for parameters that are marshalled with marshallers that have a `Free` method (and use them -- we won\u0027t use them if they\u0027re provided now), or set length to `__arrayMarshaller.GetManagedValuesSource().Length` in these specific scenarios.\r\n\r\n@jkoritzinsky @AaronRobinsonMSFT Should we try to get a fix in 8? I think it\u0027s probably okay since the behavior has been here since 7 with no issues, but what are your thoughts?\r\n\r\n\r\nSource:\r\n```C#\r\nusing System.Runtime.InteropServices;\r\nusing System.Runtime.InteropServices.Marshalling;\r\n\r\npublic static partial class PInvoke\r\n{\r\n    [LibraryImport(\"asdfasdf\")]\r\n    public static partial int Method(\r\n        [MarshalUsing(typeof(MyClassMarshaller), ElementIndirectionDepth = 2)]\r\n        [MarshalUsing(CountElementName = nameof(length))]\r\n        [MarshalUsing(CountElementName = nameof(widths), ElementIndirectionDepth =1)]\r\n        MyClass[][] arg,\r\n        int length,\r\n        int[] widths);\r\n\r\n    public class MyClass\r\n    {\r\n    }\r\n\r\n    [CustomMarshaller(typeof(MyClass), MarshalMode.Default, typeof(MyClassMarshaller))]\r\n    public static class MyClassMarshaller\r\n    {\r\n        public static nint ConvertToUnmanaged(MyClass myClass) =\u003e throw null;\r\n        public static MyClass ConverToManaged(nint nativeValue) =\u003e throw null;\r\n        public static void Free(nint unmaanged) =\u003e throw null;\r\n\r\n    }\r\n}\r\n\r\n```\r\nGenerated:\r\n```C#\r\n    public static partial int Method(global::PInvoke.MyClass[][] arg, int length, int[] widths)\r\n    {\r\n        ...\r\n        finally {\r\n            ...\r\n            // CleanupCallerAllocated - Perform cleanup of caller allocated resources.\r\n            {\r\n                global::System.ReadOnlySpan\u003cglobal::System.IntPtr\u003e __arg_native__nativeSpan = __arg_native__marshaller.GetUnmanagedValuesDestination();\r\n                for (int __i0 = 0; __i0 \u003c __arg_native__lastIndexMarshalled; ++__i0)\r\n                {\r\n                    int __arg_native__nativeSpan____i0__numElements;\r\n                    global::System.Runtime.CompilerServices.Unsafe.SkipInit(out __arg_native__nativeSpan____i0__numElements);\r\n                    __arg_native__nativeSpan____i0__numElements = 0; // Issue\r\n                    {\r\n                        global::System.ReadOnlySpan\u003cnint\u003e __arg_native__nativeSpan____i0__nativeSpan = global::System.Runtime.InteropServices.Marshalling.ArrayMarshaller\u003cglobal::PInvoke.MyClass, nint\u003e.GetUnmanagedValuesDestination((nint*)__arg_native__nativeSpan[__i0], __arg_native__nativeSpan____i0__numElements);\r\n                        for (int __i1 = 0; __i1 \u003c __arg_native__nativeSpan____i0__nativeSpan.Length; ++__i1)\r\n                        {\r\n                            // Will never execute\r\n                            global::PInvoke.MyClassMarshaller.Free(__arg_native__nativeSpan____i0__nativeSpan[__i1]);\r\n                        }\r\n                    }\r\n\r\n                    __arg_native__nativeSpan____i0__numElements = 0;\r\n                    global::System.Runtime.InteropServices.Marshalling.ArrayMarshaller\u003cglobal::PInvoke.MyClass, nint\u003e.Free((nint*)__arg_native__nativeSpan[__i0]);\r\n                }\r\n            }\r\n\r\n            __arg_native__marshaller.Free();\r\n        }\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejtschuster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003ejtschuster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `source-generator`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-10-12T21:57:26Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Marshalling generators use 0 as the length during cleanup for inner arrays of jagged 2D arrays that are [In] and ManagedToUnmanaged",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "disabled-test",
                       "source-generator"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/93431",
        "createdAt":  "2023-10-13T00:01:57Z",
        "number":  93431,
        "author":  "jtschuster",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-10-13T16:05:32Z",
        "body":  "For jagged arrays, the marshallers won\u0027t free a partially marshalled inner array because it doesn\u0027t consider the inner array to have completed marshalling until all inner elements are marshalled, and therefore assumes the inner array doesn\u0027t need to be freed. Usually this is the behavior we want, because most array elements can\u0027t be partially marshalled and won\u0027t need partial freeing, but inner arrays of jagged arrays may be partially marshalled.\r\n\r\nThis is an unsupported scenario and only occurs when marshalling fails.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOaO_yNw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5o7_I3",
                                           "createdAt":  "2023-10-13T00:02:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nFor jagged arrays, the marshallers won\u0027t free a partially marshalled inner array because it doesn\u0027t consider the inner array to have completed marshalling until all inner elements are marshalled, and therefore assumes the inner array doesn\u0027t need to be freed. Usually this is the behavior we want, because most array elements can\u0027t be partially marshalled and won\u0027t need partial freeing, but inner arrays of jagged arrays may be partially marshalled.\r\n\r\nThis is an unsupported scenario and only occurs when marshalling fails.\r\n\r\n\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejtschuster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003eFuture\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-10-13T00:02:06Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Marshalling generators LastIndexMarshalled tracking doesn\u0027t free partially marshalled inner array elements if marshalling fails",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "disabled-test"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/94079",
        "createdAt":  "2023-10-27T08:36:00Z",
        "number":  94079,
        "author":  "exoosh",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-08-19T15:36:21Z",
        "body":  "### Description\r\n\r\n`NativeLibrary.GetExport` throws a `System.ArgumentNullException` exception when passed in `IntPtr.Zero` to as `handle`.\r\n\r\nThis makes it impossible to get `RTLD_DEFAULT` behavior.\r\n\r\n### Reproduction Steps\r\n\r\nCompile and run this:\r\n\r\n```\r\nusing System.Runtime.InteropServices;\r\n\r\nNativeLibrary.GetExport(IntPtr.Zero, \"SomeFunction\");\r\n```\r\n\r\n### Expected behavior\r\n\r\nReturn function pointer or `IntPtr.Zero`.\r\n\r\n### Actual behavior\r\n\r\nThrows exception `System.ArgumentNullException`\r\n\r\n```\r\n$ dotnet run /home/username/getexport-issue/bin/Debug/net6.0/getexport.dll\r\nUnhandled exception. System.ArgumentNullException: Value cannot be null. (Parameter \u0027handle\u0027)\r\n   at System.Runtime.InteropServices.NativeLibrary.GetExport(IntPtr handle, String name)\r\n   at Program.\u003cMain\u003e$(String[] args) in /home/username/getexport-issue/Program.cs:line 3\r\n```\r\n\r\n### Regression?\r\n\r\nNo idea\r\n\r\n### Known Workarounds\r\n\r\nCall a `DllImport`-ed `dlsym()` directly with `IntPtr.Zero` for the `handle`.\r\n\r\nAs was pointed out in a comment here, [another workaround exists](https://github.com/dotnet/runtime/issues/71881) by using:\r\n\r\n```\r\nvar RTLD_DEFAULT = NativeLibrary.GetMainProgramHandle();\r\n```\r\n\r\nin place of `IntPtr.Zero`. Probably close enough.\r\n\r\n### Configuration\r\n\r\n```\r\n$ dotnet --version\r\n7.0.113\r\n$ lsb_release -a\r\nNo LSB modules are available.\r\nDistributor ID: Ubuntu\r\nDescription:    Ubuntu 22.04.3 LTS\r\nRelease:        22.04\r\nCodename:       jammy\r\n$ uname -a\r\nLinux ubuntu 6.2.0-35-generic #35~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Fri Oct  6 10:23:26 UTC 2 x86_64 x86_64 x86_64 GNU/Linux\r\n```\r\n\r\nI think it\u0027s not specific to this configuration, after looking at the runtime sources.\r\n\r\n.NET is the one packaged and available on Ubuntu 22.04 _without_ the .NET package repos.\r\n\r\n### Other information\r\n\r\n[`dlsym()`](https://man7.org/linux/man-pages/man3/dlsym.3.html) knows of two pseudo-handles which can be passed in as the first argument (\"a \"handle\" of a dynamic loaded shared object\"). These pseudo-handles are:\r\n\r\n```\r\n/* If the first argument of `dlsym\u0027 or `dlvsym\u0027 is set to RTLD_NEXT\r\n   the run-time address of the symbol called NAME in the next shared\r\n   object is returned.  The \"next\" relation is defined by the order\r\n   the shared objects were loaded.  */\r\n# define RTLD_NEXT      ((void *) -1l)\r\n\r\n/* If the first argument to `dlsym\u0027 or `dlvsym\u0027 is set to RTLD_DEFAULT\r\n   the run-time address of the symbol called NAME in the global scope\r\n   is returned.  */\r\n# define RTLD_DEFAULT   ((void *) 0)\r\n```\r\n\r\n(excerpt from `dlfcn.h` from GLIBC 2.35)\r\n\r\nWhile passing `(IntPtr)(-1)` works fine and yields `RTLD_NEXT` behavior, passing `IntPtr.Zero` is simply treated as an error condition.\r\n\r\nThis makes sense for Win32 `GetProcAddress` but doesn\u0027t make sense for `dlsym` on Linux where various scopes for symbol lookup exist.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOakbTtg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5qPyK_",
                                           "createdAt":  "2023-10-27T08:36:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\n`NativeLibrary.GetExport` throws a `System.ArgumentNullException` exception when passed in `IntPtr.Zero` to as `handle`.\r\n\r\nThis makes it impossible to get `RTLD_DEFAULT` behavior.\n\n### Reproduction Steps\n\nCompile and run this:\r\n\r\n```\r\nusing System.Runtime.InteropServices;\r\n\r\nNativeLibrary.GetExport(IntPtr.Zero, \"SomeFunction\");\r\n```\n\n### Expected behavior\n\nReturn function pointer or `IntPtr.Zero`.\n\n### Actual behavior\n\nThrows exception `System.ArgumentNullException`\r\n\r\n```\r\n$ dotnet run /home/username/getexport-issue/bin/Debug/net6.0/getexport.dll\r\nUnhandled exception. System.ArgumentNullException: Value cannot be null. (Parameter \u0027handle\u0027)\r\n   at System.Runtime.InteropServices.NativeLibrary.GetExport(IntPtr handle, String name)\r\n   at Program.\u003cMain\u003e$(String[] args) in /home/username/getexport-issue/Program.cs:line 3\r\n```\n\n### Regression?\n\nNo idea\n\n### Known Workarounds\n\nCall a `DllImport`-ed `dlsym()` directly with `IntPtr.Zero` for the `handle`.\n\n### Configuration\n\n```\r\n$ dotnet --version\r\n7.0.113\r\n$ lsb_release -a\r\nNo LSB modules are available.\r\nDistributor ID: Ubuntu\r\nDescription:    Ubuntu 22.04.3 LTS\r\nRelease:        22.04\r\nCodename:       jammy\r\n$ uname -a\r\nLinux ubuntu 6.2.0-35-generic #35~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Fri Oct  6 10:23:26 UTC 2 x86_64 x86_64 x86_64 GNU/Linux\r\n```\r\n\r\nI think it\u0027s not specific to this configuration, after looking at the runtime sources.\r\n\r\n.NET is the one packaged and available on Ubuntu 22.04 _without_ the .NET package repos.\n\n### Other information\n\n[`dlsym()`](https://man7.org/linux/man-pages/man3/dlsym.3.html) knows of two pseudo-handles which can be passed in as the first argument (\"a \"handle\" of a dynamic loaded shared object\"). These pseudo-handles are:\r\n\r\n```\r\n/* If the first argument of `dlsym\u0027 or `dlvsym\u0027 is set to RTLD_NEXT\r\n   the run-time address of the symbol called NAME in the next shared\r\n   object is returned.  The \"next\" relation is defined by the order\r\n   the shared objects were loaded.  */\r\n# define RTLD_NEXT      ((void *) -1l)\r\n\r\n/* If the first argument to `dlsym\u0027 or `dlvsym\u0027 is set to RTLD_DEFAULT\r\n   the run-time address of the symbol called NAME in the global scope\r\n   is returned.  */\r\n# define RTLD_DEFAULT   ((void *) 0)\r\n```\r\n\r\n(excerpt from `dlfcn.h` from GLIBC 2.35)\r\n\r\nWhile passing `(IntPtr)(-1)` works fine and yields `RTLD_NEXT` behavior, passing `IntPtr.Zero` is simply treated as an error condition.\r\n\r\nThis makes sense for Win32 `GetProcAddress` but doesn\u0027t make sense for `dlsym` on Linux where various scopes for symbol lookup exist.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eexoosh\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-10-27T08:36:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5qQLpf",
                                           "createdAt":  "2023-10-27T09:50:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODLIZuw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "exoosh",
                                                                               "createdAt":  "2023-10-27T09:51:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Joe4evr",
                                                                               "createdAt":  "2023-10-27T11:17:54Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "https://github.com/dotnet/runtime/issues/71881#issuecomment-1179570792",
                                           "updatedAt":  "2023-10-27T09:50:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5qQVCT",
                                           "createdAt":  "2023-10-27T10:18:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "exoosh",
                                           "body":  "\u003e [#71881 (comment)](https://github.com/dotnet/runtime/issues/71881#issuecomment-1179570792)\r\n\r\nThanks for pointing that out! I agree, that this is a viable workaround.\r\n\r\nThe linked issue has a few remarks though -- and it\u0027s closed so commenting there is impossible. One such remark is:\r\n\r\n\u003e Given that `NativeLibrary` exists to abstract away platform differences, I don\u0027t think introducing a platform difference would be a good idea. [...] (on Windows it could enumerate loaded libraries and call `TryGetExport` on each.)\r\n\r\nAgreed that it\u0027s there to gloss over those differences. Alas, seeing everything through Windows-tinted glasses in this case is the issue. Windows does in fact have the notion of \"the module that created this process\". What it does not have is the notion of a process-global symbol table. And that\u0027s where `RTLD_DEFAULT` and `RTLD_NEXT` come in. That said: the suggestion in parentheses makes little sense in the Windows context. That\u0027s no longer abstracting away platform differences, it\u0027s creating new semantics -- and arguably wouldn\u0027t be `Interop` anymore.\r\n\r\nAnother commenter states:\r\n\r\n\u003e [...] I\u0027m not convinced it is common enough [...]\r\n\r\nAnd I am not sure how that\u0027s backed by data, if at all. Certainly those are valid and common use cases in the Linux world. Certain libraries outright rely on the fact that symbols are made globally available before they get loaded (see MKL in #93911).\r\n\r\nLooking at the implementation and names like `LoadLibraryCallbackStub` and then at issues like #11901 really doesn\u0027t say \"abstract away platform differences\", it says \"use this particular semantic on the target platform because it most closely resembles Windows behavior\".\r\n\r\nAnd don\u0027t get me wrong, I _do_ appreciate many aspects of the NT platform and find myself defending its advantages against more fervent Linux aficionados on a regular basis. But abstracting platform differences in favor of one platform and at the expense of every other platform isn\u0027t exactly the spirit of cross-platform development. That\u0027s the spirit of \"I\u0027ll _port_ this fork-based Unix server to Windows\" and then complaining it doesn\u0027t scale (because of differences in the expense for process creation, because Windows uses proactor pattern whereas Linux traditionally used reactor pattern etc.) -- just in reverse.\r\n\r\nPS: I\u0027ll leave closing this ticket to someone else, because I don\u0027t want to bereave anyone of the ability to comment.",
                                           "updatedAt":  "2023-10-27T10:40:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5qRcJt",
                                           "createdAt":  "2023-10-27T13:51:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODLJYQQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "exoosh",
                                                                               "createdAt":  "2023-10-27T13:53:12Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "Will try this again for .NET 9.\r\n\r\nNote that https://github.com/dotnet/runtime/issues/71881 was left open to wait for feedback, Very little was received so it was closed. If we see a strong push then we can consider new APIs to reduce friction further but for now there doesn\u0027t seem to be enough to warrant a new API.",
                                           "updatedAt":  "2023-10-27T13:51:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5qRcwq",
                                           "createdAt":  "2023-10-27T13:53:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "exoosh",
                                           "body":  "\u003e Will try this again for .NET 9.\r\n\u003e \r\n\u003e Note that #71881 was left open to wait for feedback, Very little was received so it was closed. If we see a strong push then we can consider new APIs to reduce friction further but for now there doesn\u0027t seem to be enough to warrant a new API.\r\n\r\n@AaronRobinsonMSFT I totally agree that from the view of a C# developer this is probably a fringe problem. And workarounds exist and are now somewhat documented publicly as well.",
                                           "updatedAt":  "2023-10-27T13:53:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5qRtO2",
                                           "createdAt":  "2023-10-27T14:36:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODLKQmQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "exoosh",
                                                                               "createdAt":  "2023-10-27T15:49:17Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MichalPetryka",
                                                                               "createdAt":  "2023-10-27T15:57:49Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "jkotas",
                                           "body":  "The `NativeLibrary` APIs have been designed as the least-common denominator between platforms. They do not provide access to the full set of Windows-specific options nor the full set of Unix-specific options for working with native libraries (that also differ between Unix variants). The design expects to manually PInvoke the OS-specific API to get access to the OS-specific functionality. It is a non-goal for .NET BCL APIs to expose all OS-specific features. \r\n\r\nHaving said that, we have ability to expose OS-specific features as .NET BCL APIs.",
                                           "updatedAt":  "2023-10-27T14:36:22Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "NativeLibrary.GetExport/TryGetExport on Linux don\u0027t offer the same semantics as dlsym()",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/94088",
        "createdAt":  "2023-10-27T13:16:40Z",
        "number":  94088,
        "author":  "Sergio0694",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCzm1Hg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ahmed605",
                                            "createdAt":  "2023-10-27T13:20:28Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-08-17T17:37:41Z",
        "body":  "On NativeAOT, the `IErrorInfo` setup from `Marshal.GetHRForException` is not implemented:\r\n\r\nhttps://github.com/dotnet/runtime/blob/568ed4125d0ae62c0d82d8f3703854fcc04bf32d/src/coreclr/nativeaot/System.Private.CoreLib/src/System/Runtime/InteropServices/PInvokeMarshal.cs#L29-L38\r\n\r\nThis causes a functional difference with CoreCLR, which instead correctly sets up all the `IErrorInfo` data:\r\n\r\nhttps://github.com/dotnet/runtime/blob/568ed4125d0ae62c0d82d8f3703854fcc04bf32d/src/coreclr/vm/marshalnative.cpp#L594-L612\r\n\r\nNotably, this seems to be guarded by `FEATURE_COMINTEROP`, so it seems it\u0027s not implemented when built-in COM interop is disabled, which is always the case on NativeAOT. That said, this feature on its own doesn\u0027t really _require_ built-in COM interop. We could probably take either approach here:\r\n- Implement `IErrorInfo` on NAOT too (just with some blittable bindings and a P/Invoke, it\u0027s doable)\r\n- Decide not to support this on NAOT, and just remove that `// TODO` and simplify that code\r\n\r\nHaving built-in support for `IErrorInfo` would certainly be nice.\r\n\r\nAdditional, if we did decide to remove it, one question I have is: suppose someone is writing a library that uses COM. They want to populate `IErrorInfo` for exceptions they catch in their native exports (eg. if they\u0027re building a vtable for a native object). The library could end up running under either CoreCLR (with or without built-in COM), or NAOT. How can they know whether the explicit `IErrorInfo` is needed on their end? And if they were to just implement this on their own and always do this, wouldn\u0027t this just be quite innefficient and cause extra unnecessary work when running on CoreCLR, as you\u0027d be setting two `IErrorInfo` every single time (one from `Marshal.GetHRForException`, one from your own library code), and just discarding one?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOauP9FA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5qR00b",
                                           "createdAt":  "2023-10-27T14:55:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Implement IErrorInfo on NAOT too (just with some blittable bindings and a P/Invoke, it\u0027s doable)\r\n\r\nThis method has a hard dependency on built-in COM interop. I do not think it is possible to create equivalent implementation with built-in COM interop.\r\n\r\n\u003e suppose someone is writing a library that uses COM. \r\n\r\nIf the library wants to avoid dependency on built-in COM, I think it should avoid calling `Marshal.GetHRForException`.",
                                           "updatedAt":  "2023-10-27T14:55:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5q4_nU",
                                           "createdAt":  "2023-11-04T03:38:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e That said, this feature on its own doesn\u0027t really require built-in COM interop. \r\n\r\nYes it does. The conversion between `IErrorInfo` and .NET Exceptions are in play here.\r\n\r\n\u003e \u003e suppose someone is writing a library that uses COM.\r\n\r\n\u003e If the library wants to avoid dependency on built-in COM, I think it should avoid calling Marshal.GetHRForException.\r\n\r\nAgree.\r\n\r\nMost of the `HRESULT` to/from `Exception` APIs on `Marshal` are rarely worth the trouble they tend to cause, especially when `IErrorInfo` is involved. If a user has an `Exception` and they want the `IErrorInfo` conversion done ideally it should be done at the marshaller layer. Right now we have a note in one of our marshallers, `ExceptionAsDefaultMarshaller\u003cT\u003e`, about depending on this but as we move forward to support more scenarios, that will change and we will raise that work to be done in the marshaller itself.\r\n\r\nhttps://github.com/dotnet/runtime/blob/76a995afe3306863cb836b5becc33293a2e5a781/src/libraries/System.Runtime.InteropServices/src/System/Runtime/InteropServices/Marshalling/ExceptionAsDefaultMarshaller.cs#L6-L26\r\n\r\nIf someone wanted to update that marshaller to handle calling `SetLastError()` that would be most welcome.",
                                           "updatedAt":  "2023-11-04T03:38:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5q4_u6",
                                           "createdAt":  "2023-11-04T03:41:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "@jkoritzinsky and @jtschuster We should repurpose this issue to make `ExceptionAsDefaultMarshaller\u003cT\u003e`, or a new marshaller, do the calls to marshal the `Exception` to `IErrorInfo` as appropriate and call `SetLastError()`.",
                                           "updatedAt":  "2023-11-04T03:41:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5q4_0U",
                                           "createdAt":  "2023-11-04T03:43:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nOn NativeAOT, the `IErrorInfo` setup from `Marshal.GetHRForException` is not implemented:\r\n\r\nhttps://github.com/dotnet/runtime/blob/568ed4125d0ae62c0d82d8f3703854fcc04bf32d/src/coreclr/nativeaot/System.Private.CoreLib/src/System/Runtime/InteropServices/PInvokeMarshal.cs#L29-L38\r\n\r\nThis causes a functional difference with CoreCLR, which instead correctly sets up all the `IErrorInfo` data:\r\n\r\nhttps://github.com/dotnet/runtime/blob/568ed4125d0ae62c0d82d8f3703854fcc04bf32d/src/coreclr/vm/marshalnative.cpp#L594-L612\r\n\r\nNotably, this seems to be guarded by `FEATURE_COMINTEROP`, so it seems it\u0027s not implemented when built-in COM interop is disabled, which is always the case on NativeAOT. That said, this feature on its own doesn\u0027t really _require_ built-in COM interop. We could probably take either approach here:\r\n- Implement `IErrorInfo` on NAOT too (just with some blittable bindings and a P/Invoke, it\u0027s doable)\r\n- Decide not to support this on NAOT, and just remove that `// TODO` and simplify that code\r\n\r\nHaving built-in support for `IErrorInfo` would certainly be nice.\r\n\r\nAdditional, if we did decide to remove it, one question I have is: suppose someone is writing a library that uses COM. They want to populate `IErrorInfo` for exceptions they catch in their native exports (eg. if they\u0027re building a vtable for a native object). The library could end up running under either CoreCLR (with or without built-in COM), or NAOT. How can they know whether the explicit `IErrorInfo` is needed on their end? And if they were to just implement this on their own and always do this, wouldn\u0027t this just be quite innefficient and cause extra unnecessary work when running on CoreCLR, as you\u0027d be setting two `IErrorInfo` every single time (one from `Marshal.GetHRForException`, one from your own library code), and just discarding one?\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eSergio0694\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e9.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-11-04T03:43:01Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Need NativeAOT friendly way to marshal an `Exception` to an `IErrorInfo`",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/94273",
        "createdAt":  "2023-11-01T20:01:19Z",
        "number":  94273,
        "author":  "jtschuster",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-11T21:23:36Z",
        "body":  "Looks like we just copy the partial modifier from user code when we shouldn\u0027t\r\n\r\nCode:\r\n```C#\r\n[GeneratedComInterface]\r\n[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\r\n[Guid(IID)]\r\ninternal partial interface ICalculator\r\n{\r\n    int Add(int a, int b);\r\n    public partial int Subtract(int a, int b) =\u003e 0;\r\n    public partial int Subtract(int a, int b);\r\n    public const string IID = \"c67121c6-cf26-431f-adc7-d12fe2448841\";\r\n}\r\n```\r\ngenerated:\r\n\r\n```C#\r\n// \u003cauto-generated /\u003e\r\n#pragma warning disable CS0612, CS0618\r\nfile unsafe class InterfaceInformation : global::System.Runtime.InteropServices.Marshalling.IIUnknownInterfaceType\r\n{\r\n    public static global::System.Guid Iid { get; } = new(new global::System.ReadOnlySpan\u003cbyte\u003e(new byte[] { 198, 33, 113, 198, 38, 207, 31, 67, 173, 199, 209, 47, 226, 68, 136, 65 }));\r\n\r\n    private static void** _vtable;\r\n    public static void** ManagedVirtualMethodTable =\u003e _vtable != null ? _vtable : (_vtable = InterfaceImplementation.CreateManagedVirtualFunctionTable());\r\n}\r\n\r\n[global::System.Runtime.InteropServices.DynamicInterfaceCastableImplementationAttribute]\r\nfile unsafe partial interface InterfaceImplementation : global::Tutorial.ICalculator\r\n{\r\n    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.Interop.ComInterfaceGenerator\", \"8.0.8.41904\")]\r\n    [global::System.Runtime.CompilerServices.SkipLocalsInitAttribute]\r\n    int global::Tutorial.ICalculator.Add(int a, int b)\r\n    {\r\n        var(__this, __vtable_native) = ((global::System.Runtime.InteropServices.Marshalling.IUnmanagedVirtualMethodTableProvider)this).GetVirtualMethodTableInfoForKey(typeof(global::Tutorial.ICalculator));\r\n        int __retVal;\r\n        int __invokeRetVal;\r\n        {\r\n            __invokeRetVal = ((delegate* unmanaged[MemberFunction]\u003cvoid*, int, int, int*, int\u003e )__vtable_native[3])(__this, a, b, \u0026__retVal);\r\n        }\r\n\r\n        // NotifyForSuccessfulInvoke - Keep alive any managed objects that need to stay alive across the call.\r\n        global::System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(__invokeRetVal);\r\n        global::System.GC.KeepAlive(this);\r\n        return __retVal;\r\n    }\r\n\r\n    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.Interop.ComInterfaceGenerator\", \"8.0.8.41904\")]\r\n    [global::System.Runtime.CompilerServices.SkipLocalsInitAttribute]\r\n    partial int global::Tutorial.ICalculator.Subtract(int a, int b)\r\n    {\r\n        var(__this, __vtable_native) = ((global::System.Runtime.InteropServices.Marshalling.IUnmanagedVirtualMethodTableProvider)this).GetVirtualMethodTableInfoForKey(typeof(global::Tutorial.ICalculator));\r\n        int __retVal;\r\n        int __invokeRetVal;\r\n        {\r\n            __invokeRetVal = ((delegate* unmanaged[MemberFunction]\u003cvoid*, int, int, int*, int\u003e )__vtable_native[4])(__this, a, b, \u0026__retVal);\r\n        }\r\n\r\n        // NotifyForSuccessfulInvoke - Keep alive any managed objects that need to stay alive across the call.\r\n        global::System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(__invokeRetVal);\r\n        global::System.GC.KeepAlive(this);\r\n        return __retVal;\r\n    }\r\n}\r\n\r\nfile unsafe partial interface InterfaceImplementation\r\n{\r\n    [global::System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(global::System.Runtime.CompilerServices.CallConvMemberFunction) })]\r\n    internal static int ABI_Add(global::System.Runtime.InteropServices.ComWrappers.ComInterfaceDispatch* __this_native, int a, int b, int* __invokeRetValUnmanaged__param)\r\n    {\r\n        global::Tutorial.ICalculator @this = default;\r\n        ref int __invokeRetValUnmanaged = ref *__invokeRetValUnmanaged__param;\r\n        int __invokeRetVal = default;\r\n        int __retVal = default;\r\n        try\r\n        {\r\n            // Unmarshal - Convert native data to managed data.\r\n            @this = global::System.Runtime.InteropServices.ComWrappers.ComInterfaceDispatch.GetInstance\u003cglobal::Tutorial.ICalculator\u003e(__this_native);\r\n            __invokeRetVal = @this.Add(a, b);\r\n            // NotifyForSuccessfulInvoke - Keep alive any managed objects that need to stay alive across the call.\r\n            __retVal = 0; // S_OK\r\n            // Marshal - Convert managed data to native data.\r\n            __invokeRetValUnmanaged = __invokeRetVal;\r\n        }\r\n        catch (global::System.Exception __exception)\r\n        {\r\n            __retVal = global::System.Runtime.InteropServices.Marshalling.ExceptionAsHResultMarshaller\u003cint\u003e.ConvertToUnmanaged(__exception);\r\n        }\r\n\r\n        return __retVal;\r\n    }\r\n\r\n    [global::System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(global::System.Runtime.CompilerServices.CallConvMemberFunction) })]\r\n    internal static int ABI_Subtract(global::System.Runtime.InteropServices.ComWrappers.ComInterfaceDispatch* __this_native, int a, int b, int* __invokeRetValUnmanaged__param)\r\n    {\r\n        global::Tutorial.ICalculator @this = default;\r\n        ref int __invokeRetValUnmanaged = ref *__invokeRetValUnmanaged__param;\r\n        int __invokeRetVal = default;\r\n        int __retVal = default;\r\n        try\r\n        {\r\n            // Unmarshal - Convert native data to managed data.\r\n            @this = global::System.Runtime.InteropServices.ComWrappers.ComInterfaceDispatch.GetInstance\u003cglobal::Tutorial.ICalculator\u003e(__this_native);\r\n            __invokeRetVal = @this.Subtract(a, b);\r\n            // NotifyForSuccessfulInvoke - Keep alive any managed objects that need to stay alive across the call.\r\n            __retVal = 0; // S_OK\r\n            // Marshal - Convert managed data to native data.\r\n            __invokeRetValUnmanaged = __invokeRetVal;\r\n        }\r\n        catch (global::System.Exception __exception)\r\n        {\r\n            __retVal = global::System.Runtime.InteropServices.Marshalling.ExceptionAsHResultMarshaller\u003cint\u003e.ConvertToUnmanaged(__exception);\r\n        }\r\n\r\n        return __retVal;\r\n    }\r\n}\r\n\r\nfile unsafe partial interface InterfaceImplementation\r\n{\r\n    internal static void** CreateManagedVirtualFunctionTable()\r\n    {\r\n        void** vtable = (void**)global::System.Runtime.CompilerServices.RuntimeHelpers.AllocateTypeAssociatedMemory(typeof(global::Tutorial.ICalculator), sizeof(void*) * 5);\r\n        {\r\n            nint v0, v1, v2;\r\n            global::System.Runtime.InteropServices.ComWrappers.GetIUnknownImpl(out v0, out v1, out v2);\r\n            vtable[0] = (void*)v0;\r\n            vtable[1] = (void*)v1;\r\n            vtable[2] = (void*)v2;\r\n        }\r\n\r\n        {\r\n            vtable[3] = (void*)(delegate* unmanaged[MemberFunction]\u003cglobal::System.Runtime.InteropServices.ComWrappers.ComInterfaceDispatch*, int, int, int*, int\u003e )\u0026ABI_Add;\r\n            vtable[4] = (void*)(delegate* unmanaged[MemberFunction]\u003cglobal::System.Runtime.InteropServices.ComWrappers.ComInterfaceDispatch*, int, int, int*, int\u003e )\u0026ABI_Subtract;\r\n        }\r\n\r\n        return vtable;\r\n    }\r\n}\r\n\r\nnamespace Tutorial\r\n{\r\n    [global::System.Runtime.InteropServices.Marshalling.IUnknownDerivedAttribute\u003cInterfaceInformation, InterfaceImplementation\u003e]\r\n    internal partial interface ICalculator\r\n    {\r\n    }\r\n}\r\n\r\nnamespace Tutorial\r\n{\r\n    internal partial interface ICalculator\r\n    {\r\n    }\r\n}\r\n```\r\nError:\r\n```\r\nMicrosoft.Interop.ComInterfaceGenerator\\ICalculator.cs(33,46): error CS0759: No defining declaration found for implementing declaration of partial method \u0027InterfaceImplementation.Subtract(int, int)\u0027\r\n\r\nMicrosoft.Interop.ComInterfaceGenerator\\ICalculator.cs(33,46): error CS0754: A partial method may not explicitly implement an interface method\r\n\r\nMicrosoft.Interop.ComInterfaceGenerator\\ICalculator.cs(33,46): error CS0539: \u0027InterfaceImplementation.Subtract(int, int)\u0027 in explicit interface declaration is not found among members of the interface that can be implemented\r\n\r\nMicrosoft.Interop.ComInterfaceGenerator\\ICalculator.cs(33,46): error CS8796: Partial method \u0027InterfaceImplementation.Subtract(int, int)\u0027 must have accessibility modifiers because it has a non-void return type. \r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOaqr8NA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5qqvw0",
                                           "createdAt":  "2023-11-01T20:01:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nLooks like we just copy the partial modifier from user code when we shouldn\u0027t\r\n\r\nCode:\r\n```C#\r\n[GeneratedComInterface]\r\n[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\r\n[Guid(IID)]\r\ninternal partial interface ICalculator\r\n{\r\n    int Add(int a, int b);\r\n    public partial int Subtract(int a, int b) =\u003e 0;\r\n    public partial int Subtract(int a, int b);\r\n    public const string IID = \"c67121c6-cf26-431f-adc7-d12fe2448841\";\r\n}\r\n```\r\ngenerated:\r\n\r\n```C#\r\n// \u003cauto-generated /\u003e\r\n#pragma warning disable CS0612, CS0618\r\nfile unsafe class InterfaceInformation : global::System.Runtime.InteropServices.Marshalling.IIUnknownInterfaceType\r\n{\r\n    public static global::System.Guid Iid { get; } = new(new global::System.ReadOnlySpan\u003cbyte\u003e(new byte[] { 198, 33, 113, 198, 38, 207, 31, 67, 173, 199, 209, 47, 226, 68, 136, 65 }));\r\n\r\n    private static void** _vtable;\r\n    public static void** ManagedVirtualMethodTable =\u003e _vtable != null ? _vtable : (_vtable = InterfaceImplementation.CreateManagedVirtualFunctionTable());\r\n}\r\n\r\n[global::System.Runtime.InteropServices.DynamicInterfaceCastableImplementationAttribute]\r\nfile unsafe partial interface InterfaceImplementation : global::Tutorial.ICalculator\r\n{\r\n    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.Interop.ComInterfaceGenerator\", \"8.0.8.41904\")]\r\n    [global::System.Runtime.CompilerServices.SkipLocalsInitAttribute]\r\n    int global::Tutorial.ICalculator.Add(int a, int b)\r\n    {\r\n        var(__this, __vtable_native) = ((global::System.Runtime.InteropServices.Marshalling.IUnmanagedVirtualMethodTableProvider)this).GetVirtualMethodTableInfoForKey(typeof(global::Tutorial.ICalculator));\r\n        int __retVal;\r\n        int __invokeRetVal;\r\n        {\r\n            __invokeRetVal = ((delegate* unmanaged[MemberFunction]\u003cvoid*, int, int, int*, int\u003e )__vtable_native[3])(__this, a, b, \u0026__retVal);\r\n        }\r\n\r\n        // NotifyForSuccessfulInvoke - Keep alive any managed objects that need to stay alive across the call.\r\n        global::System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(__invokeRetVal);\r\n        global::System.GC.KeepAlive(this);\r\n        return __retVal;\r\n    }\r\n\r\n    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.Interop.ComInterfaceGenerator\", \"8.0.8.41904\")]\r\n    [global::System.Runtime.CompilerServices.SkipLocalsInitAttribute]\r\n    partial int global::Tutorial.ICalculator.Subtract(int a, int b)\r\n    {\r\n        var(__this, __vtable_native) = ((global::System.Runtime.InteropServices.Marshalling.IUnmanagedVirtualMethodTableProvider)this).GetVirtualMethodTableInfoForKey(typeof(global::Tutorial.ICalculator));\r\n        int __retVal;\r\n        int __invokeRetVal;\r\n        {\r\n            __invokeRetVal = ((delegate* unmanaged[MemberFunction]\u003cvoid*, int, int, int*, int\u003e )__vtable_native[4])(__this, a, b, \u0026__retVal);\r\n        }\r\n\r\n        // NotifyForSuccessfulInvoke - Keep alive any managed objects that need to stay alive across the call.\r\n        global::System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(__invokeRetVal);\r\n        global::System.GC.KeepAlive(this);\r\n        return __retVal;\r\n    }\r\n}\r\n\r\nfile unsafe partial interface InterfaceImplementation\r\n{\r\n    [global::System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(global::System.Runtime.CompilerServices.CallConvMemberFunction) })]\r\n    internal static int ABI_Add(global::System.Runtime.InteropServices.ComWrappers.ComInterfaceDispatch* __this_native, int a, int b, int* __invokeRetValUnmanaged__param)\r\n    {\r\n        global::Tutorial.ICalculator @this = default;\r\n        ref int __invokeRetValUnmanaged = ref *__invokeRetValUnmanaged__param;\r\n        int __invokeRetVal = default;\r\n        int __retVal = default;\r\n        try\r\n        {\r\n            // Unmarshal - Convert native data to managed data.\r\n            @this = global::System.Runtime.InteropServices.ComWrappers.ComInterfaceDispatch.GetInstance\u003cglobal::Tutorial.ICalculator\u003e(__this_native);\r\n            __invokeRetVal = @this.Add(a, b);\r\n            // NotifyForSuccessfulInvoke - Keep alive any managed objects that need to stay alive across the call.\r\n            __retVal = 0; // S_OK\r\n            // Marshal - Convert managed data to native data.\r\n            __invokeRetValUnmanaged = __invokeRetVal;\r\n        }\r\n        catch (global::System.Exception __exception)\r\n        {\r\n            __retVal = global::System.Runtime.InteropServices.Marshalling.ExceptionAsHResultMarshaller\u003cint\u003e.ConvertToUnmanaged(__exception);\r\n        }\r\n\r\n        return __retVal;\r\n    }\r\n\r\n    [global::System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(global::System.Runtime.CompilerServices.CallConvMemberFunction) })]\r\n    internal static int ABI_Subtract(global::System.Runtime.InteropServices.ComWrappers.ComInterfaceDispatch* __this_native, int a, int b, int* __invokeRetValUnmanaged__param)\r\n    {\r\n        global::Tutorial.ICalculator @this = default;\r\n        ref int __invokeRetValUnmanaged = ref *__invokeRetValUnmanaged__param;\r\n        int __invokeRetVal = default;\r\n        int __retVal = default;\r\n        try\r\n        {\r\n            // Unmarshal - Convert native data to managed data.\r\n            @this = global::System.Runtime.InteropServices.ComWrappers.ComInterfaceDispatch.GetInstance\u003cglobal::Tutorial.ICalculator\u003e(__this_native);\r\n            __invokeRetVal = @this.Subtract(a, b);\r\n            // NotifyForSuccessfulInvoke - Keep alive any managed objects that need to stay alive across the call.\r\n            __retVal = 0; // S_OK\r\n            // Marshal - Convert managed data to native data.\r\n            __invokeRetValUnmanaged = __invokeRetVal;\r\n        }\r\n        catch (global::System.Exception __exception)\r\n        {\r\n            __retVal = global::System.Runtime.InteropServices.Marshalling.ExceptionAsHResultMarshaller\u003cint\u003e.ConvertToUnmanaged(__exception);\r\n        }\r\n\r\n        return __retVal;\r\n    }\r\n}\r\n\r\nfile unsafe partial interface InterfaceImplementation\r\n{\r\n    internal static void** CreateManagedVirtualFunctionTable()\r\n    {\r\n        void** vtable = (void**)global::System.Runtime.CompilerServices.RuntimeHelpers.AllocateTypeAssociatedMemory(typeof(global::Tutorial.ICalculator), sizeof(void*) * 5);\r\n        {\r\n            nint v0, v1, v2;\r\n            global::System.Runtime.InteropServices.ComWrappers.GetIUnknownImpl(out v0, out v1, out v2);\r\n            vtable[0] = (void*)v0;\r\n            vtable[1] = (void*)v1;\r\n            vtable[2] = (void*)v2;\r\n        }\r\n\r\n        {\r\n            vtable[3] = (void*)(delegate* unmanaged[MemberFunction]\u003cglobal::System.Runtime.InteropServices.ComWrappers.ComInterfaceDispatch*, int, int, int*, int\u003e )\u0026ABI_Add;\r\n            vtable[4] = (void*)(delegate* unmanaged[MemberFunction]\u003cglobal::System.Runtime.InteropServices.ComWrappers.ComInterfaceDispatch*, int, int, int*, int\u003e )\u0026ABI_Subtract;\r\n        }\r\n\r\n        return vtable;\r\n    }\r\n}\r\n\r\nnamespace Tutorial\r\n{\r\n    [global::System.Runtime.InteropServices.Marshalling.IUnknownDerivedAttribute\u003cInterfaceInformation, InterfaceImplementation\u003e]\r\n    internal partial interface ICalculator\r\n    {\r\n    }\r\n}\r\n\r\nnamespace Tutorial\r\n{\r\n    internal partial interface ICalculator\r\n    {\r\n    }\r\n}\r\n```\r\nError:\r\n```\r\nMicrosoft.Interop.ComInterfaceGenerator\\ICalculator.cs(33,46): error CS0759: No defining declaration found for implementing declaration of partial method \u0027InterfaceImplementation.Subtract(int, int)\u0027\r\n\r\nMicrosoft.Interop.ComInterfaceGenerator\\ICalculator.cs(33,46): error CS0754: A partial method may not explicitly implement an interface method\r\n\r\nMicrosoft.Interop.ComInterfaceGenerator\\ICalculator.cs(33,46): error CS0539: \u0027InterfaceImplementation.Subtract(int, int)\u0027 in explicit interface declaration is not found among members of the interface that can be implemented\r\n\r\nMicrosoft.Interop.ComInterfaceGenerator\\ICalculator.cs(33,46): error CS8796: Partial method \u0027InterfaceImplementation.Subtract(int, int)\u0027 must have accessibility modifiers because it has a non-void return type. \r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejtschuster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `source-generator`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e9.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-11-01T20:01:26Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "ComInterfaceGenerator produces invalid C# for `partial` interface methods.",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "source-generator"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/94356",
        "createdAt":  "2023-11-03T19:32:34Z",
        "number":  94356,
        "author":  "jtschuster",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-04-18T23:00:33Z",
        "body":  "A generic class with GeneratedComClass uses the \u003c\u003e brackets in the hint name, which throws an exception, crashing the generator. ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOp921TA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5q3t8h",
                                           "createdAt":  "2023-11-03T19:32:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nA generic class with GeneratedComClass uses the \u003c\u003e brackets in the hint name, which throws an exception, crashing the generator. \n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejtschuster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `source-generator`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e9.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-11-03T19:32:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6n3bVM",
                                           "createdAt":  "2025-04-18T23:00:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mqudsi",
                                           "body":  "Just an fyi: unless I\u0027m mistaken, this was milestoned for 9.x but still happens with .NET 9",
                                           "updatedAt":  "2025-04-18T23:00:32Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "GeneratedComClass on a generic class causes generator to crash",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "source-generator"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/94419",
        "createdAt":  "2023-11-06T16:12:05Z",
        "number":  94419,
        "author":  "Sergio0694",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-18T07:07:19Z",
        "body":  "### Description\r\n\r\nFollow up with a conversation with @AaronRobinsonMSFT. Trying to use `ExceptionAsVoidMarshaller], but either I\u0027m doing something wrong, or it seems to just not work. The generated code is wrong, and I\u0027m not getting any warnings or anything.\r\n\r\ncc. @jkoritzinsky\r\n\r\n### Reproduction Steps\r\n\r\n```csharp\r\n[LibraryImport(\"kernel32\")]\r\n[return: MarshalUsing(typeof(ExceptionAsVoidMarshaller))]\r\npublic static partial void Foo();\r\n```\r\n\r\n### Expected behavior\r\n\r\nThe generated code should use `int` for the return, and then forward it to the marshaller to check and throw.\r\n\r\n### Actual behavior\r\n\r\nI just get this:\r\n\r\n```csharp\r\n[global::System.Runtime.InteropServices.DllImportAttribute(\"kernel32\", EntryPoint = \"Foo\", ExactSpelling = true)]\r\npublic static extern partial void Foo();\r\n```\r\n\r\n### Configuration\r\n\r\n.NET 8.0.100-rtm.23504.11",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOazF9FQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5rAlGj",
                                           "createdAt":  "2023-11-06T16:12:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nFollow up with a conversation with @AaronRobinsonMSFT. Trying to use `ExceptionAsVoidMarshaller], but either I\u0027m doing something wrong, or it seems to just not work. The generated code is wrong, and I\u0027m not getting any warnings or anything.\r\n\r\ncc. @jkoritzinsky\n\n### Reproduction Steps\n\n```csharp\r\n[LibraryImport(\"kernel32\")]\r\n[return: MarshalUsing(typeof(ExceptionAsVoidMarshaller))]\r\npublic static partial void Foo();\r\n```\n\n### Expected behavior\n\nThe generated code should use `int` for the return, and then forward it to the marshaller to check and throw.\n\n### Actual behavior\n\nI just get this:\r\n\r\n```csharp\r\n[global::System.Runtime.InteropServices.DllImportAttribute(\"kernel32\", EntryPoint = \"Foo\", ExactSpelling = true)]\r\npublic static extern partial void Foo();\r\n```\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eSergio0694\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-11-06T16:12:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5rAzDx",
                                           "createdAt":  "2023-11-06T16:32:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "It is entirely possible these API is only supported on COM interop right now.",
                                           "updatedAt":  "2023-11-06T16:32:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5rBBUf",
                                           "createdAt":  "2023-11-06T16:43:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "@jtschuster Any thoughts on how complex prototyping the `PreserveSig` marshallers for `LibraryImport` would be?",
                                           "updatedAt":  "2023-11-06T16:43:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5rCL22",
                                           "createdAt":  "2023-11-06T17:56:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jtschuster",
                                           "body":  "IIRC ExceptionAsX marshallers only support unmanaged to managed stubs. In managed to unmanaged stubs, the COM generator doesn\u0027t use a \"marshaller\" for the HRESULT\u0027s, it hard codes ThrowExceptionForHR. We\u0027d need to add support for `void` as the managed type in the marshalling generators and expose new API\u0027s if we want a built-in marshaller.\r\n\r\nI never had to mess too much with that part of things, so I\u0027m not sure exactly how complex it would be.\r\n\r\nHow important is it that these methods return void? Is it okay to use a custom marshaller that marshals `int` -\u003e `int` and only calls ThrowExceptionForHR in marshalling?",
                                           "updatedAt":  "2023-11-06T17:56:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5rCN8T",
                                           "createdAt":  "2023-11-06T18:02:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODL6zIQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jtschuster",
                                                                               "createdAt":  "2023-11-06T18:38:20Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Sergio0694",
                                           "body":  "\u003e \"How important is it that these methods return `void`? Is it okay to use a custom marshaller that marshals `int` -\u003e `int` and only calls `ThrowExceptionForHR` in marshalling?\"\r\n\r\nI mean maybe not critical, but I think the developer experience would be fairly worse in that case. If you have editofconfig rules, you\u0027d get warnings because of the ignored `int` return for the generated methods, and also this would make the signature pretty unintuitive and kinda hide the fact that the method would just never return for failure `HRESULT` values 🤔",
                                           "updatedAt":  "2023-11-06T18:02:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5rJuLo",
                                           "createdAt":  "2023-11-07T03:59:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e Is it okay to use a custom marshaller that marshals int -\u003e int and only calls ThrowExceptionForHR in marshalling?\r\n\r\nI think that is a fine first pass for now. In the longer term I think we should support the `PreserveSig` semantics now that we have a mechanism.",
                                           "updatedAt":  "2023-11-07T03:59:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5rMX0V",
                                           "createdAt":  "2023-11-07T12:28:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Sergio0694",
                                           "body":  "\u003e \"we should support the `PreserveSig` semantics\"\r\n\r\nTo clarify, with that do you also mean we should eventually support `[retval]`-s too? Because that\u0027d also be pretty nice 😄",
                                           "updatedAt":  "2023-11-07T12:28:03Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "Support `PreserveSig` on `LibraryImportAttribute` using the `ExceptionAs*Marshaller`s.",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/94429",
        "createdAt":  "2023-11-06T18:54:37Z",
        "number":  94429,
        "author":  "jtschuster",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-11T21:26:34Z",
        "body":  "If [ComVisible(true)] is present on a class converted to a GeneratedComClass, the codefixer should remove the attribute.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOawvatQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5rC9q1",
                                           "createdAt":  "2023-11-06T18:54:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nIf [ComVisible(true)] is present on a class converted to a GeneratedComClass, the codefixer should remove the attribute.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejtschuster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `code-analyzer`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e9.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-11-06T18:54:41Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "GeneratedComClass codefix doesn\u0027t remove [ComVisible(true)] from classes",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/94598",
        "createdAt":  "2023-11-10T09:46:50Z",
        "number":  94598,
        "author":  "winnieryl",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-09-29T02:38:50Z",
        "body":  "### Description\n\nI have a fips built shared lib(.so)in linux and wants to load it in dotnet using DllImport, then I run the program, but it fails:\r\nroot@ubuntu2204:~#  dotnet test.dll\r\n799305f152dc771a4474edaa481efcbe8bd5f29f\r\nroot@ubuntu2204:~# echo $?\r\n0\n\n### Reproduction Steps\n\nENV: \r\nubuntu 2204, \r\ndotnet version:  6.0.24\r\n\r\nbuild a shared library using fipsld from openssl, import it in dotnet.\n\n### Expected behavior\n\nThe lib can be loaded successfully\n\n### Actual behavior\n\ndotnet exits with random chars output \n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOjexgGg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5rp7uq",
                                           "createdAt":  "2023-11-10T17:41:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-security, @bartonjs, @vcsjones\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nI have a fips built shared lib(.so)in linux and wants to load it in dotnet using DllImport, then I run the program, but it fails:\r\nroot@ubuntu2204:~#  dotnet test.dll\r\n799305f152dc771a4474edaa481efcbe8bd5f29f\r\nroot@ubuntu2204:~# echo $?\r\n0\n\n### Reproduction Steps\n\nENV: \r\nubuntu 2204, \r\ndotnet version:  6.0.24\r\n\r\nbuild a shared library using fipsld from openssl, import it in dotnet.\n\n### Expected behavior\n\nThe lib can be loaded successfully\n\n### Actual behavior\n\ndotnet exits with random chars output \n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ewinnieryl\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Security`, `untriaged`, `needs-area-label`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-11-10T17:41:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5rqt2O",
                                           "createdAt":  "2023-11-10T19:58:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jozkee",
                                           "body":  "Can you share instructions in how to build the library with fipsld?",
                                           "updatedAt":  "2023-11-10T19:58:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5rqt44",
                                           "createdAt":  "2023-11-10T19:58:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "This issue has been marked `needs-author-action` and may be missing some important information.",
                                           "updatedAt":  "2023-11-10T19:58:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5rugKl",
                                           "createdAt":  "2023-11-13T01:41:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "winnieryl",
                                           "body":  "@Jozkee  thanks for the reply, here is the link on building using fipsld: \r\nhttps://wiki.openssl.org/index.php/Fipsld_and_C%2B%2B\r\nhttps://stackoverflow.com/questions/58930081/compile-application-with-fips-capable-openssl",
                                           "updatedAt":  "2023-11-13T01:41:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5rur_3",
                                           "createdAt":  "2023-11-13T02:55:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "winnieryl",
                                           "body":  "UPDATE:\r\nI just found out that this is related to fips signature, when I specify FIPS_SIG variable and point to incore, the built library will be signed by incore(invoked by fipsld), dotnet will failed to load this kind of library, when the library is not signed, dotnet is able to load the library. I guess dotnet is unable to parse the .so file when there is fips signature in it? Are there any configurations I can modify to make this work?\r\n\r\nI also packed the files needed for  testing in the attachment.\r\n[shared_file.tar.gz](https://github.com/dotnet/runtime/files/13333129/shared_file.tar.gz)\r\n",
                                           "updatedAt":  "2023-11-13T09:19:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5sgIhN",
                                           "createdAt":  "2023-11-21T07:19:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "winnieryl",
                                           "body":  "Hi @Jozkee, do you have any new info to share?",
                                           "updatedAt":  "2023-11-21T07:19:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5sko21",
                                           "createdAt":  "2023-11-21T19:21:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jozkee",
                                           "body":  "No, sorry I haven\u0027t looked into this issue yet. cc @vcsjones in case he can look into it first.",
                                           "updatedAt":  "2023-11-21T19:21:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ucZk9",
                                           "createdAt":  "2023-12-12T22:52:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODRMLJg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "winnieryl",
                                                                               "createdAt":  "2024-01-04T02:15:42Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "vcsjones",
                                           "body":  "Though this touches on OpenSSL I don\u0027t know if this is a an actual issue for the security folks, as it seems to be more related to loading a shared object with `DllImport` that has a FIPS signature.",
                                           "updatedAt":  "2023-12-12T22:52:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5v1M6Y",
                                           "createdAt":  "2024-01-04T02:16:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "winnieryl",
                                           "body":  "@vcsjones thanks for the comment, not sure if you can find the right folk for this issue ?",
                                           "updatedAt":  "2024-01-04T02:16:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6N7GAa",
                                           "createdAt":  "2024-09-29T02:38:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-09-29T02:38:48Z"
                                       }
                                   ],
                         "totalCount":  10
                     },
        "title":  "dotnet core cannot load FIPS built shared library in linux",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/95882",
        "createdAt":  "2023-12-12T00:24:31Z",
        "number":  95882,
        "author":  "jkoritzinsky",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC6rN4w==",
                          "nodes":  [
                                        {
                                            "content":  "HEART",
                                            "user":  "Sergio0694",
                                            "createdAt":  "2023-12-12T00:45:06Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2024-08-31T14:50:19Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2025-07-07T20:25:52Z",
        "body":  "Since the start of the interop source generators, we\u0027ve always decided to use Roslyn `SyntaxNode`s as both our source-of-truth as well as our go-to emit strategy. This choice has provided us a number of benefits:\r\n\r\n- C# constructs are represented the same way as the C# compiler represents them.\r\n- We can easily define an API surface that specifies \"this API returns a name/expression/statement\" without building our own type hierarchy.\r\n- We can copy tokens from the source of truth to our emitted code.\r\n- We never try emitting code that is only understood by Roslyn compilers newer than we can safely confirm we\u0027ll run against as the APIs don\u0027t exist.\r\n- We could reuse the code in a code-fix to inline the source-generated code.\r\n\r\nHowever, it has also lead to a number of problems:\r\n\r\n- The SyntaxFactory APIs are very verbose. We\u0027ve basically had to add comments above each block to explain what the code is doing.\r\n- `NormalizeWhitespace` (what we use to handle adding whitespace) is extremely slow.\r\n- We have at times accidentally added additional GC roots to the `SyntaxNode`s in the source `SyntaxTree`s due to how we structure some of our internal data types.\r\n- The source generator API surface requires us to pass strings to Roslyn, so we need to go from `SyntaxNode` to `string` for Roslyn to parse anyway.\r\n- We have a few places where we produce invalid syntax nodes because writing out the truly accurate node is a pain (in particular type names).\r\n- We never did the code-fix reuse idea and I doubt we\u0027ll ever do so (and we can\u0027t without additional work due to the above item).\r\n\r\nAdditionally, the Roslyn team recommends using a `string`-based approach.\r\n\r\nFinally, @Sergio0694 updated ComputeSharp to use an \"indented text writer\" approach and saw a ~460x performance improvement in CPU time and a ~36x Memory footprint improvement. Even if we only get a fraction of that improvement due to our desire to have an extensibility model, doing the work to rewrite the APIs seems worthwhile.\r\n\r\nAdditionally, with that amount of improvement, we may also see build-time improvements for assemblies with lots of `LibraryImport`s, such as CoreLib.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHObnjewQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5uVa50",
                                           "createdAt":  "2023-12-12T00:24:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nSince the start of the interop source generators, we\u0027ve always decided to use Roslyn `SyntaxNode`s as both our source-of-truth as well as our go-to emit strategy. This choice has provided us a number of benefits:\r\n\r\n- C# constructs are represented the same way as the C# compiler represents them.\r\n- We can easily define an API surface that specifies \"this API returns a name/expression/statement\" without building our own type hierarchy.\r\n- We can copy tokens from the source of truth to our emitted code.\r\n- We never try emitting code that is only understood by Roslyn compilers newer than we can safely confirm we\u0027ll run against as the APIs don\u0027t exist.\r\n- We could reuse the code in a code-fix to inline the source-generated code.\r\n\r\nHowever, it has also lead to a number of problems:\r\n\r\n- The SyntaxFactory APIs are very verbose. We\u0027ve basically had to add comments above each block to explain what the code is doing.\r\n- `NormalizeWhitespace` (what we use to handle adding whitespace) is extremely slow.\r\n- We have at times accidentally added additional GC roots to the `SyntaxNode`s in the source `SyntaxTree`s due to how we structure some of our internal data types.\r\n- The source generator API surface requires us to pass strings to Roslyn, so we need to go from `SyntaxNode` to `string` for Roslyn to parse anyway.\r\n- We have a few places where we produce invalid syntax nodes because writing out the truly accurate node is a pain (in particular type names).\r\n- We never did the code-fix reuse idea and I doubt we\u0027ll ever do so (and we can\u0027t without additional work due to the above item).\r\n\r\nAdditionally, the Roslyn team recommends using a `string`-based approach.\r\n\r\nFinally, @Sergio0694 updated ComputeSharp to use an \"indented text writer\" approach and saw a ~460x performance improvement in CPU time and a ~36x Memory footprint improvement. Even if we only get a fraction of that improvement due to our desire to have an extensibility model, doing the work to rewrite the APIs seems worthwhile.\r\n\r\nAdditionally, with that amount of improvement, we may also see build-time improvements for assemblies with lots of `LibraryImport`s, such as CoreLib.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejkoritzinsky\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `source-generator`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-12-12T00:24:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5uVfLk",
                                           "createdAt":  "2023-12-12T00:46:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Sergio0694",
                                           "body":  "Love it! For context, [here\u0027s my `IndentedTextWriter`](https://github.com/Sergio0694/ComputeSharp/blob/main/src/ComputeSharp.SourceGeneration/Helpers/IndentedTextWriter.cs), if you want to reuse or adapt this for the interop generators. It also has a couple of interpolated string handlers included (I\u0027d imagine you already have polyfills for the necessary types, but if not you can either just link them from corelib or perhaps use PolySharp) 🙂",
                                           "updatedAt":  "2023-12-12T00:46:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5uVjAU",
                                           "createdAt":  "2023-12-12T01:06:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "FWIW, the regex generator has been using the built-in IndentedTextWriter and it\u0027s worked fine.\r\nhttps://github.com/dotnet/runtime/blob/0fae364617f03d1003af0f0b49e57876e51875d4/src/libraries/System.Text.RegularExpressions/gen/RegexGenerator.cs#L106",
                                           "updatedAt":  "2023-12-12T01:06:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ueN7B",
                                           "createdAt":  "2023-12-13T07:45:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "In case if anyone is unaware, there is also an indented string builder proposed at roslyn side: https://github.com/dotnet/roslyn/issues/71162",
                                           "updatedAt":  "2023-12-13T07:45:35Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Generate strings instead of Roslyn SyntaxNodes in interop source generators",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "source-generator"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/95885",
        "createdAt":  "2023-12-12T00:38:37Z",
        "number":  95885,
        "author":  "jkoritzinsky",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC0kuug==",
                          "nodes":  [
                                        {
                                            "content":  "HEART",
                                            "user":  "huoyaoyuan",
                                            "createdAt":  "2023-12-12T04:41:31Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-01-02T22:32:21Z",
        "body":  "Today, Microsoft.Interop.SourceGeneration contains all of the shared logic for building interop source generators. However, we generally consider the library to contain 3 types of components:\r\n\r\n1. Parse information out of Roslyn symbols into our own equatable data types.\r\n2. Provide useful APIs to generate interop stubs based on these equatable data types.\r\n3. Provide helpers for interacting with Roslyn source-generator APIs.\r\n\r\nOne desire I\u0027ve always had for Microsoft.Interop.SourceGeneration has been to ship it externally for people to use to build their own generators and automatically get support of in-box features if desired, like support for `CustomMarshaller`-based marshalling and marshalling of `GeneratedComInterface` types by default. Also, many interop code generators aren\u0027t source generators (see ClangSharpPInvokeGenerator, SharpGenTools, TerraFx, CsWinRT) and others that are generators use a non-C# source of truth (CsWin32). As a result, we\u0027ve tried to make part 2 above not depend on Roslyn-based inputs and make it possible to use the data types in parts 1 and 2 not require using the APIs in part 1.\r\n\r\nWith the work in #95882, we move part 2 away from referencing any Roslyn APIs. If we were to split these APIs into a separate assembly that doesn\u0027t depend on any Roslyn APIs, it would be easier to use these APIs from code generators (non-Roslyn-source-generators) that don\u0027t need or want to reference Roslyn.\r\n\r\nI think we should spilt Microsoft.Interop.SourceGeneration into two assemblies, one that contains parts 1 and 3 and a separate one that contains part 2. This also helps us work around https://github.com/dotnet/sdk/issues/35739 as we will avoid conflicting newer Microsoft.Interop.SourceGeneration assemblies with older ones with significantly different API surfaces (if we ship these APIs outside of dotnet/runtime).\r\n\r\nRelated: Roslyn recommends (and has analyzers that warn if otherwise) that assemblies that define analyzers should not reference the Workspace assemblies (which are used to define code-fixes). Currently, the interop generator assemblies violate this rule. We should consider splitting the interop generator assemblies as well for this case.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOblXa2Q==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5uVdrZ",
                                           "createdAt":  "2023-12-12T00:38:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nToday, Microsoft.Interop.SourceGeneration contains all of the shared logic for building interop source generators. However, we generally consider the library to contain 3 types of components:\r\n\r\n1. Parse information out of Roslyn symbols into our own equatable data types.\r\n2. Provide useful APIs to generate interop stubs based on these equatable data types.\r\n3. Provide helpers for interacting with Roslyn source-generator APIs.\r\n\r\nOne desire I\u0027ve always had for Microsoft.Interop.SourceGeneration has been to ship it externally for people to use to build their own generators and automatically get support of in-box features if desired, like support for `CustomMarshaller`-based marshalling and marshalling of `GeneratedComInterface` types by default. Also, many interop code generators aren\u0027t source generators (see ClangSharpPInvokeGenerator, SharpGenTools, TerraFx, CsWinRT) and others that are generators use a non-C# source of truth (CsWin32). As a result, we\u0027ve tried to make part 2 above not depend on Roslyn-based inputs and make it possible to use the data types in parts 1 and 2 not require using the APIs in part 1.\r\n\r\nWith the work in #95882, we move part 2 away from referencing any Roslyn APIs. If we were to split these APIs into a separate assembly that doesn\u0027t depend on any Roslyn APIs, it would be easier to use these APIs from code generators (non-Roslyn-source-generators) that don\u0027t need or want to reference Roslyn.\r\n\r\nI think we should spilt Microsoft.Interop.SourceGeneration into two assemblies, one that contains parts 1 and 3 and a separate one that contains part 2. This also helps us work around https://github.com/dotnet/sdk/issues/35739 as we will avoid conflicting newer Microsoft.Interop.SourceGeneration assemblies with older ones with significantly different API surfaces (if we ship these APIs outside of dotnet/runtime).\r\n\r\nRelated: Roslyn recommends (and has analyzers that warn if otherwise) that assemblies that define analyzers should not reference the Workspace assemblies (which are used to define code-fixes). Currently, the interop generator assemblies violate this rule. We should consider splitting the interop generator assemblies as well for this case.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejkoritzinsky\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `source-generator`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-12-12T00:38:40Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Split Microsoft.Interop.SourceGeneration API surface and interop source generator API surface into more assemblies",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "source-generator"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/96374",
        "createdAt":  "2023-12-30T21:17:36Z",
        "number":  96374,
        "author":  "alexrp",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODBJQ9w==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "neon-sunset",
                                            "createdAt":  "2023-12-30T21:49:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "huoyaoyuan",
                                            "createdAt":  "2023-12-31T01:57:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "saucecontrol",
                                            "createdAt":  "2023-12-31T19:20:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Takym",
                                            "createdAt":  "2023-12-31T21:22:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2024-01-01T00:00:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-01-02T14:37:04Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "smaillet",
                                            "createdAt":  "2025-04-12T22:34:37Z"
                                        }
                                    ],
                          "totalCount":  7
                      },
        "updatedAt":  "2024-02-12T23:18:14Z",
        "body":  "### Background and motivation\r\n\r\nIt\u0027s a fairly common pattern to have a type that contains a (potentially large) collection of P/Invoke declarations:\r\n\r\n```csharp\r\ninternal static partial class TerminalInterop\r\n{\r\n    private const string Library = \"Vezel.Cathode.Native\";\r\n\r\n    [LibraryImport(Library, EntryPoint = \"cathode_initialize\")]\r\n    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]\r\n    public static partial void Initialize();\r\n\r\n    [LibraryImport(Library, EntryPoint = \"cathode_driver_set_mode\")]\r\n    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]\r\n    public static partial TerminalResult DriverSetMode(bool raw, bool flush);\r\n\r\n    // ...\r\n}\r\n```\r\n\r\nRepeating the application of `UnmanagedCallConvAttribute` like this is tedious, noisy, and error-prone. It would be better if it could simply be applied once to the containing type.\r\n\r\n### API Proposal\r\n\r\n```diff\r\n namespace System.Runtime.InteropServices;\r\n\r\n-[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]\r\n+[AttributeUsage(AttributeTargets.Method | AttributeTargets.Class | AttributeTargets.Interface | AttributeTargets.Struct, AllowMultiple = false, Inherited = false)]\r\n public sealed class UnmanagedCallConvAttribute : Attribute\r\n {\r\n     // ...\r\n }\r\n```\r\n\r\nNote: If `UnmanagedCallConvAttribute` is applied to e.g. a class and a method within the class also has `UnmanagedCallConvAttribute`, the latter takes precedence.\r\n\r\n### API Usage\r\n\r\n```csharp\r\n[UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]\r\ninternal static partial class TerminalInterop\r\n{\r\n    private const string Library = \"Vezel.Cathode.Native\";\r\n\r\n    [LibraryImport(Library, EntryPoint = \"cathode_initialize\")]\r\n    public static partial void Initialize();\r\n\r\n    [LibraryImport(Library, EntryPoint = \"cathode_driver_set_mode\")]\r\n    public static partial TerminalResult DriverSetMode(bool raw, bool flush);\r\n\r\n    // ...\r\n}\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\n* Not sure if `AttributeTargets.Interface` makes sense. Does the P/Invoke source generator support P/Invokes inside partial interfaces? If so, it would probably be good to include it for consistency.\r\n* Does `AttributeTargets.Assembly` and/or `AttributeTargets.Module` make sense?\r\n\r\n### Risks\r\n\r\nThis needs both runtime and P/Invoke source generator work.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOb6UVcA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5vnb6s",
                                           "createdAt":  "2023-12-30T21:17:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nIt\u0027s a fairly common pattern to have a type that contains a (potentially large) collection of P/Invoke declarations:\r\n\r\n```csharp\r\ninternal static partial class TerminalInterop\r\n{\r\n    private const string Library = \"Vezel.Cathode.Native\";\r\n\r\n    [LibraryImport(Library, EntryPoint = \"cathode_initialize\")]\r\n    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]\r\n    public static partial void Initialize();\r\n\r\n    [LibraryImport(Library, EntryPoint = \"cathode_driver_set_mode\")]\r\n    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]\r\n    public static partial TerminalResult DriverSetMode(bool raw, bool flush);\r\n\r\n    // ...\r\n}\r\n```\r\n\r\nRepeating the application of `UnmanagedCallConvAttribute` like this is tedious, noisy, and error-prone. It would be better if it could simply be applied once to the containing type.\n\n### API Proposal\n\n```diff\r\n namespace System.Runtime.InteropServices;\r\n\r\n-[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]\r\n+[AttributeUsage(AttributeTargets.Method | AttributeTargets.Class | AttributeTargets.Interface | AttributeTargets.Struct, AllowMultiple = false, Inherited = false)]\r\n public sealed class UnmanagedCallConvAttribute : Attribute\r\n {\r\n     // ...\r\n }\r\n```\r\n\r\nNote: If `UnmanagedCallConvAttribute` is applied to e.g. a class and a method within the class also has `UnmanagedCallConvAttribute`, the latter takes precedence.\n\n### API Usage\n\n```csharp\r\n[UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]\r\ninternal static partial class TerminalInterop\r\n{\r\n    private const string Library = \"Vezel.Cathode.Native\";\r\n\r\n    [LibraryImport(Library, EntryPoint = \"cathode_initialize\")]\r\n    public static partial void Initialize();\r\n\r\n    [LibraryImport(Library, EntryPoint = \"cathode_driver_set_mode\")]\r\n    public static partial TerminalResult DriverSetMode(bool raw, bool flush);\r\n\r\n    // ...\r\n}\r\n```\r\n\n\n### Alternative Designs\n\nNot sure if `AttributeTargets.Interface` makes sense. Does the P/Invoke source generator support P/Invokes inside partial interfaces? If so, it would probably be good to include it for consistency.\n\n### Risks\n\nThis needs both runtime and P/Invoke source generator work.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ealexrp\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Runtime.InteropServices`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-12-30T21:17:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5vpA57",
                                           "createdAt":  "2023-12-31T19:31:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tfenise",
                                           "body":  "If I understand the [documentation](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.unmanagedcallconvattribute?view=net-8.0#remarks) of `UnmanagedCallConvAttribute` correctly, with this API proposal,\r\n\r\n```\r\n[UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]\r\nstatic class Interop\r\n{\r\n    //...\r\n\r\n    [DllImport(\"user32.dll\", CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode)]\r\n    internal static extern int MessageBox(IntPtr hWnd, String text, String caption, uint type);\r\n\r\n    //...\r\n}\r\n```\r\n\r\nthe P/Invoke would surprisingly break due to calling convention mismatch, despite the \"explicitly\" specified `CallingConvention = CallingConvention.Winapi`, which unfortunately happens to be the default calling convention, so `[UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]` takes precedence.",
                                           "updatedAt":  "2023-12-31T19:31:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5vpJSG",
                                           "createdAt":  "2023-12-31T23:42:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "I get the underlying reason for this suggestion and am generally sympathetic. This would create a fair bit of additional complexity though during lookup (for example, nested classes) and I\u0027m not sure the benefit of this feature to the broader community - which would generally increase the priority.\r\n\r\nI\u0027ll move this to Future for now and lets see how much interest is generated.",
                                           "updatedAt":  "2023-12-31T23:42:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5vpJUw",
                                           "createdAt":  "2023-12-31T23:42:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "/cc @lambdageek ",
                                           "updatedAt":  "2023-12-31T23:42:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5vpQBS",
                                           "createdAt":  "2024-01-01T01:14:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e This needs both runtime and P/Invoke source generator work.\r\n\r\nThe defaults can be applied by the source generator. I do not think we would want to complicate runtime with it. Also, you do not have to stop with types. It costs very little to allow it at assembly level too.\r\n\r\n`DefaultCharSetAttribute` solved similar problem for built-in interop. It is recognized by the compiler and sets the default that the C#/VB compilers use.",
                                           "updatedAt":  "2024-01-01T01:14:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5vpQ6i",
                                           "createdAt":  "2024-01-01T01:23:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "alexrp",
                                           "body":  "\u003e The defaults can be applied by the source generator. I do not think we would want to complicate runtime with it.\r\n\r\nMy only concern with this would be a degraded experience for code using `[DllImport]`, but on the whole, I\u0027d be fine with that compromise.\r\n\r\n\u003e Also, you do not have to stop with types. It costs very little to allow it at assembly level too.\r\n\r\nI thought about it when writing the proposal, but it seems a bit spooky to have such an important aspect of a P/Invoke declaration potentially hidden away in `AssemblyInfo.cs` (or whatever), so I didn\u0027t include it. I\u0027m agnostic on this though.",
                                           "updatedAt":  "2024-01-01T01:23:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5vpRVw",
                                           "createdAt":  "2024-01-01T01:27:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "alexrp",
                                           "body":  "\u003e If I understand the [documentation](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.unmanagedcallconvattribute?view=net-8.0#remarks) of `UnmanagedCallConvAttribute` correctly, with this API proposal,\r\n\u003e \r\n\u003e ```\r\n\u003e [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]\r\n\u003e static class Interop\r\n\u003e {\r\n\u003e     //...\r\n\u003e \r\n\u003e     [DllImport(\"user32.dll\", CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode)]\r\n\u003e     internal static extern int MessageBox(IntPtr hWnd, String text, String caption, uint type);\r\n\u003e \r\n\u003e     //...\r\n\u003e }\r\n\u003e ```\r\n\u003e \r\n\u003e the P/Invoke would surprisingly break due to calling convention mismatch, despite the \"explicitly\" specified `CallingConvention = CallingConvention.Winapi`, which unfortunately happens to be the default calling convention, so `[UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]` takes precedence.\r\n\r\nThis is a good point. That said, it\u0027s probably just generally a bad idea to mix the old `CallingConvention` enum with the new attribute-based calling conventions. I think it would be fairly straightforward for the P/Invoke source generator to diagnose cases like this.",
                                           "updatedAt":  "2024-01-01T01:27:57Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "[API Proposal]: Allow `UnmanagedCallConvAttribute` on types for less noisy P/Invoke declarations",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/96502",
        "createdAt":  "2024-01-04T18:55:27Z",
        "number":  96502,
        "author":  "jkoritzinsky",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODLRRMg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "weltkante",
                                            "createdAt":  "2024-01-05T17:34:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "snechaev",
                                            "createdAt":  "2024-01-09T11:31:03Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "thorntonryan",
                                            "createdAt":  "2024-01-16T20:51:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "govert",
                                            "createdAt":  "2024-01-24T09:32:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "bizouarn",
                                            "createdAt":  "2024-01-30T21:59:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Aytackydln",
                                            "createdAt":  "2024-03-03T15:16:42Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-05-21T16:15:31Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MrJul",
                                            "createdAt":  "2024-07-12T15:39:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "zxbmmmmmmmmm",
                                            "createdAt":  "2025-08-14T18:15:13Z"
                                        }
                                    ],
                          "totalCount":  9
                      },
        "updatedAt":  "2025-09-19T13:52:18Z",
        "body":  "In MIDL, developers can define methods that refer to properties in COM by attributing methods with particular signatures with the `propget`, `propput`, or `propputref` attributes. In built-in COM marshalling, .NET properties defined on a `ComVisible(true)` interface are turned into two slots on a vtable, a `propget` getter method and a `propput` setter method. For `ComImport` types imported with TLBImp, .NET properties are synthesized for `propget` and `propput` or `propputref` methods.\r\n\r\n\u003e [!NOTE]\r\n\u003e If the property type is `object`, TLBs generated for a built-in .NET interface generate a `propputref` attribute instead of a `propput` attribute.\r\n\r\nCurrently, we block `GeneratedComInterface` interfaces from defining properties. We should look at providing support for properties in a similar way to the built-in .NET support for IUnknown-based interfaces.\r\n\r\nWe should consider introducing a feature to support specifying that particular methods provide the getter/setter implementation for a property as there is no restriction in COM that the propget and propput methods are sequential in the interface declaration (TLBImp supports defining a property that points to non-sequentially defined methods, but C# doesn\u0027t have a mechanism for it). Such a mechanism could be as simple as \"define a default implementation of the property that calls the methods\" and teach the COM source generator to ignore methods/properties that have default implementations.\r\n\r\nContributes to https://github.com/dotnet/runtime/issues/66674",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOxW2NeQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5v6fZy",
                                           "createdAt":  "2024-01-04T18:55:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nIn MIDL, developers can define methods that refer to properties in COM by attributing methods with particular signatures with the `propget`, `propput`, or `propputref` attributes. In built-in COM marshalling, .NET properties defined on a `ComVisible(true)` interface are turned into two slots on a vtable, a `propget` getter method and a `propput` setter method. For `ComImport` types imported with TLBImp, .NET properties are synthesized for `propget` and `propput` or `propputref` methods.\r\n\r\n\u003e [!NOTE]\r\n\u003e If the property type is `object`, TLBs generated for a built-in .NET interface generate a `propputref` attribute instead of a `propput` attribute.\r\n\r\nCurrently, we block `GeneratedComInterface` interfaces from defining properties. We should look at providing support for properties in a similar way to the built-in .NET support for IUnknown-based interfaces.\r\n\r\nWe should consider introducing a feature to support specifying that particular methods provide the getter/setter implementation for a property as there is no restriction in COM that the propget and propput methods are sequential in the interface declaration (TLBImp supports defining a property that points to non-sequentially defined methods, but C# doesn\u0027t have a mechanism for it). Such a mechanism could be as simple as \"define a default implementation of the property that calls the methods\" and teach the COM source generator to ignore methods/properties that have default implementations.\r\n\r\nContributes to https://github.com/dotnet/runtime/issues/66674\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejkoritzinsky\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `source-generator`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-01-04T18:55:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6aIL1n",
                                           "createdAt":  "2025-01-12T17:08:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "StarRiver123",
                                           "body":  "Does it Works in AOT?\n",
                                           "updatedAt":  "2025-01-12T17:08:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6bkKE_",
                                           "createdAt":  "2025-01-23T14:25:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "m-celikba",
                                           "body":  "@jkoritzinsky is there an ETA for the property support ?\nAt least for propget and propput this is something that is vastly used when wrapping native COM object.\nNot having property support is a breaking change when migrating to dotnet.\n\nI found out that I can just mimic what\u0027s done on the C++ side.\n\nThis works:\n```\n[GeneratedComInterface, Guid(\"..)]\npublic partial interface IMyItf\n{\n    double get_Value(); \n    void set_Value(double d);\n}\n```\n\nThis does not work:\n```\n[GeneratedComInterface, Guid(\"..)]\npublic partial interface IMyItf\n{\n    double Value { get; set; }\n}\n```\n\nIf we had [extension properties](https://github.com/dotnet/csharplang/discussions/5811) in c#, then this will be easier to fix.\n",
                                           "updatedAt":  "2025-01-23T14:25:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7FbY15",
                                           "createdAt":  "2025-09-19T13:52:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEjCRQg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "snechaev",
                                                                               "createdAt":  "2025-09-19T13:55:44Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "snechaev",
                                                                               "createdAt":  "2025-09-19T13:55:45Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "m-celikba",
                                           "body":  "FYI: I\u0027ve had success with this using extension properties from c#14 in dotnet10.\n\n```\n[GeneratedComInterface, Guid(\"..)]\npublic partial interface IMyItf\n{\n    double get_Value(); \n    void set_Value(double d);\n}\n\n public static class IMyItfExtensions\n {\n     extension(IMyItf arg)\n     {\n         public double Value\n         {\n             get =\u003e arg.get_Value();\n             set =\u003e arg.set_Value(value);\n         }\n     }\n }\n```\n\nThis provides portable code when migrating from dotnet framework builtin interop.\n\nThe only thing missing are indexers because the feature didn\u0027t make it to c#14.\nIndexers appear when using IDispatch interfaces that expose collections.\n\nexample\n// idl file\n```\n[object, uuid(..), dual, pointer_default(unique)]\ninterface IMyObjCollection : IDispatch\n{\n  [propget, id(DISPID_VALUE)] HRESULT Item([in] int index, [out, retval] IMyObj **ppVal);  \n  [propput, id(DISPID_VALUE)] HRESULT Item([in] int index, [in]IMyObj pdVal);\n}\n```\n\n// c# interop\n```\n[GeneratedComInterface, Guid(\"...\")]\npublic partial interface IMyObjCollection : IDispatch\n{\n    IMyObj get_Item(int index);\n    void set_Item(int index, IMyObj newVal);\n}\n```\n\nusage should be (because that\u0027s how it was in net framework):\n```\nIMyObjCollection coll = ...;\ncoll[1] = ...; // call set_Item using indexer\nConsole.WriteLine($\"{coll[1]}\");  // call get_Item using indexer\n```\n\n@jkoritzinsky @jtschuster @AaronRobinsonMSFT \n\n",
                                           "updatedAt":  "2025-09-19T13:52:18Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Property support in `[GeneratedComInterface]` interfaces",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "source-generator"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/96720",
        "createdAt":  "2024-01-09T22:24:48Z",
        "number":  96720,
        "author":  "jkoritzinsky",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC4DhhA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "thorntonryan",
                                            "createdAt":  "2024-01-16T20:51:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "govert",
                                            "createdAt":  "2024-01-24T09:33:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-05-21T17:47:36Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2024-12-20T09:23:09Z",
        "body":  "As mentioned in https://github.com/dotnet/runtime/issues/66674#issuecomment-1856072113, there\u0027s customer desire for support for Dual interfaces in NativeAOT scenarios. Dual interfaces are IDispatch-derived interfaces that also include vtable entries after the IDispatch entries. The .NET runtime has historically invoked members on Dual interfaces via their vtable entries as that is significantly more efficient.\r\n\r\nI propose that we add support for consuming Dual interfaces in the COM source generator though the vtable entries without adding any special support for IDispatch. This would also consumers of these APIs to move to using source-generated COM and supporting NativeAOT.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOmGKd7w==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5wSgCg",
                                           "createdAt":  "2024-01-09T22:24:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nAs mentioned in https://github.com/dotnet/runtime/issues/66674#issuecomment-1856072113, there\u0027s customer desire for support for Dual interfaces in NativeAOT scenarios. Dual interfaces are IDispatch-derived interfaces that also include vtable entries after the IDispatch entries. The .NET runtime has historically invoked members on Dual interfaces via their vtable entries as that is significantly more efficient.\r\n\r\nI propose that we add support for consuming Dual interfaces in the COM source generator though the vtable entries without adding any special support for IDispatch. This would also consumers of these APIs to move to using source-generated COM and supporting NativeAOT.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejkoritzinsky\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `untriaged`, `source-generator`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-01-09T22:24:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wSgL6",
                                           "createdAt":  "2024-01-09T22:25:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "cc: @awakecoding would this proposal address being able to easily consume the RDP ActiveX API surface?",
                                           "updatedAt":  "2024-01-09T22:25:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wSkdx",
                                           "createdAt":  "2024-01-09T22:43:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD_w-HQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "StarRiver123",
                                                                               "createdAt":  "2024-12-20T09:21:30Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "awakecoding",
                                           "body":  "There is one big problem we\u0027ve identified in https://github.com/Devolutions/MsRdpEx/issues/97 - the old generated COM Interop produces C# accessors over IDispatch properties using MSIL, and there is no way to do the same in C# code. Interface definitions in C# code can\u0027t easily fix the problem, we\u0027re stuck being unable to provide source compatibility between the old COM Interop and the new as a result of this limitation.",
                                           "updatedAt":  "2024-01-09T22:43:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wSnYn",
                                           "createdAt":  "2024-01-09T22:55:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "We\u0027re looking at addressing the properties support with #96502. Can you share an example of the IL that we can\u0027t represent in C#? Is it the case where the accessors aren\u0027t in the right order or is it something else?",
                                           "updatedAt":  "2024-01-09T22:55:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wSyRa",
                                           "createdAt":  "2024-01-09T23:50:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "@JeremyKuhne since WinForms is the primary owner of the ActiveX experience in .NET, we wanted to get some input from you. What\u0027s the current experience with ActiveX and user code today?",
                                           "updatedAt":  "2024-01-09T23:50:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wTpgm",
                                           "createdAt":  "2024-01-10T05:07:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "JeremyKuhne",
                                           "body":  "@jkoritzinsky I\u0027m not sure exactly what you\u0027re asking for, can you elaborate?",
                                           "updatedAt":  "2024-01-10T05:07:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5yTFuL",
                                           "createdAt":  "2024-01-30T18:04:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "@JeremyKuhne what\u0027s the UX today for .NET/COM interop in the ActiveX APIs in winforms today, in particular where users can override methods to provide implementations, in particular [AxHost.CreateInstanceCore](https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.axhost.createinstancecore?view=windowsdesktop-8.0#system-windows-forms-axhost-createinstancecore(system-guid))?\r\n\r\nFor example, if a user were to return an ComWrappers-based COM object here, would that work well?\r\n\r\nAlso, are there places where you implement dual-interfaces on types that you pass into COM APIs? If so, are those using CsWin32 or manually-written ComWrappers-based APIs?\r\n\r\nIn particular, I want to make sure that if we were to implement support for consuming a dual COM interface through the vtable-based API surface, that we wouldn\u0027t break WinForms or get in the way of your code (as the primary consumers of dual COM interfaces are ActiveX consumers).",
                                           "updatedAt":  "2024-01-30T18:04:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6YYp3v",
                                           "createdAt":  "2024-12-20T09:23:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "StarRiver123",
                                           "body":  "\u003e There is one big problem we\u0027ve identified in [Devolutions/MsRdpEx#97](https://github.com/Devolutions/MsRdpEx/issues/97) - the old generated COM Interop produces C# accessors over IDispatch properties using MSIL, and there is no way to do the same in C# code. Interface definitions in C# code can\u0027t easily fix the problem, we\u0027re stuck being unable to provide source compatibility between the old COM Interop and the new as a result of this limitation.\n\nHi, May I ask a question ?  Is There  any  way to use  other deverloper`s tlb file  in the nativeAot ?\n",
                                           "updatedAt":  "2024-12-20T09:23:07Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Provide ComObjectWrapper-only support for Dual COM interfaces",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "source-generator"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/96801",
        "createdAt":  "2024-01-10T19:11:12Z",
        "number":  96801,
        "author":  "ThadHouse",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-01-10T22:36:13Z",
        "body":  "I wanted to write a custom string marshaller that was generic across multiple of our libraries. They all have their own free() functions, so I wanted to inject a type to allow me to pass extra data to the marshaller.\r\n\r\n```csharp\r\n[CustomMarshaller(typeof(string), MarshalMode.ManagedToUnmanagedOut, typeof(LengthStringMarshaller\u003c,\u003e))]\r\n[ContiguousCollectionMarshaller]\r\npublic static unsafe class LengthStringMarshaller\u003cTFree, TUnmanagedElement\u003e where TUnmanagedElement : unmanaged\r\n                                                                            where TFree : ILengthStringFree\u003cTUnmanagedElement\u003e\r\n{\r\n    public static string AllocateContainerForManagedElements(TUnmanagedElement* unmanaged, int numElements)\r\n    {\r\n        if (unmanaged is null)\r\n            return \"\";\r\n\r\n        if (typeof(TUnmanagedElement) != typeof(byte))\r\n        {\r\n            throw new InvalidOperationException(\"TUnmanagedElement must be byte\");\r\n        }\r\n\r\n        string ret = Encoding.UTF8.GetString((byte*)unmanaged, numElements);\r\n        TFree.FreeString(unmanaged, numElements);\r\n        return ret;\r\n    }\r\n   ...\r\n}\r\n```\r\n\r\nI don\u0027t control either managed (string) or unmanaged (byte), so I can\u0027t attach the free function to either of those types using static interfaces. But this doesn\u0027t work, because the marshaller expects the generic arity to be N + 1 exactly. It expects that because NativeMarshallingAttribute requires N + 1\r\n\r\n Talking to @jkoritzinsky, this could be a case where we could downgrade that error to a warning assuming the managed type is non generic, and again downgrade from warning to nothing if the managed type is defined in another assembly.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOcGQSqw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5wZBKr",
                                           "createdAt":  "2024-01-10T19:49:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nI wanted to write a custom string marshaller that was generic across multiple of our libraries. They all have their own free() functions, so I wanted to inject a type to allow me to pass extra data to the marshaller.\r\n\r\n```\r\n[CustomMarshaller(typeof(string), MarshalMode.ManagedToUnmanagedOut, typeof(LengthStringMarshaller\u003c,\u003e))]\r\n[ContiguousCollectionMarshaller]\r\npublic static unsafe class LengthStringMarshaller\u003cTFree, TUnmanagedElement\u003e where TUnmanagedElement : unmanaged\r\n                                                                            where TFree : ILengthStringFree\u003cTUnmanagedElement\u003e\r\n{\r\n    public static string AllocateContainerForManagedElements(TUnmanagedElement* unmanaged, int numElements)\r\n    {\r\n        if (unmanaged is null)\r\n            return \"\";\r\n\r\n        if (typeof(TUnmanagedElement) != typeof(byte))\r\n        {\r\n            throw new InvalidOperationException(\"TUnmanagedElement must be byte\");\r\n        }\r\n\r\n        string ret = Encoding.UTF8.GetString((byte*)unmanaged, numElements);\r\n        TFree.FreeString(unmanaged, numElements);\r\n        return ret;\r\n    }\r\n   ...\r\n}\r\n```\r\n\r\nI don\u0027t control either managed (string) or unmanaged (byte), so I can\u0027t attach the free function to either of those types using static interfaces. But this doesn\u0027t work, because the marshaller expects the generic arity to be N + 1 exactly. It expects that because NativeMarshallingAttribute requires N + 1\r\n\r\n Talking to @jkoritzinsky, this could be a case where we could downgrade that error to a warning assuming the managed type is non generic, and again downgrade from warning to nothing if the managed type is defined in another assembly.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eThadHouse\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-01-10T19:49:16Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Downgrade arity error to warning in some cases for ContiguousCollectionMarshaller",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "code-analyzer"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/96820",
        "createdAt":  "2024-01-10T23:23:13Z",
        "number":  96820,
        "author":  "ThadHouse",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-03-29T21:17:11Z",
        "body":  "A lot of native array freeing API\u0027s take both the array pointer and length as parameters. These types of API\u0027s are difficult to use from LibraryImport source generators, because there\u0027s no easy way to pass the length to the Free() function called by the source generator. \r\n\r\nThe workaround currently is to use a Stateful marshaller, and store the length passed into GetUnmanagedValuesSource(), as the generated code immediately calls that after FromUnmanaged. But that depends on what seems like an internal source generator detail, and isn\u0027t clear.\r\n\r\nIt would be very nice if Free() for stateless source generators could take the length as an extra optional parameter, and if stateful source generators could receive the length in FromUnmanaged().",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOcHzm1Q==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5wfObV",
                                           "createdAt":  "2024-01-11T14:07:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nA lot of native array freeing API\u0027s take both the array pointer and length as parameters. These types of API\u0027s are difficult to use from LibraryImport source generators, because there\u0027s no easy way to pass the length to the Free() function called by the source generator. \r\n\r\nThe workaround currently is to use a Stateful marshaller, and store the length passed into GetUnmanagedValuesSource(), as the generated code immediately calls that after FromUnmanaged. But that depends on what seems like an internal source generator detail, and isn\u0027t clear.\r\n\r\nIt would be very nice if Free() for stateless source generators could take the length as an extra optional parameter, and if stateful source generators could receive the length in FromUnmanaged().\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eThadHouse\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-01-11T14:07:43Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Allow ContiguousCollectionMarshaller Free/FromUnmanaged to take length parameter",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/96886",
        "createdAt":  "2024-01-12T08:06:07Z",
        "number":  96886,
        "author":  "ThadHouse",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-03-29T21:17:23Z",
        "body":  "### Description\n\nWhen using a stateful native marshaller, all created temporary variables are initialized to default(). However, when using stateless, all variables are left uninitialized. This can result in unexpected behavior changes by the caller, especially if they change from stateful to stateless.\n\n### Reproduction Steps\n\n```\r\nusing System.Runtime.CompilerServices;\r\nusing System.Runtime.InteropServices;\r\nusing System.Runtime.InteropServices.Marshalling;\r\n\r\nnamespace CsCore.Natives;\r\n\r\n[NativeMarshalling(typeof(StatefulMarshaller))]\r\npublic enum StatefulEnum : int\r\n{\r\n}\r\n\r\n[NativeMarshalling(typeof(StatelessMarshaller))]\r\npublic enum StatelessEnum : int\r\n{\r\n}\r\n\r\n[CustomMarshaller(typeof(StatefulEnum), MarshalMode.ManagedToUnmanagedOut, typeof(StatefulMarshaller))]\r\npublic ref struct StatefulMarshaller {\r\n    public void FromUnmanaged(int unmanaged)\r\n    {\r\n        throw new System.NotImplementedException();\r\n    }\r\n\r\n    public StatefulEnum ToManaged()\r\n    {\r\n        throw new System.NotImplementedException();\r\n    }\r\n\r\n    public void Free()\r\n    {\r\n        throw new System.NotImplementedException();\r\n    }\r\n}\r\n\r\n[CustomMarshaller(typeof(StatelessEnum), MarshalMode.ManagedToUnmanagedOut, typeof(StatelessMarshaller))]\r\npublic static class StatelessMarshaller {\r\n    public static StatelessEnum ConvertToManaged(int unmanaged)\r\n    {\r\n        throw new System.NotImplementedException();\r\n    }\r\n}\r\n\r\npublic static unsafe partial class CsNative\r\n{\r\n    [LibraryImport(\"cscore\", EntryPoint = \"CS_GetPropertyKind\")]\r\n    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]\r\n    public static partial void Stateful(out StatefulEnum status);\r\n\r\n    [LibraryImport(\"cscore\", EntryPoint = \"CS_GetPropertyKind\")]\r\n    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]\r\n    public static partial void Stateless(out StatelessEnum status);\r\n}\r\n```\r\n\r\nCompile the above code, and review the generated output. __status_native, which is passed as a pointer into the P/Invoke is initialized to default for the stateful generator, and not initialized at all for the stateless generator.\n\n### Expected behavior\n\nI would expect these 2 to use the same type of initialization for the same variable generated between them. \n\n### Actual behavior\n\nOne is generated with initialization, one is not.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n.NET 8\n\n### Other information\n\nI noticed this because I had a scenario where I needed to ensure an `out` parameter was initialized to 0 because the native function required that, and was trying to find a method that did so. Switching to stateful did work, but adds a try catch and a ton of overhead that might not be worth it for my use case.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOcJH5aA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5wkflo",
                                           "createdAt":  "2024-01-12T08:06:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nWhen using a stateful native marshaller, all created temporary variables are initialized to default(). However, when using stateless, all variables are left uninitialized. This can result in unexpected behavior changes by the caller, especially if they change from stateful to stateless.\n\n### Reproduction Steps\n\n```\r\nusing System.Runtime.CompilerServices;\r\nusing System.Runtime.InteropServices;\r\nusing System.Runtime.InteropServices.Marshalling;\r\n\r\nnamespace CsCore.Natives;\r\n\r\n[NativeMarshalling(typeof(StatefulMarshaller))]\r\npublic enum StatefulEnum : int\r\n{\r\n}\r\n\r\n[NativeMarshalling(typeof(StatelessMarshaller))]\r\npublic enum StatelessEnum : int\r\n{\r\n}\r\n\r\n[CustomMarshaller(typeof(StatefulEnum), MarshalMode.ManagedToUnmanagedOut, typeof(StatefulMarshaller))]\r\npublic ref struct StatefulMarshaller {\r\n    public void FromUnmanaged(int unmanaged)\r\n    {\r\n        throw new System.NotImplementedException();\r\n    }\r\n\r\n    public StatefulEnum ToManaged()\r\n    {\r\n        throw new System.NotImplementedException();\r\n    }\r\n\r\n    public void Free()\r\n    {\r\n        throw new System.NotImplementedException();\r\n    }\r\n}\r\n\r\n[CustomMarshaller(typeof(StatelessEnum), MarshalMode.ManagedToUnmanagedOut, typeof(StatelessMarshaller))]\r\npublic static class StatelessMarshaller {\r\n    public static StatelessEnum ConvertToManaged(int unmanaged)\r\n    {\r\n        throw new System.NotImplementedException();\r\n    }\r\n}\r\n\r\npublic static unsafe partial class CsNative\r\n{\r\n    [LibraryImport(\"cscore\", EntryPoint = \"CS_GetPropertyKind\")]\r\n    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]\r\n    public static partial void Stateful(out StatefulEnum status);\r\n\r\n    [LibraryImport(\"cscore\", EntryPoint = \"CS_GetPropertyKind\")]\r\n    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]\r\n    public static partial void Stateless(out StatelessEnum status);\r\n}\r\n```\r\n\r\nCompile the above code, and review the generated output. __status_native, which is passed as a pointer into the P/Invoke is initialized to default for the stateful generator, and not initialized at all for the stateless generator.\n\n### Expected behavior\n\nI would expect these 2 to use the same type of initialization for the same variable generated between them. \n\n### Actual behavior\n\nOne is generated with initialization, one is not.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n.NET 8\n\n### Other information\n\nI noticed this because I had a scenario where I needed to ensure an `out` parameter was initialized to 0 because the native function required that, and was trying to find a method that did so. Switching to stateful did work, but adds a try catch and a ton of overhead that might not be worth it for my use case.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eThadHouse\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-01-12T08:06:18Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Stateless vs Stateful LibraryImport native marshaller initialize backing variables differently",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/97435",
        "createdAt":  "2024-01-24T05:40:41Z",
        "number":  97435,
        "author":  "ThadHouse",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-06-20T18:14:08Z",
        "body":  "### Description\r\n\r\nWhen using a stateful interop marshaller, there is no way to make both the managed and unmanaged side a reference or a pointer. The only way to make the marshaller happy is to have either the managed input or unmanaged output be a byvalue copy.\r\n\r\nSay I have the following interop signature (RefNetworkTableValue is a large ref struct, and is a `const NativeNetworkTableValue*` on the C side)\r\n\r\n```csharp\r\n[LibraryImport(\"ntcore\", EntryPoint = \"NT_SetEntryValue\")]\r\n[UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]\r\ninternal static unsafe partial void SetEntryValueIn(in RefNetworkTableValue value);\r\n```\r\n\r\nThat is required to have the following marshaller shape for a stateful marshaller\r\n\r\n```csharp\r\n[CustomMarshaller(typeof(RefNetworkTableValue), MarshalMode.ManagedToUnmanagedIn, typeof(RefNetworkTableValueMarshaller))]\r\npublic unsafe ref struct RefNetworkTableValueMarshaller\r\n{\r\n    public void FromManaged(in RefNetworkTableValue managed) {...}\r\n\r\n    public NativeNetworkTableValue ToUnmanaged() {...}\r\n\r\n    public void Free() {...}\r\n}\r\n```\r\n\r\nNote that the ToUnmanaged call returns `NativeNetworkTableValue` by value. I can\u0027t make it return a ref, as the marshaller is not happy about that. Additionally, I can\u0027t make it return a `NativeNetworkTableValue*`, as that makes the signature on the generated end `const NativeNetworkTableValue**`, which is incorrect.\r\n\r\nIf I change the initial call to not be an `in`, as follows\r\n\r\n```csharp\r\n[LibraryImport(\"ntcore\", EntryPoint = \"NT_SetEntryValue\")]\r\n[UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]\r\ninternal static unsafe partial void SetEntryValueIn(RefNetworkTableValue value);\r\n```\r\n\r\nThen my generator is can return a pointer from `ToUnmanaged`, but there\u0027s now a copy of a large struct on the input side.\r\n\r\n```csharp\r\n[CustomMarshaller(typeof(RefNetworkTableValue), MarshalMode.ManagedToUnmanagedIn, typeof(RefNetworkTableValueMarshaller))]\r\npublic unsafe ref struct RefNetworkTableValueMarshaller\r\n{\r\n    public void FromManaged(in RefNetworkTableValue managed) {...}\r\n\r\n    public NativeNetworkTableValue* ToUnmanaged() {...}\r\n\r\n    public void Free() {...}\r\n}\r\n```\r\n\r\nAdditionally, at least in my case, ToUnmanaged is likely too large of a function to be inlined, and I don\u0027t suspect the JIT would work around this issue in a different way.\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOci2jrw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5x-c-q",
                                           "createdAt":  "2024-01-26T14:54:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\nWhen using a stateful interop marshaller, there is no way to make both the managed and unmanaged side a reference or a pointer. The only way to make the marshaller happy is to have either the managed input or unmanaged output be a byvalue copy.\r\n\r\nSay I have the following interop signature (RefNetworkTableValue is a large ref struct, and is a `const NativeNetworkTableValue*` on the C side)\r\n\r\n```\r\n[LibraryImport(\"ntcore\", EntryPoint = \"NT_SetEntryValue\")]\r\n[UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]\r\ninternal static unsafe partial void SetEntryValueIn(in RefNetworkTableValue value);\r\n```\r\n\r\nThat is required to have the following marshaller shape for a stateful marshaller\r\n\r\n```\r\n[CustomMarshaller(typeof(RefNetworkTableValue), MarshalMode.ManagedToUnmanagedIn, typeof(RefNetworkTableValueMarshaller))]\r\npublic unsafe ref struct RefNetworkTableValueMarshaller\r\n{\r\n    public void FromManaged(in RefNetworkTableValue managed) {...}\r\n\r\n    public NativeNetworkTableValue ToUnmanaged() {...}\r\n\r\n    public void Free() {...}\r\n}\r\n```\r\n\r\nNote that the ToUnmanaged call returns `NativeNetworkTableValue` by value. I can\u0027t make it return a ref, as the marshaller is not happy about that. Additionally, I can\u0027t make it return a `NativeNetworkTableValue*`, as that makes the signature on the generated end `const NativeNetworkTableValue**`, which is incorrect.\r\n\r\nIf I change the initial call to not be an `in`, as follows\r\n\r\n```\r\n[LibraryImport(\"ntcore\", EntryPoint = \"NT_SetEntryValue\")]\r\n[UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]\r\ninternal static unsafe partial void SetEntryValueIn(RefNetworkTableValue value);\r\n```\r\n\r\nThen my generator is can return a pointer from `ToUnmanaged`, but there\u0027s now a copy of a large struct on the input side.\r\n\r\n```\r\n[CustomMarshaller(typeof(RefNetworkTableValue), MarshalMode.ManagedToUnmanagedIn, typeof(RefNetworkTableValueMarshaller))]\r\npublic unsafe ref struct RefNetworkTableValueMarshaller\r\n{\r\n    public void FromManaged(in RefNetworkTableValue managed) {...}\r\n\r\n    public NativeNetworkTableValue* ToUnmanaged() {...}\r\n\r\n    public void Free() {...}\r\n}\r\n```\r\n\r\nAdditionally, at least in my case, ToUnmanaged is likely too large of a function to be inlined, and I don\u0027t suspect the JIT would work around this issue in a different way.\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eThadHouse\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `tenet-performance`, `untriaged`, `source-generator`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-01-26T14:54:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5x-e8W",
                                           "createdAt":  "2024-01-26T14:58:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "@ThadHouse I would avoid using `in` in most cases. It has very subtle semantics and in this case even if it is used I am guessing it will be spilled to the stack. I think `ref readonly` is more likely what you want - https://learn.microsoft.com/dotnet/csharp/language-reference/proposals/csharp-12.0/ref-readonly-parameters.\r\n\r\nCan you share the `RefNetworkTableValue` definition?",
                                           "updatedAt":  "2024-01-26T14:58:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5x-2Sv",
                                           "createdAt":  "2024-01-26T16:01:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODUsrBA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-01-30T17:40:26Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "ThadHouse",
                                           "body":  "Switching to ref readonly breaks the source generator. \r\n\r\n```\r\nCSC : error CS8785: Generator \u0027LibraryImportGenerator\u0027 failed to generate source. It will not contribute to the output and compilation errors may occur as a result. Exception was of type \u0027NotImplementedException\u0027 with message \u0027Support for some RefKind\u0027. [/Users/thadhouse/GitHub/wpilib/src/ntcore/ntcore.csproj]\r\n/Users/thadhouse/GitHub/wpilib/src/ntcore/Natives/NtCore.ClientServer.cs(16,39): error CS8795: Partial method \u0027NtCore.GetNetworkMode(NtInst)\u0027 must have an implementation part because it has accessibility modifiers. [/Users/thadhouse/GitHub/wpilib/src/ntcore/ntcore.csproj]\r\n```\r\n\r\nhttps://github.com/robotdotnet/WPILib/blob/rebuild/src/ntcore/RefNetworkTableValue.cs\r\nhttps://github.com/robotdotnet/WPILib/blob/rebuild/src/ntcore/Natives/RefNetworkTableValueMarshaller.cs\r\n\r\nAt most of the callsites I am using an rvalue, so in does actually seem correct.\r\n\r\nI also tried just a normal ref (not a ref readonly), by switching `MarshalMode.ManagedToUnmanagedIn` to `MarshalMode.ManagedToUnmanagedRef`, and that also broke the source generator. No matter what I do, and what shape I change the marshaller to, it tells me that type is not supported by the source generator. Although ref definitely doesn\u0027t work because I\u0027m passing rvalues.",
                                           "updatedAt":  "2024-01-26T16:12:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5yLaOv",
                                           "createdAt":  "2024-01-29T21:21:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "@ThadHouse Appreciate the concern here. Is there any way you can confirm noticing a performance impact? The runtime has a type of RVO that should generally avoid duplication - see https://github.com/dotnet/runtime/pull/64130. If you can confirm there are multiple copies I think it might be more appropriate to look at what the JIT can do.\r\n\r\nI\u0027m going to move this into Future for now.",
                                           "updatedAt":  "2024-01-29T21:21:42Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Stateful interop marshallers cannot be copy free on both managed and unmanaged side",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "tenet-performance",
                       "source-generator"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/99850",
        "createdAt":  "2024-01-26T00:10:02Z",
        "number":  99850,
        "author":  "silkfire",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC5yBrw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MitchRazga",
                                            "createdAt":  "2024-07-29T18:48:59Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-07-28T17:40:24Z",
        "body":  "### Analyzer\r\n\r\n**Diagnostic ID**: [SYSLIB1051](https://learn.microsoft.com/en-us/dotnet/fundamentals/syslib-diagnostics/syslib1050-1069)\r\n\r\n### Describe the improvement\r\n\r\nThe analyzer tells you if you\u0027re trying to marshal a `struct` whose fields are incompatible with the `LibraryImport` ([source generated P/Invoke](https://learn.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke-source-generation) added in .NET 7) attribute.\r\n\r\nIt would be extremely useful if the analyzer informed the developer which specific fields are incompatible for marshalling.\r\n\r\nRight now it just says `The type \u0027\u003cstruct type\u003e\u0027 is not supported by source-generated P/Invokes. The generated source will not handle marshalling of parameter \u0027pstruct\u0027.` If you remove the offending field(s) from the `struct`, the error goes away.\r\n\r\n### Describe suggestions on how to achieve the rule\r\n\r\nAdd to the description of the analyzer a list of let\u0027s say max 5 fields that are incompatible for marshalling. These are types that are not blittable, i.e. reference types, string, arrays and `bool`.\r\n\r\nJust as the current implementation, this should work recursively, i.e. be able to support nested structs; an unsupported field may be found in a deeper struct hierarchy but should still be reported.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOhohw-A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc53QhsX",
                                           "createdAt":  "2024-03-16T00:41:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-03-16T00:41:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GiHD4",
                                           "createdAt":  "2024-07-29T22:04:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODsBs2g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "silkfire",
                                                                               "createdAt":  "2024-07-29T22:07:07Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "Due to how we have structured our analysis engine, this is actually much more difficult to implement than it seems. (Our system is pluggable and more of an opt-in/\"determine type is marshallable\" model than an opt-out/\"determine type is unmarshallable\" model).\n\nMoving this to .NET 10 for now.",
                                           "updatedAt":  "2024-07-29T22:04:49Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Improve SYSLIB1051 by marking the fields that are incompatible with LibraryImport",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "source-generator"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/98265",
        "createdAt":  "2024-02-10T15:56:36Z",
        "number":  98265,
        "author":  "DemiMarie",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODDWUTQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "McPherran",
                                            "createdAt":  "2025-06-06T03:39:44Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-03-25T20:45:38Z",
        "body":  "`DllImport` is no longer recommended as it is unfriendly to tree shaking and requires extra runtime support.  The replacement is `LibraryImport`, but that requires a source generator that is only available to C#.  Therefore, languages like F# do not support it, and it is not clear how they should support it.\r\n\r\nThis is a request to document what the actual tree-shaking-friendly runtime primitive is, so that source language compilers know what code they need to emit.  This is a prerequisite for tree-shaking-friendly FFI in languages other than C#.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOc515Mw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5zdXht",
                                           "createdAt":  "2024-02-10T17:32:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @agocke, @sbomer, @vitek-karas\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n`DllImport` is no longer recommended as it is unfriendly to tree shaking and requires extra runtime support.  The replacement is `LibraryImport`, but that requires a source generator that is only available to C#.  Therefore, languages like F# do not support it, and it is not clear how they should support it.\r\n\r\nThis is a request to document what the actual tree-shaking-friendly runtime primitive is, so that source language compilers know what code they need to emit.  This is a prerequisite for tree-shaking-friendly FFI in languages other than C#.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eDemiMarie\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`untriaged`, `area-Tools-ILLink`, `needs-area-label`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-02-10T17:32:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5zeIbS",
                                           "createdAt":  "2024-02-10T22:21:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODWdprg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Joe4evr",
                                                                               "createdAt":  "2024-02-10T22:38:55Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ForNeVeR",
                                                                               "createdAt":  "2024-02-11T15:14:13Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-02-12T21:33:15Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "PaulusParssinen",
                                           "body":  "Using `DllImport` for the native interop logic itself is not the issue for trimming (term more commonly used for tree shaking in .NET) but the runtime generated marshalling logic that is enabled by default. The `LibraryImport` actually uses the `DllImport` -attribute under the hood in the source generated code but with blittable[^1] signature which requires no runtime marshalling.\r\n\r\nYou can also disable the runtime marshalling for `DllImport` with `DisableRuntimeMarshalling` -attribute or at project level in the .csproj with ``\u003cDisableRuntimeMarshalling\u003etrue\u003c/DisableRuntimeMarshalling\u003e``[^2]\r\n\r\nI recommend checking out following article for more information on the topic: \r\nhttps://learn.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke-source-generation\r\n\r\n[^1]: https://learn.microsoft.com/en-us/dotnet/framework/interop/blittable-and-non-blittable-types\r\n[^2]: https://learn.microsoft.com/en-us/dotnet/standard/native-interop/disabled-marshalling",
                                           "updatedAt":  "2024-02-10T22:21:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5zeg5Q",
                                           "createdAt":  "2024-02-11T01:04:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODnum6w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Szer",
                                                                               "createdAt":  "2024-02-11T15:37:55Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "rstm-sf",
                                                                               "createdAt":  "2024-02-11T16:35:12Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-06-28T22:57:20Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "EgorBo",
                                           "body":  "Still a fair point that features like this only improve C#. And F# still has to force runtime to generate the pinvoke stub in run time (for non-blittable signatures).",
                                           "updatedAt":  "2024-02-11T01:05:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5zeiAY",
                                           "createdAt":  "2024-02-11T01:25:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODWT_Eg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "huoyaoyuan",
                                                                               "createdAt":  "2024-02-11T02:22:12Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "vzarytovskii",
                                                                               "createdAt":  "2024-02-11T15:24:23Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "DemiMarie",
                                           "body":  "@EgorBo an alternative approach would be a generic solution that every source language could use.",
                                           "updatedAt":  "2024-02-11T01:25:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5zeoXm",
                                           "createdAt":  "2024-02-11T03:30:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODWVAQA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Joe4evr",
                                                                               "createdAt":  "2024-02-11T20:21:35Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "A good portion of the actual marshalling stuff that the `LibraryImport` generator uses is reusable by other languages\r\n\r\nSomeone particularly interested could write a tool that uses the relevant F# features to do the same thing there (such as using a `type provider`, which may not be the best way but is certainly a way).\r\n\r\nSimilarly, someone could extend existing tools, like https://github.com/dotnet/clangsharp, to support other language targets such F# (it currently supports C# and an XML based output format, and is loosely designed to support other languages if that were desired).\r\n\r\nThere isn\u0027t really such a thing as a generic solution here. Every language is pretty unique and while some core information might be reusable, the actual logic required to generate code per language can get quite specialized. Even in cases where you have a shared interface like Roslyn between C#/VB, you can still end up with a lot of non-reusable logic or handling to support the various quirks of each language.",
                                           "updatedAt":  "2024-02-11T03:30:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5zeoh1",
                                           "createdAt":  "2024-02-11T03:33:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "Note, most of the reusable stuff exists here now: https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshalling?view=net-8.0\r\n\r\nEach language still has to do some basics around recognizing the `LibraryImport` attribute, generating the corresponding `DllImport` and the basic marshalling logic. But the actual marshalling logic basically boils down to using these publicly exposed helper types and following the fairly straightforward logic to map from the user-defined signature to the blittable signature.",
                                           "updatedAt":  "2024-02-11T03:33:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5zeo13",
                                           "createdAt":  "2024-02-11T03:39:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "DemiMarie",
                                           "body":  "@tannergooding one alternative that works with _any_ language would be an IL ⇒ IL translator, which does the same thing the runtime would do except at compile time.",
                                           "updatedAt":  "2024-02-11T03:39:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5zepPK",
                                           "createdAt":  "2024-02-11T03:48:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODe34kw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Joe4evr",
                                                                               "createdAt":  "2024-02-11T20:21:37Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-04-19T21:37:45Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "`IL =\u003e IL` translator itself can have issues and may be non-portable.\r\n\r\nNot all IL features are supported by all languages. Transforming existing IL can subtly break sequence points or debugging, can easily lead to de-optimizations if they use patterns that aren\u0027t what one of the standard compilers emit, can break signing or other downstream tooling, may not integrate cleanly with the general build system or expectations, can increase the risk of bugs, increase build times, etc.\r\n\r\nNot to mention that it is functionally a \"black box\", meaning that you can no longer trivially view the generated code, step into it, modify it if necessary, learn from it as easily, etc.\r\n\r\nSource Generators do have their downsides, but overall they are one of the best directions you can go when you look at and consider all the upsides. The main downside is that each language may need to support the thing independently, but that is really a necessity for most features when you actually sit down and think about it. Almost any new or core runtime feature requires some kind of language integration, and source generators are really no different.",
                                           "updatedAt":  "2024-02-11T03:48:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5zepUm",
                                           "createdAt":  "2024-02-11T03:50:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "And notably, if the fact that source generators are going to be used is accounted for, one can provide reusable components (like the `System.Runtime.InteropServices.Marshalling` namespace) which makes it simpler for a language to support the functionality.\r\n\r\nEnough so that the primary concern they have it one around doing the basic recognition of the pattern and the selection of the language specific code they want to generate.",
                                           "updatedAt":  "2024-02-11T03:50:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5zgWDw",
                                           "createdAt":  "2024-02-11T20:20:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "neon-sunset",
                                           "body":  "\u003e DllImport is no longer recommended as it is unfriendly to tree shaking and requires extra runtime support.\r\n\r\n\u003e @tannergooding one alternative that works with _any_ language would be an IL ⇒ IL translator, which does the same thing the runtime would do except at compile time.\r\n\r\nThe `LibraryGenerator`-based P/Invokes are completely orthogonal to tree-shaking aka trimming done for AOT and certain JIT-based applications and/or libraries.\r\n\r\nThe reason it was replaced was two-fold: 1) runtime marshalling stub generation was old, brittle and resistant to (performance) improvements, effectively tech debt; 2) runtime marshalling relies on JIT and is therefore cannot be done during AOT. Therefore, `[LibraryImport]` that relies on source generation was made. Languages which target .NET can simply opt to generate P/Invokes in C# and easily call them directly without any subsequent work (except perhaps certain F# constructs) - after all, because everything is compiled down to IL, such methods can be transparently called from F#, VB.NET and smaller projects. In fact, there are many existing P/Invoke generators and nothing restricts anyone from consuming them from other .NET languages because of the common type system.\r\n\r\nIn addition, as others noted, some languages like F# have more advanced type/code generation features like type providers which can be extended to define `[DllImport]`s with blittable arguments and return types (signatures which do not require marshalling) to customize and tune the interop experience to their needs *if* there is a need to completely bypass using C#-related tooling.\r\n\r\nEven if some \"generic\" solution is introduced where the IL sequences are expanded by some build post-processing phase, the marshalling semantics can and will differ in each language resulting in a requirement for significant upfront work (for each language) to lower the representation to some simpler common denominator in IL, because IL does not and cannot know about types like F# unions or nullable structs in C# (both can be arguable special-cased, at the cost of violating the abstraction).",
                                           "updatedAt":  "2024-02-11T20:24:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5zh5D6",
                                           "createdAt":  "2024-02-12T08:58:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "I\u0027ll move this to area interop and change the title. There\u0027s no trimming issues with `DllImport` that `LibraryImport` would fix. `DllImport`s are trim-safe and in cases when they\u0027re not, `LibraryImport` doesn\u0027t help (things like AsAny marshalling that `LibraryImport` doesn\u0027t support). LibraryImport improves startup time and makes it possible to evolve interop support independently of runtime.\r\n\r\nI don\u0027t think the interop team has plans to abandon the advantages that source generators provide (ability to step through the generated code to troubleshoot incorrect p/invoke declarations) in favor of an IL to IL transformer.",
                                           "updatedAt":  "2024-02-12T08:58:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5znSv1",
                                           "createdAt":  "2024-02-12T22:11:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e There\u0027s no trimming issues with DllImport that LibraryImport would fix. DllImports are trim-safe and in cases when they\u0027re not, LibraryImport doesn\u0027t help (things like AsAny marshalling that LibraryImport doesn\u0027t support). \r\n\r\nLibraryImport  helps with detecting cases that do not work. If you use LibraryImport, you can be sure that it is trim and AOT compatible. If you use DllImport (w/o `DisableRuntimeMarshalling`), you have to be careful.",
                                           "updatedAt":  "2024-02-12T22:11:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5znXkz",
                                           "createdAt":  "2024-02-12T22:17:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "\u003e \u003e There\u0027s no trimming issues with DllImport that LibraryImport would fix. DllImports are trim-safe and in cases when they\u0027re not, LibraryImport doesn\u0027t help (things like AsAny marshalling that LibraryImport doesn\u0027t support).\r\n\u003e \r\n\u003e LibraryImport helps with detecting cases that do not work. If you use LibraryImport, you can be sure that it is trim and AOT compatible. If you use DllImport (w/o `DisableRuntimeMarshalling`), you have to be careful.\r\n\r\nIIRC we generate publish-time warnings whenever problematic cases are hit (which pretty much just means COM in the trimming case; I think even AsAny marshalling is going to \"just work\" with trimming).\r\n\r\nThen there are some DllImports that are problematic for AOT but not for trimming. Generating warnings for those is tracked in #74697.",
                                           "updatedAt":  "2024-02-12T22:17:47Z"
                                       }
                                   ],
                         "totalCount":  13
                     },
        "title":  "Support LibraryImport with non-C# languages",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "source-generator"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/98616",
        "createdAt":  "2024-02-17T19:02:19Z",
        "number":  98616,
        "author":  "DjArt",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODBBTng==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MitchRazga",
                                            "createdAt":  "2024-07-30T02:04:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DerPurp",
                                            "createdAt":  "2025-03-15T13:27:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "frederik-hoeft",
                                            "createdAt":  "2025-04-09T12:35:48Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2025-08-04T22:19:57Z",
        "body":  "### Description\r\n\r\nType defined in other assembly can\u0027t be marshalled.\r\n\r\n### Reproduction Steps\r\n\r\nDefine type in first library:\r\n\r\n```\r\npublic unsafe readonly struct Target\u003cTWrapper\u003e\r\n    where TWrapper : unmanaged\r\n{\r\n    public TWrapper Handler { get; init; }\r\n    public void* Target { get; init; }\r\n}\r\n```\r\n\r\nAnd define import in another:\r\n\r\n```\r\n    [LibraryImport(LIB_NAME, EntryPoint = \"SetHandler\"), UnmanagedCallConv(CallConvs = [typeof(CallConvStdcall)])]\r\n    public static partial void set_OnHandler(in Target\u003cHandler\u003e callback);\r\n```\r\n\r\n### Expected behavior\r\n\r\nSuccessful marshalling like that type was defined in one assembly.\r\n\r\n### Actual behavior\r\n\r\nError SYSLIB1051\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\n.NET 8.0\r\n\r\n### Other information\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOhbrfNA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc50Pvtp",
                                           "createdAt":  "2024-02-17T19:02:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nType defined in other assembly can\u0027t be marshalled.\n\n### Reproduction Steps\n\nDefine type in first library:\r\n\r\n```\r\npublic unsafe readonly struct Target\u003cTWrapper\u003e\r\n    where TWrapper : unmanaged\r\n{\r\n    public TWrapper Handler { get; init; }\r\n    public void* Target { get; init; }\r\n}\r\n```\r\n\r\nAnd define import in another:\r\n\r\n```\r\n    [LibraryImport(LIB_NAME, EntryPoint = \"SetHandler\"), UnmanagedCallConv(CallConvs = [typeof(CallConvStdcall)])]\r\n    public static partial void set_OnHandler(in Target\u003cHandler\u003e callback)\r\n```;\r\n\r\n\n\n### Expected behavior\n\nSuccessful marshalling like that type was defined in one assembly.\n\n### Actual behavior\n\nError SYSLIB1051\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eDjArt\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Runtime.InteropServices`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-02-17T19:02:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc50PwPL",
                                           "createdAt":  "2024-02-17T19:13:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "This is expected behavior. There\u0027s no way to guarantee that a type in a different assembly that currently doesn\u0027t have a bool or char field at build time will not have one at runtime as reference assemblies can differ from runtime assemblies, so a custom marshaller is required for the type.",
                                           "updatedAt":  "2024-02-17T19:13:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc50Ttx_",
                                           "createdAt":  "2024-02-18T13:23:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "DjArt",
                                           "body":  "But what if signing of a assembly will be a garanitue of type equality?",
                                           "updatedAt":  "2024-02-18T13:23:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc50T-gE",
                                           "createdAt":  "2024-02-18T17:33:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "Neither strong-name signing nor authenticode signing prevents switching out a ref assembly for a different assembly at runtime.\n\nIf you add the `DisableRuntimeMarshalling` attribute to your assembly with the LibraryImport method, then we allow unmanaged types from other assemblies as blittable types, no marshaller required. Can you give that a try?",
                                           "updatedAt":  "2024-02-18T17:33:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc54VasE",
                                           "createdAt":  "2024-03-25T20:43:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "This issue has been marked `needs-author-action` and may be missing some important information.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-03-25T20:43:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc543PRG",
                                           "createdAt":  "2024-03-29T21:18:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "@jkoritzinsky and @jtschuster Thoughts on providing a mechanism for tooling generated assemblies? We\u0027ve had a TlbImp scenario involving ValueTypes. Something to consider.",
                                           "updatedAt":  "2024-03-29T21:18:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc543gx2",
                                           "createdAt":  "2024-03-29T23:25:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jtschuster",
                                           "body":  "I think it makes sense to assume tooling-generated assemblies will have identical run-time and compile-time definitions.",
                                           "updatedAt":  "2024-03-29T23:25:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Fut80",
                                           "createdAt":  "2024-07-22T18:57:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODsCvkg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MitchRazga",
                                                                               "createdAt":  "2024-07-30T02:05:43Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "Given how late we are in .NET 9, I think we can get to this early in .NET 10.",
                                           "updatedAt":  "2024-07-22T18:57:22Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "SYSLIB1051 on parameter when type imported from other assembly",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/100747",
        "createdAt":  "2024-04-07T14:57:45Z",
        "number":  100747,
        "author":  "am11",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODDyEKw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "0xF6",
                                            "createdAt":  "2024-05-10T07:18:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "antoinebj",
                                            "createdAt":  "2024-09-08T00:03:03Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dp-sgr",
                                            "createdAt":  "2025-01-24T09:20:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ni4",
                                            "createdAt":  "2025-05-02T13:05:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "miroljub1995",
                                            "createdAt":  "2025-05-22T07:37:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "TSlivede",
                                            "createdAt":  "2025-06-12T20:01:06Z"
                                        }
                                    ],
                          "totalCount":  6
                      },
        "updatedAt":  "2025-05-02T13:20:51Z",
        "body":  "Methods decorated with `[UnmanagedCallersOnly(EntryPoint=\"export-name\")]` end up as exported symbols in published binary. Since ILC has all the required info related to method signatures and beyond, it can generate a plain C header file `{outputFileName}.h` with exported APIs accurately for user convenience.\r\n\r\nThe main work it entails is C# to C type mapping (`int`-\u003e`int32_t` etc. with `inttypes.h`, `stdbool.h` includes), generating enums and generating complex object graphs representation in terms of `struct`s. This feature can be enabled behind an optional project property `\u003cGenerateCHeaderFile\u003etrue`. Further customization may not required and ilc can be opinionated about the style choice  (e.g. all definitions stuffed in one header file).",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOqbSpxA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc55rsZx",
                                           "createdAt":  "2024-04-07T14:58:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @agocke, @MichalStrehovsky, @jkotas\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-04-07T14:58:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc55ryvN",
                                           "createdAt":  "2024-04-07T16:32:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "This applies to interop in all runtime form factors, it is not specific to native AOT. You can use https://github.com/AaronRobinsonMSFT/DNNE to generate this header file today.\r\n\r\n\u003e Further customization may not required\r\n\r\nCustomization is typically required for anything that is a bit more complex. Check the customizations implemented in DNNE https://github.com/AaronRobinsonMSFT/DNNE?tab=readme-ov-file#native-code-customization .",
                                           "updatedAt":  "2024-04-07T16:32:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc55r5Sf",
                                           "createdAt":  "2024-04-07T18:14:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "am11",
                                           "body":  "This could be a subset of DNNE (only for exports) implemented directly in runtime repo.\r\n\r\nIt may have higher demand in AOT realm (e.g. https://github.com/dotnet/runtime/pull/100623/files#diff-3dad50f2b179b16bb7f3856dba5f614fea3e838c65e710885f0fc17f989ac925); but if it can be done agnostic of form-factor, that would be better. Alternatively, since ILCompiler already looks for exports for other functionalities, it can be extended for this feature without expanding feature\u0027s scope.\r\n\r\nMethod / Type infos of exported APIs and their arguments to C will cover majority of the use-cases, and provide something functional for the rest without customization. e.g. overlapping `[FieldOffset]` decorated members that are part of exports graph to end up in C `union`. In best case, user can take the ilc generated shared lib and header file, and use it in their project without modifications. Otherwise, they can skip the header generation if they are using something else (existing header).",
                                           "updatedAt":  "2024-04-07T18:14:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc55r6O6",
                                           "createdAt":  "2024-04-07T18:22:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "@am11 I agree this does have utility and would address the generation of \"boilerplate\". Although I\u0027m not sure it is at a place where we should be providing it in-box. The vast majority of signatures, since they are unmanaged, are trivial to author and the flow of these unmanaged artifacts in the managed build system creates a burden that I have trouble justifying. I would also say that C header files might be the desire now, but this feature is ripe for complex feature creep. What about definitions in Rust? Swift? Should the header be pure C99 or fully C++ compliant? Where do these artifacts go in a NuGet package? Are they included in a publish action? The introduction of extra unmanaged concepts expand the matrix greatly and concerns me. I\u0027ve had a bunch of nits in DNNE that give me pause about making this feature a first-class in-box feature.",
                                           "updatedAt":  "2024-04-07T18:22:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc55sGv7",
                                           "createdAt":  "2024-04-07T20:49:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "am11",
                                           "body":  "\u003e What about definitions in Rust? Swift?\r\n\r\nIf consumer is using the native AOT generated objects in project written in language other than C/C++, they would still be able to use third-party tool to convert the generated C header file to the target language\u0027s equivalent representation. Today, they are collecting the entrypoints definitions and writing it manually, which is more laborious than having a flat C header file to work with.\r\n\r\n\u003e Should the header be pure C99 or fully C++ compliant?\r\n\r\nIt can support both simultaneously, e.g. `MyProject.API.h`:\r\n```c\r\n// This file is generated by .NET Native IL Compiler.\r\n\r\n#include \u003cinttypes.h\u003e\r\n#include \u003cstdbool.h\u003e\r\n\r\n#ifdef __cplusplus\r\nextern \"C\"\r\n{\r\n#endif\r\n\r\n// consts\r\n// enums\r\n// structs\r\n// methods\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n```\r\n\r\n\u003e Where do these artifacts go in a NuGet package? Are they included in a publish action?\r\n\r\nI think it can use the same plan as symbol files (.dbg, .pdb, .dSYM); only generated with `dotnet publish` and end up in `PublishDir` (next to the binary).",
                                           "updatedAt":  "2024-04-07T20:49:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc55sJBk",
                                           "createdAt":  "2024-04-07T21:26:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODhYbqg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "am11",
                                                                               "createdAt":  "2024-04-07T21:31:26Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "0xF6",
                                                                               "createdAt":  "2024-05-10T07:19:14Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e which is more laborious than having a flat C header file to work with.\r\n\r\nAgree. The push back I have, at least at the moment, is (a) about understanding how common the native AOT library scenario is going to be and then (b) the additional overhead/management for producing and handling unmanaged assets. If we get signal, I am currently working with the VS team to help get data for this very question, that the library is a non-trivial portion of native AOT scenarios then we can move onto (b) and understand how to manage those assets.\r\n\r\nFor now though, we need an indication that (a) is worth the investment in designing a solution for all that (b) is presently and will likely involve into. Per usual, getting community traction on this issue will also help provide signal with respect to (a).",
                                           "updatedAt":  "2024-04-07T21:26:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ptECs",
                                           "createdAt":  "2025-05-02T13:07:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ni4",
                                           "body":  "Do I correctly understand that this functionality is not available yet? As AI happily reports what to do with .csproj to achieve this goal :) Thanks!",
                                           "updatedAt":  "2025-05-02T13:07:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ptKnE",
                                           "createdAt":  "2025-05-02T13:20:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEQlG8A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ni4",
                                                                               "createdAt":  "2025-05-02T13:22:13Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "It is available via https://www.nuget.org/packages/DNNE NuGet package. It is not built-in into .NET SDK. ",
                                           "updatedAt":  "2025-05-02T13:20:50Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Ability to generate header file from exports",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/100896",
        "createdAt":  "2024-04-10T23:06:18Z",
        "number":  100896,
        "author":  "jkoritzinsky",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC-Ij7A==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hamarb123",
                                            "createdAt":  "2024-04-11T11:09:42Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-04-11T23:04:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jkurdek",
                                            "createdAt":  "2025-01-14T16:52:30Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2025-08-14T16:45:47Z",
        "body":  "### Background and motivation\r\n\r\n.NET\u0027s struct layout system is quite extensive, but there are still some cases it does not cover that are relevant in interop scenarios at the language/runtime boundary.\r\n\r\nIn particular, we\u0027ve seen requests for features like\r\n\r\n- [explicit alignment requirements](https://github.com/dotnet/runtime/issues/9089)\r\n- .NET support for a mechanism like Rust\u0027s `repr(transparent)`\r\n\r\nWith Swift Interop, we have a need to [represent generic structs with correct Swift layouts](https://github.com/dotnet/runtime/issues/100543#issuecomment-2037276407), but we don\u0027t have a way to represent the Swift layout accurately in the general case. In the non-general case, we can represent it with an explicit `StructLayout.Size` element, but we can\u0027t do that for generics.\r\n\r\nFor all of these cases, we\u0027d like to extend the `StructLayoutAttribute` to handle these cases. However, we can\u0027t extend that attribute as it\u0027s a pseudo-attribute that maps directly to metadata. Instead, we propose adding a new attribute, only usable on struct types, that\u0027s intended to encompass all future layout features, as well as the existing layout features provided by `StructLayoutAttribute`. \r\n\r\nAs part of the implementation, we plan to introduce a simple source-generator to generate the corresponding `StructLayoutAttribute` on the type that has our new attribute applied. To ensure that we don\u0027t accidentally make types non-blittable, we\u0027ll lower the attribute such that `CharSet = CharSet.Unicode` in all cases.\r\n\r\nIn the future, we may extend this attribute to also be the \"trigger\" attribute for an interop source generator to generate a marshaller for a given struct type.\r\n\r\nTo limit the scope of this feature, we plan to start with only the feature required by Swift interop:\r\n\r\n- Provide a mechanism to not include trailing padding in the .NET struct\u0027s size for struct types.\r\n\r\nLike the `LayoutKind.Sequential` support for structs in the runtime, we won\u0027t support these new layout requirements for any structs that (recursively) contain reference type fields.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public enum LayoutKind\r\n    {\r\n        Custom\r\n    }\r\n\r\n    [AttributeUsage(AttributeTargets.Struct)]\r\n    public sealed class CustomLayoutAttribute : Attribute\r\n    {\r\n        public CustomLayoutAttribute(CustomLayoutKind kind) {}\r\n        \r\n        // Only valid for CustomLayoutKind.SwiftEnum\r\n        public int RequiredDiscriminatorBits { get; set; }\r\n    }\r\n\r\n    public enum CustomLayoutKind\r\n    {\r\n        Sequential, // C-style struct\r\n        Union, // C-style union\r\n        SwiftStruct, // Swift struct\r\n        SwiftEnum // Swift enumeration\r\n    }\r\n}\r\n\r\nnamespace System.Runtime.InteropServices.Swift\r\n{\r\n    // Represents a pointer to a Swift object (for the purposes of calculating spare bits)\r\n    public readonly unsafe struct SwiftObject\r\n    {\r\n        // Would be implemented to mask out the spare bits\r\n        public void* Value { get; }\r\n    }\r\n\r\n    // Represents a bool value in Swift (for the purposes of calculating spare bits)\r\n    public readonly unsafe struct SwiftBool\r\n    {\r\n        // Would be implemented to mask out the spare bits\r\n        // or assign while preserving spare bits\r\n        public bool Value { get; }\r\n    }\r\n}\r\n```\r\n\r\n### API Usage\r\n\r\n```csharp\r\n[StructLayout(LayoutKind.Custom)]\r\n[CustomLayout(CustomLayoutKind.SwiftStruct)]\r\npublic struct InnerStruct\r\n{\r\n     public short F0; // offset 0\r\n     public sbyte F1; // offset 2\r\n}\r\n\r\n[StructLayout(LayoutKind.Custom)]\r\n[CustomLayout(CustomLayoutKind.SwiftStruct)]\r\npublic struct OuterStruct\r\n{\r\n    public ulong F0; // offset 0\r\n    public long F1; // offset 8\r\n    public InnerStruct F2; // offset 16\r\n    public sbyte F3; // offset 19\r\n}\r\n\r\n[StructLayout(LayoutKind.Custom)]\r\n[CustomLayout(CustomLayoutKind.SwiftEnum, RequiredDescriminatorBits = 1)]\r\npublic struct MyOptional\u003cT\u003e where T : unmanaged\r\n{\r\n    [StructLayout(LayoutKind.Custom)]\r\n    [CustomLayout(CustomLayoutKind.SwiftStruct)]\r\n    private struct Some_Payload\r\n    {\r\n          public T Value;\r\n    }\r\n\r\n    private Some_Payload Some;\r\n\r\n    // An API surface to describe the different cases and provide a C# API around accessing them, out of the scope of this API proposal\r\n}\r\n\r\n\r\n[StructLayout(LayoutKind.Custom)]\r\n[CustomLayout(CustomLayoutKind.SwiftEnum, RequiredDescriminatorBits = 1)]\r\npublic struct ParsedResult\r\n{\r\n     [StructLayout(LayoutKind.Custom)]\r\n     [CustomLayout(CustomLayoutKind.SwiftStruct)]\r\n     private struct ParsedObject_Payload\r\n     {\r\n            public SwiftPointer payload_0;\r\n     }\r\n     [StructLayout(LayoutKind.Custom)]\r\n     [CustomLayout(CustomLayoutKind.SwiftStruct)]\r\n     private struct ParsedBool_Payload\r\n     {\r\n            public SwiftBool payload_0;\r\n     }\r\n\r\n     private ParsedObject_Payload ParsedObject;\r\n     private ParsedBool_Payload SwiftBool;\r\n    // An API surface to describe the different cases and provide a C# API around accessing them, out of the scope of this API proposal\r\n}\r\n```\r\n\r\n### Alternative Designs\r\n\r\nWe could provide a set of layout primitives instead of a set of well-known layouts (the original proposal). However, we\u0027d then have to handle all possible combinations of these primitives or block them to only the valid combinations to match our equivalent support in the current proposal.\r\n\r\nWe could go further than the original proposal and have a mechanism for specifying OS/Arch-specific layout and ABI parameter passing rules in attributes. This design would allow the runtime to be entirely out of the business of layout and ABI handling other than reading the attributes. This design has a few problems through: We\u0027d need to consider how to provide/validate the provided options. The code-gen backends would need to respect this information (and reading from custom attributes is expensive). Generics would also be a problem in this design space.\r\n\r\n\r\n\u003cdetails\u003e\r\n\u003csummary\u003eOriginal API Proposal\u003c/summary\u003e\r\n\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Runtime.InteropServices;\r\n\r\n[AttributeUsage(AttributeTargets.Struct, AllowMultiple = false, Inherited = false)]\r\npublic sealed class ImportedStructAttribute : Attribute\r\n{\r\n    // StructLayoutAttribute matching members, excluding CharSet.\r\n    public int Pack { get; set; }\r\n    public int Size { get; set; }\r\n    public ImportedStructAttribute(LayoutKind layoutKind);\r\n    public LayoutKind LayoutKind { get; set; }\r\n    // New member for Swift layout requirements\r\n    public bool PadSizeToAlignment { get; set; }\r\n}\r\n```\r\n\r\n### API Usage\r\n\r\n```csharp\r\n[ImportedStruct(LayoutKind.Sequential, PadSizeToAlignment = false)]\r\nstruct SwiftOptionalLike\u003cT\u003e\r\n{\r\n    T value;\r\n    byte isNull;\r\n}\r\n\r\nConsole.WriteLine(Unsafe.SizeOf\u003cSwiftOptionalLike\u003cint\u003e\u003e()); // Output: 5\r\n\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nWe could provide a dedicated attribute for the Swift scenario.\r\n\r\nWe could have Roslyn support lowering the StructLayoutAttribute-corresponding members to metadata instead of introducing a source generator.\r\n\r\nWe could skip including the StructLayoutAttribute APIs and have the attributes represent separate concepts.\r\n\r\nWe could add new members to StructLayoutAttribute and require all compilers to recognize when new members are specified and not remove the attribute (and still lower the original members to metadata). This option is very expensive.\r\n\r\n\r\n\u003c/details\u003e\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOvhaHMQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc56GsjN",
                                           "createdAt":  "2024-04-10T23:06:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-04-10T23:06:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56Hpye",
                                           "createdAt":  "2024-04-11T02:27:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e We could have Roslyn support lowering the StructLayoutAttribute-corresponding members to metadata instead of introducing a source generator.\r\n\r\nI would expect some Roslyn integration to be a baseline requirement. The compiler already special cases `StructLayout`, `FieldOffset`, and several of the other `CompilerServices`/`InteropServices` attributes including when specifying them is legal or not.\r\n\r\nIf we are going to have this work as pay for play where we only go look at the extended attributes if a particular `LayoutKind` is set, then `FieldOffset` would be blocked from usage since the layout kind isn\u0027t `Explicit`\r\n\r\nAt that point, I think it\u0027s worth just minimally integrating it like we did for extended `CallConv` so that the compiler understands this is the new thing, that `FieldOffset` is allowed with the new thing, and that there is a general extensibility model for representing this data. \r\n\r\nTheoretically we could just have something like `LayoutKind*` types, much as we have `CallConv*` types. You could then have something like `LayoutKindSwift` or `LayoutKindTransparent` or `LayoutKindSequential` and allow them to be combined in interesting ways that the runtime can opt to support. The root attribute could then have the baseline fields like `Pack` and `Size` that every type has. -- Just as a hypothetical that loosely correlates to how we\u0027ve done other things, this isn\u0027t necessarily a good idea or the right direction for type layout.\r\n\r\n\u003e public sealed class ImportedStructAttribute : Attribute\r\n\r\nI\u0027m not a huge fan of this name and don\u0027t think it\u0027s necessarily obvious what it means.\r\n\r\nCould we define it as `UnmanagedStructLayoutAttribute` or `InteropStructLayoutAttribute` or something along those lines instead, perhaps? Make it clear its only works with \"unmanaged\" types, is primarily for use in interop scenarios, is defining the layout of the type, etc.",
                                           "updatedAt":  "2024-04-11T02:28:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56H-Mi",
                                           "createdAt":  "2024-04-11T04:33:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e I would expect some Roslyn integration to be a baseline requirement.\r\n\r\nI don\u0027t think that is a requirement. We made the transition to `LibraryImport` without any deep Roslyn integration. If however you are simply referring to an Analyzer/Fixer/Source generator that is something I could understand. I\u0027m still not sure it is needed, but it depends on how broadly we expect the attribute to be used in v1.\r\n\r\n\u003e Theoretically we could just have something like LayoutKind* types, much as we have CallConv* types. \r\n\r\nThis is something we should consider. I like following the CallConv approach we\u0027ve developed.\r\n\r\n\u003e I\u0027m not a huge fan of this name and don\u0027t think it\u0027s necessarily obvious what it means.\r\n\r\nIt follows the same pattern as `LibraryImport`, `DllImport`, `JSImport`, `ComImport` - it is importing the definition of something from another source.\r\n\r\n\u003e Could we define it as UnmanagedStructLayoutAttribute or InteropStructLayoutAttribute or something along those lines instead, perhaps? \r\n\r\nThese are not appropriate in this case since the values here will be reflected in both the managed type layout itself and not just at the interop boundary. We did consider `UnmanagedStructLayoutAttribute` but since it impacts the layout done by the runtime, it didn\u0027t seem appropriate. \r\n\r\n\u003e Make it clear its only works with \"unmanaged\" types,\r\n\r\nI would prefer to avoid C# concepts in this definition, especially as it relates to types - `UnmanagedCallersOnly` isn\u0027t about types so that works for me. My preference would be using \"ValueType\" rather than \"Unmanaged\". I think the \"Import\" term is something which is consistent with our other scenarios and should be used to align with the pattern.\r\n",
                                           "updatedAt":  "2024-04-11T04:33:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56H_fx",
                                           "createdAt":  "2024-04-11T04:41:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODgnrLw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MichalPetryka",
                                                                               "createdAt":  "2024-04-11T14:41:42Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-05-04T13:09:50Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "jkotas",
                                           "body":  "There is an unused value in `LayoutKind` enum. We can use this unused `LayoutKind` enum value to mean \"look at the new attribute for the layout spec\". It is similar to the approach we have used for CallConv where we have mapped an unused value to mean \"look at the modops\". (It would require a Roslyn change to relax the validation of `LayoutKind`, but that should not be a big deal. As Tanner pointed out, we may want to make Roslyn aware of this anyway.)\r\n\r\n\u003e With Swift Interop, we have a need to represent generic structs with correct Swift layouts\r\n\r\nThere are number of other issues with generics support in Swift interop. Unless we have a solution for how to make generics work well with Swift interop end-to-end, solving the struct layout issue is not that interesting.\r\n\r\n\u003e Size\r\n\r\nI think it is a questionable property. As far as I know, there is no equivalent in C/C++.\r\n\r\nAlso, would it make more sense to allow specifying alignment, to better match how one can control layout in C/C++?\r\n\r\n\u003e PadSizeToAlignment\r\n\r\nIs this all that is required to express layout of all possible Swift structs? Is there a prior art for expressing the Swift layout struct rules in clang/C++? (I am not sure whether I like inventing names like this for language-specific layout algorithms.)\r\n\r\n\u003e that FieldOffset is allowed with the new thing\r\n\r\nWhy would we want to allow FieldOffset with the new thing? FieldOffset is problematic concept (except when used with offset 0) - I believe that you made this point earlier.\r\n\r\n\u003e we could just have something like LayoutKind* types, much as we have CallConv* types\r\n\r\nThe CallConv... types exist to allow encoding the calling convention in function pointers. It is not possible to use attributes for function pointers. I think attribute works just fine for encoding type layout.",
                                           "updatedAt":  "2024-04-11T04:46:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56IEWY",
                                           "createdAt":  "2024-04-11T05:08:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e We made the transition to LibraryImport without any deep Roslyn integration.\r\n\r\nNit: I agree that LibraryImport does not have deep integration with Roslyn. However, we have made changes in Roslyn to make it work well (e.g. relaxed rules for `partial`).\r\n\r\n\u003e We did consider UnmanagedStructLayoutAttribute but since it impacts the layout done by the runtime, it didn\u0027t seem appropriate.\r\n\r\nI would expect this to be useful for controlling struct layout in general, not limited to structs imported from other languages. My name choice would be `UnmanagedLayoutAttribute` to make it as general as possible (\"unmanaged\" in this context means \"not auto-managed by the runtime\"). If you take my other suggestions to reuse unused LayoutKind value, the attribute can pair with `LayoutKind.Unmanaged`.",
                                           "updatedAt":  "2024-04-11T05:08:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56IIkq",
                                           "createdAt":  "2024-04-11T05:28:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e I would expect this to be useful for controlling struct layout in general, not limited to structs imported from other languages.\r\n\r\nI fully agree, that is why `UnmanagedLayoutAttribute` seems inappropriate. There is no need to imply any association with the C# \"unmanaged\" concept or the \"unmanaged\" term in `UnmanagedCallersOnly`. Instead I think indicating what is being customized, a \"ValueType\", is the ideal term. The \"Import\" term was used since we assumed the majority of this customization would be in service of defining types from other systems. Your remarks about a \"general purpose\" mechanism is compelling so calling this something like `ValueTypeLayout` seems the most appropriate.",
                                           "updatedAt":  "2024-04-11T05:28:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56IWFZ",
                                           "createdAt":  "2024-04-11T06:30:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODd0dKg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hamarb123",
                                                                               "createdAt":  "2024-04-11T11:09:37Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "`ValueTypeLayoutAttribute` looks too similar to the existing `StructLayoutAttribute`. We may want something more distinct, and we may want to avoid coupling the name to value types in case we need to use it for more than value types in future (`StructLayoutAttribute` made this mistake - it can be used for both structs and non-structs).\r\n\r\nMaybe `CustomTypeLayoutAttribute`? It would pair with `LayoutKind.Custom`. We have several existing `CustomSomethingAttribute`s in the BCL.\r\n",
                                           "updatedAt":  "2024-04-11T06:30:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56KJ1D",
                                           "createdAt":  "2024-04-11T11:28:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "\u003e Maybe `CustomTypeLayoutAttribute`? It would pair with `LayoutKind.Custom`. We have several existing `CustomSomethingAttribute`s in the BCL.\r\n\r\nI think this name is pretty good. I think avoiding `unmanaged` in the name is a good idea - I thought we would make it not work with managed structs when the name was suggested because that\u0027s what it implies.\r\n\r\n\u003e Also, would it make more sense to allow specifying alignment, to better match how one can control layout in C/C++?\r\n\r\nI think it would be great if we could specify an alignment. It would be very useful.\r\n\r\n\u003e ```csharp\r\n\u003e [ImportedStruct(LayoutKind.Sequential, PadSizeToAlignment = false)]\r\n\u003e struct SwiftOptionalLike\u003cT\u003e\r\n\u003e {\r\n\u003e     T value;\r\n\u003e     byte isNull;\r\n\u003e }\r\n\u003e \r\n\u003e Console.WriteLine(Unsafe.SizeOf\u003cSwiftOptionalLike\u003cint\u003e\u003e()); // Output: 5\r\n\u003e \r\n\u003e ```\r\n\r\nWhat happens if I do this:\r\n```csharp\r\nSwiftOptionalLike\u003cint\u003e[] array = new SwiftOptionalLike\u003cint\u003e[5];\r\nSpan\u003cSwiftOptionalLike\u003cint\u003e\u003e span = array;\r\nspan[1].Value = 5; //is it misaligned? (and do we care or not?) or is sizeof is wrong and cannot be used anymore for this? or do we just disallow this entirely somehow?\r\n```\r\n\r\n\u003e Why would we want to allow FieldOffset with the new thing? FieldOffset is problematic concept (except when used with offset 0) - I believe that you made this point earlier.\r\n\r\nI\u0027d tend to agree that allowing FieldOffset it probably not a good idea, unless we have a good reason to combine explicit layout with the additional features this new system may provide.\r\n\r\nHere\u0027s 2 useful layouts I\u0027d like to see that we could potentially make with this feature:\r\n- transparent layout\r\n- union layout (something along the lines of: first field is identifier, and the rest are laid out overlapped by the runtime automatically to minimise the size whilst keeping managed \u0026 unmanaged sections separate - I described such an idea [here](https://github.com/dotnet/csharplang/discussions/8030#discussioncomment-8990297) also in more detail)\r\n\r\nIt would be good if we also kept sequential \u0026 auto with this feature so they could benefit from new options like alignment.",
                                           "updatedAt":  "2024-04-11T11:28:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56KMdq",
                                           "createdAt":  "2024-04-11T11:33:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "SingleAccretion",
                                           "body":  "\u003e alignment control\r\n\r\nI will note that the runtime doesn\u0027t support alignments larger than 8 bytes (for on-GC-heap objects).",
                                           "updatedAt":  "2024-04-11T11:33:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56KQaj",
                                           "createdAt":  "2024-04-11T11:40:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "\u003e I will note that the runtime doesn\u0027t support alignments larger than 8 bytes (for on-GC-heap objects).\r\n\r\nIndeed, that part, if approved, would presumably just be delayed until the runtime could support it (since I assume there\u0027s no fundamental reason why it couldn\u0027t work).\r\n\r\n\r\n\r\n\u003e ```csharp\r\n\u003e [ImportedStruct(LayoutKind.Sequential, PadSizeToAlignment = false)]\r\n\u003e struct SwiftOptionalLike\u003cT\u003e\r\n\u003e {\r\n\u003e     T value;\r\n\u003e     byte isNull;\r\n\u003e }\r\n\u003e \r\n\u003e Console.WriteLine(Unsafe.SizeOf\u003cSwiftOptionalLike\u003cint\u003e\u003e()); // Output: 5\r\n\u003e ```\r\n\r\nAlso, this could presumably(?) break some of use who have `AlignOf` helper functions similarly to:\r\n```csharp\r\nstruct AlignHelper\u003cT\u003e\r\n{\r\n    T value;\r\n    byte field;\r\n}\r\n\r\nstatic unsafe int AlignOf\u003cT\u003e() =\u003e sizeof(AlignHelper\u003cT\u003e) - sizeof(T);\r\n\r\nConsole.WriteLine(AlignOf\u003cSwiftOptionalLike\u003cint\u003e\u003e()); //would this produce what we expect for alignment?\r\n//it relates to the question I asked about spans earlier\r\n```\r\nIf it would break the above, it would be great to get proper `AlignOf` APIs (ideally both generic in Unsafe, and on RuntimeHelpers like with the new SizeOf API) so we can detect it legitimately.",
                                           "updatedAt":  "2024-04-11T11:43:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56K_30",
                                           "createdAt":  "2024-04-11T13:32:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e we may want to avoid coupling the name to value types in case we need to use it for more than value types in future\r\n\r\nI thought about this when Jeremy first suggested the idea - \"Would we ever want this for reference types?\". I don\u0027t think I have the imgination to come up with a scenario where we would want to play layout games with reference types. Not pushing back on the suggestion, but is there an obvious case where it would be compelling? I personally find the `StructLayoutAttribute` being applicable to reference types to be a huge mistake and has only created complexity and almost no practical upside.\r\n\r\n\u003e Maybe CustomTypeLayoutAttribute? It would pair with LayoutKind.Custom. We have several existing CustomSomethingAttributes in the BCL.\r\n\r\nI have no push back with that name. The `LayoutKind.Custom` also seems natural with that name and the intent.",
                                           "updatedAt":  "2024-04-11T13:32:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56LcZy",
                                           "createdAt":  "2024-04-11T14:26:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jakobbotsch",
                                           "body":  "FWIW, the Swift struct layout algorithm is described here: https://github.com/apple/swift/blob/4b440a1d80a0900b6121b6e4a15fff2a96263bc5/docs/ABI/TypeLayout.rst#fragile-struct-and-tuple-layout\r\n\r\nI\u0027m not sure that `PadSizeToAlignment` alone ends up being sufficient for the Swift scenarios. For example, will creating an array in .NET of a Swift struct whose size doesn\u0027t match its stride (as defined by the above) end up doing the right thing? ",
                                           "updatedAt":  "2024-04-11T14:26:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56Lt4W",
                                           "createdAt":  "2024-04-11T14:57:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODd8tVQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2024-04-11T15:05:04Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MichalPetryka",
                                                                               "createdAt":  "2024-04-11T15:05:58Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2024-04-11T15:12:06Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hamarb123",
                                                                               "createdAt":  "2024-04-11T19:55:23Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kotlarmilos",
                                                                               "createdAt":  "2024-04-12T09:29:19Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  5
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e Why would we want to allow FieldOffset with the new thing? FieldOffset is problematic concept (except when used with offset 0) - I believe that you made this point earlier.\r\n\r\nMy understanding of the proposal (based on the wording and the shape of the new attribute) was that this was basically meant to supplement the existing `StructLayout` attribute and in particular replace it when it was present.\r\n\r\nMy assumption had then been that this meant that something like a union in Swift would be defined something like: `[ImportedStruct(LayoutKind = LayoutKind.Explicit, PadSizeToAlignment = false)]` and therefore would require `FieldOffset` to work.\r\n\r\nI had also assumed we were going to want this to be \"pay for play\" so that the VM doesn\u0027t have to look for this attribute on every struct, and the only sensible way to do that is to use one of the free bits in the existing `LayoutKind` enum field used by `StructLayout`; which would of course force it to be mutually exclusive and therefore impact the special handling Roslyn already has around these pseudo- attributes.\r\n\r\n--------------\r\n\r\nI do think that `FieldOffset` itself is a very poor mechanism and doesn\u0027t itself \"properly\" match to anything C/C++ exposes unless you exclusively use it as `FieldOffset(0)`.\r\n\r\nIf we were to design this from the ground up, then what I would expect to see is probably:\r\n* We make it pay-for-play by marking the type with `[StructLayout(LayoutKind.Extended)]`\r\n* `Extended` (or a different/better name) tells the VM to also look for and resolve the new attribute (will call it `ExtendedStructLayout` for simplicity below)\r\n* `ExtendedStructLayout` then contains the relevant new fields that allow controlling newer layout mechanisms\r\n\r\nI would then expect us to take a look at what metadata is actually expressible by languages (both officially in the language spec and unofficially via documented compiler switches/features) we want to interoperate with and make a determination on what to expose based on that.\r\n\r\nI would then not want to reuse the existing `LayoutKind` definitions in the extended metadata. Rather, I\u0027d want to see:\r\n* `Sequential` - Works just like `LayoutKind.Sequential`\r\n* `Union` - Works just like `LayoutKind.Explicit` with every field at `0`\r\n* `...` - Future expansions based on need the runtime identifies and believes worth exposing\r\n  * Theoretical examples include layouts such as `Transparent` or other callouts made above\r\n\r\nI would want us to be more explicit about the differences between `Pack` and `Align`. If I were to try to describe a difference based on C/C++, then you have the natural alignment of the type as defined by the ABI (which is effectively the defined alignment for primitives and the maximum alignment of all fields otherwise). `alignas` then allows you to override the natural alignment of a type to a greater alignment (never a lesser, lesser alignment is ill-formed). `#pragma pack` then allows you to override the alignment of fields, without changing the actual alignment of a the type for a field. This does impact the natural alignment computed for the type containing those fields, however, as it can lower the alignment for a given field. Just as `alignas` can never specify a lower than natural alignment, `pack` can never specify a greater than natural packing.\r\n\r\nI think we would then need to consider the best way to represent concepts like compatibility with a particular language. My biggest concern with something like `PadSizeToAlignment` would be that it\u0027s not necessarily intuitive to someone who knows they\u0027re needing Swift interop. There are several repeated concepts across the various targets, but in general a lot of things tend to be very language centered/oriented and could break or change over time. So an alternative thought might be that we have some `TargetLanguage` field that includes `C`, `Swift`, and `Java` that makes it very clear \"we have a struct/union that will be getting passed to {TargetLanguage} so ensure the padding/layout is computed using the language specific rules\" and thus not require users to understand the large nuance (which might even differ based now or in the future on things like machine ABI, operating system, or CPU architecture).",
                                           "updatedAt":  "2024-04-11T15:00:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56w8zk",
                                           "createdAt":  "2024-04-16T17:57:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "\u003e FWIW, the Swift struct layout algorithm is described here: [apple/swift@`4b440a1`/docs/ABI/TypeLayout.rst#fragile-struct-and-tuple-layout](https://github.com/apple/swift/blob/4b440a1d80a0900b6121b6e4a15fff2a96263bc5/docs/ABI/TypeLayout.rst#fragile-struct-and-tuple-layout)\r\n\u003e \r\n\u003e I\u0027m not sure that `PadSizeToAlignment` alone ends up being sufficient for the Swift scenarios. For example, will creating an array in .NET of a Swift struct whose size doesn\u0027t match its stride (as defined by the above) end up doing the right thing?\r\n\r\nI\u0027ve spent some time looking into more specifics of Swift layout (primarily around enums and the discriminator). Swift uses a concept of \"spare bits\" based on the type and platform to reuse bits in types (thankfully only in the non-generic case). We could have the Swift projection handle this at the projection layer (with explicit layout with specifically placed `[FieldOffset(X)] byte b` fields) and get correct behavior for all 64-bit targets for enums with up to 128 cases (after that, the number of spare bits in some cases differs per-platform, so some platforms would append an additional `byte` to the layout and others wouldn\u0027t).\r\n\r\nAlternatively, we could add runtime support for this concept and add more intrinsic Swift struct types to represent the different categories of types (in particular, pointers to Swift objects and ObjC objects bridged into Swift) along with a mechanism to say how many spare bits to reserve (padding the struct length with additional bytes if necessary).\r\n\r\nI do like @tannergooding\u0027s proposal of specifying a specific target language and letting the runtime handle it, but I\u0027m concerned that the cost of implementing more complicated concepts like the spare-bits concept would be too expensive (especially if we won\u0027t hit the limitations in the .NET 9 targets for Swift interop).\r\n\r\nBased on the reactions to the `TargetLanguage` proposal, I\u0027ll start putting together a proposal for it.",
                                           "updatedAt":  "2024-04-16T17:57:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56ymj_",
                                           "createdAt":  "2024-04-16T23:53:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "Here\u0027s my first pass at an API based on Tanner\u0027s ideas (and handling spare bits in the VM/layout).\r\n\r\nThe general idea is to encode the information in the attribute by using different \"*LayoutKind\" enums for different target languages.\r\n\r\nI\u0027ve also included the extra requirements for Swift. I\u0027ve decided to not include a type for the ObjC bridged object as we\u0027re trying to avoid handling that case in the Swift interop the .NET 9 timeframe.\r\n\r\n```csharp\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public enum LayoutKind\r\n    {\r\n        Custom\r\n    }\r\n\r\n    [AttributeUsage(AttributeTargets.Struct)]\r\n    public sealed class CustomLayoutAttribute : Attribute\r\n    {\r\n        public CustomLayoutAttribute(CustomLayoutKind kind) {}\r\n        public CustomLayoutAttribute(CLayoutKind kind) {}\r\n        public CustomLayoutAttribute(Swift.SwiftLayoutKind kind, int requiredSpareBits = 0) {}\r\n    }\r\n\r\n    public enum CustomLayoutKind\r\n    {\r\n        Sequential,\r\n        Transparent\r\n    }\r\n\r\n    public enum CLayoutKind\r\n    {\r\n        Struct,\r\n        Union\r\n    }\r\n}\r\n\r\nnamespace System.Runtime.InteropServices.Swift\r\n{\r\n    public enum SwiftLayoutKind\r\n    {\r\n        Struct,\r\n        Enum\r\n    }\r\n    public struct SpareBits\r\n    {\r\n        public static SpareBits GetSpareBits\u003cT\u003e(T value) where T: unmanaged;\r\n        public static T SetSpareBits\u003cT\u003e(T value, SpareBits spareBits) where T: unmanaged;\r\n\r\n        // Returns the value of the spare bits as an unsigned 64-bit integer.\r\n        public ulong AsUInt64();\r\n\r\n        // Sets the value of the spare bits\r\n        public void Set(ulong bits);\r\n    }\r\n\r\n    // Represents a pointer to a Swift object (for the purposes of calculating spare bits)\r\n    public readonly unsafe struct SwiftObject\r\n    {\r\n        public SwiftObject(void* value)\r\n        {\r\n            Value = value;\r\n        }\r\n        public void* Value { get; }\r\n    }\r\n}\r\n```",
                                           "updatedAt":  "2024-04-16T23:53:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56ytsv",
                                           "createdAt":  "2024-04-17T00:29:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODfmUJQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2024-04-26T01:04:01Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "I do not understand the SpareBits. I assumed that the Swift-specific layout computation would take care of the spare bit allocation transparently. Could you please shed some more light on it?\r\n\r\nCan the `CustomLayoutKind` be one enum that covers all cases? \r\n```\r\nenum CustomLayoutKind\r\n{\r\n    Sequential, // C-like struct\r\n    Union, // C-like union\r\n    Swift, // Swift-specific layout rules\r\n    Transparent, // Rust-like transparent\r\n    ...\r\n}\r\n```\r\n\r\nI have mixed feeling about transparent. As I have said before, it just pushes work that can be done by interop binding generators into the runtime.",
                                           "updatedAt":  "2024-04-17T00:30:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56y3JC",
                                           "createdAt":  "2024-04-17T01:01:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODgnrfQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-05-04T13:11:22Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "\u003e ```csharp\r\n\u003e Union, // C-like union\r\n\u003e ```\r\n\r\nWhat sort of a union is this? Is it an order dependent one or an order independent one? See [this](https://github.com/dotnet/csharplang/discussions/8030#discussioncomment-8990297) (which I linked before, but nobody seemed to look at) where I go over at an overview level what they\u0027re both useful for, and how they could be specifically represented in metadata.\r\n\r\ni.e., what do we expect the answer to the following question to be?\r\n```csharp\r\n[CustomLayout(CustomLayoutKind.Union)]\r\nstruct Union1\u003cT1, T2\u003e\r\n{\r\n    T1 field1;\r\n    T2 field2;\r\n}\r\n```\r\nIs the layout of `Union1\u003cT1, T2\u003e` the same as `Union1\u003cT2, T1\u003e` always? (useful for `A|B|C` DUs, bad for `Option\u003cT\u003e` DUs)\r\nIs the type `Union1\u003cT1, T2\u003e` exactly the same type as `Union1\u003cT2, T1\u003e` always? (useful for `A|B|C` DUs, bad for `Option\u003cT\u003e` DUs)\r\nI think both of these types of DUs are useful, but they would need different encodings most likely to be most optimal as I pointed out earlier.\r\nThe one that allows swapping `T1` \u0026 `T2` could be called something like `InterchangeableUnion` to disambiguate it.\r\nAre we going to provide just one of these (and if so, which one), or are we going to provide both of them?",
                                           "updatedAt":  "2024-04-17T01:01:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56y3pi",
                                           "createdAt":  "2024-04-17T01:03:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "\u003e ```csharp\r\n\u003e         public CustomLayoutAttribute(CustomLayoutKind kind) {}\r\n\u003e         public CustomLayoutAttribute(CLayoutKind kind) {}\r\n\u003e         public CustomLayoutAttribute(Swift.SwiftLayoutKind kind, int requiredSpareBits = 0) {}\r\n\u003e ```\r\n\r\nI don\u0027t think this is the right approach, I think there should be 1 constructor that takes a `CustomLayoutKind`, and then specify any additional information on properties.",
                                           "updatedAt":  "2024-04-17T01:03:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56y6il",
                                           "createdAt":  "2024-04-17T01:19:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODgnrhw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hamarb123",
                                                                               "createdAt":  "2024-04-17T01:21:29Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkoritzinsky",
                                                                               "createdAt":  "2024-04-17T02:09:50Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2024-04-26T01:04:13Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-05-04T13:11:27Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e What sort of a union is this? \r\n\r\nIt is C-like union. It would work exactly same as `union` in C. It has nothing to do with C# DUs. I expect that it would be equivalent to what you can get today from `Layout.Explicit` and specifying `FieldOffset(0)` on all fields.",
                                           "updatedAt":  "2024-04-17T01:19:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57G-60",
                                           "createdAt":  "2024-04-18T22:26:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "\u003e I do not understand the SpareBits. I assumed that the Swift-specific layout computation would take care of the spare bit allocation transparently. Could you please shed some more light on it?\r\n\r\nThe SpareBits type would provide a way to get the value stored in the spare bits of a value type to enable a Swift projection to know which element of the enum is active.\r\n\r\nIt looks like the Swift compiler puts an entry into an enum type\u0027s value witness table to find the tag, so the projection can use that and not need to read them manually. I\u0027ll remove the type. https://godbolt.org/z/KMnaoTePd\r\n\r\n\u003e Can the `CustomLayoutKind` be one enum that covers all cases?\r\n\u003e \r\n\u003e ```\r\n\u003e enum CustomLayoutKind\r\n\u003e {\r\n\u003e     Sequential, // C-like struct\r\n\u003e     Union, // C-like union\r\n\u003e     Swift, // Swift-specific layout rules\r\n\u003e     Transparent, // Rust-like transparent\r\n\u003e     ...\r\n\u003e }\r\n\u003e ```\r\n\u003e \r\n\u003e I have mixed feeling about transparent. As I have said before, it just pushes work that can be done by interop binding generators into the runtime.\r\n\r\nI was mainly using `Transparent` as an example of another \"custom layout\" that isn\u0027t interop-language-specific.\r\n\r\nWe could use one joint enum and only read the members necessary. I was trying to use separate constructors to make it not possible to specify information that\u0027s not applicable to the target layout, but I\u0027m not tied to the idea.\r\n\r\nHere\u0027s an updated proposal:\r\n\r\n```csharp\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public enum LayoutKind\r\n    {\r\n        Custom\r\n    }\r\n\r\n    [AttributeUsage(AttributeTargets.Struct)]\r\n    public sealed class CustomLayoutAttribute : Attribute\r\n    {\r\n        public CustomLayoutAttribute(CustomLayoutKind kind) {}\r\n        \r\n        // Only valid for CustomLayoutKind.SwiftEnum\r\n        public int RequiredDiscriminatorBits { get; set; }\r\n    }\r\n\r\n    public enum CustomLayoutKind\r\n    {\r\n        Sequential, // C-style struct\r\n        Union, // C-style union\r\n        SwiftStruct, // Swift struct\r\n        SwiftEnum // Swift enumeration\r\n    }\r\n}\r\n\r\nnamespace System.Runtime.InteropServices.Swift\r\n{\r\n    // Represents a pointer to a Swift object (for the purposes of calculating spare bits)\r\n    public readonly unsafe struct SwiftObject\r\n    {\r\n        // Would be implemented to mask out the spare bits\r\n        // or assign while preserving spare bits\r\n        public void* Value { get; set; }\r\n    }\r\n\r\n    // Represents a bool value in Swift (for the purposes of calculating spare bits)\r\n    public readonly unsafe struct SwiftBool\r\n    {\r\n        // Would be implemented to mask out the spare bits\r\n        // or assign while preserving spare bits\r\n        public bool Value { get; }\r\n    }\r\n}\r\n```\r\n",
                                           "updatedAt":  "2024-04-24T20:43:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57MKnl",
                                           "createdAt":  "2024-04-19T15:14:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODgnrjQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-05-04T13:11:38Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e I have mixed feeling about transparent. As I have said before, it just pushes work that can be done by interop binding generators into the runtime.\r\n\r\nA sufficiently smart tool can try to get it all right, but its very error prone and prone to breaking if a new platform comes online. \r\n\r\nThe general issue is that it it starts getting into concepts that are ABI specific. That is, whether or not `T` and a simple struct wrapper `S` (`struct S { T value; }`) are equivalent depends on a lot of ABI specific context, such as the target operating system, the target CPU, whether its a return or parameter, whether its nested as a field of another struct, etc.\r\n\r\nA simple example is that people worked around the well known Windows member call difference for x64 for the longest time where a C signature that looked like `SomeStruct M()` would be fixed up to look like `SomeStruct* M(SomeStruct* retBuffer)`. However, this fix can subtly break for some struct layouts on Arm64 and people started hitting it when trying to run the same code on Windows Arm64. This was largely resolved with the newer `CallConvMemberFunction` but that still leaves some problems and nuance in other scenarios.\r\n\r\nA built-in layout like `Transparent` is something the runtime already has, however. It uses this for types like `NFloat`, `CLong`, and `CULong`. It will likely also be used by other special interop types the runtime needs to define in the future. We similarly already have validation to assert certain types of structs only have 1 field, as its used by the `InlineArray` feature. So getting the runtime to support this a little more broadly so that cases such as `struct HWND { void* _value; }` or `struct HRESULT { int _value;l }` can work as expected shouldn\u0027t be that much more complex and will greatly simplify the overall user experience, JIT overhead, and tooling complexity required.",
                                           "updatedAt":  "2024-04-19T15:14:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57PIZF",
                                           "createdAt":  "2024-04-20T05:34:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Here\u0027s an updated proposal:\r\n\r\nCould you please share a few examples of Swift structs and enums and what their C# equivalents would be to using these constructs?",
                                           "updatedAt":  "2024-04-20T05:34:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57PInT",
                                           "createdAt":  "2024-04-20T05:38:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODfmUNw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2024-04-26T01:04:32Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e its very error prone and prone to breaking if a new platform comes online.\r\n\r\nIt is only error prone and non-portable if people are cutting corners. It is not error prone if the types are matched between managed and unmanaged signatures exactly. If the unmanaged signature has `int32_t`, the managed signature should have `int`, anything else is non-portable. \r\n\r\nThe design principle that we have established for runtime interop going forward has been to only introduce low-level features that are impossible or very hard to do in higher level bindings. Wrapping primitive types with structs is boiler plate code that is very straightforward to do in higher level bindings. One can come up with number of similar features that require quite a bit of boiler place code in interop bindings today, but that can be implemented by the runtime instead. For example, we can allow byref types in signatures and pin them implicitly in the JIT. It would save a good amount of boiler plate-code in interop bindings too. If we start introducing these types of features, where should we stop? Are we going to end up with a complicated built-in interop v2?\r\n\r\n\u003e This was largely resolved with the newer CallConvMemberFunction but that still leaves some problems and nuance in other scenarios.\r\n\r\nRight, we have introduced `CallConvMemberFunction` since it was impossible to deal with these calling convention differences in the interop bindings in a portable way. (I am not sure what the other scenarios you have in mind are.)",
                                           "updatedAt":  "2024-04-20T05:38:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57tvkn",
                                           "createdAt":  "2024-04-24T18:36:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "\u003e \u003e Here\u0027s an updated proposal:\r\n\u003e \r\n\u003e Could you please share a few examples of Swift structs and enums and what their C# equivalents would be to using these constructs?\r\n\r\nHere\u0027s some examples:\r\n\r\n```swift\r\n@frozen\r\npublic struct InnerStruct\r\n{\r\n    let F0: Int16;\r\n    let F1: Int8;\r\n}\r\n\r\n@frozen\r\npublic struct OuterStruct\r\n{\r\n    let F0: UInt64;\r\n    let F1: Int64:\r\n    let F2 : InnerStruct;\r\n    let F3: Int8;\r\n}\r\n\r\n@frozen\r\npublic enum MyOptional\u003cT\u003e\r\n{\r\n    case Empty;\r\n    case Some(Value: T);\r\n}\r\n\r\npublic class MyClass\r\n{\r\n}\r\n\r\n@frozen\r\npublic enum ParsedResult\r\n{\r\n    case ParsedObject(MyClass);\r\n    case ParsedBool(Bool);\r\n}\r\n```\r\n\r\n```csharp\r\n[StructLayout(LayoutKind.Custom)]\r\n[CustomLayout(CustomLayoutKind.SwiftStruct)]\r\npublic struct InnerStruct\r\n{\r\n     public short F0; // offset 0\r\n     public sbyte F1; // offset 2\r\n}\r\n\r\n[StructLayout(LayoutKind.Custom)]\r\n[CustomLayout(CustomLayoutKind.SwiftStruct)]\r\npublic struct OuterStruct\r\n{\r\n    public ulong F0; // offset 0\r\n    public long F1; // offset 8\r\n    public InnerStruct F2; // offset 16\r\n    public sbyte F3; // offset 19\r\n}\r\n\r\n[StructLayout(LayoutKind.Custom)]\r\n[CustomLayout(CustomLayoutKind.SwiftEnum, RequiredDescriminatorBits = 1)]\r\npublic struct MyOptional\u003cT\u003e where T : unmanaged\r\n{\r\n    [StructLayout(LayoutKind.Custom)]\r\n    [CustomLayout(CustomLayoutKind.SwiftStruct)]\r\n    private struct Some_Payload\r\n    {\r\n          public T Value;\r\n    }\r\n\r\n    private Some_Payload Some;\r\n\r\n    // An API surface to describe the different cases and provide a C# API around accessing them, out of the scope of this API proposal\r\n}\r\n\r\n\r\n[StructLayout(LayoutKind.Custom)]\r\n[CustomLayout(CustomLayoutKind.SwiftEnum, RequiredDescriminatorBits = 1)]\r\npublic struct ParsedResult\r\n{\r\n     [StructLayout(LayoutKind.Custom)]\r\n     [CustomLayout(CustomLayoutKind.SwiftStruct)]\r\n     private struct ParsedObject_Payload\r\n     {\r\n            public SwiftPointer payload_0;\r\n     }\r\n     [StructLayout(LayoutKind.Custom)]\r\n     [CustomLayout(CustomLayoutKind.SwiftStruct)]\r\n     private struct ParsedBool_Payload\r\n     {\r\n            public SwiftBool payload_0;\r\n     }\r\n\r\n     private ParsedObject_Payload ParsedObject;\r\n     private ParsedBool_Payload SwiftBool;\r\n    // An API surface to describe the different cases and provide a C# API around accessing them, out of the scope of this API proposal\r\n}\r\n```",
                                           "updatedAt":  "2024-04-24T18:36:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57uUnS",
                                           "createdAt":  "2024-04-24T20:01:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Can the RequiredDescriminatorBits be combined with bool fields - what would the following Swift enum look like in C# and what would be its size in bytes? \r\n```\r\n@frozen\r\npublic enum MyOptional\r\n{\r\n    case Empty;\r\n    case OtherEmpty;\r\n    case Some(Bool);\r\n}\r\n```",
                                           "updatedAt":  "2024-04-24T20:01:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57ulle",
                                           "createdAt":  "2024-04-24T20:45:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "With the above proposal, that type would be projected as follows (fixed the spelling for discriminator in the proposal as well):\r\n\r\n```csharp\r\n[StructLayout(LayoutKind.Custom)]\r\n[CustomLayout(CustomLayoutKind.SwiftEnum, RequiredDiscriminatorBits = 2)]\r\npublic struct MyOptional\r\n{\r\n     [StructLayout(LayoutKind.Custom)]\r\n     [CustomLayout(CustomLayoutKind.SwiftStruct)]\r\n     private struct Some_Payload\r\n     {\r\n            public SwiftBool payload_0;\r\n     }\r\n\r\n     private Some_Payload Some;\r\n}\r\n```\r\n\r\nThe type would be 1 byte size and the bitwise layout would be as follows:\r\n\r\n```\r\ndiscriminator: 0 - 1\r\nempty: 2-6\r\nSome.payload_0: 7\r\n```\r\n\r\nI recommend we use the `SwiftBool` type here to ensure that any usage as the C# bool type has the other bits masked off correctly. I know that we have had optimizations implemented around `bool` values only ever being 0 or 1, so by using a separate type with conversions, we can ensure that we don\u0027t interfere with those optimizations.",
                                           "updatedAt":  "2024-04-24T20:45:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57u96w",
                                           "createdAt":  "2024-04-24T21:53:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "The bit fields come with many new problems. For example, you cannot take address of `MyOptional.Some` field when it is a bit field. That breaks a lot of things in the runtime, the JIT and maybe even Roslyn. ",
                                           "updatedAt":  "2024-04-24T21:53:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57vOcA",
                                           "createdAt":  "2024-04-24T22:49:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "I think there\u0027s a little confusion here. `Some_Payload` is a 1-byte type, as is `SwiftBool`. However, the discriminator bits are stored within the `SwiftBool`\u0027s storage as they\u0027re known to be unused. You can still take the address of `Some`. The `SwiftBool` type provides an API abstraction to get the `bool` value with masking off the bits that may be used by a discriminator. This is equivalent to what Swift allows for this sort of layout.",
                                           "updatedAt":  "2024-04-24T22:49:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57xHox",
                                           "createdAt":  "2024-04-25T06:38:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e provides an API abstraction to get the bool value with masking off the bits that may be used by a discriminator\r\n\r\nIs the JIT expected to generate the masking? Are there going to be special rules for how SwiftBool can and cannot be used? For example, consider: \r\n```\r\n[StructLayout(LayoutKind.Custom)]\r\n[CustomLayout(CustomLayoutKind.SwiftStruct)]\r\nstruct MyStruct\r\n{\r\n    SwiftBool f1;\r\n    SwiftBool f2;\r\n}\r\n\r\nMyStruct s;\r\n\r\nSwiftBool a = s.f2;\r\nConsole.WriteLine(a.Value);\r\n```",
                                           "updatedAt":  "2024-04-25T06:38:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc572Nos",
                                           "createdAt":  "2024-04-25T17:34:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODfknxA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "matouskozak",
                                                                               "createdAt":  "2024-04-25T18:46:09Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hamarb123",
                                                                               "createdAt":  "2024-04-25T18:59:52Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "\u003e \u003e provides an API abstraction to get the bool value with masking off the bits that may be used by a discriminator\n\u003e \n\u003e \n\u003e \n\u003e Is the JIT expected to generate the masking?\n\nNo, the masking can be implemented in SwiftBool itself.\n\n\u003e Are there going to be special rules for how SwiftBool can and cannot be used? For example, consider: \n\u003e \n\u003e ```\n\u003e \n\u003e [StructLayout(LayoutKind.Custom)]\n\u003e \n\u003e [CustomLayout(CustomLayoutKind.SwiftStruct)]\n\u003e \n\u003e struct MyStruct\n\u003e \n\u003e {\n\u003e \n\u003e     SwiftBool f1;\n\u003e \n\u003e     SwiftBool f2;\n\u003e \n\u003e }\n\u003e \n\u003e \n\u003e \n\u003e MyStruct s;\n\u003e \n\u003e \n\u003e \n\u003e SwiftBool a = s.f2;\n\u003e \n\u003e Console.WriteLine(a.Value);\n\u003e \n\u003e ```\n\nSwift\u0027s Bool type always takes up at least 1 byte. So the size of MyStruct is 2 bytes. There\u0027s no extra restrictions on its usage. Swift just allows the enumeration layout algorithm to reuse the bits that the Bool type definitely doesn\u0027t use.\n\nTo do this, Swift allows types in the standard library to use LLVM\u0027s custom-bit-sized integer types. These types are always allocated as the next legal integer size (ie the `i1` type is allocated as through it was an `i8` and an `i19` would be allocated as an `i32`), but the Swift compiler is able to identify these types and recognize that the extra bits are unused and can be re-utilized for the discriminator. In our case, `Bool` is defined with an `i1` field (so it takes up an `i8` of space and Swift knows that 7 of the bits are unused).\n",
                                           "updatedAt":  "2024-04-25T17:34:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc573AH2",
                                           "createdAt":  "2024-04-25T19:21:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "I\u0027m still confused what we expect `sizeof` to do\n```csharp\n[StructLayout(LayoutKind.Custom)]\n[CustomLayout(CustomLayoutKind.SwiftStruct)]\npublic struct OuterStruct\n{\n    public ulong F0; // offset 0\n    public long F1; // offset 8\n    public InnerStruct F2; // offset 16\n    public sbyte F3; // offset 19\n}\n```\n\nBased on the above, it seems like sizeof InnerStruct should be 3, but if we had\n```csharp\n[StructLayout(LayoutKind.Custom)]\n[CustomLayout(CustomLayoutKind.SwiftStruct)]\npublic struct OuterStruct2\n{\n    public InnerStruct F0; // offset 0\n    public ushort F1; // offset 4\n}\n```\nIt seems like the size should be 4.\n\nHow do we get these different values? I\u0027d think if we\u0027re copying an arbitrary `InnerStruct` we\u0027d only want to copy 3 bytes, but if we\u0027re indexing in a span we\u0027d want to jump 4 at a time, and potentially in other scenarios we\u0027d want to jump an amount based on a different alignment...\n\nMaybe something like\n```csharp\n//Unsafe (\u0026 RuntimeHelpers overloads for RTH?)\nstatic int SizeOf\u003cT\u003e(int nextAlignment);\nstatic int AlignOf\u003cT\u003e();\n\n//copy size\nUnsafe.SizeOf\u003cInnerStruct\u003e(1); //3\n\n//offset to next in span\nUnsafe.SizeOf\u003cInnerStruct\u003e(Unsafe.AlignOf\u003cInnerStruct\u003e()); //4\n\n//offset to next byte field\nUnsafe.SizeOf\u003cInnerStruct\u003e(Unsafe.AlignOf\u003cbyte\u003e()); //3\n\n//offset to next short field\nUnsafe.SizeOf\u003cInnerStruct\u003e(Unsafe.AlignOf\u003cshort\u003e()); //4\n```\n?\n\nEither way we set `sizeof` to work, it seems like we\u0027d definitely break existing unsafe code (but not for any existing types luckily).",
                                           "updatedAt":  "2024-04-25T19:37:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc573L7Q",
                                           "createdAt":  "2024-04-25T19:52:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Swift\u0027s Bool type always takes up at least 1 byte. So the size of MyStruct is 2 bytes. \r\n\r\nOk, I have incorrectly assumed that the bit packing works for structs too. It sounds like that it works for Swift enums only and only when there is a single bool value. Just curious - is there a reason why this specific case is optimized? Are enums like this very common in Swift APIs?\r\n\r\n\u003e No, the masking can be implemented in SwiftBool itself.\r\n\r\nSo we are going to always return the lowest bit `bool Value =\u003e (_value \u0026 1) != 0;`. I guess that works for the singular enum case.",
                                           "updatedAt":  "2024-04-25T20:14:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc579q_Y",
                                           "createdAt":  "2024-04-26T17:04:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lambdageek",
                                           "body":  "I strongly disagree with having language-specific custom layouts *as a runtime concept*.  I think this a great UX for a source generator, but the underlying mechanism should be language agnostic (to whatever extent possible - if a language, like Swift, requires an ABI different from the normal platform ABI, that has to bleed into the runtime).\r\n\r\nHaving language-specific custom layouts as a runtime concept will lead to:\r\n* Users of new languages using a \"close enough\" existing language layout that is an imperfect match.  Which means users interested in interop with a new unsupported language having to understand both their language and the \"close enough\" language.\r\n* Binary compat breaks when the runtime picks up support for the new language and presumably every interop library has to upgrade from using the \"close enough\" language attribute to using the new language attribute.\r\n\r\nAlso I\u0027m not sure that language-specific runtime mechanisms are a great idea because languages evolve.  Generally they\u0027re not breaking their ABI on every major version, but it\u0027s conceivable that some Rust edition or new version of Swift breaks compat with a previous one and now we\u0027re stuck with an enum value that is ambiguous or unusable.\r\n\r\n",
                                           "updatedAt":  "2024-04-26T17:04:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57-CRp",
                                           "createdAt":  "2024-04-26T18:06:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "@jkoritzinsky, After thinking about this more, I\u0027m actually not quite sure I 100% understand the reason behind `Swift, // Swift-specific layout rules`\r\n\r\nIn general, ABIs are determined roughly in terms of the underlying system ABI, which is itself largely oriented around C. Accordingly, if a type or method cannot be defined using \"standard\" C, then it is not possible for C to call and therefore not really possible for arbitrary interop -- Where \"standard\" C is a little bit looser term than \"spec-compliant\" C and really just means, definable by GCC/Clang/MSVC\r\n\r\nBased on some of the above, it sounds like we\u0027re trying to circumvent the core interop APIs for Swift and trying to interact with it directly, rather than going through the C compatible ABI defined for the language and so its kind-of like if some C API tried to call into a .NET generic function directly. Yes you can do it, but its technically depending on implementation details that are subject to change and is largely undefined behavior. If C wants to call a .NET generic API, then it needs to use the appropriate hooks to resolve an ABI stable wrapper instead.\r\n\r\nIt\u0027d be great if this general scenario could be clarified and why we need such a feature but C does not.",
                                           "updatedAt":  "2024-04-26T18:06:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57-fbo",
                                           "createdAt":  "2024-04-26T19:11:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "\u003e \u003e Swift\u0027s Bool type always takes up at least 1 byte. So the size of MyStruct is 2 bytes.\r\n\u003e \r\n\u003e Ok, I have incorrectly assumed that the bit packing works for structs too. It sounds like that it works for Swift enums only and only when there is a single bool value.\r\n\r\nThis works for enums with Bool members, Swift class object members, or Objective-C bridged object members.\r\n\r\n\u003e Just curious - is there a reason why this specific case is optimized?\r\n\r\nThere used to be more cases in Swift that were optimized in this way. The `UnicodeScalar` type used to be defined as `Builtin.Int21`, so the top 11 bits for it could be optimized the same way. After searching the public Standard Library, `Bool` is the only one today.\r\n\r\n\u003e Are enums like this very common in Swift APIs?\r\n\r\nEnums with Bools aren\u0027t particularly common, but ones with class types (represented by the `SwiftPointer` type) are.\r\n\r\n\u003e \u003e No, the masking can be implemented in SwiftBool itself.\r\n\u003e \r\n\u003e So we are going to always return the lowest bit `bool Value =\u003e (_value \u0026 1) != 0;`. I guess that works for the singular enum case.\r\n\r\nYep\r\n\r\n\u003e I strongly disagree with having language-specific custom layouts _as a runtime concept_. I think this a great UX for a source generator, but the underlying mechanism should be language agnostic (to whatever extent possible - if a language, like Swift, requires an ABI different from the normal platform ABI, that has to bleed into the runtime).\r\n\r\nWe plan to do most work a source generator/projection space, but the ABI platform differences that must be accounted for in the calling convention must be representable to the runtime, as the runtime handles the register allocation, lowering, etc. Basic type layout is included here.\r\n\r\nWe tried to use the existing .NET features to describe Swift layouts, but we\u0027ve realized that we can\u0027t do so with existing features. \r\n\r\nWe tried to use `StructLayoutAttribute.Size` to trim trailing padding and that worked for CoreCLR and NativeAOT for non-generic cases. However, [it doesn\u0027t work on Mono](https://github.com/dotnet/runtime/issues/101432) and it doesn\u0027t work in generic scenarios where the size of the containing structure can\u0027t be known (as one of the fields is generic).\r\n\r\nWe also can\u0027t represent the \"spare bits\" concept in a platform-agnostic way, as even macOS x64 and arm64 differ in which bits they consider \"spare\".\r\n\r\nI\u0027d love to make these cases a source-generator-supported concept, but sadly they fall below the line of things the runtime is better at (architecture-specific differences) and things the runtime needs to handle (type layout for blittability and calling convention\r\n\r\n\u003e Having language-specific custom layouts as a runtime concept will lead to:\r\n\u003e \r\n\u003e * Users of new languages using a \"close enough\" existing language layout that is an imperfect match.  Which means users interested in interop with a new unsupported language having to understand both their language and the \"close enough\" language.\r\n\u003e * Binary compat breaks when the runtime picks up support for the new language and presumably every interop library has to upgrade from using the \"close enough\" language attribute to using the new language attribute.\r\n\r\nWe will always have users using the incorrect representation of our layout APIs that are \"close enough\". The majority of usage of explicit layout is done incorrectly (it\u0027s very rare for people outside of dotnet/runtime or the C# discord to represent structs containing unions as such instead of putting the explicit layout on the containing struct). I don\u0027t think we can stop users from doing this, and by not adding the features necessary to represent this, we make cases like the \"represent a Swift type\" case even more convoluted and difficult to understand, (which is why there was pushback on the `PadSizeToAlignment` idea I presented).\r\n\r\n\u003e Also I\u0027m not sure that language-specific runtime mechanisms are a great idea because languages evolve. Generally they\u0027re not breaking their ABI on every major version, but it\u0027s conceivable that some Rust edition or new version of Swift breaks compat with a previous one and now we\u0027re stuck with an enum value that is ambiguous or unusable.\r\n\r\nIf we\u0027re concerned, we can name the Swift members `Swift5Struct` and `Swift5Enum` to state that they\u0027re a representation of the Swift 5 ABI.\r\n\r\n\u003e After thinking about this more, I\u0027m actually not quite sure I 100% understand the reason behind `Swift, // Swift-specific layout rules`\r\n\u003e \r\n\u003e In general, ABIs are determined roughly in terms of the underlying system ABI, which is itself largely oriented around C. Accordingly, if a type or method cannot be defined using \"standard\" C, then it is not possible for C to call and therefore not really possible for arbitrary interop -- Where \"standard\" C is a little bit looser term than \"spec-compliant\" C and really just means, definable by GCC/Clang/MSVC\r\n\r\nAs you know, we already have mechanisms to represent types that don\u0027t exist in C for interop scenarios (explicit-layout w/ non-zero offsets).\r\n\r\n\u003e Based on some of the above, it sounds like we\u0027re trying to circumvent the core interop APIs for Swift and trying to interact with it directly, rather than going through the C compatible ABI defined for the language and so its kind-of like if some C API tried to call into a .NET generic function directly. Yes you can do it, but its technically depending on implementation details that are subject to change and is largely undefined behavior. If C wants to call a .NET generic API, then it needs to use the appropriate hooks to resolve an ABI stable wrapper instead.\r\n\r\nFor Swift interop, we **are** trying to introduce support to directly call into Swift APIs. That is the explicit goal of the project. In .NET 8 and earlier, Swift interop requires a significant amount of codegen in both C# and Swift to provide a C-compatible API surface on each side. Our initiative is to expand what .NET supports to enable directly calling Swift APIs with the Swift calling convention with Swift types.\r\n\r\nAn explicit goal of this work is to make it possible to call Swift APIs **without** having to map a Swift API to a C-compatible API. We\u0027re not circumventing the core interop APIs, we\u0027re explicitly expanding what we support to include the Swift ABI on Apple platforms.\r\n\r\n\u003e It\u0027d be great if this general scenario could be clarified and why we need such a feature but C does not.\r\n\r\nSwift\u0027s layout rules are explicitly not C-compatible. For example, the lack of trailing padding is not expressible in C, only in LLVM IR.\r\n\r\nSwift has explicitly stabilized portions of their ABI in Swift 5. We\u0027re only proposing including support in .NET for these stable portions of the ABI that are required to accurately call exposed Swift functions in the APIs we\u0027re looking at projecting into .NET.\r\n",
                                           "updatedAt":  "2024-04-26T19:11:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57-nA6",
                                           "createdAt":  "2024-04-26T19:34:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e Swift has explicitly stabilized portions of their ABI in Swift 5. We\u0027re only proposing including support in .NET for these stable portions of the ABI that are required to accurately call exposed Swift functions in the APIs we\u0027re looking at projecting into .NET.\r\n\r\n👍, if it\u0027s explicitly defined as stable then I think that alleviates most of the concerns I had.",
                                           "updatedAt":  "2024-04-26T19:34:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc58aljM",
                                           "createdAt":  "2024-04-30T21:14:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "@lambdageek and I spoke offline and he\u0027s okay with the updated proposal given some of the mentioned concerns. I\u0027ll update the top and mark this as ready for review (and blocking).",
                                           "updatedAt":  "2024-04-30T21:14:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc58bHME",
                                           "createdAt":  "2024-04-30T21:56:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "I think we should have good understanding of the Swift generics and Swift UI solution end-to-end before we start implementing the Swift-specific field layout in the runtime. I see it as nice-to-have at this point. I am not 100% convinced that it will be required at the end.",
                                           "updatedAt":  "2024-04-30T21:56:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc58bhwk",
                                           "createdAt":  "2024-04-30T22:27:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "We\u0027ll need to either support `Optional\u003cT\u003e` or have specialized instantiations of it for our goals (CryptoKit\u0027s APIs that we use have Swift `Optional\u003cT\u003e` parameters), so I want to make sure that we\u0027re clear to implement it.\r\n\r\nI agree that we should have a good understanding of the layout algorithms and which portions we need for our .NET 9 goals before implementing it.",
                                           "updatedAt":  "2024-04-30T22:27:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc58bpX0",
                                           "createdAt":  "2024-04-30T22:38:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e have specialized instantiations of it for our goals (CryptoKit\u0027s APIs that we use have Swift Optional\u003cT\u003e parameters\r\n\r\nI think this would be sufficient for our .NET 9 Swift interop goals.",
                                           "updatedAt":  "2024-04-30T22:38:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc58cC28",
                                           "createdAt":  "2024-04-30T23:42:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODgKq6w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkoritzinsky",
                                                                               "createdAt":  "2024-04-30T23:52:58Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "(I am fine with doing prep-work towards this proposal, like running it through API review and removing the superfluous validation of LayoutKind in Roslyn.)",
                                           "updatedAt":  "2024-05-01T00:17:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc590WxN",
                                           "createdAt":  "2024-05-14T18:39:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bartonjs",
                                           "body":  "[Video](https://www.youtube.com/watch?v=Is8C-WJHtIM\u0026t=0h20m48s)\n\n\r\n* `Custom` implies customization, so let\u0027s rename it to `Extended`\r\n* `Sequential` and `Union` =\u003e `CStruct`, `CUnion`\r\n* We discussed separate attributes for things like RequiredDiscriminatorBits and decided that one big grab bag is the better approach (for now)\r\n\r\n```c#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public enum LayoutKind\r\n    {\r\n        Extended = 1,\r\n    }\r\n\r\n    [AttributeUsage(AttributeTargets.Struct)]\r\n    public sealed class ExtendedLayoutAttribute : Attribute\r\n    {\r\n        public ExtendedLayoutAttribute(ExtendedLayoutKind kind) {}\r\n        \r\n        // Only valid for ExtendedLayoutKind.SwiftEnum\r\n        public int RequiredDiscriminatorBits { get; set; }\r\n    }\r\n\r\n    public enum ExtendedLayoutKind\r\n    {\r\n        CStruct, // C-style struct\r\n        CUnion, // C-style union\r\n        SwiftStruct, // Swift struct\r\n        SwiftEnum, // Swift enumeration\r\n    }\r\n}\r\n\r\nnamespace System.Runtime.InteropServices.Swift\r\n{\r\n    // Represents a pointer to a Swift object (for the purposes of calculating spare bits)\r\n    public readonly unsafe struct SwiftObject\r\n    {\r\n        // Would be implemented to mask out the spare bits\r\n        public void* Value { get; }\r\n    }\r\n\r\n    // Represents a bool value in Swift (for the purposes of calculating spare bits)\r\n    public readonly unsafe struct SwiftBool\r\n    {\r\n        // Would be implemented to mask out the spare bits\r\n        // or assign while preserving spare bits\r\n        public bool Value { get; }\r\n    }\r\n}\r\n```",
                                           "updatedAt":  "2024-05-14T20:49:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6-Focx",
                                           "createdAt":  "2025-08-14T16:45:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "Looks like this will get in early .NET 11 (due to the dependency on the Roslyn work).",
                                           "updatedAt":  "2025-08-14T16:45:40Z"
                                       }
                                   ],
                         "totalCount":  43
                     },
        "title":  "[API Proposal]: New attribute for interop-specific struct concerns",
        "labels":  [
                       "api-approved",
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/101519",
        "createdAt":  "2024-04-24T21:31:28Z",
        "number":  101519,
        "author":  "jtschuster",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-04-24T22:07:23Z",
        "body":  "Our guidance has always been that if the generator doesn\u0027t work out of the box, you can work around it by using the generated code as a starting point. However, if the `GeneratedComInterfaceAttribute` is removed from an interface, any `GeneratedComClass` classes won\u0027t generate a VTable for it, and QI on an instance of the `GeneratedComClass` class will fail. We could have `GeneratedComClass` look for `IUnknownDerivedAttribute` in addition to `GeneratedComInterface`, or enable `[GeneratedComInterface(Options = ComInterfaceOptions.None)]` to indicate that the implementation is in source and should not be generated (currently this warns). I\u0027m in favor of enabling `ComInterfaceOptions.None`. I think it\u0027s nice to have a clear indication on the primary definition that this is a COM interface (assuming the generated source is in a different file), though maybe it could be renamed?\r\n\r\n@jkoritzinsky @AaronRobinsonMSFT thoughts?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOe7w0EA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc57u4eR",
                                           "createdAt":  "2024-04-24T21:34:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-04-24T21:34:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57u443",
                                           "createdAt":  "2024-04-24T21:35:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e I\u0027m in favor of enabling GeneratedComInterfaceOptions.None. I think it\u0027s nice to have a clear indication on the primary definition that this is a COM interface (assuming the generated source is in a different file), though maybe it could be renamed?\r\n\r\nI like where your intuition is taking you and I agree. I think creating a new option `GeneratedComInterfaceOptions.UserDefined`, might be the best option here.",
                                           "updatedAt":  "2024-04-24T21:35:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57u95e",
                                           "createdAt":  "2024-04-24T21:53:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jtschuster",
                                           "body":  "I just realized the `ComClassGenerator` uses the `ComInterfaceOptions` to determine if there is a `ManagedObjectWrapper` or not and won\u0027t generate a VTable slot for the interface if that option isn\u0027t set, so we may need `UserDefined`, `UserDefinedManagedObjectWrapper`, and `UserDefinedComObjectWrapper`, where `UserDefined = UserDefinedManagedObjectWrapper | UserDefinedComOjbectWrapper`. \r\n\r\nAlso, I\u0027d imagine we don\u0027t ever want to support a manual ManagedObjectWrapper and a generated ComObjectWrapper (or vice versa), but if we want to keep that as a potential future option, that also might affect what we want the flags to be.",
                                           "updatedAt":  "2024-04-24T21:53:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57vDQQ",
                                           "createdAt":  "2024-04-24T22:07:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODfd3tw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2024-04-24T22:26:07Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jtschuster",
                                                                               "createdAt":  "2024-04-24T22:47:02Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-04-25T00:12:21Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "I don\u0027t think we\u0027d ever want to support a mix of user-defined and non-user-defined. So, since it\u0027s already a `[Flags]` enum, we only need to add `UserDefined`.",
                                           "updatedAt":  "2024-04-24T22:07:22Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "ComClassGenerator doesn\u0027t find interfaces when the generated code is copied to a source file and GeneratedComInterfaceAttribute is removed",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "source-generator"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/102421",
        "createdAt":  "2024-05-19T15:41:25Z",
        "number":  102421,
        "author":  "smourier",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODC4ToQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-05-19T16:05:38Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "alexrp",
                                            "createdAt":  "2024-05-19T22:47:16Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "shmuelie",
                                            "createdAt":  "2025-05-27T21:13:33Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2024-05-21T08:06:14Z",
        "body":  "### Description\r\n\r\nThe current .NET 8 ComWrappers source generator doesn\u0027t seem to support skipping vtable slots in COM interface declarations, as described and supported by the builtin interface marshaling https://learn.microsoft.com/en-us/dotnet/framework/unmanaged-api/metadata/imetadataemit-definemethod-method#slots-in-the-v-table\r\n\r\n### Reproduction Steps\r\n\r\nThis code works fine with .NET Framework or .NET 8 with built-in marshaling:\r\n\r\n```\r\n    internal class Program\r\n    {\r\n        static void Main()\r\n        {\r\n            CoCreateInstance(CLSID_WICImagingFactory, 0, CLSCTX_ALL, typeof(IWICImagingFactory).GUID, out var obj);\r\n            var factory = (IWICImagingFactory)obj;\r\n            factory.CreateQueryWriter(GUID_MetadataFormatApp1, 0, out var writer);\r\n        }\r\n\r\n        static readonly Guid GUID_MetadataFormatApp1 = new(\"8fd3dfc3-f951-492b-817f-69c2e6d9a5b0\");\r\n        static readonly Guid CLSID_WICImagingFactory = new(\"cacaf262-9370-4615-a13b-9f5539da4c0a\");\r\n        const int CLSCTX_ALL = 23;\r\n\r\n        [PreserveSig, DllImport(\"ole32\")]\r\n        public static extern int CoCreateInstance([MarshalAs(UnmanagedType.LPStruct)] Guid rclsid, nint pUnkOuter, int dwClsContext, [MarshalAs(UnmanagedType.LPStruct)] Guid riid, [MarshalAs(UnmanagedType.IUnknown)] out object ppv);\r\n\r\n        [ComImport, Guid(\"ec5ec8a9-c395-4314-9c77-54d7a935ff70\"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\r\n        public partial interface IWICImagingFactory\r\n        {\r\n            void _VtblGap1_23(); // skip 23 methods we don\u0027t need\r\n\r\n            [PreserveSig]\r\n            int CreateQueryWriter([MarshalAs(UnmanagedType.LPStruct)] Guid guidMetadataFormat, nint pguidVendor, out IWICMetadataQueryWriter ppIQueryWriter);\r\n        }\r\n\r\n        [ComImport, Guid(\"a721791a-0def-4d06-bd91-2118bf1db10b\"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\r\n        public partial interface IWICMetadataQueryWriter\r\n        {\r\n            // undefined yet\r\n        }\r\n    }\r\n\r\n```\r\n\r\nHere\u0027s an equivalent source-generated .NET 8 ComWrappers:\r\n\r\n```\r\ninternal partial class Program\r\n{\r\n    static unsafe void Main(string[] args)\r\n    {\r\n        CoCreateInstance(CLSID_WICImagingFactory, 0, CLSCTX_ALL, typeof(IWICImagingFactory).GUID, out var obj);\r\n        var factory = (IWICImagingFactory)obj;\r\n        factory.CreateQueryWriter(GUID_MetadataFormatApp1, Unsafe.NullRef\u003cGuid\u003e(), out var writer);\r\n    }\r\n\r\n    static readonly Guid GUID_MetadataFormatApp1 = new(\"8fd3dfc3-f951-492b-817f-69c2e6d9a5b0\");\r\n    static readonly Guid CLSID_WICImagingFactory = new(\"cacaf262-9370-4615-a13b-9f5539da4c0a\");\r\n    const int CLSCTX_ALL = 23;\r\n\r\n    [PreserveSig, LibraryImport(\"ole32\")]\r\n    public static partial int CoCreateInstance(in Guid rclsid, nint pUnkOuter, int dwClsContext, in Guid riid, [MarshalUsing(typeof(UniqueComInterfaceMarshaller\u003cobject\u003e))] out object ppv);\r\n\r\n    [GeneratedComInterface, Guid(\"ec5ec8a9-c395-4314-9c77-54d7a935ff70\")]\r\n    public partial interface IWICImagingFactory\r\n    {\r\n        void _VTblGap1_23(); // skip 23 methods we don\u0027t need\r\n\r\n        [PreserveSig]\r\n        int CreateQueryWriter(in Guid guidMetadataFormat, in Guid pguidVendor, out IWICMetadataQueryWriter ppIQueryWriter);\r\n    }\r\n\r\n    [GeneratedComInterface, Guid(\"a721791a-0def-4d06-bd91-2118bf1db10b\")]\r\n    public partial interface IWICMetadataQueryWriter\r\n    {\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n### Expected behavior\r\n\r\nIt should work the same.\r\n\r\n### Actual behavior\r\n\r\n.NET 8 source-generated ComWrappers version crashes with a \"System.AccessViolationException: Attempted to read or write protected memory\" because the code seems to consider _VtblGap1_23 as a regular method.\r\n\r\nNote if you change` _VTblGap1_23` by` _VtblGap1_23` (note the t has a different case), the error is not the same, you get a strange\r\n\r\n```\r\nUnhandled exception. System.MissingMethodException: Method not found: \u0027Void IWICImagingFactory._VtblGap1_23()\u0027.\r\n   at System.ModuleHandle.ResolveType(QCallModule module, Int32 typeToken, IntPtr* typeInstArgs, Int32 typeInstCount, IntPtr* methodInstArgs, Int32 methodInstCount, ObjectHandleOnStack type)\r\n   at System.ModuleHandle.ResolveTypeHandle(Int32 typeToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext)\r\n   at System.Reflection.RuntimeModule.ResolveType(Int32 metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)\r\n   at System.Reflection.CustomAttribute.FilterCustomAttributeRecord(MetadataToken caCtorToken, MetadataImport\u0026 scope, RuntimeModule decoratedModule, MetadataToken decoratedToken, RuntimeType attributeFilterType, Boolean mustBeInheritable, ListBuilder`1\u0026 derivedAttributes, RuntimeType\u0026 attributeType, IRuntimeMethodInfo\u0026 ctorWithParameters, Boolean\u0026 isVarArg)\r\n   at System.Reflection.CustomAttribute.AddCustomAttributes(ListBuilder`1\u0026 attributes, RuntimeModule decoratedModule, Int32 decoratedMetadataToken, RuntimeType attributeFilterType, Boolean mustBeInheritable, ListBuilder`1 derivedAttributes)\r\n   at System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeType type, RuntimeType caType, Boolean inherit)\r\n   at System.Attribute.GetCustomAttributes(MemberInfo element, Type attributeType, Boolean inherit)\r\n   at System.Attribute.GetCustomAttribute(MemberInfo element, Type attributeType, Boolean inherit)\r\n   at System.Runtime.InteropServices.Marshalling.IIUnknownDerivedDetails.GetFromAttribute(RuntimeTypeHandle handle)\r\n   at System.Runtime.InteropServices.Marshalling.ComObject.LookUpVTableInfo(RuntimeTypeHandle handle, TableInfo\u0026 result, Int32\u0026 qiHResult)\r\n   at System.Runtime.InteropServices.Marshalling.ComObject.System.Runtime.InteropServices.IDynamicInterfaceCastable.IsInterfaceImplemented(RuntimeTypeHandle interfaceType, Boolean throwIfNotImplemented)\r\n\r\n```\r\n\r\n### Regression?\r\n\r\nIt\u0027s a regression from built-in marshaling.\r\n\r\n### Known Workarounds\r\n\r\nI don\u0027t know any but declare dummy methods.\r\n\r\n### Configuration\r\n\r\nLatest .NET 8, Windows 11, 64-bit\r\n\r\n### Other information\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOfntp0A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5-UaSd",
                                           "createdAt":  "2024-05-19T15:41:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-05-19T15:41:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-UgdI",
                                           "createdAt":  "2024-05-19T17:16:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "@smourier Thanks for trying out this scenario. I\u0027m not sure we want to continue this behavior into the new system. This is an undocumented feature that is an implicit contract between .NET Framework/CoreCLR and the C# compiler. It is an oddity that I wish was done in a better way. The concept of creating a gap makes a lot of sense, but this mechanism seems to much magic. Is the pattern itself important here or just the ability to define a vtable gap?",
                                           "updatedAt":  "2024-05-19T17:16:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-UiMu",
                                           "createdAt":  "2024-05-19T17:49:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "smourier",
                                           "body":  "It was actually documented in \"CLI Partition II\" (as \"Microsoft Specific\") back then, as well as for example in in Serge Lidin\u0027s \"Expert .NET 2.0 IL Assembler\" book (I\u0027m an old COM programmer ...).\r\n\r\nIt does look a bit awkward and magic but I find the feature super useful when you just consume interfaces (obviously) with lots of members, for example in one of my answer here https://stackoverflow.com/a/60112084/403671\r\n\r\nAny mechanism that would allow (possibly multiple) gaps would be fine I guess, since we already lost source compatibility anyway with source-generation.",
                                           "updatedAt":  "2024-05-19T17:49:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-UimK",
                                           "createdAt":  "2024-05-19T17:55:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e It was actually documented in \"CLI Partition II\" (as \"Microsoft Specific\") back then\r\n\r\nIn ECMA-335? I can\u0027t find this in the spec anywhere.\r\n\r\n\u003e  as well as for example in in Serge Lidin\u0027s \"Expert .NET 2.0 IL Assembler\" book (I\u0027m an old COM programmer ...).\r\n\r\nYep. Serge\u0027s book is not authoritative though and discusses many implementation details that are best left avoided.\r\n\r\n\u003e Any mechanism that would allow (possibly multiple) gaps would be fine I guess\r\n\r\nPerfect.\r\n\r\n@jkoritzinsky and @jtschuster Any preference here? Retaining the `_VTblGap*` mechanic or a new attribute? I dislike the naming convention approach, but I admit I\u0027ve recommend this to people as well so I\u0027m sympathetic to retaining it.",
                                           "updatedAt":  "2024-05-19T18:40:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-Ui3Z",
                                           "createdAt":  "2024-05-19T18:00:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODibLUQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2024-05-19T18:19:29Z"
                                                                           },
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-05-20T11:08:48Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "smourier",
                                           "body":  "\u003e In ECMA-335? I can\u0027t find this in the spec anywhere.\r\n\r\nOh no, when I say old, I mean it :-) https://download.microsoft.com/download/7/3/3/733ad403-90b2-4064-a81e-01035a7fe13c/ms%20partition%20ii.pdf",
                                           "updatedAt":  "2024-05-19T18:00:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-UkKf",
                                           "createdAt":  "2024-05-19T18:19:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODibLAA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "smourier",
                                                                               "createdAt":  "2024-05-19T18:37:09Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-05-20T11:07:55Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "Ah, this is prior to standardization. Well, I am going to defer to @jkoritzinsky or @agocke here. I personally don\u0027t like this pattern at all, but it is niche enough and something I\u0027ve used as well. Regardless of whether we continue to respect the `_VTblGap*` pattern or we come up with an attribute placeholder, it should be documented and a test added. Going with the `_VTblGap*` pattern makes documentation much simpler for all Microsoft-created conforming runtime implementations though and I\u0027m not sure a new attribute is all that helpful given the implementation cost.\r\n\r\nRegardless, appreciate the issue, this is a documentation area that should be improved.",
                                           "updatedAt":  "2024-05-19T18:20:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-VIRf",
                                           "createdAt":  "2024-05-20T00:16:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "agocke",
                                           "body":  "Oh wow, that\u0027s quite subtle. Never seen it before. I\u0027m personally not opposed to supporting it as it does seem useful -- but I would probably support the existing mechanism if it\u0027s not too much trouble. It\u0027s already esoteric enough that I wouldn\u0027t want to invent a new, incompatible way of doing the same thing.",
                                           "updatedAt":  "2024-05-20T00:16:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-Vydc",
                                           "createdAt":  "2024-05-20T04:24:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "We could also chuck it in the ECMA-335 Augments so that it doesn\u0027t get lost in the future.",
                                           "updatedAt":  "2024-05-20T04:33:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-V0b1",
                                           "createdAt":  "2024-05-20T04:34:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODiYteQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hamarb123",
                                                                               "createdAt":  "2024-05-20T04:36:11Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e probably support the existing mechanism if it\u0027s not too much trouble\r\n\r\nDefinitely not too much trouble from the runtime side. Adding this specific support to the COM source generators might be tricky since the generator would then also need to parse the `_VTblGap*` pattern and that means creation of additional parsers. It isn\u0027t like this can be just a \"simple pass through\" though. The source generators need to create vtable slots and also decide how to respect this for CCWs.\r\n\r\n\u003e  We could also chuck it in the ECMA-335 Augments if we support it so that it doesn\u0027t get lost in the future.\r\n\r\nThis should remain outside the official ECMA-335. I appreciate the idea of adding documentation and that should happen in [here](https://learn.microsoft.com/dotnet/standard/native-interop/). Adding this to ECMA-335 is elevating this pattern to a place I\u0027d prefer to not clutter with niche historical artifacts.",
                                           "updatedAt":  "2024-05-20T04:34:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-WDio",
                                           "createdAt":  "2024-05-20T05:44:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dongle-the-gadget",
                                           "body":  "I\u0027m pretty sure there\u0027s another issue to propose using attributes to manually define VTables? It looks to be a more elegant solution than relying on gaps.",
                                           "updatedAt":  "2024-05-20T05:44:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-YFhQ",
                                           "createdAt":  "2024-05-20T11:21:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "\u003e In addition, as you can only define a method signature once, you can\u0027t have multiple gaps that are the same size.\r\n\r\nYou\u0027re supposed to have the sequence number according to the spec that was linked at the top of the original description (and it\u0027s also in the example code provided in the original description) - so there shouldn\u0027t actually be any issue with that.\r\n\u003cimg width=\"1713\" alt=\"image\" src=\"https://github.com/dotnet/runtime/assets/25316035/24455590-e92f-4200-a2a6-3341e14ff7fb\"\u003e",
                                           "updatedAt":  "2024-05-20T11:23:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-YH-P",
                                           "createdAt":  "2024-05-20T11:26:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODpfcCA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "maikschott",
                                                                               "createdAt":  "2024-07-12T11:09:29Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "colejohnson66",
                                           "body":  "I also think an attribute-based solution would be the best option. The `_VTblGap_X` method is a flaky hack. It\u0027s an implicit contract between the compiler and runtime.\r\n\r\nI think a \"VTable offset\" attribute would be the cleanest:\r\n\r\n```csharp\r\n[GeneratedComInterface, Guid(\"ec5ec8a9-c395-4314-9c77-54d7a935ff70\")]\r\npublic partial interface IWICImagingFactory\r\n{\r\n    [ComVTableOffset(23)]\r\n    int CreateQueryWriter(in Guid guidMetadataFormat, in Guid pguidVendor, out IWICMetadataQueryWriter ppIQueryWriter);\r\n}\r\n```\r\n\r\nMethods *after* one annotated with `[ComVTableOffset]` would, as before, have incrementing offsets, similar to enumerations with explicit values. It would be an error to have overlapping V-Table offsets.\r\n\r\nThe generator would change the output:\r\n```diff\r\n file unsafe partial interface InterfaceImplementation\r\n {\r\n     internal static void** CreateManagedVirtualFunctionTable()\r\n     {\r\n-        void** vtable = (void**)global::System.Runtime.CompilerServices.RuntimeHelpers.AllocateTypeAssociatedMemory(typeof(global::Program.IWICImagingFactory), sizeof(void*) * 5);\r\n+        void** vtable = (void**)global::System.Runtime.CompilerServices.RuntimeHelpers.AllocateTypeAssociatedMemory(typeof(global::Program.IWICImagingFactory), sizeof(void*) * 27);\r\n         {\r\n             nint v0, v1, v2;\r\n             global::System.Runtime.InteropServices.ComWrappers.GetIUnknownImpl(out v0, out v1, out v2);\r\n             vtable[0] = (void*)v0;\r\n             vtable[1] = (void*)v1;\r\n             vtable[2] = (void*)v2;\r\n         }\r\n\r\n         {\r\n-            vtable[3] = (void*)(delegate* unmanaged[MemberFunction]\u003cglobal::System.Runtime.InteropServices.ComWrappers.ComInterfaceDispatch*, int\u003e )\u0026ABI__VTblGap1_23;\r\n-            vtable[4] = (void*)(delegate* unmanaged[MemberFunction]\u003cglobal::System.Runtime.InteropServices.ComWrappers.ComInterfaceDispatch*, global::System.Guid*, global::System.Guid*, void**, int\u003e )\u0026ABI_CreateQueryWriter;\r\n+            vtable[26] = (void*)(delegate* unmanaged[MemberFunction]\u003cglobal::System.Runtime.InteropServices.ComWrappers.ComInterfaceDispatch*, global::System.Guid*, global::System.Guid*, void**, int\u003e )\u0026ABI_CreateQueryWriter;\r\n         }\r\n\r\n         return vtable;\r\n     }\r\n }\r\n```\r\n\r\nAn open question would be: should one be allowed to specify an offset lower than the current? Could I do this?\r\n\r\n```csharp\r\n[GeneratedComInterface, Guid(\"ec5ec8a9-c395-4314-9c77-54d7a935ff70\")]\r\npublic partial interface IWICImagingFactory\r\n{\r\n    [ComVTableOffset(23)]\r\n    HRESULT CreateQueryWriter(in Guid guidMetadataFormat, ref readonly Guid pguidVendor, out IWICMetadataQueryWriter ppIQueryWriter);\r\n\r\n    [ComVTableOffset(22)]\r\n    HRESULT CreatePalette(out IWICPalette ppIPalette);\r\n}\r\n```",
                                           "updatedAt":  "2024-05-20T11:32:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-e2nQ",
                                           "createdAt":  "2024-05-21T08:06:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dongle-the-gadget",
                                           "body":  "I think a VTable index option looks better.",
                                           "updatedAt":  "2024-05-21T08:06:13Z"
                                       }
                                   ],
                         "totalCount":  13
                     },
        "title":  ".NET 8 ComWrappers source generator doesn\u0027t handle _VTblGap* methods",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/102768",
        "createdAt":  "2024-05-28T16:13:22Z",
        "number":  102768,
        "author":  "t-mustafin",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-28T17:42:31Z",
        "body":  "Test Interop/Interop/Interop.dll returns 100 even if problems exist. ./Interop/Interop/Interop.dll was implemented by https://github.com/dotnet/runtime/pull/94109. @jkoritzinsky, please take a look.\r\n\r\nTest suite for this launch was built with `BuildAsStandalone=true` environment variable.\r\n```bash\r\n~/main_23may_7284f17/coreclr-tc$ ./coreroot/corerun ./Interop/Interop/Interop.dll \r\n12:25:42.155 Running test: global::WinRT.Program.CannotLoadWinRTType()\r\n12:25:42.689 Passed test: global::WinRT.Program.CannotLoadWinRTType()\r\n12:25:42.795 Running test: global::Program.TestEntryPoint()\r\nUnexpected Size for DefaultLayoutDefaultPacking`1[System.Runtime.Intrinsics.Vector256`1[System.Byte]].\r\n     Expected: 64; Actual: 48\r\nUnexpected Offset for DefaultLayoutDefaultPacking`1[System.Runtime.Intrinsics.Vector256`1[System.Byte]].Value.\r\n     Expected: 32; Actual: 16\r\n\r\nUnexpected Size for SequentialLayoutDefaultPacking`1[System.Runtime.Intrinsics.Vector256`1[System.Byte]].\r\n     Expected: 64; Actual: 48\r\nUnexpected Offset for SequentialLayoutDefaultPacking`1[System.Runtime.Intrinsics.Vector256`1[System.Byte]].Value.\r\n     Expected: 32; Actual: 16\r\n\r\nUnexpected Size for SequentialLayoutMaxPacking`1[System.Runtime.Intrinsics.Vector256`1[System.Byte]].\r\n     Expected: 64; Actual: 48\r\nUnexpected Offset for SequentialLayoutMaxPacking`1[System.Runtime.Intrinsics.Vector256`1[System.Byte]].Value.\r\n     Expected: 32; Actual: 16\r\n\r\nUnexpected Size for AutoLayoutDefaultPacking`1[System.Runtime.Intrinsics.Vector256`1[System.Byte]].\r\n     Expected: 64; Actual: 48\r\nUnexpected Offset for AutoLayoutDefaultPacking`1[System.Runtime.Intrinsics.Vector256`1[System.Byte]].Value.\r\n     Expected: 32; Actual: 16\r\n\r\nUnexpected Size for AutoLayoutMinPacking`1[System.Runtime.Intrinsics.Vector256`1[System.Byte]].\r\n     Expected: 64; Actual: 48\r\nUnexpected Offset for AutoLayoutMinPacking`1[System.Runtime.Intrinsics.Vector256`1[System.Byte]].Value.\r\n     Expected: 32; Actual: 16\r\n\r\nUnexpected Size for AutoLayoutMaxPacking`1[System.Runtime.Intrinsics.Vector256`1[System.Byte]].\r\n     Expected: 64; Actual: 48\r\nUnexpected Offset for AutoLayoutMaxPacking`1[System.Runtime.Intrinsics.Vector256`1[System.Byte]].Value.\r\n     Expected: 32; Actual: 16\r\n\r\nXunit.Sdk.EqualException: Assert.Equal() Failure: Values differ\r\nExpected: 100\r\nActual:   0\r\n   at Xunit.Assert.Equal[T](T expected, T actual, IEqualityComparer`1 comparer) in /_/src/Microsoft.DotNet.XUnitAssert/src/EqualityAsserts.cs:line 168\r\n   at Xunit.Assert.Equal[T](T expected, T actual) in /_/src/Microsoft.DotNet.XUnitAssert/src/EqualityAsserts.cs:line 90\r\n   at Program.\u003c\u003cMain\u003e$\u003eg__TestExecutor2|25_3(StreamWriter tempLogSw, StreamWriter statsCsvSw, \u003c\u003ec__DisplayClass25_0\u0026)\r\n12:25:43.972 Failed test: global::Program.TestEntryPoint()\r\n\r\n... \u003ccut big log here\u003e ...\r\n\r\n12:25:51.811 Running test: Interop/UnmanagedCallersOnly/UnmanagedCallersOnlyTest/UnmanagedCallersOnlyTest.cmd\r\n/home/tmustafin/main_23may_7284f17/coreclr-tc/Interop/Interop/../UnmanagedCallersOnly/UnmanagedCallersOnlyTest/UnmanagedCallersOnlyTest.sh: line 350: /corerun: No such file or directory\r\n\r\nReturn code:      1\r\nRaw output file:      /home/tmustafin/main_23may_7284f17/UnmanagedCallersOnly/UnmanagedCallersOnlyTest/output.txt\r\nRaw output:\r\nBEGIN EXECUTION\r\n/corerun -p System.Reflection.Metadata.MetadataUpdater.IsSupported=false -p System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization=true UnmanagedCallersOnlyTest.dll \u0027\u0027\r\nExpected: 100\r\nActual: 127\r\nEND EXECUTION - FAILED\r\nTest Harness Exitcode is : 1\r\nTo run the test:\r\nSet up CORE_ROOT and run.\r\n\u003e /home/tmustafin/main_23may_7284f17/coreclr-tc/Interop/Interop/../UnmanagedCallersOnly/UnmanagedCallersOnlyTest/UnmanagedCallersOnlyTest.sh\r\nXunit.Sdk.TrueException: /home/tmustafin/main_23may_7284f17/coreclr-tc/Interop/Interop/../UnmanagedCallersOnly/UnmanagedCallersOnlyTest/UnmanagedCallersOnlyTest.sh: line 350: /corerun: No such file or directory\r\n\r\nReturn code:      1\r\nRaw output file:      /home/tmustafin/main_23may_7284f17/UnmanagedCallersOnly/UnmanagedCallersOnlyTest/output.txt\r\nRaw output:\r\nBEGIN EXECUTION\r\n/corerun -p System.Reflection.Metadata.MetadataUpdater.IsSupported=false -p System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization=true UnmanagedCallersOnlyTest.dll \u0027\u0027\r\nExpected: 100\r\nActual: 127\r\nEND EXECUTION - FAILED\r\nTest Harness Exitcode is : 1\r\nTo run the test:\r\nSet up CORE_ROOT and run.\r\n\u003e /home/tmustafin/main_23may_7284f17/coreclr-tc/Interop/Interop/../UnmanagedCallersOnly/UnmanagedCallersOnlyTest/UnmanagedCallersOnlyTest.sh\r\n   at Xunit.Assert.True(Nullable`1 condition, String userMessage) in /_/src/Microsoft.DotNet.XUnitAssert/src/BooleanAsserts.cs:line 146\r\n   at Xunit.Assert.True(Boolean condition, String userMessage) in /_/src/Microsoft.DotNet.XUnitAssert/src/BooleanAsserts.cs:line 128\r\n   at TestLibrary.OutOfProcessTest.RunOutOfProcessTest(String assemblyPath, String testPathPrefix)\r\n   at Program.\u003c\u003cMain\u003e$\u003eg__TestExecutor225|25_226(StreamWriter tempLogSw, StreamWriter statsCsvSw, \u003c\u003ec__DisplayClass25_0\u0026)\r\n12:25:51.857 Failed test: Interop/UnmanagedCallersOnly/UnmanagedCallersOnlyTest/UnmanagedCallersOnlyTest.cmd\r\n12:25:51.865 Running test: Interop/UnmanagedCallersOnlyBasic/UnmanagedCallersOnlyBasicTest/UnmanagedCallersOnlyBasicTest.cmd\r\n/home/tmustafin/main_23may_7284f17/coreclr-tc/Interop/Interop/../UnmanagedCallersOnlyBasic/UnmanagedCallersOnlyBasicTest/UnmanagedCallersOnlyBasicTest.sh: line 350: /corerun: No such file or directory\r\n\r\nReturn code:      1\r\nRaw output file:      /home/tmustafin/main_23may_7284f17/UnmanagedCallersOnlyBasic/UnmanagedCallersOnlyBasicTest/output.txt\r\nRaw output:\r\nBEGIN EXECUTION\r\n/corerun -p System.Reflection.Metadata.MetadataUpdater.IsSupported=false -p System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization=true UnmanagedCallersOnlyBasicTest.dll \u0027\u0027\r\nExpected: 100\r\nActual: 127\r\nEND EXECUTION - FAILED\r\nTest Harness Exitcode is : 1\r\nTo run the test:\r\nSet up CORE_ROOT and run.\r\n\u003e /home/tmustafin/main_23may_7284f17/coreclr-tc/Interop/Interop/../UnmanagedCallersOnlyBasic/UnmanagedCallersOnlyBasicTest/UnmanagedCallersOnlyBasicTest.sh\r\nXunit.Sdk.TrueException: /home/tmustafin/main_23may_7284f17/coreclr-tc/Interop/Interop/../UnmanagedCallersOnlyBasic/UnmanagedCallersOnlyBasicTest/UnmanagedCallersOnlyBasicTest.sh: line 350: /corerun: No such file or directory\r\n\r\nReturn code:      1\r\nRaw output file:      /home/tmustafin/main_23may_7284f17/UnmanagedCallersOnlyBasic/UnmanagedCallersOnlyBasicTest/output.txt\r\nRaw output:\r\nBEGIN EXECUTION\r\n/corerun -p System.Reflection.Metadata.MetadataUpdater.IsSupported=false -p System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization=true UnmanagedCallersOnlyBasicTest.dll \u0027\u0027\r\nExpected: 100\r\nActual: 127\r\nEND EXECUTION - FAILED\r\nTest Harness Exitcode is : 1\r\nTo run the test:\r\nSet up CORE_ROOT and run.\r\n\u003e /home/tmustafin/main_23may_7284f17/coreclr-tc/Interop/Interop/../UnmanagedCallersOnlyBasic/UnmanagedCallersOnlyBasicTest/UnmanagedCallersOnlyBasicTest.sh\r\n   at Xunit.Assert.True(Nullable`1 condition, String userMessage) in /_/src/Microsoft.DotNet.XUnitAssert/src/BooleanAsserts.cs:line 146\r\n   at Xunit.Assert.True(Boolean condition, String userMessage) in /_/src/Microsoft.DotNet.XUnitAssert/src/BooleanAsserts.cs:line 128\r\n   at TestLibrary.OutOfProcessTest.RunOutOfProcessTest(String assemblyPath, String testPathPrefix)\r\n   at Program.\u003c\u003cMain\u003e$\u003eg__TestExecutor226|25_227(StreamWriter tempLogSw, StreamWriter statsCsvSw, \u003c\u003ec__DisplayClass25_0\u0026)\r\n12:25:51.913 Failed test: Interop/UnmanagedCallersOnlyBasic/UnmanagedCallersOnlyBasicTest/UnmanagedCallersOnlyBasicTest.cmd\r\n~/main_23may_7284f17/coreclr-tc$ echo $?\r\n100\r\n```\r\nFull Interop.dll launch log: [Interop_false_positive_log.txt](https://github.com/dotnet/runtime/files/15473517/Interop_false_positive_log.txt)\r\n\r\nRuntime and tests state: main branch, 23may 7284f17efe5f1ad7382f65ef3276ac89d594d3d3\r\n\r\ncc @gbalykov @clamp03\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOjexiPg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5_Uyyh",
                                           "createdAt":  "2024-05-28T21:42:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "Please don\u0027t use the `BuildAsStandalone=true` environment variable nowadays. That\u0027s no longer a supported testing scenario.\r\n\r\nPlease set `BuildAllTestsAsStandalone=true` environment variable instead to get into a supported scenario.",
                                           "updatedAt":  "2024-05-28T21:42:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5_Vban",
                                           "createdAt":  "2024-05-29T00:46:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "clamp03",
                                           "body":  "CC @dotnet/samsung ",
                                           "updatedAt":  "2024-05-29T00:46:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5_ahKl",
                                           "createdAt":  "2024-05-29T15:11:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "t-mustafin",
                                           "body":  "\u003e Please don\u0027t use the `BuildAsStandalone=true` environment variable nowadays. That\u0027s no longer a supported testing scenario.\r\n\u003e \r\n\u003e Please set `BuildAllTestsAsStandalone=true` environment variable instead to get into a supported scenario.\r\n\r\nThanks, with updated `BuildAllTestsAsStandalone=true` test behavior is the same, returns 100 even if some tests fails.",
                                           "updatedAt":  "2024-05-29T15:11:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5_bOxL",
                                           "createdAt":  "2024-05-29T16:41:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "It looks like even with `BuildAllTestsAsStandalone=true`, it\u0027s still building using the \"merged runner\" model that emits a test results file instead of standalone. Not sure why (might need to delete the test bin/obj artifacts when switching between these settings?). \r\n\r\nFor the merged runner model, it\u0027s expected that the runner will return \"success\", as returning otherwise indicates a failure in the test harness itself, not in a test, in our distributed testing system.\r\n\r\nCan you try doing a clean rebuild of the tests and see if this reproduces?",
                                           "updatedAt":  "2024-05-29T16:41:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5_ddLc",
                                           "createdAt":  "2024-05-29T23:48:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "t-mustafin",
                                           "body":  "\u003e Can you try doing a clean rebuild of the tests and see if this reproduces?\r\n\r\nThe check I made above included `rm -rf artifacts` before rebuild tests.\r\n\r\n\u003e For the merged runner model, it\u0027s expected that the runner will return \"success\", as returning otherwise indicates a failure in the test harness itself, not in a test, in our distributed testing system.\r\n\r\nIt means that test launcher need to parse log of merged `Interop.dll` instead of simple check of return value.",
                                           "updatedAt":  "2024-05-29T23:48:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6N7GI-",
                                           "createdAt":  "2024-09-29T02:40:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-09-29T02:40:58Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "False positive test Interop/Interop/Interop.dll",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/106979",
        "createdAt":  "2024-08-26T18:46:51Z",
        "number":  106979,
        "author":  "AaronRobinsonMSFT",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC6hFOg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2024-08-27T08:13:49Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-07-29T17:53:21Z",
        "body":  "### Background and motivation\r\n\r\nIt would be nice to have some wrappers that would return other interfaces pointers, something like:\r\n\r\n    ComWrappers.TryGetComInstance\u003cT\u003e(unwrapped, out nint iface);\r\n\r\nthat would do the QI so I could call it like this:\r\n\r\n    ComWrappers.TryGetComInstance\u003cIFoo\u003e(unwrapped, out nint ifoo);\r\n\r\nAs a \"frequent COM flyer\", It\u0027s quite perturbing to have to juggle between `ComWrappers` and `Marshal` classes, actually it would be nice with all that new code to be able to avoid using `Marshal` completely :-)\r\n\r\n_Originally posted by @smourier in https://github.com/dotnet/runtime/issues/106978#issuecomment-2310822826_\r\n\r\n```diff\r\npublic abstract partial class ComWrappers\r\n{\r\n+    public bool TryGetComInstance\u003cTInterface\u003e(object instance, CreateComInterfaceFlags flags, out IntPtr result);\r\n}\r\n```\r\n\r\nThis could also be an auto-generated method that would be provided on a derived `ComWrappers` instance. Looking up the IID on `TInterface` would need to be AOT friendly, which means `typeof(TInterface).GUID` is out.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Runtime.InteropServices;\r\n\r\npublic abstract class ComWrappers\r\n{\r\n      public bool TryGetComInstance(object instance, CreateComInterfaceFlags flags, in Guid interfaceId, out IntPtr result);\r\n}\r\n```\r\n\r\n```csharp\r\nnamespace System.Runtime.InteropServices.Marshalling;\r\n\r\npublic class StrategyBasedComWrappers\r\n{\r\n     public bool TryGetComInstance\u003cT\u003e(object instance, CreateComInterfaceFlags flags, out IntPtr result) where T : class;\r\n     public IntPtr GetComInstance\u003cT\u003e(T instance, CreateComInterfaceFlags flags) where T : class;\r\n}\r\n```\r\n\r\n### API Usage\r\n\r\n```csharp\r\nusing System;\r\nusing System.Runtime.CompilerServices;\r\nusing System.Runtime.InteropServices;\r\nusing System.Runtime.InteropServices.Marshalling;\r\n\r\n[assembly: DisableRuntimeMarshalling]\r\n\r\nnamespace ConsoleAotAuthor\r\n{\r\n    internal partial class Program\r\n    {\r\n        static void Main()\r\n        {\r\n            var cw = new StrategyBasedComWrappers();\r\n            var foo = new Foo();\r\n            bool success = cw.TryGetComInstance\u003cIFoo\u003e(foo, CreateComInterfaceFlags.None, out nint ifoo);\r\n            if (!success) throw new InvalidOper\r\n            GivePointerToComInterface(ifoo);\r\n        }\r\n\r\n        [LibraryImport(\"Dll1.dll\")]\r\n        private static partial void GivePointerToComInterface(nint comObject);\r\n    }\r\n\r\n    [GeneratedComInterface, Guid(\"217104c3-ce28-4d13-a32e-ef65ee75edf1\")]\r\n    public partial interface IFoo\r\n    {\r\n        void Method(int i);\r\n    }\r\n\r\n    [GeneratedComClass]\r\n    public partial class Foo : IFoo\r\n    {\r\n        public void Method(int i) =\u003e Console.WriteLine(\".NET i:\" + i);\r\n    }\r\n}\r\n```\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOicBvSw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6JvL7M",
                                           "createdAt":  "2024-08-26T18:48:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-08-26T18:48:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6JvXXw",
                                           "createdAt":  "2024-08-26T19:14:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "We could do this as a method on StrategyBasedComWrappers without too much trouble as we have a mechanism to look up interface details.\n\nOn ComWrappers, we\u0027d have to require the user to pass in the IID as there\u0027s no Type-\u003eIID mechanism at that level.",
                                           "updatedAt":  "2024-08-26T19:14:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Jvxy5",
                                           "createdAt":  "2024-08-26T20:13:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODvvGcw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkoritzinsky",
                                                                               "createdAt":  "2024-08-26T20:21:06Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e On ComWrappers, we\u0027d have to require the user to pass in the IID as there\u0027s no Type-\u003eIID mechanism at that level.\r\n\r\nI like that. We could follow what @smourier is alluding to and simply apply the `Marshal.QueryInterface` signature to the above. That way we have the low level API that we can build upon in derived `ComWrappers`?",
                                           "updatedAt":  "2024-08-26T20:13:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Jv1Dl",
                                           "createdAt":  "2024-08-26T20:21:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "Yep! I think that\u0027s a great way to do it.",
                                           "updatedAt":  "2024-08-26T20:21:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6JwG9L",
                                           "createdAt":  "2024-08-26T21:02:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODwVgiA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2024-08-26T21:16:24Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "PaulusParssinen",
                                                                               "createdAt":  "2024-08-30T00:26:00Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "I\u0027ve updated the top of the issue to be in the API Proposal format and added one more convenience overload that I think would be quite useful.",
                                           "updatedAt":  "2024-08-26T21:02:17Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "Suggestion `ComWrappers.TryGetComInstance()` to improve UX",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/107386",
        "createdAt":  "2024-09-05T07:07:01Z",
        "number":  107386,
        "author":  "tomeksowi",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-09-11T20:29:10Z",
        "body":  ".NET currently supports passing/returning structs according to hardware floating-point calling convention up to 16 bytes for reasons stated in https://github.com/dotnet/runtime/pull/107286#discussion_r1743260919\r\n\r\nNative ABI does not limit size of FP structs so this won\u0027t work:\r\n```c#\r\nstruct Empty {}\r\nstruct S { double; Empty; long; }\r\n\r\n[DllImport(\"SomeLib\")]\r\npublic static extern void func(S s);\r\n```\r\n.NET will pass S according to integer calling convention (by implicit reference) and the native side will expect it in two registers, fa0 and a0.\r\n\r\nSuch structs are acheivable via empty structs, which are undefined in C, which ABI .NET interops follow. However, it would be nice to throw an exception if FP structs \u003e 16 bytes appear in interops. (Things like `struct { _Alignas(16) double; long; }` are legal in C and .NET users may use empty structs to match the layout.)",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOiwI0Gg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6K7LeG",
                                           "createdAt":  "2024-09-05T07:08:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-09-05T07:08:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6K7Vr0",
                                           "createdAt":  "2024-09-05T07:31:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "am11",
                                           "body":  "\u003e .NET will pass S according to integer calling convention (by implicit reference) and the native side will expect it in two registers, fa0 and a0.\r\n\r\nCan we use custom marshalling to handle the specific layout and calling conventions required by the native side?\r\n\r\nAlternatively, a wrapper function on the native side that can handle the conversion between the .NET calling convention and the native calling convention? That wrapper would take the struct as passed by .NET, unpack it, and then repack it according to the native ABI expectations.",
                                           "updatedAt":  "2024-09-05T07:31:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6K7XeN",
                                           "createdAt":  "2024-09-05T07:35:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODxFUkA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "am11",
                                                                               "createdAt":  "2024-09-05T09:54:14Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tomeksowi",
                                           "body":  "\u003e Can we use custom marshalling to handle the specific layout and calling conventions required by the native side?\r\n\u003e\r\n\u003e Alternatively, a wrapper function on the native side that can handle the conversion between the .NET calling convention and the native calling convention? That wrapper would take the struct as passed by .NET, unpack it, and then repack it according to the native ABI expectations.\r\n\r\nI think it\u0027s not worth it, it\u0027s a corner-case achievable only by extra padding and the user has an easy (and cheaper performance-wise) way out of explicitly passing by `ref`.",
                                           "updatedAt":  "2024-09-05T07:35:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6LAVOi",
                                           "createdAt":  "2024-09-05T16:04:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e However, it would be nice to throw an exception if FP structs \u003e 16 bytes appear in interops.\r\n\r\n@tomeksowi Is this issue for support or for an exception? It isn\u0027t clear based on title and the above comment in the description.",
                                           "updatedAt":  "2024-09-05T16:04:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6LAjQa",
                                           "createdAt":  "2024-09-05T16:32:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tomeksowi",
                                           "body":  "\u003e @tomeksowi Is this issue for support or for an exception?\r\n\r\nException first, we can leave it open for visibility if anyone really needs it supported.",
                                           "updatedAt":  "2024-09-05T16:32:25Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "[RISC-V] FP structs larger than 16 bytes in interops",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "arch-riscv"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/108738",
        "createdAt":  "2024-10-10T04:14:04Z",
        "number":  108738,
        "author":  "Gaoyifei1011",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-04-02T20:18:20Z",
        "body":  "### Background and motivation\n\nSystem.Runtime.InteropServices.Marshalling.DelegateMarshaller for delegate\n\nThe System.Runtime.InteropServices.Marshalling namespace already contains a number of XXXMarshaller classes for P/Invoke source generation and COM source generation, which play an important role. However, regarding the delegate delegate type, we need to manually get the pointer of the delegate type or convert the pointer to the delegate type (method: [Marshal. GetFunctionPointerForDelegate()](https://learn.microsoft.com/dotnet/api/system.runtime.interopservices.marshal.getfunctionpointerfordelegate?view=net-8.0) and [Marshal. GetDelegateForFunctionPointer()](https://learn.microsoft.com/dotnet/api/system.runtime.interopservices.marshal.getdelegateforfunctionpointer?view=net-8.0)）。 So hopefully the DOTNET team will provide a DelegateMarshaller type that can automatically handle delegate-type marshalling, similar to [UTF16StringMarshaller]( https://learn.microsoft.com/dotnet/api/system.runtime.interopservices.marshalling.utf16stringmarshaller?view=net-8.0) That\u0027s it.\n\n#----------------------------------------------\n\n目前在 System.Runtime.InteropServices.Marshalling 命名空间中已经包含了大量的 XXXMarshaller 类用于 P/Invoke 源生成和 COM 源生成，这些类起到了重要作用。然而有关 delegate 委托类型，需要我们手动获取 delegate 类型的指针或者将指针转换为委托类型（方法：[Marshal.GetFunctionPointerForDelegate()](https://learn.microsoft.com/dotnet/api/system.runtime.interopservices.marshal.getfunctionpointerfordelegate?view=net-8.0) 和 [Marshal.GetDelegateForFunctionPointer()](https://learn.microsoft.com/dotnet/api/system.runtime.interopservices.marshal.getdelegateforfunctionpointer?view=net-8.0)）。所以希望 DOTNET 团队能提供一个 DelegateMarshaller 类型，能自动处理 delegate 类型封送，类似 [UTF16StringMarshaller](https://learn.microsoft.com/dotnet/api/system.runtime.interopservices.marshalling.utf16stringmarshaller?view=net-8.0) 那样。\n\n### API Proposal\n\n```csharp\nnamespace System.Runtime.InteropServices.Marshalling\n{\n    [CLSCompliant(false)]\n    [CustomMarshaller(typeof(Delegate), MarshalMode.Default, typeof(DelegateMarshaller))]\n    public static unsafe class DelegateMarshaller\n    {\n        /// \u003csummary\u003e\n        /// Converts a delegate to an unmanaged version.\n        /// \u003c/summary\u003e\n        /// \u003cparam name=\"managed\"\u003eThe managed delegate to convert.\u003c/param\u003e\n        /// \u003creturns\u003eAn unmanaged delegate.\u003c/returns\u003e\n        public static void* ConvertToUnmanaged(Delegate? managed);\n\n        /// \u003csummary\u003e\n        /// Converts an unmanaged delegate to a managed version.\n        /// \u003c/summary\u003e\n        /// \u003cparam name=\"unmanaged\"\u003eThe unmanaged delegate to convert.\u003c/param\u003e\n        /// \u003creturns\u003eA managed delegate.\u003c/returns\u003e\n        public static Delegate? ConvertToManaged(void* unmanaged);\n    }\n\n    [CLSCompliant(false)]\n    [CustomMarshaller(typeof(CustomMarshallerAttribute.GenericPlaceholder), MarshalMode.Default, typeof(DelegateMarshaller\u003c\u003e))]\n    public static unsafe class DelegateMarshaller\u003cTDelegate\u003e where TDelegate : notnull\n    {\n        /// \u003csummary\u003e\n        /// Converts a delegate to an unmanaged version.\n        /// \u003c/summary\u003e\n        /// \u003cparam name=\"managed\"\u003eThe managed delegate to convert.\u003c/param\u003e\n        /// \u003creturns\u003eAn unmanaged delegate.\u003c/returns\u003e\n        public static void* ConvertToUnmanaged(TDelegate? managed);\n\n        /// \u003csummary\u003e\n        /// Converts an unmanaged delegate to a managed version.\n        /// \u003c/summary\u003e\n        /// \u003cparam name=\"unmanaged\"\u003eThe unmanaged delegate to convert.\u003c/param\u003e\n        /// \u003creturns\u003eA managed delegate.\u003c/returns\u003e\n        public static TDelegate? ConvertToManaged(void* unmanaged);\n    }\n}\n```\n\n\n### API Usage\n\nUse for LibraryImport (P/Invoke source generation) and COMWrappers (COM source generation)\n\n\n### Alternative Designs\n\nNone\n\n### Risks\n\nNone",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOj0r9Vw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6PSXsq",
                                           "createdAt":  "2024-10-10T04:29:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "@Gaoyifei1011 Thanks for the suggestion. I know we discussed this when we were bringing up the `LibraryImport` generator. I thought we baked `Delegate` support into the system. Meaning there is no need for a custom marshaller, the source generator will just do the right thing, like the built-in case. See below:\n\nhttps://github.com/dotnet/runtime/blob/96968171150e154a2657d6fadca8b75bea9022c4/src/libraries/System.Runtime.InteropServices/gen/Microsoft.Interop.SourceGeneration/Marshalling/DelegateMarshaller.cs#L13\n\nTests:\n\nhttps://github.com/dotnet/runtime/blob/96968171150e154a2657d6fadca8b75bea9022c4/src/libraries/System.Runtime.InteropServices/tests/LibraryImportGenerator.Tests/DelegateTests.cs#L10-L23\n\nCan you elaborate on what specifically you need from a `Delegate` marshaller?",
                                           "updatedAt":  "2024-10-10T04:29:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6PScY9",
                                           "createdAt":  "2024-10-10T04:35:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Gaoyifei1011",
                                           "body":  "\u003e [@Gaoyifei1011](https://github.com/Gaoyifei1011) Thanks for the suggestion. I know we discussed this when we were bringing up the `LibraryImport` generator. I thought we baked `Delegate` support into the system. Meaning there is no need for a custom marshaller, the source generator will just do the right thing, like the built-in case. See below:\n\u003e \n\u003e [runtime/src/libraries/System.Runtime.InteropServices/gen/Microsoft.Interop.SourceGeneration/Marshalling/DelegateMarshaller.cs](https://github.com/dotnet/runtime/blob/96968171150e154a2657d6fadca8b75bea9022c4/src/libraries/System.Runtime.InteropServices/gen/Microsoft.Interop.SourceGeneration/Marshalling/DelegateMarshaller.cs#L13)\n\u003e \n\u003e Line 13 in [9696817](/dotnet/runtime/commit/96968171150e154a2657d6fadca8b75bea9022c4)\n\u003e \n\u003e  public sealed class DelegateMarshaller : IUnboundMarshallingGenerator \n\u003e Tests:\n\u003e \n\u003e [runtime/src/libraries/System.Runtime.InteropServices/tests/LibraryImportGenerator.Tests/DelegateTests.cs](https://github.com/dotnet/runtime/blob/96968171150e154a2657d6fadca8b75bea9022c4/src/libraries/System.Runtime.InteropServices/tests/LibraryImportGenerator.Tests/DelegateTests.cs#L10-L23)\n\u003e \n\u003e Lines 10 to 23 in [9696817](/dotnet/runtime/commit/96968171150e154a2657d6fadca8b75bea9022c4)\n\u003e \n\u003e  partial class NativeExportsNE \n\u003e  { \n\u003e      public delegate void VoidVoid(); \n\u003e   \n\u003e      [LibraryImport(NativeExportsNE_Binary, EntryPoint = \"invoke_callback_after_gc\")] \n\u003e      public static partial void InvokeAfterGC(VoidVoid cb); \n\u003e   \n\u003e      public delegate int IntIntInt(int a, int b); \n\u003e   \n\u003e      [LibraryImport(NativeExportsNE_Binary, EntryPoint = \"invoke_callback_blittable_args\")] \n\u003e      public static partial int InvokeWithBlittableArgument(IntIntInt cb, int a, int b); \n\u003e  } \n\u003e   \n\u003e  public class DelegateTests \n\u003e Can you elaborate on what specifically you need from a `Delegate` marshaller?\n\n![Image](https://github.com/user-attachments/assets/f1adae99-d82b-41d3-8754-770d2435f475)\nhttps://learn.microsoft.com/zh-cn/dotnet/standard/native-interop/disabled-marshalling\n\nI always thought that there was no default support yet and that I needed to manually convert to an IntPtr pointer.\n\n-------------------------\n\n我一直以为还没有提供默认支持，需要手动转换成IntPtr 指针。",
                                           "updatedAt":  "2024-10-10T04:35:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6PSkD1",
                                           "createdAt":  "2024-10-10T04:52:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Gaoyifei1011",
                                           "body":  "\u003e [@Gaoyifei1011](https://github.com/Gaoyifei1011) Thanks for the suggestion. I know we discussed this when we were bringing up the `LibraryImport` generator. I thought we baked `Delegate` support into the system. Meaning there is no need for a custom marshaller, the source generator will just do the right thing, like the built-in case. See below:\n\u003e \n\u003e [runtime/src/libraries/System.Runtime.InteropServices/gen/Microsoft.Interop.SourceGeneration/Marshalling/DelegateMarshaller.cs](https://github.com/dotnet/runtime/blob/96968171150e154a2657d6fadca8b75bea9022c4/src/libraries/System.Runtime.InteropServices/gen/Microsoft.Interop.SourceGeneration/Marshalling/DelegateMarshaller.cs#L13)\n\u003e \n\u003e Line 13 in [9696817](/dotnet/runtime/commit/96968171150e154a2657d6fadca8b75bea9022c4)\n\u003e \n\u003e  public sealed class DelegateMarshaller : IUnboundMarshallingGenerator \n\u003e Tests:\n\u003e \n\u003e [runtime/src/libraries/System.Runtime.InteropServices/tests/LibraryImportGenerator.Tests/DelegateTests.cs](https://github.com/dotnet/runtime/blob/96968171150e154a2657d6fadca8b75bea9022c4/src/libraries/System.Runtime.InteropServices/tests/LibraryImportGenerator.Tests/DelegateTests.cs#L10-L23)\n\u003e \n\u003e Lines 10 to 23 in [9696817](/dotnet/runtime/commit/96968171150e154a2657d6fadca8b75bea9022c4)\n\u003e \n\u003e  partial class NativeExportsNE \n\u003e  { \n\u003e      public delegate void VoidVoid(); \n\u003e   \n\u003e      [LibraryImport(NativeExportsNE_Binary, EntryPoint = \"invoke_callback_after_gc\")] \n\u003e      public static partial void InvokeAfterGC(VoidVoid cb); \n\u003e   \n\u003e      public delegate int IntIntInt(int a, int b); \n\u003e   \n\u003e      [LibraryImport(NativeExportsNE_Binary, EntryPoint = \"invoke_callback_blittable_args\")] \n\u003e      public static partial int InvokeWithBlittableArgument(IntIntInt cb, int a, int b); \n\u003e  } \n\u003e   \n\u003e  public class DelegateTests \n\u003e Can you elaborate on what specifically you need from a `Delegate` marshaller?\n\n![Image](https://github.com/user-attachments/assets/a88a875d-bf92-41d0-b619-ea7f8ce6a372)\n![Image](https://github.com/user-attachments/assets/7ed0631f-b639-4fc3-b48f-df72b566dac5)\n\nSo do the pointers of the struct support?\n",
                                           "updatedAt":  "2024-10-10T04:52:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6PSt0K",
                                           "createdAt":  "2024-10-10T05:18:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e So do the pointers of the struct support?\n\nAh. Field marshalling requires using the old pattern since we don\u0027t expose the marshaller. The problem with field marshalling is how complicated it gets. For example, the proposal has a bug in it because the `Delegate` instance needs a `GC.KeepAlive()` during the call. The marshaller must be stateful to be correct.",
                                           "updatedAt":  "2024-10-10T05:18:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6PSutU",
                                           "createdAt":  "2024-10-10T05:21:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Gaoyifei1011",
                                           "body":  "\u003e \u003e So do the pointers of the struct support?\n\u003e \n\u003e Ah. Field marshalling requires using the old pattern since we don\u0027t expose the marshaller. The problem with field marshalling is how complicated it gets. For example, the proposal has a bug in it because the instance needs a during the call. The marshaller must be stateful to be correct.`Delegate``GC.KeepAlive()`\n\nWell, thank you very much for the answer",
                                           "updatedAt":  "2024-10-10T05:21:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6PSv1X",
                                           "createdAt":  "2024-10-10T05:25:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "A correct `Delegate` marshaller will need state to keep the `Delegate` instance alive. See the [code that is emitted](https://github.com/dotnet/runtime/blob/96968171150e154a2657d6fadca8b75bea9022c4/src/libraries/System.Runtime.InteropServices/gen/Microsoft.Interop.SourceGeneration/Marshalling/DelegateMarshaller.cs#L13) by the `LibraryImport` source generator for what would need to happen.",
                                           "updatedAt":  "2024-10-10T05:25:35Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "[API Proposal]: System.Runtime.InteropServices.Marshalling.DelegateMarshaller for delegate",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/111593",
        "createdAt":  "2025-01-19T18:21:28Z",
        "number":  111593,
        "author":  "MichalPetryka",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC-juDw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hamarb123",
                                            "createdAt":  "2025-01-19T20:11:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2025-01-23T12:41:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jkrejcha",
                                            "createdAt":  "2025-01-29T04:54:26Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2025-01-20T18:00:33Z",
        "body":  "The current LibraryImport analyzer always suggests to convert to it from DllImport, even when it\u0027s not necessary due to the signature being blittable. This is especially annoying when multitargeting with older TFMs without LibraryImport.\nAs discussed on Discord, there should be an option to opt out of this with an editorconfig switch.\n\ncc @jkoritzinsky @tannergooding ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOmyXaEg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6bB6XJ",
                                           "createdAt":  "2025-01-19T18:21:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-01-19T18:21:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6bCJeG",
                                           "createdAt":  "2025-01-19T21:39:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e even when it\u0027s not necessary due to the signature being blittable\n\nThis is by design. The source generator does the right thing and there is zero cost from a run time perspective. The goal here was to be consistent in interop code.\n\n\u003e This is especially annoying when multitargeting with older TFMs without LibraryImport.\n\nThis is fair criticism and some thing I\u0027ve hit as well.\n\n@jkoritzinsky Should we try to educate the generator on the TFM issue or is creating an escape hatch easier and we can avoid more complexity?",
                                           "updatedAt":  "2025-01-19T21:39:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6bCL_E",
                                           "createdAt":  "2025-01-19T22:13:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hamarb123",
                                           "body":  "\u003e Should we try to educate the generator on the TFM issue or is creating an escape hatch easier and we can avoid more complexity?\n\nEducating the generator to be smarter with TFMs would not address all of my problems. Start of (most recent (there may have been more previously, idr)) conversation that caused this issue to be open:\n\n\u003cimg width=\"870\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/7a0b3ab5-b58c-4633-b0c5-30115f891ee9\" /\u003e\n\nFor me, the issue is not just \"is there cost at runtime\", it\u0027s also attribute clutter, unnecessary code churn, suggesting changes when I\u0027d rather just keep using the low-level mechanism (esp. when there\u0027s 0 benefit to changing it to me as it\u0027s already blittable), forcing me to put `partial` on everything for no reason, and the aformentioned TFM issue.\n\nFor the reasons mentioned in the discord, I think it\u0027s reasonable enough for the default to be \"just use `LibraryImport` everywhere\" (as that makes it easier to communicate to the majority of users how to do the right thing, without confusing them with too many options for which you need to understand complex things (e.g., whether your signature is blittable or not) to use correctly, etc.); but I think for some of us that are writing blittable bindings the vast majority of the time, this constant suggestion to do something that isn\u0027t actually better (and has some actual downsides in some cases) isn\u0027t great, when it could just be suggesting it in the cases where it actually improves my code (i.e., those with marshalling - to which my response would probably be \"time to remove the marshalling from this 😁\" (as it is probably either something old that needs to be updated anyway, or a bug)). I\u0027m happy to have to opt into this mode via editorconfig or msbuild property (preferred to me, as I can then set this mode by default and set `SYSLIB1054` to error in my project SDK) somehow.\n\nCurrently, I completely ignore `SYSLIB1054` as it\u0027s not a useful suggestion for most cases in my code. But there are some cases that likely exist where I indeed should be using `LibraryImport`, or where I could just remove the unnecessary marshalling myself \u0026 benefit even more.\n\nThanks for reading all that 😁",
                                           "updatedAt":  "2025-01-19T22:14:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6bCnlb",
                                           "createdAt":  "2025-01-20T01:41:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEDQmPQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hamarb123",
                                                                               "createdAt":  "2025-01-20T05:17:54Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2025-01-20T13:37:49Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "\u003e Should we try to educate the generator on the TFM issue or is creating an escape hatch easier and we can avoid more complexity?\n\nThere\u0027s not much we can do to handle the multi-TFM problem at the analyzer level (we can\u0027t see that it\u0027s a Multi TFM project).\n\nI suggested opening this issue as there\u0027s a small number of power users who write almost exclusively blittable bindings but don\u0027t want the compile time overhead of LibraryImport for thousands of blittable P/Invokes.\n\nAdding support for an editorconfig option to only suggest the code fix for \"marshalling required\" P/Invokes is quite cheap and would satisfy our power users with an opt-in option without violating our goal to keep interop usage consistent for our users.\n\nI view this option similarly to the \"convert to collection expressions\" analyzer and code-fix in Roslyn. The default experience is to always recommend, but there\u0027s an option to only recommend in a subset of cases. In their case, the differentiator is due to actual behavioral differences instead of just compile wall-clock-time differences, but the comparison still stands.",
                                           "updatedAt":  "2025-01-20T01:41:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6bJdoS",
                                           "createdAt":  "2025-01-20T17:25:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEDTZ2g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkoritzinsky",
                                                                               "createdAt":  "2025-01-20T18:00:25Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hamarb123",
                                                                               "createdAt":  "2025-01-20T20:35:45Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e There\u0027s not much we can do to handle the multi-TFM problem at the analyzer level \n\nOkay, that is unfortunate. \n\n\u003e I view this option similarly to the \"convert to collection expressions\" analyzer and code-fix in Roslyn.\n\nPrior art helps make this concrete, thanks.\n\nI\u0027ll mark this as Future, but it is fine if someone wants to handle this in .NET 10. Not sure how much bandwidth the interop team is going to have in .NET 10.",
                                           "updatedAt":  "2025-01-20T17:25:18Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "Add an editorconfig option to supress LibraryImport suggestion for blittable PInvokes",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "help wanted",
                       "code-analyzer"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/111616",
        "createdAt":  "2025-01-20T12:14:00Z",
        "number":  111616,
        "author":  "m-celikba",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODBnXNg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AaronRobinsonMSFT",
                                            "createdAt":  "2025-01-20T18:00:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "snechaev",
                                            "createdAt":  "2025-04-23T19:08:32Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2025-06-19T10:13:21Z",
        "body":  "In built in COM we had [`ExtensibleClassFactory.RegisterObjectCreationCallback`](https://learn.microsoft.com/dotnet/api/system.runtime.interopservices.extensibleclassfactory.registerobjectcreationcallback) where we could register a factory method (often in native code)\n\n```csharp\n[ComImport, Guid(\u003cguid1\u003e)]\npublic interface IMyInterface\n{\n   void DoStuff();\n}\n\n[ComImport, Guid(\u003cguid2\u003e)]\npublic class MyClassHelper : IMyInterface\n{\n    [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]\n    public virtual extern void DoStuff();\n}\n\n[Guid(\u003cguid2\u003e)]\npublic class MyClass : MyClassHelper \n{\n    static MyClass() \n    {\n        ExtensibleClassFactory.RegisterObjectCreationCallback(new ObjectCreationDelegate(CreateComInstanceDelegate));\n    }\n    private static IntPtr CreateComInstanceDelegate(IntPtr aggr) \n    {\n        return NativeMethods.CreateComInstance(typeof(MyClass).Guid);\n    }\n}\n\n// usage\nvar inst = new MyClass();\ninst.DoStuff();\n```\n\nin source generated COM I can do:\n\n```csharp\n[GeneratedComInterface, Guid(\u003cguid1\u003e)]\npublic interface IMyInterface\n{\n   void DoStuff();\n}\n\n// usage\nvar ptr = NativeMethods.CreateComInstance(typeof(MyClass).Guid);\nvar inst = ComInterfaceMarshaller\u003cIMyInterface\u003e.ConvertToManaged(ptr);\ninst.DoStuff();\n```\nwhich is not as straight forward as before.\nInstead I can use the decorator pattern:\n\n```csharp\n[GeneratedComClass, Guid(\u003cguid2\u003e)]\npublic class MyClass : IMyInterface \n{\n    private IMyInterface _inner;\n    public MyClass()\n    {\n        var ptr = NativeMethods.CreateComInstance(typeof(MyClass).Guid);\n        _inner = ComInterfaceMarshaller\u003cIMyInterface\u003e.ConvertToManaged(ptr);\n    }\n\n    public void DoStuff() =\u003e _inner.DoStuff();\n}\n\n// usage\nvar inst = new MyClass();\ninst.DoStuff();\n\n```\nI know I can probably write a source generator that does exactly that but it will be great if the default tooling could do that for us.\nsomething like:\n\n```csharp\n[GeneratedComClassWrapper(typeof(IMyInterface)), Guid(\u003cguid2\u003e)]\npublic class MyClass \n{\n    static MyClass() \n    {\n        RegisterObjectCreationCallback(static _ =\u003e NativeMethods.CreateComInstance(typeof(MyClass).Guid));\n    }\n}\n\n// usage\nvar inst = new MyClass();\ninst.DoStuff();\n```\nThis would help migrating dotnet framework code that make heavy use of builtin COM interop.\n\n\nEDIT: fixed declaration of _inner",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOshIaGg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6bG3Ll",
                                           "createdAt":  "2025-01-20T12:14:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-01-20T12:14:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6bJhEz",
                                           "createdAt":  "2025-01-20T17:34:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-01-20T17:34:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6bJrru",
                                           "createdAt":  "2025-01-20T18:03:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "@m-celikba Thanks for the suggestion and reminder of `ExtensibleClassFactory`! This is mentioned in Checkpoint 3 in https://github.com/dotnet/runtime/issues/66674. I\u0027m going to link that point to this issue.",
                                           "updatedAt":  "2025-01-20T18:03:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6yEhoa",
                                           "createdAt":  "2025-06-19T10:13:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "m-celikba",
                                           "body":  "@AaronRobinsonMSFT I\u0027d like to point out one important caveat with using the decorator in my original message: it breaks COM identity!\n\n\n```\n[GeneratedComClass, Guid(\u003cguid2\u003e)]\npublic class MyClass : IMyInterface \n{\n    public IMyInterface Inner { get; init; }\n    public MyClass()\n    {\n        var ptr = NativeMethods.CreateComInstance(typeof(MyClass).Guid);\n        Inner = ComInterfaceMarshaller\u003cIMyInterface\u003e.ConvertToManaged(ptr);\n    }\n\n    public void DoStuff() =\u003e _inner.DoStuff();\n}\n\n\nvar wrapper = new MyClass();\n\nDebug.Assert(Marshal.GetIUnknownForObject(wrapper) == Marshal.GetIUnknownForObject(wrapper.Inner), \"COM identity failed\"); // Shouldn\u0027t fail but fails.\n```\n\nIs there a way to tell the runtime in the constructor MyClass to treat the current MyClass  instance as the CCW of Inner ?\nI see ComWrappers.GetOrRegisterObjectForComInstance(). \nCan it be used this for this scenario while still using ComInterfaceMarshaller ?\n",
                                           "updatedAt":  "2025-06-19T10:13:20Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "GeneratedComInterface/Class needs a way to register a factory method",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/111654",
        "createdAt":  "2025-01-21T10:33:01Z",
        "number":  111654,
        "author":  "ViktorHofer",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-24T22:00:20Z",
        "body":  "```\n  installer.tasks -\u003e C:\\git\\runtime4\\artifacts\\bin\\installer.tasks\\Debug\\net10.0\\installer.tasks.dll\n  Crossgen2Tasks -\u003e C:\\git\\runtime4\\artifacts\\bin\\Crossgen2Tasks\\Debug\\net10.0\\Crossgen2Tasks.dll\n  Microsoft.Interop.SourceGeneration -\u003e C:\\git\\runtime4\\artifacts\\bin\\Microsoft.Interop.SourceGeneration\\Debug\\netstandard2.0\\Microsoft.Interop.SourceGeneration.dll\n  DownlevelLibraryImportGenerator -\u003e C:\\git\\runtime4\\artifacts\\bin\\DownlevelLibraryImportGenerator\\Debug\\netstandard2.0\\Microsoft.Interop.LibraryImportGenerator.Downle\n  vel.dll\n  installer.tasks -\u003e C:\\git\\runtime4\\artifacts\\bin\\installer.tasks\\Debug\\net472\\installer.tasks.dll\n  ILLink.RoslynAnalyzer -\u003e C:\\git\\runtime4\\artifacts\\bin\\ILLink.RoslynAnalyzer\\Debug\\netstandard2.0\\ILLink.RoslynAnalyzer.dll\n  ILLink.CodeFixProvider -\u003e C:\\git\\runtime4\\artifacts\\bin\\ILLink.CodeFixProvider\\Debug\\netstandard2.0\\ILLink.CodeFixProvider.dll\n  Mono.Linker -\u003e C:\\git\\runtime4\\artifacts\\bin\\Mono.Linker\\ref\\Debug\\net10.0\\illink.dll\n  Mono.Linker -\u003e C:\\git\\runtime4\\artifacts\\bin\\Mono.Linker\\Debug\\net10.0\\illink.dll\n  ILLink.Tasks -\u003e C:\\git\\runtime4\\artifacts\\bin\\ILLink.Tasks\\Debug\\net\\ILLink.Tasks.dll\n  System.Private.CoreLib.Generators -\u003e C:\\git\\runtime4\\artifacts\\bin\\System.Private.CoreLib.Generators\\Debug\\netstandard2.0\\System.Private.CoreLib.Generators.dll\n  System.Private.CoreLib -\u003e C:\\git\\runtime4\\artifacts\\bin\\System.Private.CoreLib\\ref\\Debug\\net10.0\\System.Private.CoreLib.dll\n  Microsoft.Interop.SourceGeneration -\u003e C:\\git\\runtime4\\artifacts\\bin\\Microsoft.Interop.SourceGeneration\\Debug\\netstandard2.0\\Microsoft.Interop.SourceGeneration.dll\n  LibraryImportGenerator -\u003e C:\\git\\runtime4\\artifacts\\bin\\LibraryImportGenerator\\Debug\\netstandard2.0\\Microsoft.Interop.LibraryImportGenerator.dll\n```\n\nand the build then later yet again builds the DownlevelLibraryImportGenerator project:\n```\n  BUILD: Product binaries are available at C:\\git\\runtime4\\artifacts\\bin\\coreclr\\linux.x64.Debug\\x64\n  runincontext -\u003e C:\\git\\runtime4\\artifacts\\bin\\coreclr\\windows.x64.Debug\\runincontext.dll\n  tieringtest -\u003e C:\\git\\runtime4\\artifacts\\bin\\coreclr\\windows.x64.Debug\\tieringtest.dll\n  DownlevelLibraryImportGenerator -\u003e C:\\git\\runtime4\\artifacts\\bin\\DownlevelLibraryImportGenerator\\Debug\\netstandard2.0\\Microsoft.Interop.LibraryImportGenerator.Downle\n  vel.dll\n  ILCompiler.TypeSystem -\u003e C:\\git\\runtime4\\artifacts\\bin\\ILCompiler.TypeSystem\\x64\\Debug\\ILCompiler.TypeSystem.dll\n```\n\ncc @jkoritzinsky ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOmz0aDA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6bPRoM",
                                           "createdAt":  "2025-01-21T11:32:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-01-21T11:32:01Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Microsoft.Interop.SourceGeneration gets built twice (with a potential of a race)",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "tenet-build-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/112038",
        "createdAt":  "2025-01-31T16:26:46Z",
        "number":  112038,
        "author":  "m-celikba",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-06-26T16:09:32Z",
        "body":  "Consider this example:\n\n```\n// c++\nstruct __declspec(uuid(...)) IMyItf : public IDispatch\n{\n    virtual HRESULT STDMETHODCALLTYPE DoStuff() = 0;\n   ~IMyItf() {};\n}\n```\n\nthis can be represented in c# as :\n\n```\n// c#\n[GeneratedComInterface, Guid(\"..\")]\ninterface IMyItf : IDispatch\n{\n     void DoStuff();\n}\n```\n\nwhere IDispatch is also a GeneratedComInterface declared as above.\n\nMy ask: it would be good to have the source generator treat interfaces marked with InterfaceType(ComInterfaceType.InterfaceIsDual) as if they were declared inheriting from IDispatch ie\n\n```\n[GeneratedComInterface, Guid(\"..\"), InterfaceType(ComInterfaceType.InterfaceIsDual)]\ninterface IMyItf \n{\n     void DoStuff();\n}\n```\nis equivalent to \n```\n[GeneratedComInterface, Guid(\"..\")]\ninterface IMyItf : IDispatch\n{\n     void DoStuff();\n}\n```\nwhere IDispatch is defined in the runtime.\n\nThe idea is that for a c++ COM object, we can then have a proper COM wrapper in c# where the interface layout is correctly set by the source generator.\nThis is not difficult to achieve, and provides a way forward for migrating legacy code that makes heavy ease of such IDispatch interfaces when we only care about using them in c# as normal IUnknown-based interfaces.\n\n\n\n\n\n\n\n\n\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOs1nreQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6zWelh",
                                           "createdAt":  "2025-06-26T16:09:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-06-26T16:09:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6zWet5",
                                           "createdAt":  "2025-06-26T16:09:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "@jkoritzinsky This is related to the conversation we\u0027ve been having offline about basic `IDispatch` vtable support.",
                                           "updatedAt":  "2025-06-26T16:09:20Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Feature request: Source generated COM interface that are marked with InterfaceType(ComInterfaceType.InterfaceIsDual) should inherit from IDispatch",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "source-generator"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/112103",
        "createdAt":  "2025-02-03T19:41:23Z",
        "number":  112103,
        "author":  "davidmatson",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-02-03T20:08:28Z",
        "body":  "Consider the following native code:\n```c++\n#include \u003ccstdio\u003e\n#include \u003ccstdint\u003e\n\nstruct log_record\n{\n    const char16_t* message;\n    const char16_t* file;\n    std::int32_t line;\n    std::int32_t padding;\n};\n\nextern \"C\" __declspec(dllexport) void log_v2(const log_record* record)\n{\n    if (record == nullptr || record-\u003emessage == nullptr || record-\u003efile == nullptr)\n    {\n        return;\n    }\n\n    wprintf(L\"%s(%i): %s\\n\", reinterpret_cast\u003cconst wchar_t*\u003e(record-\u003efile), record-\u003eline,\n        reinterpret_cast\u003cconst wchar_t*\u003e(record-\u003emessage));\n}\n\nextern \"C\" __declspec(dllexport) void log_v1(const char16_t* message, const char16_t* file, std::int32_t line)\n{\n    log_record record\n    {\n        message,\n        file,\n        line\n    };\n\n    log_v2(\u0026record);\n}\n```\n\nCalling log_v1 from C# using LibraryImport works nicely:\n```c#\nusing System.Runtime.InteropServices;\n\nstatic class Program\n{\n    static void Main()\n    {\n        NativeMethods.log_v1(\"Hello, World!\", \"file.cs\", 123);\n    }\n}\n\nstatic partial class NativeMethods\n{\n    const string libraryName = \"PInvokeExampleNative.dll\";\n\n    [LibraryImport(libraryName, StringMarshalling = StringMarshalling.Utf16)]\n    public static partial void log_v1(string? message, string? file, int line);\n}\n```\n\nand generates interop code that pins both strings:\n```c#\n// \u003cauto-generated/\u003e\nstatic unsafe partial class NativeMethods\n{\n    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.Interop.LibraryImportGenerator\", \"8.0.11.10305\")]\n    [global::System.Runtime.CompilerServices.SkipLocalsInitAttribute]\n    public static partial void log_v1(string message, string file, int line)\n    {\n        // Pin - Pin data in preparation for calling the P/Invoke.\n        fixed (void* __file_native = \u0026global::System.Runtime.InteropServices.Marshalling.Utf16StringMarshaller.GetPinnableReference(file))\n        fixed (void* __message_native = \u0026global::System.Runtime.InteropServices.Marshalling.Utf16StringMarshaller.GetPinnableReference(message))\n        {\n            __PInvoke((ushort*)__message_native, (ushort*)__file_native, line);\n        }\n\n        // Local P/Invoke\n        [global::System.Runtime.InteropServices.DllImportAttribute(\"PInvokeExampleNative.dll\", EntryPoint = \"log_v1\", ExactSpelling = true)]\n        static extern unsafe void __PInvoke(ushort* __message_native, ushort* __file_native, int __line_native);\n    }\n}\n```\n\nBut there does not appear to be any way to call log_v2 while pinning both strings:\n```c#\nusing System.Runtime.InteropServices;\n\nstatic class Program\n{\n    static void Main()\n    {\n        NativeMethods.log_v1(\"Hello, World!\", \"file.cs\", 123);\n        NativeLogRecord record = new(\"Hello, World!\", \"file2.cs\", 456);\n        NativeMethods.log_v2(ref record);\n    }\n}\n\nreadonly struct NativeLogRecord(string? message, string? file, int line)\n{\n    public readonly string? Message = message;\n    public readonly string? File = file;\n    public readonly int? Line = line;\n}\n\nstatic partial class NativeMethods\n{\n    const string libraryName = \"PInvokeExampleNative.dll\";\n\n    [LibraryImport(libraryName, StringMarshalling = StringMarshalling.Utf16)]\n    public static partial void log_v1(string? message, string? file, int line);\n\n    // Does not compile:\n    [LibraryImport(libraryName, StringMarshalling = StringMarshalling.Utf16)]\n    public static partial void log_v2(ref NativeLogRecord record);\n}\n```\n\nEven when using a custom marshaller for NativeLogRecord, the only option appears to be to allocate new copies of both strings in ConvertManagedToNative and then free them in Free.\n\nFor log_v2 to pin both strings like log_v1 does, the only option appears to be to use a wrapper function that handles that pinning explicitly - it\u0027s not possible to do this via a custom marshaller, as far as I can tell:\n\n```c#\nusing System.Runtime.InteropServices;\n\nstatic class Program\n{\n    static void Main()\n    {\n        NativeMethods.log_v1(\"Hello, World!\", \"file.cs\", 123);\n        NativeLogRecordNeedsManagedWrapper record = new(\"Hello, World!\", \"file2.cs\", 456);\n        NativeMethods.LogV2NeedsWrapperMethod(ref record);\n    }\n}\n\nreadonly struct NativeLogRecordNeedsManagedWrapper(string? message, string? file, int line)\n{\n    public readonly string? Message = message;\n    public readonly string? File = file;\n    public readonly int Line = line;\n}\n\nunsafe readonly struct NativeLogRecord(char* message, char* file, int line)\n{\n    public readonly char* Message = message;\n    public readonly char* File = file;\n    public readonly int Line = line;\n}\n\nstatic partial class NativeMethods\n{\n    const string libraryName = \"PInvokeExampleNative.dll\";\n\n    [LibraryImport(libraryName, StringMarshalling = StringMarshalling.Utf16)]\n    public static partial void log_v1(string? message, string? file, int line);\n\n    [LibraryImport(libraryName, StringMarshalling = StringMarshalling.Utf16)]\n    public static partial void log_v2(ref NativeLogRecord record);\n\n    public static unsafe void LogV2NeedsWrapperMethod(ref NativeLogRecordNeedsManagedWrapper record)\n    {\n        fixed (char* message = record.Message)\n        fixed (char* file = record.File)\n        {\n            NativeLogRecord nativeRecord = new(message, file, record.Line);\n            log_v2(ref nativeRecord);\n        }\n    }\n}\n```\n\nThe request here is for some way to write a custom marshaller such that the generated interop code pins both strings (and the wrapper struct), without needing additional heap allocation. The goal would to be have the generated code look something like this:\n\n```c#\n```c#\n// \u003cauto-generated/\u003e\nstatic unsafe partial class NativeMethods\n{\n    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.Interop.LibraryImportGenerator\", \"8.0.11.10305\")]\n    [global::System.Runtime.CompilerServices.SkipLocalsInitAttribute]\n    public static partial void log_v1(string message, string file, int line)\n    {\n        // Pin - Pin data in preparation for calling the P/Invoke.\n        fixed (void* __file_native = \u0026global::System.Runtime.InteropServices.Marshalling.Utf16StringMarshaller.GetPinnableReference(file))\n        fixed (void* __message_native = \u0026global::System.Runtime.InteropServices.Marshalling.Utf16StringMarshaller.GetPinnableReference(message))\n        {\n            __PInvoke((ushort*)__message_native, (ushort*)__file_native, line);\n        }\n\n        // Local P/Invoke\n        [global::System.Runtime.InteropServices.DllImportAttribute(\"PInvokeExampleNative.dll\", EntryPoint = \"log_v1\", ExactSpelling = true)]\n        static extern unsafe void __PInvoke(ushort* __message_native, ushort* __file_native, int __line_native);\n    }\n}\nstatic unsafe partial class NativeMethods\n{\n    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.Interop.LibraryImportGenerator\", \"8.0.11.10305\")]\n    [global::System.Runtime.CompilerServices.SkipLocalsInitAttribute]\n    public static partial void log_v2(ref global::LogRecord record)\n    {\n        // Pin - Pin data in preparation for calling the P/Invoke.\n        fixed (char* __record_native_pin1 = \u0026global::LogRecordMarshaller::GetPinnableReference1(record))\n        fixed (char* __record_native_pin2 = \u0026global::LogRecordMarshaller::GetPinnableReference2(record))\n        {\n            global::NativeLogRecord nativeRecord = ::global::LogRecordMarshaller::ManagedToNative(record, __record_native_pin1, __record_native_pin2);\n\n            fixed (global::NativeLogRecord* __record_native = \u0026nativeRecord)\n            {\n                __PInvoke(__record_native);\n            }\n        }\n\n        // Local P/Invoke\n        [global::System.Runtime.InteropServices.DllImportAttribute(\"PInvokeExampleNative.dll\", EntryPoint = \"log_v2\", ExactSpelling = true)]\n        static extern unsafe void __PInvoke(global::NativeLogRecord* __record_native);\n    }\n}\n```\n\nFrom source that looks something like this (details could vary; as long as the generated code is in the shape shown above and pins both strings):\n```c#\nusing System;\nusing System.Runtime.InteropServices;\nusing System.Runtime.InteropServices.Marshalling;\n\nstatic class Program\n{\n    static void Main()\n    {\n        NativeMethods.log_v1(\"Hello, World!\", \"file.cs\", 123);\n        LogRecord record = new(\"Hello, World!\", \"file2.cs\", 456);\n        NativeMethods.log_v2(ref record);\n    }\n}\n\n[NativeMarshalling(typeof(LogRecordMarshaller))]\nstruct LogRecord(string? message, string? file, int line)\n{\n    public string? Message = message;\n    public string? File = file;\n    public int Line = line;\n}\n\nstatic partial class NativeMethods\n{\n    const string libraryName = \"PInvokeExampleNative.dll\";\n\n    [LibraryImport(libraryName, StringMarshalling = StringMarshalling.Utf16)]\n    public static partial void log_v1(string? message, string? file, int line);\n\n    [LibraryImport(libraryName, StringMarshalling = StringMarshalling.Utf16)]\n    public static partial void log_v2(ref LogRecord record);\n}\n\n[CustomMarshaller(typeof(LogRecord), MarshalMode.ManagedToUnmanagedIn, typeof(LogRecordMarshaller))]\nstatic class LogRecordMarshaller\n{\n    public static ref string? GetPinnableReference1(ref LogRecord managed) =\u003e ref managed.Message;\n\n    public static ref string? GetPinnableReference2(ref LogRecord managed) =\u003e ref managed.File;\n\n    public unsafe static LogRecord ConvertToManaged(LogRecordNative) =\u003e throw new NotImplementedException();\n\n    public unsafe static LogRecordNative ConvertToUnmanaged(ref LogRecord managed, char* pin1, char* pin2)\n    {\n        return new LogRecordNative(pin1, pin2, managed.Line);\n    }\n\n    public static void Free(LogRecordNative unmanaged) { }\n\n    public unsafe readonly struct LogRecordNative(char* message, char* file, int line)\n    {\n        public readonly char* Message = message;\n        public readonly char* File = file;\n        public readonly int Line = line;\n    }\n}\n```\n\n(Note that solving the scenario above might also open the possibility of writing a custom marshaller for a struct that includes other marshalled structs as fields, since it could provide pinnable references for each field inside.)\n\nOverall, log_v1 works really easily today, pinning multiple strings used by the native function, but there doesn\u0027t appear to be any way to that when there\u0027s a wrapper struct, and supporting this capability in LibraryImport would be a significant improvement.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOnOCVXA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6c38vw",
                                           "createdAt":  "2025-02-03T19:41:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-02-03T19:41:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6c4JVc",
                                           "createdAt":  "2025-02-03T20:08:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "This is something I\u0027m generally interested in, but we\u0027re still trying to figure out a good pattern for.",
                                           "updatedAt":  "2025-02-03T20:08:21Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Feature Request: LibraryImport Support for Marshalling structs with Multiple Pinnable Items",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/112589",
        "createdAt":  "2025-02-14T22:53:14Z",
        "number":  112589,
        "author":  "leandro-benedet-garcia",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODKweKw==",
                          "nodes":  [
                                        {
                                            "content":  "EYES",
                                            "user":  "Copilot",
                                            "createdAt":  "2025-08-11T21:08:37Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-08-18T06:43:21Z",
        "body":  "### Description\n\nWhile making a binding using SDL3-CS as a reference project I found a very weird error:\n\n```\n/bug_project/bug.cs(21,35): error SYSLIB1052: The specified \u0027MarshalAsAttribute\u0027 configuration for the return value of method \u0027SDL_ShaderCross_Init\u0027 is not supported by source-generated P/Invokes. If the specified configuration is required, use a regular \u0027DllImport\u0027 instead. (https://learn.microsoft.com/dotnet/fundamentals/syslib-diagnostics/syslib1052)\n```\n\nThe binding in question is:\n```csharp\n[LibraryImport(\"SDL3_shadercross\")]\n[UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]\npublic static partial SDLBool SDL_ShaderCross_Init();\n```\n\nThe declaration of `SDLBool` can be found here https://github.com/flibitijibibo/SDL3-CS/blob/42d1b438aabeabd68385cba3ed5c21e73e8cc877/SDL3/SDL3.Core.cs#L44-L75\n\n### Reproduction Steps\n\nMinimum reproducible project:\n\n[binding_bug.zip](https://github.com/user-attachments/files/18805316/binding_bug.zip)\n\n### Expected behavior\n\nI would expect the code to work with and without the project reference.\n\nOr at least, be told that I cannot use bindings from a referenced project.\n\n### Actual behavior\n\nA confusing error message.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nIf I instead remove the reference and add this to the project file:\n```xml\n\u003cItemGroup\u003e\n  \u003cCompile Include=\"lib\\SDL3-CS\\SDL3\\SDL3.Core.cs\" /\u003e\n\u003c/ItemGroup\u003e\n```\n\nThe code compiles fine.\n\n### Configuration\n\n- Which version of .NET is the code running on?\n  Dotnet version 9.0.102\n- What OS and version, and what distro if applicable?\n  Arch Linux kernel version 6.13.2-arch1-1 \n- What is the architecture (x64, x86, ARM, ARM64)?\n  x86_64\n- Do you know whether it is specific to that configuration?\n  Unsure\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOnpwDGA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6ekyhG",
                                           "createdAt":  "2025-02-14T23:12:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-02-14T23:12:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ek0OC",
                                           "createdAt":  "2025-02-14T23:20:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kg",
                                           "body":  "Additional context from discord troubleshooting:\n* `void X ()` worked\n* primitive return types and parameter types i.e. `int` worked\n* They were using `ProjectReference` to pull in types like SDLBool from another assembly that contained its own `LibraryImport`s, not an assembly or package reference",
                                           "updatedAt":  "2025-02-14T23:20:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6emqdk",
                                           "createdAt":  "2025-02-15T13:56:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEGesNg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2025-02-15T17:53:49Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "This is expected. See also #98616 . Type from other assembly are not considered as invariant in compile time.",
                                           "updatedAt":  "2025-02-15T13:56:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6emvdG",
                                           "createdAt":  "2025-02-15T14:52:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kg",
                                           "body":  "OK, sounds like this is a documentation/error quality issue then? Because none of the documentation I found explains this, and the error suggests it\u0027s related to use of MarshalAs when MarshalAs isn\u0027t in use",
                                           "updatedAt":  "2025-02-15T14:52:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6emvw7",
                                           "createdAt":  "2025-02-15T14:55:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEGesOA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2025-02-15T17:53:52Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "leandro-benedet-garcia",
                                           "body":  "\u003e This is expected. See also [#98616](https://github.com/dotnet/runtime/issues/98616) . Type from other assembly are not considered as invariant in compile time.\n\nI still would expect, that at least,  the error tell me that I cannot do that.\n\nI can understand that It is not supported. \n\n\u003e OK, sounds like this is a documentation/error quality issue then? Because none of the documentation I found explains this, and the error suggests it\u0027s related to use of MarshalAs when MarshalAs isn\u0027t in use\n\nYeah, the link that it gives, where it could provide me with information in how to fix the issue, or why it happens, just repeats the error. And since the error is not directly related to the cause of the issue, looking up a search engine does not help at all.",
                                           "updatedAt":  "2025-02-15T15:01:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6enAMY",
                                           "createdAt":  "2025-02-15T17:54:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEGetLQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkoritzinsky",
                                                                               "createdAt":  "2025-02-15T18:04:08Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "@jkoritzinsky or @jtschuster Creating a clearer error message here seems appropriate.\n\n@huoyaoyuan If you\u0027re feeling ambitious, feel free to handle this :)",
                                           "updatedAt":  "2025-02-15T17:54:54Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "LibraryImport fails with MarshalAsAttribute errors when return value or parameter types are from another assembly",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/113132",
        "createdAt":  "2025-03-04T17:39:22Z",
        "number":  113132,
        "author":  "hez2010",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-03-10T20:14:46Z",
        "body":  "We are missing `where T : allows ref struct` on:\n\n- `MemoryMarshal.Read`\n- `MemoryMarshal.TryRead`\n- `MemoryMarshal.Write`\n- `MemoryMarshal.TryWrite`\n- `MemoryMarshal.AsRef`\n- `MemoryMarshal.AsRef` (readonly ref)",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOoOdZ1g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6g1uHV",
                                           "createdAt":  "2025-03-04T17:39:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-03-04T17:39:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6g1wRu",
                                           "createdAt":  "2025-03-04T17:43:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "All of these are blocking `IsReferenceOrContainsReferences` because of GC safety. A `ref struct` without `ref` field is not so meaningful.",
                                           "updatedAt":  "2025-03-04T17:43:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6g1yLJ",
                                           "createdAt":  "2025-03-04T17:47:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEImElw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "neon-sunset",
                                                                               "createdAt":  "2025-03-05T09:45:30Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "hez2010",
                                           "body":  "\u003e All of these are blocking `IsReferenceOrContainsReferences` because of GC safety. \n\nYeah. But note that `IsReferenceOrContainsReferences\u003cT\u003e()` has `where T: allows ref struct` so it shouldn\u0027t be a problem in terms of compilation.\n\n\u003e A `ref struct` without `ref` field is not so meaningful.\n\nYou don\u0027t have control to types coming from other libs. Some libs just define all their value types as `ref struct` to avoid unexpected boxing regardless of whether it has a `ref` field in it or not.\n\nWe can already do `Unsafe.ReadUnaligned\u003cFoo\u003e(ref MemoryMarshal.GetReference(span))` (where `Foo` is a ref struct), so I don\u0027t see a reason why its short-hand `MemoryMarshal.Read\u003cFoo\u003e(span)` should be blocked.",
                                           "updatedAt":  "2025-03-04T18:00:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6g127i",
                                           "createdAt":  "2025-03-04T17:56:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-03-04T17:56:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6g19zj",
                                           "createdAt":  "2025-03-04T18:10:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "\u003e We can already do `Unsafe.ReadUnaligned\u003cFoo\u003e(ref MemoryMarshal.GetReference(span))` (where `Foo` is a ref struct), so I don\u0027t see a reason why its short-hand `MemoryMarshal.Read\u003cFoo\u003e(span)` should be blocked.\n\n`Unsafe.ReadUnaligned` is not GC safe. It can also be used with `class` to read a GC reference from byte span. Using it with reference type or `Span\u003cT\u003e` can easily cause GC hole and access violation.\n\n`MemoryMarshal` is safer than `Unsafe`. All its APIs don\u0027t allow breaking the boundary between value and GC ref.\n\n\u003e You don\u0027t have control to types coming from other libs. Some libs just define all their value types as `ref struct` to avoid unexpected boxing regardless of whether it has a `ref` field in it or not.\n\nUsing pointer should be sufficient in these cases.",
                                           "updatedAt":  "2025-03-04T18:10:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6g51nW",
                                           "createdAt":  "2025-03-05T01:47:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEImEwQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "neon-sunset",
                                                                               "createdAt":  "2025-03-05T09:45:49Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "hez2010",
                                           "body":  "\u003e MemoryMarshal is safer than Unsafe\n\nThat\u0027s why we need it to take a ref struct so that it can help block invalid usage because it checks gc pointer for you. Without the support, people will just copy whatever the code from its implementation and make their code even more unsafe. \n\n\u003e Using pointer should be sufficient in these cases.\n\nThis doesn\u0027t hold as you can replace almost all Unsafe.* API usage by using pointers, so it should have been so sufficient that Unsafe.* API shouldn\u0027t even have existed in the first place. ",
                                           "updatedAt":  "2025-03-05T01:50:46Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "MemoryMarshal.{Try}Read/{Try}Write/AsRef should allow ref struct",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/113162",
        "createdAt":  "2025-03-05T13:17:44Z",
        "number":  113162,
        "author":  "Aniobodo",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-03-25T19:22:55Z",
        "body":  "**Version Used**: \n.NET SDK 9.0.200\n\nRepro:\n```\nusing System.Runtime.InteropServices;\n\nnamespace ConsoleApp1;\npublic static class InfoBox\n{\n    [DllImport(\"user32.dll\", CharSet = CharSet.Unicode)]\n    static extern int InfoBoxA(nint hWnd,\n        string lpText,\n        string lpCaption,\n        uint uType);\n}\n```\n\n**Steps to Reproduce**:\n\n1. Create a project with the above repro in Visual Studio 2022.\n2. SYSLIB1054: Respond to the Quick Action tip (Yellow light bulb) on the method by accepting the suggestion.\n3. Recognise the new error CS8796\n\nhttps://github.com/user-attachments/assets/4f49c41c-4a6c-4fb6-a3e2-eb54021e7890\n\n**Diagnostic Id**:\nCS8796\n\n**Expected Behavior**:\nNo error if Quick Action suggestion is accepted\n\n**Actual Behavior**: \nAccepting the suggestion from Quick Action tip results in compiler error  CS8796\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOoQS1vA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6hA8tS",
                                           "createdAt":  "2025-03-05T13:17:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one area label.",
                                           "updatedAt":  "2025-03-05T13:17:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6hA8tg",
                                           "createdAt":  "2025-03-05T13:17:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one area label.",
                                           "updatedAt":  "2025-03-05T13:17:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6hBLUb",
                                           "createdAt":  "2025-03-05T16:22:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-03-05T16:22:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6hBLW8",
                                           "createdAt":  "2025-03-05T16:23:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "The fixer should be adding a visibility modifier to the generated partial.",
                                           "updatedAt":  "2025-03-05T16:23:01Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Suggested solution to SYSLIB1054 results in compiler error  CS8796",
        "labels":  [
                       "bug",
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/113970",
        "createdAt":  "2025-03-27T15:43:02Z",
        "number":  113970,
        "author":  "ThaDaVos",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-07T20:22:25Z",
        "body":  "### Description\n\nTaking below declarations, when using `Marshal.PtrToStructure\u003c\u003e()`, the fields from the base `record` aren\u0027t filled, adding to that, the `StructLayoutAttribute` is not inherited (no problem, just stating), throwing an error that the size could not be determined (giving a hint it doesn\u0027t see the fields) - I also tried setting the fields to `protected` and `public/internal`:\n```csharp\n[StructLayout(LayoutKind.Sequential, Pack = 1, CharSet = CharSet.Ansi)]\npublic record A\u003cT\u003e where T : struct\n{\n    [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n    private string name;\n    public string Name =\u003e name;\n\n    private T value;\n    public T Value =\u003e value;\n}\n\npublic struct BValues\n{\n    public int x;\n    public int y;\n    public int z;\n}\n\n[StructLayout(LayoutKind.Sequential, Pack = 1, CharSet = CharSet.Ansi)]\npublic record B : A\u003cBValues\u003e\n{\n\n}\n```\n\n### Reproduction Steps\n\nPlease see the given code snippet above\n\n### Expected behavior\n\nI expected the fields from the base class to be marshalled/filled first, or at least, filled at all\n\n### Actual behavior\n\nThey stay empty\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nChanging the fields to be `private`, making the properties `virtual` and re-implementing the logic - defeating the purpose of the base class except methods - so moving the field/properties to each subrecord\n\n### Configuration\n\n- **Which version of .NET is the code running on?**\nDotnet Version: 9.0.104\n- **What OS and version, and what distro if applicable?**\nWindows 11 24h2\n- **What is the architecture (x64, x86, ARM, ARM64)?**\nx86-windows\n- **Do you know whether it is specific to that configuration?**\nNot sure, it\u0027s a interop project for `Clarion` with NativeAoT\n- **If you\u0027re using Blazor, which web browser(s) do you see this issue in?**\nNo\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOq6zgxw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6ka750",
                                           "createdAt":  "2025-03-27T15:43:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-03-27T15:43:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ka9qa",
                                           "createdAt":  "2025-03-27T15:45:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-03-27T15:45:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6kbC6g",
                                           "createdAt":  "2025-03-27T15:52:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "@ThaDaVos Thanks for letting us know about this. Can you try marking the `record` as a `record struct` instead? \n\n@jkoritzinsky Could this be an issue with marshalling generic types when `T` is blittable? I thought we had originally blocked marshalling any generic type, but changed that at some point.\n\n\u003e I expected the fields from the base class to be marshalled/filled first, or at least, filled at all\n\nThe interop team no longer advocates for marshalling through class inheritance. It is still an option and something we continue to support, but it is definitely a place where issues still lurk. It is unlikely to be fixed as opposed to blocked since we know there are bugs we can\u0027t easily fix. For the current scenario, removing the `record`, can you construct an example of this scenario that works on .NET Framework? If so, then we would fix it, otherwise we are likely to down the \"block it\" path.",
                                           "updatedAt":  "2025-03-27T15:52:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6kbEJy",
                                           "createdAt":  "2025-03-27T15:54:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "Oh shoot, `record B` can be defined as is if it is a `record struct`. Hmmmm. Yeah I think this is something we should get to the bottom of and then decide the cost to support it if it is new behavior compared to .NET Framework.",
                                           "updatedAt":  "2025-03-27T15:54:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6kbuKs",
                                           "createdAt":  "2025-03-27T16:47:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "Looks like this is the same behavior in both .NET 9 and .NET Framework. I switch from `class` to `record` so the same code would compile on both - see repro below.\n\nI think we should explicitly block the scenario that should not work, which is using inheritance to obscure the failure about the generic type.\n\nOutput\n```\n...\\Repro\u003edotnet run --framework net472\nSystem.ArgumentException: The specified Type must not be a generic type definition.\nParameter name: structureType\n   at System.Runtime.InteropServices.Marshal.PtrToStructure(IntPtr ptr, Type structureType)\n   at System.Runtime.InteropServices.Marshal.PtrToStructure[T](IntPtr ptr)\n   at Program.Main(String[] args) in ...\\Repro\\Program.cs:line 37\nB structure successfully marshaled.\n\n...\\Repro\u003edotnet run --framework net9.0\nSystem.ArgumentException: The specified Type must not be a generic type. (Parameter \u0027T\u0027)\n   at System.Runtime.InteropServices.Marshal.PtrToStructure[T](IntPtr ptr)\n   at Program.Main(String[] args) in ...\\Repro\\Program.cs:line 37\nB structure successfully marshaled.\n```\n\n```xml\n\u003cProject Sdk=\"Microsoft.NET.Sdk\"\u003e\n\n  \u003cPropertyGroup\u003e\n    \u003cOutputType\u003eExe\u003c/OutputType\u003e\n    \u003cTargetFrameworks\u003enet9.0;net472\u003c/TargetFrameworks\u003e\n  \u003c/PropertyGroup\u003e\n\n\u003c/Project\u003e\n```\n\n```csharp\nusing System;\nusing System.Runtime.InteropServices;\n\n[StructLayout(LayoutKind.Sequential, Pack = 1, CharSet = CharSet.Ansi)]\nclass A\u003cT\u003e where T : struct\n{\n    [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n    private string name;\n    public string Name =\u003e name;\n\n    private T value;\n    public T Value =\u003e value;\n}\n\nstruct BValues\n{\n    public int x;\n    public int y;\n    public int z;\n}\n\n[StructLayout(LayoutKind.Sequential, Pack = 1, CharSet = CharSet.Ansi)]\nclass B : A\u003cBValues\u003e\n{\n\n}\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        // Allocate memory for the structure\n        IntPtr mem = Marshal.AllocCoTaskMem(0x1000);\n\n        try\n        {\n            var result = Marshal.PtrToStructure\u003cA\u003cBValues\u003e\u003e(mem);\n            Console.WriteLine(\"A\u003cBValues\u003e structure successfully marshaled.\");\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine(ex);\n        }\n        try\n        {\n            var result = Marshal.PtrToStructure\u003cB\u003e(mem);\n            Console.WriteLine(\"B structure successfully marshaled.\");\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine(ex);\n        }\n\n        // Free the allocated memory\n        Marshal.FreeCoTaskMem(mem);\n    }\n}\n```",
                                           "updatedAt":  "2025-03-27T16:47:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6kb8Tg",
                                           "createdAt":  "2025-03-27T17:00:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ThaDaVos",
                                           "body":  "So it\u0027s the Generic causing the issue? \nIf so, if I remove the generic and just add the field itself to B with the type I would use as Generic, then it should work as expected? \n\nThe reason is, I am - in the actual code - trying to deduplicate code, in this case, I\u0027ve got an Account struct with Parameters per platform which is supported by the library - the parameters are unique per platform, so I want to prevent redeclaring the common fields like Id, Name and Platform each time - I also looked at using something instead of the Parameters struct which allows having keys/values of different kinds, but couldn\u0027t find something which works with P/Invoke and Marshalling - which also exists on the side of `Clarion` (which is pretty limited in regards to types)",
                                           "updatedAt":  "2025-03-27T17:01:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6lhAj2",
                                           "createdAt":  "2025-04-03T20:52:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e So it\u0027s the Generic causing the issue?\n\nYes. Generic types that aren\u0027t blittable aren\u0027t supported for marshalling. This means that inheritance isn\u0027t going to work at all.\n\n\u003e  trying to deduplicate code, in this case\n\nUnderstood. This is a common scenario. We recommend to not try and solve this through the building system, but instead either use a source generation scheme or custom marshalling to handle this scenario.",
                                           "updatedAt":  "2025-04-03T20:52:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6lvw0M",
                                           "createdAt":  "2025-04-05T14:34:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ThaDaVos",
                                           "body":  "\u003e \u003e So it\u0027s the Generic causing the issue?\n\u003e \n\u003e Yes. Generic types that aren\u0027t blittable aren\u0027t supported for marshalling. This means that inheritance isn\u0027t going to work at all.\n\u003e \n\u003e \u003e trying to deduplicate code, in this case\n\u003e \n\u003e Understood. This is a common scenario. We recommend to not try and solve this through the building system, but instead either use a source generation scheme or custom marshalling to handle this scenario.\n\nJust tried with subclassing and yeah, it doesn\u0027t work at all, even without generics (see below actual code) - should Structs with Generic Interfaces work though with the generic constrainted to `struct`? - if not, I think I will need a different way to force a pattern with source generation - could do it without generics perhaps - but using generics helps force the type where needed - in below code I use an empty interface for the `Parameters` instead of a generic, but this will require me to cast from an `Interface` to a specific `struct` - which requires boxing etc I think.\n\nPlatform Specific Account\n```C#\n[StructLayout(LayoutKind.Sequential, Pack = 1, CharSet = CharSet.Ansi)]\npublic record Account : Shared.Data.Account\n{\n    private AccountParameters parameters;\n    public override IAccountParameters Parameters =\u003e parameters;\n\n    public Account() : base(Accounting.Data.Platforms.Snelstart)\n    {\n    }\n}\n```\n\nBase Account\n```C#\n[StructLayout(LayoutKind.Sequential, Pack = 1, CharSet = CharSet.Ansi)]\npublic abstract record Account : IAccount\n{\n    [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 36)]\n    public string? id;\n    public virtual Guid Id\n    {\n        get =\u003e string.IsNullOrEmpty(id) ? Guid.Empty : Guid.ParseExact(id, Constants.GUID_FORMAT.ToString());\n        set =\u003e id = value.ToString(Constants.GUID_FORMAT.ToString()).ToUpperInvariant();\n    }\n    [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n    public string? name;\n    public virtual string Name =\u003e string.IsNullOrEmpty(name) ? string.Empty : name;\n    [MarshalAs(UnmanagedType.I1)]\n    public Accounting.Data.Platforms platform;\n    public virtual Accounting.Data.Platforms Platform =\u003e platform;\n    public abstract IAccountParameters Parameters { get; }\n\n    protected Account(Accounting.Data.Platforms platform)\n    {\n        this.platform = platform;\n    }\n\n    public byte[] SerializeForStorage(Encoding encoding)\n    {\n        byte[] nameBytes = encoding.GetBytes(Name);\n\n        return Id.ToByteArray()\n            .Concat(BitConverter.GetBytes(nameBytes.Length))\n            .Concat(nameBytes)\n            .Concat(BitConverter.GetBytes((int)Platform))\n            .Concat(Parameters.SerializeForStorage(encoding))\n            .ToArray();\n    }\n\n    public void DeserializeFromStorage(byte[] data, Encoding encoding)\n    {\n        int offset = 0;\n\n        Id = new Guid(data[offset..(offset += 16)]);\n        int nameLength = BitConverter.ToInt32(data[offset..(offset += 4)]);\n        name = encoding.GetString(data[offset..(offset += nameLength)]);\n        platform = (Accounting.Data.Platforms)BitConverter.ToInt32(data[offset..(offset += 4)]);\n        Parameters.DeserializeFromStorage(data[offset..], encoding);\n    }\n}\n```\n\nInterface\n```C#\npublic interface IAccount : IPlatformed, ISerializableForStorage\n{\n    Guid Id { get; set; }\n    string Name { get; }\n    IAccountParameters Parameters { get; }\n}\n```",
                                           "updatedAt":  "2025-04-05T14:34:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6rrODH",
                                           "createdAt":  "2025-05-14T13:23:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ThaDaVos",
                                           "body":  "Any ideas @AaronRobinsonMSFT ?\nStill looking for a way to prevent duplication of the common fields but also the serialization logic as much as possible - luckily it\u0027s currently only a single platform so I\u0027ve got time to wait.\nI did add an Abstract record in between the Interface and the implementation - but sadly still need to define the fields again.\n\nI also looked at `IDynamicInterfaceCastable` as I came across this - but don\u0027t think that can help, can it?\n\nAnother thing I tried was, maybe `inheritance` doesn\u0027t work as the layout was set to `sequential` but I am failing to get it working with `explicit` due to not getting the offsets right:\n```shell\nCould not load type \u0027Account\u0027 from assembly \u0027\u0027 because it contains an object field at offset \u0027\u0027 that is incorrectly aligned or overlapped by a non-object field.\n```",
                                           "updatedAt":  "2025-05-14T13:24:05Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "`Marshal.PtrToStructure\u003c\u003e()` Doesn\u0027t work for inherited fields",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/114156",
        "createdAt":  "2025-04-02T15:18:59Z",
        "number":  114156,
        "author":  "ptr727",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-05-22T21:50:38Z",
        "body":  "### Description\n\nPer [docs](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.runtimeinformation.runtimeidentifier?view=net-9.0#system-runtime-interopservices-runtimeinformation-runtimeidentifier) it is expected that `RuntimeInformation.RuntimeIdentifier` returns OS agnostic RID\u0027s.\n\nIn my testing the RID\u0027s returned on some Linux installs includes the OS name, this is not expected, and breaks usage of the reported RID. (I use the RID to [download](https://github.com/dotnet/diagnostics/blob/main/documentation/single-file-tools.md) single file dotnet tools)\n\nNote that the issue may be related to how the SDK/runtime was built and installed, as the behavior on Windows (.NET sourced rom Msft, and Debian (.NET sourced from install script) appear to work, while the SDK/runtime installed using the OS native repository does not produce the correct results.\n\nSummary:\\\nWin11 Msft download : Ok\\\nDebian `https://dot.net/v1/dotnet-install.sh` : Ok\\\nUbuntu [dotnet-runtime-9.0](https://packages.ubuntu.com/oracular/dotnet-runtime-9.0) : Fail\\\nAlpine [dotnet9-runtime](https://pkgs.alpinelinux.org/package/v3.21/community/x86_64/dotnet9-runtime) : Fail\n\n### Reproduction Steps\n\nWindows 11 x64, .NET 9 SDK installed: (Ok)\\\n`dotnet --info` -\u003e `RID:         win-x64`\\\n`Console.WriteLine(RuntimeInformation.RuntimeIdentifier);` -\u003e `win-x64`\n\nAlpine, docker `alpine:latest`, `apk add dotnet9-runtime` (Fail)\\\n`dotnet --info` -\u003e `RID:          alpine.3.21-x64` (expected `linux-musl-x64`)\\\n`Console.WriteLine(RuntimeInformation.RuntimeIdentifier);` -\u003e `alpine.3.21-x64` (expected `linux-musl-x64`)\n\nDebian, docker `debian:stable-slim`, `https://dot.net/v1/dotnet-install.sh` (Ok)\\\n`dotnet --info` -\u003e `RID:          linux-x64`\\\n`Console.WriteLine(RuntimeInformation.RuntimeIdentifier);` -\u003e `linux-x64`\n\nUbuntu, docker `ubuntu:rolling`, `dotnet-runtime-9.0` (Fail)\\\n`dotnet --info` -\u003e `RID:          ubuntu.24.10-x64` (expected `linux-x64`)\\\n`Console.WriteLine(RuntimeInformation.RuntimeIdentifier);` -\u003e `ubuntu.24.10-x64` (expected `linux-x64`)\n\n\n\n### Expected behavior\n\nRID returned in `dotnet --info` and `RuntimeInformation.RuntimeIdentifier` is consistent with documentation.\n\n### Actual behavior\n\nSee reproduction steps, it appears that .NET installed via Linux native repos do not return the correct RID.\n\n### Regression?\n\nI last tested this behavior in .NET v7 and it worked then, but that was a long time ago.\n\n### Known Workarounds\n\nAlways install using Msft helper script, but that is not recommended for production use.\n\n### Configuration\n\n.NET 9.0.3\n\nSee description for install steps on Docker.\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOrP9vPQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6lTDOz",
                                           "createdAt":  "2025-04-02T17:19:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOETQPOw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ptr727",
                                                                               "createdAt":  "2025-05-22T20:03:10Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "pra2892",
                                           "body":  "This issue with **RuntimeInformation.RuntimeIdentifier** returning OS-specific details on Linux when installed from native repositories can be problematic when you need consistent RIDs. \n\nHere\u0027s a possible solution that normalizes the RID to the expected format:\n\n```\nusing System;\nusing System.Runtime.InteropServices;\nusing System.Text.RegularExpressions;\n\nclass Program\n{\n    static void Main()\n    {\n        // Get the raw RID as reported by the runtime\n        string rawRid = RuntimeInformation.RuntimeIdentifier;\n        Console.WriteLine($\"Raw RID: {rawRid}\");\n        \n        // Get the normalized RID\n        string normalizedRid = GetNormalizedRuntimeIdentifier();\n        Console.WriteLine($\"Normalized RID: {normalizedRid}\");\n    }\n    \n    /// \u003csummary\u003e\n    /// Gets a normalized runtime identifier that\u0027s consistent across different installation methods.\n    /// \u003c/summary\u003e\n    public static string GetNormalizedRuntimeIdentifier()\n    {\n        string rid = RuntimeInformation.RuntimeIdentifier;\n        \n        // If already in the expected format, return as is\n        if (rid == \"win-x64\" || rid == \"win-arm64\" || \n            rid == \"linux-x64\" || rid == \"linux-arm64\" || \n            rid == \"linux-musl-x64\" || rid == \"linux-musl-arm64\" ||\n            rid == \"osx-x64\" || rid == \"osx-arm64\")\n        {\n            return rid;\n        }\n        \n        // Handle OS-specific RIDs from native repositories\n        \n        // Extract architecture (should be the part after the last dash)\n        string architecture = \"x64\"; // Default\n        if (rid.Contains(\"-\"))\n        {\n            architecture = rid.Substring(rid.LastIndexOf(\u0027-\u0027) + 1);\n        }\n        \n        // Determine OS and variant\n        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))\n        {\n            return $\"win-{architecture}\";\n        }\n        else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))\n        {\n            // Check if it\u0027s Alpine Linux (musl-based)\n            if (rid.Contains(\"alpine\") || IsAlpineLinux())\n            {\n                return $\"linux-musl-{architecture}\";\n            }\n            return $\"linux-{architecture}\";\n        }\n        else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))\n        {\n            return $\"osx-{architecture}\";\n        }\n        \n        // Fallback to the original RID if we can\u0027t normalize it\n        return rid;\n    }\n    \n    /// \u003csummary\u003e\n    /// Checks if the current Linux distribution is Alpine (musl-based).\n    /// \u003c/summary\u003e\n    private static bool IsAlpineLinux()\n    {\n        try\n        {\n            // Check for /etc/os-release file which contains distribution info\n            if (File.Exists(\"/etc/os-release\"))\n            {\n                string content = File.ReadAllText(\"/etc/os-release\");\n                return content.Contains(\"ID=alpine\") || content.Contains(\"ID=\\\"alpine\\\"\");\n            }\n            \n            // Alternative check for /etc/alpine-release\n            return File.Exists(\"/etc/alpine-release\");\n        }\n        catch\n        {\n            return false;\n        }\n    }\n}\n\n```\n\nThis solution:\n\n1. Creates a `GetNormalizedRuntimeIdentifier()` method that returns a consistent RID format regardless of installation method\n2. Handles the specific cases mentioned in your issue (Windows, standard Linux, and Alpine Linux)\n3. Includes a helper method to detect Alpine Linux specifically, which needs the \"linux-musl-x64\" RID\n\nYou can use this normalized RID for your tool downloads instead of directly using `RuntimeInformation.RuntimeIdentifier`. This should work across all installation methods, including native repository installations.\n\nFor production use, you might want to add more comprehensive detection for other Linux distributions or edge cases, but this covers the main scenarios you described in the issue.\n\nThank You,\n\nPrashant Yadav",
                                           "updatedAt":  "2025-04-16T17:10:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6lTG23",
                                           "createdAt":  "2025-04-02T17:27:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ptr727",
                                           "body":  "\u003e For production use, you might want to add more comprehensive detection for other Linux distributions or edge cases, but this covers the main scenarios you described in the issue.\n\nThank you, this is a temporary workaround, I do believe the repo based installers should report the correct information, and workarounds should not be required.\n\nI\u0027d like to hear from dotnet if this is in fact a repo installer issue, how they interact with maintainers to get it fixed, and maybe add tests to assure correct RID behavior?",
                                           "updatedAt":  "2025-04-02T17:27:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6lUqi9",
                                           "createdAt":  "2025-04-02T20:30:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-04-02T20:30:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6lUuFc",
                                           "createdAt":  "2025-04-02T20:34:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "This is expected. The distro package managers install distro-specific .NET runtime. The distro-specific .NET runtime has RuntimeIdentifier specific to that distro.\n\nWhat are you trying to do? If you just need to check whether you are running on Linux, there is `OperatingSystem.IsLinux()` API for that.\n\ncc @dotnet/distro-maintainers ",
                                           "updatedAt":  "2025-04-02T20:34:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6lVBUx",
                                           "createdAt":  "2025-04-02T21:10:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ptr727",
                                           "body":  "I am trying to get the RID so that I can download the correct [single file test tool](https://github.com/dotnet/diagnostics/blob/main/documentation/single-file-tools.md).\n\nThe method of using `dotnet --info` is [very widely used](https://grep.app/search?q=dotnet%20--info%20%7C%20grep%20) to get the RID. So making the result of `dotnet --info` and `RuntimeInformation.RuntimeIdentifier` non-deterministic is very troublesome, and it is contrary to the [documentation](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.runtimeinformation.runtimeidentifier?view=net-9.0#system-runtime-interopservices-runtimeinformation-runtimeidentifier).\n\nI expect some form of method that returns the RID in a deterministic way, that matches the documentation, regardless of how the runtime was installed.",
                                           "updatedAt":  "2025-04-02T21:10:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ntzzs",
                                           "createdAt":  "2025-04-17T19:07:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "agocke",
                                           "body":  "@elinor-fung Looks like the documentation isn\u0027t quite right. It says that the RID on ubuntu will be linux-x64, but that\u0027s dependent on whether they\u0027re using a portable or non-portable build, right?",
                                           "updatedAt":  "2025-04-17T19:07:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6nukce",
                                           "createdAt":  "2025-04-17T20:53:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "am11",
                                           "body":  "I guess more problematic is the behavior of published apps, which differ from `dotnet run`:\n\n```sh\n$ dotnet run\nubuntu.25.04-arm64\n\n# dotnet publish -p:PublishSingleFile=true -o publish-singlefile\n$ publish-singlefile/app1 \nlinux-arm64\n\n# dotnet publish -p:PublishAot=true -o publish-aot\n$ publish-aot/app1        \nlinux-arm64\n```\n\nAt minimum, we should make it consistently return the same RID, either portable or non-portable. This is informational API for telemetry purposes etc. For other use-cases, OperatingSystem.IsXx APIs are preferred as @jkotas has pointed out. However, that does not cover cases like `linux-musl-{arch}` for which we have to detect libc flavor by shelling out to environment or P/Invoking. Ideally, both pieces of information are useful for non-portable builds: effective RID (for telemetry etc.) and portable RIDs (for native assets / runtime.json https://github.com/NuGet/Home/issues/10571 etc.).",
                                           "updatedAt":  "2025-04-17T20:54:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6nuwao",
                                           "createdAt":  "2025-04-17T21:23:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ptr727",
                                           "body":  "Thank you for continuing to investigate.\n\nI do want to call out that the [.NET diagnostic tooling](https://github.com/dotnet/diagnostics/blob/main/documentation/single-file-tools.md#obtaining-the-tools) expects normalized RID\u0027s, so I\u0027d still prefer some solution where `dotnet --info` (as I mentioned before this is used in `grep` all over github to get the RID) or some other CLI accessible command returns the normalized RID as expected by .NET tooling, or that all .NET tooling support whatever RID is returned from other .NET CLI tools.",
                                           "updatedAt":  "2025-04-17T21:23:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6nvEcc",
                                           "createdAt":  "2025-04-17T22:28:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "elinor-fung",
                                           "body":  "\u003e [@elinor-fung](https://github.com/elinor-fung) Looks like the documentation isn\u0027t quite right. It says that the RID on ubuntu will be linux-x64, but that\u0027s dependent on whether they\u0027re using a portable or non-portable build, right?\n\nIt should probably call that out explicitly. The example is technically correct (version of Ubuntu from when they didn\u0027t produce their own packages), but confusing. Tried to clarify in: https://github.com/dotnet/dotnet-api-docs/pull/11203",
                                           "updatedAt":  "2025-04-17T22:28:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6nvbAk",
                                           "createdAt":  "2025-04-18T00:04:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "\u003e I guess more problematic is the behavior of published apps, which differ from `dotnet run`:\n\u003e \n\u003e $ dotnet run\n\u003e ubuntu.25.04-arm64\n\u003e \n\u003e # dotnet publish -p:PublishSingleFile=true -o publish-singlefile\n\u003e $ publish-singlefile/app1 \n\u003e linux-arm64\n\u003e \n\u003e # dotnet publish -p:PublishAot=true -o publish-aot\n\u003e $ publish-aot/app1        \n\u003e linux-arm64\n\u003e At minimum, we should make it consistently return the same RID, either portable or non-portable. This is informational API for telemetry purposes etc. For other use-cases, OperatingSystem.IsXx APIs are preferred as [@jkotas](https://github.com/jkotas) has pointed out. However, that does not cover cases like `linux-musl-{arch}` for which we have to detect libc flavor by shelling out to environment or P/Invoking. Ideally, both pieces of information are useful for non-portable builds: effective RID (for telemetry etc.) and portable RIDs (for native assets / runtime.json [NuGet/Home#10571](https://github.com/NuGet/Home/issues/10571) etc.).\n\nI think this is actually a different case: The SDK specifically uses a portable RID as the default RID when you publish, even if you\u0027re on a non-portable SD (see the behavior of `UseCurrentRuntimeIdentifier`). So using `dotnet run` uses the current SDK, whereas `PublishSingleFile` will use the corresponding `singlefilehost` for the portable RID. So you are actually getting a different host.\n\nThis behavior is a reasonable default IMO because otherwise the default publish experience would mean that a project built on a SourceBuild-based SDK (like RHEL) would publish non-portable, whereas building on a Microsoft-build would publish portable.",
                                           "updatedAt":  "2025-04-18T00:04:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6nv08U",
                                           "createdAt":  "2025-04-18T01:50:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "am11",
                                           "body":  "\u003e I think this is actually a different case: The SDK specifically uses a portable RID as the default RID when you publish, even if you\u0027re on a non-portable SD (see the behavior of UseCurrentRuntimeIdentifier). So using dotnet run uses the current SDK, whereas PublishSingleFile will use the corresponding singlefilehost for the portable RID. So you are actually getting a different host.\n\nYes I saw the behavior, rather wrote it myself https://github.com/dotnet/sdk/commit/347f78f654ba9bd4271db007929e3d3e5aa6179f and it was equally messy back then.\n\nDo we want `RuntimeInformation.RuntimeIdentifier` API to change the value based on `--runtime` and `-p:UseRidGraph` etc. or do we want this API to report consistent result? The current behavior is not very intuitive from UX perspective and docs are still not capturing what contributes to its output. The output seems to be leaking build-time concerns; how SDK and hosts were built, and publish options used.",
                                           "updatedAt":  "2025-04-18T01:50:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6nw0Ag",
                                           "createdAt":  "2025-04-18T05:40:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEPzRrw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ptr727",
                                                                               "createdAt":  "2025-04-18T18:02:33Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "makazeu",
                                                                               "createdAt":  "2025-04-27T03:43:33Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "tmds",
                                           "body":  "I don\u0027t think we should be changing the value of `RuntimeInformation.RuntimeIdentifier` as we still like a way to return the non-portable rid.\n\nPerhaps an additional property, like `RuntimeInformation.PortableRuntimeIdentifier` can be considered.\n\nIf you are doing something on the SDK side, there is the `NETCoreSdkPortableRuntimeIdentifier` MSBuild property.\n\nThe broader use-case is to find a best match among a set of target rids. e.g. I have installers for `linux-x64` and `osx-x64`, what is the best match on my `fedora.41-x64`.",
                                           "updatedAt":  "2025-04-18T05:40:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6nym3m",
                                           "createdAt":  "2025-04-18T09:24:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "am11",
                                           "body":  "\u003e I don\u0027t think we should be changing the value of RuntimeInformation.RuntimeIdentifier as we still like a way to return the non-portable rid.\n\n`RuntimeInformation.RuntimeIdentifier` is changing the value today based on multiple factors, as seen above. Do you mean current behavior is correct or that it shouldn\u0027t be changing the values on those factors?\n\nIn addition to how user has installed the SDK (from MSFT or the distro), these are some differences:\n```sh\n$ apt install -y dotnet-sdk-9.0\n$ dotnet new console -n app1 \u0026\u0026 cd app1\n$ cat \u003eProgram.cs\u003c\u003cEOF\nusing System.Runtime.InteropServices;\nConsole.WriteLine(RuntimeInformation.RuntimeIdentifier);\nEOF\n\n$ dotnet run\nubuntu.25.04-arm64\n\n$ dotnet publish --self-contained -o out \u0026\u0026 out/app1\nlinux-arm64\n\n$ dotnet publish --self-contained -o out --ucr \u0026\u0026 out/app1\nubuntu.25.04-arm64\n\n$ dotnet publish --self-contained -r ubuntu.25.04-arm64 -p:UseRidGraph=true -o out \u0026\u0026 out/app1\nubuntu.25.04-arm64\n\n$ dotnet publish --self-contained -r ubuntu.22.04-arm64 -p:UseRidGraph=true -o out \u0026\u0026 out/app1\nlinux-arm64\n\n$ dotnet publish --self-contained -r fedora.39-arm64 -p:UseRidGraph=true -o out \u0026\u0026 out/app1\nlinux-arm64\n```\n\nBy reading the remarks section in docs as an API consumer, these output should be explainable without needing to learn the internal infrastructure details of dotnet org.",
                                           "updatedAt":  "2025-05-22T21:50:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6nyscn",
                                           "createdAt":  "2025-04-18T09:37:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e RuntimeInformation.RuntimeIdentifier is changing the value today based on multiple factor\n\nIn all cases it should be returning the rid the native assets are compatible with (that is: the vmr build `TargetRid` property).\n\n`fedora.41-x64` assets are not compatible to run on all `linux-x64`.",
                                           "updatedAt":  "2025-04-18T09:37:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6sz02m",
                                           "createdAt":  "2025-05-21T21:15:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "agocke",
                                           "body":  "Closing as resolved by https://github.com/dotnet/dotnet-api-docs/pull/11203",
                                           "updatedAt":  "2025-05-21T21:15:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6s0bbZ",
                                           "createdAt":  "2025-05-21T22:38:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ptr727",
                                           "body":  "Is it the position then that the runtime will not be providing an agnostic identifier and users have to roll their own?",
                                           "updatedAt":  "2025-05-21T22:38:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6s16-l",
                                           "createdAt":  "2025-05-22T03:48:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "agocke",
                                           "body":  "Good point -- I don\u0027t think I\u0027m ruling it out forever, but this is not something likely to happen soon. It looks like most of the pieces are available in `RuntimeInformation.IsOSPlatform` and similar. It might not map precisely, but it\u0027s likely close for most users. Before adding yet another version of OS info, I would want to see broad demand.",
                                           "updatedAt":  "2025-05-22T03:48:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6s17OL",
                                           "createdAt":  "2025-05-22T03:49:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-05-22T03:49:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6s2LyD",
                                           "createdAt":  "2025-05-22T04:44:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e It looks like most of the pieces are available in RuntimeInformation.IsOSPlatform and similar. It might not map precisely, but it\u0027s likely close for most users.\n\nWhat you can\u0027t find out with the existing APIs is whether the system is `linux` or `linux-musl`.\n\nThis request is outside the usual use-cases for RIDs: we have the SDK which has the notion of a larger RID graph, and the host which knows the rids it is compatible with.\n\nWhile this request is for the user to know what portable rid the host is compatible with.\n\nSomething like `RuntimeInformation.PortableRuntimeIdentifier` is a direct way to provide that information.\n\nAn API to to query the compatible rids for the best one (like what we do in the SDK) could also be useful, something like:\n\n```\nstatic string? RuntimeInformation.FindBestRuntimeIdentifier(string[] availableRIDs);\n```",
                                           "updatedAt":  "2025-05-22T14:04:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6s_289",
                                           "createdAt":  "2025-05-22T20:05:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ptr727",
                                           "body":  "I\u0027m using code based the [snippet](https://github.com/dotnet/runtime/issues/114156#issuecomment-2773234611) suggested by @pra2892, it works, but this should in my humble opinion be part of the runtime.",
                                           "updatedAt":  "2025-05-22T20:05:40Z"
                                       }
                                   ],
                         "totalCount":  20
                     },
        "title":  "[.NET 9] `RuntimeInformation.RuntimeIdentifier` includes unexpected OS details on Linux repo installs",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/114708",
        "createdAt":  "2025-04-15T19:27:24Z",
        "number":  114708,
        "author":  "Xtarii",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-05T20:56:47Z",
        "body":  "### Background and motivation\n\nEvery native method needs to define a **LibraryImport** Attribute.\n```csharp\n[LibraryImport(\"foo.dll\")]\nprivate static partial void Foo();\n\n[LibraryImport(\"foo.dll\")]\nprivate static partial void Boo();\n```\n\nIt would be faster if the native methods could inherit import settings from the parenting class.\nThis way only the class needs to define the DLL import settings once and native methods can simply inherit and override the class settings when needed.\n\n### API Proposal\n\n```csharp\n[LibraryImport(\"foo.dll\")]\npublic partial class MyFancyWrapper\n{\n    // Inherits DLL import from parent\n    private static partial void Boo();\n}\n```\n\n\n### API Usage\n\n```csharp\n[LibraryImport(\"foo.dll\", CallingConvention = CallingConvention.Cdecl)]\npublic partial class FooClass\n{\n     // Inhertis\n     private static partial void Foo();\n\n\n     // Overrides Settings\n     [ApplyDllSettings(CallingConvention = CallingConvention.FastCall)]\n     private static partial void Boo();\n\n\n     // Overrides Import\n     [LibraryImport(\"other.dll\")]\n     private static partial void Other();\n}\n```\n\n\n### Alternative Designs\n\nThis would update the already existing **LibraryImport** Attribute to allow methods to inherit import data from parent class.\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOp1R-sg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6nU-8P",
                                           "createdAt":  "2025-04-15T19:40:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "@Xtarii This is an interesting idea, but it is not something we are inclined to add for the `DllImportAttribute`. The `DllImportAttribute` is a pseudo-attribute and doesn\u0027t really exist in metadata, therefore trying to influence it through a real attribute isn\u0027t a path for success. Any proposal for improving workflow in this domain should focus on the `LibraryImportAttribute`, which is a real attribute and something we can improve.\n\nFeel free to update this issue or open a new one. Thanks.",
                                           "updatedAt":  "2025-04-15T19:40:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6nVH6y",
                                           "createdAt":  "2025-04-15T19:54:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Xtarii",
                                           "body":  "I updated from **DllImport** to **LibraryImport**",
                                           "updatedAt":  "2025-04-15T19:54:54Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[API Proposal]: Inherit LibraryImport from class to reduce rewriting code",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/114733",
        "createdAt":  "2025-04-16T10:31:08Z",
        "number":  114733,
        "author":  "HolographicHat",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-04-24T14:34:05Z",
        "body":  "### Background and motivation\n\nSome funcs are only used for native interop with static libraries and we don\u0027t want them exported, so we need a new field to UnmanagedCallersOnlyAttribute to control whether the method is exported.\n\n### API Proposal\n\n```diff\n    [System.AttributeUsageAttribute(System.AttributeTargets.Method, Inherited = false)]\n    public sealed class UnmanagedCallersOnlyAttribute : System.Attribute\n    {\n         public UnmanagedCallersOnlyAttribute() { }\n         public System.Type[]? CallConvs;\n         public string? EntryPoint;\n+        public bool Export = true;\n     }\n```\n\n### API Usage\n\n```csharp\n[UnmanagedCallersOnly(EntryPoint = \"InternalSum\", Export = false)]\npublic static int InternalSum(int a, int b) =\u003e a + b;\n```\n```c++\nextern \"C\" int InternalSum(int a, int b);\n\nextern \"C\" __declspec(dllexport) capi_get_number() {\n    return InternalSum(114, 514);\n}\n```\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOqI3yOg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6neUHn",
                                           "createdAt":  "2025-04-16T14:17:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "The function still needs to be exported from NativeAOT compiler, otherwise the linker can\u0027t link it with the import in C++.\n\nThe exporting instruction should be passed to the native linker, not NativeAOT compiler. See https://learn.microsoft.com/dotnet/core/deploying/native-aot/interop#linking .",
                                           "updatedAt":  "2025-04-16T14:17:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6nfcDH",
                                           "createdAt":  "2025-04-16T16:00:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "HolographicHat",
                                           "body":  "\u003e The function still needs to be exported from NativeAOT compiler, otherwise the linker can\u0027t link it with the import in C++.\n\u003e \n\u003e The exporting instruction should be passed to the native linker, not NativeAOT compiler. See [learn.microsoft.com/dotnet/core/deploying/native-aot/interop#linking](https://learn.microsoft.com/dotnet/core/deploying/native-aot/interop#linking) .\n\nStrictly speaking, the purpose of this proposal is to assign a symbol name while preventing its export in the linker output.\n\n```c++\n// main.cpp, compiled into native.lib\nextern \"C\" int InternalSum(int a, int b);\n\nextern \"C\" int GetNumberImpl() {\n    return InternalSum(114, 514);\n}\n```\n```csharp\n// Class1.cs\nusing System.Runtime.InteropServices;\n\npublic static partial class Class1 {\n\n    [UnmanagedCallersOnly(EntryPoint = \"InternalSum\", Export = false)]\n    public static int Sum(int a, int b) =\u003e a + b;\n\n    [LibraryImport(\"native\")]\n    private static partial int GetNumberImpl();\n\n    [UnmanagedCallersOnly(EntryPoint = \"ExportedGetNumber\")]\n    public static int GetNumber() =\u003e GetNumberImpl();\n\n}\n```\n```xml\n\u003cProject Sdk=\"Microsoft.NET.Sdk\"\u003e\n    \u003c!-- ~ ~ --\u003e\n    \u003cPropertyGroup\u003e\n        \u003cPublishAot\u003etrue\u003c/PublishAot\u003e\n    \u003c/PropertyGroup\u003e\n    \u003cItemGroup\u003e\n        \u003cDirectPInvoke Include=\"native\"/\u003e\n        \u003cNativeLibrary Include=\"native.lib\"/\u003e\n    \u003c/ItemGroup\u003e\n\u003c/Project\u003e\n```\nResult:\n![Image](https://github.com/user-attachments/assets/f42f9000-8c89-4267-9f3e-75f078966440)\n\nRef:\nhttps://github.com/HolographicHat/runtime/commit/e7b1476d9db84869bd352d8305db69c97ea3f28e",
                                           "updatedAt":  "2025-04-16T16:07:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6nfmgE",
                                           "createdAt":  "2025-04-16T16:16:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "\u003e assign a symbol name while preventing its export in the linker output\n\nThere are two separate steps. .NET attribute can only control the output `.obj` file of ilc. The symbol must be present in order to link with `native.lib`.\n\nThe output of native linker is not controllable from .NET. You need to use linker-native way (.DEF file) to specify it.",
                                           "updatedAt":  "2025-04-16T16:16:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6nfoV-",
                                           "createdAt":  "2025-04-16T16:20:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "HolographicHat",
                                           "body":  "\u003e \u003e assign a symbol name while preventing its export in the linker output\n\u003e \n\u003e There are two separate steps. .NET attribute can only control the output `.obj` file of ilc. The symbol must be present in order to link with `native.lib`.\n\u003e \n\u003e The output of native linker is not controllable from .NET. You need to use linker-native way (.DEF file) to specify it.\n\nhttps://github.com/HolographicHat/runtime/commit/e7b1476d9db84869bd352d8305db69c97ea3f28e#diff-cbfc0b2a712d55d27b39efb1ee0625e78f2c5ba58fcc9a5f6351241c44134d84R80\n\n![Image](https://github.com/user-attachments/assets/ce668935-0f64-4308-98fc-53557094794e)\n\nhttps://github.com/HolographicHat/runtime/commit/e7b1476d9db84869bd352d8305db69c97ea3f28e#diff-2d87bd33cc36a7cbe4cc52708e0212f778f3b9b4c3d51890fee89b283c52e86bR29\n\n![Image](https://github.com/user-attachments/assets/25413254-6179-40e7-9b85-ceb80d9ccce4)",
                                           "updatedAt":  "2025-04-24T10:24:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ngGmW",
                                           "createdAt":  "2025-04-16T17:13:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "Well I was incorrect. ILC does write the DEF file based on exports.",
                                           "updatedAt":  "2025-04-16T17:13:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ngtoO",
                                           "createdAt":  "2025-04-16T18:21:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "You can supply your own exports file (DEF file on Windows) if you want to have fine grained control over what gets exported or if you need to use other advanced exports file features.\n \nIf we wanted something built-in, we have been exposing this sort of functionality via project file properties, similar to DirectPInvoke/DirectPInvokeList or UnmanagedEntryPointsAssembly exist today.",
                                           "updatedAt":  "2025-04-16T18:21:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6nhaYC",
                                           "createdAt":  "2025-04-16T19:27:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "HolographicHat",
                                           "body":  "\u003e You can supply your own exports file (DEF file on Windows) if you want to have fine grained control over what gets exported or if you need to use other advanced exports file features.   If we wanted something built-in, we have been exposing this sort of functionality via project file properties, similar to DirectPInvoke/DirectPInvokeList or UnmanagedEntryPointsAssembly exist today.\n\n\u003e the purpose of this proposal is to **assign a symbol name** while **preventing its export** in the linker output.`\n\nIf you don\u0027t use UnmanagedCallersOnly to specify the symbol name, you cannot export the symbol via a DEF file, as the function name not included in the obj file.\nIf you use UnmanagedCallersOnly to specify the symbol name, the symbol will be **automatically** write to $(TargetName).def and exported.\n\nThis is unrelated to DirectPInvoke/DirectPInvokeList/UnmanagedEntryPointsAssembly\n\nI know how to remove it before linking just provide a simplify way to do it.\n\nI have implemented a solution for this. May I create a pull request?",
                                           "updatedAt":  "2025-04-16T19:27:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6nlkqB",
                                           "createdAt":  "2025-04-17T03:29:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEOquaQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "HolographicHat",
                                                                               "createdAt":  "2025-04-17T05:03:06Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "\u003e I have implemented a solution for this. May I create a pull request?\n\nNo. This involves public API and must go through the [API review process](https://github.com/dotnet/runtime/blob/main/docs/project/api-review-process.md). Pull request can only be accepted after it\u0027s approved.\n\nThat\u0027s also the reason why workarounding with existing feature is recommended, because is available immediately.",
                                           "updatedAt":  "2025-04-17T03:29:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6nltAZ",
                                           "createdAt":  "2025-04-17T04:04:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e I know how to remove it before linking just provide a simplify way to do it.\n\nA few simple options:\n\n- You can set `ExportsFile` property to point to your own .DEF file\nor\n- You can set (undocumented) `IlcExportUnmanagedEntrypoints` property to false. It will omit all unmanaged entrypoints from the .DEF file ",
                                           "updatedAt":  "2025-04-17T04:04:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6nnCiY",
                                           "createdAt":  "2025-04-17T07:22:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "HolographicHat",
                                           "body":  "\u003e You can set `ExportsFile` property to point to your own .DEF file\n\nilc will override it\n\n\u003e A few simple options:\n\u003e     * You can set (undocumented) `IlcExportUnmanagedEntrypoints` property to false. It will omit all unmanaged entrypoints from the .DEF file\n\nfor developers, omitting `__declspec(dllexport)` in Cxx achieves the desired behavior, whereas in C# it requires relying on undocumented property and manually managing export lists — it\u0027s really \\*simple\\*?\n",
                                           "updatedAt":  "2025-04-17T07:22:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6n5v4D",
                                           "createdAt":  "2025-04-20T01:13:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e for developers, omitting __declspec(dllexport) in Cxx achieves the desired behavior, whereas in C# it requires relying on undocumented property and manually managing export lists — it\u0027s really *simple*?\n\nIt is neither simple nor cheap when viewed in totality. It involves documentation, tests, new APIs, interaction matrices that need consideration, and of course perpetual ownership.\n\nThe calculus for this is going to come down to how many others need this feature and is there another way to achieve it. These relate to one another. If this feature will handle a scenario hit by many, then that may outweight the costs defined above. However, if there are few impacted people and there already exists a way to acheive the solution, it is unlikely to outweight the costs.\n\nI\u0027ll place this in Future for now and see if there is more interest. If not, we\u0027ll likely close this at a future date.",
                                           "updatedAt":  "2025-04-20T01:13:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ogyDj",
                                           "createdAt":  "2025-04-24T10:44:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "HolographicHat",
                                           "body":  "could we implement this by adding a step in the ILCompiler (similar to [dotnet/runtime#110152](https://github.com/dotnet/runtime/pull/110152)) to suppress symbol export when EntryPoint ends with `,HIDDEN` to prevent api changes?\n",
                                           "updatedAt":  "2025-04-24T10:44:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ojfI6",
                                           "createdAt":  "2025-04-24T14:34:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e EntryPoint ends with ,HIDDEN to prevent api changes?\n\nWe avoid these sorts of [DSL](https://wikipedia.org/wiki/Domain-specific_language) solutions. They are fragile and in the long term tend to be more difficult to document/test/enforce than creating APIs. It is another approach to discuss if we see enough community interest.",
                                           "updatedAt":  "2025-04-24T14:34:03Z"
                                       }
                                   ],
                         "totalCount":  13
                     },
        "title":  "[API Proposal]: Optional export of UnmanagedCallersOnlyAttribute",
        "labels":  [
                       "api-suggestion",
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/115205",
        "createdAt":  "2025-04-30T19:33:56Z",
        "number":  115205,
        "author":  "max-charlamb",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-04-30T19:54:33Z",
        "body":  "Currently `GeneratedComInterface` supports passing COM interfaces as method arguments using `[in]` and `[out]` tags but does not support optional COM interface arguments.\n\nUsing the the following IDL definition (found in xclrdata.idl) as an example, \n```\nHRESULT GetTokenAndScope([out] mdMethodDef* token, [out] IXCLRDataModule **mod);\n```\nthis could normally be marshalled using a generated interface with a method signature like\n```csharp\n[PreserveSig]\nint GetTokenAndScope(out uint token, out IXCLRDataModule? mod);\n```\nthe marshaller will take automatically convert the interface into the native pointer.\n\nHowever, this method supports passing `mod` as a `nullptr`. In this case no COM interface should be marshalled back to the caller. This pattern is not currently supported and requires falling back to manually marshalling the interface.\n\nRelated to #66674 ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOqXZ-dA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6pdenR",
                                           "createdAt":  "2025-04-30T19:34:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-04-30T19:34:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6pdn50",
                                           "createdAt":  "2025-04-30T19:51:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEQWhtw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "max-charlamb",
                                                                               "createdAt":  "2025-04-30T19:53:23Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "\u003e this could normally be marshalled using a generated interface with a method signature like\n\nNit: The function should be defined as\n\n```csharp\n[PreserveSig]\nint GetTokenAndScope(out uint token, out IXCLRDataModule? mod);\n``` ",
                                           "updatedAt":  "2025-04-30T19:54:32Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Support for marshalling optional parameters in `[GeneratedComInterface]` interfaces",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "source-generator"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/115608",
        "createdAt":  "2025-05-15T12:48:36Z",
        "number":  115608,
        "author":  "just-ero",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-05-17T10:46:43Z",
        "body":  "### Description\n\nThe `LibraryImport` generator uses `byte* __retVal_native` as the name for the local return value buffer variable. It uses `byte* __parameterName_native` as the name for the local input buffer variable. If the parameter is named `retVal`, this results in two locals named `__retVal_native`.\n\nThis can potentially be solved by simply using `__retVal_native` for the return value local variable and `__p_retVal_native` for parameter local variables.\n\n\n### Reproduction Steps\n\n```cs\npartial class C\n{\n    [LibraryImport(\"_\", StringMarshalling = StringMarshalling.Utf8)]\n    private static partial string M(string retVal);\n}\n```\n\n### Expected behavior\n\nThe generator does not use the same local variable names for both parameters and return values.\n\n\n### Actual behavior\n\nIt does.\n\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nDon\u0027t name the parameter `retVal`.\n\n\n### Configuration\n\n`10.0.100-preview.4.25258.110`\n\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOrCfKqw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6r4lGF",
                                           "createdAt":  "2025-05-15T13:01:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-05-15T13:01:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6r4rzx",
                                           "createdAt":  "2025-05-15T13:11:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "just-ero",
                                           "body":  "You know, I think this is pretty much unactionable. The same happens when you name the parameter `__invokeSucceeded`, or `__retVal` or `__retVal_native`, etc., etc., etc.",
                                           "updatedAt":  "2025-05-15T13:11:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6sGtD4",
                                           "createdAt":  "2025-05-16T18:41:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "@just-ero @jkoritzinsky and I have discussed making names more opaque, but this creates readability issues. I think for now our guidance is to avoid these names. I\u0027ll move this to future in case we discover this is a blocker.",
                                           "updatedAt":  "2025-05-16T18:41:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6sGui6",
                                           "createdAt":  "2025-05-16T18:45:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "\u003e [@just-ero](https://github.com/just-ero) [@jkoritzinsky](https://github.com/jkoritzinsky) and I have discussed making names more opaque, but this creates readability issues. I think for now our guidance is to avoid these names. I\u0027ll move this to future in case we discover this is a blocker.\n\nCould the generator just add `__` in front of the names it generates?",
                                           "updatedAt":  "2025-05-16T18:45:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6sGvIt",
                                           "createdAt":  "2025-05-16T18:46:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-05-16T18:46:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6sIUVi",
                                           "createdAt":  "2025-05-16T23:57:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEScOPA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2025-05-17T00:55:34Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "It was suggested on discord you could use the name `@return` or similar, as it\u0027s less likely someone is using a keyword.\n\nYou might also be able to doing something like `retVal__` for the return value but `__retVal` for the parameter. Wouldn\u0027t be the most readable but at least it avoids the conflict in most scenarios.\n\nI don\u0027t think guaranteeing uniqueness should be a goal here. Just something minimal to avoid the conflict between what\u0027s generated for the return value and what\u0027s generated for the parameter values should be sufficient.",
                                           "updatedAt":  "2025-05-16T23:57:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6sJqMf",
                                           "createdAt":  "2025-05-17T08:11:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "just-ero",
                                           "body":  "Even that breaks when the user names the parameter `retVal__` (because then you have a parameter named `retVal__`, and a local variable named `retVal__`). Like I said, this is almost certainly unsolvable and should probably be on the user to not mess up.",
                                           "updatedAt":  "2025-05-17T08:11:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6sJ8qr",
                                           "createdAt":  "2025-05-17T10:46:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEShK6Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "just-ero",
                                                                               "createdAt":  "2025-05-18T09:29:26Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "I explicitly stated that I don’t think guaranteeing uniqueness should be a goal. Rather simply trying to avoid conflicts for common names\n\nNaming something retVal__ is incredibly unlikely for real world interop code. Naming something retVal on the other hand can be decently common in some interop libraries and so the risk of conflict if you’re trying to match native increases",
                                           "updatedAt":  "2025-05-17T10:46:42Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "[LibraryImport] Naming `string` parameter `retVal` in import with `string` return value results in `CS0128`",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/117041",
        "createdAt":  "2025-06-26T07:58:12Z",
        "number":  117041,
        "author":  "m-celikba",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-06-26T16:11:51Z",
        "body":  "### Description\n\nConsider this example:\n\n```csharp\n[GeneratedComInterface, Guid(..)]\ninterface IComItf\n{\n    ...\n}\n\n[GeneratedComClass, Guid(..)]\nclass ManagedComItf : IComItf\n{\n    ...\n}\n```\n\nthen:\n\n```csharp\nIComItf instNative = CreateNativeImplementation();\nIComItf instManaged = new ManagedComItf();\n\nvar v1 = ComVariantMarshaller.ConvertToUnmanaged(instManaged); // works\nvar v2 = ComVariantMarshaller.ConvertToUnmanaged(instNative); // \u003c--------------- does not work\n```\n\nbecause of this passing a com interface to a com method as object fails when the method has this signature:\n`void Method([MarshalUsing(typeof(ComVariantMarshaller))] object obj);`\n\nAdditionally these are missing:\n```csharp\nvar v3 = ComVariant.Create(instNative);\nvar instManaged2 = v1.As\u003cIComItf\u003e();\n```\n\nPS:\nthis works but does not help:\n`var v4 = ComVariantMarshaller.ConvertToUnmanaged(new UnknownWrapper(instNative)); // works`\n\n### Reproduction Steps\n\nsee description\n\n### Expected behavior\n\nComVariantMarshaller should be able to work directly with COM interfaces\n\n### Actual behavior\n\nComVariantMarshallers cannot be created from COM interfaces\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n.NET9\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOs0O8mw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6zQ7yb",
                                           "createdAt":  "2025-06-26T07:58:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-06-26T07:58:53Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "ComVariantMarshaller and ComVariant does not work well with Com interfaces",
        "labels":  [
                       "area-System.Runtime.InteropServices"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/117448",
        "createdAt":  "2025-07-08T23:22:14Z",
        "number":  117448,
        "author":  "jtschuster",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODGX7Yw==",
                          "nodes":  [
                                        {
                                            "content":  "EYES",
                                            "user":  "Copilot",
                                            "createdAt":  "2025-07-09T17:07:33Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-07-09T17:07:30Z",
        "body":  "The test case in https://github.com/dotnet/runtime/pull/117447 crashes the LibraryImportGenerator with a NullRef.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOtdPbZw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6109tn",
                                           "createdAt":  "2025-07-08T23:22:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-07-08T23:22:47Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "LibraryImportGenerator crashes when a malformed CollectionMarshaller and ElementMarshaller are used",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "source-generator"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/119084",
        "createdAt":  "2025-08-26T08:49:57Z",
        "number":  119084,
        "author":  "Sergio0694",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-02T08:30:53Z",
        "body":  "\u003e [!NOTE]\n\u003e Follow up from @sbomer\u0027s comment: https://github.com/dotnet/runtime/issues/110691#issuecomment-2679701987.\n\u003e Related to: #114179.\n\nOpening this issue to close the loop on the `[RequiresUnreferencedCode]` behavior for the type map attributes. We\u0027ve started the work in CsWinRT 3.0 and this is currently blocking our CI (https://github.com/microsoft/CsWinRT/pull/2034). We\u0027d like to avoid suppressing the warnings for the whole project (also because that wouldn\u0027t apply to ILC builds anyway). My understanding is that the plan was to have the analyzer/linker/ILC automatically special-case and suppress these specific warnings, but that\u0027s not implemented yet as of .NET 10 RC1. Just wanted to make sure this is still on the radar, as we\u0027ll be relying on this for CsWinRT 3.0, and currently trying to build the new `WinRT.Runtime.dll` projct produces dozens of IL2026-s 😅\n\n@sbomer what would be your preference here?\nShould this auto-suppression be added?\nShould we just remove `[RUC]` from the attributes?\nThank you!\n\ncc. @MichalStrehovsky @jkoritzinsky",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOwWC_XQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc7AHpYB",
                                           "createdAt":  "2025-08-26T08:50:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-08-26T08:50:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7AH7Pv",
                                           "createdAt":  "2025-08-26T09:10:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "Could we do the simplest thing and just drop the RUC from the attribute?\n\nI think if we add a strict mode in the future, we would need to special case the attribute either way. Maybe we could add the RUC then? (It would still not warn in the non-strict mode so no breaking change in theory)",
                                           "updatedAt":  "2025-08-26T09:10:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7ANUV1",
                                           "createdAt":  "2025-08-26T15:39:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "The expectation is that the analyzer emits the warning (which can be suppressed with a pragma) and the trimmer and NAOT don\u0027t emit a warning at all. Are you seeing the trimmer or NAOT emitting the warning?",
                                           "updatedAt":  "2025-08-26T15:39:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7ANXaS",
                                           "createdAt":  "2025-08-26T15:42:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Sergio0694",
                                           "body":  "Haven\u0027t tested that yet, but I can do that later today. Though just to be clear, my understanding is that the analyzer shouldn\u0027t have warned either, otherwise you\u0027d need to manually suppress it every single time like you mentioned. Which is also not ideal because I feel like it\u0027d push people to just suppress in the whole file or in the project to reduce friction, and that\u0027ll end up hiding actual issues as a side effect. It\u0027d be nicer to just have this not warn at all, since for practical purpose it is in fact safe 😅",
                                           "updatedAt":  "2025-08-26T15:42:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7BFzbe",
                                           "createdAt":  "2025-08-30T20:23:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Sergio0694",
                                           "body":  "I can confirm that ILC doesn\u0027t warn, only the analyzer does. Not a blocker but it\u0027s quite annoying and seems very weird. Like, we\u0027ve always said that the analyzer can\u0027t ever be 100% accurate, and that ILC is always the source of truth for what\u0027s correct and what isn\u0027t. This is also the official advice we\u0027ve always given to folks. And ILC doesn\u0027t warn here. So the analyzer warning just seems like a bug, according to our very own guidance. It also just seems pointless.\n\nAlso the analyzer is warning twice, for some reason:\n\n\u003cimg width=\"1720\" height=\"378\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/6d3015d8-401d-4b35-8057-8f7eb9aed649\" /\u003e",
                                           "updatedAt":  "2025-08-30T20:23:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7BWH-3",
                                           "createdAt":  "2025-09-02T05:12:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "\u003e I can confirm that ILC doesn\u0027t warn, only the analyzer does. Not a blocker but it\u0027s quite annoying and seems very weird.\n\nDoes `#pragma warning disable XYZ` disable both warnings? If it doesn\u0027t, it would be a problem. If it does, it\u0027s probably fine for .NET 10.",
                                           "updatedAt":  "2025-09-02T05:12:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7BYL9d",
                                           "createdAt":  "2025-09-02T08:30:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Sergio0694",
                                           "body":  "Yeah that does the trick. I guess we\u0027ll just keep using the `#pragma` suppressions for now then 🥲",
                                           "updatedAt":  "2025-09-02T08:30:53Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "Missing auto-suppressions for type map attributes (IL2026)",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "untriaged",
                       "partner-impact"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/119183",
        "createdAt":  "2025-08-28T17:37:31Z",
        "number":  119183,
        "author":  "jtschuster",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODOQ9og==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AaronRobinsonMSFT",
                                            "createdAt":  "2025-08-28T18:18:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "RenderMichael",
                                            "createdAt":  "2025-08-30T12:36:52Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "KirillOsenkov",
                                            "createdAt":  "2025-09-03T22:00:52Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2025-09-04T19:13:27Z",
        "body":  "ComInterfaceGenerator.Initialize does more work than necessary setting up incremental steps and calculating some information before any GeneratedComInterfaceAttributes are found. We should move some of this processing to within the pipeline, only once we\u0027ve found a GeneratedComInterfaceAttribute. We also should think about what level of granularity we need for each incremental step. There is some overhead to each incremental `Select`, and we make liberal use of it with small operations.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOwMi5VA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc7AyLlU",
                                           "createdAt":  "2025-08-28T17:38:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/interop-contrib\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-08-28T17:38:27Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "ComInterfaceGenerator.Initialize taking too much time for projects with no GeneratedComInterfaces",
        "labels":  [
                       "area-System.Runtime.InteropServices",
                       "source-generator"
                   ]
    }
]
